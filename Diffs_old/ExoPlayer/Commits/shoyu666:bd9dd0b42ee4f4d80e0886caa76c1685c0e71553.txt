diff --git a/ISSUE_TEMPLATE b/.github/ISSUE_TEMPLATE/bug.md
similarity index 50%
rename from ISSUE_TEMPLATE
rename to .github/ISSUE_TEMPLATE/bug.md
index 8d2f66093d..690069ffa8 100644
--- a/ISSUE_TEMPLATE
+++ b/.github/ISSUE_TEMPLATE/bug.md
@@ -1,13 +1,20 @@
-Before filing an issue:
+---
+name: Bug report
+about: Issue template for a bug report.
+title: ''
+labels: bug, needs triage
+assignees: ''
+---
+
+Before filing a bug:
 -----------------------
 - Search existing issues, including issues that are closed.
 - Consult our FAQs, supported devices and supported formats pages. These can be
-  found at https://google.github.io/ExoPlayer/.
+  found at https://exoplayer.dev/.
 - Rule out issues in your own code. A good way to do this is to try and
-  reproduce the issue in the ExoPlayer demo app.
-- This issue tracker is intended for bugs, feature requests and ExoPlayer
-  specific questions. If you're asking a general Android development question,
-  please do so on Stack Overflow.
+  reproduce the issue in the ExoPlayer demo app. Information about the ExoPlayer
+  demo app can be found here:
+  http://exoplayer.dev/demo-application.html.
 
 When reporting a bug:
 -----------------------
@@ -15,29 +22,37 @@ Fill out the sections below, leaving the headers but replacing the content. If
 you're unable to provide certain information, please explain why in the relevant
 section. We may close issues if they do not include sufficient information.
 
-### Issue description
+### [REQUIRED] Issue description
 Describe the issue in detail, including observed and expected behavior.
 
-### Reproduction steps
-Describe how the issue can be reproduced, ideally using the ExoPlayer demo app.
+### [REQUIRED] Reproduction steps
+Describe how the issue can be reproduced, ideally using the ExoPlayer demo app
+or a small sample app that you’re able to share as source code on GitHub.
 
-### Link to test content
-Provide a link to media that reproduces the issue. If you don't wish to post it
-publicly, please submit the issue, then email the link to
-dev.exoplayer@gmail.com using a subject in the format "Issue #1234".
+### [REQUIRED] Link to test content
+Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
+media that reproduces the issue. If you don't wish to post it publicly, please
+submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
+in the format "Issue #1234". Provide all the metadata we'd need to play the
+content like drm license urls or similar. If the content is accessible only in
+certain countries or regions, please say so.
 
-### Version of ExoPlayer being used
-Specify the absolute version number. Avoid using terms such as "latest".
-
-### Device(s) and version(s) of Android being used
-Specify the devices and versions of Android on which the issue can be
-reproduced, and how easily it reproduces. If possible, please test on multiple
-devices and Android versions.
-
-### A full bug report captured from the device
+### [REQUIRED] A full bug report captured from the device
 Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
 log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
 bug report to dev.exoplayer@gmail.com using a subject in the format
 "Issue #1234".
 
+### [REQUIRED] Version of ExoPlayer being used
+Specify the absolute version number. Avoid using terms such as "latest".
+
+### [REQUIRED] Device(s) and version(s) of Android being used
+Specify the devices and versions of Android on which the issue can be
+reproduced, and how easily it reproduces. If possible, please test on multiple
+devices and Android versions.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/bug.md
+-->
diff --git a/.github/ISSUE_TEMPLATE/content_not_playing.md b/.github/ISSUE_TEMPLATE/content_not_playing.md
new file mode 100644
index 0000000000..f326e7cd46
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/content_not_playing.md
@@ -0,0 +1,47 @@
+---
+name: Content not playing correctly
+about: Issue template for a content not playing issue.
+title: ''
+labels: content not playing, needs triage
+assignees: ''
+---
+
+Before filing a content issue:
+------------------------------
+- Search existing issues, including issues that are closed.
+- Consult our supported formats page, which can be found at
+  https://exoplayer.dev/supported-formats.html.
+- Try playing your content in the ExoPlayer demo app. Information about the
+  ExoPlayer demo app can be found here:
+  http://exoplayer.dev/demo-application.html.
+
+When reporting a content issue:
+-----------------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### [REQUIRED] Content description
+Describe the content and any specifics you expected to play but did not. This
+could be the container or sample format itself or any features the stream has
+and you expect to play, like 5.1 audio track, text tracks or drm systems.
+
+### [REQUIRED] Link to test content
+Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
+media that reproduces the issue. If you don't wish to post it publicly, please
+submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
+in the format "Issue #1234". Provide all the metadata we'd need to play the
+content like drm license urls or similar. If the content is accessible only in
+certain countries or regions, please say so.
+
+### [REQUIRED] Version of ExoPlayer being used
+Specify the absolute version number. Avoid using terms such as "latest".
+
+### [REQUIRED] Device(s) and version(s) of Android being used
+Specify the devices and versions of Android on which you expect the content to
+play. If possible, please test on multiple devices and Android versions.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/content_not_playing.md
+-->
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
new file mode 100644
index 0000000000..089de35910
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -0,0 +1,34 @@
+---
+name: Feature request
+about: Issue template for a feature request.
+title: ''
+labels: enhancement, needs triage
+assignees: ''
+---
+
+Before filing a feature request:
+-----------------------
+- Search existing open issues, specifically with the label ‘enhancement’.
+- Search existing pull requests.
+
+When filing a feature request:
+-----------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### [REQUIRED] Use case description
+Describe the use case or problem you are trying to solve in detail. If there are
+any standards or specifications involved, please provide the relevant details.
+
+### Proposed solution
+A clear and concise description of your proposed solution, if you have one.
+
+### Alternatives considered
+A clear and concise description of any alternative solutions you considered,
+if applicable.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/feature_request.md
+-->
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
new file mode 100644
index 0000000000..3ed569862f
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -0,0 +1,34 @@
+---
+name: Question
+about: Issue template for a question.
+title: ''
+labels: question, needs triage
+assignees: ''
+---
+
+Before filing a question:
+-----------------------
+- This issue tracker is intended ExoPlayer specific questions. If you're asking
+  a general Android development question, please do so on Stack Overflow.
+- Search existing issues, including issues that are closed. It’s often the
+  quickest way to get an answer!
+- Consult our FAQs, developer guide and the class reference of ExoPlayer. These
+  can be found at https://exoplayer.dev/.
+
+When filing a question:
+-----------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### [REQUIRED] Searched documentation and issues
+Tell us where you’ve already looked for an answer to your question. It’s
+important for us to know this so that we can improve our documentation.
+
+### [REQUIRED] Question
+Describe your question in detail.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/question.md
+-->
diff --git a/.gitignore b/.gitignore
index db5a8c4305..4731d5ba99 100644
--- a/.gitignore
+++ b/.gitignore
@@ -37,6 +37,12 @@ local.properties
 proguard.cfg
 proguard-project.txt
 
+# Bazel
+bazel-bin
+bazel-genfiles
+bazel-out
+bazel-testlogs
+
 # Other
 .DS_Store
 cmake-build-debug
@@ -66,3 +72,6 @@ extensions/cronet/jniLibs/*
 extensions/cronet/libs/*
 !extensions/cronet/libs/README.md
 
+# Cast receiver
+cast_receiver_app/external-js
+cast_receiver_app/bazel-cast_receiver_app
diff --git a/.hgignore b/.hgignore
index f7c3656f65..36d3268005 100644
--- a/.hgignore
+++ b/.hgignore
@@ -44,6 +44,12 @@ local.properties
 proguard.cfg
 proguard-project.txt
 
+# Bazel
+bazel-bin
+bazel-genfiles
+bazel-out
+bazel-testlogs
+
 # Other
 .DS_Store
 cmake-build-debug
@@ -69,3 +75,7 @@ extensions/cronet/jniLibs/*
 !extensions/cronet/jniLibs/README.md
 extensions/cronet/libs/*
 !extensions/cronet/libs/README.md
+
+# Cast receiver
+cast_receiver_app/external-js
+cast_receiver_app/bazel-cast_receiver_app
diff --git a/README.md b/README.md
index 37967dd527..a369b077f4 100644
--- a/README.md
+++ b/README.md
@@ -15,8 +15,8 @@ and extend, and can be updated through Play Store application updates.
 * Follow our [developer blog][] to keep up to date with the latest ExoPlayer
   developments!
 
-[developer guide]: https://google.github.io/ExoPlayer/guide.html
-[class reference]: https://google.github.io/ExoPlayer/doc/reference
+[developer guide]: https://exoplayer.dev/guide.html
+[class reference]: https://exoplayer.dev/doc/reference
 [release notes]: https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md
 [developer blog]: https://medium.com/google-exoplayer
 
@@ -27,6 +27,8 @@ repository and depend on the modules locally.
 
 ### From JCenter ###
 
+#### 1. Add repositories ####
+
 The easiest way to get started using ExoPlayer is to add it as a gradle
 dependency. You need to make sure you have the Google and JCenter repositories
 included in the `build.gradle` file in the root of your project:
@@ -38,6 +40,8 @@ repositories {
 }
 ```
 
+#### 2. Add ExoPlayer module dependencies ####
+
 Next add a dependency in the `build.gradle` file of your app module. The
 following will add a dependency to the full library:
 
@@ -45,15 +49,7 @@ following will add a dependency to the full library:
 implementation 'com.google.android.exoplayer:exoplayer:2.X.X'
 ```
 
-where `2.X.X` is your preferred version. If not enabled already, you also need
-to turn on Java 8 support in all `build.gradle` files depending on ExoPlayer, by
-adding the following to the `android` section:
-
-```gradle
-compileOptions {
-    targetCompatibility JavaVersion.VERSION_1_8
-}
-```
+where `2.X.X` is your preferred version.
 
 As an alternative to the full library, you can depend on only the library
 modules that you actually need. For example the following will add dependencies
@@ -87,6 +83,18 @@ JCenter can be found on [Bintray][].
 [extensions directory]: https://github.com/google/ExoPlayer/tree/release-v2/extensions/
 [Bintray]: https://bintray.com/google/exoplayer
 
+#### 3. Turn on Java 8 support ####
+
+If not enabled already, you also need to turn on Java 8 support in all
+`build.gradle` files depending on ExoPlayer, by adding the following to the
+`android` section:
+
+```gradle
+compileOptions {
+  targetCompatibility JavaVersion.VERSION_1_8
+}
+```
+
 ### Locally ###
 
 Cloning the repository and depending on the modules locally is required when
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 1699f2c09b..9e69bcc917 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,198 @@
 # Release notes #
 
+### 2.10.0 ###
+
+* Core library:
+  * Improve decoder re-use between playbacks
+    ([#2826](https://github.com/google/ExoPlayer/issues/2826)). Read
+    [this blog post](https://medium.com/google-exoplayer/improved-decoder-reuse-in-exoplayer-ef4c6d99591d)
+    for more details.
+  * Rename `ExtractorMediaSource` to `ProgressiveMediaSource`.
+  * Fix issue where using `ProgressiveMediaSource.Factory` would mean that
+    `DefaultExtractorsFactory` would be kept by proguard. Custom
+    `ExtractorsFactory` instances must now be passed via the
+    `ProgressiveMediaSource.Factory` constructor, and `setExtractorsFactory` is
+    deprecated.
+  * Move `PriorityTaskManager` from `DefaultLoadControl` to `SimpleExoPlayer`.
+  * Add new `ExoPlaybackException` types for remote exceptions and out-of-memory
+    errors.
+  * Use full BCP 47 language tags in `Format`.
+  * Do not retry failed loads whose error is `FileNotFoundException`.
+  * Fix issue where not resetting the position for a new `MediaSource` in calls
+    to `ExoPlayer.prepare` causes an `IndexOutOfBoundsException`
+    ([#5520](https://github.com/google/ExoPlayer/issues/5520)).
+* Offline:
+  * Improve offline support. `DownloadManager` now tracks all offline content,
+    not just tasks in progress. Read
+    [this page](https://exoplayer.dev/downloading-media.html) for more details.
+* Caching:
+  * Improve performance of `SimpleCache`
+    ([#4253](https://github.com/google/ExoPlayer/issues/4253)).
+  * Cache data with unknown length by default. The previous flag to opt in to
+    this behavior (`DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH`) has been
+    replaced with an opt out flag
+    (`DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN`).
+* Extractors:
+  * MP4/FMP4: Add support for Dolby Vision.
+  * MP4: Fix issue handling meta atoms in some streams
+    ([#5698](https://github.com/google/ExoPlayer/issues/5698),
+    [#5694](https://github.com/google/ExoPlayer/issues/5694)).
+  * MP3: Add support for SHOUTcast ICY metadata
+    ([#3735](https://github.com/google/ExoPlayer/issues/3735)).
+  * MP3: Fix ID3 frame unsychronization
+    ([#5673](https://github.com/google/ExoPlayer/issues/5673)).
+  * MP3: Fix playback of badly clipped files
+    ([#5772](https://github.com/google/ExoPlayer/issues/5772)).
+  * MPEG-TS: Enable HDMV DTS stream detection only if a flag is set. By default
+    (i.e. if the flag is not set), the 0x82 elementary stream type is now
+    treated as an SCTE subtitle track
+    ([#5330](https://github.com/google/ExoPlayer/issues/5330)).
+* Track selection:
+  * Add options for controlling audio track selections to `DefaultTrackSelector`
+    ([#3314](https://github.com/google/ExoPlayer/issues/3314)).
+  * Update `TrackSelection.Factory` interface to support creating all track
+    selections together.
+  * Allow to specify a selection reason for a `SelectionOverride`.
+  * When no text language preference matches, only select forced text tracks
+    whose language matches the selected audio language.
+* UI:
+  * Update `DefaultTimeBar` based on duration of media and add parameter to set
+    the minimum update interval to control the smoothness of the updates
+    ([#5040](https://github.com/google/ExoPlayer/issues/5040)).
+  * Move creation of dialogs for `TrackSelectionView`s to
+    `TrackSelectionDialogBuilder` and add option to select multiple overrides.
+  * Change signature of `PlayerNotificationManager.NotificationListener` to
+    better fit service requirements.
+  * Add option to include navigation actions in the compact mode of
+    notifications created using `PlayerNotificationManager`.
+  * Fix issues with flickering notifications on KitKat when using
+    `PlayerNotificationManager` and `DownloadNotificationUtil`. For the latter,
+    applications should switch to using `DownloadNotificationHelper`.
+  * Fix accuracy of D-pad seeking in `DefaultTimeBar`
+    ([#5767](https://github.com/google/ExoPlayer/issues/5767)).
+* Audio:
+  * Allow `AudioProcessor`s to be drained of pending output after they are
+    reconfigured.
+  * Fix an issue that caused audio to be truncated at the end of a period
+    when switching to a new period where gapless playback information was newly
+    present or newly absent.
+  * Add support for reading AC-4 streams
+    ([#5303](https://github.com/google/ExoPlayer/pull/5303)).
+* Video:
+  * Remove `MediaCodecSelector.DEFAULT_WITH_FALLBACK`. Apps should instead
+    signal that fallback should be used by passing `true` as the
+    `enableDecoderFallback` parameter when instantiating the video renderer.
+  * Support video tunneling when the decoder is not listed first for the MIME
+    type ([#3100](https://github.com/google/ExoPlayer/issues/3100)).
+  * Query `MediaCodecList.ALL_CODECS` when selecting a tunneling decoder
+    ([#5547](https://github.com/google/ExoPlayer/issues/5547)).
+* DRM:
+  * Fix black flicker when keys rotate in DRM protected content
+  ([#3561](https://github.com/google/ExoPlayer/issues/3561)).
+  * Work around lack of LA_URL attribute in PlayReady key request init data.
+* CEA-608: Improved conformance to the specification
+  ([#3860](https://github.com/google/ExoPlayer/issues/3860)).
+* DASH:
+  * Parse role and accessibility descriptors into `Format.roleFlags`.
+  * Support multiple CEA-608 channels muxed into FMP4 representations
+    ([#5656](https://github.com/google/ExoPlayer/issues/5656)).
+* HLS:
+  * Prevent unnecessary reloads of initialization segments.
+  * Form an adaptive track group out of audio renditions with matching name.
+  * Support encrypted initialization segments
+    ([#5441](https://github.com/google/ExoPlayer/issues/5441)).
+  * Parse `EXT-X-MEDIA` `CHARACTERISTICS` attribute into `Format.roleFlags`.
+  * Add metadata entry for HLS tracks to expose master playlist information.
+  * Prevent `IndexOutOfBoundsException` in some live HLS scenarios
+    ([#5816](https://github.com/google/ExoPlayer/issues/5816)).
+* Support for playing spherical videos on Daydream.
+* Cast extension: Work around Cast framework returning a limited-size queue
+  items list ([#4964](https://github.com/google/ExoPlayer/issues/4964)).
+* VP9 extension: Remove RGB output mode and libyuv dependency, and switch to
+  surface YUV output as the default. Remove constructor parameters `scaleToFit`
+  and `useSurfaceYuvOutput`.
+* MediaSession extension:
+  * Let apps intercept media button events
+    ([#5179](https://github.com/google/ExoPlayer/issues/5179)).
+  * Fix issue with `TimelineQueueNavigator` not publishing the queue in shuffled
+    order when in shuffle mode.
+  * Allow handling of custom commands via `registerCustomCommandReceiver`.
+  * Add ability to include an extras `Bundle` when reporting a custom error.
+* LoadControl: Set minimum buffer for playbacks with video equal to maximum
+  buffer ([#2083](https://github.com/google/ExoPlayer/issues/2083)).
+* Log warnings when extension native libraries can't be used, to help with
+  diagnosing playback failures
+  ([#5788](https://github.com/google/ExoPlayer/issues/5788)).
+
+### 2.9.6 ###
+
+* Remove `player` and `isTopLevelSource` parameters from `MediaSource.prepare`.
+* IMA extension:
+  * Require setting the `Player` on `AdsLoader` instances before
+    playback.
+  * Remove deprecated `ImaAdsMediaSource`. Create `AdsMediaSource` with an
+    `ImaAdsLoader` instead.
+  * Remove deprecated `AdsMediaSource` constructors. Listen for media source
+    events using `AdsMediaSource.addEventListener`, and ad interaction events by
+    adding a listener when building `ImaAdsLoader`.
+  * Allow apps to register playback-related obstructing views that are on top of
+    their ad display containers via `AdsLoader.AdViewProvider`. `PlayerView`
+    implements this interface and will register its control view. This makes it
+    possible for ad loading SDKs to calculate ad viewability accurately.
+* DASH: Fix issue handling large `EventStream` presentation timestamps
+  ([#5490](https://github.com/google/ExoPlayer/issues/5490)).
+* HLS: Fix transition to STATE_ENDED when playing fragmented mp4 in chunkless
+  preparation ([#5524](https://github.com/google/ExoPlayer/issues/5524)).
+* Revert workaround for video quality problems with Amlogic decoders, as this
+  may cause problems for some devices and/or non-interlaced content
+  ([#5003](https://github.com/google/ExoPlayer/issues/5003)).
+
+### 2.9.5 ###
+
+* HLS: Parse `CHANNELS` attribute from `EXT-X-MEDIA` tag.
+* ConcatenatingMediaSource:
+  * Add `Handler` parameter to methods that take a callback `Runnable`.
+  * Fix issue with dropped messages when releasing the source
+    ([#5464](https://github.com/google/ExoPlayer/issues/5464)).
+* ExtractorMediaSource: Fix issue that could cause the player to get stuck
+  buffering at the end of the media.
+* PlayerView: Fix issue preventing `OnClickListener` from receiving events
+  ([#5433](https://github.com/google/ExoPlayer/issues/5433)).
+* IMA extension: Upgrade IMA dependency to 3.10.6.
+* Cronet extension: Upgrade Cronet dependency to 71.3578.98.
+* OkHttp extension: Upgrade OkHttp dependency to 3.12.1.
+* MP3: Wider fix for issue where streams would play twice on some Samsung
+  devices ([#4519](https://github.com/google/ExoPlayer/issues/4519)).
+
+### 2.9.4 ###
+
+* IMA extension: Clear ads loader listeners on release
+  ([#4114](https://github.com/google/ExoPlayer/issues/4114)).
+* SmoothStreaming: Fix support for subtitles in DRM protected streams
+  ([#5378](https://github.com/google/ExoPlayer/issues/5378)).
+* FFmpeg extension: Treat invalid data errors as non-fatal to match the behavior
+  of MediaCodec ([#5293](https://github.com/google/ExoPlayer/issues/5293)).
+* GVR extension: upgrade GVR SDK dependency to 1.190.0.
+* Associate fatal player errors of type SOURCE with the loading source in
+  `AnalyticsListener.EventTime`
+  ([#5407](https://github.com/google/ExoPlayer/issues/5407)).
+* Add `startPositionUs` to `MediaSource.createPeriod`. This fixes an issue where
+  using lazy preparation in `ConcatenatingMediaSource` with an
+  `ExtractorMediaSource` overrides initial seek positions
+  ([#5350](https://github.com/google/ExoPlayer/issues/5350)).
+* Add subtext to the `MediaDescriptionAdapter` of the
+  `PlayerNotificationManager`.
+* Add workaround for video quality problems with Amlogic decoders
+  ([#5003](https://github.com/google/ExoPlayer/issues/5003)).
+* Fix issue where sending callbacks for playlist changes may cause problems
+  because of parallel player access
+  ([#5240](https://github.com/google/ExoPlayer/issues/5240)).
+* Fix issue with reusing a `ClippingMediaSource` with an inner
+  `ExtractorMediaSource` and a non-zero start position
+  ([#5351](https://github.com/google/ExoPlayer/issues/5351)).
+* Fix issue where uneven track durations in MP4 streams can cause OOM problems
+  ([#3670](https://github.com/google/ExoPlayer/issues/3670)).
+
 ### 2.9.3 ###
 
 * Captions: Support PNG subtitles in SMPTE-TT
@@ -1131,7 +1324,7 @@
   [here](https://medium.com/google-exoplayer/customizing-exoplayers-ui-components-728cf55ee07a#.9ewjg7avi).
 * Robustness improvements when handling MediaSource timeline changes and
   MediaPeriod transitions.
-* EIA608: Support for caption styling and positioning.
+* CEA-608: Support for caption styling and positioning.
 * MPEG-TS: Improved support:
   * Support injection of custom TS payload readers.
   * Support injection of custom section payload readers.
@@ -1375,8 +1568,8 @@ V2 release.
   (#801).
 * MP3: Fix playback of some streams when stream length is unknown.
 * ID3: Support multiple frames of the same type in a single tag.
-* EIA608: Correctly handle repeated control characters, fixing an issue in which
-  captions would immediately disappear.
+* CEA-608: Correctly handle repeated control characters, fixing an issue in
+  which captions would immediately disappear.
 * AVC3: Fix decoder failures on some MediaTek devices in the case where the
   first buffer fed to the decoder does not start with SPS/PPS NAL units.
 * Misc bug fixes.
diff --git a/build.gradle b/build.gradle
index 96eade1aa3..4761a1fbe0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,9 +17,9 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.1.4'
-        classpath 'com.novoda:bintray-release:0.8.1'
-        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.0.3'
+        classpath 'com.android.tools.build:gradle:3.4.0'
+        classpath 'com.novoda:bintray-release:0.9'
+        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.1.0'
     }
     // Workaround for the following test coverage issue. Remove when fixed:
     // https://code.google.com/p/android/issues/detail?id=226070
diff --git a/constants.gradle b/constants.gradle
index ac801d2d3b..5063c59141 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,26 +13,17 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.9.3'
-    releaseVersionCode = 2009003
-    // Important: ExoPlayer specifies a minSdkVersion of 14 because various
-    // components provided by the library may be of use on older devices.
-    // However, please note that the core media playback functionality provided
-    // by the library requires API level 16 or greater.
-    minSdkVersion = 14
+    releaseVersion = '2.10.0'
+    releaseVersionCode = 2010000
+    minSdkVersion = 16
     targetSdkVersion = 28
     compileSdkVersion = 28
-    buildToolsVersion = '28.0.2'
-    testSupportLibraryVersion = '0.5'
-    supportLibraryVersion = '27.1.1'
-    dexmakerVersion = '1.2'
-    mockitoVersion = '1.9.5'
-    junitVersion = '4.12'
-    truthVersion = '0.39'
-    robolectricVersion = '3.7.1'
+    dexmakerVersion = '2.21.0'
+    mockitoVersion = '2.25.0'
+    robolectricVersion = '4.2'
     autoValueVersion = '1.6'
     checkerframeworkVersion = '2.5.0'
-    testRunnerVersion = '1.1.0-alpha3'
+    androidXTestVersion = '1.1.0'
     modulePrefix = ':'
     if (gradle.ext.has('exoplayerModulePrefix')) {
         modulePrefix += gradle.ext.exoplayerModulePrefix
diff --git a/demos/cast/build.gradle b/demos/cast/build.gradle
index 915bc10b7c..03a54947cf 100644
--- a/demos/cast/build.gradle
+++ b/demos/cast/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -26,7 +25,7 @@ android {
     defaultConfig {
         versionName project.ext.releaseVersion
         versionCode project.ext.releaseVersionCode
-        minSdkVersion 16
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
 
@@ -45,8 +44,18 @@ android {
     }
 
     lintOptions {
-        // The demo app does not have translations.
-        disable 'MissingTranslation'
+        // The demo app isn't indexed and doesn't have translations.
+        disable 'GoogleAppIndexingWarning','MissingTranslation'
+    }
+
+    flavorDimensions "receiver"
+
+    productFlavors {
+        defaultCast {
+            dimension "receiver"
+            manifestPlaceholders =
+                    [castOptionsProvider: "com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider"]
+        }
     }
 
 }
@@ -58,9 +67,10 @@ dependencies {
     implementation project(modulePrefix + 'library-smoothstreaming')
     implementation project(modulePrefix + 'library-ui')
     implementation project(modulePrefix + 'extension-cast')
-    implementation 'com.android.support:support-v4:' + supportLibraryVersion
-    implementation 'com.android.support:appcompat-v7:' + supportLibraryVersion
-    implementation 'com.android.support:recyclerview-v7:' + supportLibraryVersion
+    implementation 'com.google.android.material:material:1.0.0'
+    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
+    implementation 'androidx.appcompat:appcompat:1.0.2'
+    implementation 'androidx.recyclerview:recyclerview:1.0.0'
 }
 
 apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/cast/proguard-rules.txt b/demos/cast/proguard-rules.txt
index 3221818080..e6bf2dd3bf 100644
--- a/demos/cast/proguard-rules.txt
+++ b/demos/cast/proguard-rules.txt
@@ -1,6 +1,6 @@
 # Proguard rules specific to the Cast demo app.
 
 # Accessed via menu.xml
--keep class android.support.v7.app.MediaRouteActionProvider {
+-keep class androidx.mediarouter.app.MediaRouteActionProvider {
   *;
 }
diff --git a/demos/cast/src/main/AndroidManifest.xml b/demos/cast/src/main/AndroidManifest.xml
index ae16776333..856b0b1235 100644
--- a/demos/cast/src/main/AndroidManifest.xml
+++ b/demos/cast/src/main/AndroidManifest.xml
@@ -17,13 +17,15 @@
     package="com.google.android.exoplayer2.castdemo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+
   <uses-sdk/>
 
   <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
       android:largeHeap="true" android:allowBackup="false">
 
     <meta-data android:name="com.google.android.gms.cast.framework.OPTIONS_PROVIDER_CLASS_NAME"
-        android:value="com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider" />
+        android:value="${castOptionsProvider}" />
 
     <activity android:name="com.google.android.exoplayer2.castdemo.MainActivity"
         android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
new file mode 100644
index 0000000000..4b71b3a001
--- /dev/null
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
@@ -0,0 +1,405 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.castdemo;
+
+import android.content.Context;
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import android.view.KeyEvent;
+import android.view.View;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultRenderersFactory;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.Player.EventListener;
+import com.google.android.exoplayer2.Player.TimelineChangeReason;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.ext.cast.CastPlayer;
+import com.google.android.exoplayer2.ext.cast.MediaItem;
+import com.google.android.exoplayer2.ext.cast.SessionAvailabilityListener;
+import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.hls.HlsMediaSource;
+import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.ui.PlayerView;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaMetadata;
+import com.google.android.gms.cast.MediaQueueItem;
+import com.google.android.gms.cast.framework.CastContext;
+import java.util.ArrayList;
+
+/** Manages players and an internal media queue for the ExoPlayer/Cast demo app. */
+/* package */ class DefaultReceiverPlayerManager
+    implements PlayerManager, EventListener, SessionAvailabilityListener {
+
+  private static final String USER_AGENT = "ExoCastDemoPlayer";
+  private static final DefaultHttpDataSourceFactory DATA_SOURCE_FACTORY =
+      new DefaultHttpDataSourceFactory(USER_AGENT);
+
+  private final PlayerView localPlayerView;
+  private final PlayerControlView castControlView;
+  private final SimpleExoPlayer exoPlayer;
+  private final CastPlayer castPlayer;
+  private final ArrayList<MediaItem> mediaQueue;
+  private final Listener listener;
+  private final ConcatenatingMediaSource concatenatingMediaSource;
+
+  private boolean castMediaQueueCreationPending;
+  private int currentItemIndex;
+  private Player currentPlayer;
+
+  /**
+   * Creates a new manager for {@link SimpleExoPlayer} and {@link CastPlayer}.
+   *
+   * @param listener A {@link Listener} for queue position changes.
+   * @param localPlayerView The {@link PlayerView} for local playback.
+   * @param castControlView The {@link PlayerControlView} to control remote playback.
+   * @param context A {@link Context}.
+   * @param castContext The {@link CastContext}.
+   */
+  public DefaultReceiverPlayerManager(
+      Listener listener,
+      PlayerView localPlayerView,
+      PlayerControlView castControlView,
+      Context context,
+      CastContext castContext) {
+    this.listener = listener;
+    this.localPlayerView = localPlayerView;
+    this.castControlView = castControlView;
+    mediaQueue = new ArrayList<>();
+    currentItemIndex = C.INDEX_UNSET;
+    concatenatingMediaSource = new ConcatenatingMediaSource();
+
+    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
+    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
+    exoPlayer = ExoPlayerFactory.newSimpleInstance(context, renderersFactory, trackSelector);
+    exoPlayer.addListener(this);
+    localPlayerView.setPlayer(exoPlayer);
+
+    castPlayer = new CastPlayer(castContext);
+    castPlayer.addListener(this);
+    castPlayer.setSessionAvailabilityListener(this);
+    castControlView.setPlayer(castPlayer);
+
+    setCurrentPlayer(castPlayer.isCastSessionAvailable() ? castPlayer : exoPlayer);
+  }
+
+  // Queue manipulation methods.
+
+  /**
+   * Plays a specified queue item in the current player.
+   *
+   * @param itemIndex The index of the item to play.
+   */
+  @Override
+  public void selectQueueItem(int itemIndex) {
+    setCurrentItem(itemIndex, C.TIME_UNSET, true);
+  }
+
+  /** Returns the index of the currently played item. */
+  @Override
+  public int getCurrentItemIndex() {
+    return currentItemIndex;
+  }
+
+  /**
+   * Appends {@code item} to the media queue.
+   *
+   * @param item The {@link MediaItem} to append.
+   */
+  @Override
+  public void addItem(MediaItem item) {
+    mediaQueue.add(item);
+    concatenatingMediaSource.addMediaSource(buildMediaSource(item));
+    if (currentPlayer == castPlayer) {
+      castPlayer.addItems(buildMediaQueueItem(item));
+    }
+  }
+
+  /** Returns the size of the media queue. */
+  @Override
+  public int getMediaQueueSize() {
+    return mediaQueue.size();
+  }
+
+  /**
+   * Returns the item at the given index in the media queue.
+   *
+   * @param position The index of the item.
+   * @return The item at the given index in the media queue.
+   */
+  @Override
+  public MediaItem getItem(int position) {
+    return mediaQueue.get(position);
+  }
+
+  /**
+   * Removes the item at the given index from the media queue.
+   *
+   * @param item The item to remove.
+   * @return Whether the removal was successful.
+   */
+  @Override
+  public boolean removeItem(MediaItem item) {
+    int itemIndex = mediaQueue.indexOf(item);
+    if (itemIndex == -1) {
+      return false;
+    }
+    concatenatingMediaSource.removeMediaSource(itemIndex);
+    if (currentPlayer == castPlayer) {
+      if (castPlayer.getPlaybackState() != Player.STATE_IDLE) {
+        Timeline castTimeline = castPlayer.getCurrentTimeline();
+        if (castTimeline.getPeriodCount() <= itemIndex) {
+          return false;
+        }
+        castPlayer.removeItem((int) castTimeline.getPeriod(itemIndex, new Period()).id);
+      }
+    }
+    mediaQueue.remove(itemIndex);
+    if (itemIndex == currentItemIndex && itemIndex == mediaQueue.size()) {
+      maybeSetCurrentItemAndNotify(C.INDEX_UNSET);
+    } else if (itemIndex < currentItemIndex) {
+      maybeSetCurrentItemAndNotify(currentItemIndex - 1);
+    }
+    return true;
+  }
+
+  /**
+   * Moves an item within the queue.
+   *
+   * @param item The item to move.
+   * @param toIndex The target index of the item in the queue.
+   * @return Whether the item move was successful.
+   */
+  @Override
+  public boolean moveItem(MediaItem item, int toIndex) {
+    int fromIndex = mediaQueue.indexOf(item);
+    if (fromIndex == -1) {
+      return false;
+    }
+    // Player update.
+    concatenatingMediaSource.moveMediaSource(fromIndex, toIndex);
+    if (currentPlayer == castPlayer && castPlayer.getPlaybackState() != Player.STATE_IDLE) {
+      Timeline castTimeline = castPlayer.getCurrentTimeline();
+      int periodCount = castTimeline.getPeriodCount();
+      if (periodCount <= fromIndex || periodCount <= toIndex) {
+        return false;
+      }
+      int elementId = (int) castTimeline.getPeriod(fromIndex, new Period()).id;
+      castPlayer.moveItem(elementId, toIndex);
+    }
+
+    mediaQueue.add(toIndex, mediaQueue.remove(fromIndex));
+
+    // Index update.
+    if (fromIndex == currentItemIndex) {
+      maybeSetCurrentItemAndNotify(toIndex);
+    } else if (fromIndex < currentItemIndex && toIndex >= currentItemIndex) {
+      maybeSetCurrentItemAndNotify(currentItemIndex - 1);
+    } else if (fromIndex > currentItemIndex && toIndex <= currentItemIndex) {
+      maybeSetCurrentItemAndNotify(currentItemIndex + 1);
+    }
+
+    return true;
+  }
+
+  /**
+   * Dispatches a given {@link KeyEvent} to the corresponding view of the current player.
+   *
+   * @param event The {@link KeyEvent}.
+   * @return Whether the event was handled by the target view.
+   */
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    if (currentPlayer == exoPlayer) {
+      return localPlayerView.dispatchKeyEvent(event);
+    } else /* currentPlayer == castPlayer */ {
+      return castControlView.dispatchKeyEvent(event);
+    }
+  }
+
+  /** Releases the manager and the players that it holds. */
+  @Override
+  public void release() {
+    currentItemIndex = C.INDEX_UNSET;
+    mediaQueue.clear();
+    concatenatingMediaSource.clear();
+    castPlayer.setSessionAvailabilityListener(null);
+    castPlayer.release();
+    localPlayerView.setPlayer(null);
+    exoPlayer.release();
+  }
+
+  // Player.EventListener implementation.
+
+  @Override
+  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+    updateCurrentItemIndex();
+  }
+
+  @Override
+  public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+    updateCurrentItemIndex();
+  }
+
+  @Override
+  public void onTimelineChanged(
+      Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
+    updateCurrentItemIndex();
+    if (currentPlayer == castPlayer && timeline.isEmpty()) {
+      castMediaQueueCreationPending = true;
+    }
+  }
+
+  // CastPlayer.SessionAvailabilityListener implementation.
+
+  @Override
+  public void onCastSessionAvailable() {
+    setCurrentPlayer(castPlayer);
+  }
+
+  @Override
+  public void onCastSessionUnavailable() {
+    setCurrentPlayer(exoPlayer);
+  }
+
+  // Internal methods.
+
+  private void updateCurrentItemIndex() {
+    int playbackState = currentPlayer.getPlaybackState();
+    maybeSetCurrentItemAndNotify(
+        playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED
+            ? currentPlayer.getCurrentWindowIndex()
+            : C.INDEX_UNSET);
+  }
+
+  private void setCurrentPlayer(Player currentPlayer) {
+    if (this.currentPlayer == currentPlayer) {
+      return;
+    }
+
+    // View management.
+    if (currentPlayer == exoPlayer) {
+      localPlayerView.setVisibility(View.VISIBLE);
+      castControlView.hide();
+    } else /* currentPlayer == castPlayer */ {
+      localPlayerView.setVisibility(View.GONE);
+      castControlView.show();
+    }
+
+    // Player state management.
+    long playbackPositionMs = C.TIME_UNSET;
+    int windowIndex = C.INDEX_UNSET;
+    boolean playWhenReady = false;
+    if (this.currentPlayer != null) {
+      int playbackState = this.currentPlayer.getPlaybackState();
+      if (playbackState != Player.STATE_ENDED) {
+        playbackPositionMs = this.currentPlayer.getCurrentPosition();
+        playWhenReady = this.currentPlayer.getPlayWhenReady();
+        windowIndex = this.currentPlayer.getCurrentWindowIndex();
+        if (windowIndex != currentItemIndex) {
+          playbackPositionMs = C.TIME_UNSET;
+          windowIndex = currentItemIndex;
+        }
+      }
+      this.currentPlayer.stop(true);
+    } else {
+      // This is the initial setup. No need to save any state.
+    }
+
+    this.currentPlayer = currentPlayer;
+
+    // Media queue management.
+    castMediaQueueCreationPending = currentPlayer == castPlayer;
+    if (currentPlayer == exoPlayer) {
+      exoPlayer.prepare(concatenatingMediaSource);
+    }
+
+    // Playback transition.
+    if (windowIndex != C.INDEX_UNSET) {
+      setCurrentItem(windowIndex, playbackPositionMs, playWhenReady);
+    }
+  }
+
+  /**
+   * Starts playback of the item at the given position.
+   *
+   * @param itemIndex The index of the item to play.
+   * @param positionMs The position at which playback should start.
+   * @param playWhenReady Whether the player should proceed when ready to do so.
+   */
+  private void setCurrentItem(int itemIndex, long positionMs, boolean playWhenReady) {
+    maybeSetCurrentItemAndNotify(itemIndex);
+    if (castMediaQueueCreationPending) {
+      MediaQueueItem[] items = new MediaQueueItem[mediaQueue.size()];
+      for (int i = 0; i < items.length; i++) {
+        items[i] = buildMediaQueueItem(mediaQueue.get(i));
+      }
+      castMediaQueueCreationPending = false;
+      castPlayer.loadItems(items, itemIndex, positionMs, Player.REPEAT_MODE_OFF);
+    } else {
+      currentPlayer.seekTo(itemIndex, positionMs);
+      currentPlayer.setPlayWhenReady(playWhenReady);
+    }
+  }
+
+  private void maybeSetCurrentItemAndNotify(int currentItemIndex) {
+    if (this.currentItemIndex != currentItemIndex) {
+      int oldIndex = this.currentItemIndex;
+      this.currentItemIndex = currentItemIndex;
+      listener.onQueuePositionChanged(oldIndex, currentItemIndex);
+    }
+  }
+
+  private static MediaSource buildMediaSource(MediaItem item) {
+    Uri uri = item.media.uri;
+    switch (item.mimeType) {
+      case DemoUtil.MIME_TYPE_SS:
+        return new SsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
+      case DemoUtil.MIME_TYPE_DASH:
+        return new DashMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
+      case DemoUtil.MIME_TYPE_HLS:
+        return new HlsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
+      case DemoUtil.MIME_TYPE_VIDEO_MP4:
+        return new ProgressiveMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
+      default:
+        {
+          throw new IllegalStateException("Unsupported type: " + item.mimeType);
+        }
+    }
+  }
+
+  private static MediaQueueItem buildMediaQueueItem(MediaItem item) {
+    MediaMetadata movieMetadata = new MediaMetadata(MediaMetadata.MEDIA_TYPE_MOVIE);
+    movieMetadata.putString(MediaMetadata.KEY_TITLE, item.title);
+    MediaInfo mediaInfo =
+        new MediaInfo.Builder(item.media.uri.toString())
+            .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED)
+            .setContentType(item.mimeType)
+            .setMetadata(movieMetadata)
+            .build();
+    return new MediaQueueItem.Builder(mediaInfo).build();
+  }
+}
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
index 77f6a6fc1a..9625304252 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
@@ -15,44 +15,37 @@
  */
 package com.google.android.exoplayer2.castdemo;
 
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.MimeTypes;
-import com.google.android.gms.cast.MediaInfo;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.UUID;
 
-/**
- * Utility methods and constants for the Cast demo application.
- */
+/** Utility methods and constants for the Cast demo application. */
 /* package */ final class DemoUtil {
 
-  public static final String MIME_TYPE_DASH = MimeTypes.APPLICATION_MPD;
-  public static final String MIME_TYPE_HLS = MimeTypes.APPLICATION_M3U8;
-  public static final String MIME_TYPE_SS = MimeTypes.APPLICATION_SS;
-  public static final String MIME_TYPE_VIDEO_MP4 = MimeTypes.VIDEO_MP4;
-
-  /**
-   * The list of samples available in the cast demo app.
-   */
-  public static final List<Sample> SAMPLES;
-
-  /**
-   * Represents a media sample.
-   */
+  /** Represents a media sample. */
   public static final class Sample {
 
-    /**
-     * The uri from which the media sample is obtained.
-     */
+    /** The uri of the media content. */
     public final String uri;
+    /** The name of the sample. */
+    public final String name;
+    /** The mime type of the sample media content. */
+    public final String mimeType;
     /**
-     * A descriptive name for the sample.
+     * The {@link UUID} of the DRM scheme that protects the content, or null if the content is not
+     * DRM-protected.
      */
-    public final String name;
+    @Nullable public final UUID drmSchemeUuid;
     /**
-     * The mime type of the media sample, as required by {@link MediaInfo#setContentType}.
+     * The url from which players should obtain DRM licenses, or null if the content is not
+     * DRM-protected.
      */
-    public final String mimeType;
+    @Nullable public final Uri licenseServerUri;
 
     /**
      * @param uri See {@link #uri}.
@@ -60,31 +53,53 @@
      * @param mimeType See {@link #mimeType}.
      */
     public Sample(String uri, String name, String mimeType) {
+      this(uri, name, mimeType, /* drmSchemeUuid= */ null, /* licenseServerUriString= */ null);
+    }
+
+    public Sample(
+        String uri,
+        String name,
+        String mimeType,
+        @Nullable UUID drmSchemeUuid,
+        @Nullable String licenseServerUriString) {
       this.uri = uri;
       this.name = name;
       this.mimeType = mimeType;
+      this.drmSchemeUuid = drmSchemeUuid;
+      this.licenseServerUri =
+          licenseServerUriString != null ? Uri.parse(licenseServerUriString) : null;
     }
 
     @Override
     public String toString() {
       return name;
     }
-
   }
 
+  public static final String MIME_TYPE_DASH = MimeTypes.APPLICATION_MPD;
+  public static final String MIME_TYPE_HLS = MimeTypes.APPLICATION_M3U8;
+  public static final String MIME_TYPE_SS = MimeTypes.APPLICATION_SS;
+  public static final String MIME_TYPE_VIDEO_MP4 = MimeTypes.VIDEO_MP4;
+
+  /** The list of samples available in the cast demo app. */
+  public static final List<Sample> SAMPLES;
+
   static {
     // App samples.
     ArrayList<Sample> samples = new ArrayList<>();
-    samples.add(new Sample("https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd",
-        "DASH (clear,MP4,H264)", MIME_TYPE_DASH));
-    samples.add(new Sample("https://commondatastorage.googleapis.com/gtv-videos-bucket/CastVideos/"
-        + "hls/TearsOfSteel.m3u8", "Tears of Steel (HLS)", MIME_TYPE_HLS));
-    samples.add(new Sample("https://html5demos.com/assets/dizzy.mp4", "Dizzy (MP4)",
-        MIME_TYPE_VIDEO_MP4));
-    SAMPLES = Collections.unmodifiableList(samples);
 
+    // Clear content.
+    samples.add(
+        new Sample(
+            "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd",
+            "Clear DASH: Tears",
+            MIME_TYPE_DASH));
+    samples.add(
+        new Sample(
+            "https://html5demos.com/assets/dizzy.mp4", "Clear MP4: Dizzy", MIME_TYPE_VIDEO_MP4));
+
+    SAMPLES = Collections.unmodifiableList(samples);
   }
 
   private DemoUtil() {}
-
 }
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
index 30968b8f85..17eeed2da7 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
@@ -17,13 +17,13 @@
 
 import android.content.Context;
 import android.os.Bundle;
-import android.support.v4.graphics.ColorUtils;
-import android.support.v7.app.AlertDialog;
-import android.support.v7.app.AppCompatActivity;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.support.v7.widget.RecyclerView.ViewHolder;
-import android.support.v7.widget.helper.ItemTouchHelper;
+import androidx.core.graphics.ColorUtils;
+import androidx.appcompat.app.AlertDialog;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+import androidx.recyclerview.widget.RecyclerView.ViewHolder;
+import androidx.recyclerview.widget.ItemTouchHelper;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -33,20 +33,26 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
+import android.widget.Toast;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.castdemo.DemoUtil.Sample;
-import com.google.android.exoplayer2.ext.cast.CastPlayer;
+import com.google.android.exoplayer2.ext.cast.MediaItem;
 import com.google.android.exoplayer2.ui.PlayerControlView;
 import com.google.android.exoplayer2.ui.PlayerView;
+import com.google.android.gms.cast.CastMediaControlIntent;
 import com.google.android.gms.cast.framework.CastButtonFactory;
 import com.google.android.gms.cast.framework.CastContext;
+import com.google.android.gms.dynamite.DynamiteModule;
+import java.util.Collections;
 
 /**
- * An activity that plays video using {@link SimpleExoPlayer} and {@link CastPlayer}.
+ * An activity that plays video using {@link SimpleExoPlayer} and supports casting using ExoPlayer's
+ * Cast extension.
  */
-public class MainActivity extends AppCompatActivity implements OnClickListener,
-    PlayerManager.QueuePositionListener {
+public class MainActivity extends AppCompatActivity
+    implements OnClickListener, PlayerManager.Listener {
+
+  private final MediaItem.Builder mediaItemBuilder;
 
   private PlayerView localPlayerView;
   private PlayerControlView castControlView;
@@ -55,13 +61,30 @@
   private MediaQueueListAdapter mediaQueueListAdapter;
   private CastContext castContext;
 
+  public MainActivity() {
+    mediaItemBuilder = new MediaItem.Builder();
+  }
+
   // Activity lifecycle methods.
 
   @Override
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     // Getting the cast context later than onStart can cause device discovery not to take place.
-    castContext = CastContext.getSharedInstance(this);
+    try {
+      castContext = CastContext.getSharedInstance(this);
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      while (cause != null) {
+        if (cause instanceof DynamiteModule.LoadingException) {
+          setContentView(R.layout.cast_context_error);
+          return;
+        }
+        cause = cause.getCause();
+      }
+      // Unknown error. We propagate it.
+      throw e;
+    }
 
     setContentView(R.layout.main_activity);
 
@@ -91,22 +114,38 @@ public boolean onCreateOptionsMenu(Menu menu) {
   @Override
   public void onResume() {
     super.onResume();
-    playerManager =
-        PlayerManager.createPlayerManager(
-            /* queuePositionListener= */ this,
-            localPlayerView,
-            castControlView,
-            /* context= */ this,
-            castContext);
+    if (castContext == null) {
+      // There is no Cast context to work with. Do nothing.
+      return;
+    }
+    String applicationId = castContext.getCastOptions().getReceiverApplicationId();
+    switch (applicationId) {
+      case CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID:
+        playerManager =
+            new DefaultReceiverPlayerManager(
+                /* listener= */ this,
+                localPlayerView,
+                castControlView,
+                /* context= */ this,
+                castContext);
+        break;
+      default:
+        throw new IllegalStateException("Illegal receiver app id: " + applicationId);
+    }
     mediaQueueList.setAdapter(mediaQueueListAdapter);
   }
 
   @Override
   public void onPause() {
     super.onPause();
+    if (castContext == null) {
+      // Nothing to release.
+      return;
+    }
     mediaQueueListAdapter.notifyItemRangeRemoved(0, mediaQueueListAdapter.getItemCount());
     mediaQueueList.setAdapter(null);
     playerManager.release();
+    playerManager = null;
   }
 
   // Activity input.
@@ -119,12 +158,15 @@ public boolean dispatchKeyEvent(KeyEvent event) {
 
   @Override
   public void onClick(View view) {
-    new AlertDialog.Builder(this).setTitle(R.string.sample_list_dialog_title)
-        .setView(buildSampleListView()).setPositiveButton(android.R.string.ok, null).create()
+    new AlertDialog.Builder(this)
+        .setTitle(R.string.add_samples)
+        .setView(buildSampleListView())
+        .setPositiveButton(android.R.string.ok, null)
+        .create()
         .show();
   }
 
-  // PlayerManager.QueuePositionListener implementation.
+  // PlayerManager.Listener implementation.
 
   @Override
   public void onQueuePositionChanged(int previousIndex, int newIndex) {
@@ -136,6 +178,16 @@ public void onQueuePositionChanged(int previousIndex, int newIndex) {
     }
   }
 
+  @Override
+  public void onQueueContentsExternallyChanged() {
+    mediaQueueListAdapter.notifyDataSetChanged();
+  }
+
+  @Override
+  public void onPlayerError() {
+    Toast.makeText(getApplicationContext(), R.string.player_error_msg, Toast.LENGTH_LONG).show();
+  }
+
   // Internal methods.
 
   private View buildSampleListView() {
@@ -144,7 +196,19 @@ private View buildSampleListView() {
     sampleList.setAdapter(new SampleListAdapter(this));
     sampleList.setOnItemClickListener(
         (parent, view, position, id) -> {
-          playerManager.addItem(DemoUtil.SAMPLES.get(position));
+          DemoUtil.Sample sample = DemoUtil.SAMPLES.get(position);
+          mediaItemBuilder
+              .clear()
+              .setMedia(sample.uri)
+              .setTitle(sample.name)
+              .setMimeType(sample.mimeType);
+          if (sample.drmSchemeUuid != null) {
+            mediaItemBuilder.setDrmSchemes(
+                Collections.singletonList(
+                    new MediaItem.DrmScheme(
+                        sample.drmSchemeUuid, new MediaItem.UriBundle(sample.licenseServerUri))));
+          }
+          playerManager.addItem(mediaItemBuilder.build());
           mediaQueueListAdapter.notifyItemInserted(playerManager.getMediaQueueSize() - 1);
         });
     return dialogList;
@@ -152,23 +216,6 @@ private View buildSampleListView() {
 
   // Internal classes.
 
-  private class QueueItemViewHolder extends RecyclerView.ViewHolder implements OnClickListener {
-
-    public final TextView textView;
-
-    public QueueItemViewHolder(TextView textView) {
-      super(textView);
-      this.textView = textView;
-      textView.setOnClickListener(this);
-    }
-
-    @Override
-    public void onClick(View v) {
-      playerManager.selectQueueItem(getAdapterPosition());
-    }
-
-  }
-
   private class MediaQueueListAdapter extends RecyclerView.Adapter<QueueItemViewHolder> {
 
     @Override
@@ -180,8 +227,9 @@ public QueueItemViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
 
     @Override
     public void onBindViewHolder(QueueItemViewHolder holder, int position) {
+      holder.item = playerManager.getItem(position);
       TextView view = holder.textView;
-      view.setText(playerManager.getItem(position).name);
+      view.setText(holder.item.title);
       // TODO: Solve coloring using the theme's ColorStateList.
       view.setTextColor(ColorUtils.setAlphaComponent(view.getCurrentTextColor(),
            position == playerManager.getCurrentItemIndex() ? 255 : 100));
@@ -222,8 +270,11 @@ public boolean onMove(RecyclerView list, RecyclerView.ViewHolder origin,
     @Override
     public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
       int position = viewHolder.getAdapterPosition();
-      if (playerManager.removeItem(position)) {
+      QueueItemViewHolder queueItemHolder = (QueueItemViewHolder) viewHolder;
+      if (playerManager.removeItem(queueItemHolder.item)) {
         mediaQueueListAdapter.notifyItemRemoved(position);
+        // Update whichever item took its place, in case it became the new selected item.
+        mediaQueueListAdapter.notifyItemChanged(position);
       }
     }
 
@@ -231,8 +282,9 @@ public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
     public void clearView(RecyclerView recyclerView, ViewHolder viewHolder) {
       super.clearView(recyclerView, viewHolder);
       if (draggingFromPosition != C.INDEX_UNSET) {
+        QueueItemViewHolder queueItemHolder = (QueueItemViewHolder) viewHolder;
         // A drag has ended. We reflect the media queue change in the player.
-        if (!playerManager.moveItem(draggingFromPosition, draggingToPosition)) {
+        if (!playerManager.moveItem(queueItemHolder.item, draggingToPosition)) {
           // The move failed. The entire sequence of onMove calls since the drag started needs to be
           // invalidated.
           mediaQueueListAdapter.notifyDataSetChanged();
@@ -241,15 +293,30 @@ public void clearView(RecyclerView recyclerView, ViewHolder viewHolder) {
       draggingFromPosition = C.INDEX_UNSET;
       draggingToPosition = C.INDEX_UNSET;
     }
+  }
+
+  private class QueueItemViewHolder extends RecyclerView.ViewHolder implements OnClickListener {
+
+    public final TextView textView;
+    public MediaItem item;
+
+    public QueueItemViewHolder(TextView textView) {
+      super(textView);
+      this.textView = textView;
+      textView.setOnClickListener(this);
+    }
 
+    @Override
+    public void onClick(View v) {
+      playerManager.selectQueueItem(getAdapterPosition());
+    }
   }
 
-  private static final class SampleListAdapter extends ArrayAdapter<Sample> {
+  private static final class SampleListAdapter extends ArrayAdapter<DemoUtil.Sample> {
 
     public SampleListAdapter(Context context) {
       super(context, android.R.layout.simple_list_item_1, DemoUtil.SAMPLES);
     }
-
   }
 
 }
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
index d188469de8..c9a728b3ff 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2019 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,402 +15,53 @@
  */
 package com.google.android.exoplayer2.castdemo;
 
-import android.content.Context;
-import android.net.Uri;
-import android.support.annotation.Nullable;
 import android.view.KeyEvent;
-import android.view.View;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.DefaultRenderersFactory;
-import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Player.DiscontinuityReason;
-import com.google.android.exoplayer2.Player.EventListener;
-import com.google.android.exoplayer2.Player.TimelineChangeReason;
-import com.google.android.exoplayer2.RenderersFactory;
-import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.Timeline.Period;
-import com.google.android.exoplayer2.castdemo.DemoUtil.Sample;
-import com.google.android.exoplayer2.ext.cast.CastPlayer;
-import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.ui.PlayerControlView;
-import com.google.android.exoplayer2.ui.PlayerView;
-import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
-import com.google.android.gms.cast.MediaInfo;
-import com.google.android.gms.cast.MediaMetadata;
-import com.google.android.gms.cast.MediaQueueItem;
-import com.google.android.gms.cast.framework.CastContext;
-import java.util.ArrayList;
+import com.google.android.exoplayer2.ext.cast.MediaItem;
 
-/** Manages players and an internal media queue for the ExoPlayer/Cast demo app. */
-/* package */ final class PlayerManager
-    implements EventListener, CastPlayer.SessionAvailabilityListener {
+/** Manages the players in the Cast demo app. */
+/* package */ interface PlayerManager {
 
-  /**
-   * Listener for changes in the media queue playback position.
-   */
-  public interface QueuePositionListener {
+  /** Listener for events. */
+  interface Listener {
 
-    /**
-     * Called when the currently played item of the media queue changes.
-     */
+    /** Called when the currently played item of the media queue changes. */
     void onQueuePositionChanged(int previousIndex, int newIndex);
 
-  }
-
-  private static final String USER_AGENT = "ExoCastDemoPlayer";
-  private static final DefaultHttpDataSourceFactory DATA_SOURCE_FACTORY =
-      new DefaultHttpDataSourceFactory(USER_AGENT);
-
-  private final PlayerView localPlayerView;
-  private final PlayerControlView castControlView;
-  private final SimpleExoPlayer exoPlayer;
-  private final CastPlayer castPlayer;
-  private final ArrayList<DemoUtil.Sample> mediaQueue;
-  private final QueuePositionListener queuePositionListener;
-  private final ConcatenatingMediaSource concatenatingMediaSource;
+    /** Called when the media queue changes due to modifications not caused by this manager. */
+    void onQueueContentsExternallyChanged();
 
-  private boolean castMediaQueueCreationPending;
-  private int currentItemIndex;
-  private Player currentPlayer;
-
-  /**
-   * @param queuePositionListener A {@link QueuePositionListener} for queue position changes.
-   * @param localPlayerView The {@link PlayerView} for local playback.
-   * @param castControlView The {@link PlayerControlView} to control remote playback.
-   * @param context A {@link Context}.
-   * @param castContext The {@link CastContext}.
-   */
-  public static PlayerManager createPlayerManager(
-      QueuePositionListener queuePositionListener,
-      PlayerView localPlayerView,
-      PlayerControlView castControlView,
-      Context context,
-      CastContext castContext) {
-    PlayerManager playerManager =
-        new PlayerManager(
-            queuePositionListener, localPlayerView, castControlView, context, castContext);
-    playerManager.init();
-    return playerManager;
+    /** Called when an error occurs in the current player. */
+    void onPlayerError();
   }
 
-  private PlayerManager(
-      QueuePositionListener queuePositionListener,
-      PlayerView localPlayerView,
-      PlayerControlView castControlView,
-      Context context,
-      CastContext castContext) {
-    this.queuePositionListener = queuePositionListener;
-    this.localPlayerView = localPlayerView;
-    this.castControlView = castControlView;
-    mediaQueue = new ArrayList<>();
-    currentItemIndex = C.INDEX_UNSET;
-    concatenatingMediaSource = new ConcatenatingMediaSource();
+  /** Redirects the given {@code keyEvent} to the active player. */
+  boolean dispatchKeyEvent(KeyEvent keyEvent);
 
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
-    exoPlayer = ExoPlayerFactory.newSimpleInstance(context, renderersFactory, trackSelector);
-    exoPlayer.addListener(this);
-    localPlayerView.setPlayer(exoPlayer);
-
-    castPlayer = new CastPlayer(castContext);
-    castPlayer.addListener(this);
-    castPlayer.setSessionAvailabilityListener(this);
-    castControlView.setPlayer(castPlayer);
-  }
+  /** Appends the given {@link MediaItem} to the media queue. */
+  void addItem(MediaItem mediaItem);
 
-  // Queue manipulation methods.
+  /** Returns the number of items in the media queue. */
+  int getMediaQueueSize();
 
-  /**
-   * Plays a specified queue item in the current player.
-   *
-   * @param itemIndex The index of the item to play.
-   */
-  public void selectQueueItem(int itemIndex) {
-    setCurrentItem(itemIndex, C.TIME_UNSET, true);
-  }
+  /** Selects the item at the given position for playback. */
+  void selectQueueItem(int position);
 
   /**
-   * Returns the index of the currently played item.
+   * Returns the position of the item currently being played, or {@link C#INDEX_UNSET} if no item is
+   * being played.
    */
-  public int getCurrentItemIndex() {
-    return currentItemIndex;
-  }
+  int getCurrentItemIndex();
 
-  /**
-   * Appends {@code sample} to the media queue.
-   *
-   * @param sample The {@link Sample} to append.
-   */
-  public void addItem(Sample sample) {
-    mediaQueue.add(sample);
-    concatenatingMediaSource.addMediaSource(buildMediaSource(sample));
-    if (currentPlayer == castPlayer) {
-      castPlayer.addItems(buildMediaQueueItem(sample));
-    }
-  }
+  /** Returns the {@link MediaItem} at the given {@code position}. */
+  MediaItem getItem(int position);
 
-  /**
-   * Returns the size of the media queue.
-   */
-  public int getMediaQueueSize() {
-    return mediaQueue.size();
-  }
+  /** Moves the item at position {@code from} to position {@code to}. */
+  boolean moveItem(MediaItem item, int to);
 
-  /**
-   * Returns the item at the given index in the media queue.
-   *
-   * @param position The index of the item.
-   * @return The item at the given index in the media queue.
-   */
-  public Sample getItem(int position) {
-    return mediaQueue.get(position);
-  }
-
-  /**
-   * Removes the item at the given index from the media queue.
-   *
-   * @param itemIndex The index of the item to remove.
-   * @return Whether the removal was successful.
-   */
-  public boolean removeItem(int itemIndex) {
-    concatenatingMediaSource.removeMediaSource(itemIndex);
-    if (currentPlayer == castPlayer) {
-      if (castPlayer.getPlaybackState() != Player.STATE_IDLE) {
-        Timeline castTimeline = castPlayer.getCurrentTimeline();
-        if (castTimeline.getPeriodCount() <= itemIndex) {
-          return false;
-        }
-        castPlayer.removeItem((int) castTimeline.getPeriod(itemIndex, new Period()).id);
-      }
-    }
-    mediaQueue.remove(itemIndex);
-    if (itemIndex == currentItemIndex && itemIndex == mediaQueue.size()) {
-      maybeSetCurrentItemAndNotify(C.INDEX_UNSET);
-    } else if (itemIndex < currentItemIndex) {
-      maybeSetCurrentItemAndNotify(currentItemIndex - 1);
-    }
-    return true;
-  }
-
-  /**
-   * Moves an item within the queue.
-   *
-   * @param fromIndex The index of the item to move.
-   * @param toIndex The target index of the item in the queue.
-   * @return Whether the item move was successful.
-   */
-  public boolean moveItem(int fromIndex, int toIndex) {
-    // Player update.
-    concatenatingMediaSource.moveMediaSource(fromIndex, toIndex);
-    if (currentPlayer == castPlayer && castPlayer.getPlaybackState() != Player.STATE_IDLE) {
-      Timeline castTimeline = castPlayer.getCurrentTimeline();
-      int periodCount = castTimeline.getPeriodCount();
-      if (periodCount <= fromIndex || periodCount <= toIndex) {
-        return false;
-      }
-      int elementId = (int) castTimeline.getPeriod(fromIndex, new Period()).id;
-      castPlayer.moveItem(elementId, toIndex);
-    }
-
-    mediaQueue.add(toIndex, mediaQueue.remove(fromIndex));
-
-    // Index update.
-    if (fromIndex == currentItemIndex) {
-      maybeSetCurrentItemAndNotify(toIndex);
-    } else if (fromIndex < currentItemIndex && toIndex >= currentItemIndex) {
-      maybeSetCurrentItemAndNotify(currentItemIndex - 1);
-    } else if (fromIndex > currentItemIndex && toIndex <= currentItemIndex) {
-      maybeSetCurrentItemAndNotify(currentItemIndex + 1);
-    }
-
-    return true;
-  }
-
-  // Miscellaneous methods.
-
-  /**
-   * Dispatches a given {@link KeyEvent} to the corresponding view of the current player.
-   *
-   * @param event The {@link KeyEvent}.
-   * @return Whether the event was handled by the target view.
-   */
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    if (currentPlayer == exoPlayer) {
-      return localPlayerView.dispatchKeyEvent(event);
-    } else /* currentPlayer == castPlayer */ {
-      return castControlView.dispatchKeyEvent(event);
-    }
-  }
-
-  /**
-   * Releases the manager and the players that it holds.
-   */
-  public void release() {
-    currentItemIndex = C.INDEX_UNSET;
-    mediaQueue.clear();
-    concatenatingMediaSource.clear();
-    castPlayer.setSessionAvailabilityListener(null);
-    castPlayer.release();
-    localPlayerView.setPlayer(null);
-    exoPlayer.release();
-  }
-
-  // Player.EventListener implementation.
-
-  @Override
-  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-    updateCurrentItemIndex();
-  }
-
-  @Override
-  public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
-    updateCurrentItemIndex();
-  }
-
-  @Override
-  public void onTimelineChanged(
-      Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
-    updateCurrentItemIndex();
-    if (timeline.isEmpty()) {
-      castMediaQueueCreationPending = true;
-    }
-  }
-
-  // CastPlayer.SessionAvailabilityListener implementation.
-
-  @Override
-  public void onCastSessionAvailable() {
-    setCurrentPlayer(castPlayer);
-  }
-
-  @Override
-  public void onCastSessionUnavailable() {
-    setCurrentPlayer(exoPlayer);
-  }
-
-  // Internal methods.
-
-  private void init() {
-    setCurrentPlayer(castPlayer.isCastSessionAvailable() ? castPlayer : exoPlayer);
-  }
-
-  private void updateCurrentItemIndex() {
-    int playbackState = currentPlayer.getPlaybackState();
-    maybeSetCurrentItemAndNotify(
-        playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED
-        ? currentPlayer.getCurrentWindowIndex() : C.INDEX_UNSET);
-  }
-
-  private void setCurrentPlayer(Player currentPlayer) {
-    if (this.currentPlayer == currentPlayer) {
-      return;
-    }
-
-    // View management.
-    if (currentPlayer == exoPlayer) {
-      localPlayerView.setVisibility(View.VISIBLE);
-      castControlView.hide();
-    } else /* currentPlayer == castPlayer */ {
-      localPlayerView.setVisibility(View.GONE);
-      castControlView.show();
-    }
-
-    // Player state management.
-    long playbackPositionMs = C.TIME_UNSET;
-    int windowIndex = C.INDEX_UNSET;
-    boolean playWhenReady = false;
-    if (this.currentPlayer != null) {
-      int playbackState = this.currentPlayer.getPlaybackState();
-      if (playbackState != Player.STATE_ENDED) {
-        playbackPositionMs = this.currentPlayer.getCurrentPosition();
-        playWhenReady = this.currentPlayer.getPlayWhenReady();
-        windowIndex = this.currentPlayer.getCurrentWindowIndex();
-        if (windowIndex != currentItemIndex) {
-          playbackPositionMs = C.TIME_UNSET;
-          windowIndex = currentItemIndex;
-        }
-      }
-      this.currentPlayer.stop(true);
-    } else {
-      // This is the initial setup. No need to save any state.
-    }
-
-    this.currentPlayer = currentPlayer;
-
-    // Media queue management.
-    castMediaQueueCreationPending = currentPlayer == castPlayer;
-    if (currentPlayer == exoPlayer) {
-      exoPlayer.prepare(concatenatingMediaSource);
-    }
-
-    // Playback transition.
-    if (windowIndex != C.INDEX_UNSET) {
-      setCurrentItem(windowIndex, playbackPositionMs, playWhenReady);
-    }
-  }
-
-  /**
-   * Starts playback of the item at the given position.
-   *
-   * @param itemIndex The index of the item to play.
-   * @param positionMs The position at which playback should start.
-   * @param playWhenReady Whether the player should proceed when ready to do so.
-   */
-  private void setCurrentItem(int itemIndex, long positionMs, boolean playWhenReady) {
-    maybeSetCurrentItemAndNotify(itemIndex);
-    if (castMediaQueueCreationPending) {
-      MediaQueueItem[] items = new MediaQueueItem[mediaQueue.size()];
-      for (int i = 0; i < items.length; i++) {
-        items[i] = buildMediaQueueItem(mediaQueue.get(i));
-      }
-      castMediaQueueCreationPending = false;
-      castPlayer.loadItems(items, itemIndex, positionMs, Player.REPEAT_MODE_OFF);
-    } else {
-      currentPlayer.seekTo(itemIndex, positionMs);
-      currentPlayer.setPlayWhenReady(playWhenReady);
-    }
-  }
-
-  private void maybeSetCurrentItemAndNotify(int currentItemIndex) {
-    if (this.currentItemIndex != currentItemIndex) {
-      int oldIndex = this.currentItemIndex;
-      this.currentItemIndex = currentItemIndex;
-      queuePositionListener.onQueuePositionChanged(oldIndex, currentItemIndex);
-    }
-  }
-
-  private static MediaSource buildMediaSource(DemoUtil.Sample sample) {
-    Uri uri = Uri.parse(sample.uri);
-    switch (sample.mimeType) {
-      case DemoUtil.MIME_TYPE_SS:
-        return new SsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
-      case DemoUtil.MIME_TYPE_DASH:
-        return new DashMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
-      case DemoUtil.MIME_TYPE_HLS:
-        return new HlsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
-      case DemoUtil.MIME_TYPE_VIDEO_MP4:
-        return new ExtractorMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
-      default: {
-        throw new IllegalStateException("Unsupported type: " + sample.mimeType);
-      }
-    }
-  }
-
-  private static MediaQueueItem buildMediaQueueItem(DemoUtil.Sample sample) {
-    MediaMetadata movieMetadata = new MediaMetadata(MediaMetadata.MEDIA_TYPE_MOVIE);
-    movieMetadata.putString(MediaMetadata.KEY_TITLE, sample.name);
-    MediaInfo mediaInfo = new MediaInfo.Builder(sample.uri)
-        .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED).setContentType(sample.mimeType)
-        .setMetadata(movieMetadata).build();
-    return new MediaQueueItem.Builder(mediaInfo).build();
-  }
+  /** Removes the item at position {@code index}. */
+  boolean removeItem(MediaItem item);
 
+  /** Releases any acquired resources. */
+  void release();
 }
diff --git a/demos/cast/src/main/res/drawable/ic_add_circle_white_24dp.xml b/demos/cast/src/main/res/drawable/ic_plus.xml
similarity index 59%
rename from demos/cast/src/main/res/drawable/ic_add_circle_white_24dp.xml
rename to demos/cast/src/main/res/drawable/ic_plus.xml
index 5f3c8961ef..5a5a5154c9 100644
--- a/demos/cast/src/main/res/drawable/ic_add_circle_white_24dp.xml
+++ b/demos/cast/src/main/res/drawable/ic_plus.xml
@@ -13,8 +13,12 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<vector android:alpha="0.8" android:height="24dp" android:viewportHeight="24.0"
-    android:viewportWidth="24.0" android:width="24dp"
-    xmlns:android="http://schemas.android.com/apk/res/android">
-  <path android:fillColor="#FFFFFF" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM17,13h-4v4h-2v-4L7,13v-2h4L11,7h2v4h4v2z"/>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:height="24.0dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0"
+    android:width="24.0dp" >
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M18,13h-5v5c0,0.55 -0.45,1 -1,1h0c-0.55,0 -1,-0.45 -1,-1v-5H6c-0.55,0 -1,-0.45 -1,-1v0c0,-0.55 0.45,-1 1,-1h5V6c0,-0.55 0.45,-1 1,-1h0c0.55,0 1,0.45 1,1v5h5c0.55,0 1,0.45 1,1v0C19,12.55 18.55,13 18,13z"/>
 </vector>
diff --git a/demos/cast/src/main/res/layout/cast_context_error.xml b/demos/cast/src/main/res/layout/cast_context_error.xml
new file mode 100644
index 0000000000..0b3fdb63d2
--- /dev/null
+++ b/demos/cast/src/main/res/layout/cast_context_error.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/textView"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center"
+    android:textSize="20sp"
+    android:text="@string/cast_context_error"/>
diff --git a/demos/cast/src/main/res/layout/main_activity.xml b/demos/cast/src/main/res/layout/main_activity.xml
index 01e48cdea7..71dbcdcd9c 100644
--- a/demos/cast/src/main/res/layout/main_activity.xml
+++ b/demos/cast/src/main/res/layout/main_activity.xml
@@ -19,34 +19,42 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:keepScreenOn="true">
+
   <com.google.android.exoplayer2.ui.PlayerView android:id="@+id/local_player_view"
       android:layout_width="match_parent"
       android:layout_height="0dp"
-      android:layout_weight="12"
+      android:layout_weight="1"
+      android:background="@android:color/black"
       app:repeat_toggle_modes="all|one"/>
+
   <RelativeLayout android:layout_width="match_parent"
       android:layout_height="0dp"
-      android:layout_weight="12">
-    <android.support.v7.widget.RecyclerView android:id="@+id/sample_list"
+      android:layout_weight="1">
+
+    <androidx.recyclerview.widget.RecyclerView android:id="@+id/sample_list"
         android:choiceMode="singleChoice"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         android:scrollbars="vertical"
         android:fadeScrollbars="false"/>
-    <ImageButton android:id="@+id/add_sample_button"
-        android:background="@drawable/ic_add_circle_white_24dp"
+
+    <com.google.android.material.floatingactionbutton.FloatingActionButton android:id="@+id/add_sample_button"
+        android:src="@drawable/ic_plus"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_alignParentEnd="true"
         android:layout_alignParentRight="true"
         android:layout_alignParentBottom="true"
-        android:padding="30dp"/>
+        android:layout_margin="16dp"
+        android:contentDescription="@string/add_samples"/>
+
   </RelativeLayout>
+
   <com.google.android.exoplayer2.ui.PlayerControlView android:id="@+id/cast_control_view"
       android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="2"
+      android:layout_height="wrap_content"
       android:visibility="gone"
       app:repeat_toggle_modes="all|one"
       app:show_timeout="-1"/>
+
 </LinearLayout>
diff --git a/demos/cast/src/main/res/layout/sample_list.xml b/demos/cast/src/main/res/layout/sample_list.xml
index 910db9e058..183c74eb3a 100644
--- a/demos/cast/src/main/res/layout/sample_list.xml
+++ b/demos/cast/src/main/res/layout/sample_list.xml
@@ -14,7 +14,7 @@
      limitations under the License.
 -->
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="wrap_content"
+    android:layout_width="match_parent"
     android:layout_height="match_parent">
 
   <ListView android:id="@+id/sample_list"
diff --git a/demos/cast/src/main/res/menu/menu.xml b/demos/cast/src/main/res/menu/menu.xml
index 075ad34ec4..95419adf3c 100644
--- a/demos/cast/src/main/res/menu/menu.xml
+++ b/demos/cast/src/main/res/menu/menu.xml
@@ -19,7 +19,7 @@
   <item
       android:id="@+id/media_route_menu_item"
       android:title="@string/media_route_menu_title"
-      app:actionProviderClass="android.support.v7.app.MediaRouteActionProvider"
+      app:actionProviderClass="androidx.mediarouter.app.MediaRouteActionProvider"
       app:showAsAction="always" />
 
 </menu>
diff --git a/demos/cast/src/main/res/values/strings.xml b/demos/cast/src/main/res/values/strings.xml
index 3505c40400..013b50a175 100644
--- a/demos/cast/src/main/res/values/strings.xml
+++ b/demos/cast/src/main/res/values/strings.xml
@@ -20,6 +20,10 @@
 
   <string name="media_route_menu_title">Cast</string>
 
-  <string name="sample_list_dialog_title">Add samples</string>
+  <string name="add_samples">Add samples</string>
+
+  <string name="cast_context_error">Failed to get Cast context. Try updating Google Play Services and restart the app.</string>
+
+  <string name="player_error_msg">Player error encountered. Select a queue item to reprepare. Check the logcat and receiver app\'s console for more info.</string>
 
 </resources>
diff --git a/demos/ima/build.gradle b/demos/ima/build.gradle
index 33cca6ef46..33161b4121 100644
--- a/demos/ima/build.gradle
+++ b/demos/ima/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -26,7 +25,7 @@ android {
     defaultConfig {
         versionName project.ext.releaseVersion
         versionCode project.ext.releaseVersionCode
-        minSdkVersion 16
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
 
@@ -42,8 +41,8 @@ android {
     }
 
     lintOptions {
-        // The demo app does not have translations.
-        disable 'MissingTranslation'
+        // The demo app isn't indexed and doesn't have translations.
+        disable 'GoogleAppIndexingWarning','MissingTranslation'
     }
 }
 
@@ -54,7 +53,7 @@ dependencies {
     implementation project(modulePrefix + 'library-hls')
     implementation project(modulePrefix + 'library-smoothstreaming')
     implementation project(modulePrefix + 'extension-ima')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
 }
 
 apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/ima/src/main/AndroidManifest.xml b/demos/ima/src/main/AndroidManifest.xml
index 50ad0c1b54..85439018fd 100644
--- a/demos/ima/src/main/AndroidManifest.xml
+++ b/demos/ima/src/main/AndroidManifest.xml
@@ -17,6 +17,7 @@
     package="com.google.android.exoplayer2.imademo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-sdk/>
 
   <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
index d67c4549d8..05c804c7a8 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -23,16 +23,12 @@
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.ext.ima.ImaAdsLoader;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
-import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.ui.PlayerView;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
@@ -56,14 +52,9 @@ public PlayerManager(Context context) {
   }
 
   public void init(Context context, PlayerView playerView) {
-    // Create a default track selector.
-    TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory();
-    TrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
-
     // Create a player instance.
-    player = ExoPlayerFactory.newSimpleInstance(context, trackSelector);
-
-    // Bind the player to the view.
+    player = ExoPlayerFactory.newSimpleInstance(context);
+    adsLoader.setPlayer(player);
     playerView.setPlayer(player);
 
     // This is the MediaSource representing the content media (i.e. not the ad).
@@ -73,10 +64,7 @@ public void init(Context context, PlayerView playerView) {
     // Compose the content media source into a new AdsMediaSource with both ads and content.
     MediaSource mediaSourceWithAds =
         new AdsMediaSource(
-            contentMediaSource,
-            /* adMediaSourceFactory= */ this,
-            adsLoader,
-            playerView.getOverlayFrameLayout());
+            contentMediaSource, /* adMediaSourceFactory= */ this, adsLoader, playerView);
 
     // Prepare the player with the source.
     player.seekTo(contentPosition);
@@ -89,6 +77,7 @@ public void reset() {
       contentPosition = player.getContentPosition();
       player.release();
       player = null;
+      adsLoader.setPlayer(null);
     }
   }
 
@@ -125,7 +114,7 @@ private MediaSource buildMediaSource(Uri uri) {
       case C.TYPE_HLS:
         return new HlsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_OTHER:
-        return new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
+        return new ProgressiveMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       default:
         throw new IllegalStateException("Unsupported type: " + type);
     }
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index c516ba297f..7089d4d731 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -26,7 +25,7 @@ android {
     defaultConfig {
         versionName project.ext.releaseVersion
         versionCode project.ext.releaseVersionCode
-        minSdkVersion 16
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
 
@@ -45,8 +44,9 @@ android {
     }
 
     lintOptions {
-        // The demo app does not have translations.
-        disable 'MissingTranslation'
+        // The demo app isn't indexed, doesn't have translations, and has a
+        // banner for AndroidTV that's only in xhdpi density.
+        disable 'GoogleAppIndexingWarning','MissingTranslation','IconDensities'
     }
 
     flavorDimensions "extensions"
@@ -62,7 +62,10 @@ android {
 }
 
 dependencies {
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.legacy:legacy-support-core-ui:1.0.0'
+    implementation 'androidx.fragment:fragment:1.0.0'
+    implementation 'com.google.android.material:material:1.0.0'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-dash')
     implementation project(modulePrefix + 'library-hls')
diff --git a/demos/main/src/main/AndroidManifest.xml b/demos/main/src/main/AndroidManifest.xml
index e80e37688d..355ba43405 100644
--- a/demos/main/src/main/AndroidManifest.xml
+++ b/demos/main/src/main/AndroidManifest.xml
@@ -15,6 +15,7 @@
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.demo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -33,11 +34,13 @@
       android:banner="@drawable/ic_banner"
       android:largeHeap="true"
       android:allowBackup="false"
-      android:name="com.google.android.exoplayer2.demo.DemoApplication">
+      android:name="com.google.android.exoplayer2.demo.DemoApplication"
+      tools:ignore="UnusedAttribute">
 
     <activity android:name="com.google.android.exoplayer2.demo.SampleChooserActivity"
         android:configChanges="keyboardHidden"
-        android:label="@string/application_name">
+        android:label="@string/application_name"
+        android:theme="@style/Theme.AppCompat">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
         <category android:name="android.intent.category.LAUNCHER"/>
diff --git a/demos/main/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
index c2acf3990b..bcb3ef4ad1 100644
--- a/demos/main/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -330,11 +330,11 @@
     "samples": [
       {
         "name": "Super speed",
-        "uri": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism"
+        "uri": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism/Manifest"
       },
       {
         "name": "Super speed (PlayReady)",
-        "uri": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
+        "uri": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism/Manifest",
         "drm_scheme": "playready"
       }
     ]
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index ac8be7dc16..6985d42b36 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -16,6 +16,13 @@
 package com.google.android.exoplayer2.demo;
 
 import android.app.Application;
+import com.google.android.exoplayer2.DefaultRenderersFactory;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.database.DatabaseProvider;
+import com.google.android.exoplayer2.database.ExoDatabaseProvider;
+import com.google.android.exoplayer2.offline.ActionFileUpgradeUtil;
+import com.google.android.exoplayer2.offline.DefaultDownloadIndex;
+import com.google.android.exoplayer2.offline.DefaultDownloaderFactory;
 import com.google.android.exoplayer2.offline.DownloadManager;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -28,21 +35,24 @@
 import com.google.android.exoplayer2.upstream.cache.CacheDataSourceFactory;
 import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
 import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
+import java.io.IOException;
 
 /**
  * Placeholder application to facilitate overriding Application methods for debugging and testing.
  */
 public class DemoApplication extends Application {
 
+  private static final String TAG = "DemoApplication";
   private static final String DOWNLOAD_ACTION_FILE = "actions";
   private static final String DOWNLOAD_TRACKER_ACTION_FILE = "tracked_actions";
   private static final String DOWNLOAD_CONTENT_DIRECTORY = "downloads";
-  private static final int MAX_SIMULTANEOUS_DOWNLOADS = 2;
 
   protected String userAgent;
 
+  private DatabaseProvider databaseProvider;
   private File downloadDirectory;
   private Cache downloadCache;
   private DownloadManager downloadManager;
@@ -71,6 +81,18 @@ public boolean useExtensionRenderers() {
     return "withExtensions".equals(BuildConfig.FLAVOR);
   }
 
+  public RenderersFactory buildRenderersFactory(boolean preferExtensionRenderer) {
+    @DefaultRenderersFactory.ExtensionRendererMode
+    int extensionRendererMode =
+        useExtensionRenderers()
+            ? (preferExtensionRenderer
+                ? DefaultRenderersFactory.EXTENSION_RENDERER_MODE_PREFER
+                : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
+            : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF;
+    return new DefaultRenderersFactory(/* context= */ this)
+        .setExtensionRendererMode(extensionRendererMode);
+  }
+
   public DownloadManager getDownloadManager() {
     initDownloadManager();
     return downloadManager;
@@ -81,31 +103,51 @@ public DownloadTracker getDownloadTracker() {
     return downloadTracker;
   }
 
+  protected synchronized Cache getDownloadCache() {
+    if (downloadCache == null) {
+      File downloadContentDirectory = new File(getDownloadDirectory(), DOWNLOAD_CONTENT_DIRECTORY);
+      downloadCache =
+          new SimpleCache(downloadContentDirectory, new NoOpCacheEvictor(), getDatabaseProvider());
+    }
+    return downloadCache;
+  }
+
   private synchronized void initDownloadManager() {
     if (downloadManager == null) {
+      DefaultDownloadIndex downloadIndex = new DefaultDownloadIndex(getDatabaseProvider());
+      upgradeActionFile(
+          DOWNLOAD_ACTION_FILE, downloadIndex, /* addNewDownloadsAsCompleted= */ false);
+      upgradeActionFile(
+          DOWNLOAD_TRACKER_ACTION_FILE, downloadIndex, /* addNewDownloadsAsCompleted= */ true);
       DownloaderConstructorHelper downloaderConstructorHelper =
           new DownloaderConstructorHelper(getDownloadCache(), buildHttpDataSourceFactory());
       downloadManager =
           new DownloadManager(
-              downloaderConstructorHelper,
-              MAX_SIMULTANEOUS_DOWNLOADS,
-              DownloadManager.DEFAULT_MIN_RETRY_COUNT,
-              new File(getDownloadDirectory(), DOWNLOAD_ACTION_FILE));
+              this, downloadIndex, new DefaultDownloaderFactory(downloaderConstructorHelper));
       downloadTracker =
-          new DownloadTracker(
-              /* context= */ this,
-              buildDataSourceFactory(),
-              new File(getDownloadDirectory(), DOWNLOAD_TRACKER_ACTION_FILE));
-      downloadManager.addListener(downloadTracker);
+          new DownloadTracker(/* context= */ this, buildDataSourceFactory(), downloadManager);
     }
   }
 
-  private synchronized Cache getDownloadCache() {
-    if (downloadCache == null) {
-      File downloadContentDirectory = new File(getDownloadDirectory(), DOWNLOAD_CONTENT_DIRECTORY);
-      downloadCache = new SimpleCache(downloadContentDirectory, new NoOpCacheEvictor());
+  private void upgradeActionFile(
+      String fileName, DefaultDownloadIndex downloadIndex, boolean addNewDownloadsAsCompleted) {
+    try {
+      ActionFileUpgradeUtil.upgradeAndDelete(
+          new File(getDownloadDirectory(), fileName),
+          /* downloadIdProvider= */ null,
+          downloadIndex,
+          /* deleteOnFailure= */ true,
+          addNewDownloadsAsCompleted);
+    } catch (IOException e) {
+      Log.e(TAG, "Failed to upgrade action file: " + fileName, e);
     }
-    return downloadCache;
+  }
+
+  private DatabaseProvider getDatabaseProvider() {
+    if (databaseProvider == null) {
+      databaseProvider = new ExoDatabaseProvider(this);
+    }
+    return databaseProvider;
   }
 
   private File getDownloadDirectory() {
@@ -118,8 +160,8 @@ private File getDownloadDirectory() {
     return downloadDirectory;
   }
 
-  private static CacheDataSourceFactory buildReadOnlyCacheDataSource(
-      DefaultDataSourceFactory upstreamFactory, Cache cache) {
+  protected static CacheDataSourceFactory buildReadOnlyCacheDataSource(
+      DataSource.Factory upstreamFactory, Cache cache) {
     return new CacheDataSourceFactory(
         cache,
         upstreamFactory,
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
index 7d1ab16ce4..3886ef5c44 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
@@ -16,13 +16,14 @@
 package com.google.android.exoplayer2.demo;
 
 import android.app.Notification;
+import com.google.android.exoplayer2.offline.Download;
 import com.google.android.exoplayer2.offline.DownloadManager;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
 import com.google.android.exoplayer2.offline.DownloadService;
 import com.google.android.exoplayer2.scheduler.PlatformScheduler;
-import com.google.android.exoplayer2.ui.DownloadNotificationUtil;
+import com.google.android.exoplayer2.ui.DownloadNotificationHelper;
 import com.google.android.exoplayer2.util.NotificationUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.util.List;
 
 /** A service for downloading media. */
 public class DemoDownloadService extends DownloadService {
@@ -31,12 +32,23 @@
   private static final int JOB_ID = 1;
   private static final int FOREGROUND_NOTIFICATION_ID = 1;
 
+  private static int nextNotificationId = FOREGROUND_NOTIFICATION_ID + 1;
+
+  private DownloadNotificationHelper notificationHelper;
+
   public DemoDownloadService() {
     super(
         FOREGROUND_NOTIFICATION_ID,
         DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL,
         CHANNEL_ID,
         R.string.exo_download_notification_channel_name);
+    nextNotificationId = FOREGROUND_NOTIFICATION_ID + 1;
+  }
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    notificationHelper = new DownloadNotificationHelper(this, CHANNEL_ID);
   }
 
   @Override
@@ -50,40 +62,29 @@ protected PlatformScheduler getScheduler() {
   }
 
   @Override
-  protected Notification getForegroundNotification(TaskState[] taskStates) {
-    return DownloadNotificationUtil.buildProgressNotification(
-        /* context= */ this,
-        R.drawable.exo_controls_play,
-        CHANNEL_ID,
-        /* contentIntent= */ null,
-        /* message= */ null,
-        taskStates);
+  protected Notification getForegroundNotification(List<Download> downloads) {
+    return notificationHelper.buildProgressNotification(
+        R.drawable.ic_download, /* contentIntent= */ null, /* message= */ null, downloads);
   }
 
   @Override
-  protected void onTaskStateChanged(TaskState taskState) {
-    if (taskState.action.isRemoveAction) {
-      return;
-    }
-    Notification notification = null;
-    if (taskState.state == TaskState.STATE_COMPLETED) {
+  protected void onDownloadChanged(Download download) {
+    Notification notification;
+    if (download.state == Download.STATE_COMPLETED) {
       notification =
-          DownloadNotificationUtil.buildDownloadCompletedNotification(
-              /* context= */ this,
-              R.drawable.exo_controls_play,
-              CHANNEL_ID,
+          notificationHelper.buildDownloadCompletedNotification(
+              R.drawable.ic_download_done,
               /* contentIntent= */ null,
-              Util.fromUtf8Bytes(taskState.action.data));
-    } else if (taskState.state == TaskState.STATE_FAILED) {
+              Util.fromUtf8Bytes(download.request.data));
+    } else if (download.state == Download.STATE_FAILED) {
       notification =
-          DownloadNotificationUtil.buildDownloadFailedNotification(
-              /* context= */ this,
-              R.drawable.exo_controls_play,
-              CHANNEL_ID,
+          notificationHelper.buildDownloadFailedNotification(
+              R.drawable.ic_download_done,
               /* contentIntent= */ null,
-              Util.fromUtf8Bytes(taskState.action.data));
+              Util.fromUtf8Bytes(download.request.data));
+    } else {
+      return;
     }
-    int notificationId = FOREGROUND_NOTIFICATION_ID + 1 + taskState.taskId;
-    NotificationUtil.setNotification(this, notificationId, notification);
+    NotificationUtil.setNotification(this, nextNotificationId++, notification);
   }
 }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
index b0619a82fd..f372a47df6 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
@@ -15,54 +15,34 @@
  */
 package com.google.android.exoplayer2.demo;
 
-import android.app.Activity;
-import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.net.Uri;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.FragmentManager;
 import android.widget.Toast;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.offline.ActionFile;
-import com.google.android.exoplayer2.offline.DownloadAction;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.offline.Download;
+import com.google.android.exoplayer2.offline.DownloadCursor;
 import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.DownloadIndex;
 import com.google.android.exoplayer2.offline.DownloadManager;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
+import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.offline.DownloadService;
-import com.google.android.exoplayer2.offline.ProgressiveDownloadHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.offline.TrackKey;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.dash.offline.DashDownloadHelper;
-import com.google.android.exoplayer2.source.hls.offline.HlsDownloadHelper;
-import com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadHelper;
-import com.google.android.exoplayer2.ui.DefaultTrackNameProvider;
-import com.google.android.exoplayer2.ui.TrackNameProvider;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
-import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-/**
- * Tracks media that has been downloaded.
- *
- * <p>Tracked downloads are persisted using an {@link ActionFile}, however in a real application
- * it's expected that state will be stored directly in the application's media database, so that it
- * can be queried efficiently together with other information about the media.
- */
-public class DownloadTracker implements DownloadManager.Listener {
+/** Tracks media that has been downloaded. */
+public class DownloadTracker {
 
   /** Listens for changes in the tracked downloads. */
   public interface Listener {
@@ -75,28 +55,21 @@
 
   private final Context context;
   private final DataSource.Factory dataSourceFactory;
-  private final TrackNameProvider trackNameProvider;
   private final CopyOnWriteArraySet<Listener> listeners;
-  private final HashMap<Uri, DownloadAction> trackedDownloadStates;
-  private final ActionFile actionFile;
-  private final Handler actionFileWriteHandler;
+  private final HashMap<Uri, Download> downloads;
+  private final DownloadIndex downloadIndex;
+
+  @Nullable private StartDownloadDialogHelper startDownloadDialogHelper;
 
   public DownloadTracker(
-      Context context,
-      DataSource.Factory dataSourceFactory,
-      File actionFile,
-      DownloadAction.Deserializer... deserializers) {
+      Context context, DataSource.Factory dataSourceFactory, DownloadManager downloadManager) {
     this.context = context.getApplicationContext();
     this.dataSourceFactory = dataSourceFactory;
-    this.actionFile = new ActionFile(actionFile);
-    trackNameProvider = new DefaultTrackNameProvider(context.getResources());
     listeners = new CopyOnWriteArraySet<>();
-    trackedDownloadStates = new HashMap<>();
-    HandlerThread actionFileWriteThread = new HandlerThread("DownloadTracker");
-    actionFileWriteThread.start();
-    actionFileWriteHandler = new Handler(actionFileWriteThread.getLooper());
-    loadTrackedActions(
-        deserializers.length > 0 ? deserializers : DownloadAction.getDefaultDeserializers());
+    downloads = new HashMap<>();
+    downloadIndex = downloadManager.getDownloadIndex();
+    downloadManager.addListener(new DownloadManagerListener());
+    loadDownloads();
   }
 
   public void addListener(Listener listener) {
@@ -108,167 +81,139 @@ public void removeListener(Listener listener) {
   }
 
   public boolean isDownloaded(Uri uri) {
-    return trackedDownloadStates.containsKey(uri);
+    Download download = downloads.get(uri);
+    return download != null && download.state != Download.STATE_FAILED;
   }
 
   @SuppressWarnings("unchecked")
   public List<StreamKey> getOfflineStreamKeys(Uri uri) {
-    if (!trackedDownloadStates.containsKey(uri)) {
-      return Collections.emptyList();
-    }
-    return trackedDownloadStates.get(uri).getKeys();
+    Download download = downloads.get(uri);
+    return download != null && download.state != Download.STATE_FAILED
+        ? download.request.streamKeys
+        : Collections.emptyList();
   }
 
-  public void toggleDownload(Activity activity, String name, Uri uri, String extension) {
-    if (isDownloaded(uri)) {
-      DownloadAction removeAction =
-          getDownloadHelper(uri, extension).getRemoveAction(Util.getUtf8Bytes(name));
-      startServiceWithAction(removeAction);
+  public void toggleDownload(
+      FragmentManager fragmentManager,
+      String name,
+      Uri uri,
+      String extension,
+      RenderersFactory renderersFactory) {
+    Download download = downloads.get(uri);
+    if (download != null) {
+      DownloadService.sendRemoveDownload(
+          context, DemoDownloadService.class, download.request.id, /* foreground= */ false);
     } else {
-      StartDownloadDialogHelper helper =
-          new StartDownloadDialogHelper(activity, getDownloadHelper(uri, extension), name);
-      helper.prepare();
-    }
-  }
-
-  // DownloadManager.Listener
-
-  @Override
-  public void onInitialized(DownloadManager downloadManager) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onTaskStateChanged(DownloadManager downloadManager, TaskState taskState) {
-    DownloadAction action = taskState.action;
-    Uri uri = action.uri;
-    if ((action.isRemoveAction && taskState.state == TaskState.STATE_COMPLETED)
-        || (!action.isRemoveAction && taskState.state == TaskState.STATE_FAILED)) {
-      // A download has been removed, or has failed. Stop tracking it.
-      if (trackedDownloadStates.remove(uri) != null) {
-        handleTrackedDownloadStatesChanged();
+      if (startDownloadDialogHelper != null) {
+        startDownloadDialogHelper.release();
       }
+      startDownloadDialogHelper =
+          new StartDownloadDialogHelper(
+              fragmentManager, getDownloadHelper(uri, extension, renderersFactory), name);
     }
   }
 
-  @Override
-  public void onIdle(DownloadManager downloadManager) {
-    // Do nothing.
-  }
-
-  // Internal methods
-
-  private void loadTrackedActions(DownloadAction.Deserializer[] deserializers) {
-    try {
-      DownloadAction[] allActions = actionFile.load(deserializers);
-      for (DownloadAction action : allActions) {
-        trackedDownloadStates.put(action.uri, action);
+  private void loadDownloads() {
+    try (DownloadCursor loadedDownloads = downloadIndex.getDownloads()) {
+      while (loadedDownloads.moveToNext()) {
+        Download download = loadedDownloads.getDownload();
+        downloads.put(download.request.uri, download);
       }
     } catch (IOException e) {
-      Log.e(TAG, "Failed to load tracked actions", e);
+      Log.w(TAG, "Failed to query downloads", e);
     }
   }
 
-  private void handleTrackedDownloadStatesChanged() {
-    for (Listener listener : listeners) {
-      listener.onDownloadsChanged();
-    }
-    final DownloadAction[] actions = trackedDownloadStates.values().toArray(new DownloadAction[0]);
-    actionFileWriteHandler.post(
-        () -> {
-          try {
-            actionFile.store(actions);
-          } catch (IOException e) {
-            Log.e(TAG, "Failed to store tracked actions", e);
-          }
-        });
-  }
-
-  private void startDownload(DownloadAction action) {
-    if (trackedDownloadStates.containsKey(action.uri)) {
-      // This content is already being downloaded. Do nothing.
-      return;
-    }
-    trackedDownloadStates.put(action.uri, action);
-    handleTrackedDownloadStatesChanged();
-    startServiceWithAction(action);
-  }
-
-  private void startServiceWithAction(DownloadAction action) {
-    DownloadService.startWithAction(context, DemoDownloadService.class, action, false);
-  }
-
-  private DownloadHelper getDownloadHelper(Uri uri, String extension) {
+  private DownloadHelper getDownloadHelper(
+      Uri uri, String extension, RenderersFactory renderersFactory) {
     int type = Util.inferContentType(uri, extension);
     switch (type) {
       case C.TYPE_DASH:
-        return new DashDownloadHelper(uri, dataSourceFactory);
+        return DownloadHelper.forDash(uri, dataSourceFactory, renderersFactory);
       case C.TYPE_SS:
-        return new SsDownloadHelper(uri, dataSourceFactory);
+        return DownloadHelper.forSmoothStreaming(uri, dataSourceFactory, renderersFactory);
       case C.TYPE_HLS:
-        return new HlsDownloadHelper(uri, dataSourceFactory);
+        return DownloadHelper.forHls(uri, dataSourceFactory, renderersFactory);
       case C.TYPE_OTHER:
-        return new ProgressiveDownloadHelper(uri);
+        return DownloadHelper.forProgressive(uri);
       default:
         throw new IllegalStateException("Unsupported type: " + type);
     }
   }
 
+  private class DownloadManagerListener implements DownloadManager.Listener {
+
+    @Override
+    public void onDownloadChanged(DownloadManager downloadManager, Download download) {
+      downloads.put(download.request.uri, download);
+      for (Listener listener : listeners) {
+        listener.onDownloadsChanged();
+      }
+    }
+
+    @Override
+    public void onDownloadRemoved(DownloadManager downloadManager, Download download) {
+      downloads.remove(download.request.uri);
+      for (Listener listener : listeners) {
+        listener.onDownloadsChanged();
+      }
+    }
+  }
+
   private final class StartDownloadDialogHelper
-      implements DownloadHelper.Callback, DialogInterface.OnClickListener {
+      implements DownloadHelper.Callback,
+          DialogInterface.OnClickListener,
+          DialogInterface.OnDismissListener {
 
+    private final FragmentManager fragmentManager;
     private final DownloadHelper downloadHelper;
     private final String name;
 
-    private final AlertDialog.Builder builder;
-    private final View dialogView;
-    private final List<TrackKey> trackKeys;
-    private final ArrayAdapter<String> trackTitles;
-    private final ListView representationList;
+    private TrackSelectionDialog trackSelectionDialog;
+    private MappedTrackInfo mappedTrackInfo;
 
     public StartDownloadDialogHelper(
-        Activity activity, DownloadHelper downloadHelper, String name) {
+        FragmentManager fragmentManager, DownloadHelper downloadHelper, String name) {
+      this.fragmentManager = fragmentManager;
       this.downloadHelper = downloadHelper;
       this.name = name;
-      builder =
-          new AlertDialog.Builder(activity)
-              .setTitle(R.string.exo_download_description)
-              .setPositiveButton(android.R.string.ok, this)
-              .setNegativeButton(android.R.string.cancel, null);
-
-      // Inflate with the builder's context to ensure the correct style is used.
-      LayoutInflater dialogInflater = LayoutInflater.from(builder.getContext());
-      dialogView = dialogInflater.inflate(R.layout.start_download_dialog, null);
-
-      trackKeys = new ArrayList<>();
-      trackTitles =
-          new ArrayAdapter<>(
-              builder.getContext(), android.R.layout.simple_list_item_multiple_choice);
-      representationList = dialogView.findViewById(R.id.representation_list);
-      representationList.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
-      representationList.setAdapter(trackTitles);
+      downloadHelper.prepare(this);
     }
 
-    public void prepare() {
-      downloadHelper.prepare(this);
+    public void release() {
+      downloadHelper.release();
+      if (trackSelectionDialog != null) {
+        trackSelectionDialog.dismiss();
+      }
     }
 
+    // DownloadHelper.Callback implementation.
+
     @Override
     public void onPrepared(DownloadHelper helper) {
-      for (int i = 0; i < downloadHelper.getPeriodCount(); i++) {
-        TrackGroupArray trackGroups = downloadHelper.getTrackGroups(i);
-        for (int j = 0; j < trackGroups.length; j++) {
-          TrackGroup trackGroup = trackGroups.get(j);
-          for (int k = 0; k < trackGroup.length; k++) {
-            trackKeys.add(new TrackKey(i, j, k));
-            trackTitles.add(trackNameProvider.getTrackName(trackGroup.getFormat(k)));
-          }
-        }
+      if (helper.getPeriodCount() == 0) {
+        Log.d(TAG, "No periods found. Downloading entire stream.");
+        startDownload();
+        downloadHelper.release();
+        return;
       }
-      if (!trackKeys.isEmpty()) {
-        builder.setView(dialogView);
+      mappedTrackInfo = downloadHelper.getMappedTrackInfo(/* periodIndex= */ 0);
+      if (!TrackSelectionDialog.willHaveContent(mappedTrackInfo)) {
+        Log.d(TAG, "No dialog content. Downloading entire stream.");
+        startDownload();
+        downloadHelper.release();
+        return;
       }
-      builder.create().show();
+      trackSelectionDialog =
+          TrackSelectionDialog.createForMappedTrackInfoAndParameters(
+              /* titleId= */ R.string.exo_download_description,
+              mappedTrackInfo,
+              /* initialParameters= */ DownloadHelper.DEFAULT_TRACK_SELECTOR_PARAMETERS,
+              /* allowAdaptiveSelections =*/ false,
+              /* allowMultipleOverrides= */ true,
+              /* onClickListener= */ this,
+              /* onDismissListener= */ this);
+      trackSelectionDialog.show(fragmentManager, /* tag= */ null);
     }
 
     @Override
@@ -279,20 +224,51 @@ public void onPrepareError(DownloadHelper helper, IOException e) {
       Log.e(TAG, "Failed to start download", e);
     }
 
+    // DialogInterface.OnClickListener implementation.
+
     @Override
     public void onClick(DialogInterface dialog, int which) {
-      ArrayList<TrackKey> selectedTrackKeys = new ArrayList<>();
-      for (int i = 0; i < representationList.getChildCount(); i++) {
-        if (representationList.isItemChecked(i)) {
-          selectedTrackKeys.add(trackKeys.get(i));
+      for (int periodIndex = 0; periodIndex < downloadHelper.getPeriodCount(); periodIndex++) {
+        downloadHelper.clearTrackSelections(periodIndex);
+        for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
+          if (!trackSelectionDialog.getIsDisabled(/* rendererIndex= */ i)) {
+            downloadHelper.addTrackSelectionForSingleRenderer(
+                periodIndex,
+                /* rendererIndex= */ i,
+                DownloadHelper.DEFAULT_TRACK_SELECTOR_PARAMETERS,
+                trackSelectionDialog.getOverrides(/* rendererIndex= */ i));
+          }
         }
       }
-      if (!selectedTrackKeys.isEmpty() || trackKeys.isEmpty()) {
-        // We have selected keys, or we're dealing with single stream content.
-        DownloadAction downloadAction =
-            downloadHelper.getDownloadAction(Util.getUtf8Bytes(name), selectedTrackKeys);
-        startDownload(downloadAction);
+      DownloadRequest downloadRequest = buildDownloadRequest();
+      if (downloadRequest.streamKeys.isEmpty()) {
+        // All tracks were deselected in the dialog. Don't start the download.
+        return;
       }
+      startDownload(downloadRequest);
+    }
+
+    // DialogInterface.OnDismissListener implementation.
+
+    @Override
+    public void onDismiss(DialogInterface dialogInterface) {
+      trackSelectionDialog = null;
+      downloadHelper.release();
+    }
+
+    // Internal methods.
+
+    private void startDownload() {
+      startDownload(buildDownloadRequest());
+    }
+
+    private void startDownload(DownloadRequest downloadRequest) {
+      DownloadService.sendAddDownload(
+          context, DemoDownloadService.class, downloadRequest, /* foreground= */ false);
+    }
+
+    private DownloadRequest buildDownloadRequest() {
+      return downloadHelper.getDownloadRequest(Util.getUtf8Bytes(name));
     }
   }
 }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index ffa9bafa4f..acb24adebe 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -15,31 +15,28 @@
  */
 package com.google.android.exoplayer2.demo;
 
-import android.app.Activity;
-import android.app.AlertDialog;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.appcompat.app.AppCompatActivity;
 import android.util.Pair;
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
-import android.view.ViewGroup;
 import android.widget.Button;
-import android.widget.FrameLayout;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 import android.widget.Toast;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.ContentType;
-import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -48,21 +45,17 @@
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
-import com.google.android.exoplayer2.offline.FilteringManifestParser;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
@@ -72,7 +65,6 @@
 import com.google.android.exoplayer2.ui.DebugTextViewHelper;
 import com.google.android.exoplayer2.ui.PlayerControlView;
 import com.google.android.exoplayer2.ui.PlayerView;
-import com.google.android.exoplayer2.ui.TrackSelectionView;
 import com.google.android.exoplayer2.ui.spherical.SphericalSurfaceView;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
@@ -87,7 +79,7 @@
 import java.util.UUID;
 
 /** An activity that plays media using {@link SimpleExoPlayer}. */
-public class PlayerActivity extends Activity
+public class PlayerActivity extends AppCompatActivity
     implements OnClickListener, PlaybackPreparer, PlayerControlView.VisibilityListener {
 
   public static final String DRM_SCHEME_EXTRA = "drm_scheme";
@@ -132,7 +124,9 @@
 
   private PlayerView playerView;
   private LinearLayout debugRootView;
+  private Button selectTracksButton;
   private TextView debugTextView;
+  private boolean isShowingTrackSelectionDialog;
 
   private DataSource.Factory dataSourceFactory;
   private SimpleExoPlayer player;
@@ -151,7 +145,6 @@
 
   private AdsLoader adsLoader;
   private Uri loadedAdTagUri;
-  private ViewGroup adUiViewGroup;
 
   // Activity lifecycle
 
@@ -168,10 +161,10 @@ public void onCreate(Bundle savedInstanceState) {
     }
 
     setContentView(R.layout.player_activity);
-    View rootView = findViewById(R.id.root);
-    rootView.setOnClickListener(this);
     debugRootView = findViewById(R.id.controls_root);
     debugTextView = findViewById(R.id.debug_text_view);
+    selectTracksButton = findViewById(R.id.select_tracks_button);
+    selectTracksButton.setOnClickListener(this);
 
     playerView = findViewById(R.id.player_view);
     playerView.setControllerVisibilityListener(this);
@@ -206,6 +199,7 @@ public void onCreate(Bundle savedInstanceState) {
 
   @Override
   public void onNewIntent(Intent intent) {
+    super.onNewIntent(intent);
     releasePlayer();
     releaseAdsLoader();
     clearStartPosition();
@@ -280,6 +274,7 @@ public void onRequestPermissionsResult(int requestCode, @NonNull String[] permis
 
   @Override
   public void onSaveInstanceState(Bundle outState) {
+    super.onSaveInstanceState(outState);
     updateTrackSelectorParameters();
     updateStartPosition();
     outState.putParcelable(KEY_TRACK_SELECTOR_PARAMETERS, trackSelectorParameters);
@@ -300,23 +295,15 @@ public boolean dispatchKeyEvent(KeyEvent event) {
 
   @Override
   public void onClick(View view) {
-    if (view.getParent() == debugRootView) {
-      MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
-      if (mappedTrackInfo != null) {
-        CharSequence title = ((Button) view).getText();
-        int rendererIndex = (int) view.getTag();
-        int rendererType = mappedTrackInfo.getRendererType(rendererIndex);
-        boolean allowAdaptiveSelections =
-            rendererType == C.TRACK_TYPE_VIDEO
-                || (rendererType == C.TRACK_TYPE_AUDIO
-                    && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
-                        == MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);
-        Pair<AlertDialog, TrackSelectionView> dialogPair =
-            TrackSelectionView.getDialog(this, title, trackSelector, rendererIndex);
-        dialogPair.second.setShowDisableOption(true);
-        dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);
-        dialogPair.first.show();
-      }
+    if (view == selectTracksButton
+        && !isShowingTrackSelectionDialog
+        && TrackSelectionDialog.willHaveContent(trackSelector)) {
+      isShowingTrackSelectionDialog = true;
+      TrackSelectionDialog trackSelectionDialog =
+          TrackSelectionDialog.createForTrackSelector(
+              trackSelector,
+              /* onDismissListener= */ dismissedDialog -> isShowingTrackSelectionDialog = false);
+      trackSelectionDialog.show(getSupportFragmentManager(), /* tag= */ null);
     }
   }
 
@@ -324,7 +311,7 @@ public void onClick(View view) {
 
   @Override
   public void preparePlayback() {
-    initializePlayer();
+    player.retry();
   }
 
   // PlaybackControlView.VisibilityListener implementation
@@ -416,13 +403,8 @@ private void initializePlayer() {
 
       boolean preferExtensionDecoders =
           intent.getBooleanExtra(PREFER_EXTENSION_DECODERS_EXTRA, false);
-      @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode =
-          ((DemoApplication) getApplication()).useExtensionRenderers()
-              ? (preferExtensionDecoders ? DefaultRenderersFactory.EXTENSION_RENDERER_MODE_PREFER
-              : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
-              : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF;
-      DefaultRenderersFactory renderersFactory =
-          new DefaultRenderersFactory(this, extensionRendererMode);
+      RenderersFactory renderersFactory =
+          ((DemoApplication) getApplication()).buildRenderersFactory(preferExtensionDecoders);
 
       trackSelector = new DefaultTrackSelector(trackSelectionFactory);
       trackSelector.setParameters(trackSelectorParameters);
@@ -467,34 +449,31 @@ private void initializePlayer() {
       player.seekTo(startWindow, startPosition);
     }
     player.prepare(mediaSource, !haveStartPosition, false);
-    updateButtonVisibilities();
+    updateButtonVisibility();
   }
 
   private MediaSource buildMediaSource(Uri uri) {
     return buildMediaSource(uri, null);
   }
 
-  @SuppressWarnings("unchecked")
   private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
     @ContentType int type = Util.inferContentType(uri, overrideExtension);
+    List<StreamKey> offlineStreamKeys = getOfflineStreamKeys(uri);
     switch (type) {
       case C.TYPE_DASH:
         return new DashMediaSource.Factory(dataSourceFactory)
-            .setManifestParser(
-                new FilteringManifestParser<>(new DashManifestParser(), getOfflineStreamKeys(uri)))
+            .setStreamKeys(offlineStreamKeys)
             .createMediaSource(uri);
       case C.TYPE_SS:
         return new SsMediaSource.Factory(dataSourceFactory)
-            .setManifestParser(
-                new FilteringManifestParser<>(new SsManifestParser(), getOfflineStreamKeys(uri)))
+            .setStreamKeys(offlineStreamKeys)
             .createMediaSource(uri);
       case C.TYPE_HLS:
         return new HlsMediaSource.Factory(dataSourceFactory)
-            .setPlaylistParserFactory(
-                new DefaultHlsPlaylistParserFactory(getOfflineStreamKeys(uri)))
+            .setStreamKeys(offlineStreamKeys)
             .createMediaSource(uri);
       case C.TYPE_OTHER:
-        return new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
+        return new ProgressiveMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       default: {
         throw new IllegalStateException("Unsupported type: " + type);
       }
@@ -534,6 +513,9 @@ private void releasePlayer() {
       mediaSource = null;
       trackSelector = null;
     }
+    if (adsLoader != null) {
+      adsLoader.setPlayer(null);
+    }
     releaseMediaDrm();
   }
 
@@ -593,10 +575,8 @@ private void clearStartPosition() {
                 .getConstructor(android.content.Context.class, android.net.Uri.class);
         // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
         adsLoader = loaderConstructor.newInstance(this, adTagUri);
-        adUiViewGroup = new FrameLayout(this);
-        // The demo app has a non-null overlay frame layout.
-        playerView.getOverlayFrameLayout().addView(adUiViewGroup);
       }
+      adsLoader.setPlayer(player);
       AdsMediaSource.MediaSourceFactory adMediaSourceFactory =
           new AdsMediaSource.MediaSourceFactory() {
             @Override
@@ -609,7 +589,7 @@ public MediaSource createMediaSource(Uri uri) {
               return new int[] {C.TYPE_DASH, C.TYPE_SS, C.TYPE_HLS, C.TYPE_OTHER};
             }
           };
-      return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, adUiViewGroup);
+      return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, playerView);
     } catch (ClassNotFoundException e) {
       // IMA extension not loaded.
       return null;
@@ -620,41 +600,9 @@ public MediaSource createMediaSource(Uri uri) {
 
   // User controls
 
-  private void updateButtonVisibilities() {
-    debugRootView.removeAllViews();
-    if (player == null) {
-      return;
-    }
-
-    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
-    if (mappedTrackInfo == null) {
-      return;
-    }
-
-    for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
-      TrackGroupArray trackGroups = mappedTrackInfo.getTrackGroups(i);
-      if (trackGroups.length != 0) {
-        Button button = new Button(this);
-        int label;
-        switch (player.getRendererType(i)) {
-          case C.TRACK_TYPE_AUDIO:
-            label = R.string.exo_track_selection_title_audio;
-            break;
-          case C.TRACK_TYPE_VIDEO:
-            label = R.string.exo_track_selection_title_video;
-            break;
-          case C.TRACK_TYPE_TEXT:
-            label = R.string.exo_track_selection_title_text;
-            break;
-          default:
-            continue;
-        }
-        button.setText(label);
-        button.setTag(i);
-        button.setOnClickListener(this);
-        debugRootView.addView(button);
-      }
-    }
+  private void updateButtonVisibility() {
+    selectTracksButton.setEnabled(
+        player != null && TrackSelectionDialog.willHaveContent(trackSelector));
   }
 
   private void showControls() {
@@ -690,16 +638,7 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       if (playbackState == Player.STATE_ENDED) {
         showControls();
       }
-      updateButtonVisibilities();
-    }
-
-    @Override
-    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
-      if (player.getPlaybackError() != null) {
-        // The user has performed a seek whilst in the error state. Update the resume position so
-        // that if the user then retries, playback resumes from the position to which they seeked.
-        updateStartPosition();
-      }
+      updateButtonVisibility();
     }
 
     @Override
@@ -708,8 +647,7 @@ public void onPlayerError(ExoPlaybackException e) {
         clearStartPosition();
         initializePlayer();
       } else {
-        updateStartPosition();
-        updateButtonVisibilities();
+        updateButtonVisibility();
         showControls();
       }
     }
@@ -717,7 +655,7 @@ public void onPlayerError(ExoPlaybackException e) {
     @Override
     @SuppressWarnings("ReferenceEquality")
     public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      updateButtonVisibilities();
+      updateButtonVisibility();
       if (trackGroups != lastSeenTrackGroupArray) {
         MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
         if (mappedTrackInfo != null) {
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index 6395ea4c24..7245de01c6 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -15,14 +15,14 @@
  */
 package com.google.android.exoplayer2.demo;
 
-import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Bundle;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.appcompat.app.AppCompatActivity;
 import android.util.JsonReader;
 import android.view.Menu;
 import android.view.MenuInflater;
@@ -37,6 +37,7 @@
 import android.widget.TextView;
 import android.widget.Toast;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.offline.DownloadService;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
@@ -54,7 +55,7 @@
 import java.util.List;
 
 /** An activity for selecting from a list of media samples. */
-public class SampleChooserActivity extends Activity
+public class SampleChooserActivity extends AppCompatActivity
     implements DownloadTracker.Listener, OnChildClickListener {
 
   private static final String TAG = "SampleChooserActivity";
@@ -177,7 +178,15 @@ private void onSampleDownloadButtonClicked(Sample sample) {
           .show();
     } else {
       UriSample uriSample = (UriSample) sample;
-      downloadTracker.toggleDownload(this, sample.name, uriSample.uri, uriSample.extension);
+      RenderersFactory renderersFactory =
+          ((DemoApplication) getApplication())
+              .buildRenderersFactory(isNonNullAndChecked(preferExtensionDecodersMenuItem));
+      downloadTracker.toggleDownload(
+          getSupportFragmentManager(),
+          sample.name,
+          uriSample.uri,
+          uriSample.extension,
+          renderersFactory);
     }
   }
 
@@ -350,8 +359,7 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
               ? null
               : new DrmInfo(drmScheme, drmLicenseUrl, drmKeyRequestProperties, drmMultiSession);
       if (playlistSamples != null) {
-        UriSample[] playlistSamplesArray = playlistSamples.toArray(
-            new UriSample[playlistSamples.size()]);
+        UriSample[] playlistSamplesArray = playlistSamples.toArray(new UriSample[0]);
         return new PlaylistSample(sampleName, drmInfo, playlistSamplesArray);
       } else {
         return new UriSample(
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
new file mode 100644
index 0000000000..a7dd1a0df8
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo;
+
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.content.res.Resources;
+import android.os.Bundle;
+import androidx.annotation.Nullable;
+import com.google.android.material.tabs.TabLayout;
+import androidx.fragment.app.DialogFragment;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentPagerAdapter;
+import androidx.viewpager.widget.ViewPager;
+import androidx.appcompat.app.AppCompatDialog;
+import android.util.SparseArray;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
+import com.google.android.exoplayer2.ui.TrackSelectionView;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/** Dialog to select tracks. */
+public final class TrackSelectionDialog extends DialogFragment {
+
+  private final SparseArray<TrackSelectionViewFragment> tabFragments;
+  private final ArrayList<Integer> tabTrackTypes;
+
+  private int titleId;
+  private DialogInterface.OnClickListener onClickListener;
+  private DialogInterface.OnDismissListener onDismissListener;
+
+  /**
+   * Returns whether a track selection dialog will have content to display if initialized with the
+   * specified {@link DefaultTrackSelector} in its current state.
+   */
+  public static boolean willHaveContent(DefaultTrackSelector trackSelector) {
+    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+    return mappedTrackInfo != null && willHaveContent(mappedTrackInfo);
+  }
+
+  /**
+   * Returns whether a track selection dialog will have content to display if initialized with the
+   * specified {@link MappedTrackInfo}.
+   */
+  public static boolean willHaveContent(MappedTrackInfo mappedTrackInfo) {
+    for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
+      if (showTabForRenderer(mappedTrackInfo, i)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Creates a dialog for a given {@link DefaultTrackSelector}, whose parameters will be
+   * automatically updated when tracks are selected.
+   *
+   * @param trackSelector The {@link DefaultTrackSelector}.
+   * @param onDismissListener A {@link DialogInterface.OnDismissListener} to call when the dialog is
+   *     dismissed.
+   */
+  public static TrackSelectionDialog createForTrackSelector(
+      DefaultTrackSelector trackSelector, DialogInterface.OnDismissListener onDismissListener) {
+    MappedTrackInfo mappedTrackInfo =
+        Assertions.checkNotNull(trackSelector.getCurrentMappedTrackInfo());
+    TrackSelectionDialog trackSelectionDialog = new TrackSelectionDialog();
+    DefaultTrackSelector.Parameters parameters = trackSelector.getParameters();
+    trackSelectionDialog.init(
+        /* titleId= */ R.string.track_selection_title,
+        mappedTrackInfo,
+        /* initialParameters = */ parameters,
+        /* allowAdaptiveSelections =*/ true,
+        /* allowMultipleOverrides= */ false,
+        /* onClickListener= */ (dialog, which) -> {
+          DefaultTrackSelector.ParametersBuilder builder = parameters.buildUpon();
+          for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
+            builder
+                .clearSelectionOverrides(/* rendererIndex= */ i)
+                .setRendererDisabled(
+                    /* rendererIndex= */ i,
+                    trackSelectionDialog.getIsDisabled(/* rendererIndex= */ i));
+            List<SelectionOverride> overrides =
+                trackSelectionDialog.getOverrides(/* rendererIndex= */ i);
+            if (!overrides.isEmpty()) {
+              builder.setSelectionOverride(
+                  /* rendererIndex= */ i,
+                  mappedTrackInfo.getTrackGroups(/* rendererIndex= */ i),
+                  overrides.get(0));
+            }
+          }
+          trackSelector.setParameters(builder);
+        },
+        onDismissListener);
+    return trackSelectionDialog;
+  }
+
+  /**
+   * Creates a dialog for given {@link MappedTrackInfo} and {@link DefaultTrackSelector.Parameters}.
+   *
+   * @param titleId The resource id of the dialog title.
+   * @param mappedTrackInfo The {@link MappedTrackInfo} to display.
+   * @param initialParameters The {@link DefaultTrackSelector.Parameters} describing the initial
+   *     track selection.
+   * @param allowAdaptiveSelections Whether adaptive selections (consisting of more than one track)
+   *     can be made.
+   * @param allowMultipleOverrides Whether tracks from multiple track groups can be selected.
+   * @param onClickListener {@link DialogInterface.OnClickListener} called when tracks are selected.
+   * @param onDismissListener {@link DialogInterface.OnDismissListener} called when the dialog is
+   *     dismissed.
+   */
+  public static TrackSelectionDialog createForMappedTrackInfoAndParameters(
+      int titleId,
+      MappedTrackInfo mappedTrackInfo,
+      DefaultTrackSelector.Parameters initialParameters,
+      boolean allowAdaptiveSelections,
+      boolean allowMultipleOverrides,
+      DialogInterface.OnClickListener onClickListener,
+      DialogInterface.OnDismissListener onDismissListener) {
+    TrackSelectionDialog trackSelectionDialog = new TrackSelectionDialog();
+    trackSelectionDialog.init(
+        titleId,
+        mappedTrackInfo,
+        initialParameters,
+        allowAdaptiveSelections,
+        allowMultipleOverrides,
+        onClickListener,
+        onDismissListener);
+    return trackSelectionDialog;
+  }
+
+  public TrackSelectionDialog() {
+    tabFragments = new SparseArray<>();
+    tabTrackTypes = new ArrayList<>();
+    // Retain instance across activity re-creation to prevent losing access to init data.
+    setRetainInstance(true);
+  }
+
+  private void init(
+      int titleId,
+      MappedTrackInfo mappedTrackInfo,
+      DefaultTrackSelector.Parameters initialParameters,
+      boolean allowAdaptiveSelections,
+      boolean allowMultipleOverrides,
+      DialogInterface.OnClickListener onClickListener,
+      DialogInterface.OnDismissListener onDismissListener) {
+    this.titleId = titleId;
+    this.onClickListener = onClickListener;
+    this.onDismissListener = onDismissListener;
+    for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
+      if (showTabForRenderer(mappedTrackInfo, i)) {
+        int trackType = mappedTrackInfo.getRendererType(/* rendererIndex= */ i);
+        TrackGroupArray trackGroupArray = mappedTrackInfo.getTrackGroups(i);
+        TrackSelectionViewFragment tabFragment = new TrackSelectionViewFragment();
+        tabFragment.init(
+            mappedTrackInfo,
+            /* rendererIndex= */ i,
+            initialParameters.getRendererDisabled(/* rendererIndex= */ i),
+            initialParameters.getSelectionOverride(/* rendererIndex= */ i, trackGroupArray),
+            allowAdaptiveSelections,
+            allowMultipleOverrides);
+        tabFragments.put(i, tabFragment);
+        tabTrackTypes.add(trackType);
+      }
+    }
+  }
+
+  /**
+   * Returns whether a renderer is disabled.
+   *
+   * @param rendererIndex Renderer index.
+   * @return Whether the renderer is disabled.
+   */
+  public boolean getIsDisabled(int rendererIndex) {
+    TrackSelectionViewFragment rendererView = tabFragments.get(rendererIndex);
+    return rendererView != null && rendererView.isDisabled;
+  }
+
+  /**
+   * Returns the list of selected track selection overrides for the specified renderer. There will
+   * be at most one override for each track group.
+   *
+   * @param rendererIndex Renderer index.
+   * @return The list of track selection overrides for this renderer.
+   */
+  public List<SelectionOverride> getOverrides(int rendererIndex) {
+    TrackSelectionViewFragment rendererView = tabFragments.get(rendererIndex);
+    return rendererView == null ? Collections.emptyList() : rendererView.overrides;
+  }
+
+  @Override
+  public Dialog onCreateDialog(Bundle savedInstanceState) {
+    // We need to own the view to let tab layout work correctly on all API levels. We can't use
+    // AlertDialog because it owns the view itself, so we use AppCompatDialog instead, themed using
+    // the AlertDialog theme overlay with force-enabled title.
+    AppCompatDialog dialog =
+        new AppCompatDialog(getActivity(), R.style.TrackSelectionDialogThemeOverlay);
+    dialog.setTitle(titleId);
+    return dialog;
+  }
+
+  @Override
+  public void onDismiss(DialogInterface dialog) {
+    super.onDismiss(dialog);
+    onDismissListener.onDismiss(dialog);
+  }
+
+  @Nullable
+  @Override
+  public View onCreateView(
+      LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
+
+    View dialogView = inflater.inflate(R.layout.track_selection_dialog, container, false);
+    TabLayout tabLayout = dialogView.findViewById(R.id.track_selection_dialog_tab_layout);
+    ViewPager viewPager = dialogView.findViewById(R.id.track_selection_dialog_view_pager);
+    Button cancelButton = dialogView.findViewById(R.id.track_selection_dialog_cancel_button);
+    Button okButton = dialogView.findViewById(R.id.track_selection_dialog_ok_button);
+    viewPager.setAdapter(new FragmentAdapter(getChildFragmentManager()));
+    tabLayout.setupWithViewPager(viewPager);
+    tabLayout.setVisibility(tabFragments.size() > 1 ? View.VISIBLE : View.GONE);
+    cancelButton.setOnClickListener(view -> dismiss());
+    okButton.setOnClickListener(
+        view -> {
+          onClickListener.onClick(getDialog(), DialogInterface.BUTTON_POSITIVE);
+          dismiss();
+        });
+    return dialogView;
+  }
+
+  private static boolean showTabForRenderer(MappedTrackInfo mappedTrackInfo, int rendererIndex) {
+    TrackGroupArray trackGroupArray = mappedTrackInfo.getTrackGroups(rendererIndex);
+    if (trackGroupArray.length == 0) {
+      return false;
+    }
+    int trackType = mappedTrackInfo.getRendererType(rendererIndex);
+    return isSupportedTrackType(trackType);
+  }
+
+  private static boolean isSupportedTrackType(int trackType) {
+    switch (trackType) {
+      case C.TRACK_TYPE_VIDEO:
+      case C.TRACK_TYPE_AUDIO:
+      case C.TRACK_TYPE_TEXT:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  private static String getTrackTypeString(Resources resources, int trackType) {
+    switch (trackType) {
+      case C.TRACK_TYPE_VIDEO:
+        return resources.getString(R.string.exo_track_selection_title_video);
+      case C.TRACK_TYPE_AUDIO:
+        return resources.getString(R.string.exo_track_selection_title_audio);
+      case C.TRACK_TYPE_TEXT:
+        return resources.getString(R.string.exo_track_selection_title_text);
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  private final class FragmentAdapter extends FragmentPagerAdapter {
+
+    public FragmentAdapter(FragmentManager fragmentManager) {
+      super(fragmentManager);
+    }
+
+    @Override
+    public Fragment getItem(int position) {
+      return tabFragments.valueAt(position);
+    }
+
+    @Override
+    public int getCount() {
+      return tabFragments.size();
+    }
+
+    @Nullable
+    @Override
+    public CharSequence getPageTitle(int position) {
+      return getTrackTypeString(getResources(), tabTrackTypes.get(position));
+    }
+  }
+
+  /** Fragment to show a track seleciton in tab of the track selection dialog. */
+  public static final class TrackSelectionViewFragment extends Fragment
+      implements TrackSelectionView.TrackSelectionListener {
+
+    private MappedTrackInfo mappedTrackInfo;
+    private int rendererIndex;
+    private boolean allowAdaptiveSelections;
+    private boolean allowMultipleOverrides;
+
+    /* package */ boolean isDisabled;
+    /* package */ List<SelectionOverride> overrides;
+
+    public TrackSelectionViewFragment() {
+      // Retain instance across activity re-creation to prevent losing access to init data.
+      setRetainInstance(true);
+    }
+
+    public void init(
+        MappedTrackInfo mappedTrackInfo,
+        int rendererIndex,
+        boolean initialIsDisabled,
+        @Nullable SelectionOverride initialOverride,
+        boolean allowAdaptiveSelections,
+        boolean allowMultipleOverrides) {
+      this.mappedTrackInfo = mappedTrackInfo;
+      this.rendererIndex = rendererIndex;
+      this.isDisabled = initialIsDisabled;
+      this.overrides =
+          initialOverride == null
+              ? Collections.emptyList()
+              : Collections.singletonList(initialOverride);
+      this.allowAdaptiveSelections = allowAdaptiveSelections;
+      this.allowMultipleOverrides = allowMultipleOverrides;
+    }
+
+    @Nullable
+    @Override
+    public View onCreateView(
+        LayoutInflater inflater,
+        @Nullable ViewGroup container,
+        @Nullable Bundle savedInstanceState) {
+      View rootView =
+          inflater.inflate(
+              R.layout.exo_track_selection_dialog, container, /* attachToRoot= */ false);
+      TrackSelectionView trackSelectionView = rootView.findViewById(R.id.exo_track_selection_view);
+      trackSelectionView.setShowDisableOption(true);
+      trackSelectionView.setAllowMultipleOverrides(allowMultipleOverrides);
+      trackSelectionView.setAllowAdaptiveSelections(allowAdaptiveSelections);
+      trackSelectionView.init(
+          mappedTrackInfo, rendererIndex, isDisabled, overrides, /* listener= */ this);
+      return rootView;
+    }
+
+    @Override
+    public void onTrackSelectionChanged(boolean isDisabled, List<SelectionOverride> overrides) {
+      this.isDisabled = isDisabled;
+      this.overrides = overrides;
+    }
+  }
+}
diff --git a/demos/main/src/main/res/layout/player_activity.xml b/demos/main/src/main/res/layout/player_activity.xml
index 6b84033273..ea3de257e2 100644
--- a/demos/main/src/main/res/layout/player_activity.xml
+++ b/demos/main/src/main/res/layout/player_activity.xml
@@ -42,7 +42,15 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:orientation="horizontal"
-        android:visibility="gone"/>
+        android:visibility="gone">
+
+      <Button android:id="@+id/select_tracks_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:text="@string/track_selection_title"
+          android:enabled="false"/>
+
+    </LinearLayout>
 
   </LinearLayout>
 
diff --git a/demos/main/src/main/res/layout/track_selection_dialog.xml b/demos/main/src/main/res/layout/track_selection_dialog.xml
new file mode 100644
index 0000000000..7f6c45e131
--- /dev/null
+++ b/demos/main/src/main/res/layout/track_selection_dialog.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+  <androidx.viewpager.widget.ViewPager
+      android:id="@+id/track_selection_dialog_view_pager"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1">
+
+    <com.google.android.material.tabs.TabLayout
+        android:id="@+id/track_selection_dialog_tab_layout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:tabGravity="fill"
+        app:tabMode="fixed"/>
+
+  </androidx.viewpager.widget.ViewPager>
+
+  <LinearLayout
+      android:orientation="horizontal"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:gravity="end">
+
+    <Button
+        android:id="@+id/track_selection_dialog_cancel_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@android:string/cancel"
+        style="?android:attr/borderlessButtonStyle"/>
+
+    <Button
+        android:id="@+id/track_selection_dialog_ok_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@android:string/ok"
+        style="?android:attr/borderlessButtonStyle"/>
+
+  </LinearLayout>
+
+</LinearLayout>
diff --git a/demos/main/src/main/res/menu/sample_chooser_menu.xml b/demos/main/src/main/res/menu/sample_chooser_menu.xml
index 566b23a0d5..9934e9db95 100644
--- a/demos/main/src/main/res/menu/sample_chooser_menu.xml
+++ b/demos/main/src/main/res/menu/sample_chooser_menu.xml
@@ -13,13 +13,14 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<menu xmlns:android="http://schemas.android.com/apk/res/android">
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
   <item android:id="@+id/prefer_extension_decoders"
-    android:title="@string/prefer_extension_decoders"
-    android:showAsAction="never"
-    android:checkable="true"/>
+      android:title="@string/prefer_extension_decoders"
+      android:checkable="true"
+      app:showAsAction="never"/>
   <item android:id="@+id/random_abr"
-    android:title="@string/random_abr"
-    android:showAsAction="never"
-    android:checkable="true"/>
+      android:title="@string/random_abr"
+      android:checkable="true"
+      app:showAsAction="never"/>
 </menu>
diff --git a/demos/main/src/main/res/values/strings.xml b/demos/main/src/main/res/values/strings.xml
index 40f065b18e..0729da2fc6 100644
--- a/demos/main/src/main/res/values/strings.xml
+++ b/demos/main/src/main/res/values/strings.xml
@@ -17,6 +17,8 @@
 
   <string name="application_name">ExoPlayer</string>
 
+  <string name="track_selection_title">Select tracks</string>
+
   <string name="unexpected_intent_action">Unexpected intent action: <xliff:g id="action">%1$s</xliff:g></string>
 
   <string name="error_cleartext_not_permitted">Cleartext traffic not permitted</string>
diff --git a/demos/main/src/main/res/values/styles.xml b/demos/main/src/main/res/values/styles.xml
index 25d826bdf6..04c5b90edc 100644
--- a/demos/main/src/main/res/values/styles.xml
+++ b/demos/main/src/main/res/values/styles.xml
@@ -15,8 +15,11 @@
 -->
 <resources xmlns:android="http://schemas.android.com/apk/res/android">
 
-  <style name="PlayerTheme" parent="android:Theme.Holo">
-    <item name="android:windowNoTitle">true</item>
+  <style name="TrackSelectionDialogThemeOverlay" parent="ThemeOverlay.AppCompat.Dialog.Alert">
+    <item name="windowNoTitle">false</item>
+  </style>
+
+  <style name="PlayerTheme" parent="Theme.AppCompat.NoActionBar">
     <item name="android:windowBackground">@android:color/black</item>
   </style>
 
diff --git a/extensions/cast/README.md b/extensions/cast/README.md
index cc72c5f9bc..1c0d7ac56f 100644
--- a/extensions/cast/README.md
+++ b/extensions/cast/README.md
@@ -5,7 +5,7 @@
 The cast extension is a [Player][] implementation that controls playback on a
 Cast receiver app.
 
-[Player]: https://google.github.io/ExoPlayer/doc/reference/index.html?com/google/android/exoplayer2/Player.html
+[Player]: https://exoplayer.dev/doc/reference/index.html?com/google/android/exoplayer2/Player.html
 
 ## Getting the extension ##
 
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index 30fe10085f..4dc463ff81 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -24,30 +23,21 @@ android {
     }
 
     defaultConfig {
-        minSdkVersion 14
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-        consumerProguardFiles 'proguard-rules.txt'
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:16.0.3'
+    api 'com.google.android.gms:play-services-cast-framework:16.1.2'
+    implementation 'androidx.annotation:annotation:1.0.2'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
-    testImplementation project(modulePrefix + 'testutils')
-    testImplementation 'junit:junit:' + junitVersion
-    testImplementation 'org.mockito:mockito-core:' + mockitoVersion
-    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
+    compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
-    // These dependencies are necessary to force the supportLibraryVersion of
-    // com.android.support:support-v4, com.android.support:appcompat-v7 and
-    // com.android.support:mediarouter-v7 to be used. Else older versions are
-    // used, for example via:
-    // com.google.android.gms:play-services-cast-framework:15.0.1
-    // |-- com.android.support:mediarouter-v7:26.1.0
-    api 'com.android.support:support-v4:' + supportLibraryVersion
-    api 'com.android.support:mediarouter-v7:' + supportLibraryVersion
-    api 'com.android.support:recyclerview-v7:' + supportLibraryVersion
 }
 
 ext {
diff --git a/extensions/cast/proguard-rules.txt b/extensions/cast/proguard-rules.txt
deleted file mode 100644
index bc94b33c1c..0000000000
--- a/extensions/cast/proguard-rules.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-# Proguard rules specific to the Cast extension.
-
-# DefaultCastOptionsProvider is commonly referred to only by the app's manifest.
--keep class com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 71322de87e..14bb433d2b 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.ext.cast;
 
 import android.os.Looper;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BasePlayer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -52,35 +52,18 @@
  * {@link Player} implementation that communicates with a Cast receiver app.
  *
  * <p>The behavior of this class depends on the underlying Cast session, which is obtained from the
- * Cast context passed to {@link #CastPlayer}. To keep track of the session,
- * {@link #isCastSessionAvailable()} can be queried and {@link SessionAvailabilityListener} can be
- * implemented and attached to the player.</p>
+ * Cast context passed to {@link #CastPlayer}. To keep track of the session, {@link
+ * #isCastSessionAvailable()} can be queried and {@link SessionAvailabilityListener} can be
+ * implemented and attached to the player.
  *
- * <p> If no session is available, the player state will remain unchanged and calls to methods that
+ * <p>If no session is available, the player state will remain unchanged and calls to methods that
  * alter it will be ignored. Querying the player state is possible even when no session is
- * available, in which case, the last observed receiver app state is reported.</p>
+ * available, in which case, the last observed receiver app state is reported.
  *
- * <p>Methods should be called on the application's main thread.</p>
+ * <p>Methods should be called on the application's main thread.
  */
 public final class CastPlayer extends BasePlayer {
 
-  /**
-   * Listener of changes in the cast session availability.
-   */
-  public interface SessionAvailabilityListener {
-
-    /**
-     * Called when a cast session becomes available to the player.
-     */
-    void onCastSessionAvailable();
-
-    /**
-     * Called when the cast session becomes unavailable.
-     */
-    void onCastSessionUnavailable();
-
-  }
-
   private static final String TAG = "CastPlayer";
 
   private static final int RENDERER_COUNT = 3;
@@ -591,7 +574,9 @@ private boolean updateTimeline() {
     CastTimeline oldTimeline = currentTimeline;
     MediaStatus status = getMediaStatus();
     currentTimeline =
-        status != null ? timelineTracker.getCastTimeline(status) : CastTimeline.EMPTY_CAST_TIMELINE;
+        status != null
+            ? timelineTracker.getCastTimeline(remoteMediaClient)
+            : CastTimeline.EMPTY_CAST_TIMELINE;
     return !oldTimeline.equals(currentTimeline);
   }
 
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
index 4939e62a2b..800c19047b 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
@@ -15,24 +15,66 @@
  */
 package com.google.android.exoplayer2.ext.cast;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import android.util.SparseArray;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.gms.cast.MediaInfo;
-import com.google.android.gms.cast.MediaQueueItem;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
 
 /**
  * A {@link Timeline} for Cast media queues.
  */
 /* package */ final class CastTimeline extends Timeline {
 
+  /** Holds {@link Timeline} related data for a Cast media item. */
+  public static final class ItemData {
+
+    /** Holds no media information. */
+    public static final ItemData EMPTY = new ItemData();
+
+    /** The duration of the item in microseconds, or {@link C#TIME_UNSET} if unknown. */
+    public final long durationUs;
+    /**
+     * The default start position of the item in microseconds, or {@link C#TIME_UNSET} if unknown.
+     */
+    public final long defaultPositionUs;
+
+    private ItemData() {
+      this(/* durationUs= */ C.TIME_UNSET, /* defaultPositionUs */ C.TIME_UNSET);
+    }
+
+    /**
+     * Creates an instance.
+     *
+     * @param durationUs See {@link #durationsUs}.
+     * @param defaultPositionUs See {@link #defaultPositionUs}.
+     */
+    public ItemData(long durationUs, long defaultPositionUs) {
+      this.durationUs = durationUs;
+      this.defaultPositionUs = defaultPositionUs;
+    }
+
+    /** Returns an instance with the given {@link #durationsUs}. */
+    public ItemData copyWithDurationUs(long durationUs) {
+      if (durationUs == this.durationUs) {
+        return this;
+      }
+      return new ItemData(durationUs, defaultPositionUs);
+    }
+
+    /** Returns an instance with the given {@link #defaultPositionsUs}. */
+    public ItemData copyWithDefaultPositionUs(long defaultPositionUs) {
+      if (defaultPositionUs == this.defaultPositionUs) {
+        return this;
+      }
+      return new ItemData(durationUs, defaultPositionUs);
+    }
+  }
+
+  /** {@link Timeline} for a cast queue that has no items. */
   public static final CastTimeline EMPTY_CAST_TIMELINE =
-      new CastTimeline(Collections.emptyList(), Collections.emptyMap());
+      new CastTimeline(new int[0], new SparseArray<>());
 
   private final SparseIntArray idsToIndex;
   private final int[] ids;
@@ -40,28 +82,23 @@
   private final long[] defaultPositionsUs;
 
   /**
-   * @param items A list of cast media queue items to represent.
-   * @param contentIdToDurationUsMap A map of content id to duration in microseconds.
+   * Creates a Cast timeline from the given data.
+   *
+   * @param itemIds The ids of the items in the timeline.
+   * @param itemIdToData Maps item ids to {@link ItemData}.
    */
-  public CastTimeline(List<MediaQueueItem> items, Map<String, Long> contentIdToDurationUsMap) {
-    int itemCount = items.size();
-    int index = 0;
+  public CastTimeline(int[] itemIds, SparseArray<ItemData> itemIdToData) {
+    int itemCount = itemIds.length;
     idsToIndex = new SparseIntArray(itemCount);
-    ids = new int[itemCount];
+    ids = Arrays.copyOf(itemIds, itemCount);
     durationsUs = new long[itemCount];
     defaultPositionsUs = new long[itemCount];
-    for (MediaQueueItem item : items) {
-      int itemId = item.getItemId();
-      ids[index] = itemId;
-      idsToIndex.put(itemId, index);
-      MediaInfo mediaInfo = item.getMedia();
-      String contentId = mediaInfo.getContentId();
-      durationsUs[index] =
-          contentIdToDurationUsMap.containsKey(contentId)
-              ? contentIdToDurationUsMap.get(contentId)
-              : CastUtils.getStreamDurationUs(mediaInfo);
-      defaultPositionsUs[index] = (long) (item.getStartTime() * C.MICROS_PER_SECOND);
-      index++;
+    for (int i = 0; i < ids.length; i++) {
+      int id = ids[i];
+      idsToIndex.put(id, i);
+      ItemData data = itemIdToData.get(id, ItemData.EMPTY);
+      durationsUs[i] = data.durationUs;
+      defaultPositionsUs[i] = data.defaultPositionUs;
     }
   }
 
@@ -108,7 +145,7 @@ public int getIndexOfPeriod(Object uid) {
   }
 
   @Override
-  public Object getUidOfPeriod(int periodIndex) {
+  public Integer getUidOfPeriod(int periodIndex) {
     return ids[periodIndex];
   }
 
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java
index 412bfb476d..40c93a115a 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java
@@ -15,53 +15,84 @@
  */
 package com.google.android.exoplayer2.ext.cast;
 
-import com.google.android.gms.cast.MediaInfo;
+import android.util.SparseArray;
+import com.google.android.exoplayer2.C;
 import com.google.android.gms.cast.MediaQueueItem;
 import com.google.android.gms.cast.MediaStatus;
-import java.util.HashMap;
+import com.google.android.gms.cast.framework.media.RemoteMediaClient;
 import java.util.HashSet;
-import java.util.List;
 
 /**
- * Creates {@link CastTimeline}s from cast receiver app media status.
+ * Creates {@link CastTimeline CastTimelines} from cast receiver app status updates.
  *
  * <p>This class keeps track of the duration reported by the current item to fill any missing
  * durations in the media queue items [See internal: b/65152553].
  */
 /* package */ final class CastTimelineTracker {
 
-  private final HashMap<String, Long> contentIdToDurationUsMap;
-  private final HashSet<String> scratchContentIdSet;
+  private final SparseArray<CastTimeline.ItemData> itemIdToData;
 
   public CastTimelineTracker() {
-    contentIdToDurationUsMap = new HashMap<>();
-    scratchContentIdSet = new HashSet<>();
+    itemIdToData = new SparseArray<>();
   }
 
   /**
-   * Returns a {@link CastTimeline} that represent the given {@code status}.
+   * Returns a {@link CastTimeline} that represents the state of the given {@code
+   * remoteMediaClient}.
    *
-   * @param status The Cast media status.
-   * @return A {@link CastTimeline} that represent the given {@code status}.
+   * <p>Returned timelines may contain values obtained from {@code remoteMediaClient} in previous
+   * invocations of this method.
+   *
+   * @param remoteMediaClient The Cast media client.
+   * @return A {@link CastTimeline} that represents the given {@code remoteMediaClient} status.
    */
-  public CastTimeline getCastTimeline(MediaStatus status) {
-    MediaInfo mediaInfo = status.getMediaInfo();
-    List<MediaQueueItem> items = status.getQueueItems();
-    removeUnusedDurationEntries(items);
+  public CastTimeline getCastTimeline(RemoteMediaClient remoteMediaClient) {
+    int[] itemIds = remoteMediaClient.getMediaQueue().getItemIds();
+    if (itemIds.length > 0) {
+      // Only remove unused items when there is something in the queue to avoid removing all entries
+      // if the remote media client clears the queue temporarily. See [Internal ref: b/128825216].
+      removeUnusedItemDataEntries(itemIds);
+    }
+
+    // TODO: Reset state when the app instance changes [Internal ref: b/129672468].
+    MediaStatus mediaStatus = remoteMediaClient.getMediaStatus();
+    if (mediaStatus == null) {
+      return CastTimeline.EMPTY_CAST_TIMELINE;
+    }
 
-    if (mediaInfo != null) {
-      String contentId = mediaInfo.getContentId();
-      long durationUs = CastUtils.getStreamDurationUs(mediaInfo);
-      contentIdToDurationUsMap.put(contentId, durationUs);
+    int currentItemId = mediaStatus.getCurrentItemId();
+    long durationUs = CastUtils.getStreamDurationUs(mediaStatus.getMediaInfo());
+    itemIdToData.put(
+        currentItemId,
+        itemIdToData
+            .get(currentItemId, CastTimeline.ItemData.EMPTY)
+            .copyWithDurationUs(durationUs));
+
+    for (MediaQueueItem item : mediaStatus.getQueueItems()) {
+      int itemId = item.getItemId();
+      itemIdToData.put(
+          itemId,
+          itemIdToData
+              .get(itemId, CastTimeline.ItemData.EMPTY)
+              .copyWithDefaultPositionUs((long) (item.getStartTime() * C.MICROS_PER_SECOND)));
     }
-    return new CastTimeline(items, contentIdToDurationUsMap);
+
+    return new CastTimeline(itemIds, itemIdToData);
   }
 
-  private void removeUnusedDurationEntries(List<MediaQueueItem> items) {
-    scratchContentIdSet.clear();
-    for (MediaQueueItem item : items) {
-      scratchContentIdSet.add(item.getMedia().getContentId());
+  private void removeUnusedItemDataEntries(int[] itemIds) {
+    HashSet<Integer> scratchItemIds = new HashSet<>(/* initialCapacity= */ itemIds.length * 2);
+    for (int id : itemIds) {
+      scratchItemIds.add(id);
+    }
+
+    int index = 0;
+    while (index < itemIdToData.size()) {
+      if (!scratchItemIds.contains(itemIdToData.keyAt(index))) {
+        itemIdToData.removeAt(index);
+      } else {
+        index++;
+      }
     }
-    contentIdToDurationUsMap.keySet().retainAll(scratchContentIdSet);
   }
 }
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
index 997857f6b5..d1660c3306 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
@@ -31,11 +31,13 @@
    * unknown or not applicable.
    *
    * @param mediaInfo The media info to get the duration from.
-   * @return The duration in microseconds.
+   * @return The duration in microseconds, or {@link C#TIME_UNSET} if unknown or not applicable.
    */
   public static long getStreamDurationUs(MediaInfo mediaInfo) {
-    long durationMs =
-        mediaInfo != null ? mediaInfo.getStreamDuration() : MediaInfo.UNKNOWN_DURATION;
+    if (mediaInfo == null) {
+      return C.TIME_UNSET;
+    }
+    long durationMs = mediaInfo.getStreamDuration();
     return durationMs != MediaInfo.UNKNOWN_DURATION ? C.msToUs(durationMs) : C.TIME_UNSET;
   }
 
@@ -109,6 +111,7 @@ public static Format mediaTrackToFormat(MediaTrack mediaTrack) {
         /* codecs= */ null,
         /* bitrate= */ Format.NO_VALUE,
         /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
         mediaTrack.getLanguage());
   }
 
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/MediaItem.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/MediaItem.java
new file mode 100644
index 0000000000..adb8e59070
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/MediaItem.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import org.checkerframework.checker.initialization.qual.UnknownInitialization;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
+
+/** Representation of an item that can be played by a media player. */
+public final class MediaItem {
+
+  /** A builder for {@link MediaItem} instances. */
+  public static final class Builder {
+
+    @Nullable private UUID uuid;
+    private String title;
+    private String description;
+    private MediaItem.UriBundle media;
+    @Nullable private Object attachment;
+    private List<MediaItem.DrmScheme> drmSchemes;
+    private long startPositionUs;
+    private long endPositionUs;
+    private String mimeType;
+
+    /** Creates an builder with default field values. */
+    public Builder() {
+      clearInternal();
+    }
+
+    /** See {@link MediaItem#uuid}. */
+    public Builder setUuid(UUID uuid) {
+      this.uuid = uuid;
+      return this;
+    }
+
+    /** See {@link MediaItem#title}. */
+    public Builder setTitle(String title) {
+      this.title = title;
+      return this;
+    }
+
+    /** See {@link MediaItem#description}. */
+    public Builder setDescription(String description) {
+      this.description = description;
+      return this;
+    }
+
+    /** Equivalent to {@link #setMedia(UriBundle) setMedia(new UriBundle(Uri.parse(uri)))}. */
+    public Builder setMedia(String uri) {
+      return setMedia(new UriBundle(Uri.parse(uri)));
+    }
+
+    /** See {@link MediaItem#media}. */
+    public Builder setMedia(UriBundle media) {
+      this.media = media;
+      return this;
+    }
+
+    /** See {@link MediaItem#attachment}. */
+    public Builder setAttachment(Object attachment) {
+      this.attachment = attachment;
+      return this;
+    }
+
+    /** See {@link MediaItem#drmSchemes}. */
+    public Builder setDrmSchemes(List<MediaItem.DrmScheme> drmSchemes) {
+      this.drmSchemes = Collections.unmodifiableList(new ArrayList<>(drmSchemes));
+      return this;
+    }
+
+    /** See {@link MediaItem#startPositionUs}. */
+    public Builder setStartPositionUs(long startPositionUs) {
+      this.startPositionUs = startPositionUs;
+      return this;
+    }
+
+    /** See {@link MediaItem#endPositionUs}. */
+    public Builder setEndPositionUs(long endPositionUs) {
+      Assertions.checkArgument(endPositionUs != C.TIME_END_OF_SOURCE);
+      this.endPositionUs = endPositionUs;
+      return this;
+    }
+
+    /** See {@link MediaItem#mimeType}. */
+    public Builder setMimeType(String mimeType) {
+      this.mimeType = mimeType;
+      return this;
+    }
+
+    /**
+     * Equivalent to {@link #build()}, except it also calls {@link #clear()} after creating the
+     * {@link MediaItem}.
+     */
+    public MediaItem buildAndClear() {
+      MediaItem item = build();
+      clearInternal();
+      return item;
+    }
+
+    /** Returns the builder to default values. */
+    public Builder clear() {
+      clearInternal();
+      return this;
+    }
+
+    /**
+     * Returns a new {@link MediaItem} instance with the current builder values. This method also
+     * clears any values passed to {@link #setUuid(UUID)}.
+     */
+    public MediaItem build() {
+      UUID uuid = this.uuid;
+      this.uuid = null;
+      return new MediaItem(
+          uuid != null ? uuid : UUID.randomUUID(),
+          title,
+          description,
+          media,
+          attachment,
+          drmSchemes,
+          startPositionUs,
+          endPositionUs,
+          mimeType);
+    }
+
+    @EnsuresNonNull({"title", "description", "media", "drmSchemes", "mimeType"})
+    private void clearInternal(@UnknownInitialization Builder this) {
+      uuid = null;
+      title = "";
+      description = "";
+      media = UriBundle.EMPTY;
+      attachment = null;
+      drmSchemes = Collections.emptyList();
+      startPositionUs = C.TIME_UNSET;
+      endPositionUs = C.TIME_UNSET;
+      mimeType = "";
+    }
+  }
+
+  /** Bundles a resource's URI with headers to attach to any request to that URI. */
+  public static final class UriBundle {
+
+    /** An empty {@link UriBundle}. */
+    public static final UriBundle EMPTY = new UriBundle(Uri.EMPTY);
+
+    /** A URI. */
+    public final Uri uri;
+
+    /** The headers to attach to any request for the given URI. */
+    public final Map<String, String> requestHeaders;
+
+    /**
+     * Creates an instance with no request headers.
+     *
+     * @param uri See {@link #uri}.
+     */
+    public UriBundle(Uri uri) {
+      this(uri, Collections.emptyMap());
+    }
+
+    /**
+     * Creates an instance with the given URI and request headers.
+     *
+     * @param uri See {@link #uri}.
+     * @param requestHeaders See {@link #requestHeaders}.
+     */
+    public UriBundle(Uri uri, Map<String, String> requestHeaders) {
+      this.uri = uri;
+      this.requestHeaders = Collections.unmodifiableMap(new HashMap<>(requestHeaders));
+    }
+
+    @Override
+    public boolean equals(@Nullable Object other) {
+      if (this == other) {
+        return true;
+      }
+      if (other == null || getClass() != other.getClass()) {
+        return false;
+      }
+
+      UriBundle uriBundle = (UriBundle) other;
+      return uri.equals(uriBundle.uri) && requestHeaders.equals(uriBundle.requestHeaders);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = uri.hashCode();
+      result = 31 * result + requestHeaders.hashCode();
+      return result;
+    }
+  }
+
+  /**
+   * Represents a DRM protection scheme, and optionally provides information about how to acquire
+   * the license for the media.
+   */
+  public static final class DrmScheme {
+
+    /** The UUID of the protection scheme. */
+    public final UUID uuid;
+
+    /**
+     * Optional {@link UriBundle} for the license server. If no license server is provided, the
+     * server must be provided by the media.
+     */
+    @Nullable public final UriBundle licenseServer;
+
+    /**
+     * Creates an instance.
+     *
+     * @param uuid See {@link #uuid}.
+     * @param licenseServer See {@link #licenseServer}.
+     */
+    public DrmScheme(UUID uuid, @Nullable UriBundle licenseServer) {
+      this.uuid = uuid;
+      this.licenseServer = licenseServer;
+    }
+
+    @Override
+    public boolean equals(@Nullable Object other) {
+      if (this == other) {
+        return true;
+      }
+      if (other == null || getClass() != other.getClass()) {
+        return false;
+      }
+
+      DrmScheme drmScheme = (DrmScheme) other;
+      return uuid.equals(drmScheme.uuid) && Util.areEqual(licenseServer, drmScheme.licenseServer);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = uuid.hashCode();
+      result = 31 * result + (licenseServer != null ? licenseServer.hashCode() : 0);
+      return result;
+    }
+  }
+
+  /**
+   * A UUID that identifies this item, potentially across different devices. The default value is
+   * obtained by calling {@link UUID#randomUUID()}.
+   */
+  public final UUID uuid;
+
+  /** The title of the item. The default value is an empty string. */
+  public final String title;
+
+  /** A description for the item. The default value is an empty string. */
+  public final String description;
+
+  /**
+   * A {@link UriBundle} to fetch the media content. The default value is {@link UriBundle#EMPTY}.
+   */
+  public final UriBundle media;
+
+  /**
+   * An optional opaque object to attach to the media item. Handling of this attachment is
+   * implementation specific. The default value is null.
+   */
+  @Nullable public final Object attachment;
+
+  /**
+   * Immutable list of {@link DrmScheme} instances sorted in decreasing order of preference. The
+   * default value is an empty list.
+   */
+  public final List<DrmScheme> drmSchemes;
+
+  /**
+   * The position in microseconds at which playback of this media item should start. {@link
+   * C#TIME_UNSET} if playback should start at the default position. The default value is {@link
+   * C#TIME_UNSET}.
+   */
+  public final long startPositionUs;
+
+  /**
+   * The position in microseconds at which playback of this media item should end. {@link
+   * C#TIME_UNSET} if playback should end at the end of the media. The default value is {@link
+   * C#TIME_UNSET}.
+   */
+  public final long endPositionUs;
+
+  /**
+   * The mime type of this media item. The default value is an empty string.
+   *
+   * <p>The usage of this mime type is optional and player implementation specific.
+   */
+  public final String mimeType;
+
+  // TODO: Add support for sideloaded tracks, artwork, icon, and subtitle.
+
+  @Override
+  public boolean equals(@Nullable Object other) {
+    if (this == other) {
+      return true;
+    }
+    if (other == null || getClass() != other.getClass()) {
+      return false;
+    }
+    MediaItem mediaItem = (MediaItem) other;
+    return startPositionUs == mediaItem.startPositionUs
+        && endPositionUs == mediaItem.endPositionUs
+        && uuid.equals(mediaItem.uuid)
+        && title.equals(mediaItem.title)
+        && description.equals(mediaItem.description)
+        && media.equals(mediaItem.media)
+        && Util.areEqual(attachment, mediaItem.attachment)
+        && drmSchemes.equals(mediaItem.drmSchemes)
+        && mimeType.equals(mediaItem.mimeType);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = uuid.hashCode();
+    result = 31 * result + title.hashCode();
+    result = 31 * result + description.hashCode();
+    result = 31 * result + media.hashCode();
+    result = 31 * result + (attachment != null ? attachment.hashCode() : 0);
+    result = 31 * result + drmSchemes.hashCode();
+    result = 31 * result + (int) (startPositionUs ^ (startPositionUs >>> 32));
+    result = 31 * result + (int) (endPositionUs ^ (endPositionUs >>> 32));
+    result = 31 * result + mimeType.hashCode();
+    return result;
+  }
+
+  private MediaItem(
+      UUID uuid,
+      String title,
+      String description,
+      UriBundle media,
+      @Nullable Object attachment,
+      List<DrmScheme> drmSchemes,
+      long startPositionUs,
+      long endPositionUs,
+      String mimeType) {
+    this.uuid = uuid;
+    this.title = title;
+    this.description = description;
+    this.media = media;
+    this.attachment = attachment;
+    this.drmSchemes = drmSchemes;
+    this.startPositionUs = startPositionUs;
+    this.endPositionUs = endPositionUs;
+    this.mimeType = mimeType;
+  }
+}
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/MediaItemQueue.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/MediaItemQueue.java
new file mode 100644
index 0000000000..184e347e1c
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/MediaItemQueue.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+/** Represents a sequence of {@link MediaItem MediaItems}. */
+public interface MediaItemQueue {
+
+  /**
+   * Returns the item at the given index.
+   *
+   * @param index The index of the item to retrieve.
+   * @return The item at the given index.
+   * @throws IndexOutOfBoundsException If {@code index < 0 || index >= getSize()}.
+   */
+  MediaItem get(int index);
+
+  /** Returns the number of items in this queue. */
+  int getSize();
+
+  /**
+   * Appends the given sequence of items to the queue.
+   *
+   * @param items The sequence of items to append.
+   */
+  void add(MediaItem... items);
+
+  /**
+   * Adds the given sequence of items to the queue at the given position, so that the first of
+   * {@code items} is placed at the given index.
+   *
+   * @param index The index at which {@code items} will be inserted.
+   * @param items The sequence of items to append.
+   * @throws IndexOutOfBoundsException If {@code index < 0 || index > getSize()}.
+   */
+  void add(int index, MediaItem... items);
+
+  /**
+   * Moves an existing item within the playlist.
+   *
+   * <p>Calling this method is equivalent to removing the item at position {@code indexFrom} and
+   * immediately inserting it at position {@code indexTo}. If the moved item is being played at the
+   * moment of the invocation, playback will stick with the moved item.
+   *
+   * @param indexFrom The index of the item to move.
+   * @param indexTo The index at which the item will be placed after this operation.
+   * @throws IndexOutOfBoundsException If for either index, {@code index < 0 || index >= getSize()}.
+   */
+  void move(int indexFrom, int indexTo);
+
+  /**
+   * Removes an item from the queue.
+   *
+   * @param index The index of the item to remove from the queue.
+   * @throws IndexOutOfBoundsException If {@code index < 0 || index >= getSize()}.
+   */
+  void remove(int index);
+
+  /**
+   * Removes a range of items from the queue.
+   *
+   * <p>Does nothing if an empty range ({@code from == exclusiveTo}) is passed.
+   *
+   * @param from The inclusive index at which the range to remove starts.
+   * @param exclusiveTo The exclusive index at which the range to remove ends.
+   * @throws IndexOutOfBoundsException If {@code from < 0 || exclusiveTo > getSize() || from >
+   *     exclusiveTo}.
+   */
+  void removeRange(int from, int exclusiveTo);
+
+  /** Removes all items in the queue. */
+  void clear();
+}
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/SessionAvailabilityListener.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/SessionAvailabilityListener.java
new file mode 100644
index 0000000000..c686c496c6
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/SessionAvailabilityListener.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+/** Listener of changes in the cast session availability. */
+public interface SessionAvailabilityListener {
+
+  /** Called when a cast session becomes available to the player. */
+  void onCastSessionAvailable();
+
+  /** Called when the cast session becomes unavailable. */
+  void onCastSessionUnavailable();
+}
diff --git a/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java b/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java
index 4c60e7c0b3..69b25e4456 100644
--- a/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java
+++ b/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java
@@ -15,23 +15,23 @@
  */
 package com.google.android.exoplayer2.ext.cast;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TimelineAsserts;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.gms.cast.MediaInfo;
-import com.google.android.gms.cast.MediaQueueItem;
 import com.google.android.gms.cast.MediaStatus;
-import java.util.ArrayList;
+import com.google.android.gms.cast.framework.media.MediaQueue;
+import com.google.android.gms.cast.framework.media.RemoteMediaClient;
+import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link CastTimelineTracker}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class CastTimelineTrackerTest {
 
-  private static final long DURATION_1_MS = 1000;
   private static final long DURATION_2_MS = 2000;
   private static final long DURATION_3_MS = 3000;
   private static final long DURATION_4_MS = 4000;
@@ -39,91 +39,89 @@
 
   /** Tests that duration of the current media info is correctly propagated to the timeline. */
   @Test
-  public void testGetCastTimeline() {
-    MediaInfo mediaInfo;
-    MediaStatus status =
-        mockMediaStatus(
-            new int[] {1, 2, 3},
-            new String[] {"contentId1", "contentId2", "contentId3"},
-            new long[] {DURATION_1_MS, MediaInfo.UNKNOWN_DURATION, MediaInfo.UNKNOWN_DURATION});
-
+  public void testGetCastTimelinePersistsDuration() {
     CastTimelineTracker tracker = new CastTimelineTracker();
-    mediaInfo = getMediaInfo("contentId1", DURATION_1_MS);
-    Mockito.when(status.getMediaInfo()).thenReturn(mediaInfo);
-    TimelineAsserts.assertPeriodDurations(
-        tracker.getCastTimeline(status), C.msToUs(DURATION_1_MS), C.TIME_UNSET, C.TIME_UNSET);
 
-    mediaInfo = getMediaInfo("contentId3", DURATION_3_MS);
-    Mockito.when(status.getMediaInfo()).thenReturn(mediaInfo);
+    RemoteMediaClient remoteMediaClient =
+        mockRemoteMediaClient(
+            /* itemIds= */ new int[] {1, 2, 3, 4, 5},
+            /* currentItemId= */ 2,
+            /* currentDurationMs= */ DURATION_2_MS);
     TimelineAsserts.assertPeriodDurations(
-        tracker.getCastTimeline(status),
-        C.msToUs(DURATION_1_MS),
+        tracker.getCastTimeline(remoteMediaClient),
         C.TIME_UNSET,
-        C.msToUs(DURATION_3_MS));
+        C.msToUs(DURATION_2_MS),
+        C.TIME_UNSET,
+        C.TIME_UNSET,
+        C.TIME_UNSET);
 
-    mediaInfo = getMediaInfo("contentId2", DURATION_2_MS);
-    Mockito.when(status.getMediaInfo()).thenReturn(mediaInfo);
+    remoteMediaClient =
+        mockRemoteMediaClient(
+            /* itemIds= */ new int[] {1, 2, 3},
+            /* currentItemId= */ 3,
+            /* currentDurationMs= */ DURATION_3_MS);
     TimelineAsserts.assertPeriodDurations(
-        tracker.getCastTimeline(status),
-        C.msToUs(DURATION_1_MS),
+        tracker.getCastTimeline(remoteMediaClient),
+        C.TIME_UNSET,
         C.msToUs(DURATION_2_MS),
         C.msToUs(DURATION_3_MS));
 
-    MediaStatus newStatus =
-        mockMediaStatus(
-            new int[] {4, 1, 5, 3},
-            new String[] {"contentId4", "contentId1", "contentId5", "contentId3"},
-            new long[] {
-              MediaInfo.UNKNOWN_DURATION,
-              MediaInfo.UNKNOWN_DURATION,
-              DURATION_5_MS,
-              MediaInfo.UNKNOWN_DURATION
-            });
-    mediaInfo = getMediaInfo("contentId5", DURATION_5_MS);
-    Mockito.when(newStatus.getMediaInfo()).thenReturn(mediaInfo);
+    remoteMediaClient =
+        mockRemoteMediaClient(
+            /* itemIds= */ new int[] {1, 3},
+            /* currentItemId= */ 3,
+            /* currentDurationMs= */ DURATION_3_MS);
     TimelineAsserts.assertPeriodDurations(
-        tracker.getCastTimeline(newStatus),
-        C.TIME_UNSET,
-        C.msToUs(DURATION_1_MS),
-        C.msToUs(DURATION_5_MS),
-        C.msToUs(DURATION_3_MS));
+        tracker.getCastTimeline(remoteMediaClient), C.TIME_UNSET, C.msToUs(DURATION_3_MS));
 
-    mediaInfo = getMediaInfo("contentId3", DURATION_3_MS);
-    Mockito.when(newStatus.getMediaInfo()).thenReturn(mediaInfo);
+    remoteMediaClient =
+        mockRemoteMediaClient(
+            /* itemIds= */ new int[] {1, 2, 3, 4, 5},
+            /* currentItemId= */ 4,
+            /* currentDurationMs= */ DURATION_4_MS);
     TimelineAsserts.assertPeriodDurations(
-        tracker.getCastTimeline(newStatus),
+        tracker.getCastTimeline(remoteMediaClient),
         C.TIME_UNSET,
-        C.msToUs(DURATION_1_MS),
-        C.msToUs(DURATION_5_MS),
-        C.msToUs(DURATION_3_MS));
+        C.TIME_UNSET,
+        C.msToUs(DURATION_3_MS),
+        C.msToUs(DURATION_4_MS),
+        C.TIME_UNSET);
 
-    mediaInfo = getMediaInfo("contentId4", DURATION_4_MS);
-    Mockito.when(newStatus.getMediaInfo()).thenReturn(mediaInfo);
+    remoteMediaClient =
+        mockRemoteMediaClient(
+            /* itemIds= */ new int[] {1, 2, 3, 4, 5},
+            /* currentItemId= */ 5,
+            /* currentDurationMs= */ DURATION_5_MS);
     TimelineAsserts.assertPeriodDurations(
-        tracker.getCastTimeline(newStatus),
+        tracker.getCastTimeline(remoteMediaClient),
+        C.TIME_UNSET,
+        C.TIME_UNSET,
+        C.msToUs(DURATION_3_MS),
         C.msToUs(DURATION_4_MS),
-        C.msToUs(DURATION_1_MS),
-        C.msToUs(DURATION_5_MS),
-        C.msToUs(DURATION_3_MS));
+        C.msToUs(DURATION_5_MS));
   }
 
-  private static MediaStatus mockMediaStatus(
-      int[] itemIds, String[] contentIds, long[] durationsMs) {
-    ArrayList<MediaQueueItem> items = new ArrayList<>();
-    for (int i = 0; i < contentIds.length; i++) {
-      MediaInfo mediaInfo = getMediaInfo(contentIds[i], durationsMs[i]);
-      MediaQueueItem item = Mockito.mock(MediaQueueItem.class);
-      Mockito.when(item.getMedia()).thenReturn(mediaInfo);
-      Mockito.when(item.getItemId()).thenReturn(itemIds[i]);
-      items.add(item);
-    }
+  private static RemoteMediaClient mockRemoteMediaClient(
+      int[] itemIds, int currentItemId, long currentDurationMs) {
+    RemoteMediaClient remoteMediaClient = Mockito.mock(RemoteMediaClient.class);
     MediaStatus status = Mockito.mock(MediaStatus.class);
-    Mockito.when(status.getQueueItems()).thenReturn(items);
-    return status;
+    Mockito.when(status.getQueueItems()).thenReturn(Collections.emptyList());
+    Mockito.when(remoteMediaClient.getMediaStatus()).thenReturn(status);
+    Mockito.when(status.getMediaInfo()).thenReturn(getMediaInfo(currentDurationMs));
+    Mockito.when(status.getCurrentItemId()).thenReturn(currentItemId);
+    MediaQueue mediaQueue = mockMediaQueue(itemIds);
+    Mockito.when(remoteMediaClient.getMediaQueue()).thenReturn(mediaQueue);
+    return remoteMediaClient;
+  }
+
+  private static MediaQueue mockMediaQueue(int[] itemIds) {
+    MediaQueue mediaQueue = Mockito.mock(MediaQueue.class);
+    Mockito.when(mediaQueue.getItemIds()).thenReturn(itemIds);
+    return mediaQueue;
   }
 
-  private static MediaInfo getMediaInfo(String contentId, long durationMs) {
-    return new MediaInfo.Builder(contentId)
+  private static MediaInfo getMediaInfo(long durationMs) {
+    return new MediaInfo.Builder(/*contentId= */ "")
         .setStreamDuration(durationMs)
         .setContentType(MimeTypes.APPLICATION_MP4)
         .setStreamType(MediaInfo.STREAM_TYPE_NONE)
diff --git a/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/MediaItemTest.java b/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/MediaItemTest.java
new file mode 100644
index 0000000000..9cdc073b06
--- /dev/null
+++ b/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/MediaItemTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.UUID;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link MediaItem}. */
+@RunWith(AndroidJUnit4.class)
+public class MediaItemTest {
+
+  @Test
+  public void buildMediaItem_resetsUuid() {
+    MediaItem.Builder builder = new MediaItem.Builder();
+    UUID uuid = new UUID(1, 1);
+    MediaItem item1 = builder.setUuid(uuid).build();
+    MediaItem item2 = builder.build();
+    MediaItem item3 = builder.build();
+    assertThat(item1.uuid).isEqualTo(uuid);
+    assertThat(item2.uuid).isNotEqualTo(uuid);
+    assertThat(item3.uuid).isNotEqualTo(item2.uuid);
+    assertThat(item3.uuid).isNotEqualTo(uuid);
+  }
+
+  @Test
+  public void buildMediaItem_doesNotChangeState() {
+    MediaItem.Builder builder = new MediaItem.Builder();
+    MediaItem item1 =
+        builder
+            .setUuid(new UUID(0, 1))
+            .setMedia("http://example.com")
+            .setTitle("title")
+            .setMimeType(MimeTypes.AUDIO_MP4)
+            .setStartPositionUs(3)
+            .setEndPositionUs(4)
+            .build();
+    MediaItem item2 = builder.setUuid(new UUID(0, 1)).build();
+    assertThat(item1).isEqualTo(item2);
+  }
+
+  @Test
+  public void buildMediaItem_assertDefaultValues() {
+    assertDefaultValues(new MediaItem.Builder().build());
+  }
+
+  @Test
+  public void buildAndClear_assertDefaultValues() {
+    MediaItem.Builder builder = new MediaItem.Builder();
+    builder
+        .setMedia("http://example.com")
+        .setTitle("title")
+        .setMimeType(MimeTypes.AUDIO_MP4)
+        .setStartPositionUs(3)
+        .setEndPositionUs(4)
+        .buildAndClear();
+    assertDefaultValues(builder.build());
+  }
+
+  @Test
+  public void equals_withEqualDrmSchemes_returnsTrue() {
+    MediaItem.Builder builder = new MediaItem.Builder();
+    MediaItem mediaItem1 =
+        builder
+            .setUuid(new UUID(0, 1))
+            .setMedia("www.google.com")
+            .setDrmSchemes(createDummyDrmSchemes(1))
+            .buildAndClear();
+    MediaItem mediaItem2 =
+        builder
+            .setUuid(new UUID(0, 1))
+            .setMedia("www.google.com")
+            .setDrmSchemes(createDummyDrmSchemes(1))
+            .buildAndClear();
+    assertThat(mediaItem1).isEqualTo(mediaItem2);
+  }
+
+  @Test
+  public void equals_withDifferentDrmRequestHeaders_returnsFalse() {
+    MediaItem.Builder builder = new MediaItem.Builder();
+    MediaItem mediaItem1 =
+        builder
+            .setUuid(new UUID(0, 1))
+            .setMedia("www.google.com")
+            .setDrmSchemes(createDummyDrmSchemes(1))
+            .buildAndClear();
+    MediaItem mediaItem2 =
+        builder
+            .setUuid(new UUID(0, 1))
+            .setMedia("www.google.com")
+            .setDrmSchemes(createDummyDrmSchemes(2))
+            .buildAndClear();
+    assertThat(mediaItem1).isNotEqualTo(mediaItem2);
+  }
+
+  private static void assertDefaultValues(MediaItem item) {
+    assertThat(item.title).isEmpty();
+    assertThat(item.description).isEmpty();
+    assertThat(item.media.uri).isEqualTo(Uri.EMPTY);
+    assertThat(item.attachment).isNull();
+    assertThat(item.drmSchemes).isEmpty();
+    assertThat(item.startPositionUs).isEqualTo(C.TIME_UNSET);
+    assertThat(item.endPositionUs).isEqualTo(C.TIME_UNSET);
+    assertThat(item.mimeType).isEmpty();
+  }
+
+  private static List<MediaItem.DrmScheme> createDummyDrmSchemes(int seed) {
+    HashMap<String, String> requestHeaders1 = new HashMap<>();
+    requestHeaders1.put("key1", "value1");
+    requestHeaders1.put("key2", "value1");
+    MediaItem.UriBundle uriBundle1 =
+        new MediaItem.UriBundle(Uri.parse("www.uri1.com"), requestHeaders1);
+    MediaItem.DrmScheme drmScheme1 = new MediaItem.DrmScheme(C.WIDEVINE_UUID, uriBundle1);
+    HashMap<String, String> requestHeaders2 = new HashMap<>();
+    requestHeaders2.put("key3", "value3");
+    requestHeaders2.put("key4", "valueWithSeed" + seed);
+    MediaItem.UriBundle uriBundle2 =
+        new MediaItem.UriBundle(Uri.parse("www.uri2.com"), requestHeaders2);
+    MediaItem.DrmScheme drmScheme2 = new MediaItem.DrmScheme(C.PLAYREADY_UUID, uriBundle2);
+    return Arrays.asList(drmScheme1, drmScheme2);
+  }
+}
diff --git a/extensions/cast/src/test/resources/robolectric.properties b/extensions/cast/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/extensions/cast/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/extensions/cronet/README.md b/extensions/cronet/README.md
index f1f6d68c81..dc64b862b6 100644
--- a/extensions/cronet/README.md
+++ b/extensions/cronet/README.md
@@ -2,7 +2,7 @@
 
 The Cronet extension is an [HttpDataSource][] implementation using [Cronet][].
 
-[HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
+[HttpDataSource]: https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
 [Cronet]: https://chromium.googlesource.com/chromium/src/+/master/components/cronet?autodive=0%2F%2F
 
 ## Getting the extension ##
@@ -52,4 +52,4 @@ respectively.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.cronet.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 7d8c217b58..76972a3530 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -16,10 +16,9 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 16
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
 
@@ -27,12 +26,14 @@ android {
         sourceCompatibility JavaVersion.VERSION_1_8
         targetCompatibility JavaVersion.VERSION_1_8
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    api 'org.chromium.net:cronet-embedded:66.3359.158'
+    api 'org.chromium.net:cronet-embedded:73.3683.76'
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     testImplementation project(modulePrefix + 'library')
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index ab10f41d8f..a9995af0e4 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -16,10 +16,11 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -493,6 +494,11 @@ protected UrlResponseInfo getCurrentUrlResponseInfo() {
     if (dataSpec.httpBody != null && !isContentTypeHeaderSet) {
       throw new IOException("HTTP request with non-empty body must set Content-Type");
     }
+    if (dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA)) {
+      requestBuilder.addHeader(
+          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
+          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
+    }
     // Set the Range header.
     if (dataSpec.position != 0 || dataSpec.length != C.LENGTH_UNSET) {
       StringBuilder rangeValue = new StringBuilder();
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
index d832e4625d..93edb4e893 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.cronet;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
index 829b53f863..270c1f6323 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import android.content.Context;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
diff --git a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
index 117518a1eb..244ba9083b 100644
--- a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
+++ b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
@@ -19,6 +19,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
@@ -28,10 +29,9 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link ByteArrayUploadDataProvider}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class ByteArrayUploadDataProviderTest {
 
   private static final byte[] TEST_DATA = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
diff --git a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index 7d47b0da64..7c4c03dd87 100644
--- a/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -31,6 +31,7 @@
 import android.net.Uri;
 import android.os.ConditionVariable;
 import android.os.SystemClock;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
@@ -62,10 +63,9 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link CronetDataSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class CronetDataSourceTest {
 
   private static final int TEST_CONNECT_TIMEOUT_MS = 100;
diff --git a/extensions/cronet/src/test/resources/robolectric.properties b/extensions/cronet/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/extensions/cronet/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index 52dacf8166..5b68f1e352 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -147,11 +147,11 @@ then implement your own logic to use the renderer for a given track.
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
 [Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
 [#2781]: https://github.com/google/ExoPlayer/issues/2781
-[Supported formats]: https://google.github.io/ExoPlayer/supported-formats.html#ffmpeg-extension
+[Supported formats]: https://exoplayer.dev/supported-formats.html#ffmpeg-extension
 
 ## Links ##
 
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.ffmpeg.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index 1630b6f775..ffecdcd16f 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -33,12 +32,15 @@ android {
         jniLibs.srcDir 'src/main/libs'
         jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index f0b30baa8a..c5d80aa32b 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.ext.ffmpeg;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 6f3c623f3f..7c5864420a 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.ffmpeg;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
@@ -37,6 +37,10 @@
   private static final int OUTPUT_BUFFER_SIZE_16BIT = 65536;
   private static final int OUTPUT_BUFFER_SIZE_32BIT = OUTPUT_BUFFER_SIZE_16BIT * 2;
 
+  // Error codes matching ffmpeg_jni.cc.
+  private static final int DECODER_ERROR_INVALID_DATA = -1;
+  private static final int DECODER_ERROR_OTHER = -2;
+
   private final String codecName;
   private final @Nullable byte[] extraData;
   private final @C.Encoding int encoding;
@@ -106,8 +110,14 @@ protected FfmpegDecoderException createUnexpectedDecodeException(Throwable error
     int inputSize = inputData.limit();
     ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, outputBufferSize);
     int result = ffmpegDecode(nativeContext, inputData, inputSize, outputData, outputBufferSize);
-    if (result < 0) {
-      return new FfmpegDecoderException("Error decoding (see logcat). Code: " + result);
+    if (result == DECODER_ERROR_INVALID_DATA) {
+      // Treat invalid data errors as non-fatal to match the behavior of MediaCodec. No output will
+      // be produced for this buffer, so mark it as decode-only to ensure that the audio sink's
+      // position is reset when more audio is produced.
+      outputBuffer.setFlags(C.BUFFER_FLAG_DECODE_ONLY);
+      return null;
+    } else if (result == DECODER_ERROR_OTHER) {
+      return new FfmpegDecoderException("Error decoding (see logcat).");
     }
     if (!hasOutputFormat) {
       channelCount = ffmpegGetChannelCount(nativeContext);
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
index e5018a49b3..58109c1666 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer2.ext.ffmpeg;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.util.LibraryLoader;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 
 /**
@@ -30,6 +31,8 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.ffmpeg");
   }
 
+  private static final String TAG = "FfmpegLibrary";
+
   private static final LibraryLoader LOADER =
       new LibraryLoader("avutil", "avresample", "avcodec", "ffmpeg");
 
@@ -69,7 +72,14 @@ public static boolean supportsFormat(String mimeType, @C.PcmEncoding int encodin
       return false;
     }
     String codecName = getCodecName(mimeType, encoding);
-    return codecName != null && ffmpegHasDecoder(codecName);
+    if (codecName == null) {
+      return false;
+    }
+    if (!ffmpegHasDecoder(codecName)) {
+      Log.w(TAG, "No " + codecName + " decoder available. Check the FFmpeg build configuration.");
+      return false;
+    }
+    return true;
   }
 
   /**
diff --git a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
index 87579ebb9a..dcd4560e4a 100644
--- a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
+++ b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
@@ -63,6 +63,10 @@ static const AVSampleFormat OUTPUT_FORMAT_PCM_16BIT = AV_SAMPLE_FMT_S16;
 // Output format corresponding to AudioFormat.ENCODING_PCM_FLOAT.
 static const AVSampleFormat OUTPUT_FORMAT_PCM_FLOAT = AV_SAMPLE_FMT_FLT;
 
+// Error codes matching FfmpegDecoder.java.
+static const int DECODER_ERROR_INVALID_DATA = -1;
+static const int DECODER_ERROR_OTHER = -2;
+
 /**
  * Returns the AVCodec with the specified name, or NULL if it is not available.
  */
@@ -79,7 +83,7 @@ AVCodecContext *createContext(JNIEnv *env, AVCodec *codec, jbyteArray extraData,
 
 /**
  * Decodes the packet into the output buffer, returning the number of bytes
- * written, or a negative value in the case of an error.
+ * written, or a negative DECODER_ERROR constant value in the case of an error.
  */
 int decodePacket(AVCodecContext *context, AVPacket *packet,
                  uint8_t *outputBuffer, int outputSize);
@@ -238,6 +242,7 @@ AVCodecContext *createContext(JNIEnv *env, AVCodec *codec, jbyteArray extraData,
     context->channels = rawChannelCount;
     context->channel_layout = av_get_default_channel_layout(rawChannelCount);
   }
+  context->err_recognition = AV_EF_IGNORE_ERR;
   int result = avcodec_open2(context, codec, NULL);
   if (result < 0) {
     logError("avcodec_open2", result);
@@ -254,7 +259,8 @@ int decodePacket(AVCodecContext *context, AVPacket *packet,
   result = avcodec_send_packet(context, packet);
   if (result) {
     logError("avcodec_send_packet", result);
-    return result;
+    return result == AVERROR_INVALIDDATA ? DECODER_ERROR_INVALID_DATA
+                                         : DECODER_ERROR_OTHER;
   }
 
   // Dequeue output data until it runs out.
diff --git a/extensions/ffmpeg/src/test/AndroidManifest.xml b/extensions/ffmpeg/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..d53bca4ca2
--- /dev/null
+++ b/extensions/ffmpeg/src/test/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.ffmpeg"/>
diff --git a/extensions/ffmpeg/src/test/java/com/google/android/exoplayer2/ext/ffmpeg/DefaultRenderersFactoryTest.java b/extensions/ffmpeg/src/test/java/com/google/android/exoplayer2/ext/ffmpeg/DefaultRenderersFactoryTest.java
new file mode 100644
index 0000000000..a52d1b1d7a
--- /dev/null
+++ b/extensions/ffmpeg/src/test/java/com/google/android/exoplayer2/ext/ffmpeg/DefaultRenderersFactoryTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.ffmpeg;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.DefaultRenderersFactoryAsserts;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link DefaultRenderersFactoryTest} with {@link FfmpegAudioRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public final class DefaultRenderersFactoryTest {
+
+  @Test
+  public void createRenderers_instantiatesVpxRenderer() {
+    DefaultRenderersFactoryAsserts.assertExtensionRendererCreated(
+        FfmpegAudioRenderer.class, C.TRACK_TYPE_AUDIO);
+  }
+}
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
index 54701eea1d..78035f4d87 100644
--- a/extensions/flac/README.md
+++ b/extensions/flac/README.md
@@ -95,4 +95,4 @@ player, then implement your own logic to use the renderer for a given track.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.flac.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index e5261902c6..06a5888404 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -34,13 +33,15 @@ android {
         jniLibs.srcDir 'src/main/libs'
         jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     implementation project(modulePrefix + 'library-core')
-    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     androidTestImplementation project(modulePrefix + 'testutils')
+    androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/extensions/flac/src/androidTest/AndroidManifest.xml b/extensions/flac/src/androidTest/AndroidManifest.xml
index cfc90117ac..39b92aa217 100644
--- a/extensions/flac/src/androidTest/AndroidManifest.xml
+++ b/extensions/flac/src/androidTest/AndroidManifest.xml
@@ -18,6 +18,9 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.flac.test">
 
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-sdk/>
+
   <application android:debuggable="true"
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
index f8e61a0609..435279fc45 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
@@ -16,22 +16,26 @@
 package com.google.android.exoplayer2.ext.flac;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
-import android.test.InstrumentationTestCase;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import org.junit.Before;
+import org.junit.runner.RunWith;
 
 /** Unit test for {@link FlacBinarySearchSeeker}. */
-public final class FlacBinarySearchSeekerTest extends InstrumentationTestCase {
+@RunWith(AndroidJUnit4.class)
+public final class FlacBinarySearchSeekerTest {
 
   private static final String NOSEEKTABLE_FLAC = "bear_no_seek.flac";
   private static final int DURATION_US = 2_741_000;
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  @Before
+  public void setUp() {
     if (!FlacLibrary.isAvailable()) {
       fail("Flac library not available.");
     }
@@ -39,7 +43,8 @@ protected void setUp() throws Exception {
 
   public void testGetSeekMap_returnsSeekMapWithCorrectDuration()
       throws IOException, FlacDecoderException, InterruptedException {
-    byte[] data = TestUtil.getByteArray(getInstrumentation().getContext(), NOSEEKTABLE_FLAC);
+    byte[] data =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), NOSEEKTABLE_FLAC);
 
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
     FlacDecoderJni decoderJni = new FlacDecoderJni();
@@ -57,7 +62,8 @@ public void testGetSeekMap_returnsSeekMapWithCorrectDuration()
 
   public void testSetSeekTargetUs_returnsSeekPending()
       throws IOException, FlacDecoderException, InterruptedException {
-    byte[] data = TestUtil.getByteArray(getInstrumentation().getContext(), NOSEEKTABLE_FLAC);
+    byte[] data =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), NOSEEKTABLE_FLAC);
 
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
     FlacDecoderJni decoderJni = new FlacDecoderJni();
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorSeekTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorSeekTest.java
index 58ab260277..6008d99448 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorSeekTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorSeekTest.java
@@ -16,11 +16,13 @@
 package com.google.android.exoplayer2.ext.flac;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 import android.content.Context;
 import android.net.Uri;
-import android.support.annotation.Nullable;
-import android.test.InstrumentationTestCase;
+import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -38,9 +40,12 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.Random;
+import org.junit.Before;
+import org.junit.runner.RunWith;
 
 /** Seeking tests for {@link FlacExtractor} when the FLAC stream does not have a SEEKTABLE. */
-public final class FlacExtractorSeekTest extends InstrumentationTestCase {
+@RunWith(AndroidJUnit4.class)
+public final class FlacExtractorSeekTest {
 
   private static final String NO_SEEKTABLE_FLAC = "bear_no_seek.flac";
   private static final int DURATION_US = 2_741_000;
@@ -54,18 +59,18 @@
   private PositionHolder positionHolder;
   private long totalInputLength;
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  @Before
+  public void setUp() throws Exception {
     if (!FlacLibrary.isAvailable()) {
       fail("Flac library not available.");
     }
     expectedOutput = new FakeExtractorOutput();
-    extractAllSamplesFromFileToExpectedOutput(getInstrumentation().getContext(), NO_SEEKTABLE_FLAC);
+    extractAllSamplesFromFileToExpectedOutput(
+        ApplicationProvider.getApplicationContext(), NO_SEEKTABLE_FLAC);
     expectedTrackOutput = expectedOutput.trackOutputs.get(0);
 
     dataSource =
-        new DefaultDataSourceFactory(getInstrumentation().getContext(), "UserAgent")
+        new DefaultDataSourceFactory(ApplicationProvider.getApplicationContext(), "UserAgent")
             .createDataSource();
     totalInputLength = readInputLength();
     positionHolder = new PositionHolder();
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
index 29a597daa4..d9cbac6ad5 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
@@ -15,17 +15,20 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
-import android.test.InstrumentationTestCase;
+import static org.junit.Assert.fail;
+
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
+import org.junit.Before;
+import org.junit.runner.RunWith;
 
-/**
- * Unit test for {@link FlacExtractor}.
- */
-public class FlacExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link FlacExtractor}. */
+@RunWith(AndroidJUnit4.class)
+public class FlacExtractorTest {
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
+  @Before
+  public void setUp() throws Exception {
     if (!FlacLibrary.isAvailable()) {
       fail("Flac library not available.");
     }
@@ -33,11 +36,11 @@ protected void setUp() throws Exception {
 
   public void testExtractFlacSample() throws Exception {
     ExtractorAsserts.assertBehavior(
-        FlacExtractor::new, "bear.flac", getInstrumentation().getContext());
+        FlacExtractor::new, "bear.flac", ApplicationProvider.getApplicationContext());
   }
 
   public void testExtractFlacSampleWithId3Header() throws Exception {
     ExtractorAsserts.assertBehavior(
-        FlacExtractor::new, "bear_with_id3.flac", getInstrumentation().getContext());
+        FlacExtractor::new, "bear_with_id3.flac", ApplicationProvider.getApplicationContext());
   }
 }
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index 99ddba55c4..1cd9483178 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -15,21 +15,21 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
-import static androidx.test.InstrumentationRegistry.getContext;
 import static org.junit.Assert.fail;
 
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import org.junit.Before;
@@ -56,7 +56,7 @@ public void testBasicPlayback() throws Exception {
 
   private void playUri(String uri) throws Exception {
     TestPlaybackRunnable testPlaybackRunnable =
-        new TestPlaybackRunnable(Uri.parse(uri), getContext());
+        new TestPlaybackRunnable(Uri.parse(uri), ApplicationProvider.getApplicationContext());
     Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
     thread.join();
@@ -83,12 +83,12 @@ public void run() {
       Looper.prepare();
       LibflacAudioRenderer audioRenderer = new LibflacAudioRenderer();
       DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-      player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
+      player = ExoPlayerFactory.newInstance(context, new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
       MediaSource mediaSource =
-          new ExtractorMediaSource.Factory(
-                  new DefaultDataSourceFactory(context, "ExoPlayerExtFlacTest"))
-              .setExtractorsFactory(MatroskaExtractor.FACTORY)
+          new ProgressiveMediaSource.Factory(
+                  new DefaultDataSourceFactory(context, "ExoPlayerExtFlacTest"),
+                  MatroskaExtractor.FACTORY)
               .createMediaSource(uri);
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index 8f5dcef16b..bb72e114fe 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -17,8 +17,8 @@
 
 import static com.google.android.exoplayer2.util.Util.getPcmEncoding;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
@@ -94,7 +94,7 @@
 
   /** Constructs an instance with flags = 0. */
   public FlacExtractor() {
-    this(0);
+    this(/* flags= */ 0);
   }
 
   /**
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index 424fcbb285..ac7646cc4b 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -42,7 +42,9 @@ public LibflacAudioRenderer() {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+  public LibflacAudioRenderer(
+      Handler eventHandler,
+      AudioRendererEventListener eventListener,
       AudioProcessor... audioProcessors) {
     super(eventHandler, eventListener, audioProcessors);
   }
diff --git a/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java b/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java
index 79c4452928..611197bbe5 100644
--- a/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java
+++ b/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultExtractorsFactoryTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.amr.AmrExtractor;
@@ -27,6 +28,7 @@
 import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
 import com.google.android.exoplayer2.extractor.ogg.OggExtractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.Ac4Extractor;
 import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
 import com.google.android.exoplayer2.extractor.ts.PsExtractor;
 import com.google.android.exoplayer2.extractor.ts.TsExtractor;
@@ -35,10 +37,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link DefaultExtractorsFactory}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DefaultExtractorsFactoryTest {
 
   @Test
@@ -59,6 +60,7 @@ public void testCreateExtractors_returnExpectedClasses() {
           Mp3Extractor.class,
           AdtsExtractor.class,
           Ac3Extractor.class,
+          Ac4Extractor.class,
           TsExtractor.class,
           FlvExtractor.class,
           OggExtractor.class,
diff --git a/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultRenderersFactoryTest.java b/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultRenderersFactoryTest.java
new file mode 100644
index 0000000000..fb20ff1114
--- /dev/null
+++ b/extensions/flac/src/test/java/com/google/android/exoplayer2/ext/flac/DefaultRenderersFactoryTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.flac;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.DefaultRenderersFactoryAsserts;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link DefaultRenderersFactoryTest} with {@link LibflacAudioRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public final class DefaultRenderersFactoryTest {
+
+  @Test
+  public void createRenderers_instantiatesVpxRenderer() {
+    DefaultRenderersFactoryAsserts.assertExtensionRendererCreated(
+        LibflacAudioRenderer.class, C.TRACK_TYPE_AUDIO);
+  }
+}
diff --git a/extensions/flac/src/test/resources/robolectric.properties b/extensions/flac/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/extensions/flac/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/extensions/gvr/README.md b/extensions/gvr/README.md
index 5dab885436..1874ff77d7 100644
--- a/extensions/gvr/README.md
+++ b/extensions/gvr/README.md
@@ -37,4 +37,4 @@ locally. Instructions for doing this can be found in ExoPlayer's
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.gvr.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index af973e1345..50acd6c040 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -27,12 +26,16 @@ android {
         minSdkVersion 19
         targetSdkVersion project.ext.targetSdkVersion
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
-    implementation 'com.google.vr:sdk-audio:1.80.0'
+    implementation project(modulePrefix + 'library-ui')
+    implementation 'androidx.annotation:annotation:1.0.2'
+    api 'com.google.vr:sdk-base:1.190.0'
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
 }
 
 ext {
diff --git a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
index eca31c98e4..02e4328ec7 100644
--- a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
+++ b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.gvr;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.Format;
@@ -38,9 +38,11 @@
   private static final int FRAMES_PER_OUTPUT_BUFFER = 1024;
   private static final int OUTPUT_CHANNEL_COUNT = 2;
   private static final int OUTPUT_FRAME_SIZE = OUTPUT_CHANNEL_COUNT * 2; // 16-bit stereo output.
+  private static final int NO_SURROUND_FORMAT = GvrAudioSurround.SurroundFormat.INVALID;
 
   private int sampleRateHz;
   private int channelCount;
+  private int pendingGvrAudioSurroundFormat;
   @Nullable private GvrAudioSurround gvrAudioSurround;
   private ByteBuffer buffer;
   private boolean inputEnded;
@@ -57,6 +59,7 @@ public GvrAudioProcessor() {
     sampleRateHz = Format.NO_VALUE;
     channelCount = Format.NO_VALUE;
     buffer = EMPTY_BUFFER;
+    pendingGvrAudioSurroundFormat = NO_SURROUND_FORMAT;
   }
 
   /**
@@ -92,33 +95,28 @@ public synchronized boolean configure(
     }
     this.sampleRateHz = sampleRateHz;
     this.channelCount = channelCount;
-    maybeReleaseGvrAudioSurround();
-    int surroundFormat;
     switch (channelCount) {
       case 1:
-        surroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_MONO;
+        pendingGvrAudioSurroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_MONO;
         break;
       case 2:
-        surroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_STEREO;
+        pendingGvrAudioSurroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_STEREO;
         break;
       case 4:
-        surroundFormat = GvrAudioSurround.SurroundFormat.FIRST_ORDER_AMBISONICS;
+        pendingGvrAudioSurroundFormat = GvrAudioSurround.SurroundFormat.FIRST_ORDER_AMBISONICS;
         break;
       case 6:
-        surroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_FIVE_DOT_ONE;
+        pendingGvrAudioSurroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_FIVE_DOT_ONE;
         break;
       case 9:
-        surroundFormat = GvrAudioSurround.SurroundFormat.SECOND_ORDER_AMBISONICS;
+        pendingGvrAudioSurroundFormat = GvrAudioSurround.SurroundFormat.SECOND_ORDER_AMBISONICS;
         break;
       case 16:
-        surroundFormat = GvrAudioSurround.SurroundFormat.THIRD_ORDER_AMBISONICS;
+        pendingGvrAudioSurroundFormat = GvrAudioSurround.SurroundFormat.THIRD_ORDER_AMBISONICS;
         break;
       default:
         throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
-    gvrAudioSurround = new GvrAudioSurround(surroundFormat, sampleRateHz, channelCount,
-        FRAMES_PER_OUTPUT_BUFFER);
-    gvrAudioSurround.updateNativeOrientation(w, x, y, z);
     if (buffer == EMPTY_BUFFER) {
       buffer = ByteBuffer.allocateDirect(FRAMES_PER_OUTPUT_BUFFER * OUTPUT_FRAME_SIZE)
           .order(ByteOrder.nativeOrder());
@@ -128,7 +126,7 @@ public synchronized boolean configure(
 
   @Override
   public boolean isActive() {
-    return gvrAudioSurround != null;
+    return pendingGvrAudioSurroundFormat != NO_SURROUND_FORMAT || gvrAudioSurround != null;
   }
 
   @Override
@@ -156,14 +154,17 @@ public void queueInput(ByteBuffer input) {
 
   @Override
   public void queueEndOfStream() {
-    Assertions.checkNotNull(gvrAudioSurround);
+    if (gvrAudioSurround != null) {
+      gvrAudioSurround.triggerProcessing();
+    }
     inputEnded = true;
-    gvrAudioSurround.triggerProcessing();
   }
 
   @Override
   public ByteBuffer getOutput() {
-    Assertions.checkNotNull(gvrAudioSurround);
+    if (gvrAudioSurround == null) {
+      return EMPTY_BUFFER;
+    }
     int writtenBytes = gvrAudioSurround.getOutput(buffer, 0, buffer.capacity());
     buffer.position(0).limit(writtenBytes);
     return buffer;
@@ -171,13 +172,20 @@ public ByteBuffer getOutput() {
 
   @Override
   public boolean isEnded() {
-    Assertions.checkNotNull(gvrAudioSurround);
-    return inputEnded && gvrAudioSurround.getAvailableOutputSize() == 0;
+    return inputEnded
+        && (gvrAudioSurround == null || gvrAudioSurround.getAvailableOutputSize() == 0);
   }
 
   @Override
   public void flush() {
-    if (gvrAudioSurround != null) {
+    if (pendingGvrAudioSurroundFormat != NO_SURROUND_FORMAT) {
+      maybeReleaseGvrAudioSurround();
+      gvrAudioSurround =
+          new GvrAudioSurround(
+              pendingGvrAudioSurroundFormat, sampleRateHz, channelCount, FRAMES_PER_OUTPUT_BUFFER);
+      gvrAudioSurround.updateNativeOrientation(w, x, y, z);
+      pendingGvrAudioSurroundFormat = NO_SURROUND_FORMAT;
+    } else if (gvrAudioSurround != null) {
       gvrAudioSurround.flush();
     }
     inputEnded = false;
@@ -191,13 +199,13 @@ public synchronized void reset() {
     sampleRateHz = Format.NO_VALUE;
     channelCount = Format.NO_VALUE;
     buffer = EMPTY_BUFFER;
+    pendingGvrAudioSurroundFormat = NO_SURROUND_FORMAT;
   }
 
   private void maybeReleaseGvrAudioSurround() {
-    if (this.gvrAudioSurround != null) {
-      GvrAudioSurround gvrAudioSurround = this.gvrAudioSurround;
-      this.gvrAudioSurround = null;
+    if (gvrAudioSurround != null) {
       gvrAudioSurround.release();
+      gvrAudioSurround = null;
     }
   }
 
diff --git a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrPlayerActivity.java b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrPlayerActivity.java
new file mode 100644
index 0000000000..2c912c17f2
--- /dev/null
+++ b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrPlayerActivity.java
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.ext.gvr;
+
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.SurfaceTexture;
+import android.opengl.Matrix;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import androidx.annotation.BinderThread;
+import androidx.annotation.CallSuper;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import android.view.ContextThemeWrapper;
+import android.view.MotionEvent;
+import android.view.Surface;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.ui.spherical.GlViewGroup;
+import com.google.android.exoplayer2.ui.spherical.PointerRenderer;
+import com.google.android.exoplayer2.ui.spherical.SceneRenderer;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import com.google.vr.ndk.base.DaydreamApi;
+import com.google.vr.sdk.base.AndroidCompat;
+import com.google.vr.sdk.base.Eye;
+import com.google.vr.sdk.base.GvrActivity;
+import com.google.vr.sdk.base.GvrView;
+import com.google.vr.sdk.base.HeadTransform;
+import com.google.vr.sdk.base.Viewport;
+import com.google.vr.sdk.controller.Controller;
+import com.google.vr.sdk.controller.ControllerManager;
+import javax.microedition.khronos.egl.EGLConfig;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+/** Base activity for VR 360 video playback. */
+public abstract class GvrPlayerActivity extends GvrActivity {
+
+  private static final int EXIT_FROM_VR_REQUEST_CODE = 42;
+
+  private final Handler mainHandler;
+
+  @Nullable private Player player;
+  @MonotonicNonNull private GlViewGroup glView;
+  @MonotonicNonNull private ControllerManager controllerManager;
+  @MonotonicNonNull private SurfaceTexture surfaceTexture;
+  @MonotonicNonNull private Surface surface;
+  @MonotonicNonNull private SceneRenderer scene;
+  @MonotonicNonNull private PlayerControlView playerControl;
+
+  public GvrPlayerActivity() {
+    mainHandler = new Handler(Looper.getMainLooper());
+  }
+
+  @Override
+  protected void onCreate(@Nullable Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setScreenAlwaysOn(true);
+
+    GvrView gvrView = new GvrView(this);
+    // Since videos typically have fewer pixels per degree than the phones, reducing the render
+    // target scaling factor reduces the work required to render the scene.
+    gvrView.setRenderTargetScale(.5f);
+
+    // If a custom theme isn't specified, the Context's theme is used. For VR Activities, this is
+    // the old Android default theme rather than a modern theme. Override this with a custom theme.
+    Context theme = new ContextThemeWrapper(this, R.style.VrTheme);
+    glView = new GlViewGroup(theme, R.layout.vr_ui);
+
+    playerControl = Assertions.checkNotNull(glView.findViewById(R.id.controller));
+    playerControl.setShowVrButton(true);
+    playerControl.setVrButtonListener(v -> exit());
+
+    PointerRenderer pointerRenderer = new PointerRenderer();
+    scene = new SceneRenderer();
+    Renderer renderer = new Renderer(scene, glView, pointerRenderer);
+
+    // Attach glView to gvrView in order to properly handle UI events.
+    gvrView.addView(glView, 0);
+
+    // Standard GvrView configuration
+    gvrView.setEGLConfigChooser(
+        8, 8, 8, 8, // RGBA bits.
+        16, // Depth bits.
+        0); // Stencil bits.
+    gvrView.setRenderer(renderer);
+    setContentView(gvrView);
+
+    // Most Daydream phones can render a 4k video at 60fps in sustained performance mode. These
+    // options can be tweaked along with the render target scale.
+    if (gvrView.setAsyncReprojectionEnabled(true)) {
+      AndroidCompat.setSustainedPerformanceMode(this, true);
+    }
+
+    // Handle the user clicking on the 'X' in the top left corner. Since this is done when the user
+    // has taken the headset out of VR, it should launch the app's exit flow directly rather than
+    // using the transition flow.
+    gvrView.setOnCloseButtonListener(this::finish);
+
+    ControllerManager.EventListener listener =
+        new ControllerManager.EventListener() {
+          @Override
+          public void onApiStatusChanged(int status) {
+            // Do nothing.
+          }
+
+          @Override
+          public void onRecentered() {
+            // TODO if in cardboard mode call gvrView.recenterHeadTracker();
+            glView.post(() -> Util.castNonNull(playerControl).show());
+          }
+        };
+    controllerManager = new ControllerManager(this, listener);
+
+    Controller controller = controllerManager.getController();
+    ControllerEventListener controllerEventListener =
+        new ControllerEventListener(controller, pointerRenderer, glView);
+    controller.setEventListener(controllerEventListener);
+  }
+
+  /**
+   * Sets the {@link Player} to use.
+   *
+   * @param newPlayer The {@link Player} to use, or {@code null} to detach the current player.
+   */
+  protected void setPlayer(@Nullable Player newPlayer) {
+    Assertions.checkNotNull(scene);
+    if (player == newPlayer) {
+      return;
+    }
+    if (player != null) {
+      Player.VideoComponent videoComponent = player.getVideoComponent();
+      if (videoComponent != null) {
+        if (surface != null) {
+          videoComponent.clearVideoSurface(surface);
+        }
+        videoComponent.clearVideoFrameMetadataListener(scene);
+        videoComponent.clearCameraMotionListener(scene);
+      }
+    }
+    player = newPlayer;
+    if (player != null) {
+      Player.VideoComponent videoComponent = player.getVideoComponent();
+      if (videoComponent != null) {
+        videoComponent.setVideoFrameMetadataListener(scene);
+        videoComponent.setCameraMotionListener(scene);
+        videoComponent.setVideoSurface(surface);
+      }
+    }
+    Assertions.checkNotNull(playerControl).setPlayer(player);
+  }
+
+  /**
+   * Sets the default stereo mode. If the played video doesn't contain a stereo mode the default one
+   * is used.
+   *
+   * @param stereoMode A {@link C.StereoMode} value.
+   */
+  protected void setDefaultStereoMode(@C.StereoMode int stereoMode) {
+    Assertions.checkNotNull(scene).setDefaultStereoMode(stereoMode);
+  }
+
+  @CallSuper
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent unused) {
+    if (requestCode == EXIT_FROM_VR_REQUEST_CODE && resultCode == RESULT_OK) {
+      finish();
+    }
+  }
+
+  @Override
+  protected void onResume() {
+    super.onResume();
+    Util.castNonNull(controllerManager).start();
+  }
+
+  @Override
+  protected void onPause() {
+    Util.castNonNull(controllerManager).stop();
+    super.onPause();
+  }
+
+  @Override
+  protected void onDestroy() {
+    setPlayer(null);
+    releaseSurface(surfaceTexture, surface);
+    super.onDestroy();
+  }
+
+  /** Tries to exit gracefully from VR using a VR transition dialog. */
+  @SuppressWarnings("nullness:argument.type.incompatible")
+  protected void exit() {
+    // This needs to use GVR's exit transition to avoid disorienting the user.
+    DaydreamApi api = DaydreamApi.create(this);
+    if (api != null) {
+      api.exitFromVr(this, EXIT_FROM_VR_REQUEST_CODE, null);
+      // Eventually, the Activity's onActivityResult will be called.
+      api.close();
+    } else {
+      finish();
+    }
+  }
+
+  /** Toggles PlayerControl visibility. */
+  @UiThread
+  protected void togglePlayerControlVisibility() {
+    if (Assertions.checkNotNull(playerControl).isVisible()) {
+      playerControl.hide();
+    } else {
+      playerControl.show();
+    }
+  }
+
+  // Called on GL thread.
+  private void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture) {
+    mainHandler.post(
+        () -> {
+          SurfaceTexture oldSurfaceTexture = this.surfaceTexture;
+          Surface oldSurface = this.surface;
+          this.surfaceTexture = surfaceTexture;
+          this.surface = new Surface(surfaceTexture);
+          if (player != null) {
+            Player.VideoComponent videoComponent = player.getVideoComponent();
+            if (videoComponent != null) {
+              videoComponent.setVideoSurface(surface);
+            }
+          }
+          releaseSurface(oldSurfaceTexture, oldSurface);
+        });
+  }
+
+  private static void releaseSurface(
+      @Nullable SurfaceTexture oldSurfaceTexture, @Nullable Surface oldSurface) {
+    if (oldSurfaceTexture != null) {
+      oldSurfaceTexture.release();
+    }
+    if (oldSurface != null) {
+      oldSurface.release();
+    }
+  }
+
+  private class Renderer implements GvrView.StereoRenderer {
+    private static final float Z_NEAR = .1f;
+    private static final float Z_FAR = 100;
+
+    private final float[] viewProjectionMatrix = new float[16];
+    private final SceneRenderer scene;
+    private final GlViewGroup glView;
+    private final PointerRenderer pointerRenderer;
+
+    public Renderer(SceneRenderer scene, GlViewGroup glView, PointerRenderer pointerRenderer) {
+      this.scene = scene;
+      this.glView = glView;
+      this.pointerRenderer = pointerRenderer;
+    }
+
+    @Override
+    public void onNewFrame(HeadTransform headTransform) {}
+
+    @Override
+    public void onDrawEye(Eye eye) {
+      Matrix.multiplyMM(
+          viewProjectionMatrix, 0, eye.getPerspective(Z_NEAR, Z_FAR), 0, eye.getEyeView(), 0);
+      scene.drawFrame(viewProjectionMatrix, eye.getType() == Eye.Type.RIGHT);
+      if (glView.isVisible()) {
+        glView.getRenderer().draw(viewProjectionMatrix);
+        pointerRenderer.draw(viewProjectionMatrix);
+      }
+    }
+
+    @Override
+    public void onFinishFrame(Viewport viewport) {}
+
+    @Override
+    public void onSurfaceCreated(EGLConfig config) {
+      onSurfaceTextureAvailable(scene.init());
+      glView.getRenderer().init();
+      pointerRenderer.init();
+    }
+
+    @Override
+    public void onSurfaceChanged(int width, int height) {}
+
+    @Override
+    public void onRendererShutdown() {
+      glView.getRenderer().shutdown();
+      pointerRenderer.shutdown();
+      scene.shutdown();
+    }
+  }
+
+  private class ControllerEventListener extends Controller.EventListener {
+
+    private final Controller controller;
+    private final PointerRenderer pointerRenderer;
+    private final GlViewGroup glView;
+    private final float[] controllerOrientationMatrix;
+    private boolean clickButtonDown;
+    private boolean appButtonDown;
+
+    public ControllerEventListener(
+        Controller controller, PointerRenderer pointerRenderer, GlViewGroup glView) {
+      this.controller = controller;
+      this.pointerRenderer = pointerRenderer;
+      this.glView = glView;
+      controllerOrientationMatrix = new float[16];
+    }
+
+    @Override
+    @BinderThread
+    public void onUpdate() {
+      controller.update();
+      controller.orientation.toRotationMatrix(controllerOrientationMatrix);
+      pointerRenderer.setControllerOrientation(controllerOrientationMatrix);
+
+      if (clickButtonDown || controller.clickButtonState) {
+        int action;
+        if (clickButtonDown != controller.clickButtonState) {
+          clickButtonDown = controller.clickButtonState;
+          action = clickButtonDown ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_UP;
+        } else {
+          action = MotionEvent.ACTION_MOVE;
+        }
+        glView.post(
+            () -> {
+              float[] angles = controller.orientation.toYawPitchRollRadians(new float[3]);
+              boolean clickedOnView = glView.simulateClick(action, angles[0], angles[1]);
+              if (action == MotionEvent.ACTION_DOWN && !clickedOnView) {
+                togglePlayerControlVisibility();
+              }
+            });
+      } else if (!appButtonDown && controller.appButtonState) {
+        glView.post(GvrPlayerActivity.this::togglePlayerControlVisibility);
+      }
+      appButtonDown = controller.appButtonState;
+    }
+  }
+}
diff --git a/extensions/gvr/src/main/res/layout/vr_ui.xml b/extensions/gvr/src/main/res/layout/vr_ui.xml
new file mode 100644
index 0000000000..e84ee31fe6
--- /dev/null
+++ b/extensions/gvr/src/main/res/layout/vr_ui.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<merge xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  android:id="@+id/video_ui_view"
+  android:layout_width="match_parent"
+  android:layout_height="wrap_content"
+  android:background="@android:color/black"
+  android:orientation="horizontal"
+  tools:ignore="Overdraw">
+  <com.google.android.exoplayer2.ui.PlayerControlView
+    android:id="@+id/controller"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"/>
+</merge>
diff --git a/demos/main/src/main/res/layout/start_download_dialog.xml b/extensions/gvr/src/main/res/values-v21/styles.xml
similarity index 77%
rename from demos/main/src/main/res/layout/start_download_dialog.xml
rename to extensions/gvr/src/main/res/values-v21/styles.xml
index acb9af5d97..276db1b42d 100644
--- a/demos/main/src/main/res/layout/start_download_dialog.xml
+++ b/extensions/gvr/src/main/res/values-v21/styles.xml
@@ -13,7 +13,6 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<ListView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/representation_list"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"/>
+<resources>
+  <style name="VrTheme" parent="android:Theme.Material"/>
+</resources>
diff --git a/extensions/gvr/src/main/res/values/styles.xml b/extensions/gvr/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..ab5fde106a
--- /dev/null
+++ b/extensions/gvr/src/main/res/values/styles.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+  <style name="VrTheme" parent="android:Theme.Holo"/>
+</resources>
diff --git a/extensions/ima/README.md b/extensions/ima/README.md
index e13cd85590..4ed6a5428a 100644
--- a/extensions/ima/README.md
+++ b/extensions/ima/README.md
@@ -5,7 +5,7 @@ The IMA extension is an [AdsLoader][] implementation wrapping the
 alongside content.
 
 [IMA]: https://developers.google.com/interactive-media-ads/docs/sdks/android/
-[AdsLoader]: https://google.github.io/ExoPlayer/doc/reference/index.html?com/google/android/exoplayer2/source/ads/AdsLoader.html
+[AdsLoader]: https://exoplayer.dev/doc/reference/index.html?com/google/android/exoplayer2/source/ads/AdsLoader.html
 
 ## Getting the extension ##
 
@@ -61,4 +61,4 @@ playback.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.ima.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index 22196ff3ab..a91bbbd981 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -28,23 +27,14 @@ android {
         targetSdkVersion project.ext.targetSdkVersion
         consumerProguardFiles 'proguard-rules.txt'
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.10.2'
+    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.11.2'
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.google.android.gms:play-services-ads:17.1.1'
-    // These dependencies are necessary to force the supportLibraryVersion of
-    // com.android.support:support-v4 and com.android.support:customtabs to be
-    // used. Else older versions are used, for example via:
-    // com.google.android.gms:play-services-ads:17.1.1
-    // |-- com.android.support:customtabs:26.1.0
-    implementation 'com.android.support:support-v4:' + supportLibraryVersion
-    implementation 'com.android.support:customtabs:' + supportLibraryVersion
-    testImplementation 'com.google.truth:truth:' + truthVersion
-    testImplementation 'junit:junit:' + junitVersion
-    testImplementation 'org.mockito:mockito-core:' + mockitoVersion
-    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
+    implementation 'com.google.android.gms:play-services-ads-identifier:16.0.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 6ca3bfd881..465ad51ac5 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -19,8 +19,10 @@
 import android.net.Uri;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import android.view.View;
 import android.view.ViewGroup;
 import com.google.ads.interactivemedia.v3.api.Ad;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
@@ -46,7 +48,6 @@
 import com.google.ads.interactivemedia.v3.api.player.VideoProgressUpdate;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
@@ -73,7 +74,17 @@
 import java.util.Map;
 import java.util.Set;
 
-/** Loads ads using the IMA SDK. All methods are called on the main thread. */
+/**
+ * {@link AdsLoader} using the IMA SDK. All methods must be called on the main thread.
+ *
+ * <p>The player instance that will play the loaded ads must be set before playback using {@link
+ * #setPlayer(Player)}. If the ads loader is no longer required, it must be released by calling
+ * {@link #release()}.
+ *
+ * <p>The IMA SDK can take into account video control overlay views when calculating ad viewability.
+ * For more details see {@link AdDisplayContainer#registerVideoControlsOverlay(View)} and {@link
+ * AdViewProvider#getAdOverlayViews()}.
+ */
 public final class ImaAdsLoader
     implements Player.EventListener,
         AdsLoader,
@@ -92,9 +103,9 @@
 
     private final Context context;
 
-    private @Nullable ImaSdkSettings imaSdkSettings;
-    private @Nullable AdEventListener adEventListener;
-    private @Nullable Set<UiElement> adUiElements;
+    @Nullable private ImaSdkSettings imaSdkSettings;
+    @Nullable private AdEventListener adEventListener;
+    @Nullable private Set<UiElement> adUiElements;
     private int vastLoadTimeoutMs;
     private int mediaLoadTimeoutMs;
     private int mediaBitrate;
@@ -206,7 +217,7 @@ public Builder setFocusSkipButtonWhenAvailable(boolean focusSkipButtonWhenAvaila
       return this;
     }
 
-    // @VisibleForTesting
+    @VisibleForTesting
     /* package */ Builder setImaFactory(ImaFactory imaFactory) {
       this.imaFactory = Assertions.checkNotNull(imaFactory);
       return this;
@@ -316,10 +327,11 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private final AdDisplayContainer adDisplayContainer;
   private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
+  @Nullable private Player nextPlayer;
   private Object pendingAdRequestContext;
   private List<String> supportedMimeTypes;
-  private EventListener eventListener;
-  private Player player;
+  @Nullable private EventListener eventListener;
+  @Nullable private Player player;
   private VideoProgressUpdate lastContentProgress;
   private VideoProgressUpdate lastAdProgress;
   private int lastVolumePercentage;
@@ -459,11 +471,11 @@ private ImaAdsLoader(
     }
     imaSdkSettings.setPlayerType(IMA_SDK_SETTINGS_PLAYER_TYPE);
     imaSdkSettings.setPlayerVersion(IMA_SDK_SETTINGS_PLAYER_VERSION);
-    adsLoader = imaFactory.createAdsLoader(context, imaSdkSettings);
     period = new Timeline.Period();
     adCallbacks = new ArrayList<>(/* initialCapacity= */ 1);
     adDisplayContainer = imaFactory.createAdDisplayContainer();
     adDisplayContainer.setPlayer(/* videoAdPlayer= */ this);
+    adsLoader = imaFactory.createAdsLoader(context, imaSdkSettings, adDisplayContainer);
     adsLoader.addAdErrorListener(/* adErrorListener= */ this);
     adsLoader.addAdsLoadedListener(/* adsLoadedListener= */ this);
     fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
@@ -481,13 +493,29 @@ private ImaAdsLoader(
     return adsLoader;
   }
 
+  /**
+   * Returns the {@link AdDisplayContainer} used by this loader.
+   *
+   * <p>Note: any video controls overlays registered via {@link
+   * AdDisplayContainer#registerVideoControlsOverlay(View)} will be unregistered automatically when
+   * the media source detaches from this instance. It is therefore necessary to re-register views
+   * each time the ads loader is reused. Alternatively, provide overlay views via the {@link
+   * AdsLoader.AdViewProvider} when creating the media source to benefit from automatic
+   * registration.
+   */
+  public AdDisplayContainer getAdDisplayContainer() {
+    return adDisplayContainer;
+  }
+
   /**
    * Sets the slots for displaying companion ads. Individual slots can be created using {@link
    * ImaSdkFactory#createCompanionAdSlot()}.
    *
    * @param companionSlots Slots for displaying companion ads.
    * @see AdDisplayContainer#setCompanionSlots(Collection)
+   * @deprecated Use {@code getAdDisplayContainer().setCompanionSlots(...)}.
    */
+  @Deprecated
   public void setCompanionSlots(Collection<CompanionAdSlot> companionSlots) {
     adDisplayContainer.setCompanionSlots(companionSlots);
   }
@@ -499,14 +527,14 @@ public void setCompanionSlots(Collection<CompanionAdSlot> companionSlots) {
    * called, so it is only necessary to call this method if you want to request ads before preparing
    * the player.
    *
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param adViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
    */
-  public void requestAds(ViewGroup adUiViewGroup) {
+  public void requestAds(ViewGroup adViewGroup) {
     if (adPlaybackState != null || adsManager != null || pendingAdRequestContext != null) {
       // Ads have already been requested.
       return;
     }
-    adDisplayContainer.setAdContainer(adUiViewGroup);
+    adDisplayContainer.setAdContainer(adViewGroup);
     pendingAdRequestContext = new Object();
     AdsRequest request = imaFactory.createAdsRequest();
     if (adTagUri != null) {
@@ -517,7 +545,6 @@ public void requestAds(ViewGroup adUiViewGroup) {
     if (vastLoadTimeoutMs != TIMEOUT_UNSET) {
       request.setVastLoadTimeout(vastLoadTimeoutMs);
     }
-    request.setAdDisplayContainer(adDisplayContainer);
     request.setContentProgressProvider(this);
     request.setUserRequestContext(pendingAdRequestContext);
     adsLoader.requestAds(request);
@@ -525,6 +552,14 @@ public void requestAds(ViewGroup adUiViewGroup) {
 
   // AdsLoader implementation.
 
+  @Override
+  public void setPlayer(@Nullable Player player) {
+    Assertions.checkState(Looper.getMainLooper() == Looper.myLooper());
+    Assertions.checkState(
+        player == null || player.getApplicationLooper() == Looper.getMainLooper());
+    nextPlayer = player;
+  }
+
   @Override
   public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
     List<String> supportedMimeTypes = new ArrayList<>();
@@ -549,14 +584,20 @@ public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
   }
 
   @Override
-  public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup) {
-    Assertions.checkArgument(player.getApplicationLooper() == Looper.getMainLooper());
-    this.player = player;
+  public void start(EventListener eventListener, AdViewProvider adViewProvider) {
+    Assertions.checkNotNull(
+        nextPlayer, "Set player using adsLoader.setPlayer before preparing the player.");
+    player = nextPlayer;
     this.eventListener = eventListener;
     lastVolumePercentage = 0;
     lastAdProgress = null;
     lastContentProgress = null;
-    adDisplayContainer.setAdContainer(adUiViewGroup);
+    ViewGroup adViewGroup = adViewProvider.getAdViewGroup();
+    adDisplayContainer.setAdContainer(adViewGroup);
+    View[] adOverlayViews = adViewProvider.getAdOverlayViews();
+    for (View view : adOverlayViews) {
+      adDisplayContainer.registerVideoControlsOverlay(view);
+    }
     player.addListener(this);
     maybeNotifyPendingAdLoadError();
     if (adPlaybackState != null) {
@@ -570,12 +611,12 @@ public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGrou
       startAdPlayback();
     } else {
       // Ads haven't loaded yet, so request them.
-      requestAds(adUiViewGroup);
+      requestAds(adViewGroup);
     }
   }
 
   @Override
-  public void detachPlayer() {
+  public void stop() {
     if (adsManager != null && imaPausedContent) {
       adPlaybackState =
           adPlaybackState.withAdResumePositionUs(
@@ -585,6 +626,7 @@ public void detachPlayer() {
     lastVolumePercentage = getVolume();
     lastAdProgress = getAdProgress();
     lastContentProgress = getContentProgress();
+    adDisplayContainer.unregisterAllVideoControlsOverlays();
     player.removeListener(this);
     player = null;
     eventListener = null;
@@ -597,6 +639,8 @@ public void release() {
       adsManager.destroy();
       adsManager = null;
     }
+    adsLoader.removeAdsLoadedListener(/* adsLoadedListener= */ this);
+    adsLoader.removeAdErrorListener(/* adErrorListener= */ this);
     imaPausedContent = false;
     imaAdState = IMA_AD_STATE_NONE;
     pendingAdLoadError = null;
@@ -712,7 +756,8 @@ public VideoProgressUpdate getContentProgress() {
       // until MAXIMUM_PRELOAD_DURATION_MS before the ad so that an ad group load error delivered
       // just after an ad group isn't incorrectly attributed to the next ad group.
       int nextAdGroupIndex =
-          adPlaybackState.getAdGroupIndexAfterPositionUs(C.msToUs(contentPositionMs));
+          adPlaybackState.getAdGroupIndexAfterPositionUs(
+              C.msToUs(contentPositionMs), C.msToUs(contentDurationMs));
       if (nextAdGroupIndex != expectedAdGroupIndex && nextAdGroupIndex != C.INDEX_UNSET) {
         long nextAdGroupTimeMs = C.usToMs(adPlaybackState.adGroupTimesUs[nextAdGroupIndex]);
         if (nextAdGroupTimeMs == C.TIME_END_OF_SOURCE) {
@@ -1329,7 +1374,8 @@ private void maybeNotifyInternalError(String name, Exception cause) {
   private static boolean isAdGroupLoadError(AdError adError) {
     // TODO: Find out what other errors need to be handled (if any), and whether each one relates to
     // a single ad, ad group or the whole timeline.
-    return adError.getErrorCode() == AdErrorCode.VAST_LINEAR_ASSET_MISMATCH;
+    return adError.getErrorCode() == AdErrorCode.VAST_LINEAR_ASSET_MISMATCH
+        || adError.getErrorCode() == AdErrorCode.UNKNOWN_ERROR;
   }
 
   private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
@@ -1345,7 +1391,7 @@ private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
   }
 
   /** Factory for objects provided by the IMA SDK. */
-  // @VisibleForTesting
+  @VisibleForTesting
   /* package */ interface ImaFactory {
     /** @see ImaSdkSettings */
     ImaSdkSettings createImaSdkSettings();
@@ -1355,9 +1401,9 @@ private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
     AdDisplayContainer createAdDisplayContainer();
     /** @see com.google.ads.interactivemedia.v3.api.ImaSdkFactory#createAdsRequest() */
     AdsRequest createAdsRequest();
-    /** @see ImaSdkFactory#createAdsLoader(Context, ImaSdkSettings) */
+    /** @see ImaSdkFactory#createAdsLoader(Context, ImaSdkSettings, AdDisplayContainer) */
     com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
-        Context context, ImaSdkSettings imaSdkSettings);
+        Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer);
   }
 
   /** Default {@link ImaFactory} for non-test usage, which delegates to {@link ImaSdkFactory}. */
@@ -1384,8 +1430,9 @@ public AdsRequest createAdsRequest() {
 
     @Override
     public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
-        Context context, ImaSdkSettings imaSdkSettings) {
-      return ImaSdkFactory.getInstance().createAdsLoader(context, imaSdkSettings);
+        Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer) {
+      return ImaSdkFactory.getInstance()
+          .createAdsLoader(context, imaSdkSettings, adDisplayContainer);
     }
   }
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
deleted file mode 100644
index 85042c4354..0000000000
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.ext.ima;
-
-import android.os.Handler;
-import android.support.annotation.Nullable;
-import android.view.ViewGroup;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.BaseMediaSource;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSource.SourceInfoRefreshListener;
-import com.google.android.exoplayer2.source.ads.AdsMediaSource;
-import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.TransferListener;
-import java.io.IOException;
-
-/**
- * A {@link MediaSource} that inserts ads linearly with a provided content media source.
- *
- * @deprecated Use com.google.android.exoplayer2.source.ads.AdsMediaSource with ImaAdsLoader.
- */
-@Deprecated
-public final class ImaAdsMediaSource extends BaseMediaSource implements SourceInfoRefreshListener {
-
-  private final AdsMediaSource adsMediaSource;
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by
-   * {@code contentMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param dataSourceFactory Factory for data sources used to load ad media.
-   * @param imaAdsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   */
-  public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
-      ImaAdsLoader imaAdsLoader, ViewGroup adUiViewGroup) {
-    this(contentMediaSource, dataSourceFactory, imaAdsLoader, adUiViewGroup, null, null);
-  }
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param dataSourceFactory Factory for data sources used to load ad media.
-   * @param imaAdsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public ImaAdsMediaSource(
-      MediaSource contentMediaSource,
-      DataSource.Factory dataSourceFactory,
-      ImaAdsLoader imaAdsLoader,
-      ViewGroup adUiViewGroup,
-      @Nullable Handler eventHandler,
-      @Nullable AdsMediaSource.EventListener eventListener) {
-    adsMediaSource = new AdsMediaSource(contentMediaSource, dataSourceFactory, imaAdsLoader,
-        adUiViewGroup, eventHandler, eventListener);
-  }
-
-  @Override
-  @Nullable
-  public Object getTag() {
-    return adsMediaSource.getTag();
-  }
-
-  @Override
-  public void prepareSourceInternal(
-      final ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    adsMediaSource.prepareSource(
-        player, isTopLevelSource, /* listener= */ this, mediaTransferListener);
-  }
-
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    adsMediaSource.maybeThrowSourceInfoRefreshError();
-  }
-
-  @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    return adsMediaSource.createPeriod(id, allocator);
-  }
-
-  @Override
-  public void releasePeriod(MediaPeriod mediaPeriod) {
-    adsMediaSource.releasePeriod(mediaPeriod);
-  }
-
-  @Override
-  public void releaseSourceInternal() {
-    adsMediaSource.releaseSource(/* listener= */ this);
-  }
-
-  @Override
-  public void onSourceInfoRefreshed(
-      MediaSource source, Timeline timeline, @Nullable Object manifest) {
-    refreshSourceInfo(timeline, manifest);
-  }
-}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
index b626a08780..59dfc6473c 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
@@ -64,14 +64,17 @@ public double getTimeOffset() {
         };
   }
 
+  @Override
   public int getVastMediaWidth() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getVastMediaHeight() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getVastMediaBitrate() {
     throw new UnsupportedOperationException();
   }
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
index b8024d6534..d20ccbd728 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.testutil.StubExoPlayer;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import java.util.ArrayList;
 
 /** A fake player for testing content/ad playback. */
@@ -109,6 +110,11 @@ public void setState(int state, boolean playWhenReady) {
 
   // ExoPlayer methods. Other methods are unsupported.
 
+  @Override
+  public AudioComponent getAudioComponent() {
+    return null;
+  }
+
   @Override
   public Looper getApplicationLooper() {
     return Looper.getMainLooper();
@@ -134,6 +140,16 @@ public boolean getPlayWhenReady() {
     return playWhenReady;
   }
 
+  @Override
+  public int getRendererCount() {
+    return 0;
+  }
+
+  @Override
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return new TrackSelectionArray();
+  }
+
   @Override
   public Timeline getCurrentTimeline() {
     return timeline;
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
index b0fe731480..1e1935c63a 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
@@ -17,13 +17,17 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import android.view.View;
 import android.view.ViewGroup;
 import android.widget.FrameLayout;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.ads.interactivemedia.v3.api.Ad;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
 import com.google.ads.interactivemedia.v3.api.AdEvent;
@@ -49,13 +53,12 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Test for {@link ImaAdsLoader}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class ImaAdsLoaderTest {
 
   private static final long CONTENT_DURATION_US = 10 * C.MICROS_PER_SECOND;
@@ -73,7 +76,9 @@
   private @Mock AdDisplayContainer adDisplayContainer;
   private @Mock AdsManager adsManager;
   private SingletonImaFactory testImaFactory;
-  private ViewGroup adUiViewGroup;
+  private ViewGroup adViewGroup;
+  private View adOverlayView;
+  private AdsLoader.AdViewProvider adViewProvider;
   private TestAdsLoaderListener adsLoaderListener;
   private FakePlayer fakeExoPlayer;
   private ImaAdsLoader imaAdsLoader;
@@ -90,7 +95,20 @@ public void setUp() {
             adDisplayContainer,
             fakeAdsRequest,
             fakeAdsLoader);
-    adUiViewGroup = new FrameLayout(RuntimeEnvironment.application);
+    adViewGroup = new FrameLayout(ApplicationProvider.getApplicationContext());
+    adOverlayView = new View(ApplicationProvider.getApplicationContext());
+    adViewProvider =
+        new AdsLoader.AdViewProvider() {
+          @Override
+          public ViewGroup getAdViewGroup() {
+            return adViewGroup;
+          }
+
+          @Override
+          public View[] getAdOverlayViews() {
+            return new View[] {adOverlayView};
+          }
+        };
   }
 
   @After
@@ -109,17 +127,18 @@ public void testBuilder_overridesPlayerType() {
   }
 
   @Test
-  public void testAttachPlayer_setsAdUiViewGroup() {
+  public void testStart_setsAdUiViewGroup() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
 
-    verify(adDisplayContainer, atLeastOnce()).setAdContainer(adUiViewGroup);
+    verify(adDisplayContainer, atLeastOnce()).setAdContainer(adViewGroup);
+    verify(adDisplayContainer, atLeastOnce()).registerVideoControlsOverlay(adOverlayView);
   }
 
   @Test
-  public void testAttachPlayer_updatesAdPlaybackState() {
+  public void testStart_updatesAdPlaybackState() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
 
     assertThat(adsLoaderListener.adPlaybackState)
         .isEqualTo(
@@ -128,17 +147,17 @@ public void testAttachPlayer_updatesAdPlaybackState() {
   }
 
   @Test
-  public void testAttachAfterRelease() {
+  public void testStartAfterRelease() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
     imaAdsLoader.release();
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
   }
 
   @Test
-  public void testAttachAndCallbacksAfterRelease() {
+  public void testStartAndCallbacksAfterRelease() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
     imaAdsLoader.release();
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
     fakeExoPlayer.setPlayingContentPosition(/* position= */ 0);
     fakeExoPlayer.setState(Player.STATE_READY, true);
 
@@ -146,7 +165,7 @@ public void testAttachAndCallbacksAfterRelease() {
     // Note: we can't currently call getContentProgress/getAdProgress as a VerifyError is thrown
     // when using Robolectric and accessing VideoProgressUpdate.VIDEO_TIME_NOT_READY, due to the IMA
     // SDK being proguarded.
-    imaAdsLoader.requestAds(adUiViewGroup);
+    imaAdsLoader.requestAds(adViewGroup);
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.LOADED, UNSKIPPABLE_AD));
     imaAdsLoader.loadAd(TEST_URI.toString());
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_PAUSE_REQUESTED, UNSKIPPABLE_AD));
@@ -166,7 +185,7 @@ public void testPlayback_withPrerollAd_marksAdAsPlayed() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
 
     // Load the preroll ad.
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.LOADED, UNSKIPPABLE_AD));
     imaAdsLoader.loadAd(TEST_URI.toString());
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_PAUSE_REQUESTED, UNSKIPPABLE_AD));
@@ -201,15 +220,28 @@ public void testPlayback_withPrerollAd_marksAdAsPlayed() {
                 .withAdResumePositionUs(/* adResumePositionUs= */ 0));
   }
 
+  @Test
+  public void testStop_unregistersAllVideoControlOverlays() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
+    imaAdsLoader.requestAds(adViewGroup);
+    imaAdsLoader.stop();
+
+    InOrder inOrder = inOrder(adDisplayContainer);
+    inOrder.verify(adDisplayContainer).registerVideoControlsOverlay(adOverlayView);
+    inOrder.verify(adDisplayContainer).unregisterAllVideoControlsOverlays();
+  }
+
   private void setupPlayback(Timeline contentTimeline, long[][] adDurationsUs, Float[] cuePoints) {
     fakeExoPlayer = new FakePlayer();
     adsLoaderListener = new TestAdsLoaderListener(fakeExoPlayer, contentTimeline, adDurationsUs);
     when(adsManager.getAdCuePoints()).thenReturn(Arrays.asList(cuePoints));
     imaAdsLoader =
-        new ImaAdsLoader.Builder(RuntimeEnvironment.application)
+        new ImaAdsLoader.Builder(ApplicationProvider.getApplicationContext())
             .setImaFactory(testImaFactory)
             .setImaSdkSettings(imaSdkSettings)
             .buildForAdTag(TEST_URI);
+    imaAdsLoader.setPlayer(fakeExoPlayer);
   }
 
   private static AdEvent getAdEvent(AdEventType adEventType, @Nullable Ad ad) {
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
index dd46d8a68b..4efd8cf38c 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
@@ -17,6 +17,7 @@
 
 import android.content.Context;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
+import com.google.ads.interactivemedia.v3.api.AdsLoader;
 import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
 import com.google.ads.interactivemedia.v3.api.AdsRequest;
 import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
@@ -64,8 +65,8 @@ public AdsRequest createAdsRequest() {
   }
 
   @Override
-  public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
-      Context context, ImaSdkSettings imaSdkSettings) {
+  public AdsLoader createAdsLoader(
+      Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer) {
     return adsLoader;
   }
 }
diff --git a/extensions/ima/src/test/resources/robolectric.properties b/extensions/ima/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/extensions/ima/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/extensions/jobdispatcher/build.gradle b/extensions/jobdispatcher/build.gradle
index a0e3f8e0c8..d7f19d2545 100644
--- a/extensions/jobdispatcher/build.gradle
+++ b/extensions/jobdispatcher/build.gradle
@@ -18,7 +18,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -29,6 +28,8 @@ android {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
diff --git a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
index b7818546f9..d79dead0d7 100644
--- a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
+++ b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
@@ -57,6 +57,7 @@
  */
 public final class JobDispatcherScheduler implements Scheduler {
 
+  private static final boolean DEBUG = false;
   private static final String TAG = "JobDispatcherScheduler";
   private static final String KEY_SERVICE_ACTION = "service_action";
   private static final String KEY_SERVICE_PACKAGE = "service_package";
@@ -78,8 +79,8 @@ public JobDispatcherScheduler(Context context, String jobTag) {
   }
 
   @Override
-  public boolean schedule(Requirements requirements, String serviceAction, String servicePackage) {
-    Job job = buildJob(jobDispatcher, requirements, jobTag, serviceAction, servicePackage);
+  public boolean schedule(Requirements requirements, String servicePackage, String serviceAction) {
+    Job job = buildJob(jobDispatcher, requirements, jobTag, servicePackage, serviceAction);
     int result = jobDispatcher.schedule(job);
     logd("Scheduling job: " + jobTag + " result: " + result);
     return result == FirebaseJobDispatcher.SCHEDULE_RESULT_SUCCESS;
@@ -96,26 +97,18 @@ private static Job buildJob(
       FirebaseJobDispatcher dispatcher,
       Requirements requirements,
       String tag,
-      String serviceAction,
-      String servicePackage) {
+      String servicePackage,
+      String serviceAction) {
     Job.Builder builder =
         dispatcher
             .newJobBuilder()
             .setService(JobDispatcherSchedulerService.class) // the JobService that will be called
             .setTag(tag);
 
-    switch (requirements.getRequiredNetworkType()) {
-      case Requirements.NETWORK_TYPE_NONE:
-        // do nothing.
-        break;
-      case Requirements.NETWORK_TYPE_ANY:
-        builder.addConstraint(Constraint.ON_ANY_NETWORK);
-        break;
-      case Requirements.NETWORK_TYPE_UNMETERED:
-        builder.addConstraint(Constraint.ON_UNMETERED_NETWORK);
-        break;
-      default:
-        throw new UnsupportedOperationException();
+    if (requirements.isUnmeteredNetworkRequired()) {
+      builder.addConstraint(Constraint.ON_UNMETERED_NETWORK);
+    } else if (requirements.isNetworkRequired()) {
+      builder.addConstraint(Constraint.ON_ANY_NETWORK);
     }
 
     if (requirements.isIdleRequired()) {
@@ -129,7 +122,7 @@ private static Job buildJob(
     Bundle extras = new Bundle();
     extras.putString(KEY_SERVICE_ACTION, serviceAction);
     extras.putString(KEY_SERVICE_PACKAGE, servicePackage);
-    extras.putInt(KEY_REQUIREMENTS, requirements.getRequirementsData());
+    extras.putInt(KEY_REQUIREMENTS, requirements.getRequirements());
     builder.setExtras(extras);
 
     return builder.build();
diff --git a/extensions/leanback/README.md b/extensions/leanback/README.md
index 4eba6552e1..b6eb085247 100644
--- a/extensions/leanback/README.md
+++ b/extensions/leanback/README.md
@@ -28,4 +28,4 @@ locally. Instructions for doing this can be found in ExoPlayer's
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.leanback.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/leanback/build.gradle b/extensions/leanback/build.gradle
index 10bfef8e7c..c6f5a216ce 100644
--- a/extensions/leanback/build.gradle
+++ b/extensions/leanback/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -27,11 +26,14 @@ android {
         minSdkVersion 17
         targetSdkVersion project.ext.targetSdkVersion
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation('com.android.support:leanback-v17:' + supportLibraryVersion)
+    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.leanback:leanback:1.0.0'
 }
 
 ext {
diff --git a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
index 0c9491bb1a..3f4c5d6229 100644
--- a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
+++ b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
@@ -17,11 +17,11 @@
 
 import android.content.Context;
 import android.os.Handler;
-import android.support.annotation.Nullable;
-import android.support.v17.leanback.R;
-import android.support.v17.leanback.media.PlaybackGlueHost;
-import android.support.v17.leanback.media.PlayerAdapter;
-import android.support.v17.leanback.media.SurfaceHolderGlueHost;
+import androidx.annotation.Nullable;
+import androidx.leanback.R;
+import androidx.leanback.media.PlaybackGlueHost;
+import androidx.leanback.media.PlayerAdapter;
+import androidx.leanback.media.SurfaceHolderGlueHost;
 import android.util.Pair;
 import android.view.Surface;
 import android.view.SurfaceHolder;
diff --git a/extensions/mediasession/README.md b/extensions/mediasession/README.md
index bd6b59c0c1..64b55a8036 100644
--- a/extensions/mediasession/README.md
+++ b/extensions/mediasession/README.md
@@ -29,4 +29,4 @@ locally. Instructions for doing this can be found in ExoPlayer's
 * [Javadoc][]: Classes matching
   `com.google.android.exoplayer2.ext.mediasession.*` belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/mediasession/build.gradle b/extensions/mediasession/build.gradle
index 5fb25c6382..6c6ddf4ce4 100644
--- a/extensions/mediasession/build.gradle
+++ b/extensions/mediasession/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -27,11 +26,13 @@ android {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    api 'com.android.support:support-media-compat:' + supportLibraryVersion
+    api 'androidx.media:media:1.0.1'
 }
 
 ext {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
deleted file mode 100644
index 7d983e14e9..0000000000
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.ext.mediasession;
-
-import android.os.Bundle;
-import android.os.ResultReceiver;
-import android.support.v4.media.session.PlaybackStateCompat;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.util.RepeatModeUtil;
-
-/**
- * A default implementation of {@link MediaSessionConnector.PlaybackController}.
- * <p>
- * Methods can be safely overridden by subclasses to intercept calls for given actions.
- */
-public class DefaultPlaybackController implements MediaSessionConnector.PlaybackController {
-
-  /**
-   * The default fast forward increment, in milliseconds.
-   */
-  public static final int DEFAULT_FAST_FORWARD_MS = 15000;
-  /**
-   * The default rewind increment, in milliseconds.
-   */
-  public static final int DEFAULT_REWIND_MS = 5000;
-
-  private static final long BASE_ACTIONS = PlaybackStateCompat.ACTION_PLAY_PAUSE
-      | PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_PAUSE
-      | PlaybackStateCompat.ACTION_STOP | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE
-      | PlaybackStateCompat.ACTION_SET_REPEAT_MODE;
-
-  protected final long rewindIncrementMs;
-  protected final long fastForwardIncrementMs;
-  protected final int repeatToggleModes;
-
-  /**
-   * Creates a new instance.
-   * <p>
-   * Equivalent to {@code DefaultPlaybackController(DefaultPlaybackController.DEFAULT_REWIND_MS,
-   *     DefaultPlaybackController.DEFAULT_FAST_FORWARD_MS,
-   *     MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES)}.
-   */
-  public DefaultPlaybackController() {
-    this(DEFAULT_REWIND_MS, DEFAULT_FAST_FORWARD_MS,
-        MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES);
-  }
-
-  /**
-   * Creates a new instance with the given fast forward and rewind increments.
-   *  @param rewindIncrementMs The rewind increment in milliseconds. A zero or negative value will
-   *     cause the rewind action to be disabled.
-   * @param fastForwardIncrementMs The fast forward increment in milliseconds. A zero or negative
-   * @param repeatToggleModes The available repeatToggleModes.
-   */
-  public DefaultPlaybackController(long rewindIncrementMs, long fastForwardIncrementMs,
-      @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    this.rewindIncrementMs = rewindIncrementMs;
-    this.fastForwardIncrementMs = fastForwardIncrementMs;
-    this.repeatToggleModes = repeatToggleModes;
-  }
-
-  @Override
-  public long getSupportedPlaybackActions(Player player) {
-    if (player == null || player.getCurrentTimeline().isEmpty()) {
-      return 0;
-    } else if (!player.isCurrentWindowSeekable()) {
-      return BASE_ACTIONS;
-    }
-    long actions = BASE_ACTIONS | PlaybackStateCompat.ACTION_SEEK_TO;
-    if (fastForwardIncrementMs > 0) {
-      actions |= PlaybackStateCompat.ACTION_FAST_FORWARD;
-    }
-    if (rewindIncrementMs > 0) {
-      actions |= PlaybackStateCompat.ACTION_REWIND;
-    }
-    return actions;
-  }
-
-  @Override
-  public void onPlay(Player player) {
-    player.setPlayWhenReady(true);
-  }
-
-  @Override
-  public void onPause(Player player) {
-    player.setPlayWhenReady(false);
-  }
-
-  @Override
-  public void onSeekTo(Player player, long position) {
-    long duration = player.getDuration();
-    if (duration != C.TIME_UNSET) {
-      position = Math.min(position, duration);
-    }
-    player.seekTo(Math.max(position, 0));
-  }
-
-  @Override
-  public void onFastForward(Player player) {
-    if (fastForwardIncrementMs <= 0) {
-      return;
-    }
-    onSeekTo(player, player.getCurrentPosition() + fastForwardIncrementMs);
-  }
-
-  @Override
-  public void onRewind(Player player) {
-    if (rewindIncrementMs <= 0) {
-      return;
-    }
-    onSeekTo(player, player.getCurrentPosition() - rewindIncrementMs);
-  }
-
-  @Override
-  public void onStop(Player player) {
-    player.stop(true);
-  }
-
-  @Override
-  public void onSetShuffleMode(Player player, int shuffleMode) {
-    player.setShuffleModeEnabled(shuffleMode == PlaybackStateCompat.SHUFFLE_MODE_ALL
-        || shuffleMode == PlaybackStateCompat.SHUFFLE_MODE_GROUP);
-  }
-
-  @Override
-  public void onSetRepeatMode(Player player, int repeatMode) {
-    int selectedExoPlayerRepeatMode = player.getRepeatMode();
-    switch (repeatMode) {
-      case PlaybackStateCompat.REPEAT_MODE_ALL:
-      case PlaybackStateCompat.REPEAT_MODE_GROUP:
-        if ((repeatToggleModes & RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL) != 0) {
-          selectedExoPlayerRepeatMode = Player.REPEAT_MODE_ALL;
-        }
-        break;
-      case PlaybackStateCompat.REPEAT_MODE_ONE:
-        if ((repeatToggleModes & RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE) != 0) {
-          selectedExoPlayerRepeatMode = Player.REPEAT_MODE_ONE;
-        }
-        break;
-      default:
-        selectedExoPlayerRepeatMode = Player.REPEAT_MODE_OFF;
-        break;
-    }
-    player.setRepeatMode(selectedExoPlayerRepeatMode);
-  }
-
-  // CommandReceiver implementation.
-
-  @Override
-  public String[] getCommands() {
-    return null;
-  }
-
-  @Override
-  public void onCommand(Player player, String command, Bundle extras, ResultReceiver cb) {
-    // Do nothing.
-  }
-
-}
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 9323723601..9c80fabc50 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.mediasession;
 
+import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Bundle;
@@ -22,8 +23,9 @@
 import android.os.Looper;
 import android.os.ResultReceiver;
 import android.os.SystemClock;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.LongDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.support.v4.media.MediaDescriptionCompat;
 import android.support.v4.media.MediaMetadataCompat;
 import android.support.v4.media.RatingCompat;
@@ -32,6 +34,8 @@
 import android.support.v4.media.session.PlaybackStateCompat;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ControlDispatcher;
+import com.google.android.exoplayer2.DefaultControlDispatcher;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -41,6 +45,9 @@
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -61,18 +68,24 @@
  *
  * <ul>
  *   <li>Actions to initiate media playback ({@code PlaybackStateCompat#ACTION_PREPARE_*} and {@code
- *       PlaybackStateCompat#ACTION_PLAY_*}) can be handled by a {@link PlaybackPreparer} passed
- *       when calling {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}. Custom
- *       actions can be handled by passing one or more {@link CustomActionProvider}s in a similar
- *       way.
+ *       PlaybackStateCompat#ACTION_PLAY_*}) can be handled by a {@link PlaybackPreparer} passed to
+ *       {@link #setPlaybackPreparer(PlaybackPreparer)}.
+ *   <li>Custom actions can be handled by passing one or more {@link CustomActionProvider}s to
+ *       {@link #setCustomActionProviders(CustomActionProvider...)}.
  *   <li>To enable a media queue and navigation within it, you can set a {@link QueueNavigator} by
  *       calling {@link #setQueueNavigator(QueueNavigator)}. Use of {@link TimelineQueueNavigator}
  *       is recommended for most use cases.
  *   <li>To enable editing of the media queue, you can set a {@link QueueEditor} by calling {@link
  *       #setQueueEditor(QueueEditor)}.
+ *   <li>A {@link MediaButtonEventHandler} can be set by calling {@link
+ *       #setMediaButtonEventHandler(MediaButtonEventHandler)}. By default media button events are
+ *       handled by {@link MediaSessionCompat.Callback#onMediaButtonEvent(Intent)}.
  *   <li>An {@link ErrorMessageProvider} for providing human readable error messages and
  *       corresponding error codes can be set by calling {@link
  *       #setErrorMessageProvider(ErrorMessageProvider)}.
+ *   <li>A {@link MediaMetadataProvider} can be set by calling {@link
+ *       #setMediaMetadataProvider(MediaMetadataProvider)}. By default the {@link
+ *       DefaultMediaMetadataProvider} is used.
  * </ul>
  */
 public final class MediaSessionConnector {
@@ -81,28 +94,82 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.mediasession");
   }
 
-  /**
-   * The default repeat toggle modes which is the bitmask of {@link
-   * RepeatModeUtil#REPEAT_TOGGLE_MODE_ONE} and {@link RepeatModeUtil#REPEAT_TOGGLE_MODE_ALL}.
-   */
-  public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
-      RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE | RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL;
+  /** Playback actions supported by the connector. */
+  @LongDef(
+      flag = true,
+      value = {
+        PlaybackStateCompat.ACTION_PLAY_PAUSE,
+        PlaybackStateCompat.ACTION_PLAY,
+        PlaybackStateCompat.ACTION_PAUSE,
+        PlaybackStateCompat.ACTION_SEEK_TO,
+        PlaybackStateCompat.ACTION_FAST_FORWARD,
+        PlaybackStateCompat.ACTION_REWIND,
+        PlaybackStateCompat.ACTION_STOP,
+        PlaybackStateCompat.ACTION_SET_REPEAT_MODE,
+        PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE
+      })
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface PlaybackActions {}
+
+  @PlaybackActions
+  public static final long ALL_PLAYBACK_ACTIONS =
+      PlaybackStateCompat.ACTION_PLAY_PAUSE
+          | PlaybackStateCompat.ACTION_PLAY
+          | PlaybackStateCompat.ACTION_PAUSE
+          | PlaybackStateCompat.ACTION_SEEK_TO
+          | PlaybackStateCompat.ACTION_FAST_FORWARD
+          | PlaybackStateCompat.ACTION_REWIND
+          | PlaybackStateCompat.ACTION_STOP
+          | PlaybackStateCompat.ACTION_SET_REPEAT_MODE
+          | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE;
+
+  /** The default playback actions. */
+  @PlaybackActions public static final long DEFAULT_PLAYBACK_ACTIONS = ALL_PLAYBACK_ACTIONS;
+
+  /** The default fast forward increment, in milliseconds. */
+  public static final int DEFAULT_FAST_FORWARD_MS = 15000;
+  /** The default rewind increment, in milliseconds. */
+  public static final int DEFAULT_REWIND_MS = 5000;
 
   public static final String EXTRAS_PITCH = "EXO_PITCH";
+
+  private static final long BASE_PLAYBACK_ACTIONS =
+      PlaybackStateCompat.ACTION_PLAY_PAUSE
+          | PlaybackStateCompat.ACTION_PLAY
+          | PlaybackStateCompat.ACTION_PAUSE
+          | PlaybackStateCompat.ACTION_STOP
+          | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE
+          | PlaybackStateCompat.ACTION_SET_REPEAT_MODE;
   private static final int BASE_MEDIA_SESSION_FLAGS =
       MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS
           | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS;
   private static final int EDITOR_MEDIA_SESSION_FLAGS =
       BASE_MEDIA_SESSION_FLAGS | MediaSessionCompat.FLAG_HANDLES_QUEUE_COMMANDS;
 
+  private static final MediaMetadataCompat METADATA_EMPTY =
+      new MediaMetadataCompat.Builder().build();
+
   /** Receiver of media commands sent by a media controller. */
   public interface CommandReceiver {
     /**
-     * Returns the commands the receiver handles, or {@code null} if no commands need to be handled.
+     * See {@link MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}. The
+     * receiver may handle the command, but is not required to do so. Changes to the player should
+     * be made via the {@link ControlDispatcher}.
+     *
+     * @param player The player connected to the media session.
+     * @param controlDispatcher A {@link ControlDispatcher} that should be used for dispatching
+     *     changes to the player.
+     * @param command The command name.
+     * @param extras Optional parameters for the command, may be null.
+     * @param cb A result receiver to which a result may be sent by the command, may be null.
+     * @return Whether the receiver handled the command.
      */
-    String[] getCommands();
-    /** See {@link MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}. */
-    void onCommand(Player player, String command, Bundle extras, ResultReceiver cb);
+    boolean onCommand(
+        Player player,
+        ControlDispatcher controlDispatcher,
+        String command,
+        Bundle extras,
+        ResultReceiver cb);
   }
 
   /** Interface to which playback preparation actions are delegated. */
@@ -140,51 +207,6 @@
     void onPrepareFromUri(Uri uri, Bundle extras);
   }
 
-  /** Interface to which playback actions are delegated. */
-  public interface PlaybackController extends CommandReceiver {
-
-    long ACTIONS =
-        PlaybackStateCompat.ACTION_PLAY_PAUSE
-            | PlaybackStateCompat.ACTION_PLAY
-            | PlaybackStateCompat.ACTION_PAUSE
-            | PlaybackStateCompat.ACTION_SEEK_TO
-            | PlaybackStateCompat.ACTION_FAST_FORWARD
-            | PlaybackStateCompat.ACTION_REWIND
-            | PlaybackStateCompat.ACTION_STOP
-            | PlaybackStateCompat.ACTION_SET_REPEAT_MODE
-            | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE;
-
-    /**
-     * Returns the actions which are supported by the controller. The supported actions must be a
-     * bitmask combined out of {@link PlaybackStateCompat#ACTION_PLAY_PAUSE}, {@link
-     * PlaybackStateCompat#ACTION_PLAY}, {@link PlaybackStateCompat#ACTION_PAUSE}, {@link
-     * PlaybackStateCompat#ACTION_SEEK_TO}, {@link PlaybackStateCompat#ACTION_FAST_FORWARD}, {@link
-     * PlaybackStateCompat#ACTION_REWIND}, {@link PlaybackStateCompat#ACTION_STOP}, {@link
-     * PlaybackStateCompat#ACTION_SET_REPEAT_MODE} and {@link
-     * PlaybackStateCompat#ACTION_SET_SHUFFLE_MODE}.
-     *
-     * @param player The player.
-     * @return The bitmask of the supported media actions.
-     */
-    long getSupportedPlaybackActions(@Nullable Player player);
-    /** See {@link MediaSessionCompat.Callback#onPlay()}. */
-    void onPlay(Player player);
-    /** See {@link MediaSessionCompat.Callback#onPause()}. */
-    void onPause(Player player);
-    /** See {@link MediaSessionCompat.Callback#onSeekTo(long)}. */
-    void onSeekTo(Player player, long position);
-    /** See {@link MediaSessionCompat.Callback#onFastForward()}. */
-    void onFastForward(Player player);
-    /** See {@link MediaSessionCompat.Callback#onRewind()}. */
-    void onRewind(Player player);
-    /** See {@link MediaSessionCompat.Callback#onStop()}. */
-    void onStop(Player player);
-    /** See {@link MediaSessionCompat.Callback#onSetShuffleMode(int)}. */
-    void onSetShuffleMode(Player player, int shuffleMode);
-    /** See {@link MediaSessionCompat.Callback#onSetRepeatMode(int)}. */
-    void onSetRepeatMode(Player player, int repeatMode);
-  }
-
   /**
    * Handles queue navigation actions, and updates the media session queue by calling {@code
    * MediaSessionCompat.setQueue()}.
@@ -202,20 +224,20 @@
      * PlaybackStateCompat#ACTION_SKIP_TO_NEXT}, {@link
      * PlaybackStateCompat#ACTION_SKIP_TO_PREVIOUS}.
      *
-     * @param player The {@link Player}.
+     * @param player The player connected to the media session.
      * @return The bitmask of the supported media actions.
      */
-    long getSupportedQueueNavigatorActions(@Nullable Player player);
+    long getSupportedQueueNavigatorActions(Player player);
     /**
      * Called when the timeline of the player has changed.
      *
-     * @param player The player of which the timeline has changed.
+     * @param player The player connected to the media session.
      */
     void onTimelineChanged(Player player);
     /**
      * Called when the current window index changed.
      *
-     * @param player The player of which the current window index of the timeline has changed.
+     * @param player The player connected to the media session.
      */
     void onCurrentWindowIndexChanged(Player player);
     /**
@@ -230,12 +252,30 @@
      * @return The id of the active queue item.
      */
     long getActiveQueueItemId(@Nullable Player player);
-    /** See {@link MediaSessionCompat.Callback#onSkipToPrevious()}. */
-    void onSkipToPrevious(Player player);
-    /** See {@link MediaSessionCompat.Callback#onSkipToQueueItem(long)}. */
-    void onSkipToQueueItem(Player player, long id);
-    /** See {@link MediaSessionCompat.Callback#onSkipToNext()}. */
-    void onSkipToNext(Player player);
+    /**
+     * See {@link MediaSessionCompat.Callback#onSkipToPrevious()}.
+     *
+     * @param player The player connected to the media session.
+     * @param controlDispatcher A {@link ControlDispatcher} that should be used for dispatching
+     *     changes to the player.
+     */
+    void onSkipToPrevious(Player player, ControlDispatcher controlDispatcher);
+    /**
+     * See {@link MediaSessionCompat.Callback#onSkipToQueueItem(long)}.
+     *
+     * @param player The player connected to the media session.
+     * @param controlDispatcher A {@link ControlDispatcher} that should be used for dispatching
+     *     changes to the player.
+     */
+    void onSkipToQueueItem(Player player, ControlDispatcher controlDispatcher, long id);
+    /**
+     * See {@link MediaSessionCompat.Callback#onSkipToNext()}.
+     *
+     * @param player The player connected to the media session.
+     * @param controlDispatcher A {@link ControlDispatcher} that should be used for dispatching
+     *     changes to the player.
+     */
+    void onSkipToNext(Player player, ControlDispatcher controlDispatcher);
   }
 
   /** Handles media session queue edits. */
@@ -260,15 +300,28 @@
   /** Callback receiving a user rating for the active media item. */
   public interface RatingCallback extends CommandReceiver {
 
-    long ACTIONS = PlaybackStateCompat.ACTION_SET_RATING;
-
     /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat)}. */
     void onSetRating(Player player, RatingCompat rating);
-    
+
     /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat, Bundle)}. */
     void onSetRating(Player player, RatingCompat rating, Bundle extras);
   }
 
+  /** Handles a media button event. */
+  public interface MediaButtonEventHandler {
+    /**
+     * See {@link MediaSessionCompat.Callback#onMediaButtonEvent(Intent)}.
+     *
+     * @param player The {@link Player}.
+     * @param controlDispatcher A {@link ControlDispatcher} that should be used for dispatching
+     *     changes to the player.
+     * @param mediaButtonEvent The {@link Intent}.
+     * @return True if the event was handled, false otherwise.
+     */
+    boolean onMediaButtonEvent(
+        Player player, ControlDispatcher controlDispatcher, Intent mediaButtonEvent);
+  }
+
   /**
    * Provides a {@link PlaybackStateCompat.CustomAction} to be published and handles the action when
    * sent by a media controller.
@@ -277,19 +330,24 @@
     /**
      * Called when a custom action provided by this provider is sent to the media session.
      *
+     * @param player The player connected to the media session.
+     * @param controlDispatcher A {@link ControlDispatcher} that should be used for dispatching
+     *     changes to the player.
      * @param action The name of the action which was sent by a media controller.
      * @param extras Optional extras sent by a media controller.
      */
-    void onCustomAction(String action, Bundle extras);
+    void onCustomAction(
+        Player player, ControlDispatcher controlDispatcher, String action, Bundle extras);
 
     /**
      * Returns a {@link PlaybackStateCompat.CustomAction} which will be published to the media
      * session by the connector or {@code null} if this action should not be published at the given
      * player state.
      *
+     * @param player The player connected to the media session.
      * @return The custom action to be included in the session playback state or {@code null}.
      */
-    PlaybackStateCompat.CustomAction getCustomAction();
+    PlaybackStateCompat.CustomAction getCustomAction(Player player);
   }
 
   /** Provides a {@link MediaMetadataCompat} for a given player state. */
@@ -297,7 +355,7 @@
     /**
      * Gets the {@link MediaMetadataCompat} to be published to the session.
      *
-     * @param player The player for which to provide metadata.
+     * @param player The player connected to the media session.
      * @return The {@link MediaMetadataCompat} to be published to the session.
      */
     MediaMetadataCompat getMetadata(Player player);
@@ -306,141 +364,149 @@
   /** The wrapped {@link MediaSessionCompat}. */
   public final MediaSessionCompat mediaSession;
 
-  private @Nullable final MediaMetadataProvider mediaMetadataProvider;
-  private final ExoPlayerEventListener exoPlayerEventListener;
-  private final MediaSessionCallback mediaSessionCallback;
-  private final PlaybackController playbackController;
-  private final Map<String, CommandReceiver> commandMap;
+  private final Looper looper;
+  private final ComponentListener componentListener;
+  private final ArrayList<CommandReceiver> commandReceivers;
+  private final ArrayList<CommandReceiver> customCommandReceivers;
 
-  private Player player;
+  private ControlDispatcher controlDispatcher;
   private CustomActionProvider[] customActionProviders;
   private Map<String, CustomActionProvider> customActionMap;
-  private @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
-  private @Nullable Pair<Integer, CharSequence> customError;
-  private PlaybackPreparer playbackPreparer;
-  private QueueNavigator queueNavigator;
-  private QueueEditor queueEditor;
-  private RatingCallback ratingCallback;
+  @Nullable private MediaMetadataProvider mediaMetadataProvider;
+  @Nullable private Player player;
+  @Nullable private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
+  @Nullable private Pair<Integer, CharSequence> customError;
+  @Nullable private Bundle customErrorExtras;
+  @Nullable private PlaybackPreparer playbackPreparer;
+  @Nullable private QueueNavigator queueNavigator;
+  @Nullable private QueueEditor queueEditor;
+  @Nullable private RatingCallback ratingCallback;
+  @Nullable private MediaButtonEventHandler mediaButtonEventHandler;
+
+  private long enabledPlaybackActions;
+  private int rewindMs;
+  private int fastForwardMs;
 
   /**
    * Creates an instance.
    *
-   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, new DefaultPlaybackController())}.
-   *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
    */
   public MediaSessionConnector(MediaSessionCompat mediaSession) {
-    this(mediaSession, null);
+    this.mediaSession = mediaSession;
+    looper = Util.getLooper();
+    componentListener = new ComponentListener();
+    commandReceivers = new ArrayList<>();
+    customCommandReceivers = new ArrayList<>();
+    controlDispatcher = new DefaultControlDispatcher();
+    customActionProviders = new CustomActionProvider[0];
+    customActionMap = Collections.emptyMap();
+    mediaMetadataProvider =
+        new DefaultMediaMetadataProvider(
+            mediaSession.getController(), /* metadataExtrasPrefix= */ null);
+    enabledPlaybackActions = DEFAULT_PLAYBACK_ACTIONS;
+    rewindMs = DEFAULT_REWIND_MS;
+    fastForwardMs = DEFAULT_FAST_FORWARD_MS;
+    mediaSession.setFlags(BASE_MEDIA_SESSION_FLAGS);
+    mediaSession.setCallback(componentListener, new Handler(looper));
   }
 
   /**
-   * Creates an instance.
-   *
-   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, new
-   * DefaultMediaMetadataProvider(mediaSession.getController(), null))}.
+   * Sets the player to be connected to the media session. Must be called on the same thread that is
+   * used to access the player.
    *
-   * @param mediaSession The {@link MediaSessionCompat} to connect to.
-   * @param playbackController A {@link PlaybackController} for handling playback actions.
+   * @param player The player to be connected to the {@code MediaSession}, or {@code null} to
+   *     disconnect the current player.
    */
-  public MediaSessionConnector(
-      MediaSessionCompat mediaSession, PlaybackController playbackController) {
-    this(
-        mediaSession,
-        playbackController,
-        new DefaultMediaMetadataProvider(mediaSession.getController(), null));
+  public void setPlayer(@Nullable Player player) {
+    Assertions.checkArgument(player == null || player.getApplicationLooper() == looper);
+    if (this.player != null) {
+      this.player.removeListener(componentListener);
+    }
+    this.player = player;
+    if (player != null) {
+      player.addListener(componentListener);
+    }
+    invalidateMediaSessionPlaybackState();
+    invalidateMediaSessionMetadata();
   }
 
   /**
-   * Creates an instance.
+   * Sets the {@link PlaybackPreparer}.
    *
-   * @param mediaSession The {@link MediaSessionCompat} to connect to.
-   * @param playbackController A {@link PlaybackController} for handling playback actions, or {@code
-   *     null} if the connector should handle playback actions directly.
-   * @param doMaintainMetadata Whether the connector should maintain the metadata of the session.
-   * @param metadataExtrasPrefix A string to prefix extra keys which are propagated from the active
-   *     queue item to the session metadata.
-   * @deprecated Use {@link MediaSessionConnector#MediaSessionConnector(MediaSessionCompat,
-   *     PlaybackController, MediaMetadataProvider)}.
+   * @param playbackPreparer The {@link PlaybackPreparer}.
    */
-  @Deprecated
-  public MediaSessionConnector(
-      MediaSessionCompat mediaSession,
-      @Nullable PlaybackController playbackController,
-      boolean doMaintainMetadata,
-      @Nullable String metadataExtrasPrefix) {
-    this(
-        mediaSession,
-        playbackController,
-        doMaintainMetadata
-            ? new DefaultMediaMetadataProvider(mediaSession.getController(), metadataExtrasPrefix)
-            : null);
+  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
+    if (this.playbackPreparer != playbackPreparer) {
+      unregisterCommandReceiver(this.playbackPreparer);
+      this.playbackPreparer = playbackPreparer;
+      registerCommandReceiver(playbackPreparer);
+      invalidateMediaSessionPlaybackState();
+    }
   }
 
   /**
-   * Creates an instance.
+   * Sets the {@link ControlDispatcher}.
    *
-   * @param mediaSession The {@link MediaSessionCompat} to connect to.
-   * @param playbackController A {@link PlaybackController} for handling playback actions, or {@code
-   *     null} if the connector should handle playback actions directly.
-   * @param mediaMetadataProvider A {@link MediaMetadataProvider} for providing a custom metadata
-   *     object to be published to the media session, or {@code null} if metadata shouldn't be
-   *     published.
+   * @param controlDispatcher The {@link ControlDispatcher}, or null to use {@link
+   *     DefaultControlDispatcher}.
    */
-  public MediaSessionConnector(
-      MediaSessionCompat mediaSession,
-      @Nullable PlaybackController playbackController,
-      @Nullable MediaMetadataProvider mediaMetadataProvider) {
-    this.mediaSession = mediaSession;
-    this.playbackController =
-        playbackController != null ? playbackController : new DefaultPlaybackController();
-    this.mediaMetadataProvider = mediaMetadataProvider;
-    mediaSession.setFlags(BASE_MEDIA_SESSION_FLAGS);
-    mediaSessionCallback = new MediaSessionCallback();
-    exoPlayerEventListener = new ExoPlayerEventListener();
-    customActionMap = Collections.emptyMap();
-    commandMap = new HashMap<>();
-    registerCommandReceiver(playbackController);
+  public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
+    if (this.controlDispatcher != controlDispatcher) {
+      this.controlDispatcher =
+          controlDispatcher == null ? new DefaultControlDispatcher() : controlDispatcher;
+    }
   }
 
   /**
-   * Sets the player to be connected to the media session. Must be called on the same thread that is
-   * used to access the player.
+   * Sets the {@link MediaButtonEventHandler}. Pass {@code null} if the media button event should be
+   * handled by {@link MediaSessionCompat.Callback#onMediaButtonEvent(Intent)}.
    *
-   * <p>The order in which any {@link CustomActionProvider}s are passed determines the order of the
-   * actions published with the playback state of the session.
+   * @param mediaButtonEventHandler The {@link MediaButtonEventHandler}, or null to let the event be
+   *     handled by {@link MediaSessionCompat.Callback#onMediaButtonEvent(Intent)}.
+   */
+  public void setMediaButtonEventHandler(
+      @Nullable MediaButtonEventHandler mediaButtonEventHandler) {
+    this.mediaButtonEventHandler = mediaButtonEventHandler;
+  }
+
+  /**
+   * Sets the enabled playback actions.
    *
-   * @param player The player to be connected to the {@code MediaSession}, or {@code null} to
-   *     disconnect the current player.
-   * @param playbackPreparer An optional {@link PlaybackPreparer} for preparing the player.
-   * @param customActionProviders Optional {@link CustomActionProvider}s to publish and handle
-   *     custom actions.
+   * @param enabledPlaybackActions The enabled playback actions.
    */
-  public void setPlayer(
-      @Nullable Player player,
-      @Nullable PlaybackPreparer playbackPreparer,
-      CustomActionProvider... customActionProviders) {
-    Assertions.checkArgument(player == null || player.getApplicationLooper() == Looper.myLooper());
-    if (this.player != null) {
-      this.player.removeListener(exoPlayerEventListener);
-      mediaSession.setCallback(null);
+  public void setEnabledPlaybackActions(@PlaybackActions long enabledPlaybackActions) {
+    enabledPlaybackActions &= ALL_PLAYBACK_ACTIONS;
+    if (this.enabledPlaybackActions != enabledPlaybackActions) {
+      this.enabledPlaybackActions = enabledPlaybackActions;
+      invalidateMediaSessionPlaybackState();
     }
-    unregisterCommandReceiver(this.playbackPreparer);
+  }
 
-    this.player = player;
-    this.playbackPreparer = playbackPreparer;
-    registerCommandReceiver(playbackPreparer);
+  /**
+   * Sets the rewind increment in milliseconds.
+   *
+   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
+   *     rewind button to be disabled.
+   */
+  public void setRewindIncrementMs(int rewindMs) {
+    if (this.rewindMs != rewindMs) {
+      this.rewindMs = rewindMs;
+      invalidateMediaSessionPlaybackState();
+    }
+  }
 
-    this.customActionProviders =
-        (player != null && customActionProviders != null)
-            ? customActionProviders
-            : new CustomActionProvider[0];
-    if (player != null) {
-      Handler handler = new Handler(Util.getLooper());
-      mediaSession.setCallback(mediaSessionCallback, handler);
-      player.addListener(exoPlayerEventListener);
+  /**
+   * Sets the fast forward increment in milliseconds.
+   *
+   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
+   *     cause the fast forward button to be disabled.
+   */
+  public void setFastForwardIncrementMs(int fastForwardMs) {
+    if (this.fastForwardMs != fastForwardMs) {
+      this.fastForwardMs = fastForwardMs;
+      invalidateMediaSessionPlaybackState();
     }
-    invalidateMediaSessionPlaybackState();
-    invalidateMediaSessionMetadata();
   }
 
   /**
@@ -519,20 +585,65 @@ public void setCustomErrorMessage(@Nullable CharSequence message) {
    * @param code The error code to report. Ignored when {@code message} is {@code null}.
    */
   public void setCustomErrorMessage(@Nullable CharSequence message, int code) {
+    setCustomErrorMessage(message, code, /* extras= */ null);
+  }
+
+  /**
+   * Sets a custom error on the session.
+   *
+   * @param message The error string to report or {@code null} to clear the error.
+   * @param code The error code to report. Ignored when {@code message} is {@code null}.
+   * @param extras Extras to include in reported {@link PlaybackStateCompat}.
+   */
+  public void setCustomErrorMessage(
+      @Nullable CharSequence message, int code, @Nullable Bundle extras) {
     customError = (message == null) ? null : new Pair<>(code, message);
+    customErrorExtras = (message == null) ? null : extras;
     invalidateMediaSessionPlaybackState();
   }
 
+  /**
+   * Sets custom action providers. The order of the {@link CustomActionProvider}s determines the
+   * order in which the actions are published.
+   *
+   * @param customActionProviders The custom action providers, or null to remove all existing custom
+   *     action providers.
+   */
+  public void setCustomActionProviders(@Nullable CustomActionProvider... customActionProviders) {
+    this.customActionProviders =
+        customActionProviders == null ? new CustomActionProvider[0] : customActionProviders;
+    invalidateMediaSessionPlaybackState();
+  }
+
+  /**
+   * Sets a provider of metadata to be published to the media session. Pass {@code null} if no
+   * metadata should be published.
+   *
+   * @param mediaMetadataProvider The provider of metadata to publish, or {@code null} if no
+   *     metadata should be published.
+   */
+  public void setMediaMetadataProvider(@Nullable MediaMetadataProvider mediaMetadataProvider) {
+    if (this.mediaMetadataProvider != mediaMetadataProvider) {
+      this.mediaMetadataProvider = mediaMetadataProvider;
+      invalidateMediaSessionMetadata();
+    }
+  }
+
   /**
    * Updates the metadata of the media session.
    *
    * <p>Apps normally only need to call this method when the backing data for a given media item has
    * changed and the metadata should be updated immediately.
+   *
+   * <p>The {@link MediaMetadataCompat} which is published to the session is obtained by calling
+   * {@link MediaMetadataProvider#getMetadata(Player)}.
    */
   public final void invalidateMediaSessionMetadata() {
-    if (mediaMetadataProvider != null && player != null) {
-      mediaSession.setMetadata(mediaMetadataProvider.getMetadata(player));
-    }
+    MediaMetadataCompat metadata =
+        mediaMetadataProvider != null && player != null
+            ? mediaMetadataProvider.getMetadata(player)
+            : METADATA_EMPTY;
+    mediaSession.setMetadata(metadata != null ? metadata : METADATA_EMPTY);
   }
 
   /**
@@ -544,14 +655,14 @@ public final void invalidateMediaSessionMetadata() {
   public final void invalidateMediaSessionPlaybackState() {
     PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
     if (player == null) {
-      builder.setActions(buildPlaybackActions()).setState(PlaybackStateCompat.STATE_NONE, 0, 0, 0);
+      builder.setActions(buildPrepareActions()).setState(PlaybackStateCompat.STATE_NONE, 0, 0, 0);
       mediaSession.setPlaybackState(builder.build());
       return;
     }
 
     Map<String, CustomActionProvider> currentActions = new HashMap<>();
     for (CustomActionProvider customActionProvider : customActionProviders) {
-      PlaybackStateCompat.CustomAction customAction = customActionProvider.getCustomAction();
+      PlaybackStateCompat.CustomAction customAction = customActionProvider.getCustomAction(player);
       if (customAction != null) {
         currentActions.put(customAction.getAction(), customActionProvider);
         builder.addCustomAction(customAction);
@@ -560,6 +671,7 @@ public final void invalidateMediaSessionPlaybackState() {
     customActionMap = Collections.unmodifiableMap(currentActions);
 
     int playbackState = player.getPlaybackState();
+    Bundle extras = new Bundle();
     ExoPlaybackException playbackError =
         playbackState == Player.STATE_IDLE ? player.getPlaybackError() : null;
     boolean reportError = playbackError != null || customError != null;
@@ -569,6 +681,9 @@ public final void invalidateMediaSessionPlaybackState() {
             : mapPlaybackState(player.getPlaybackState(), player.getPlayWhenReady());
     if (customError != null) {
       builder.setErrorMessage(customError.first, customError.second);
+      if (customErrorExtras != null) {
+        extras.putAll(customErrorExtras);
+      }
     } else if (playbackError != null && errorMessageProvider != null) {
       Pair<Integer, String> message = errorMessageProvider.getErrorMessage(playbackError);
       builder.setErrorMessage(message.first, message.second);
@@ -577,10 +692,9 @@ public final void invalidateMediaSessionPlaybackState() {
         queueNavigator != null
             ? queueNavigator.getActiveQueueItemId(player)
             : MediaSessionCompat.QueueItem.UNKNOWN_ID;
-    Bundle extras = new Bundle();
     extras.putFloat(EXTRAS_PITCH, player.getPlaybackParameters().pitch);
     builder
-        .setActions(buildPlaybackActions())
+        .setActions(buildPrepareActions() | buildPlaybackActions(player))
         .setActiveQueueItemId(activeQueueItemId)
         .setBufferedPosition(player.getBufferedPosition())
         .setState(
@@ -605,34 +719,77 @@ public final void invalidateMediaSessionQueue() {
     }
   }
 
+  /**
+   * Registers a custom command receiver for responding to commands delivered via {@link
+   * MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}.
+   *
+   * <p>Commands are only dispatched to this receiver when a player is connected.
+   *
+   * @param commandReceiver The command receiver to register.
+   */
+  public void registerCustomCommandReceiver(CommandReceiver commandReceiver) {
+    if (!customCommandReceivers.contains(commandReceiver)) {
+      customCommandReceivers.add(commandReceiver);
+    }
+  }
+
+  /**
+   * Unregisters a previously registered custom command receiver.
+   *
+   * @param commandReceiver The command receiver to unregister.
+   */
+  public void unregisterCustomCommandReceiver(CommandReceiver commandReceiver) {
+    customCommandReceivers.remove(commandReceiver);
+  }
+
   private void registerCommandReceiver(CommandReceiver commandReceiver) {
-    if (commandReceiver != null && commandReceiver.getCommands() != null) {
-      for (String command : commandReceiver.getCommands()) {
-        commandMap.put(command, commandReceiver);
-      }
+    if (!commandReceivers.contains(commandReceiver)) {
+      commandReceivers.add(commandReceiver);
     }
   }
 
   private void unregisterCommandReceiver(CommandReceiver commandReceiver) {
-    if (commandReceiver != null && commandReceiver.getCommands() != null) {
-      for (String command : commandReceiver.getCommands()) {
-        commandMap.remove(command);
-      }
-    }
+    commandReceivers.remove(commandReceiver);
+  }
+
+  private long buildPrepareActions() {
+    return playbackPreparer == null
+        ? 0
+        : (PlaybackPreparer.ACTIONS & playbackPreparer.getSupportedPrepareActions());
   }
 
-  private long buildPlaybackActions() {
-    long actions =
-        (PlaybackController.ACTIONS & playbackController.getSupportedPlaybackActions(player));
-    if (playbackPreparer != null) {
-      actions |= (PlaybackPreparer.ACTIONS & playbackPreparer.getSupportedPrepareActions());
+  private long buildPlaybackActions(Player player) {
+    boolean enableSeeking = false;
+    boolean enableRewind = false;
+    boolean enableFastForward = false;
+    boolean enableSetRating = false;
+    Timeline timeline = player.getCurrentTimeline();
+    if (!timeline.isEmpty() && !player.isPlayingAd()) {
+      enableSeeking = player.isCurrentWindowSeekable();
+      enableRewind = enableSeeking && rewindMs > 0;
+      enableFastForward = enableSeeking && fastForwardMs > 0;
+      enableSetRating = true;
+    }
+
+    long playbackActions = BASE_PLAYBACK_ACTIONS;
+    if (enableSeeking) {
+      playbackActions |= PlaybackStateCompat.ACTION_SEEK_TO;
     }
+    if (enableFastForward) {
+      playbackActions |= PlaybackStateCompat.ACTION_FAST_FORWARD;
+    }
+    if (enableRewind) {
+      playbackActions |= PlaybackStateCompat.ACTION_REWIND;
+    }
+    playbackActions &= enabledPlaybackActions;
+
+    long actions = playbackActions;
     if (queueNavigator != null) {
       actions |=
           (QueueNavigator.ACTIONS & queueNavigator.getSupportedQueueNavigatorActions(player));
     }
-    if (ratingCallback != null) {
-      actions |= RatingCallback.ACTIONS;
+    if (ratingCallback != null && enableSetRating) {
+      actions |= PlaybackStateCompat.ACTION_SET_RATING;
     }
     return actions;
   }
@@ -644,39 +801,74 @@ private int mapPlaybackState(int exoPlayerPlaybackState, boolean playWhenReady)
       case Player.STATE_READY:
         return playWhenReady ? PlaybackStateCompat.STATE_PLAYING : PlaybackStateCompat.STATE_PAUSED;
       case Player.STATE_ENDED:
-        return PlaybackStateCompat.STATE_PAUSED;
+        return PlaybackStateCompat.STATE_STOPPED;
       default:
         return PlaybackStateCompat.STATE_NONE;
     }
   }
 
+  private boolean canDispatchPlaybackAction(long action) {
+    return player != null && (enabledPlaybackActions & action) != 0;
+  }
+
   private boolean canDispatchToPlaybackPreparer(long action) {
     return playbackPreparer != null
-        && (playbackPreparer.getSupportedPrepareActions() & PlaybackPreparer.ACTIONS & action) != 0;
+        && (playbackPreparer.getSupportedPrepareActions() & action) != 0;
+  }
+
+  private boolean canDispatchToQueueNavigator(long action) {
+    return player != null
+        && queueNavigator != null
+        && (queueNavigator.getSupportedQueueNavigatorActions(player) & action) != 0;
   }
 
-  private boolean canDispatchToRatingCallback(long action) {
-    return ratingCallback != null && (RatingCallback.ACTIONS & action) != 0;
+  private boolean canDispatchSetRating() {
+    return player != null && ratingCallback != null;
   }
 
-  private boolean canDispatchToPlaybackController(long action) {
-    return (playbackController.getSupportedPlaybackActions(player)
-            & PlaybackController.ACTIONS
-            & action)
-        != 0;
+  private boolean canDispatchQueueEdit() {
+    return player != null && queueEditor != null;
   }
 
-  private boolean canDispatchToQueueNavigator(long action) {
-    return queueNavigator != null
-        && (queueNavigator.getSupportedQueueNavigatorActions(player)
-                & QueueNavigator.ACTIONS
-                & action)
-            != 0;
+  private boolean canDispatchMediaButtonEvent() {
+    return player != null && mediaButtonEventHandler != null;
+  }
+
+  private void stopPlayerForPrepare(boolean playWhenReady) {
+    if (player != null) {
+      player.stop();
+      player.setPlayWhenReady(playWhenReady);
+    }
+  }
+
+  private void rewind(Player player) {
+    if (player.isCurrentWindowSeekable() && rewindMs > 0) {
+      seekTo(player, player.getCurrentPosition() - rewindMs);
+    }
+  }
+
+  private void fastForward(Player player) {
+    if (player.isCurrentWindowSeekable() && fastForwardMs > 0) {
+      seekTo(player, player.getCurrentPosition() + fastForwardMs);
+    }
+  }
+
+  private void seekTo(Player player, long positionMs) {
+    seekTo(player, player.getCurrentWindowIndex(), positionMs);
+  }
+
+  private void seekTo(Player player, int windowIndex, long positionMs) {
+    long durationMs = player.getDuration();
+    if (durationMs != C.TIME_UNSET) {
+      positionMs = Math.min(positionMs, durationMs);
+    }
+    positionMs = Math.max(positionMs, 0);
+    controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
   }
 
   /**
-   * Provides a default {@link MediaMetadataCompat} with properties and extras propagated from the
-   * active queue item to the session metadata.
+   * Provides a default {@link MediaMetadataCompat} with properties and extras taken from the {@link
+   * MediaDescriptionCompat} of the {@link MediaSessionCompat.QueueItem} of the active queue item.
    */
   public static final class DefaultMediaMetadataProvider implements MediaMetadataProvider {
 
@@ -699,7 +891,7 @@ public DefaultMediaMetadataProvider(
     @Override
     public MediaMetadataCompat getMetadata(Player player) {
       if (player.getCurrentTimeline().isEmpty()) {
-        return null;
+        return METADATA_EMPTY;
       }
       MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
       if (player.isPlayingAd()) {
@@ -776,11 +968,14 @@ public MediaMetadataCompat getMetadata(Player player) {
     }
   }
 
-  private class ExoPlayerEventListener implements Player.EventListener {
+  private class ComponentListener extends MediaSessionCompat.Callback
+      implements Player.EventListener {
 
     private int currentWindowIndex;
     private int currentWindowCount;
 
+    // Player.EventListener implementation.
+
     @Override
     public void onTimelineChanged(
         Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
@@ -821,6 +1016,7 @@ public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
               ? PlaybackStateCompat.SHUFFLE_MODE_ALL
               : PlaybackStateCompat.SHUFFLE_MODE_NONE);
       invalidateMediaSessionPlaybackState();
+      invalidateMediaSessionQueue();
     }
 
     @Override
@@ -843,109 +1039,150 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
     public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
       invalidateMediaSessionPlaybackState();
     }
-  }
 
-  private class MediaSessionCallback extends MediaSessionCompat.Callback {
+    // MediaSessionCompat.Callback implementation.
 
     @Override
     public void onPlay() {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_PLAY)) {
-        playbackController.onPlay(player);
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_PLAY)) {
+        if (player.getPlaybackState() == Player.STATE_IDLE) {
+          if (playbackPreparer != null) {
+            playbackPreparer.onPrepare();
+          }
+        } else if (player.getPlaybackState() == Player.STATE_ENDED) {
+          controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+        }
+        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ true);
       }
     }
 
     @Override
     public void onPause() {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_PAUSE)) {
-        playbackController.onPause(player);
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_PAUSE)) {
+        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ false);
       }
     }
 
     @Override
-    public void onSeekTo(long position) {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_SEEK_TO)) {
-        playbackController.onSeekTo(player, position);
+    public void onSeekTo(long positionMs) {
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_SEEK_TO)) {
+        seekTo(player, positionMs);
       }
     }
 
     @Override
     public void onFastForward() {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_FAST_FORWARD)) {
-        playbackController.onFastForward(player);
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_FAST_FORWARD)) {
+        fastForward(player);
       }
     }
 
     @Override
     public void onRewind() {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_REWIND)) {
-        playbackController.onRewind(player);
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_REWIND)) {
+        rewind(player);
       }
     }
 
     @Override
     public void onStop() {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_STOP)) {
-        playbackController.onStop(player);
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_STOP)) {
+        controlDispatcher.dispatchStop(player, /* reset= */ true);
       }
     }
 
     @Override
-    public void onSetShuffleMode(int shuffleMode) {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE)) {
-        playbackController.onSetShuffleMode(player, shuffleMode);
+    public void onSetShuffleMode(@PlaybackStateCompat.ShuffleMode int shuffleMode) {
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE)) {
+        boolean shuffleModeEnabled;
+        switch (shuffleMode) {
+          case PlaybackStateCompat.SHUFFLE_MODE_ALL:
+          case PlaybackStateCompat.SHUFFLE_MODE_GROUP:
+            shuffleModeEnabled = true;
+            break;
+          case PlaybackStateCompat.SHUFFLE_MODE_NONE:
+          case PlaybackStateCompat.SHUFFLE_MODE_INVALID:
+          default:
+            shuffleModeEnabled = false;
+            break;
+        }
+        controlDispatcher.dispatchSetShuffleModeEnabled(player, shuffleModeEnabled);
       }
     }
 
     @Override
-    public void onSetRepeatMode(int repeatMode) {
-      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_SET_REPEAT_MODE)) {
-        playbackController.onSetRepeatMode(player, repeatMode);
+    public void onSetRepeatMode(@PlaybackStateCompat.RepeatMode int mediaSessionRepeatMode) {
+      if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_SET_REPEAT_MODE)) {
+        @RepeatModeUtil.RepeatToggleModes int repeatMode;
+        switch (mediaSessionRepeatMode) {
+          case PlaybackStateCompat.REPEAT_MODE_ALL:
+          case PlaybackStateCompat.REPEAT_MODE_GROUP:
+            repeatMode = Player.REPEAT_MODE_ALL;
+            break;
+          case PlaybackStateCompat.REPEAT_MODE_ONE:
+            repeatMode = Player.REPEAT_MODE_ONE;
+            break;
+          case PlaybackStateCompat.REPEAT_MODE_NONE:
+          case PlaybackStateCompat.REPEAT_MODE_INVALID:
+          default:
+            repeatMode = Player.REPEAT_MODE_OFF;
+            break;
+        }
+        controlDispatcher.dispatchSetRepeatMode(player, repeatMode);
       }
     }
 
     @Override
     public void onSkipToNext() {
       if (canDispatchToQueueNavigator(PlaybackStateCompat.ACTION_SKIP_TO_NEXT)) {
-        queueNavigator.onSkipToNext(player);
+        queueNavigator.onSkipToNext(player, controlDispatcher);
       }
     }
 
     @Override
     public void onSkipToPrevious() {
       if (canDispatchToQueueNavigator(PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)) {
-        queueNavigator.onSkipToPrevious(player);
+        queueNavigator.onSkipToPrevious(player, controlDispatcher);
       }
     }
 
     @Override
     public void onSkipToQueueItem(long id) {
       if (canDispatchToQueueNavigator(PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM)) {
-        queueNavigator.onSkipToQueueItem(player, id);
+        queueNavigator.onSkipToQueueItem(player, controlDispatcher, id);
       }
     }
 
     @Override
     public void onCustomAction(@NonNull String action, @Nullable Bundle extras) {
-      Map<String, CustomActionProvider> actionMap = customActionMap;
-      if (actionMap.containsKey(action)) {
-        actionMap.get(action).onCustomAction(action, extras);
+      if (player != null && customActionMap.containsKey(action)) {
+        customActionMap.get(action).onCustomAction(player, controlDispatcher, action, extras);
         invalidateMediaSessionPlaybackState();
       }
     }
 
     @Override
     public void onCommand(String command, Bundle extras, ResultReceiver cb) {
-      CommandReceiver commandReceiver = commandMap.get(command);
-      if (commandReceiver != null) {
-        commandReceiver.onCommand(player, command, extras, cb);
+      if (player != null) {
+        for (int i = 0; i < commandReceivers.size(); i++) {
+          if (commandReceivers.get(i).onCommand(player, controlDispatcher, command, extras, cb)) {
+            return;
+          }
+        }
+        for (int i = 0; i < customCommandReceivers.size(); i++) {
+          if (customCommandReceivers
+              .get(i)
+              .onCommand(player, controlDispatcher, command, extras, cb)) {
+            return;
+          }
+        }
       }
     }
 
     @Override
     public void onPrepare() {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE)) {
-        player.stop();
-        player.setPlayWhenReady(false);
+        stopPlayerForPrepare(/* playWhenReady= */ false);
         playbackPreparer.onPrepare();
       }
     }
@@ -953,8 +1190,7 @@ public void onPrepare() {
     @Override
     public void onPrepareFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID)) {
-        player.stop();
-        player.setPlayWhenReady(false);
+        stopPlayerForPrepare(/* playWhenReady= */ false);
         playbackPreparer.onPrepareFromMediaId(mediaId, extras);
       }
     }
@@ -962,8 +1198,7 @@ public void onPrepareFromMediaId(String mediaId, Bundle extras) {
     @Override
     public void onPrepareFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_SEARCH)) {
-        player.stop();
-        player.setPlayWhenReady(false);
+        stopPlayerForPrepare(/* playWhenReady= */ false);
         playbackPreparer.onPrepareFromSearch(query, extras);
       }
     }
@@ -971,8 +1206,7 @@ public void onPrepareFromSearch(String query, Bundle extras) {
     @Override
     public void onPrepareFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_URI)) {
-        player.stop();
-        player.setPlayWhenReady(false);
+        stopPlayerForPrepare(/* playWhenReady= */ false);
         playbackPreparer.onPrepareFromUri(uri, extras);
       }
     }
@@ -980,8 +1214,7 @@ public void onPrepareFromUri(Uri uri, Bundle extras) {
     @Override
     public void onPlayFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID)) {
-        player.stop();
-        player.setPlayWhenReady(true);
+        stopPlayerForPrepare(/* playWhenReady= */ true);
         playbackPreparer.onPrepareFromMediaId(mediaId, extras);
       }
     }
@@ -989,8 +1222,7 @@ public void onPlayFromMediaId(String mediaId, Bundle extras) {
     @Override
     public void onPlayFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_SEARCH)) {
-        player.stop();
-        player.setPlayWhenReady(true);
+        stopPlayerForPrepare(/* playWhenReady= */ true);
         playbackPreparer.onPrepareFromSearch(query, extras);
       }
     }
@@ -998,45 +1230,53 @@ public void onPlayFromSearch(String query, Bundle extras) {
     @Override
     public void onPlayFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_URI)) {
-        player.stop();
-        player.setPlayWhenReady(true);
+        stopPlayerForPrepare(/* playWhenReady= */ true);
         playbackPreparer.onPrepareFromUri(uri, extras);
       }
     }
 
     @Override
     public void onSetRating(RatingCompat rating) {
-      if (canDispatchToRatingCallback(PlaybackStateCompat.ACTION_SET_RATING)) {
+      if (canDispatchSetRating()) {
         ratingCallback.onSetRating(player, rating);
       }
     }
-    
+
     @Override
     public void onSetRating(RatingCompat rating, Bundle extras) {
-      if (canDispatchToRatingCallback(PlaybackStateCompat.ACTION_SET_RATING)) {
+      if (canDispatchSetRating()) {
         ratingCallback.onSetRating(player, rating, extras);
       }
     }
 
     @Override
     public void onAddQueueItem(MediaDescriptionCompat description) {
-      if (queueEditor != null) {
+      if (canDispatchQueueEdit()) {
         queueEditor.onAddQueueItem(player, description);
       }
     }
 
     @Override
     public void onAddQueueItem(MediaDescriptionCompat description, int index) {
-      if (queueEditor != null) {
+      if (canDispatchQueueEdit()) {
         queueEditor.onAddQueueItem(player, description, index);
       }
     }
 
     @Override
     public void onRemoveQueueItem(MediaDescriptionCompat description) {
-      if (queueEditor != null) {
+      if (canDispatchQueueEdit()) {
         queueEditor.onRemoveQueueItem(player, description);
       }
     }
+
+    @Override
+    public boolean onMediaButtonEvent(Intent mediaButtonEvent) {
+      boolean isHandled =
+          canDispatchMediaButtonEvent()
+              && mediaButtonEventHandler.onMediaButtonEvent(
+                  player, controlDispatcher, mediaButtonEvent);
+      return isHandled || super.onMediaButtonEvent(mediaButtonEvent);
+    }
   }
 }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
index 057f59f62c..617b8781f4 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
@@ -18,17 +18,20 @@
 import android.content.Context;
 import android.os.Bundle;
 import android.support.v4.media.session.PlaybackStateCompat;
+import com.google.android.exoplayer2.ControlDispatcher;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 
-/**
- * Provides a custom action for toggling repeat modes.
- */
+/** Provides a custom action for toggling repeat modes. */
 public final class RepeatModeActionProvider implements MediaSessionConnector.CustomActionProvider {
 
+  /** The default repeat toggle modes. */
+  @RepeatModeUtil.RepeatToggleModes
+  public static final int DEFAULT_REPEAT_TOGGLE_MODES =
+      RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE | RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL;
+
   private static final String ACTION_REPEAT_MODE = "ACTION_EXO_REPEAT_MODE";
 
-  private final Player player;
   @RepeatModeUtil.RepeatToggleModes
   private final int repeatToggleModes;
   private final CharSequence repeatAllDescription;
@@ -37,27 +40,23 @@
 
   /**
    * Creates a new instance.
-   * <p>
-   * Equivalent to {@code RepeatModeActionProvider(context, player,
-   *     MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES)}.
+   *
+   * <p>Equivalent to {@code RepeatModeActionProvider(context, DEFAULT_REPEAT_TOGGLE_MODES)}.
    *
    * @param context The context.
-   * @param player The player on which to toggle the repeat mode.
    */
-  public RepeatModeActionProvider(Context context, Player player) {
-    this(context, player, MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES);
+  public RepeatModeActionProvider(Context context) {
+    this(context, DEFAULT_REPEAT_TOGGLE_MODES);
   }
 
   /**
    * Creates a new instance enabling the given repeat toggle modes.
    *
    * @param context The context.
-   * @param player The player on which to toggle the repeat mode.
    * @param repeatToggleModes The toggle modes to enable.
    */
-  public RepeatModeActionProvider(Context context, Player player,
-      @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    this.player = player;
+  public RepeatModeActionProvider(
+      Context context, @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
     this.repeatToggleModes = repeatToggleModes;
     repeatAllDescription = context.getString(R.string.exo_media_action_repeat_all_description);
     repeatOneDescription = context.getString(R.string.exo_media_action_repeat_one_description);
@@ -65,16 +64,17 @@ public RepeatModeActionProvider(Context context, Player player,
   }
 
   @Override
-  public void onCustomAction(String action, Bundle extras) {
+  public void onCustomAction(
+      Player player, ControlDispatcher controlDispatcher, String action, Bundle extras) {
     int mode = player.getRepeatMode();
     int proposedMode = RepeatModeUtil.getNextRepeatMode(mode, repeatToggleModes);
     if (mode != proposedMode) {
-      player.setRepeatMode(proposedMode);
+      controlDispatcher.dispatchSetRepeatMode(player, proposedMode);
     }
   }
 
   @Override
-  public PlaybackStateCompat.CustomAction getCustomAction() {
+  public PlaybackStateCompat.CustomAction getCustomAction(Player player) {
     CharSequence actionLabel;
     int iconResourceId;
     switch (player.getRepeatMode()) {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
index 7c00fcdf17..d076404bb4 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
@@ -17,12 +17,13 @@
 
 import android.os.Bundle;
 import android.os.ResultReceiver;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.support.v4.media.MediaDescriptionCompat;
 import android.support.v4.media.session.MediaControllerCompat;
 import android.support.v4.media.session.MediaSessionCompat;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ControlDispatcher;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -186,20 +187,23 @@ public void onRemoveQueueItem(Player player, MediaDescriptionCompat description)
 
   // CommandReceiver implementation.
 
-  @NonNull
   @Override
-  public String[] getCommands() {
-    return new String[] {COMMAND_MOVE_QUEUE_ITEM};
-  }
-
-  @Override
-  public void onCommand(Player player, String command, Bundle extras, ResultReceiver cb) {
+  public boolean onCommand(
+      Player player,
+      ControlDispatcher controlDispatcher,
+      String command,
+      Bundle extras,
+      ResultReceiver cb) {
+    if (!COMMAND_MOVE_QUEUE_ITEM.equals(command)) {
+      return false;
+    }
     int from = extras.getInt(EXTRA_FROM_INDEX, C.INDEX_UNSET);
     int to = extras.getInt(EXTRA_TO_INDEX, C.INDEX_UNSET);
     if (from != C.INDEX_UNSET && to != C.INDEX_UNSET) {
       queueDataAdapter.move(from, to);
       queueMediaSource.moveMediaSource(from, to);
     }
+    return true;
   }
 
 }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
index d55f8e04f0..6e61ad2fe2 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
@@ -17,17 +17,18 @@
 
 import android.os.Bundle;
 import android.os.ResultReceiver;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.support.v4.media.MediaDescriptionCompat;
 import android.support.v4.media.session.MediaSessionCompat;
 import android.support.v4.media.session.PlaybackStateCompat;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ControlDispatcher;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.List;
 
 /**
  * An abstract implementation of the {@link MediaSessionConnector.QueueNavigator} that maps the
@@ -40,7 +41,7 @@
 
   private final MediaSessionCompat mediaSession;
   private final Timeline.Window window;
-  protected final int maxQueueSize;
+  private final int maxQueueSize;
 
   private long activeQueueItemId;
 
@@ -66,6 +67,7 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession) {
    * @param maxQueueSize The maximum queue size.
    */
   public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize) {
+    Assertions.checkState(maxQueueSize > 0);
     this.mediaSession = mediaSession;
     this.maxQueueSize = maxQueueSize;
     activeQueueItemId = MediaSessionCompat.QueueItem.UNKNOWN_ID;
@@ -75,6 +77,11 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize)
   /**
    * Gets the {@link MediaDescriptionCompat} for a given timeline window index.
    *
+   * <p>Often artworks and icons need to be loaded asynchronously. In such a case, return a {@link
+   * MediaDescriptionCompat} without the images, load your images asynchronously off the main thread
+   * and then call {@link MediaSessionConnector#invalidateMediaSessionQueue()} to make the connector
+   * update the queue by calling {@link #getMediaDescription(Player, int)} again.
+   *
    * @param player The current player.
    * @param windowIndex The timeline window index for which to provide a description.
    * @return A {@link MediaDescriptionCompat}.
@@ -83,21 +90,25 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize)
 
   @Override
   public long getSupportedQueueNavigatorActions(Player player) {
-    if (player == null) {
-      return 0;
-    }
+    boolean enableSkipTo = false;
+    boolean enablePrevious = false;
+    boolean enableNext = false;
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty() || player.isPlayingAd()) {
-      return 0;
+    if (!timeline.isEmpty() && !player.isPlayingAd()) {
+      timeline.getWindow(player.getCurrentWindowIndex(), window);
+      enableSkipTo = timeline.getWindowCount() > 1;
+      enablePrevious = window.isSeekable || !window.isDynamic || player.hasPrevious();
+      enableNext = window.isDynamic || player.hasNext();
     }
+
     long actions = 0;
-    if (timeline.getWindowCount() > 1) {
+    if (enableSkipTo) {
       actions |= PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
     }
-    if (window.isSeekable || !window.isDynamic || player.hasPrevious()) {
+    if (enablePrevious) {
       actions |= PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
     }
-    if (window.isDynamic || player.hasNext()) {
+    if (enableNext) {
       actions |= PlaybackStateCompat.ACTION_SKIP_TO_NEXT;
     }
     return actions;
@@ -124,7 +135,7 @@ public final long getActiveQueueItemId(@Nullable Player player) {
   }
 
   @Override
-  public void onSkipToPrevious(Player player) {
+  public void onSkipToPrevious(Player player, ControlDispatcher controlDispatcher) {
     Timeline timeline = player.getCurrentTimeline();
     if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
@@ -135,26 +146,26 @@ public void onSkipToPrevious(Player player) {
     if (previousWindowIndex != C.INDEX_UNSET
         && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
             || (window.isDynamic && !window.isSeekable))) {
-      player.seekTo(previousWindowIndex, C.TIME_UNSET);
+      controlDispatcher.dispatchSeekTo(player, previousWindowIndex, C.TIME_UNSET);
     } else {
-      player.seekTo(0);
+      controlDispatcher.dispatchSeekTo(player, windowIndex, 0);
     }
   }
 
   @Override
-  public void onSkipToQueueItem(Player player, long id) {
+  public void onSkipToQueueItem(Player player, ControlDispatcher controlDispatcher, long id) {
     Timeline timeline = player.getCurrentTimeline();
     if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = (int) id;
     if (0 <= windowIndex && windowIndex < timeline.getWindowCount()) {
-      player.seekTo(windowIndex, C.TIME_UNSET);
+      controlDispatcher.dispatchSeekTo(player, windowIndex, C.TIME_UNSET);
     }
   }
 
   @Override
-  public void onSkipToNext(Player player) {
+  public void onSkipToNext(Player player, ControlDispatcher controlDispatcher) {
     Timeline timeline = player.getCurrentTimeline();
     if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
@@ -162,42 +173,71 @@ public void onSkipToNext(Player player) {
     int windowIndex = player.getCurrentWindowIndex();
     int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
-      player.seekTo(nextWindowIndex, C.TIME_UNSET);
+      controlDispatcher.dispatchSeekTo(player, nextWindowIndex, C.TIME_UNSET);
     } else if (timeline.getWindow(windowIndex, window).isDynamic) {
-      player.seekTo(windowIndex, C.TIME_UNSET);
+      controlDispatcher.dispatchSeekTo(player, windowIndex, C.TIME_UNSET);
     }
   }
 
   // CommandReceiver implementation.
 
   @Override
-  public String[] getCommands() {
-    return null;
+  public boolean onCommand(
+      Player player,
+      ControlDispatcher controlDispatcher,
+      String command,
+      Bundle extras,
+      ResultReceiver cb) {
+    return false;
   }
 
-  @Override
-  public void onCommand(Player player, String command, Bundle extras, ResultReceiver cb) {
-    // Do nothing.
-  }
+  // Helper methods.
 
   private void publishFloatingQueueWindow(Player player) {
-    if (player.getCurrentTimeline().isEmpty()) {
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty()) {
       mediaSession.setQueue(Collections.emptyList());
       activeQueueItemId = MediaSessionCompat.QueueItem.UNKNOWN_ID;
       return;
     }
-    int windowCount = player.getCurrentTimeline().getWindowCount();
+    ArrayDeque<MediaSessionCompat.QueueItem> queue = new ArrayDeque<>();
+    int queueSize = Math.min(maxQueueSize, timeline.getWindowCount());
+
+    // Add the active queue item.
     int currentWindowIndex = player.getCurrentWindowIndex();
-    int queueSize = Math.min(maxQueueSize, windowCount);
-    int startIndex = Util.constrainValue(currentWindowIndex - ((queueSize - 1) / 2), 0,
-        windowCount - queueSize);
-    List<MediaSessionCompat.QueueItem> queue = new ArrayList<>();
-    for (int i = startIndex; i < startIndex + queueSize; i++) {
-      queue.add(new MediaSessionCompat.QueueItem(getMediaDescription(player, i), i));
+    queue.add(
+        new MediaSessionCompat.QueueItem(
+            getMediaDescription(player, currentWindowIndex), currentWindowIndex));
+
+    // Fill queue alternating with next and/or previous queue items.
+    int firstWindowIndex = currentWindowIndex;
+    int lastWindowIndex = currentWindowIndex;
+    boolean shuffleModeEnabled = player.getShuffleModeEnabled();
+    while ((firstWindowIndex != C.INDEX_UNSET || lastWindowIndex != C.INDEX_UNSET)
+        && queue.size() < queueSize) {
+      // Begin with next to have a longer tail than head if an even sized queue needs to be trimmed.
+      if (lastWindowIndex != C.INDEX_UNSET) {
+        lastWindowIndex =
+            timeline.getNextWindowIndex(
+                lastWindowIndex, Player.REPEAT_MODE_OFF, shuffleModeEnabled);
+        if (lastWindowIndex != C.INDEX_UNSET) {
+          queue.add(
+              new MediaSessionCompat.QueueItem(
+                  getMediaDescription(player, lastWindowIndex), lastWindowIndex));
+        }
+      }
+      if (firstWindowIndex != C.INDEX_UNSET && queue.size() < queueSize) {
+        firstWindowIndex =
+            timeline.getPreviousWindowIndex(
+                firstWindowIndex, Player.REPEAT_MODE_OFF, shuffleModeEnabled);
+        if (firstWindowIndex != C.INDEX_UNSET) {
+          queue.addFirst(
+              new MediaSessionCompat.QueueItem(
+                  getMediaDescription(player, firstWindowIndex), firstWindowIndex));
+        }
+      }
     }
-    mediaSession.setQueue(queue);
+    mediaSession.setQueue(new ArrayList<>(queue));
     activeQueueItemId = currentWindowIndex;
   }
-
 }
-
diff --git a/extensions/okhttp/README.md b/extensions/okhttp/README.md
index 73297b54a9..2f9893fe3b 100644
--- a/extensions/okhttp/README.md
+++ b/extensions/okhttp/README.md
@@ -3,7 +3,7 @@
 The OkHttp extension is an [HttpDataSource][] implementation using Square's
 [OkHttp][].
 
-[HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
+[HttpDataSource]: https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
 [OkHttp]: https://square.github.io/okhttp/
 
 ## License note ##
@@ -61,4 +61,4 @@ respectively.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.okhttp.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 4e6b11c495..db2e073c8a 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -28,13 +27,15 @@ android {
         targetSdkVersion project.ext.targetSdkVersion
         consumerProguardFiles 'proguard-rules.txt'
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    api 'com.squareup.okhttp3:okhttp:3.11.0'
+    api 'com.squareup.okhttp3:okhttp:3.12.1'
 }
 
 ext {
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 778277fdbc..a749495184 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -18,9 +18,10 @@
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -263,7 +264,6 @@ protected final long bytesRemaining() {
   private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
     if (url == null) {
@@ -293,10 +293,14 @@ private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {
     if (userAgent != null) {
       builder.addHeader("User-Agent", userAgent);
     }
-
-    if (!allowGzip) {
+    if (!dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP)) {
       builder.addHeader("Accept-Encoding", "identity");
     }
+    if (dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA)) {
+      builder.addHeader(
+          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
+          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
+    }
     RequestBody requestBody = null;
     if (dataSpec.httpBody != null) {
       requestBody = RequestBody.create(null, dataSpec.httpBody);
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 09f4e0b61a..d0ef35cb07 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.okhttp;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
diff --git a/extensions/opus/README.md b/extensions/opus/README.md
index 15c3e5413d..95c6807275 100644
--- a/extensions/opus/README.md
+++ b/extensions/opus/README.md
@@ -98,4 +98,4 @@ player, then implement your own logic to use the renderer for a given track.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.opus.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index cb12442de8..56acbdb7d3 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -34,11 +33,15 @@ android {
         jniLibs.srcDir 'src/main/libs'
         jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
+    androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
+    androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
 }
 
 ext {
diff --git a/extensions/opus/src/androidTest/AndroidManifest.xml b/extensions/opus/src/androidTest/AndroidManifest.xml
index 5ba0f3c0f4..7f775f4d32 100644
--- a/extensions/opus/src/androidTest/AndroidManifest.xml
+++ b/extensions/opus/src/androidTest/AndroidManifest.xml
@@ -18,6 +18,9 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.opus.test">
 
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-sdk/>
+
   <application android:debuggable="true"
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index c457514c87..dcd5f4957a 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -15,21 +15,21 @@
  */
 package com.google.android.exoplayer2.ext.opus;
 
-import static androidx.test.InstrumentationRegistry.getContext;
 import static org.junit.Assert.fail;
 
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import org.junit.Before;
@@ -56,7 +56,7 @@ public void testBasicPlayback() throws Exception {
 
   private void playUri(String uri) throws Exception {
     TestPlaybackRunnable testPlaybackRunnable =
-        new TestPlaybackRunnable(Uri.parse(uri), getContext());
+        new TestPlaybackRunnable(Uri.parse(uri), ApplicationProvider.getApplicationContext());
     Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
     thread.join();
@@ -83,12 +83,12 @@ public void run() {
       Looper.prepare();
       LibopusAudioRenderer audioRenderer = new LibopusAudioRenderer();
       DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-      player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
+      player = ExoPlayerFactory.newInstance(context, new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
       MediaSource mediaSource =
-          new ExtractorMediaSource.Factory(
-                  new DefaultDataSourceFactory(context, "ExoPlayerExtOpusTest"))
-              .setExtractorsFactory(MatroskaExtractor.FACTORY)
+          new ProgressiveMediaSource.Factory(
+                  new DefaultDataSourceFactory(context, "ExoPlayerExtOpusTest"),
+                  MatroskaExtractor.FACTORY)
               .createMediaSource(uri);
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index e288339058..59337c0847 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -47,7 +47,9 @@ public LibopusAudioRenderer() {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+  public LibopusAudioRenderer(
+      Handler eventHandler,
+      AudioRendererEventListener eventListener,
       AudioProcessor... audioProcessors) {
     super(eventHandler, eventListener, audioProcessors);
   }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
index 4cb3ce3190..285be96388 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
@@ -27,7 +27,7 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.opus");
   }
 
-  private static final LibraryLoader LOADER = new LibraryLoader("opusJNI");
+  private static final LibraryLoader LOADER = new LibraryLoader("opusV2JNI");
 
   private OpusLibrary() {}
 
diff --git a/extensions/opus/src/main/jni/Android.mk b/extensions/opus/src/main/jni/Android.mk
index 9d1e4fe726..0b06d9ecd8 100644
--- a/extensions/opus/src/main/jni/Android.mk
+++ b/extensions/opus/src/main/jni/Android.mk
@@ -21,10 +21,10 @@ include $(CLEAR_VARS)
 LOCAL_PATH := $(WORKING_DIR)
 include libopus.mk
 
-# build libopusJNI.so
+# build libopusV2JNI.so
 include $(CLEAR_VARS)
 LOCAL_PATH := $(WORKING_DIR)
-LOCAL_MODULE := libopusJNI
+LOCAL_MODULE := libopusV2JNI
 LOCAL_ARM_MODE := arm
 LOCAL_CPP_EXTENSION := .cc
 LOCAL_SRC_FILES := opus_jni.cc
diff --git a/extensions/opus/src/test/AndroidManifest.xml b/extensions/opus/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..ac6a3bf68f
--- /dev/null
+++ b/extensions/opus/src/test/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.opus"/>
diff --git a/extensions/opus/src/test/java/com/google/android/exoplayer2/ext/opus/DefaultRenderersFactoryTest.java b/extensions/opus/src/test/java/com/google/android/exoplayer2/ext/opus/DefaultRenderersFactoryTest.java
new file mode 100644
index 0000000000..e57ad84a41
--- /dev/null
+++ b/extensions/opus/src/test/java/com/google/android/exoplayer2/ext/opus/DefaultRenderersFactoryTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.opus;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.DefaultRenderersFactoryAsserts;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link DefaultRenderersFactoryTest} with {@link LibopusAudioRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public final class DefaultRenderersFactoryTest {
+
+  @Test
+  public void createRenderers_instantiatesVpxRenderer() {
+    DefaultRenderersFactoryAsserts.assertExtensionRendererCreated(
+        LibopusAudioRenderer.class, C.TRACK_TYPE_AUDIO);
+  }
+}
diff --git a/extensions/rtmp/README.md b/extensions/rtmp/README.md
index b222bdabd9..a34341692b 100644
--- a/extensions/rtmp/README.md
+++ b/extensions/rtmp/README.md
@@ -3,7 +3,7 @@
 The RTMP extension is a [DataSource][] implementation for playing [RTMP][]
 streams using [LibRtmp Client for Android][].
 
-[DataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer2/upstream/DataSource.html
+[DataSource]: https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/DataSource.html
 [RTMP]: https://en.wikipedia.org/wiki/Real-Time_Messaging_Protocol
 [LibRtmp Client for Android]: https://github.com/ant-media/LibRtmp-Client-for-Android
 
@@ -39,7 +39,7 @@ either instantiated and injected from application code, or obtained from
 instances of `DataSource.Factory` that are instantiated and injected from
 application code.
 
-`DefaultDataSource` will automatically use uses the RTMP extension whenever it's
+`DefaultDataSource` will automatically use the RTMP extension whenever it's
 available. Hence if your application is using `DefaultDataSource` or
 `DefaultDataSourceFactory`, adding support for RTMP streams is as simple as
 adding a dependency to the RTMP extension as described above. No changes to your
@@ -53,4 +53,4 @@ doesn't need to handle any other protocols, you can update any `DataSource`s and
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.rtmp.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/rtmp/build.gradle b/extensions/rtmp/build.gradle
index af02ee2eaa..ca734c3657 100644
--- a/extensions/rtmp/build.gradle
+++ b/extensions/rtmp/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -24,17 +23,18 @@ android {
     }
 
     defaultConfig {
-        minSdkVersion 15
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'net.butterflytv.utils:rtmp-client:3.0.1'
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
-    testImplementation 'junit:junit:' + junitVersion
-    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java
index 08c328ce81..272a8d1eb4 100644
--- a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java
+++ b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.ext.rtmp;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.upstream.BaseDataSource;
diff --git a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
index d1350276f2..36abf825d6 100644
--- a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
+++ b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.rtmp;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
diff --git a/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java b/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
index f4753798b8..469e66a884 100644
--- a/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
+++ b/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
@@ -16,23 +16,25 @@
 package com.google.android.exoplayer2.ext.rtmp;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.DefaultDataSource;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link DefaultDataSource} with RTMP URIs. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DefaultDataSourceTest {
 
   @Test
   public void openRtmpDataSpec_instantiatesRtmpDataSourceViaReflection() throws IOException {
     DefaultDataSource dataSource =
         new DefaultDataSource(
-            RuntimeEnvironment.application, "userAgent", /* allowCrossProtocolRedirects= */ false);
+            ApplicationProvider.getApplicationContext(),
+            "userAgent",
+            /* allowCrossProtocolRedirects= */ false);
     DataSpec dataSpec = new DataSpec(Uri.parse("rtmp://test.com/stream"));
     try {
       dataSource.open(dataSpec);
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 306f04d0e2..0de29eea32 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -34,24 +34,20 @@ VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Fetch libvpx and libyuv:
+* Fetch libvpx:
 
 ```
 cd "${VP9_EXT_PATH}/jni" && \
-git clone https://chromium.googlesource.com/webm/libvpx libvpx && \
-git clone https://chromium.googlesource.com/libyuv/libyuv libyuv
+git clone https://chromium.googlesource.com/webm/libvpx libvpx
 ```
 
-* Checkout the appropriate branches of libvpx and libyuv (the scripts and
-  makefiles bundled in this repo are known to work only at these versions of the
-  libraries - we will update this periodically as newer versions of
-  libvpx/libyuv are released):
+* Checkout the appropriate branch of libvpx (the scripts and makefiles bundled
+  in this repo are known to work only at specific versions of the library - we
+  will update this periodically as newer versions of libvpx are released):
 
 ```
 cd "${VP9_EXT_PATH}/jni/libvpx" && \
-git checkout tags/v1.7.0 -b v1.7.0 && \
-cd "${VP9_EXT_PATH}/jni/libyuv" && \
-git checkout 996a2bbd
+git checkout tags/v1.8.0 -b v1.8.0
 ```
 
 * Run a script that generates necessary configuration files for libvpx:
@@ -78,10 +74,10 @@ ${NDK_PATH}/ndk-build APP_ABI=all -j4
   * Android config scripts should be re-generated by running
     `generate_libvpx_android_configs.sh`
   * Clean and re-build the project.
-* If you want to use your own version of libvpx or libyuv, place it in
-  `${VP9_EXT_PATH}/jni/libvpx` or `${VP9_EXT_PATH}/jni/libyuv` respectively. But
-  please note that `generate_libvpx_android_configs.sh` and the makefiles need
-  to be modified to work with arbitrary versions of libvpx and libyuv.
+* If you want to use your own version of libvpx, place it in
+  `${VP9_EXT_PATH}/jni/libvpx`. Please note that
+  `generate_libvpx_android_configs.sh` and the makefiles may need to be modified
+  to work with arbitrary versions of libvpx.
 
 ## Using the extension ##
 
@@ -123,4 +119,4 @@ type `LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER` with the
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.vp9.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 96c58d7a57..02b68b831d 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -34,13 +33,17 @@ android {
         jniLibs.srcDir 'src/main/libs'
         jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
-    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
-    androidTestImplementation 'com.google.truth:truth:' + truthVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
+    testImplementation project(modulePrefix + 'testutils-robolectric')
+    androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
+    androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
+    androidTestImplementation 'androidx.test.ext:truth:' + androidXTestVersion
 }
 
 ext {
diff --git a/extensions/vp9/src/androidTest/AndroidManifest.xml b/extensions/vp9/src/androidTest/AndroidManifest.xml
index 214427c4f0..6ca2e7164a 100644
--- a/extensions/vp9/src/androidTest/AndroidManifest.xml
+++ b/extensions/vp9/src/androidTest/AndroidManifest.xml
@@ -18,6 +18,9 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.vp9.test">
 
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-sdk/>
+
   <application android:debuggable="true"
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index 2eb5c87e04..5120004889 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -15,22 +15,22 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
-import static androidx.test.InstrumentationRegistry.getContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.util.Log;
@@ -89,7 +89,7 @@ public void testInvalidBitstream() {
 
   private void playUri(String uri) throws Exception {
     TestPlaybackRunnable testPlaybackRunnable =
-        new TestPlaybackRunnable(Uri.parse(uri), getContext());
+        new TestPlaybackRunnable(Uri.parse(uri), ApplicationProvider.getApplicationContext());
     Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
     thread.join();
@@ -114,14 +114,14 @@ public TestPlaybackRunnable(Uri uri, Context context) {
     @Override
     public void run() {
       Looper.prepare();
-      LibvpxVideoRenderer videoRenderer = new LibvpxVideoRenderer(true, 0);
+      LibvpxVideoRenderer videoRenderer = new LibvpxVideoRenderer(0);
       DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-      player = ExoPlayerFactory.newInstance(new Renderer[] {videoRenderer}, trackSelector);
+      player = ExoPlayerFactory.newInstance(context, new Renderer[] {videoRenderer}, trackSelector);
       player.addListener(this);
       MediaSource mediaSource =
-          new ExtractorMediaSource.Factory(
-                  new DefaultDataSourceFactory(context, "ExoPlayerExtVp9Test"))
-              .setExtractorsFactory(MatroskaExtractor.FACTORY)
+          new ProgressiveMediaSource.Factory(
+                  new DefaultDataSourceFactory(context, "ExoPlayerExtVp9Test"),
+                  MatroskaExtractor.FACTORY)
               .createMediaSource(uri);
       player
           .createMessage(videoRenderer)
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index e3081cd2d2..d5da9a011d 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -15,14 +15,14 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
+import static java.lang.Runtime.getRuntime;
+
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.support.annotation.CallSuper;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.CallSuper;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
@@ -97,19 +97,17 @@
    */
   public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = C.MSG_CUSTOM_BASE;
 
-  /**
-   * The number of input buffers.
-   */
-  private static final int NUM_INPUT_BUFFERS = 8;
+  /** The number of input buffers. */
+  private final int numInputBuffers;
   /**
    * The number of output buffers. The renderer may limit the minimum possible value due to
    * requiring multiple output buffers to be dequeued at a time for it to make progress.
    */
-  private static final int NUM_OUTPUT_BUFFERS = 8;
+  private final int numOutputBuffers;
   /** The default input buffer size. */
   private static final int DEFAULT_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
 
-  private final boolean scaleToFit;
+  private final boolean enableRowMultiThreadMode;
   private final boolean disableLoopFilter;
   private final long allowedJoiningTimeMs;
   private final int maxDroppedFramesToNotify;
@@ -119,7 +117,7 @@
   private final TimedValueQueue<Format> formatQueue;
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
-  private final boolean useSurfaceYuvOutput;
+  private final int threads;
 
   private Format format;
   private Format pendingFormat;
@@ -127,13 +125,12 @@
   private VpxDecoder decoder;
   private VpxInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
-  private DrmSession<ExoMediaCrypto> drmSession;
-  private DrmSession<ExoMediaCrypto> pendingDrmSession;
+  @Nullable private DrmSession<ExoMediaCrypto> decoderDrmSession;
+  @Nullable private DrmSession<ExoMediaCrypto> sourceDrmSession;
 
   private @ReinitializationState int decoderReinitializationState;
   private boolean decoderReceivedBuffers;
 
-  private Bitmap bitmap;
   private boolean renderedFirstFrame;
   private long initialPositionUs;
   private long joiningDeadlineMs;
@@ -158,16 +155,14 @@
   protected DecoderCounters decoderCounters;
 
   /**
-   * @param scaleToFit Whether video frames should be scaled to fit when rendering.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    */
-  public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs) {
-    this(scaleToFit, allowedJoiningTimeMs, null, null, 0);
+  public LibvpxVideoRenderer(long allowedJoiningTimeMs) {
+    this(allowedJoiningTimeMs, null, null, 0);
   }
 
   /**
-   * @param scaleToFit Whether video frames should be scaled to fit when rendering.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
@@ -176,23 +171,22 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs) {
    * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
-  public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
-      Handler eventHandler, VideoRendererEventListener eventListener,
+  public LibvpxVideoRenderer(
+      long allowedJoiningTimeMs,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
       int maxDroppedFramesToNotify) {
     this(
-        scaleToFit,
         allowedJoiningTimeMs,
         eventHandler,
         eventListener,
         maxDroppedFramesToNotify,
         /* drmSessionManager= */ null,
         /* playClearSamplesWithoutKeys= */ false,
-        /* disableLoopFilter= */ false,
-        /* useSurfaceYuvOutput= */ false);
+        /* disableLoopFilter= */ false);
   }
 
   /**
-   * @param scaleToFit Whether video frames should be scaled to fit when rendering.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
@@ -208,10 +202,51 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
-   * @param useSurfaceYuvOutput Directly output YUV to the Surface via ANativeWindow.
    */
   public LibvpxVideoRenderer(
-      boolean scaleToFit,
+      long allowedJoiningTimeMs,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify,
+      DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      boolean disableLoopFilter) {
+    this(
+        allowedJoiningTimeMs,
+        eventHandler,
+        eventListener,
+        maxDroppedFramesToNotify,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        disableLoopFilter,
+        /* enableRowMultiThreadMode= */ false,
+        getRuntime().availableProcessors(),
+        /* numInputBuffers= */ 4,
+        /* numOutputBuffers= */ 4);
+  }
+
+  /**
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
+   *     media is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
+   * @param enableRowMultiThreadMode Whether row multi threading decoding is enabled.
+   * @param threads Number of threads libvpx will use to decode.
+   * @param numInputBuffers Number of input buffers.
+   * @param numOutputBuffers Number of output buffers.
+   */
+  public LibvpxVideoRenderer(
       long allowedJoiningTimeMs,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
@@ -219,15 +254,20 @@ public LibvpxVideoRenderer(
       DrmSessionManager<ExoMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
       boolean disableLoopFilter,
-      boolean useSurfaceYuvOutput) {
+      boolean enableRowMultiThreadMode,
+      int threads,
+      int numInputBuffers,
+      int numOutputBuffers) {
     super(C.TRACK_TYPE_VIDEO);
-    this.scaleToFit = scaleToFit;
     this.disableLoopFilter = disableLoopFilter;
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
-    this.useSurfaceYuvOutput = useSurfaceYuvOutput;
+    this.enableRowMultiThreadMode = enableRowMultiThreadMode;
+    this.threads = threads;
+    this.numInputBuffers = numInputBuffers;
+    this.numOutputBuffers = numOutputBuffers;
     joiningDeadlineMs = C.TIME_UNSET;
     clearReportedVideoSize();
     formatHolder = new FormatHolder();
@@ -364,24 +404,10 @@ protected void onDisabled() {
     clearReportedVideoSize();
     clearRenderedFirstFrame();
     try {
+      setSourceDrmSession(null);
       releaseDecoder();
     } finally {
-      try {
-        if (drmSession != null) {
-          drmSessionManager.releaseSession(drmSession);
-        }
-      } finally {
-        try {
-          if (pendingDrmSession != null && pendingDrmSession != drmSession) {
-            drmSessionManager.releaseSession(pendingDrmSession);
-          }
-        } finally {
-          drmSession = null;
-          pendingDrmSession = null;
-          decoderCounters.ensureUpdated();
-          eventDispatcher.disabled(decoderCounters);
-        }
-      }
+      eventDispatcher.disabled(decoderCounters);
     }
   }
 
@@ -433,18 +459,35 @@ protected void flushDecoder() throws ExoPlaybackException {
   /** Releases the decoder. */
   @CallSuper
   protected void releaseDecoder() {
-    if (decoder == null) {
-      return;
-    }
-
     inputBuffer = null;
     outputBuffer = null;
-    decoder.release();
-    decoder = null;
-    decoderCounters.decoderReleaseCount++;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     decoderReceivedBuffers = false;
     buffersInCodecCount = 0;
+    if (decoder != null) {
+      decoder.release();
+      decoder = null;
+      decoderCounters.decoderReleaseCount++;
+    }
+    setDecoderDrmSession(null);
+  }
+
+  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession<ExoMediaCrypto> previous = sourceDrmSession;
+    sourceDrmSession = session;
+    releaseDrmSessionIfUnused(previous);
+  }
+
+  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession<ExoMediaCrypto> previous = decoderDrmSession;
+    decoderDrmSession = session;
+    releaseDrmSessionIfUnused(previous);
+  }
+
+  private void releaseDrmSessionIfUnused(@Nullable DrmSession<ExoMediaCrypto> session) {
+    if (session != null && session != decoderDrmSession && session != sourceDrmSession) {
+      drmSessionManager.releaseSession(session);
+    }
   }
 
   /**
@@ -467,16 +510,20 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
           throw ExoPlaybackException.createForRenderer(
               new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
         }
-        pendingDrmSession = drmSessionManager.acquireSession(Looper.myLooper(), format.drmInitData);
-        if (pendingDrmSession == drmSession) {
-          drmSessionManager.releaseSession(pendingDrmSession);
+        DrmSession<ExoMediaCrypto> session =
+            drmSessionManager.acquireSession(Looper.myLooper(), newFormat.drmInitData);
+        if (session == decoderDrmSession || session == sourceDrmSession) {
+          // We already had this session. The manager must be reference counting, so release it once
+          // to get the count attributed to this renderer back down to 1.
+          drmSessionManager.releaseSession(session);
         }
+        setSourceDrmSession(session);
       } else {
-        pendingDrmSession = null;
+        setSourceDrmSession(null);
       }
     }
 
-    if (pendingDrmSession != drmSession) {
+    if (sourceDrmSession != decoderDrmSession) {
       if (decoderReceivedBuffers) {
         // Signal end of stream and wait for any final output buffers before re-initialization.
         decoderReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
@@ -579,18 +626,14 @@ protected void dropOutputBuffer(VpxOutputBuffer outputBuffer) {
    */
   protected void renderOutputBuffer(VpxOutputBuffer outputBuffer) throws VpxDecoderException {
     int bufferMode = outputBuffer.mode;
-    boolean renderRgb = bufferMode == VpxDecoder.OUTPUT_MODE_RGB && surface != null;
     boolean renderSurface = bufferMode == VpxDecoder.OUTPUT_MODE_SURFACE_YUV && surface != null;
     boolean renderYuv = bufferMode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null;
     lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-    if (!renderRgb && !renderYuv && !renderSurface) {
+    if (!renderYuv && !renderSurface) {
       dropOutputBuffer(outputBuffer);
     } else {
       maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
-      if (renderRgb) {
-        renderRgbFrame(outputBuffer, scaleToFit);
-        outputBuffer.release();
-      } else if (renderYuv) {
+      if (renderYuv) {
         outputBufferRenderer.setOutputBuffer(outputBuffer);
         // The renderer will release the buffer.
       } else { // renderSurface
@@ -668,8 +711,7 @@ private void setOutput(
       this.surface = surface;
       this.outputBufferRenderer = outputBufferRenderer;
       if (surface != null) {
-        outputMode =
-            useSurfaceYuvOutput ? VpxDecoder.OUTPUT_MODE_SURFACE_YUV : VpxDecoder.OUTPUT_MODE_RGB;
+        outputMode = VpxDecoder.OUTPUT_MODE_SURFACE_YUV;
       } else {
         outputMode =
             outputBufferRenderer != null ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_NONE;
@@ -704,12 +746,13 @@ private void maybeInitDecoder() throws ExoPlaybackException {
       return;
     }
 
-    drmSession = pendingDrmSession;
+    setDecoderDrmSession(sourceDrmSession);
+
     ExoMediaCrypto mediaCrypto = null;
-    if (drmSession != null) {
-      mediaCrypto = drmSession.getMediaCrypto();
+    if (decoderDrmSession != null) {
+      mediaCrypto = decoderDrmSession.getMediaCrypto();
       if (mediaCrypto == null) {
-        DrmSessionException drmError = drmSession.getError();
+        DrmSessionException drmError = decoderDrmSession.getError();
         if (drmError != null) {
           // Continue for now. We may be able to avoid failure if the session recovers, or if a new
           // input format causes the session to be replaced before it's used.
@@ -727,12 +770,13 @@ private void maybeInitDecoder() throws ExoPlaybackException {
           format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
       decoder =
           new VpxDecoder(
-              NUM_INPUT_BUFFERS,
-              NUM_OUTPUT_BUFFERS,
+              numInputBuffers,
+              numOutputBuffers,
               initialInputBufferSize,
               mediaCrypto,
               disableLoopFilter,
-              useSurfaceYuvOutput);
+              enableRowMultiThreadMode,
+              threads);
       decoder.setOutputMode(outputMode);
       TraceUtil.endSection();
       long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
@@ -922,33 +966,16 @@ private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
   }
 
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (drmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+    if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
       return false;
     }
-    @DrmSession.State int drmSessionState = drmSession.getState();
+    @DrmSession.State int drmSessionState = decoderDrmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+      throw ExoPlaybackException.createForRenderer(decoderDrmSession.getError(), getIndex());
     }
     return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
   }
 
-  private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
-    if (bitmap == null
-        || bitmap.getWidth() != outputBuffer.width
-        || bitmap.getHeight() != outputBuffer.height) {
-      bitmap = Bitmap.createBitmap(outputBuffer.width, outputBuffer.height, Bitmap.Config.RGB_565);
-    }
-    bitmap.copyPixelsFromBuffer(outputBuffer.data);
-    Canvas canvas = surface.lockCanvas(null);
-    if (scale) {
-      canvas.scale(
-          ((float) canvas.getWidth()) / outputBuffer.width,
-          ((float) canvas.getHeight()) / outputBuffer.height);
-    }
-    canvas.drawBitmap(bitmap, 0, 0, null);
-    surface.unlockCanvasAndPost(canvas);
-  }
-
   private void setJoiningDeadlineMs() {
     joiningDeadlineMs = allowedJoiningTimeMs > 0
         ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs) : C.TIME_UNSET;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 51ef8e9bcf..57e5481b55 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -31,8 +31,7 @@
 
   public static final int OUTPUT_MODE_NONE = -1;
   public static final int OUTPUT_MODE_YUV = 0;
-  public static final int OUTPUT_MODE_RGB = 1;
-  public static final int OUTPUT_MODE_SURFACE_YUV = 2;
+  public static final int OUTPUT_MODE_SURFACE_YUV = 1;
 
   private static final int NO_ERROR = 0;
   private static final int DECODE_ERROR = 1;
@@ -52,7 +51,8 @@
    * @param exoMediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted
    *     content. Maybe null and can be ignored if decoder does not handle encrypted content.
    * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
-   * @param enableSurfaceYuvOutputMode Whether OUTPUT_MODE_SURFACE_YUV is allowed.
+   * @param enableRowMultiThreadMode Whether row multi threading decoding is enabled.
+   * @param threads Number of threads libvpx will use to decode.
    * @throws VpxDecoderException Thrown if an exception occurs when initializing the decoder.
    */
   public VpxDecoder(
@@ -61,7 +61,8 @@ public VpxDecoder(
       int initialInputBufferSize,
       ExoMediaCrypto exoMediaCrypto,
       boolean disableLoopFilter,
-      boolean enableSurfaceYuvOutputMode)
+      boolean enableRowMultiThreadMode,
+      int threads)
       throws VpxDecoderException {
     super(new VpxInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
     if (!VpxLibrary.isAvailable()) {
@@ -71,7 +72,7 @@ public VpxDecoder(
     if (exoMediaCrypto != null && !VpxLibrary.vpxIsSecureDecodeSupported()) {
       throw new VpxDecoderException("Vpx decoder does not support secure decode.");
     }
-    vpxDecContext = vpxInit(disableLoopFilter, enableSurfaceYuvOutputMode);
+    vpxDecContext = vpxInit(disableLoopFilter, enableRowMultiThreadMode, threads);
     if (vpxDecContext == 0) {
       throw new VpxDecoderException("Failed to initialize decoder");
     }
@@ -86,8 +87,8 @@ public String getName() {
   /**
    * Sets the output mode for frames rendered by the decoder.
    *
-   * @param outputMode The output mode. One of {@link #OUTPUT_MODE_NONE}, {@link #OUTPUT_MODE_RGB}
-   *     and {@link #OUTPUT_MODE_YUV}.
+   * @param outputMode The output mode. One of {@link #OUTPUT_MODE_NONE} and {@link
+   *     #OUTPUT_MODE_YUV}.
    */
   public void setOutputMode(int outputMode) {
     this.outputMode = outputMode;
@@ -168,7 +169,8 @@ public void renderToSurface(VpxOutputBuffer outputBuffer, Surface surface)
     }
   }
 
-  private native long vpxInit(boolean disableLoopFilter, boolean enableSurfaceYuvOutputMode);
+  private native long vpxInit(
+      boolean disableLoopFilter, boolean enableRowMultiThreadMode, int threads);
 
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
index 854576b4b2..5a65fc56ff 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
@@ -27,7 +27,7 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.vpx");
   }
 
-  private static final LibraryLoader LOADER = new LibraryLoader("vpx", "vpxJNI");
+  private static final LibraryLoader LOADER = new LibraryLoader("vpx", "vpxV2JNI");
 
   private VpxLibrary() {}
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index fa0df1cfa9..22330e0a05 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -19,10 +19,8 @@
 import com.google.android.exoplayer2.video.ColorInfo;
 import java.nio.ByteBuffer;
 
-/**
- * Output buffer containing video frame data, populated by {@link VpxDecoder}.
- */
-/* package */ final class VpxOutputBuffer extends OutputBuffer {
+/** Output buffer containing video frame data, populated by {@link VpxDecoder}. */
+public final class VpxOutputBuffer extends OutputBuffer {
 
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
@@ -62,36 +60,20 @@ public void release() {
    * Initializes the buffer.
    *
    * @param timeUs The presentation timestamp for the buffer, in microseconds.
-   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE},
-   *     {@link VpxDecoder#OUTPUT_MODE_RGB} and {@link VpxDecoder#OUTPUT_MODE_YUV}.
+   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE} and {@link
+   *     VpxDecoder#OUTPUT_MODE_YUV}.
    */
   public void init(long timeUs, int mode) {
     this.timeUs = timeUs;
     this.mode = mode;
   }
 
-  /**
-   * Resizes the buffer based on the given dimensions. Called via JNI after decoding completes.
-   * @return Whether the buffer was resized successfully.
-   */
-  public boolean initForRgbFrame(int width, int height) {
-    this.width = width;
-    this.height = height;
-    this.yuvPlanes = null;
-    if (!isSafeToMultiply(width, height) || !isSafeToMultiply(width * height, 2)) {
-      return false;
-    }
-    int minimumRgbSize = width * height * 2;
-    initData(minimumRgbSize);
-    return true;
-  }
-
   /**
    * Resizes the buffer based on the given stride. Called via JNI after decoding completes.
+   *
    * @return Whether the buffer was resized successfully.
    */
-  public boolean initForYuvFrame(int width, int height, int yStride, int uvStride,
-      int colorspace) {
+  public boolean initForYuvFrame(int width, int height, int yStride, int uvStride, int colorspace) {
     this.width = width;
     this.height = height;
     this.colorspace = colorspace;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
index 837539593e..d82f5a6071 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
@@ -17,8 +17,7 @@
 
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
+import com.google.android.exoplayer2.util.GlUtil;
 import java.nio.FloatBuffer;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.microedition.khronos.egl.EGLConfig;
@@ -72,11 +71,8 @@
       + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);\n"
       + "}\n";
 
-  private static final FloatBuffer TEXTURE_VERTICES = nativeFloatBuffer(
-      -1.0f, 1.0f,
-      -1.0f, -1.0f,
-      1.0f, 1.0f,
-      1.0f, -1.0f);
+  private static final FloatBuffer TEXTURE_VERTICES =
+      GlUtil.createBuffer(new float[] {-1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f});
   private final int[] yuvTextures = new int[3];
   private final AtomicReference<VpxOutputBuffer> pendingOutputBufferReference;
 
@@ -114,21 +110,7 @@ public void setFrame(VpxOutputBuffer outputBuffer) {
 
   @Override
   public void onSurfaceCreated(GL10 unused, EGLConfig config) {
-    // Create the GL program.
-    program = GLES20.glCreateProgram();
-
-    // Add the vertex and fragment shaders.
-    addShader(GLES20.GL_VERTEX_SHADER, VERTEX_SHADER, program);
-    addShader(GLES20.GL_FRAGMENT_SHADER, FRAGMENT_SHADER, program);
-
-    // Link the GL program.
-    GLES20.glLinkProgram(program);
-    int[] result = new int[] {
-        GLES20.GL_FALSE
-    };
-    result[0] = GLES20.GL_FALSE;
-    GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, result, 0);
-    abortUnless(result[0] == GLES20.GL_TRUE, GLES20.glGetProgramInfoLog(program));
+    program = GlUtil.compileProgram(VERTEX_SHADER, FRAGMENT_SHADER);
     GLES20.glUseProgram(program);
     int posLocation = GLES20.glGetAttribLocation(program, "in_pos");
     GLES20.glEnableVertexAttribArray(posLocation);
@@ -136,11 +118,11 @@ public void onSurfaceCreated(GL10 unused, EGLConfig config) {
         posLocation, 2, GLES20.GL_FLOAT, false, 0, TEXTURE_VERTICES);
     texLocation = GLES20.glGetAttribLocation(program, "in_tc");
     GLES20.glEnableVertexAttribArray(texLocation);
-    checkNoGLES2Error();
+    GlUtil.checkGlError();
     colorMatrixLocation = GLES20.glGetUniformLocation(program, "mColorConversion");
-    checkNoGLES2Error();
+    GlUtil.checkGlError();
     setupTextures();
-    checkNoGLES2Error();
+    GlUtil.checkGlError();
   }
 
   @Override
@@ -191,11 +173,8 @@ public void onDrawFrame(GL10 unused) {
       float crop = (float) outputBuffer.width / outputBuffer.yuvStrides[0];
       // This buffer is consumed during each call to glDrawArrays. It needs to be a member variable
       // rather than a local variable to ensure that it doesn't get garbage collected.
-      textureCoords = nativeFloatBuffer(
-          0.0f, 0.0f,
-          0.0f, 1.0f,
-          crop, 0.0f,
-          crop, 1.0f);
+      textureCoords =
+          GlUtil.createBuffer(new float[] {0.0f, 0.0f, 0.0f, 1.0f, crop, 0.0f, crop, 1.0f});
       GLES20.glVertexAttribPointer(
           texLocation, 2, GLES20.GL_FLOAT, false, 0, textureCoords);
       previousWidth = outputBuffer.width;
@@ -203,23 +182,7 @@ public void onDrawFrame(GL10 unused) {
     }
     GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
     GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
-    checkNoGLES2Error();
-  }
-
-  private void addShader(int type, String source, int program) {
-    int[] result = new int[] {
-        GLES20.GL_FALSE
-    };
-    int shader = GLES20.glCreateShader(type);
-    GLES20.glShaderSource(shader, source);
-    GLES20.glCompileShader(shader);
-    GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, result, 0);
-    abortUnless(result[0] == GLES20.GL_TRUE,
-        GLES20.glGetShaderInfoLog(shader) + ", source: " + source);
-    GLES20.glAttachShader(program, shader);
-    GLES20.glDeleteShader(shader);
-
-    checkNoGLES2Error();
+    GlUtil.checkGlError();
   }
 
   private void setupTextures() {
@@ -237,28 +200,6 @@ private void setupTextures() {
       GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
           GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
     }
-    checkNoGLES2Error();
-  }
-
-  private void abortUnless(boolean condition, String msg) {
-    if (!condition) {
-      throw new RuntimeException(msg);
-    }
-  }
-
-  private void checkNoGLES2Error() {
-    int error = GLES20.glGetError();
-    if (error != GLES20.GL_NO_ERROR) {
-      throw new RuntimeException("GLES20 error: " + error);
-    }
+    GlUtil.checkGlError();
   }
-
-  private static FloatBuffer nativeFloatBuffer(float... array) {
-    FloatBuffer buffer = ByteBuffer.allocateDirect(array.length * 4).order(
-        ByteOrder.nativeOrder()).asFloatBuffer();
-    buffer.put(array);
-    buffer.flip();
-    return buffer;
-  }
-
 }
diff --git a/extensions/vp9/src/main/jni/Android.mk b/extensions/vp9/src/main/jni/Android.mk
index 868b869d56..cb7571a1b0 100644
--- a/extensions/vp9/src/main/jni/Android.mk
+++ b/extensions/vp9/src/main/jni/Android.mk
@@ -17,27 +17,21 @@
 WORKING_DIR := $(call my-dir)
 include $(CLEAR_VARS)
 LIBVPX_ROOT := $(WORKING_DIR)/libvpx
-LIBYUV_ROOT := $(WORKING_DIR)/libyuv
-
-# build libyuv_static.a
-LOCAL_PATH := $(WORKING_DIR)
-LIBYUV_DISABLE_JPEG := "yes"
-include $(LIBYUV_ROOT)/Android.mk
 
 # build libvpx.so
 LOCAL_PATH := $(WORKING_DIR)
 include libvpx.mk
 
-# build libvpxJNI.so
+# build libvpxV2JNI.so
 include $(CLEAR_VARS)
 LOCAL_PATH := $(WORKING_DIR)
-LOCAL_MODULE := libvpxJNI
+LOCAL_MODULE := libvpxV2JNI
 LOCAL_ARM_MODE := arm
 LOCAL_CPP_EXTENSION := .cc
 LOCAL_SRC_FILES := vpx_jni.cc
 LOCAL_LDLIBS := -llog -lz -lm -landroid
 LOCAL_SHARED_LIBRARIES := libvpx
-LOCAL_STATIC_LIBRARIES := libyuv_static cpufeatures
+LOCAL_STATIC_LIBRARIES := cpufeatures
 include $(BUILD_SHARED_LIBRARY)
 
 $(call import-module,android/cpufeatures)
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index f36c433b22..82c023afbc 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -30,8 +30,6 @@
 #include <cstring>
 #include <new>
 
-#include "libyuv.h"  // NOLINT
-
 #define VPX_CODEC_DISABLE_COMPAT 1
 #include "vpx/vpx_decoder.h"
 #include "vpx/vp8dx.h"
@@ -61,7 +59,6 @@
       (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
 
 // JNI references for VpxOutputBuffer class.
-static jmethodID initForRgbFrame;
 static jmethodID initForYuvFrame;
 static jfieldID dataField;
 static jfieldID outputModeField;
@@ -393,11 +390,7 @@ class JniBufferManager {
 };
 
 struct JniCtx {
-  JniCtx(bool enableBufferManager) {
-    if (enableBufferManager) {
-      buffer_manager = new JniBufferManager();
-    }
-  }
+  JniCtx() { buffer_manager = new JniBufferManager(); }
 
   ~JniCtx() {
     if (native_window) {
@@ -441,11 +434,11 @@ int vpx_release_frame_buffer(void* priv, vpx_codec_frame_buffer_t* fb) {
 }
 
 DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
-             jboolean enableBufferManager) {
-  JniCtx* context = new JniCtx(enableBufferManager);
+             jboolean enableRowMultiThreadMode, jint threads) {
+  JniCtx* context = new JniCtx();
   context->decoder = new vpx_codec_ctx_t();
   vpx_codec_dec_cfg_t cfg = {0, 0, 0};
-  cfg.threads = android_getCpuCount();
+  cfg.threads = threads;
   errorCode = 0;
   vpx_codec_err_t err =
       vpx_codec_dec_init(context->decoder, &vpx_codec_vp9_dx_algo, &cfg, 0);
@@ -454,21 +447,33 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
     errorCode = err;
     return 0;
   }
+#ifdef VPX_CTRL_VP9_DECODE_SET_ROW_MT
+  err = vpx_codec_control(context->decoder, VP9D_SET_ROW_MT,
+                          enableRowMultiThreadMode);
+  if (err) {
+    LOGE("ERROR: Failed to enable row multi thread mode, error = %d.", err);
+  }
+#endif
   if (disableLoopFilter) {
-    // TODO(b/71930387): Use vpx_codec_control(), not vpx_codec_control_().
-    err = vpx_codec_control_(context->decoder, VP9_SET_SKIP_LOOP_FILTER, true);
+    err = vpx_codec_control(context->decoder, VP9_SET_SKIP_LOOP_FILTER, true);
     if (err) {
       LOGE("ERROR: Failed to shut off libvpx loop filter, error = %d.", err);
     }
-  }
-  if (enableBufferManager) {
-    err = vpx_codec_set_frame_buffer_functions(
-        context->decoder, vpx_get_frame_buffer, vpx_release_frame_buffer,
-        context->buffer_manager);
+#ifdef VPX_CTRL_VP9_SET_LOOP_FILTER_OPT
+  } else {
+    err = vpx_codec_control(context->decoder, VP9D_SET_LOOP_FILTER_OPT, true);
     if (err) {
-      LOGE("ERROR: Failed to set libvpx frame buffer functions, error = %d.",
+      LOGE("ERROR: Failed to enable loop filter optimization, error = %d.",
            err);
     }
+#endif
+  }
+  err = vpx_codec_set_frame_buffer_functions(
+      context->decoder, vpx_get_frame_buffer, vpx_release_frame_buffer,
+      context->buffer_manager);
+  if (err) {
+    LOGE("ERROR: Failed to set libvpx frame buffer functions, error = %d.",
+         err);
   }
 
   // Populate JNI References.
@@ -476,8 +481,6 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
       "com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
                                      "(IIIII)Z");
-  initForRgbFrame = env->GetMethodID(outputBufferClass, "initForRgbFrame",
-                                     "(II)Z");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
@@ -529,28 +532,10 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
   }
 
   const int kOutputModeYuv = 0;
-  const int kOutputModeRgb = 1;
-  const int kOutputModeSurfaceYuv = 2;
+  const int kOutputModeSurfaceYuv = 1;
 
   int outputMode = env->GetIntField(jOutputBuffer, outputModeField);
-  if (outputMode == kOutputModeRgb) {
-    // resize buffer if required.
-    jboolean initResult = env->CallBooleanMethod(jOutputBuffer, initForRgbFrame,
-                                                 img->d_w, img->d_h);
-    if (env->ExceptionCheck() || !initResult) {
-      return -1;
-    }
-
-    // get pointer to the data buffer.
-    const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
-    uint8_t* const dst =
-        reinterpret_cast<uint8_t*>(env->GetDirectBufferAddress(dataObject));
-
-    libyuv::I420ToRGB565(img->planes[VPX_PLANE_Y], img->stride[VPX_PLANE_Y],
-                         img->planes[VPX_PLANE_U], img->stride[VPX_PLANE_U],
-                         img->planes[VPX_PLANE_V], img->stride[VPX_PLANE_V],
-                         dst, img->d_w * 2, img->d_w, img->d_h);
-  } else if (outputMode == kOutputModeYuv) {
+  if (outputMode == kOutputModeYuv) {
     const int kColorspaceUnknown = 0;
     const int kColorspaceBT601 = 1;
     const int kColorspaceBT709 = 2;
@@ -608,9 +593,6 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     }
   } else if (outputMode == kOutputModeSurfaceYuv &&
              img->fmt != VPX_IMG_FMT_I42016) {
-    if (!context->buffer_manager) {
-      return -1;  // enableBufferManager was not set in vpxInit.
-    }
     int id = *(int*)img->fb_priv;
     context->buffer_manager->add_ref(id);
     JniFrameBuffer* jfb = context->buffer_manager->get_buffer(id);
diff --git a/extensions/vp9/src/test/AndroidManifest.xml b/extensions/vp9/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..a0123f17db
--- /dev/null
+++ b/extensions/vp9/src/test/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.vp9"/>
diff --git a/extensions/vp9/src/test/java/com/google/android/exoplayer2/ext/vp9/DefaultRenderersFactoryTest.java b/extensions/vp9/src/test/java/com/google/android/exoplayer2/ext/vp9/DefaultRenderersFactoryTest.java
new file mode 100644
index 0000000000..33de600aa7
--- /dev/null
+++ b/extensions/vp9/src/test/java/com/google/android/exoplayer2/ext/vp9/DefaultRenderersFactoryTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.vp9;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.DefaultRenderersFactoryAsserts;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link DefaultRenderersFactoryTest} with {@link LibvpxVideoRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public final class DefaultRenderersFactoryTest {
+
+  @Test
+  public void createRenderers_instantiatesVpxRenderer() {
+    DefaultRenderersFactoryAsserts.assertExtensionRendererCreated(
+        LibvpxVideoRenderer.class, C.TRACK_TYPE_VIDEO);
+  }
+}
diff --git a/gradle.properties b/gradle.properties
index b55575bc3b..4b9bfa8fa2 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,5 @@
 ## Project-wide Gradle settings.
-android.useDeprecatedNdk=true
+android.useAndroidX=true
+android.enableJetifier=true
+android.enableUnitTestBinaryResources=true
 buildDir=buildout
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 5559e8ccfa..6d00e1ce97 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 05 13:43:42 BST 2017
+#Thu Apr 25 13:15:25 BST 2019
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
diff --git a/javadoc_combined.gradle b/javadoc_combined.gradle
index 209ad3a1a3..d2fa241a81 100644
--- a/javadoc_combined.gradle
+++ b/javadoc_combined.gradle
@@ -42,7 +42,7 @@ class CombinedJavadocPlugin implements Plugin<Project> {
                 if (name == "release") {
                   classpath +=
                       libraryModule.project.files(
-                          variant.javaCompile.classpath.files,
+                          variant.javaCompileProvider.get().classpath.files,
                           libraryModule.project.android.getBootClasspath())
                 }
               }
diff --git a/javadoc_library.gradle b/javadoc_library.gradle
index 65219843e3..a818ea390e 100644
--- a/javadoc_library.gradle
+++ b/javadoc_library.gradle
@@ -21,7 +21,7 @@ android.libraryVariants.all { variant ->
     task("generateJavadoc", type: Javadoc) {
         description = "Generates Javadoc for the ${javadocTitle}."
         title = "ExoPlayer ${javadocTitle}"
-        source = variant.javaCompile.source
+        source = variant.javaCompileProvider.get().source
         options {
             links "http://docs.oracle.com/javase/7/docs/api/"
             linksOffline "https://developer.android.com/reference",
@@ -33,7 +33,7 @@ android.libraryVariants.all { variant ->
         doFirst {
             classpath =
                 files(
-                    variant.javaCompile.classpath.files,
+                    variant.javaCompileProvider.get().classpath.files,
                     project.android.getBootClasspath())
         }
         doLast {
diff --git a/library/all/README.md b/library/all/README.md
index 8746e3afc6..43f942116e 100644
--- a/library/all/README.md
+++ b/library/all/README.md
@@ -10,4 +10,4 @@ individually. See ExoPlayer's [top level README][] for more information.
 
 * [Javadoc][]: Note that this Javadoc is combined with that of other modules.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/all/build.gradle b/library/all/build.gradle
index bb832ba0ff..f78b8b2132 100644
--- a/library/all/build.gradle
+++ b/library/all/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
diff --git a/library/core/README.md b/library/core/README.md
index f31ffed131..7fa89dda8d 100644
--- a/library/core/README.md
+++ b/library/core/README.md
@@ -6,4 +6,4 @@ The core of the ExoPlayer library.
 
 * [Javadoc][]: Note that this Javadoc is combined with that of other modules.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/core/build.gradle b/library/core/build.gradle
index 606033fdea..68ff8cc977 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -16,7 +16,6 @@ apply from: '../../constants.gradle'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -54,21 +53,25 @@ android {
         //    testCoverageEnabled = true
         // }
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersion
-    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
+    androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
+    androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
+    androidTestImplementation 'androidx.test.ext:truth:' + androidXTestVersion
     androidTestImplementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
-    androidTestImplementation 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestImplementation 'com.google.truth:truth:' + truthVersion
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker:' + dexmakerVersion
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker-mockito:' + dexmakerVersion
     androidTestImplementation 'org.mockito:mockito-core:' + mockitoVersion
     androidTestAnnotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
-    testImplementation 'com.google.truth:truth:' + truthVersion
-    testImplementation 'junit:junit:' + junitVersion
+    testImplementation 'androidx.test:core:' + androidXTestVersion
+    testImplementation 'androidx.test.ext:junit:' + androidXTestVersion
+    testImplementation 'androidx.test.ext:truth:' + androidXTestVersion
     testImplementation 'org.mockito:mockito-core:' + mockitoVersion
     testImplementation 'org.robolectric:robolectric:' + robolectricVersion
     testImplementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
index a5c50a78f5..07ba438182 100644
--- a/library/core/proguard-rules.txt
+++ b/library/core/proguard-rules.txt
@@ -3,7 +3,7 @@
 # Constructors accessed via reflection in DefaultRenderersFactory
 -dontnote com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer
 -keepclassmembers class com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer {
-  <init>(boolean, long, android.os.Handler, com.google.android.exoplayer2.video.VideoRendererEventListener, int);
+  <init>(long, android.os.Handler, com.google.android.exoplayer2.video.VideoRendererEventListener, int);
 }
 -dontnote com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer
 -keepclassmembers class com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer {
@@ -30,10 +30,36 @@
   <init>();
 }
 
-# Constructors accessed via reflection in DownloadAction
--dontnote com.google.android.exoplayer2.source.dash.offline.DashDownloadAction
--dontnote com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction
--dontnote com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction
+# Constructors accessed via reflection in DefaultDownloaderFactory
+-dontnote com.google.android.exoplayer2.source.dash.offline.DashDownloader
+-keepclassmembers class com.google.android.exoplayer2.source.dash.offline.DashDownloader {
+  <init>(android.net.Uri, java.util.List, com.google.android.exoplayer2.offline.DownloaderConstructorHelper);
+}
+-dontnote com.google.android.exoplayer2.source.hls.offline.HlsDownloader
+-keepclassmembers class com.google.android.exoplayer2.source.hls.offline.HlsDownloader {
+  <init>(android.net.Uri, java.util.List, com.google.android.exoplayer2.offline.DownloaderConstructorHelper);
+}
+-dontnote com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloader
+-keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloader {
+  <init>(android.net.Uri, java.util.List, com.google.android.exoplayer2.offline.DownloaderConstructorHelper);
+}
+
+# Constructors accessed via reflection in DownloadHelper
+-dontnote com.google.android.exoplayer2.source.dash.DashMediaSource$Factory
+-keepclassmembers class com.google.android.exoplayer2.source.dash.DashMediaSource$Factory {
+  <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  com.google.android.exoplayer2.source.dash.DashMediaSource createMediaSource(android.net.Uri);
+}
+-dontnote com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory
+-keepclassmembers class com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory {
+  <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  com.google.android.exoplayer2.source.hls.HlsMediaSource createMediaSource(android.net.Uri);
+}
+-dontnote com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory
+-keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory {
+  <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource createMediaSource(android.net.Uri);
+}
 
 # Don't warn about checkerframework
 -dontwarn org.checkerframework.**
diff --git a/library/core/src/androidTest/AndroidManifest.xml b/library/core/src/androidTest/AndroidManifest.xml
index d9104b1077..e6e874a27a 100644
--- a/library/core/src/androidTest/AndroidManifest.xml
+++ b/library/core/src/androidTest/AndroidManifest.xml
@@ -18,6 +18,9 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.core.test">
 
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-sdk/>
+
   <application android:debuggable="true"
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
index 45b784e30f..a76b5cf6c1 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
@@ -26,10 +26,10 @@
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.test.InstrumentationRegistry;
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.FileNotFoundException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
index eb3bd4f91a..774f1b452c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /** Abstract base {@link Player} which implements common implementation independent methods. */
@@ -135,4 +135,58 @@ private int getRepeatModeForNavigation() {
     @RepeatMode int repeatMode = getRepeatMode();
     return repeatMode == REPEAT_MODE_ONE ? REPEAT_MODE_OFF : repeatMode;
   }
+
+  /** Holds a listener reference. */
+  protected static final class ListenerHolder {
+
+    /**
+     * The listener on which {link #invoke} will execute {@link ListenerInvocation listener
+     * invocations}.
+     */
+    public final Player.EventListener listener;
+
+    private boolean released;
+
+    public ListenerHolder(Player.EventListener listener) {
+      this.listener = listener;
+    }
+
+    /** Prevents any further {@link ListenerInvocation} to be executed on {@link #listener}. */
+    public void release() {
+      released = true;
+    }
+
+    /**
+     * Executes the given {@link ListenerInvocation} on {@link #listener}. Does nothing if {@link
+     * #release} has been called on this instance.
+     */
+    public void invoke(ListenerInvocation listenerInvocation) {
+      if (!released) {
+        listenerInvocation.invokeListener(listener);
+      }
+    }
+
+    @Override
+    public boolean equals(@Nullable Object other) {
+      if (this == other) {
+        return true;
+      }
+      if (other == null || getClass() != other.getClass()) {
+        return false;
+      }
+      return listener.equals(((ListenerHolder) other).listener);
+    }
+
+    @Override
+    public int hashCode() {
+      return listener.hashCode();
+    }
+  }
+
+  /** Parameterized invocation of a {@link Player.EventListener} method. */
+  protected interface ListenerInvocation {
+
+    /** Executes the invocation on the given {@link Player.EventListener}. */
+    void invokeListener(Player.EventListener listener);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index 51e724bee1..1099b14bfc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -37,7 +37,7 @@
   private SampleStream stream;
   private Format[] streamFormats;
   private long streamOffsetUs;
-  private boolean readEndOfStream;
+  private long readingPositionUs;
   private boolean streamIsFinal;
 
   /**
@@ -46,7 +46,7 @@
    */
   public BaseRenderer(int trackType) {
     this.trackType = trackType;
-    readEndOfStream = true;
+    readingPositionUs = C.TIME_END_OF_SOURCE;
   }
 
   @Override
@@ -98,7 +98,7 @@ public final void replaceStream(Format[] formats, SampleStream stream, long offs
       throws ExoPlaybackException {
     Assertions.checkState(!streamIsFinal);
     this.stream = stream;
-    readEndOfStream = false;
+    readingPositionUs = offsetUs;
     streamFormats = formats;
     streamOffsetUs = offsetUs;
     onStreamChanged(formats, offsetUs);
@@ -111,7 +111,12 @@ public final SampleStream getStream() {
 
   @Override
   public final boolean hasReadStreamToEnd() {
-    return readEndOfStream;
+    return readingPositionUs == C.TIME_END_OF_SOURCE;
+  }
+
+  @Override
+  public final long getReadingPositionUs() {
+    return readingPositionUs;
   }
 
   @Override
@@ -132,7 +137,7 @@ public final void maybeThrowStreamError() throws IOException {
   @Override
   public final void resetPosition(long positionUs) throws ExoPlaybackException {
     streamIsFinal = false;
-    readEndOfStream = false;
+    readingPositionUs = positionUs;
     onPositionReset(positionUs, false);
   }
 
@@ -153,6 +158,12 @@ public final void disable() {
     onDisabled();
   }
 
+  @Override
+  public final void reset() {
+    Assertions.checkState(state == STATE_DISABLED);
+    onReset();
+  }
+
   // RendererCapabilities implementation.
 
   @Override
@@ -247,6 +258,15 @@ protected void onDisabled() {
     // Do nothing.
   }
 
+  /**
+   * Called when the renderer is reset.
+   *
+   * <p>The default implementation is a no-op.
+   */
+  protected void onReset() {
+    // Do nothing.
+  }
+
   // Methods to be called by subclasses.
 
   /** Returns the formats of the currently enabled stream. */
@@ -288,10 +308,11 @@ protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buf
     int result = stream.readData(formatHolder, buffer, formatRequired);
     if (result == C.RESULT_BUFFER_READ) {
       if (buffer.isEndOfStream()) {
-        readEndOfStream = true;
+        readingPositionUs = C.TIME_END_OF_SOURCE;
         return streamIsFinal ? C.RESULT_BUFFER_READ : C.RESULT_NOTHING_READ;
       }
       buffer.timeUs += streamOffsetUs;
+      readingPositionUs = Math.max(readingPositionUs, buffer.timeUs);
     } else if (result == C.RESULT_FORMAT_READ) {
       Format format = formatHolder.format;
       if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
@@ -317,7 +338,7 @@ protected int skipSource(long positionUs) {
    * Returns whether the upstream source is ready.
    */
   protected final boolean isSourceReady() {
-    return readEndOfStream ? streamIsFinal : stream.isReady();
+    return hasReadStreamToEnd() ? streamIsFinal : stream.isReady();
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index fac9818d9e..04a90b38d8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -21,7 +21,7 @@
 import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.media.MediaFormat;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.view.Surface;
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.audio.AuxEffectInfo;
@@ -101,6 +101,9 @@ private C() {}
    */
   public static final String UTF16_NAME = "UTF-16";
 
+  /** The name of the UTF-16 little-endian charset. */
+  public static final String UTF16LE_NAME = "UTF-16LE";
+
   /**
    * The name of the serif font family.
    */
@@ -143,8 +146,8 @@ private C() {}
    * {@link #ENCODING_INVALID}, {@link #ENCODING_PCM_8BIT}, {@link #ENCODING_PCM_16BIT}, {@link
    * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
    * #ENCODING_PCM_MU_LAW}, {@link #ENCODING_PCM_A_LAW}, {@link #ENCODING_AC3}, {@link
-   * #ENCODING_E_AC3}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or {@link
-   * #ENCODING_DOLBY_TRUEHD}.
+   * #ENCODING_E_AC3}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or
+   * {@link #ENCODING_DOLBY_TRUEHD}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -160,9 +163,10 @@ private C() {}
     ENCODING_PCM_A_LAW,
     ENCODING_AC3,
     ENCODING_E_AC3,
+    ENCODING_AC4,
     ENCODING_DTS,
     ENCODING_DTS_HD,
-    ENCODING_DOLBY_TRUEHD
+    ENCODING_DOLBY_TRUEHD,
   })
   public @interface Encoding {}
 
@@ -206,6 +210,8 @@ private C() {}
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
   /** @see AudioFormat#ENCODING_E_AC3 */
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+  /** @see AudioFormat#ENCODING_AC4 */
+  public static final int ENCODING_AC4 = AudioFormat.ENCODING_AC4;
   /** @see AudioFormat#ENCODING_DTS */
   public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
   /** @see AudioFormat#ENCODING_DTS_HD */
@@ -460,8 +466,8 @@ private C() {}
 
   /**
    * Flags which can apply to a buffer containing a media sample. Possible flag values are {@link
-   * #BUFFER_FLAG_KEY_FRAME}, {@link #BUFFER_FLAG_END_OF_STREAM}, {@link #BUFFER_FLAG_ENCRYPTED} and
-   * {@link #BUFFER_FLAG_DECODE_ONLY}.
+   * #BUFFER_FLAG_KEY_FRAME}, {@link #BUFFER_FLAG_END_OF_STREAM}, {@link #BUFFER_FLAG_LAST_SAMPLE},
+   * {@link #BUFFER_FLAG_ENCRYPTED} and {@link #BUFFER_FLAG_DECODE_ONLY}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -470,6 +476,7 @@ private C() {}
       value = {
         BUFFER_FLAG_KEY_FRAME,
         BUFFER_FLAG_END_OF_STREAM,
+        BUFFER_FLAG_LAST_SAMPLE,
         BUFFER_FLAG_ENCRYPTED,
         BUFFER_FLAG_DECODE_ONLY
       })
@@ -482,6 +489,8 @@ private C() {}
    * Flag for empty buffers that signal that the end of the stream was reached.
    */
   public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+  /** Indicates that a buffer is known to contain the last media sample of the stream. */
+  public static final int BUFFER_FLAG_LAST_SAMPLE = 1 << 29; // 0x20000000
   /** Indicates that a buffer is (at least partially) encrypted. */
   public static final int BUFFER_FLAG_ENCRYPTED = 1 << 30; // 0x40000000
   /** Indicates that a buffer should be decoded but not rendered. */
@@ -533,9 +542,7 @@ private C() {}
    */
   public static final int SELECTION_FLAG_AUTOSELECT = 1 << 2; // 4
 
-  /**
-   * Represents an undetermined language as an ISO 639 alpha-3 language code.
-   */
+  /** Represents an undetermined language as an ISO 639-2 language code. */
   public static final String LANGUAGE_UNDETERMINED = "und";
 
   /**
@@ -896,6 +903,26 @@ private C() {}
    */
   public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
 
+  /** Video projection types. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    Format.NO_VALUE,
+    PROJECTION_RECTANGULAR,
+    PROJECTION_EQUIRECTANGULAR,
+    PROJECTION_CUBEMAP,
+    PROJECTION_MESH
+  })
+  public @interface Projection {}
+  /** Conventional rectangular projection. */
+  public static final int PROJECTION_RECTANGULAR = 0;
+  /** Equirectangular spherical projection. */
+  public static final int PROJECTION_EQUIRECTANGULAR = 1;
+  /** Cube map projection. */
+  public static final int PROJECTION_CUBEMAP = 2;
+  /** 3-D mesh projection. */
+  public static final int PROJECTION_MESH = 3;
+
   /**
    * Priority for media playback.
    *
@@ -955,6 +982,79 @@ private C() {}
    */
   public static final int NETWORK_TYPE_OTHER = 8;
 
+  /**
+   * Track role flags. Possible flag values are {@link #ROLE_FLAG_MAIN}, {@link
+   * #ROLE_FLAG_ALTERNATE}, {@link #ROLE_FLAG_SUPPLEMENTARY}, {@link #ROLE_FLAG_COMMENTARY}, {@link
+   * #ROLE_FLAG_DUB}, {@link #ROLE_FLAG_EMERGENCY}, {@link #ROLE_FLAG_CAPTION}, {@link
+   * #ROLE_FLAG_SUBTITLE}, {@link #ROLE_FLAG_SIGN}, {@link #ROLE_FLAG_DESCRIBES_VIDEO}, {@link
+   * #ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND}, {@link #ROLE_FLAG_ENHANCED_DIALOG_INTELLIGIBILITY},
+   * {@link #ROLE_FLAG_TRANSCRIBES_DIALOG} and {@link #ROLE_FLAG_EASY_TO_READ}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(
+      flag = true,
+      value = {
+        ROLE_FLAG_MAIN,
+        ROLE_FLAG_ALTERNATE,
+        ROLE_FLAG_SUPPLEMENTARY,
+        ROLE_FLAG_COMMENTARY,
+        ROLE_FLAG_DUB,
+        ROLE_FLAG_EMERGENCY,
+        ROLE_FLAG_CAPTION,
+        ROLE_FLAG_SUBTITLE,
+        ROLE_FLAG_SIGN,
+        ROLE_FLAG_DESCRIBES_VIDEO,
+        ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND,
+        ROLE_FLAG_ENHANCED_DIALOG_INTELLIGIBILITY,
+        ROLE_FLAG_TRANSCRIBES_DIALOG,
+        ROLE_FLAG_EASY_TO_READ
+      })
+  public @interface RoleFlags {}
+  /** Indicates a main track. */
+  public static final int ROLE_FLAG_MAIN = 1;
+  /**
+   * Indicates an alternate track. For example a video track recorded from an different view point
+   * than the main track(s).
+   */
+  public static final int ROLE_FLAG_ALTERNATE = 1 << 1;
+  /**
+   * Indicates a supplementary track, meaning the track has lower importance than the main track(s).
+   * For example a video track that provides a visual accompaniment to a main audio track.
+   */
+  public static final int ROLE_FLAG_SUPPLEMENTARY = 1 << 2;
+  /** Indicates the track contains commentary, for example from the director. */
+  public static final int ROLE_FLAG_COMMENTARY = 1 << 3;
+  /**
+   * Indicates the track is in a different language from the original, for example dubbed audio or
+   * translated captions.
+   */
+  public static final int ROLE_FLAG_DUB = 1 << 4;
+  /** Indicates the track contains information about a current emergency. */
+  public static final int ROLE_FLAG_EMERGENCY = 1 << 5;
+  /**
+   * Indicates the track contains captions. This flag may be set on video tracks to indicate the
+   * presence of burned in captions.
+   */
+  public static final int ROLE_FLAG_CAPTION = 1 << 6;
+  /**
+   * Indicates the track contains subtitles. This flag may be set on video tracks to indicate the
+   * presence of burned in subtitles.
+   */
+  public static final int ROLE_FLAG_SUBTITLE = 1 << 7;
+  /** Indicates the track contains a visual sign-language interpretation of an audio track. */
+  public static final int ROLE_FLAG_SIGN = 1 << 8;
+  /** Indicates the track contains an audio or textual description of a video track. */
+  public static final int ROLE_FLAG_DESCRIBES_VIDEO = 1 << 9;
+  /** Indicates the track contains a textual description of music and sound. */
+  public static final int ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND = 1 << 10;
+  /** Indicates the track is designed for improved intelligibility of dialogue. */
+  public static final int ROLE_FLAG_ENHANCED_DIALOG_INTELLIGIBILITY = 1 << 11;
+  /** Indicates the track contains a transcription of spoken dialog. */
+  public static final int ROLE_FLAG_TRANSCRIBES_DIALOG = 1 << 12;
+  /** Indicates the track contains a text that has been edited for ease of reading. */
+  public static final int ROLE_FLAG_EASY_TO_READ = 1 << 13;
+
   /**
    * Converts a time in microseconds to the corresponding time in milliseconds, preserving
    * {@link #TIME_UNSET} and {@link #TIME_END_OF_SOURCE} values.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index c109ed81c1..972f651a41 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -30,12 +29,14 @@
 
   /**
    * The default minimum duration of media that the player will attempt to ensure is buffered at all
-   * times, in milliseconds.
+   * times, in milliseconds. This value is only applied to playbacks without video.
    */
   public static final int DEFAULT_MIN_BUFFER_MS = 15000;
 
   /**
    * The default maximum duration of media that the player will attempt to buffer, in milliseconds.
+   * For playbacks with video, this is also the default minimum duration of media that the player
+   * will attempt to ensure is buffered.
    */
   public static final int DEFAULT_MAX_BUFFER_MS = 50000;
 
@@ -70,27 +71,26 @@
   public static final class Builder {
 
     private DefaultAllocator allocator;
-    private int minBufferMs;
+    private int minBufferAudioMs;
+    private int minBufferVideoMs;
     private int maxBufferMs;
     private int bufferForPlaybackMs;
     private int bufferForPlaybackAfterRebufferMs;
     private int targetBufferBytes;
     private boolean prioritizeTimeOverSizeThresholds;
-    private PriorityTaskManager priorityTaskManager;
     private int backBufferDurationMs;
     private boolean retainBackBufferFromKeyframe;
     private boolean createDefaultLoadControlCalled;
 
     /** Constructs a new instance. */
     public Builder() {
-      allocator = null;
-      minBufferMs = DEFAULT_MIN_BUFFER_MS;
+      minBufferAudioMs = DEFAULT_MIN_BUFFER_MS;
+      minBufferVideoMs = DEFAULT_MAX_BUFFER_MS;
       maxBufferMs = DEFAULT_MAX_BUFFER_MS;
       bufferForPlaybackMs = DEFAULT_BUFFER_FOR_PLAYBACK_MS;
       bufferForPlaybackAfterRebufferMs = DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS;
       targetBufferBytes = DEFAULT_TARGET_BUFFER_BYTES;
       prioritizeTimeOverSizeThresholds = DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS;
-      priorityTaskManager = null;
       backBufferDurationMs = DEFAULT_BACK_BUFFER_DURATION_MS;
       retainBackBufferFromKeyframe = DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME;
     }
@@ -129,7 +129,18 @@ public Builder setBufferDurationsMs(
         int bufferForPlaybackMs,
         int bufferForPlaybackAfterRebufferMs) {
       Assertions.checkState(!createDefaultLoadControlCalled);
-      this.minBufferMs = minBufferMs;
+      assertGreaterOrEqual(bufferForPlaybackMs, 0, "bufferForPlaybackMs", "0");
+      assertGreaterOrEqual(
+          bufferForPlaybackAfterRebufferMs, 0, "bufferForPlaybackAfterRebufferMs", "0");
+      assertGreaterOrEqual(minBufferMs, bufferForPlaybackMs, "minBufferMs", "bufferForPlaybackMs");
+      assertGreaterOrEqual(
+          minBufferMs,
+          bufferForPlaybackAfterRebufferMs,
+          "minBufferMs",
+          "bufferForPlaybackAfterRebufferMs");
+      assertGreaterOrEqual(maxBufferMs, minBufferMs, "maxBufferMs", "minBufferMs");
+      this.minBufferAudioMs = minBufferMs;
+      this.minBufferVideoMs = minBufferMs;
       this.maxBufferMs = maxBufferMs;
       this.bufferForPlaybackMs = bufferForPlaybackMs;
       this.bufferForPlaybackAfterRebufferMs = bufferForPlaybackAfterRebufferMs;
@@ -165,19 +176,6 @@ public Builder setPrioritizeTimeOverSizeThresholds(boolean prioritizeTimeOverSiz
       return this;
     }
 
-    /**
-     * Sets the {@link PriorityTaskManager} to use.
-     *
-     * @param priorityTaskManager The {@link PriorityTaskManager} to use.
-     * @return This builder, for convenience.
-     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
-     */
-    public Builder setPriorityTaskManager(PriorityTaskManager priorityTaskManager) {
-      Assertions.checkState(!createDefaultLoadControlCalled);
-      this.priorityTaskManager = priorityTaskManager;
-      return this;
-    }
-
     /**
      * Sets the back buffer duration, and whether the back buffer is retained from the previous
      * keyframe.
@@ -190,6 +188,7 @@ public Builder setPriorityTaskManager(PriorityTaskManager priorityTaskManager) {
      */
     public Builder setBackBuffer(int backBufferDurationMs, boolean retainBackBufferFromKeyframe) {
       Assertions.checkState(!createDefaultLoadControlCalled);
+      assertGreaterOrEqual(backBufferDurationMs, 0, "backBufferDurationMs", "0");
       this.backBufferDurationMs = backBufferDurationMs;
       this.retainBackBufferFromKeyframe = retainBackBufferFromKeyframe;
       return this;
@@ -197,19 +196,20 @@ public Builder setBackBuffer(int backBufferDurationMs, boolean retainBackBufferF
 
     /** Creates a {@link DefaultLoadControl}. */
     public DefaultLoadControl createDefaultLoadControl() {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       createDefaultLoadControlCalled = true;
       if (allocator == null) {
-        allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
+        allocator = new DefaultAllocator(/* trimOnReset= */ true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
       }
       return new DefaultLoadControl(
           allocator,
-          minBufferMs,
+          minBufferAudioMs,
+          minBufferVideoMs,
           maxBufferMs,
           bufferForPlaybackMs,
           bufferForPlaybackAfterRebufferMs,
           targetBufferBytes,
           prioritizeTimeOverSizeThresholds,
-          priorityTaskManager,
           backBufferDurationMs,
           retainBackBufferFromKeyframe);
     }
@@ -217,18 +217,19 @@ public DefaultLoadControl createDefaultLoadControl() {
 
   private final DefaultAllocator allocator;
 
-  private final long minBufferUs;
+  private final long minBufferAudioUs;
+  private final long minBufferVideoUs;
   private final long maxBufferUs;
   private final long bufferForPlaybackUs;
   private final long bufferForPlaybackAfterRebufferUs;
   private final int targetBufferBytesOverwrite;
   private final boolean prioritizeTimeOverSizeThresholds;
-  private final PriorityTaskManager priorityTaskManager;
   private final long backBufferDurationUs;
   private final boolean retainBackBufferFromKeyframe;
 
   private int targetBufferSize;
   private boolean isBuffering;
+  private boolean hasVideo;
 
   /** Constructs a new instance, using the {@code DEFAULT_*} constants defined in this class. */
   @SuppressWarnings("deprecation")
@@ -238,21 +239,22 @@ public DefaultLoadControl() {
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
-  @SuppressWarnings("deprecation")
   public DefaultLoadControl(DefaultAllocator allocator) {
     this(
         allocator,
-        DEFAULT_MIN_BUFFER_MS,
+        /* minBufferAudioMs= */ DEFAULT_MIN_BUFFER_MS,
+        /* minBufferVideoMs= */ DEFAULT_MAX_BUFFER_MS,
         DEFAULT_MAX_BUFFER_MS,
         DEFAULT_BUFFER_FOR_PLAYBACK_MS,
         DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS,
         DEFAULT_TARGET_BUFFER_BYTES,
-        DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS);
+        DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS,
+        DEFAULT_BACK_BUFFER_DURATION_MS,
+        DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME);
   }
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
-  @SuppressWarnings("deprecation")
   public DefaultLoadControl(
       DefaultAllocator allocator,
       int minBufferMs,
@@ -263,70 +265,57 @@ public DefaultLoadControl(
       boolean prioritizeTimeOverSizeThresholds) {
     this(
         allocator,
-        minBufferMs,
-        maxBufferMs,
-        bufferForPlaybackMs,
-        bufferForPlaybackAfterRebufferMs,
-        targetBufferBytes,
-        prioritizeTimeOverSizeThresholds,
-        /* priorityTaskManager= */ null);
-  }
-
-  /** @deprecated Use {@link Builder} instead. */
-  @Deprecated
-  public DefaultLoadControl(
-      DefaultAllocator allocator,
-      int minBufferMs,
-      int maxBufferMs,
-      int bufferForPlaybackMs,
-      int bufferForPlaybackAfterRebufferMs,
-      int targetBufferBytes,
-      boolean prioritizeTimeOverSizeThresholds,
-      PriorityTaskManager priorityTaskManager) {
-    this(
-        allocator,
-        minBufferMs,
+        /* minBufferAudioMs= */ minBufferMs,
+        /* minBufferVideoMs= */ minBufferMs,
         maxBufferMs,
         bufferForPlaybackMs,
         bufferForPlaybackAfterRebufferMs,
         targetBufferBytes,
         prioritizeTimeOverSizeThresholds,
-        priorityTaskManager,
         DEFAULT_BACK_BUFFER_DURATION_MS,
         DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME);
   }
 
   protected DefaultLoadControl(
       DefaultAllocator allocator,
-      int minBufferMs,
+      int minBufferAudioMs,
+      int minBufferVideoMs,
       int maxBufferMs,
       int bufferForPlaybackMs,
       int bufferForPlaybackAfterRebufferMs,
       int targetBufferBytes,
       boolean prioritizeTimeOverSizeThresholds,
-      PriorityTaskManager priorityTaskManager,
       int backBufferDurationMs,
       boolean retainBackBufferFromKeyframe) {
     assertGreaterOrEqual(bufferForPlaybackMs, 0, "bufferForPlaybackMs", "0");
     assertGreaterOrEqual(
         bufferForPlaybackAfterRebufferMs, 0, "bufferForPlaybackAfterRebufferMs", "0");
-    assertGreaterOrEqual(minBufferMs, bufferForPlaybackMs, "minBufferMs", "bufferForPlaybackMs");
     assertGreaterOrEqual(
-        minBufferMs,
+        minBufferAudioMs, bufferForPlaybackMs, "minBufferAudioMs", "bufferForPlaybackMs");
+    assertGreaterOrEqual(
+        minBufferVideoMs, bufferForPlaybackMs, "minBufferVideoMs", "bufferForPlaybackMs");
+    assertGreaterOrEqual(
+        minBufferAudioMs,
+        bufferForPlaybackAfterRebufferMs,
+        "minBufferAudioMs",
+        "bufferForPlaybackAfterRebufferMs");
+    assertGreaterOrEqual(
+        minBufferVideoMs,
         bufferForPlaybackAfterRebufferMs,
-        "minBufferMs",
+        "minBufferVideoMs",
         "bufferForPlaybackAfterRebufferMs");
-    assertGreaterOrEqual(maxBufferMs, minBufferMs, "maxBufferMs", "minBufferMs");
+    assertGreaterOrEqual(maxBufferMs, minBufferAudioMs, "maxBufferMs", "minBufferAudioMs");
+    assertGreaterOrEqual(maxBufferMs, minBufferVideoMs, "maxBufferMs", "minBufferVideoMs");
     assertGreaterOrEqual(backBufferDurationMs, 0, "backBufferDurationMs", "0");
 
     this.allocator = allocator;
-    this.minBufferUs = C.msToUs(minBufferMs);
+    this.minBufferAudioUs = C.msToUs(minBufferAudioMs);
+    this.minBufferVideoUs = C.msToUs(minBufferVideoMs);
     this.maxBufferUs = C.msToUs(maxBufferMs);
     this.bufferForPlaybackUs = C.msToUs(bufferForPlaybackMs);
     this.bufferForPlaybackAfterRebufferUs = C.msToUs(bufferForPlaybackAfterRebufferMs);
     this.targetBufferBytesOverwrite = targetBufferBytes;
     this.prioritizeTimeOverSizeThresholds = prioritizeTimeOverSizeThresholds;
-    this.priorityTaskManager = priorityTaskManager;
     this.backBufferDurationUs = C.msToUs(backBufferDurationMs);
     this.retainBackBufferFromKeyframe = retainBackBufferFromKeyframe;
   }
@@ -339,6 +328,7 @@ public void onPrepared() {
   @Override
   public void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
       TrackSelectionArray trackSelections) {
+    hasVideo = hasVideo(renderers, trackSelections);
     targetBufferSize =
         targetBufferBytesOverwrite == C.LENGTH_UNSET
             ? calculateTargetBufferSize(renderers, trackSelections)
@@ -374,8 +364,7 @@ public boolean retainBackBufferFromKeyframe() {
   @Override
   public boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpeed) {
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
-    boolean wasBuffering = isBuffering;
-    long minBufferUs = this.minBufferUs;
+    long minBufferUs = hasVideo ? minBufferVideoUs : minBufferAudioUs;
     if (playbackSpeed > 1) {
       // The playback speed is faster than real time, so scale up the minimum required media
       // duration to keep enough media buffered for a playout duration of minBufferUs.
@@ -388,13 +377,6 @@ public boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpee
     } else if (bufferedDurationUs >= maxBufferUs || targetBufferSizeReached) {
       isBuffering = false;
     } // Else don't change the buffering state
-    if (priorityTaskManager != null && isBuffering != wasBuffering) {
-      if (isBuffering) {
-        priorityTaskManager.add(C.PRIORITY_PLAYBACK);
-      } else {
-        priorityTaskManager.remove(C.PRIORITY_PLAYBACK);
-      }
-    }
     return isBuffering;
   }
 
@@ -430,15 +412,21 @@ protected int calculateTargetBufferSize(
 
   private void reset(boolean resetAllocator) {
     targetBufferSize = 0;
-    if (priorityTaskManager != null && isBuffering) {
-      priorityTaskManager.remove(C.PRIORITY_PLAYBACK);
-    }
     isBuffering = false;
     if (resetAllocator) {
       allocator.reset();
     }
   }
 
+  private static boolean hasVideo(Renderer[] renderers, TrackSelectionArray trackSelectionArray) {
+    for (int i = 0; i < renderers.length; i++) {
+      if (renderers[i].getTrackType() == C.TRACK_TYPE_VIDEO && trackSelectionArray.get(i) != null) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   private static void assertGreaterOrEqual(int value1, int value2, String name1, String name2) {
     Assertions.checkArgument(value1 >= value2, name1 + " cannot be less than " + name2);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
index ed57cec70c..89e7d857c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.StandaloneMediaClock;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index cc16c43b05..2a977f5bba 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -16,10 +16,11 @@
 package com.google.android.exoplayer2;
 
 import android.content.Context;
+import android.media.MediaCodec;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
@@ -85,15 +86,18 @@
   protected static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
 
   private final Context context;
-  private final @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
-  private final @ExtensionRendererMode int extensionRendererMode;
-  private final long allowedVideoJoiningTimeMs;
+  @Nullable private DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
+  @ExtensionRendererMode private int extensionRendererMode;
+  private long allowedVideoJoiningTimeMs;
+  private boolean playClearSamplesWithoutKeys;
+  private MediaCodecSelector mediaCodecSelector;
 
-  /**
-   * @param context A {@link Context}.
-   */
+  /** @param context A {@link Context}. */
   public DefaultRenderersFactory(Context context) {
-    this(context, EXTENSION_RENDERER_MODE_OFF);
+    this.context = context;
+    extensionRendererMode = EXTENSION_RENDERER_MODE_OFF;
+    allowedVideoJoiningTimeMs = DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS;
+    mediaCodecSelector = MediaCodecSelector.DEFAULT;
   }
 
   /**
@@ -108,19 +112,20 @@ public DefaultRenderersFactory(
   }
 
   /**
-   * @param context A {@link Context}.
-   * @param extensionRendererMode The extension renderer mode, which determines if and how available
-   *     extension renderers are used. Note that extensions must be included in the application
-   *     build for them to be considered available.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)} and {@link
+   *     #setExtensionRendererMode(int)}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultRenderersFactory(
       Context context, @ExtensionRendererMode int extensionRendererMode) {
     this(context, extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
   }
 
   /**
-   * @deprecated Use {@link #DefaultRenderersFactory(Context, int)} and pass {@link
-   *     DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)} and {@link
+   *     #setExtensionRendererMode(int)}, and pass {@link DrmSessionManager} directly to {@link
+   *     SimpleExoPlayer} or {@link ExoPlayerFactory}.
    */
   @Deprecated
   @SuppressWarnings("deprecation")
@@ -132,26 +137,22 @@ public DefaultRenderersFactory(
   }
 
   /**
-   * @param context A {@link Context}.
-   * @param extensionRendererMode The extension renderer mode, which determines if and how available
-   *     extension renderers are used. Note that extensions must be included in the application
-   *     build for them to be considered available.
-   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
-   *     seamlessly join an ongoing playback.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)}, {@link
+   *     #setExtensionRendererMode(int)} and {@link #setAllowedVideoJoiningTimeMs(long)}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultRenderersFactory(
       Context context,
       @ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
-    this.context = context;
-    this.extensionRendererMode = extensionRendererMode;
-    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
-    this.drmSessionManager = null;
+    this(context, null, extensionRendererMode, allowedVideoJoiningTimeMs);
   }
 
   /**
-   * @deprecated Use {@link #DefaultRenderersFactory(Context, int, long)} and pass {@link
-   *     DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)}, {@link
+   *     #setExtensionRendererMode(int)} and {@link #setAllowedVideoJoiningTimeMs(long)}, and pass
+   *     {@link DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
    */
   @Deprecated
   public DefaultRenderersFactory(
@@ -163,6 +164,70 @@ public DefaultRenderersFactory(
     this.extensionRendererMode = extensionRendererMode;
     this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
     this.drmSessionManager = drmSessionManager;
+    mediaCodecSelector = MediaCodecSelector.DEFAULT;
+  }
+
+  /**
+   * Sets the extension renderer mode, which determines if and how available extension renderers are
+   * used. Note that extensions must be included in the application build for them to be considered
+   * available.
+   *
+   * <p>The default value is {@link #EXTENSION_RENDERER_MODE_OFF}.
+   *
+   * @param extensionRendererMode The extension renderer mode.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setExtensionRendererMode(
+      @ExtensionRendererMode int extensionRendererMode) {
+    this.extensionRendererMode = extensionRendererMode;
+    return this;
+  }
+
+  /**
+   * Sets whether renderers are permitted to play clear regions of encrypted media prior to having
+   * obtained the keys necessary to decrypt encrypted regions of the media. For encrypted media that
+   * starts with a short clear region, this allows playback to begin in parallel with key
+   * acquisition, which can reduce startup latency.
+   *
+   * <p>The default value is {@code false}.
+   *
+   * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
+   *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
+   *     the media.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setPlayClearSamplesWithoutKeys(
+      boolean playClearSamplesWithoutKeys) {
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    return this;
+  }
+
+  /**
+   * Sets a {@link MediaCodecSelector} for use by {@link MediaCodec} based renderers.
+   *
+   * <p>The default value is {@link MediaCodecSelector#DEFAULT}.
+   *
+   * @param mediaCodecSelector The {@link MediaCodecSelector}.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setMediaCodecSelector(MediaCodecSelector mediaCodecSelector) {
+    this.mediaCodecSelector = mediaCodecSelector;
+    return this;
+  }
+
+  /**
+   * Sets the maximum duration for which video renderers can attempt to seamlessly join an ongoing
+   * playback.
+   *
+   * <p>The default value is {@link #DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS}.
+   *
+   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
+   *     seamlessly join an ongoing playback, in milliseconds.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoiningTimeMs) {
+    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
+    return this;
   }
 
   @Override
@@ -177,44 +242,69 @@ public DefaultRenderersFactory(
       drmSessionManager = this.drmSessionManager;
     }
     ArrayList<Renderer> renderersList = new ArrayList<>();
-    buildVideoRenderers(context, drmSessionManager, allowedVideoJoiningTimeMs,
-        eventHandler, videoRendererEventListener, extensionRendererMode, renderersList);
-    buildAudioRenderers(context, drmSessionManager, buildAudioProcessors(),
-        eventHandler, audioRendererEventListener, extensionRendererMode, renderersList);
+    buildVideoRenderers(
+        context,
+        extensionRendererMode,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        eventHandler,
+        videoRendererEventListener,
+        allowedVideoJoiningTimeMs,
+        renderersList);
+    buildAudioRenderers(
+        context,
+        extensionRendererMode,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        buildAudioProcessors(),
+        eventHandler,
+        audioRendererEventListener,
+        renderersList);
     buildTextRenderers(context, textRendererOutput, eventHandler.getLooper(),
         extensionRendererMode, renderersList);
     buildMetadataRenderers(context, metadataRendererOutput, eventHandler.getLooper(),
         extensionRendererMode, renderersList);
     buildCameraMotionRenderers(context, extensionRendererMode, renderersList);
     buildMiscellaneousRenderers(context, eventHandler, extensionRendererMode, renderersList);
-    return renderersList.toArray(new Renderer[renderersList.size()]);
+    return renderersList.toArray(new Renderer[0]);
   }
 
   /**
    * Builds video renderers for use by the player.
    *
    * @param context The {@link Context} associated with the player.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player
-   *     will not be used for DRM protected playbacks.
-   * @param allowedVideoJoiningTimeMs The maximum duration in milliseconds for which video
-   *     renderers can attempt to seamlessly join an ongoing playback.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+   *     not be used for DRM protected playbacks.
+   * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
+   *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
+   *     the media.
    * @param eventHandler A handler associated with the main thread's looper.
    * @param eventListener An event listener.
-   * @param extensionRendererMode The extension renderer mode.
+   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
+   *     seamlessly join an ongoing playback, in milliseconds.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildVideoRenderers(Context context,
+  protected void buildVideoRenderers(
+      Context context,
+      @ExtensionRendererMode int extensionRendererMode,
+      MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      long allowedVideoJoiningTimeMs, Handler eventHandler,
-      VideoRendererEventListener eventListener, @ExtensionRendererMode int extensionRendererMode,
+      boolean playClearSamplesWithoutKeys,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
+      long allowedVideoJoiningTimeMs,
       ArrayList<Renderer> out) {
     out.add(
         new MediaCodecVideoRenderer(
             context,
-            MediaCodecSelector.DEFAULT,
+            mediaCodecSelector,
             allowedVideoJoiningTimeMs,
             drmSessionManager,
-            /* playClearSamplesWithoutKeys= */ false,
+            playClearSamplesWithoutKeys,
             eventHandler,
             eventListener,
             MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
@@ -233,7 +323,6 @@ protected void buildVideoRenderers(Context context,
       Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
       Constructor<?> constructor =
           clazz.getConstructor(
-              boolean.class,
               long.class,
               android.os.Handler.class,
               com.google.android.exoplayer2.video.VideoRendererEventListener.class,
@@ -242,7 +331,6 @@ protected void buildVideoRenderers(Context context,
       Renderer renderer =
           (Renderer)
               constructor.newInstance(
-                  true,
                   allowedVideoJoiningTimeMs,
                   eventHandler,
                   eventListener,
@@ -261,26 +349,35 @@ protected void buildVideoRenderers(Context context,
    * Builds audio renderers for use by the player.
    *
    * @param context The {@link Context} associated with the player.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player
-   *     will not be used for DRM protected playbacks.
-   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio
-   *     buffers before output. May be empty.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+   *     not be used for DRM protected playbacks.
+   * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
+   *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
+   *     the media.
+   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
+   *     before output. May be empty.
    * @param eventHandler A handler to use when invoking event listeners and outputs.
    * @param eventListener An event listener.
-   * @param extensionRendererMode The extension renderer mode.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildAudioRenderers(Context context,
+  protected void buildAudioRenderers(
+      Context context,
+      @ExtensionRendererMode int extensionRendererMode,
+      MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      AudioProcessor[] audioProcessors, Handler eventHandler,
-      AudioRendererEventListener eventListener, @ExtensionRendererMode int extensionRendererMode,
+      boolean playClearSamplesWithoutKeys,
+      AudioProcessor[] audioProcessors,
+      Handler eventHandler,
+      AudioRendererEventListener eventListener,
       ArrayList<Renderer> out) {
     out.add(
         new MediaCodecAudioRenderer(
             context,
-            MediaCodecSelector.DEFAULT,
+            mediaCodecSelector,
             drmSessionManager,
-            /* playClearSamplesWithoutKeys= */ false,
+            playClearSamplesWithoutKeys,
             eventHandler,
             eventListener,
             AudioCapabilities.getCapabilities(context),
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
index 6b84245141..b5f8f954bb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -30,11 +31,12 @@
 
   /**
    * The type of source that produced the error. One of {@link #TYPE_SOURCE}, {@link #TYPE_RENDERER}
-   * or {@link #TYPE_UNEXPECTED}.
+   * {@link #TYPE_UNEXPECTED}, {@link #TYPE_REMOTE} or {@link #TYPE_OUT_OF_MEMORY}. Note that new
+   * types may be added in the future and error handling should handle unknown type values.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TYPE_SOURCE, TYPE_RENDERER, TYPE_UNEXPECTED})
+  @IntDef({TYPE_SOURCE, TYPE_RENDERER, TYPE_UNEXPECTED, TYPE_REMOTE, TYPE_OUT_OF_MEMORY})
   public @interface Type {}
   /**
    * The error occurred loading data from a {@link MediaSource}.
@@ -54,11 +56,16 @@
    * Call {@link #getUnexpectedException()} to retrieve the underlying cause.
    */
   public static final int TYPE_UNEXPECTED = 2;
-
   /**
-   * The type of the playback failure. One of {@link #TYPE_SOURCE}, {@link #TYPE_RENDERER} and
-   * {@link #TYPE_UNEXPECTED}.
+   * The error occurred in a remote component.
+   *
+   * <p>Call {@link #getMessage()} to retrieve the message associated with the error.
    */
+  public static final int TYPE_REMOTE = 3;
+  /** The error was an {@link OutOfMemoryError}. */
+  public static final int TYPE_OUT_OF_MEMORY = 4;
+
+  /** The {@link Type} of the playback failure. */
   @Type public final int type;
 
   /**
@@ -66,7 +73,7 @@
    */
   public final int rendererIndex;
 
-  private final Throwable cause;
+  @Nullable private final Throwable cause;
 
   /**
    * Creates an instance of type {@link #TYPE_SOURCE}.
@@ -75,7 +82,7 @@
    * @return The created instance.
    */
   public static ExoPlaybackException createForSource(IOException cause) {
-    return new ExoPlaybackException(TYPE_SOURCE, cause, C.INDEX_UNSET);
+    return new ExoPlaybackException(TYPE_SOURCE, cause, /* rendererIndex= */ C.INDEX_UNSET);
   }
 
   /**
@@ -95,8 +102,28 @@ public static ExoPlaybackException createForRenderer(Exception cause, int render
    * @param cause The cause of the failure.
    * @return The created instance.
    */
-  /* package */ static ExoPlaybackException createForUnexpected(RuntimeException cause) {
-    return new ExoPlaybackException(TYPE_UNEXPECTED, cause, C.INDEX_UNSET);
+  public static ExoPlaybackException createForUnexpected(RuntimeException cause) {
+    return new ExoPlaybackException(TYPE_UNEXPECTED, cause, /* rendererIndex= */ C.INDEX_UNSET);
+  }
+
+  /**
+   * Creates an instance of type {@link #TYPE_REMOTE}.
+   *
+   * @param message The message associated with the error.
+   * @return The created instance.
+   */
+  public static ExoPlaybackException createForRemote(String message) {
+    return new ExoPlaybackException(TYPE_REMOTE, message);
+  }
+
+  /**
+   * Creates an instance of type {@link #TYPE_OUT_OF_MEMORY}.
+   *
+   * @param cause The cause of the failure.
+   * @return The created instance.
+   */
+  public static ExoPlaybackException createForOutOfMemoryError(OutOfMemoryError cause) {
+    return new ExoPlaybackException(TYPE_OUT_OF_MEMORY, cause, /* rendererIndex= */ C.INDEX_UNSET);
   }
 
   private ExoPlaybackException(@Type int type, Throwable cause, int rendererIndex) {
@@ -106,6 +133,13 @@ private ExoPlaybackException(@Type int type, Throwable cause, int rendererIndex)
     this.rendererIndex = rendererIndex;
   }
 
+  private ExoPlaybackException(@Type int type, String message) {
+    super(message);
+    this.type = type;
+    rendererIndex = C.INDEX_UNSET;
+    cause = null;
+  }
+
   /**
    * Retrieves the underlying error when {@link #type} is {@link #TYPE_SOURCE}.
    *
@@ -113,7 +147,7 @@ private ExoPlaybackException(@Type int type, Throwable cause, int rendererIndex)
    */
   public IOException getSourceException() {
     Assertions.checkState(type == TYPE_SOURCE);
-    return (IOException) cause;
+    return (IOException) Assertions.checkNotNull(cause);
   }
 
   /**
@@ -123,7 +157,7 @@ public IOException getSourceException() {
    */
   public Exception getRendererException() {
     Assertions.checkState(type == TYPE_RENDERER);
-    return (Exception) cause;
+    return (Exception) Assertions.checkNotNull(cause);
   }
 
   /**
@@ -133,7 +167,16 @@ public Exception getRendererException() {
    */
   public RuntimeException getUnexpectedException() {
     Assertions.checkState(type == TYPE_UNEXPECTED);
-    return (RuntimeException) cause;
+    return (RuntimeException) Assertions.checkNotNull(cause);
   }
 
+  /**
+   * Retrieves the underlying error when {@link #type} is {@link #TYPE_OUT_OF_MEMORY}.
+   *
+   * @throws IllegalStateException If {@link #type} is not {@link #TYPE_OUT_OF_MEMORY}.
+   */
+  public OutOfMemoryError getOutOfMemoryError() {
+    Assertions.checkState(type == TYPE_OUT_OF_MEMORY);
+    return (OutOfMemoryError) Assertions.checkNotNull(cause);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 0e8c176486..d0f9e2ae04 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -16,15 +16,15 @@
 package com.google.android.exoplayer2;
 
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.LoopingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MergingMediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.source.SingleSampleMediaSource;
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
@@ -48,7 +48,7 @@
  *   <li>A <b>{@link MediaSource}</b> that defines the media to be played, loads the media, and from
  *       which the loaded media can be read. A MediaSource is injected via {@link
  *       #prepare(MediaSource)} at the start of playback. The library modules provide default
- *       implementations for regular media files ({@link ExtractorMediaSource}), DASH
+ *       implementations for progressive media files ({@link ProgressiveMediaSource}), DASH
  *       (DashMediaSource), SmoothStreaming (SsMediaSource) and HLS (HlsMediaSource), an
  *       implementation for loading single media samples ({@link SingleSampleMediaSource}) that's
  *       most often used for side-loaded subtitle files, and implementations for building more
@@ -117,12 +117,6 @@
  */
 public interface ExoPlayer extends Player {
 
-  /**
-   * @deprecated Use {@link Player.EventListener} instead.
-   */
-  @Deprecated
-  interface EventListener extends Player.EventListener {}
-
   /** @deprecated Use {@link PlayerMessage.Target} instead. */
   @Deprecated
   interface ExoPlayerComponent extends PlayerMessage.Target {}
@@ -147,43 +141,6 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
     }
   }
 
-  /**
-   * @deprecated Use {@link Player#STATE_IDLE} instead.
-   */
-  @Deprecated
-  int STATE_IDLE = Player.STATE_IDLE;
-  /**
-   * @deprecated Use {@link Player#STATE_BUFFERING} instead.
-   */
-  @Deprecated
-  int STATE_BUFFERING = Player.STATE_BUFFERING;
-  /**
-   * @deprecated Use {@link Player#STATE_READY} instead.
-   */
-  @Deprecated
-  int STATE_READY = Player.STATE_READY;
-  /**
-   * @deprecated Use {@link Player#STATE_ENDED} instead.
-   */
-  @Deprecated
-  int STATE_ENDED = Player.STATE_ENDED;
-
-  /**
-   * @deprecated Use {@link Player#REPEAT_MODE_OFF} instead.
-   */
-  @Deprecated
-  @RepeatMode int REPEAT_MODE_OFF = Player.REPEAT_MODE_OFF;
-  /**
-   * @deprecated Use {@link Player#REPEAT_MODE_ONE} instead.
-   */
-  @Deprecated
-  @RepeatMode int REPEAT_MODE_ONE = Player.REPEAT_MODE_ONE;
-  /**
-   * @deprecated Use {@link Player#REPEAT_MODE_ALL} instead.
-   */
-  @Deprecated
-  @RepeatMode int REPEAT_MODE_ALL = Player.REPEAT_MODE_ALL;
-
   /** Returns the {@link Looper} associated with the playback thread. */
   Looper getPlaybackLooper();
 
@@ -196,18 +153,12 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
   /**
    * Prepares the player to play the provided {@link MediaSource}. Equivalent to
    * {@code prepare(mediaSource, true, true)}.
-   * <p>
-   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to prepare a
-   * player more than once with the same piece of media, use a new instance each time.
    */
   void prepare(MediaSource mediaSource);
 
   /**
    * Prepares the player to play the provided {@link MediaSource}, optionally resetting the playback
    * position the default position in the first {@link Timeline.Window}.
-   * <p>
-   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to prepare a
-   * player more than once with the same piece of media, use a new instance each time.
    *
    * @param mediaSource The {@link MediaSource} to play.
    * @param resetPosition Whether the playback position should be reset to the default position in
@@ -252,4 +203,34 @@ public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object mes
 
   /** Returns the currently active {@link SeekParameters} of the player. */
   SeekParameters getSeekParameters();
+
+  /**
+   * Sets whether the player is allowed to keep holding limited resources such as video decoders,
+   * even when in the idle state. By doing so, the player may be able to reduce latency when
+   * starting to play another piece of content for which the same resources are required.
+   *
+   * <p>This mode should be used with caution, since holding limited resources may prevent other
+   * players of media components from acquiring them. It should only be enabled when <em>both</em>
+   * of the following conditions are true:
+   *
+   * <ul>
+   *   <li>The application that owns the player is in the foreground.
+   *   <li>The player is used in a way that may benefit from foreground mode. For this to be true,
+   *       the same player instance must be used to play multiple pieces of content, and there must
+   *       be gaps between the playbacks (i.e. {@link #stop} is called to halt one playback, and
+   *       {@link #prepare} is called some time later to start a new one).
+   * </ul>
+   *
+   * <p>Note that foreground mode is <em>not</em> useful for switching between content without gaps
+   * between the playbacks. For this use case {@link #stop} does not need to be called, and simply
+   * calling {@link #prepare} for the new media will cause limited resources to be retained even if
+   * foreground mode is not enabled.
+   *
+   * <p>If foreground mode is enabled, it's the application's responsibility to disable it when the
+   * conditions described above no longer hold.
+   *
+   * @param foregroundMode Whether the player is allowed to keep limited resources even when in the
+   *     idle state.
+   */
+  void setForegroundMode(boolean foregroundMode);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 81f4285a08..59647feaa9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -17,9 +17,8 @@
 
 import android.content.Context;
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
-import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
@@ -38,44 +37,6 @@
 
   private ExoPlayerFactory() {}
 
-  /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
-   *     LoadControl)}.
-   */
-  @Deprecated
-  public static SimpleExoPlayer newSimpleInstance(
-      Context context, TrackSelector trackSelector, LoadControl loadControl) {
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
-    return newSimpleInstance(context, renderersFactory, trackSelector, loadControl);
-  }
-
-  /**
-   * Creates a {@link SimpleExoPlayer} instance. Available extension renderers are not used.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
-   *     LoadControl)}.
-   */
-  @Deprecated
-  public static SimpleExoPlayer newSimpleInstance(
-      Context context,
-      TrackSelector trackSelector,
-      LoadControl loadControl,
-      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
-    return newSimpleInstance(
-        context, renderersFactory, trackSelector, loadControl, drmSessionManager);
-  }
-
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
@@ -88,7 +49,7 @@ public static SimpleExoPlayer newSimpleInstance(
    *     extension renderers are used. Note that extensions must be included in the application
    *     build for them to be considered available.
    * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
-   *     LoadControl)}.
+   *     LoadControl, DrmSessionManager)}.
    */
   @Deprecated
   public static SimpleExoPlayer newSimpleInstance(
@@ -97,7 +58,8 @@ public static SimpleExoPlayer newSimpleInstance(
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode) {
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(context, extensionRendererMode);
+    RenderersFactory renderersFactory =
+        new DefaultRenderersFactory(context).setExtensionRendererMode(extensionRendererMode);
     return newSimpleInstance(
         context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
@@ -116,7 +78,7 @@ public static SimpleExoPlayer newSimpleInstance(
    * @param allowedVideoJoiningTimeMs The maximum duration for which a video renderer can attempt to
    *     seamlessly join an ongoing playback.
    * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
-   *     LoadControl)}.
+   *     LoadControl, DrmSessionManager)}.
    */
   @Deprecated
   public static SimpleExoPlayer newSimpleInstance(
@@ -127,7 +89,9 @@ public static SimpleExoPlayer newSimpleInstance(
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
     RenderersFactory renderersFactory =
-        new DefaultRenderersFactory(context, extensionRendererMode, allowedVideoJoiningTimeMs);
+        new DefaultRenderersFactory(context)
+            .setExtensionRendererMode(extensionRendererMode)
+            .setAllowedVideoJoiningTimeMs(allowedVideoJoiningTimeMs);
     return newSimpleInstance(
         context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
@@ -154,30 +118,45 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector)}. The use
-   *     of {@link SimpleExoPlayer#setAudioAttributes(AudioAttributes, boolean)} to manage audio
-   *     focus will be unavailable for the {@link SimpleExoPlayer} returned by this method.
    */
-  @Deprecated
-  @SuppressWarnings("nullness:argument.type.incompatible")
   public static SimpleExoPlayer newSimpleInstance(
-      RenderersFactory renderersFactory, TrackSelector trackSelector) {
-    return newSimpleInstance(
-        /* context= */ null, renderersFactory, trackSelector, new DefaultLoadControl());
+      Context context, RenderersFactory renderersFactory, TrackSelector trackSelector) {
+    return newSimpleInstance(context, renderersFactory, trackSelector, new DefaultLoadControl());
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance.
    *
    * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
   public static SimpleExoPlayer newSimpleInstance(
-      Context context, RenderersFactory renderersFactory, TrackSelector trackSelector) {
-    return newSimpleInstance(context, renderersFactory, trackSelector, new DefaultLoadControl());
+      Context context, TrackSelector trackSelector, LoadControl loadControl) {
+    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
+    return newSimpleInstance(context, renderersFactory, trackSelector, loadControl);
+  }
+
+  /**
+   * Creates a {@link SimpleExoPlayer} instance. Available extension renderers are not used.
+   *
+   * @param context A {@link Context}.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   */
+  public static SimpleExoPlayer newSimpleInstance(
+      Context context,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
+    return newSimpleInstance(
+        context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
 
   /**
@@ -355,7 +334,7 @@ public static SimpleExoPlayer newSimpleInstance(
         trackSelector,
         loadControl,
         drmSessionManager,
-        getDefaultBandwidthMeter(),
+        getDefaultBandwidthMeter(context),
         analyticsCollectorFactory,
         looper);
   }
@@ -397,28 +376,32 @@ public static SimpleExoPlayer newSimpleInstance(
   /**
    * Creates an {@link ExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    */
-  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector) {
-    return newInstance(renderers, trackSelector, new DefaultLoadControl());
+  public static ExoPlayer newInstance(
+      Context context, Renderer[] renderers, TrackSelector trackSelector) {
+    return newInstance(context, renderers, trackSelector, new DefaultLoadControl());
   }
 
   /**
    * Creates an {@link ExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
-  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
-      LoadControl loadControl) {
-    return newInstance(renderers, trackSelector, loadControl, Util.getLooper());
+  public static ExoPlayer newInstance(
+      Context context, Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl) {
+    return newInstance(context, renderers, trackSelector, loadControl, Util.getLooper());
   }
 
   /**
    * Creates an {@link ExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
@@ -426,13 +409,19 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSel
    *     used to call listeners on.
    */
   public static ExoPlayer newInstance(
-      Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl, Looper looper) {
-    return newInstance(renderers, trackSelector, loadControl, getDefaultBandwidthMeter(), looper);
+      Context context,
+      Renderer[] renderers,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      Looper looper) {
+    return newInstance(
+        context, renderers, trackSelector, loadControl, getDefaultBandwidthMeter(context), looper);
   }
 
   /**
    * Creates an {@link ExoPlayer} instance.
    *
+   * @param context A {@link Context}.
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
@@ -440,7 +429,9 @@ public static ExoPlayer newInstance(
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
    *     used to call listeners on.
    */
+  @SuppressWarnings("unused")
   public static ExoPlayer newInstance(
+      Context context,
       Renderer[] renderers,
       TrackSelector trackSelector,
       LoadControl loadControl,
@@ -450,9 +441,9 @@ public static ExoPlayer newInstance(
         renderers, trackSelector, loadControl, bandwidthMeter, Clock.DEFAULT, looper);
   }
 
-  private static synchronized BandwidthMeter getDefaultBandwidthMeter() {
+  private static synchronized BandwidthMeter getDefaultBandwidthMeter(Context context) {
     if (singletonBandwidthMeter == null) {
-      singletonBandwidthMeter = new DefaultBandwidthMeter.Builder().build();
+      singletonBandwidthMeter = new DefaultBandwidthMeter.Builder(context).build();
     }
     return singletonBandwidthMeter;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 35fa85e467..15deb8ea47 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -19,7 +19,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -37,8 +37,7 @@
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /** An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}. */
 /* package */ final class ExoPlayerImpl extends BasePlayer implements ExoPlayer {
@@ -49,7 +48,8 @@
    * This empty track selector result can only be used for {@link PlaybackInfo#trackSelectorResult}
    * when the player does not have any track selection made (such as when player is reset, or when
    * player seeks to an unprepared period). It will not be used as result of any {@link
-   * TrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)} operation.
+   * TrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray, MediaPeriodId, Timeline)}
+   * operation.
    */
   /* package */ final TrackSelectorResult emptyTrackSelectorResult;
 
@@ -58,9 +58,9 @@
   private final Handler eventHandler;
   private final ExoPlayerImplInternal internalPlayer;
   private final Handler internalPlayerHandler;
-  private final CopyOnWriteArraySet<Player.EventListener> listeners;
+  private final CopyOnWriteArrayList<ListenerHolder> listeners;
   private final Timeline.Period period;
-  private final ArrayDeque<PlaybackInfoUpdate> pendingPlaybackInfoUpdates;
+  private final ArrayDeque<Runnable> pendingListenerNotifications;
 
   private MediaSource mediaSource;
   private boolean playWhenReady;
@@ -70,6 +70,7 @@
   private int pendingOperationAcks;
   private boolean hasPendingPrepare;
   private boolean hasPendingSeek;
+  private boolean foregroundMode;
   private PlaybackParameters playbackParameters;
   private SeekParameters seekParameters;
   private @Nullable ExoPlaybackException playbackError;
@@ -109,7 +110,7 @@ public ExoPlayerImpl(
     this.playWhenReady = false;
     this.repeatMode = Player.REPEAT_MODE_OFF;
     this.shuffleModeEnabled = false;
-    this.listeners = new CopyOnWriteArraySet<>();
+    this.listeners = new CopyOnWriteArrayList<>();
     emptyTrackSelectorResult =
         new TrackSelectorResult(
             new RendererConfiguration[renderers.length],
@@ -126,7 +127,7 @@ public void handleMessage(Message msg) {
           }
         };
     playbackInfo = PlaybackInfo.createDummy(/* startPositionUs= */ 0, emptyTrackSelectorResult);
-    pendingPlaybackInfoUpdates = new ArrayDeque<>();
+    pendingListenerNotifications = new ArrayDeque<>();
     internalPlayer =
         new ExoPlayerImplInternal(
             renderers,
@@ -138,7 +139,6 @@ public void handleMessage(Message msg) {
             repeatMode,
             shuffleModeEnabled,
             eventHandler,
-            this,
             clock);
     internalPlayerHandler = new Handler(internalPlayer.getPlaybackLooper());
   }
@@ -179,12 +179,17 @@ public Looper getApplicationLooper() {
 
   @Override
   public void addListener(Player.EventListener listener) {
-    listeners.add(listener);
+    listeners.addIfAbsent(new ListenerHolder(listener));
   }
 
   @Override
   public void removeListener(Player.EventListener listener) {
-    listeners.remove(listener);
+    for (ListenerHolder listenerHolder : listeners) {
+      if (listenerHolder.listener.equals(listener)) {
+        listenerHolder.release();
+        listeners.remove(listenerHolder);
+      }
+    }
   }
 
   @Override
@@ -229,8 +234,7 @@ public void prepare(MediaSource mediaSource, boolean resetPosition, boolean rese
         /* positionDiscontinuity= */ false,
         /* ignored */ DISCONTINUITY_REASON_INTERNAL,
         TIMELINE_CHANGE_REASON_RESET,
-        /* seekProcessed= */ false,
-        /* playWhenReadyChanged= */ false);
+        /* seekProcessed= */ false);
   }
 
   @Override
@@ -246,13 +250,8 @@ public void setPlayWhenReady(boolean playWhenReady, boolean suppressPlayback) {
     }
     if (this.playWhenReady != playWhenReady) {
       this.playWhenReady = playWhenReady;
-      updatePlaybackInfo(
-          playbackInfo,
-          /* positionDiscontinuity= */ false,
-          /* ignored */ DISCONTINUITY_REASON_INTERNAL,
-          /* ignored */ TIMELINE_CHANGE_REASON_RESET,
-          /* seekProcessed= */ false,
-          /* playWhenReadyChanged= */ true);
+      int playbackState = playbackInfo.playbackState;
+      notifyListeners(listener -> listener.onPlayerStateChanged(playWhenReady, playbackState));
     }
   }
 
@@ -266,9 +265,7 @@ public void setRepeatMode(@RepeatMode int repeatMode) {
     if (this.repeatMode != repeatMode) {
       this.repeatMode = repeatMode;
       internalPlayer.setRepeatMode(repeatMode);
-      for (Player.EventListener listener : listeners) {
-        listener.onRepeatModeChanged(repeatMode);
-      }
+      notifyListeners(listener -> listener.onRepeatModeChanged(repeatMode));
     }
   }
 
@@ -282,9 +279,7 @@ public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
     if (this.shuffleModeEnabled != shuffleModeEnabled) {
       this.shuffleModeEnabled = shuffleModeEnabled;
       internalPlayer.setShuffleModeEnabled(shuffleModeEnabled);
-      for (Player.EventListener listener : listeners) {
-        listener.onShuffleModeEnabledChanged(shuffleModeEnabled);
-      }
+      notifyListeners(listener -> listener.onShuffleModeEnabledChanged(shuffleModeEnabled));
     }
   }
 
@@ -333,9 +328,7 @@ public void seekTo(int windowIndex, long positionMs) {
       maskingPeriodIndex = timeline.getIndexOfPeriod(periodUidAndPosition.first);
     }
     internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
-    for (Player.EventListener listener : listeners) {
-      listener.onPositionDiscontinuity(DISCONTINUITY_REASON_SEEK);
-    }
+    notifyListeners(listener -> listener.onPositionDiscontinuity(DISCONTINUITY_REASON_SEEK));
   }
 
   @Override
@@ -367,6 +360,14 @@ public SeekParameters getSeekParameters() {
     return seekParameters;
   }
 
+  @Override
+  public void setForegroundMode(boolean foregroundMode) {
+    if (this.foregroundMode != foregroundMode) {
+      this.foregroundMode = foregroundMode;
+      internalPlayer.setForegroundMode(foregroundMode);
+    }
+  }
+
   @Override
   public void stop(boolean reset) {
     if (reset) {
@@ -389,8 +390,7 @@ public void stop(boolean reset) {
         /* positionDiscontinuity= */ false,
         /* ignored */ DISCONTINUITY_REASON_INTERNAL,
         TIMELINE_CHANGE_REASON_RESET,
-        /* seekProcessed= */ false,
-        /* playWhenReadyChanged= */ false);
+        /* seekProcessed= */ false);
   }
 
   @Override
@@ -401,6 +401,11 @@ public void release() {
     mediaSource = null;
     internalPlayer.release();
     eventHandler.removeCallbacksAndMessages(null);
+    playbackInfo =
+        getResetPlaybackInfo(
+            /* resetPosition= */ false,
+            /* resetState= */ false,
+            /* playbackState= */ Player.STATE_IDLE);
   }
 
   @Override
@@ -600,17 +605,13 @@ public Object getCurrentManifest() {
         PlaybackParameters playbackParameters = (PlaybackParameters) msg.obj;
         if (!this.playbackParameters.equals(playbackParameters)) {
           this.playbackParameters = playbackParameters;
-          for (Player.EventListener listener : listeners) {
-            listener.onPlaybackParametersChanged(playbackParameters);
-          }
+          notifyListeners(listener -> listener.onPlaybackParametersChanged(playbackParameters));
         }
         break;
       case ExoPlayerImplInternal.MSG_ERROR:
         ExoPlaybackException playbackError = (ExoPlaybackException) msg.obj;
         this.playbackError = playbackError;
-        for (Player.EventListener listener : listeners) {
-          listener.onPlayerError(playbackError);
-        }
+        notifyListeners(listener -> listener.onPlayerError(playbackError));
         break;
       default:
         throw new IllegalStateException();
@@ -630,8 +631,7 @@ private void handlePlaybackInfo(
             playbackInfo.resetToNewPosition(
                 playbackInfo.periodId, /* startPositionUs= */ 0, playbackInfo.contentPositionUs);
       }
-      if ((!this.playbackInfo.timeline.isEmpty() || hasPendingPrepare)
-          && playbackInfo.timeline.isEmpty()) {
+      if (!this.playbackInfo.timeline.isEmpty() && playbackInfo.timeline.isEmpty()) {
         // Update the masking variables, which are used when the timeline becomes empty.
         maskingPeriodIndex = 0;
         maskingWindowIndex = 0;
@@ -650,8 +650,7 @@ private void handlePlaybackInfo(
           positionDiscontinuity,
           positionDiscontinuityReason,
           timelineChangeReason,
-          seekProcessed,
-          /* playWhenReadyChanged= */ false);
+          seekProcessed);
     }
   }
 
@@ -666,6 +665,8 @@ private PlaybackInfo getResetPlaybackInfo(
       maskingPeriodIndex = getCurrentPeriodIndex();
       maskingWindowPositionMs = getCurrentPosition();
     }
+    // Also reset period-based PlaybackInfo positions if resetting the state.
+    resetPosition = resetPosition || resetState;
     MediaPeriodId mediaPeriodId =
         resetPosition
             ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
@@ -693,29 +694,37 @@ private void updatePlaybackInfo(
       boolean positionDiscontinuity,
       @Player.DiscontinuityReason int positionDiscontinuityReason,
       @Player.TimelineChangeReason int timelineChangeReason,
-      boolean seekProcessed,
-      boolean playWhenReadyChanged) {
-    boolean isRunningRecursiveListenerNotification = !pendingPlaybackInfoUpdates.isEmpty();
-    pendingPlaybackInfoUpdates.addLast(
+      boolean seekProcessed) {
+    // Assign playback info immediately such that all getters return the right values.
+    PlaybackInfo previousPlaybackInfo = this.playbackInfo;
+    this.playbackInfo = playbackInfo;
+    notifyListeners(
         new PlaybackInfoUpdate(
             playbackInfo,
-            /* previousPlaybackInfo= */ this.playbackInfo,
+            previousPlaybackInfo,
             listeners,
             trackSelector,
             positionDiscontinuity,
             positionDiscontinuityReason,
             timelineChangeReason,
             seekProcessed,
-            playWhenReady,
-            playWhenReadyChanged));
-    // Assign playback info immediately such that all getters return the right values.
-    this.playbackInfo = playbackInfo;
+            playWhenReady));
+  }
+
+  private void notifyListeners(ListenerInvocation listenerInvocation) {
+    CopyOnWriteArrayList<ListenerHolder> listenerSnapshot = new CopyOnWriteArrayList<>(listeners);
+    notifyListeners(() -> invokeAll(listenerSnapshot, listenerInvocation));
+  }
+
+  private void notifyListeners(Runnable listenerNotificationRunnable) {
+    boolean isRunningRecursiveListenerNotification = !pendingListenerNotifications.isEmpty();
+    pendingListenerNotifications.addLast(listenerNotificationRunnable);
     if (isRunningRecursiveListenerNotification) {
       return;
     }
-    while (!pendingPlaybackInfoUpdates.isEmpty()) {
-      pendingPlaybackInfoUpdates.peekFirst().notifyListeners();
-      pendingPlaybackInfoUpdates.removeFirst();
+    while (!pendingListenerNotifications.isEmpty()) {
+      pendingListenerNotifications.peekFirst().run();
+      pendingListenerNotifications.removeFirst();
     }
   }
 
@@ -730,42 +739,40 @@ private boolean shouldMaskPosition() {
     return playbackInfo.timeline.isEmpty() || pendingOperationAcks > 0;
   }
 
-  private static final class PlaybackInfoUpdate {
+  private static final class PlaybackInfoUpdate implements Runnable {
 
     private final PlaybackInfo playbackInfo;
-    private final Set<Player.EventListener> listeners;
+    private final CopyOnWriteArrayList<ListenerHolder> listenerSnapshot;
     private final TrackSelector trackSelector;
     private final boolean positionDiscontinuity;
     private final @Player.DiscontinuityReason int positionDiscontinuityReason;
     private final @Player.TimelineChangeReason int timelineChangeReason;
     private final boolean seekProcessed;
-    private final boolean playWhenReady;
-    private final boolean playbackStateOrPlayWhenReadyChanged;
+    private final boolean playbackStateChanged;
     private final boolean timelineOrManifestChanged;
     private final boolean isLoadingChanged;
     private final boolean trackSelectorResultChanged;
+    private final boolean playWhenReady;
 
     public PlaybackInfoUpdate(
         PlaybackInfo playbackInfo,
         PlaybackInfo previousPlaybackInfo,
-        Set<Player.EventListener> listeners,
+        CopyOnWriteArrayList<ListenerHolder> listeners,
         TrackSelector trackSelector,
         boolean positionDiscontinuity,
         @Player.DiscontinuityReason int positionDiscontinuityReason,
         @Player.TimelineChangeReason int timelineChangeReason,
         boolean seekProcessed,
-        boolean playWhenReady,
-        boolean playWhenReadyChanged) {
+        boolean playWhenReady) {
       this.playbackInfo = playbackInfo;
-      this.listeners = listeners;
+      this.listenerSnapshot = new CopyOnWriteArrayList<>(listeners);
       this.trackSelector = trackSelector;
       this.positionDiscontinuity = positionDiscontinuity;
       this.positionDiscontinuityReason = positionDiscontinuityReason;
       this.timelineChangeReason = timelineChangeReason;
       this.seekProcessed = seekProcessed;
       this.playWhenReady = playWhenReady;
-      playbackStateOrPlayWhenReadyChanged =
-          playWhenReadyChanged || previousPlaybackInfo.playbackState != playbackInfo.playbackState;
+      playbackStateChanged = previousPlaybackInfo.playbackState != playbackInfo.playbackState;
       timelineOrManifestChanged =
           previousPlaybackInfo.timeline != playbackInfo.timeline
               || previousPlaybackInfo.manifest != playbackInfo.manifest;
@@ -774,40 +781,46 @@ public PlaybackInfoUpdate(
           previousPlaybackInfo.trackSelectorResult != playbackInfo.trackSelectorResult;
     }
 
-    public void notifyListeners() {
+    @Override
+    public void run() {
       if (timelineOrManifestChanged || timelineChangeReason == TIMELINE_CHANGE_REASON_PREPARED) {
-        for (Player.EventListener listener : listeners) {
-          listener.onTimelineChanged(
-              playbackInfo.timeline, playbackInfo.manifest, timelineChangeReason);
-        }
+        invokeAll(
+            listenerSnapshot,
+            listener ->
+                listener.onTimelineChanged(
+                    playbackInfo.timeline, playbackInfo.manifest, timelineChangeReason));
       }
       if (positionDiscontinuity) {
-        for (Player.EventListener listener : listeners) {
-          listener.onPositionDiscontinuity(positionDiscontinuityReason);
-        }
+        invokeAll(
+            listenerSnapshot,
+            listener -> listener.onPositionDiscontinuity(positionDiscontinuityReason));
       }
       if (trackSelectorResultChanged) {
         trackSelector.onSelectionActivated(playbackInfo.trackSelectorResult.info);
-        for (Player.EventListener listener : listeners) {
-          listener.onTracksChanged(
-              playbackInfo.trackGroups, playbackInfo.trackSelectorResult.selections);
-        }
+        invokeAll(
+            listenerSnapshot,
+            listener ->
+                listener.onTracksChanged(
+                    playbackInfo.trackGroups, playbackInfo.trackSelectorResult.selections));
       }
       if (isLoadingChanged) {
-        for (Player.EventListener listener : listeners) {
-          listener.onLoadingChanged(playbackInfo.isLoading);
-        }
+        invokeAll(listenerSnapshot, listener -> listener.onLoadingChanged(playbackInfo.isLoading));
       }
-      if (playbackStateOrPlayWhenReadyChanged) {
-        for (Player.EventListener listener : listeners) {
-          listener.onPlayerStateChanged(playWhenReady, playbackInfo.playbackState);
-        }
+      if (playbackStateChanged) {
+        invokeAll(
+            listenerSnapshot,
+            listener -> listener.onPlayerStateChanged(playWhenReady, playbackInfo.playbackState));
       }
       if (seekProcessed) {
-        for (Player.EventListener listener : listeners) {
-          listener.onSeekProcessed();
-        }
+        invokeAll(listenerSnapshot, EventListener::onSeekProcessed);
       }
     }
   }
+
+  private static void invokeAll(
+      CopyOnWriteArrayList<ListenerHolder> listeners, ListenerInvocation listenerInvocation) {
+    for (ListenerHolder listenerHolder : listeners) {
+      listenerHolder.invoke(listenerInvocation);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 7f41719d1d..37774bccb5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -21,8 +21,8 @@
 import android.os.Message;
 import android.os.Process;
 import android.os.SystemClock;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
@@ -44,6 +44,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Implements the internal behavior of {@link ExoPlayerImpl}. */
 /* package */ final class ExoPlayerImplInternal
@@ -76,9 +77,10 @@
   private static final int MSG_TRACK_SELECTION_INVALIDATED = 11;
   private static final int MSG_SET_REPEAT_MODE = 12;
   private static final int MSG_SET_SHUFFLE_ENABLED = 13;
-  private static final int MSG_SEND_MESSAGE = 14;
-  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 15;
-  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 16;
+  private static final int MSG_SET_FOREGROUND_MODE = 14;
+  private static final int MSG_SEND_MESSAGE = 15;
+  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 16;
+  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 17;
 
   private static final int PREPARING_SOURCE_INTERVAL_MS = 10;
   private static final int RENDERING_INTERVAL_MS = 10;
@@ -93,7 +95,6 @@
   private final HandlerWrapper handler;
   private final HandlerThread internalPlaybackThread;
   private final Handler eventHandler;
-  private final ExoPlayer player;
   private final Timeline.Window window;
   private final Timeline.Period period;
   private final long backBufferDurationUs;
@@ -115,6 +116,7 @@
   private boolean rebuffering;
   @Player.RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
+  private boolean foregroundMode;
 
   private int pendingPrepareCount;
   private SeekPosition pendingInitialSeekPosition;
@@ -131,7 +133,6 @@ public ExoPlayerImplInternal(
       @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled,
       Handler eventHandler,
-      ExoPlayer player,
       Clock clock) {
     this.renderers = renderers;
     this.trackSelector = trackSelector;
@@ -142,7 +143,6 @@ public ExoPlayerImplInternal(
     this.repeatMode = repeatMode;
     this.shuffleModeEnabled = shuffleModeEnabled;
     this.eventHandler = eventHandler;
-    this.player = player;
     this.clock = clock;
     this.queue = new MediaPeriodQueue();
 
@@ -218,6 +218,29 @@ public synchronized void sendMessage(PlayerMessage message) {
     handler.obtainMessage(MSG_SEND_MESSAGE, message).sendToTarget();
   }
 
+  public synchronized void setForegroundMode(boolean foregroundMode) {
+    if (foregroundMode) {
+      handler.obtainMessage(MSG_SET_FOREGROUND_MODE, /* foregroundMode */ 1, 0).sendToTarget();
+    } else {
+      AtomicBoolean processedFlag = new AtomicBoolean();
+      handler
+          .obtainMessage(MSG_SET_FOREGROUND_MODE, /* foregroundMode */ 0, 0, processedFlag)
+          .sendToTarget();
+      boolean wasInterrupted = false;
+      while (!processedFlag.get() && !released) {
+        try {
+          wait();
+        } catch (InterruptedException e) {
+          wasInterrupted = true;
+        }
+      }
+      if (wasInterrupted) {
+        // Restore the interrupted status.
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   public synchronized void release() {
     if (released) {
       return;
@@ -311,8 +334,15 @@ public boolean handleMessage(Message msg) {
         case MSG_SET_SEEK_PARAMETERS:
           setSeekParametersInternal((SeekParameters) msg.obj);
           break;
+        case MSG_SET_FOREGROUND_MODE:
+          setForegroundModeInternal(
+              /* foregroundMode= */ msg.arg1 != 0, /* processedFlag= */ (AtomicBoolean) msg.obj);
+          break;
         case MSG_STOP:
-          stopInternal(/* reset= */ msg.arg1 != 0, /* acknowledgeStop= */ true);
+          stopInternal(
+              /* forceResetRenderers= */ false,
+              /* resetPositionAndState= */ msg.arg1 != 0,
+              /* acknowledgeStop= */ true);
           break;
         case MSG_PERIOD_PREPARED:
           handlePeriodPrepared((MediaPeriod) msg.obj);
@@ -345,19 +375,31 @@ public boolean handleMessage(Message msg) {
       maybeNotifyPlaybackInfoChanged();
     } catch (ExoPlaybackException e) {
       Log.e(TAG, "Playback error.", e);
-      stopInternal(/* reset= */ false, /* acknowledgeStop= */ false);
       eventHandler.obtainMessage(MSG_ERROR, e).sendToTarget();
+      stopInternal(
+          /* forceResetRenderers= */ true,
+          /* resetPositionAndState= */ false,
+          /* acknowledgeStop= */ false);
       maybeNotifyPlaybackInfoChanged();
     } catch (IOException e) {
       Log.e(TAG, "Source error.", e);
-      stopInternal(/* reset= */ false, /* acknowledgeStop= */ false);
       eventHandler.obtainMessage(MSG_ERROR, ExoPlaybackException.createForSource(e)).sendToTarget();
+      stopInternal(
+          /* forceResetRenderers= */ false,
+          /* resetPositionAndState= */ false,
+          /* acknowledgeStop= */ false);
       maybeNotifyPlaybackInfoChanged();
-    } catch (RuntimeException e) {
+    } catch (RuntimeException | OutOfMemoryError e) {
       Log.e(TAG, "Internal runtime error.", e);
-      stopInternal(/* reset= */ false, /* acknowledgeStop= */ false);
-      eventHandler.obtainMessage(MSG_ERROR, ExoPlaybackException.createForUnexpected(e))
-          .sendToTarget();
+      ExoPlaybackException error =
+          e instanceof OutOfMemoryError
+              ? ExoPlaybackException.createForOutOfMemoryError((OutOfMemoryError) e)
+              : ExoPlaybackException.createForUnexpected((RuntimeException) e);
+      eventHandler.obtainMessage(MSG_ERROR, error).sendToTarget();
+      stopInternal(
+          /* forceResetRenderers= */ true,
+          /* resetPositionAndState= */ false,
+          /* acknowledgeStop= */ false);
       maybeNotifyPlaybackInfoChanged();
     }
     return true;
@@ -394,15 +436,12 @@ private void maybeNotifyPlaybackInfoChanged() {
 
   private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     pendingPrepareCount++;
-    resetInternal(/* releaseMediaSource= */ true, resetPosition, resetState);
+    resetInternal(
+        /* resetRenderers= */ false, /* releaseMediaSource= */ true, resetPosition, resetState);
     loadControl.onPrepared();
     this.mediaSource = mediaSource;
     setState(Player.STATE_BUFFERING);
-    mediaSource.prepareSource(
-        player,
-        /* isTopLevelSource= */ true,
-        /* listener= */ this,
-        bandwidthMeter.getTransferListener());
+    mediaSource.prepareSource(/* listener= */ this, bandwidthMeter.getTransferListener());
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
@@ -631,7 +670,10 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
         // End playback, as we didn't manage to find a valid seek position.
         setState(Player.STATE_ENDED);
         resetInternal(
-            /* releaseMediaSource= */ false, /* resetPosition= */ true, /* resetState= */ false);
+            /* resetRenderers= */ false,
+            /* releaseMediaSource= */ false,
+            /* resetPosition= */ true,
+            /* resetState= */ false);
       } else {
         // Execute the seek in the current media periods.
         long newPeriodPositionUs = periodPositionUs;
@@ -728,6 +770,7 @@ private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackExce
     for (Renderer renderer : enabledRenderers) {
       renderer.resetPosition(rendererPositionUs);
     }
+    notifyTrackSelectionDiscontinuity();
   }
 
   private void setPlaybackParametersInternal(PlaybackParameters playbackParameters) {
@@ -738,9 +781,33 @@ private void setSeekParametersInternal(SeekParameters seekParameters) {
     this.seekParameters = seekParameters;
   }
 
-  private void stopInternal(boolean reset, boolean acknowledgeStop) {
+  private void setForegroundModeInternal(
+      boolean foregroundMode, @Nullable AtomicBoolean processedFlag) {
+    if (this.foregroundMode != foregroundMode) {
+      this.foregroundMode = foregroundMode;
+      if (!foregroundMode) {
+        for (Renderer renderer : renderers) {
+          if (renderer.getState() == Renderer.STATE_DISABLED) {
+            renderer.reset();
+          }
+        }
+      }
+    }
+    if (processedFlag != null) {
+      synchronized (this) {
+        processedFlag.set(true);
+        notifyAll();
+      }
+    }
+  }
+
+  private void stopInternal(
+      boolean forceResetRenderers, boolean resetPositionAndState, boolean acknowledgeStop) {
     resetInternal(
-        /* releaseMediaSource= */ true, /* resetPosition= */ reset, /* resetState= */ reset);
+        /* resetRenderers= */ forceResetRenderers || !foregroundMode,
+        /* releaseMediaSource= */ true,
+        /* resetPosition= */ resetPositionAndState,
+        /* resetState= */ resetPositionAndState);
     playbackInfoUpdate.incrementPendingOperationAcks(
         pendingPrepareCount + (acknowledgeStop ? 1 : 0));
     pendingPrepareCount = 0;
@@ -750,7 +817,10 @@ private void stopInternal(boolean reset, boolean acknowledgeStop) {
 
   private void releaseInternal() {
     resetInternal(
-        /* releaseMediaSource= */ true, /* resetPosition= */ true, /* resetState= */ true);
+        /* resetRenderers= */ true,
+        /* releaseMediaSource= */ true,
+        /* resetPosition= */ true,
+        /* resetState= */ true);
     loadControl.onReleased();
     setState(Player.STATE_IDLE);
     internalPlaybackThread.quit();
@@ -761,7 +831,10 @@ private void releaseInternal() {
   }
 
   private void resetInternal(
-      boolean releaseMediaSource, boolean resetPosition, boolean resetState) {
+      boolean resetRenderers,
+      boolean releaseMediaSource,
+      boolean resetPosition,
+      boolean resetState) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
     mediaClock.stop();
@@ -771,15 +844,37 @@ private void resetInternal(
         disableRenderer(renderer);
       } catch (ExoPlaybackException | RuntimeException e) {
         // There's nothing we can do.
-        Log.e(TAG, "Stop failed.", e);
+        Log.e(TAG, "Disable failed.", e);
+      }
+    }
+    if (resetRenderers) {
+      for (Renderer renderer : renderers) {
+        try {
+          renderer.reset();
+        } catch (RuntimeException e) {
+          // There's nothing we can do.
+          Log.e(TAG, "Reset failed.", e);
+        }
       }
     }
     enabledRenderers = new Renderer[0];
-    queue.clear(/* keepFrontPeriodUid= */ !resetPosition);
-    setIsLoading(false);
+
     if (resetPosition) {
       pendingInitialSeekPosition = null;
+    } else if (resetState) {
+      // When resetting the state, also reset the period-based PlaybackInfo position and convert
+      // existing position to initial seek instead.
+      resetPosition = true;
+      if (pendingInitialSeekPosition == null && !playbackInfo.timeline.isEmpty()) {
+        playbackInfo.timeline.getPeriodByUid(playbackInfo.periodId.periodUid, period);
+        long windowPositionUs = playbackInfo.positionUs + period.getPositionInWindowUs();
+        pendingInitialSeekPosition =
+            new SeekPosition(Timeline.EMPTY, period.windowIndex, windowPositionUs);
+      }
     }
+
+    queue.clear(/* keepFrontPeriodUid= */ !resetPosition);
+    setIsLoading(false);
     if (resetState) {
       queue.setTimeline(Timeline.EMPTY);
       for (PendingMessageInfo pendingMessageInfo : pendingMessages) {
@@ -993,12 +1088,14 @@ private void reselectTracksInternal() throws ExoPlaybackException {
     MediaPeriodHolder periodHolder = queue.getPlayingPeriod();
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     boolean selectionsChangedForReadPeriod = true;
+    TrackSelectorResult newTrackSelectorResult;
     while (true) {
       if (periodHolder == null || !periodHolder.prepared) {
         // The reselection did not change any prepared periods.
         return;
       }
-      if (periodHolder.selectTracks(playbackSpeed)) {
+      newTrackSelectorResult = periodHolder.selectTracks(playbackSpeed, playbackInfo.timeline);
+      if (newTrackSelectorResult != null) {
         // Selected tracks have changed for this period.
         break;
       }
@@ -1006,7 +1103,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
         // The track reselection didn't affect any period that has been read.
         selectionsChangedForReadPeriod = false;
       }
-      periodHolder = periodHolder.next;
+      periodHolder = periodHolder.getNext();
     }
 
     if (selectionsChangedForReadPeriod) {
@@ -1017,7 +1114,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       boolean[] streamResetFlags = new boolean[renderers.length];
       long periodPositionUs =
           playingPeriodHolder.applyTrackSelection(
-              playbackInfo.positionUs, recreateStreams, streamResetFlags);
+              newTrackSelectorResult, playbackInfo.positionUs, recreateStreams, streamResetFlags);
       if (playbackInfo.playbackState != Player.STATE_ENDED
           && periodPositionUs != playbackInfo.positionUs) {
         playbackInfo =
@@ -1051,7 +1148,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       }
       playbackInfo =
           playbackInfo.copyWithTrackInfo(
-              playingPeriodHolder.trackGroups, playingPeriodHolder.trackSelectorResult);
+              playingPeriodHolder.getTrackGroups(), playingPeriodHolder.getTrackSelectorResult());
       enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
     } else {
       // Release and re-prepare/buffer periods after the one whose selection changed.
@@ -1060,7 +1157,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
         long loadingPeriodPositionUs =
             Math.max(
                 periodHolder.info.startPositionUs, periodHolder.toPeriodTime(rendererPositionUs));
-        periodHolder.applyTrackSelection(loadingPeriodPositionUs, false);
+        periodHolder.applyTrackSelection(newTrackSelectorResult, loadingPeriodPositionUs, false);
       }
     }
     handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ true);
@@ -1072,17 +1169,31 @@ private void reselectTracksInternal() throws ExoPlaybackException {
   }
 
   private void updateTrackSelectionPlaybackSpeed(float playbackSpeed) {
+    MediaPeriodHolder periodHolder = queue.getFrontPeriod();
+    while (periodHolder != null && periodHolder.prepared) {
+      TrackSelection[] trackSelections = periodHolder.getTrackSelectorResult().selections.getAll();
+      for (TrackSelection trackSelection : trackSelections) {
+        if (trackSelection != null) {
+          trackSelection.onPlaybackSpeed(playbackSpeed);
+        }
+      }
+      periodHolder = periodHolder.getNext();
+    }
+  }
+
+  private void notifyTrackSelectionDiscontinuity() {
     MediaPeriodHolder periodHolder = queue.getFrontPeriod();
     while (periodHolder != null) {
-      if (periodHolder.trackSelectorResult != null) {
-        TrackSelection[] trackSelections = periodHolder.trackSelectorResult.selections.getAll();
+      TrackSelectorResult trackSelectorResult = periodHolder.getTrackSelectorResult();
+      if (trackSelectorResult != null) {
+        TrackSelection[] trackSelections = trackSelectorResult.selections.getAll();
         for (TrackSelection trackSelection : trackSelections) {
           if (trackSelection != null) {
-            trackSelection.onPlaybackSpeed(playbackSpeed);
+            trackSelection.onDiscontinuity();
           }
         }
       }
-      periodHolder = periodHolder.next;
+      periodHolder = periodHolder.getNext();
     }
   }
 
@@ -1109,11 +1220,12 @@ private boolean shouldTransitionToReadyState(boolean renderersReadyOrEnded) {
 
   private boolean isTimelineReady() {
     MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    MediaPeriodHolder nextPeriodHolder = playingPeriodHolder.getNext();
     long playingPeriodDurationUs = playingPeriodHolder.info.durationUs;
     return playingPeriodDurationUs == C.TIME_UNSET
         || playbackInfo.positionUs < playingPeriodDurationUs
-        || (playingPeriodHolder.next != null
-            && (playingPeriodHolder.next.prepared || playingPeriodHolder.next.info.id.isAd()));
+        || (nextPeriodHolder != null
+            && (nextPeriodHolder.prepared || nextPeriodHolder.info.id.isAd()));
   }
 
   private void maybeThrowSourceInfoRefreshError() throws IOException {
@@ -1132,8 +1244,9 @@ private void maybeThrowSourceInfoRefreshError() throws IOException {
   private void maybeThrowPeriodPrepareError() throws IOException {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
-    if (loadingPeriodHolder != null && !loadingPeriodHolder.prepared
-        && (readingPeriodHolder == null || readingPeriodHolder.next == loadingPeriodHolder)) {
+    if (loadingPeriodHolder != null
+        && !loadingPeriodHolder.prepared
+        && (readingPeriodHolder == null || readingPeriodHolder.getNext() == loadingPeriodHolder)) {
       for (Renderer renderer : enabledRenderers) {
         if (!renderer.hasReadStreamToEnd()) {
           return;
@@ -1149,6 +1262,8 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       // Stale event.
       return;
     }
+    playbackInfoUpdate.incrementPendingOperationAcks(pendingPrepareCount);
+    pendingPrepareCount = 0;
 
     Timeline oldTimeline = playbackInfo.timeline;
     Timeline timeline = sourceRefreshInfo.timeline;
@@ -1157,138 +1272,107 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
     playbackInfo = playbackInfo.copyWithTimeline(timeline, manifest);
     resolvePendingMessagePositions();
 
-    if (pendingPrepareCount > 0) {
-      playbackInfoUpdate.incrementPendingOperationAcks(pendingPrepareCount);
-      pendingPrepareCount = 0;
-      if (pendingInitialSeekPosition != null) {
-        Pair<Object, Long> periodPosition;
-        try {
-          periodPosition =
-              resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
-        } catch (IllegalSeekPositionException e) {
-          MediaPeriodId firstMediaPeriodId =
-              playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window);
-          playbackInfo =
-              playbackInfo.resetToNewPosition(
-                  firstMediaPeriodId,
-                  /* startPositionUs= */ C.TIME_UNSET,
-                  /* contentPositionUs= */ C.TIME_UNSET);
-          throw e;
-        }
-        pendingInitialSeekPosition = null;
-        if (periodPosition == null) {
-          // The seek position was valid for the timeline that it was performed into, but the
-          // timeline has changed and a suitable seek position could not be resolved in the new one.
-          handleSourceInfoRefreshEndedPlayback();
-        } else {
-          Object periodUid = periodPosition.first;
-          long positionUs = periodPosition.second;
-          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, positionUs);
-          playbackInfo =
-              playbackInfo.resetToNewPosition(
-                  periodId, periodId.isAd() ? 0 : positionUs, /* contentPositionUs= */ positionUs);
-        }
-      } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {
-        if (timeline.isEmpty()) {
-          handleSourceInfoRefreshEndedPlayback();
-        } else {
-          Pair<Object, Long> defaultPosition =
-              getPeriodPosition(
-                  timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
-          Object periodUid = defaultPosition.first;
-          long startPositionUs = defaultPosition.second;
-          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, startPositionUs);
-          playbackInfo =
-              playbackInfo.resetToNewPosition(
-                  periodId,
-                  periodId.isAd() ? 0 : startPositionUs,
-                  /* contentPositionUs= */ startPositionUs);
-        }
-      }
-      return;
-    }
-
-    if (oldTimeline.isEmpty()) {
-      // If the old timeline is empty, the period queue is also empty.
-      if (!timeline.isEmpty()) {
-        Pair<Object, Long> defaultPosition =
-            getPeriodPosition(
-                timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
-        Object periodUid = defaultPosition.first;
-        long startPositionUs = defaultPosition.second;
-        MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, startPositionUs);
-        playbackInfo =
-            playbackInfo.resetToNewPosition(
-                periodId,
-                /* startPositionUs= */ periodId.isAd() ? 0 : startPositionUs,
-                /* contentPositionUs= */ startPositionUs);
+    MediaPeriodId newPeriodId = playbackInfo.periodId;
+    long oldContentPositionUs =
+        playbackInfo.periodId.isAd() ? playbackInfo.contentPositionUs : playbackInfo.positionUs;
+    long newContentPositionUs = oldContentPositionUs;
+    if (pendingInitialSeekPosition != null) {
+      // Resolve initial seek position.
+      Pair<Object, Long> periodPosition =
+          resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
+      pendingInitialSeekPosition = null;
+      if (periodPosition == null) {
+        // The seek position was valid for the timeline that it was performed into, but the
+        // timeline has changed and a suitable seek position could not be resolved in the new one.
+        handleSourceInfoRefreshEndedPlayback();
+        return;
       }
-      return;
-    }
-    MediaPeriodHolder periodHolder = queue.getFrontPeriod();
-    long contentPositionUs = playbackInfo.contentPositionUs;
-    Object playingPeriodUid =
-        periodHolder == null ? playbackInfo.periodId.periodUid : periodHolder.uid;
-    int periodIndex = timeline.getIndexOfPeriod(playingPeriodUid);
-    if (periodIndex == C.INDEX_UNSET) {
-      // We didn't find the current period in the new timeline. Attempt to resolve a subsequent
-      // period whose window we can restart from.
-      Object newPeriodUid = resolveSubsequentPeriod(playingPeriodUid, oldTimeline, timeline);
+      newContentPositionUs = periodPosition.second;
+      newPeriodId = queue.resolveMediaPeriodIdForAds(periodPosition.first, newContentPositionUs);
+    } else if (oldContentPositionUs == C.TIME_UNSET && !timeline.isEmpty()) {
+      // Resolve unset start position to default position.
+      Pair<Object, Long> defaultPosition =
+          getPeriodPosition(
+              timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
+      newContentPositionUs = defaultPosition.second;
+      newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, newContentPositionUs);
+    } else if (timeline.getIndexOfPeriod(newPeriodId.periodUid) == C.INDEX_UNSET) {
+      // The current period isn't in the new timeline. Attempt to resolve a subsequent period whose
+      // window we can restart from.
+      Object newPeriodUid = resolveSubsequentPeriod(newPeriodId.periodUid, oldTimeline, timeline);
       if (newPeriodUid == null) {
         // We failed to resolve a suitable restart position.
         handleSourceInfoRefreshEndedPlayback();
         return;
       }
-      // We resolved a subsequent period. Seek to the default position in the corresponding window.
+      // We resolved a subsequent period. Start at the default position in the corresponding window.
       Pair<Object, Long> defaultPosition =
           getPeriodPosition(
               timeline, timeline.getPeriodByUid(newPeriodUid, period).windowIndex, C.TIME_UNSET);
-      newPeriodUid = defaultPosition.first;
-      contentPositionUs = defaultPosition.second;
-      MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(newPeriodUid, contentPositionUs);
+      newContentPositionUs = defaultPosition.second;
+      newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, newContentPositionUs);
+    } else if (newPeriodId.isAd()) {
+      // Recheck if the current ad still needs to be played.
+      newPeriodId = queue.resolveMediaPeriodIdForAds(newPeriodId.periodUid, newContentPositionUs);
+    }
+
+    if (playbackInfo.periodId.equals(newPeriodId) && oldContentPositionUs == newContentPositionUs) {
+      // We can keep the current playing period. Update the rest of the queued periods.
+      if (!queue.updateQueuedPeriods(rendererPositionUs, getMaxRendererReadPositionUs())) {
+        seekToCurrentPosition(/* sendDiscontinuity= */ false);
+      }
+    } else {
+      // Something changed. Seek to new start position.
+      MediaPeriodHolder periodHolder = queue.getFrontPeriod();
       if (periodHolder != null) {
         // Update the new playing media period info if it already exists.
-        while (periodHolder.next != null) {
-          periodHolder = periodHolder.next;
-          if (periodHolder.info.id.equals(periodId)) {
+        while (periodHolder.getNext() != null) {
+          periodHolder = periodHolder.getNext();
+          if (periodHolder.info.id.equals(newPeriodId)) {
             periodHolder.info = queue.getUpdatedMediaPeriodInfo(periodHolder.info);
           }
         }
       }
       // Actually do the seek.
-      long seekPositionUs = seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
+      long newPositionUs = newPeriodId.isAd() ? 0 : newContentPositionUs;
+      long seekedToPositionUs = seekToPeriodPosition(newPeriodId, newPositionUs);
       playbackInfo =
           playbackInfo.copyWithNewPosition(
-              periodId, seekPositionUs, contentPositionUs, getTotalBufferedDurationUs());
-      return;
+              newPeriodId, seekedToPositionUs, newContentPositionUs, getTotalBufferedDurationUs());
     }
+    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
+  }
 
-    MediaPeriodId playingPeriodId = playbackInfo.periodId;
-    if (playingPeriodId.isAd()) {
-      MediaPeriodId periodId =
-          queue.resolveMediaPeriodIdForAds(playingPeriodUid, contentPositionUs);
-      if (!periodId.equals(playingPeriodId)) {
-        // The previously playing ad should no longer be played, so skip it.
-        long seekPositionUs =
-            seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
-        playbackInfo =
-            playbackInfo.copyWithNewPosition(
-                periodId, seekPositionUs, contentPositionUs, getTotalBufferedDurationUs());
-        return;
-      }
+  private long getMaxRendererReadPositionUs() {
+    MediaPeriodHolder readingHolder = queue.getReadingPeriod();
+    if (readingHolder == null) {
+      return 0;
     }
-
-    if (!queue.updateQueuedPeriods(playingPeriodId, rendererPositionUs)) {
-      seekToCurrentPosition(/* sendDiscontinuity= */ false);
+    long maxReadPositionUs = readingHolder.getRendererOffset();
+    for (int i = 0; i < renderers.length; i++) {
+      if (renderers[i].getState() == Renderer.STATE_DISABLED
+          || renderers[i].getStream() != readingHolder.sampleStreams[i]) {
+        // Ignore disabled renderers and renderers with sample streams from previous periods.
+        continue;
+      }
+      long readingPositionUs = renderers[i].getReadingPositionUs();
+      if (readingPositionUs == C.TIME_END_OF_SOURCE) {
+        return C.TIME_END_OF_SOURCE;
+      } else {
+        maxReadPositionUs = Math.max(readingPositionUs, maxReadPositionUs);
+      }
     }
-    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
+    return maxReadPositionUs;
   }
 
   private void handleSourceInfoRefreshEndedPlayback() {
     setState(Player.STATE_ENDED);
     // Reset, but retain the source so that it can still be used should a seek occur.
     resetInternal(
-        /* releaseMediaSource= */ false, /* resetPosition= */ true, /* resetState= */ false);
+        /* resetRenderers= */ false,
+        /* releaseMediaSource= */ false,
+        /* resetPosition= */ true,
+        /* resetState= */ false);
   }
 
   /**
@@ -1349,8 +1433,7 @@ private void handleSourceInfoRefreshEndedPlayback() {
           seekPosition.windowPositionUs);
     } catch (IndexOutOfBoundsException e) {
       // The window index of the seek position was outside the bounds of the timeline.
-      throw new IllegalSeekPositionException(timeline, seekPosition.windowIndex,
-          seekPosition.windowPositionUs);
+      return null;
     }
     if (timeline == seekTimeline) {
       // Our internal timeline is the seek timeline, so the mapped position is correct.
@@ -1415,7 +1498,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     boolean advancedPlayingPeriod = false;
     while (playWhenReady
         && playingPeriodHolder != readingPeriodHolder
-        && rendererPositionUs >= playingPeriodHolder.next.getStartPositionRendererTime()) {
+        && rendererPositionUs >= playingPeriodHolder.getNext().getStartPositionRendererTime()) {
       // All enabled renderers' streams have been read to the end, and the playback position reached
       // the end of the playing period, so advance playback to the next period.
       if (advancedPlayingPeriod) {
@@ -1455,7 +1538,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
 
     // Advance the reading period if necessary.
-    if (readingPeriodHolder.next == null) {
+    if (readingPeriodHolder.getNext() == null) {
       // We don't have a successor to advance the reading period to.
       return;
     }
@@ -1470,15 +1553,15 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       }
     }
 
-    if (!readingPeriodHolder.next.prepared) {
+    if (!readingPeriodHolder.getNext().prepared) {
       // The successor is not prepared yet.
       maybeThrowPeriodPrepareError();
       return;
     }
 
-    TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
+    TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.getTrackSelectorResult();
     readingPeriodHolder = queue.advanceReadingPeriod();
-    TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
+    TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.getTrackSelectorResult();
 
     boolean initialDiscontinuity =
         readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
@@ -1546,9 +1629,10 @@ private void handlePeriodPrepared(MediaPeriod mediaPeriod) throws ExoPlaybackExc
       return;
     }
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    loadingPeriodHolder.handlePrepared(mediaClock.getPlaybackParameters().speed);
+    loadingPeriodHolder.handlePrepared(
+        mediaClock.getPlaybackParameters().speed, playbackInfo.timeline);
     updateLoadControlTrackSelection(
-        loadingPeriodHolder.trackGroups, loadingPeriodHolder.trackSelectorResult);
+        loadingPeriodHolder.getTrackGroups(), loadingPeriodHolder.getTrackSelectorResult());
     if (!queue.hasPlayingPeriod()) {
       // This is the first prepared period, so start playing it.
       MediaPeriodHolder playingPeriodHolder = queue.advancePlayingPeriod();
@@ -1608,11 +1692,11 @@ private void updatePlayingPeriodRenderers(@Nullable MediaPeriodHolder oldPlaying
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       rendererWasEnabledFlags[i] = renderer.getState() != Renderer.STATE_DISABLED;
-      if (newPlayingPeriodHolder.trackSelectorResult.isRendererEnabled(i)) {
+      if (newPlayingPeriodHolder.getTrackSelectorResult().isRendererEnabled(i)) {
         enabledRendererCount++;
       }
       if (rendererWasEnabledFlags[i]
-          && (!newPlayingPeriodHolder.trackSelectorResult.isRendererEnabled(i)
+          && (!newPlayingPeriodHolder.getTrackSelectorResult().isRendererEnabled(i)
               || (renderer.isCurrentStreamFinal()
                   && renderer.getStream() == oldPlayingPeriodHolder.sampleStreams[i]))) {
         // The renderer should be disabled before playing the next period, either because it's not
@@ -1623,7 +1707,8 @@ private void updatePlayingPeriodRenderers(@Nullable MediaPeriodHolder oldPlaying
     }
     playbackInfo =
         playbackInfo.copyWithTrackInfo(
-            newPlayingPeriodHolder.trackGroups, newPlayingPeriodHolder.trackSelectorResult);
+            newPlayingPeriodHolder.getTrackGroups(),
+            newPlayingPeriodHolder.getTrackSelectorResult());
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
 
@@ -1631,9 +1716,17 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int totalEnabled
       throws ExoPlaybackException {
     enabledRenderers = new Renderer[totalEnabledRendererCount];
     int enabledRendererCount = 0;
-    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    TrackSelectorResult trackSelectorResult = queue.getPlayingPeriod().getTrackSelectorResult();
+    // Reset all disabled renderers before enabling any new ones. This makes sure resources released
+    // by the disabled renderers will be available to renderers that are being enabled.
+    for (int i = 0; i < renderers.length; i++) {
+      if (!trackSelectorResult.isRendererEnabled(i)) {
+        renderers[i].reset();
+      }
+    }
+    // Enable the renderers.
     for (int i = 0; i < renderers.length; i++) {
-      if (playingPeriodHolder.trackSelectorResult.isRendererEnabled(i)) {
+      if (trackSelectorResult.isRendererEnabled(i)) {
         enableRenderer(i, rendererWasEnabledFlags[i], enabledRendererCount++);
       }
     }
@@ -1646,10 +1739,10 @@ private void enableRenderer(
     Renderer renderer = renderers[rendererIndex];
     enabledRenderers[enabledRendererIndex] = renderer;
     if (renderer.getState() == Renderer.STATE_DISABLED) {
+      TrackSelectorResult trackSelectorResult = playingPeriodHolder.getTrackSelectorResult();
       RendererConfiguration rendererConfiguration =
-          playingPeriodHolder.trackSelectorResult.rendererConfigurations[rendererIndex];
-      TrackSelection newSelection = playingPeriodHolder.trackSelectorResult.selections.get(
-          rendererIndex);
+          trackSelectorResult.rendererConfigurations[rendererIndex];
+      TrackSelection newSelection = trackSelectorResult.selections.get(rendererIndex);
       Format[] formats = getFormats(newSelection);
       // The renderer needs enabling with its new track selection.
       boolean playing = playWhenReady && playbackInfo.playbackState == Player.STATE_READY;
@@ -1669,8 +1762,8 @@ private void enableRenderer(
 
   private boolean rendererWaitingForNextStream(Renderer renderer) {
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
-    return readingPeriodHolder.next != null && readingPeriodHolder.next.prepared
-        && renderer.hasReadStreamToEnd();
+    MediaPeriodHolder nextPeriodHolder = readingPeriodHolder.getNext();
+    return nextPeriodHolder != null && nextPeriodHolder.prepared && renderer.hasReadStreamToEnd();
   }
 
   private void handleLoadingMediaPeriodChanged(boolean loadingTrackSelectionChanged) {
@@ -1691,7 +1784,8 @@ private void handleLoadingMediaPeriodChanged(boolean loadingTrackSelectionChange
         && loadingMediaPeriodHolder != null
         && loadingMediaPeriodHolder.prepared) {
       updateLoadControlTrackSelection(
-          loadingMediaPeriodHolder.trackGroups, loadingMediaPeriodHolder.trackSelectorResult);
+          loadingMediaPeriodHolder.getTrackGroups(),
+          loadingMediaPeriodHolder.getTrackSelectorResult());
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 792f6cf651..72760db31b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.9.3";
+  public static final String VERSION = "2.10.0";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.3";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.0";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2009003;
+  public static final int VERSION_INT = 2010000;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 3456fc39a2..dcb7a83dca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -17,7 +17,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -48,7 +48,10 @@
   public final @Nullable String id;
   /** The human readable label, or null if unknown or not applicable. */
   public final @Nullable String label;
-
+  /** Track selection flags. */
+  @C.SelectionFlags public final int selectionFlags;
+  /** Track role flags. */
+  @C.RoleFlags public final int roleFlags;
   /**
    * The average bandwidth in bits per second, or {@link #NO_VALUE} if unknown or not applicable.
    */
@@ -153,15 +156,8 @@
 
   // Audio and text specific.
 
-  /**
-   * Track selection flags.
-   */
-  @C.SelectionFlags
-  public final int selectionFlags;
-
-  /** The language, or null if unknown or not applicable. */
+  /** The language as an IETF BCP 47 conformant tag, or null if unknown or not applicable. */
   public final @Nullable String language;
-
   /**
    * The Accessibility channel, or {@link #NO_VALUE} if not known or applicable.
    */
@@ -195,7 +191,8 @@ public static Format createVideoContainerFormat(
         height,
         frameRate,
         initializationData,
-        selectionFlags);
+        selectionFlags,
+        /* roleFlags= */ 0);
   }
 
   public static Format createVideoContainerFormat(
@@ -209,15 +206,22 @@ public static Format createVideoContainerFormat(
       int height,
       float frameRate,
       @Nullable List<byte[]> initializationData,
-      @C.SelectionFlags int selectionFlags) {
+      @C.SelectionFlags int selectionFlags,
+      @C.RoleFlags int roleFlags) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        initializationData,
+        /* drmInitData= */ null,
+        OFFSET_SAMPLE_RELATIVE,
         width,
         height,
         frameRate,
@@ -231,13 +235,8 @@ public static Format createVideoContainerFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        selectionFlags,
         /* language= */ null,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        initializationData,
-        /* drmInitData= */ null,
-        /* metadata= */ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   public static Format createVideoSampleFormat(
@@ -316,11 +315,17 @@ public static Format createVideoSampleFormat(
     return new Format(
         id,
         /* label= */ null,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         /* containerMimeType= */ null,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        OFFSET_SAMPLE_RELATIVE,
         width,
         height,
         frameRate,
@@ -334,13 +339,8 @@ public static Format createVideoSampleFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        /* selectionFlags= */ 0,
         /* language= */ null,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        initializationData,
-        drmInitData,
-        /* metadata= */ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   // Audio.
@@ -368,6 +368,7 @@ public static Format createAudioContainerFormat(
         sampleRate,
         initializationData,
         selectionFlags,
+        /* roleFlags= */ 0,
         language);
   }
 
@@ -382,15 +383,22 @@ public static Format createAudioContainerFormat(
       int sampleRate,
       @Nullable List<byte[]> initializationData,
       @C.SelectionFlags int selectionFlags,
+      @C.RoleFlags int roleFlags,
       @Nullable String language) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        initializationData,
+        /* drmInitData= */ null,
+        OFFSET_SAMPLE_RELATIVE,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -404,13 +412,8 @@ public static Format createAudioContainerFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        selectionFlags,
         language,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        initializationData,
-        /* drmInitData= */ null,
-        /* metadata= */ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   public static Format createAudioSampleFormat(
@@ -490,11 +493,17 @@ public static Format createAudioSampleFormat(
     return new Format(
         id,
         /* label= */ null,
+        selectionFlags,
+        /* roleFlags= */ 0,
+        bitrate,
+        codecs,
+        metadata,
         /* containerMimeType= */ null,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        OFFSET_SAMPLE_RELATIVE,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -508,37 +517,12 @@ public static Format createAudioSampleFormat(
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        initializationData,
-        drmInitData,
-        metadata);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   // Text.
 
-  @Deprecated
-  public static Format createTextContainerFormat(
-      @Nullable String id,
-      @Nullable String containerMimeType,
-      @Nullable String sampleMimeType,
-      @Nullable String codecs,
-      int bitrate,
-      @C.SelectionFlags int selectionFlags,
-      @Nullable String language) {
-    return createTextContainerFormat(
-        id,
-        /* label= */ null,
-        containerMimeType,
-        sampleMimeType,
-        codecs,
-        bitrate,
-        selectionFlags,
-        language);
-  }
-
   public static Format createTextContainerFormat(
       @Nullable String id,
       @Nullable String label,
@@ -547,6 +531,7 @@ public static Format createTextContainerFormat(
       @Nullable String codecs,
       int bitrate,
       @C.SelectionFlags int selectionFlags,
+      @C.RoleFlags int roleFlags,
       @Nullable String language) {
     return createTextContainerFormat(
         id,
@@ -556,6 +541,7 @@ public static Format createTextContainerFormat(
         codecs,
         bitrate,
         selectionFlags,
+        roleFlags,
         language,
         /* accessibilityChannel= */ NO_VALUE);
   }
@@ -568,16 +554,23 @@ public static Format createTextContainerFormat(
       @Nullable String codecs,
       int bitrate,
       @C.SelectionFlags int selectionFlags,
+      @C.RoleFlags int roleFlags,
       @Nullable String language,
       int accessibilityChannel) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        OFFSET_SAMPLE_RELATIVE,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -591,13 +584,8 @@ public static Format createTextContainerFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        OFFSET_SAMPLE_RELATIVE,
-        /* initializationData= */ null,
-        /* drmInitData= */ null,
-        /* metadata= */ null);
+        accessibilityChannel);
   }
 
   public static Format createTextSampleFormat(
@@ -685,11 +673,17 @@ public static Format createTextSampleFormat(
     return new Format(
         id,
         /* label= */ null,
+        selectionFlags,
+        /* roleFlags= */ 0,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         /* containerMimeType= */ null,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -703,13 +697,8 @@ public static Format createTextSampleFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        /* metadata= */ null);
+        accessibilityChannel);
   }
 
   // Image.
@@ -726,11 +715,17 @@ public static Format createImageSampleFormat(
     return new Format(
         id,
         /* label= */ null,
+        selectionFlags,
+        /* roleFlags= */ 0,
+        bitrate,
+        codecs,
+        /* metadata=*/ null,
         /* containerMimeType= */ null,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        initializationData,
+        drmInitData,
+        OFFSET_SAMPLE_RELATIVE,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -744,13 +739,8 @@ public static Format createImageSampleFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        selectionFlags,
         language,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        initializationData,
-        drmInitData,
-        /* metadata=*/ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   // Generic.
@@ -772,6 +762,7 @@ public static Format createContainerFormat(
         codecs,
         bitrate,
         selectionFlags,
+        /* roleFlags= */ 0,
         language);
   }
 
@@ -783,15 +774,22 @@ public static Format createContainerFormat(
       @Nullable String codecs,
       int bitrate,
       @C.SelectionFlags int selectionFlags,
+      @C.RoleFlags int roleFlags,
       @Nullable String language) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        OFFSET_SAMPLE_RELATIVE,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -805,13 +803,8 @@ public static Format createContainerFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        selectionFlags,
         language,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        /* initializationData= */ null,
-        /* drmInitData= */ null,
-        /* metadata= */ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   public static Format createSampleFormat(
@@ -819,11 +812,17 @@ public static Format createSampleFormat(
     return new Format(
         id,
         /* label= */ null,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        /* bitrate= */ NO_VALUE,
+        /* codecs= */ null,
+        /* metadata= */ null,
         /* containerMimeType= */ null,
         sampleMimeType,
-        /* codecs= */ null,
-        /* bitrate= */ NO_VALUE,
         /* maxInputSize= */ NO_VALUE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        subsampleOffsetUs,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -837,13 +836,8 @@ public static Format createSampleFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        /* selectionFlags= */ 0,
         /* language= */ null,
-        /* accessibilityChannel= */ NO_VALUE,
-        subsampleOffsetUs,
-        /* initializationData= */ null,
-        /* drmInitData= */ null,
-        /* metadata= */ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   public static Format createSampleFormat(
@@ -855,11 +849,17 @@ public static Format createSampleFormat(
     return new Format(
         id,
         /* label= */ null,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        bitrate,
+        codecs,
+        /* metadata= */ null,
         /* containerMimeType= */ null,
         sampleMimeType,
-        codecs,
-        bitrate,
         /* maxInputSize= */ NO_VALUE,
+        /* initializationData= */ null,
+        drmInitData,
+        OFFSET_SAMPLE_RELATIVE,
         /* width= */ NO_VALUE,
         /* height= */ NO_VALUE,
         /* frameRate= */ NO_VALUE,
@@ -873,23 +873,27 @@ public static Format createSampleFormat(
         /* pcmEncoding= */ NO_VALUE,
         /* encoderDelay= */ NO_VALUE,
         /* encoderPadding= */ NO_VALUE,
-        /* selectionFlags= */ 0,
         /* language= */ null,
-        /* accessibilityChannel= */ NO_VALUE,
-        OFFSET_SAMPLE_RELATIVE,
-        /* initializationData= */ null,
-        drmInitData,
-        /* metadata= */ null);
+        /* accessibilityChannel= */ NO_VALUE);
   }
 
   /* package */ Format(
       @Nullable String id,
       @Nullable String label,
+      @C.SelectionFlags int selectionFlags,
+      @C.RoleFlags int roleFlags,
+      int bitrate,
+      @Nullable String codecs,
+      @Nullable Metadata metadata,
+      // Container specific.
       @Nullable String containerMimeType,
+      // Elementary stream specific.
       @Nullable String sampleMimeType,
-      @Nullable String codecs,
-      int bitrate,
       int maxInputSize,
+      @Nullable List<byte[]> initializationData,
+      @Nullable DrmInitData drmInitData,
+      long subsampleOffsetUs,
+      // Video specific.
       int width,
       int height,
       float frameRate,
@@ -898,25 +902,32 @@ public static Format createSampleFormat(
       @Nullable byte[] projectionData,
       @C.StereoMode int stereoMode,
       @Nullable ColorInfo colorInfo,
+      // Audio specific.
       int channelCount,
       int sampleRate,
       @C.PcmEncoding int pcmEncoding,
       int encoderDelay,
       int encoderPadding,
-      @C.SelectionFlags int selectionFlags,
+      // Audio and text specific.
       @Nullable String language,
-      int accessibilityChannel,
-      long subsampleOffsetUs,
-      @Nullable List<byte[]> initializationData,
-      @Nullable DrmInitData drmInitData,
-      @Nullable Metadata metadata) {
+      int accessibilityChannel) {
     this.id = id;
     this.label = label;
+    this.selectionFlags = selectionFlags;
+    this.roleFlags = roleFlags;
+    this.bitrate = bitrate;
+    this.codecs = codecs;
+    this.metadata = metadata;
+    // Container specific.
     this.containerMimeType = containerMimeType;
+    // Elementary stream specific.
     this.sampleMimeType = sampleMimeType;
-    this.codecs = codecs;
-    this.bitrate = bitrate;
     this.maxInputSize = maxInputSize;
+    this.initializationData =
+        initializationData == null ? Collections.emptyList() : initializationData;
+    this.drmInitData = drmInitData;
+    this.subsampleOffsetUs = subsampleOffsetUs;
+    // Video specific.
     this.width = width;
     this.height = height;
     this.frameRate = frameRate;
@@ -926,30 +937,39 @@ public static Format createSampleFormat(
     this.projectionData = projectionData;
     this.stereoMode = stereoMode;
     this.colorInfo = colorInfo;
+    // Audio specific.
     this.channelCount = channelCount;
     this.sampleRate = sampleRate;
     this.pcmEncoding = pcmEncoding;
     this.encoderDelay = encoderDelay == Format.NO_VALUE ? 0 : encoderDelay;
     this.encoderPadding = encoderPadding == Format.NO_VALUE ? 0 : encoderPadding;
-    this.selectionFlags = selectionFlags;
-    this.language = language;
+    // Audio and text specific.
+    this.language = Util.normalizeLanguageCode(language);
     this.accessibilityChannel = accessibilityChannel;
-    this.subsampleOffsetUs = subsampleOffsetUs;
-    this.initializationData =
-        initializationData == null ? Collections.emptyList() : initializationData;
-    this.drmInitData = drmInitData;
-    this.metadata = metadata;
   }
 
   @SuppressWarnings("ResourceType")
   /* package */ Format(Parcel in) {
     id = in.readString();
     label = in.readString();
+    selectionFlags = in.readInt();
+    roleFlags = in.readInt();
+    bitrate = in.readInt();
+    codecs = in.readString();
+    metadata = in.readParcelable(Metadata.class.getClassLoader());
+    // Container specific.
     containerMimeType = in.readString();
+    // Elementary stream specific.
     sampleMimeType = in.readString();
-    codecs = in.readString();
-    bitrate = in.readInt();
     maxInputSize = in.readInt();
+    int initializationDataSize = in.readInt();
+    initializationData = new ArrayList<>(initializationDataSize);
+    for (int i = 0; i < initializationDataSize; i++) {
+      initializationData.add(in.createByteArray());
+    }
+    drmInitData = in.readParcelable(DrmInitData.class.getClassLoader());
+    subsampleOffsetUs = in.readLong();
+    // Video specific.
     width = in.readInt();
     height = in.readInt();
     frameRate = in.readFloat();
@@ -959,33 +979,32 @@ public static Format createSampleFormat(
     projectionData = hasProjectionData ? in.createByteArray() : null;
     stereoMode = in.readInt();
     colorInfo = in.readParcelable(ColorInfo.class.getClassLoader());
+    // Audio specific.
     channelCount = in.readInt();
     sampleRate = in.readInt();
     pcmEncoding = in.readInt();
     encoderDelay = in.readInt();
     encoderPadding = in.readInt();
-    selectionFlags = in.readInt();
+    // Audio and text specific.
     language = in.readString();
     accessibilityChannel = in.readInt();
-    subsampleOffsetUs = in.readLong();
-    int initializationDataSize = in.readInt();
-    initializationData = new ArrayList<>(initializationDataSize);
-    for (int i = 0; i < initializationDataSize; i++) {
-      initializationData.add(in.createByteArray());
-    }
-    drmInitData = in.readParcelable(DrmInitData.class.getClassLoader());
-    metadata = in.readParcelable(Metadata.class.getClassLoader());
   }
 
   public Format copyWithMaxInputSize(int maxInputSize) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -999,24 +1018,25 @@ public Format copyWithMaxInputSize(int maxInputSize) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        metadata);
+        accessibilityChannel);
   }
 
   public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1030,13 +1050,8 @@ public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        metadata);
+        accessibilityChannel);
   }
 
   public Format copyWithContainerInfo(
@@ -1044,19 +1059,32 @@ public Format copyWithContainerInfo(
       @Nullable String label,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
+      @Nullable Metadata metadata,
       int bitrate,
       int width,
       int height,
+      int channelCount,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
+
+    if (this.metadata != null) {
+      metadata = this.metadata.copyWithAppendedEntriesFrom(metadata);
+    }
+
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1070,13 +1098,8 @@ public Format copyWithContainerInfo(
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        metadata);
+        accessibilityChannel);
   }
 
   @SuppressWarnings("ReferenceEquality")
@@ -1110,6 +1133,12 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
         codecs = codecsOfType;
       }
     }
+
+    Metadata metadata =
+        this.metadata == null
+            ? manifestFormat.metadata
+            : this.metadata.copyWithAppendedEntriesFrom(manifestFormat.metadata);
+
     float frameRate = this.frameRate;
     if (frameRate == NO_VALUE && trackType == C.TRACK_TYPE_VIDEO) {
       frameRate = manifestFormat.frameRate;
@@ -1117,17 +1146,24 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
 
     // Merge manifest and sample format values.
     @C.SelectionFlags int selectionFlags = this.selectionFlags | manifestFormat.selectionFlags;
+    @C.RoleFlags int roleFlags = this.roleFlags | manifestFormat.roleFlags;
     DrmInitData drmInitData =
         DrmInitData.createSessionCreationData(manifestFormat.drmInitData, this.drmInitData);
 
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1141,24 +1177,25 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        metadata);
+        accessibilityChannel);
   }
 
   public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1172,24 +1209,57 @@ public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
+        accessibilityChannel);
+  }
+
+  public Format copyWithFrameRate(float frameRate) {
+    return new Format(
+        id,
+        label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
+        containerMimeType,
+        sampleMimeType,
+        maxInputSize,
         initializationData,
         drmInitData,
-        metadata);
+        subsampleOffsetUs,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        language,
+        accessibilityChannel);
   }
 
   public Format copyWithDrmInitData(@Nullable DrmInitData drmInitData) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1203,24 +1273,25 @@ public Format copyWithDrmInitData(@Nullable DrmInitData drmInitData) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        metadata);
+        accessibilityChannel);
   }
 
   public Format copyWithMetadata(@Nullable Metadata metadata) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1234,24 +1305,25 @@ public Format copyWithMetadata(@Nullable Metadata metadata) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
-        initializationData,
-        drmInitData,
-        metadata);
+        accessibilityChannel);
   }
 
   public Format copyWithRotationDegrees(int rotationDegrees) {
     return new Format(
         id,
         label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
         containerMimeType,
         sampleMimeType,
-        codecs,
-        bitrate,
         maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
         width,
         height,
         frameRate,
@@ -1265,13 +1337,40 @@ public Format copyWithRotationDegrees(int rotationDegrees) {
         pcmEncoding,
         encoderDelay,
         encoderPadding,
-        selectionFlags,
         language,
-        accessibilityChannel,
-        subsampleOffsetUs,
+        accessibilityChannel);
+  }
+
+  public Format copyWithBitrate(int bitrate) {
+    return new Format(
+        id,
+        label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
+        containerMimeType,
+        sampleMimeType,
+        maxInputSize,
         initializationData,
         drmInitData,
-        metadata);
+        subsampleOffsetUs,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        language,
+        accessibilityChannel);
   }
 
   /**
@@ -1315,32 +1414,41 @@ public String toString() {
   @Override
   public int hashCode() {
     if (hashCode == 0) {
+      // Some fields for which hashing is expensive are deliberately omitted.
       int result = 17;
       result = 31 * result + (id == null ? 0 : id.hashCode());
-      result = 31 * result + (containerMimeType == null ? 0 : containerMimeType.hashCode());
-      result = 31 * result + (sampleMimeType == null ? 0 : sampleMimeType.hashCode());
-      result = 31 * result + (codecs == null ? 0 : codecs.hashCode());
+      result = 31 * result + (label != null ? label.hashCode() : 0);
+      result = 31 * result + selectionFlags;
+      result = 31 * result + roleFlags;
       result = 31 * result + bitrate;
-      result = 31 * result + width;
-      result = 31 * result + height;
-      result = 31 * result + channelCount;
-      result = 31 * result + sampleRate;
-      result = 31 * result + (language == null ? 0 : language.hashCode());
-      result = 31 * result + accessibilityChannel;
-      result = 31 * result + (drmInitData == null ? 0 : drmInitData.hashCode());
+      result = 31 * result + (codecs == null ? 0 : codecs.hashCode());
       result = 31 * result + (metadata == null ? 0 : metadata.hashCode());
-      result = 31 * result + (label != null ? label.hashCode() : 0);
+      // Container specific.
+      result = 31 * result + (containerMimeType == null ? 0 : containerMimeType.hashCode());
+      // Elementary stream specific.
+      result = 31 * result + (sampleMimeType == null ? 0 : sampleMimeType.hashCode());
       result = 31 * result + maxInputSize;
+      // [Omitted] initializationData.
+      // [Omitted] drmInitData.
       result = 31 * result + (int) subsampleOffsetUs;
+      // Video specific.
+      result = 31 * result + width;
+      result = 31 * result + height;
       result = 31 * result + Float.floatToIntBits(frameRate);
-      result = 31 * result + Float.floatToIntBits(pixelWidthHeightRatio);
       result = 31 * result + rotationDegrees;
+      result = 31 * result + Float.floatToIntBits(pixelWidthHeightRatio);
+      // [Omitted] projectionData.
       result = 31 * result + stereoMode;
+      // [Omitted] colorInfo.
+      // Audio specific.
+      result = 31 * result + channelCount;
+      result = 31 * result + sampleRate;
       result = 31 * result + pcmEncoding;
       result = 31 * result + encoderDelay;
       result = 31 * result + encoderPadding;
-      result = 31 * result + selectionFlags;
-      // Not all of the fields are included to keep the calculation quick enough.
+      // Audio and text specific.
+      result = 31 * result + (language == null ? 0 : language.hashCode());
+      result = 31 * result + accessibilityChannel;
       hashCode = result;
     }
     return hashCode;
@@ -1358,32 +1466,34 @@ public boolean equals(@Nullable Object obj) {
     if (hashCode != 0 && other.hashCode != 0 && hashCode != other.hashCode) {
       return false;
     }
-    return bitrate == other.bitrate
+    // Field equality checks ordered by type, with the cheapest checks first.
+    return selectionFlags == other.selectionFlags
+        && roleFlags == other.roleFlags
+        && bitrate == other.bitrate
         && maxInputSize == other.maxInputSize
+        && subsampleOffsetUs == other.subsampleOffsetUs
         && width == other.width
         && height == other.height
-        && Float.compare(frameRate, other.frameRate) == 0
         && rotationDegrees == other.rotationDegrees
-        && Float.compare(pixelWidthHeightRatio, other.pixelWidthHeightRatio) == 0
         && stereoMode == other.stereoMode
         && channelCount == other.channelCount
         && sampleRate == other.sampleRate
         && pcmEncoding == other.pcmEncoding
         && encoderDelay == other.encoderDelay
         && encoderPadding == other.encoderPadding
-        && subsampleOffsetUs == other.subsampleOffsetUs
-        && selectionFlags == other.selectionFlags
+        && accessibilityChannel == other.accessibilityChannel
+        && Float.compare(frameRate, other.frameRate) == 0
+        && Float.compare(pixelWidthHeightRatio, other.pixelWidthHeightRatio) == 0
         && Util.areEqual(id, other.id)
         && Util.areEqual(label, other.label)
-        && Util.areEqual(language, other.language)
-        && accessibilityChannel == other.accessibilityChannel
+        && Util.areEqual(codecs, other.codecs)
         && Util.areEqual(containerMimeType, other.containerMimeType)
         && Util.areEqual(sampleMimeType, other.sampleMimeType)
-        && Util.areEqual(codecs, other.codecs)
-        && Util.areEqual(drmInitData, other.drmInitData)
+        && Util.areEqual(language, other.language)
+        && Arrays.equals(projectionData, other.projectionData)
         && Util.areEqual(metadata, other.metadata)
         && Util.areEqual(colorInfo, other.colorInfo)
-        && Arrays.equals(projectionData, other.projectionData)
+        && Util.areEqual(drmInitData, other.drmInitData)
         && initializationDataEquals(other);
   }
 
@@ -1454,11 +1564,24 @@ public int describeContents() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(id);
     dest.writeString(label);
+    dest.writeInt(selectionFlags);
+    dest.writeInt(roleFlags);
+    dest.writeInt(bitrate);
+    dest.writeString(codecs);
+    dest.writeParcelable(metadata, 0);
+    // Container specific.
     dest.writeString(containerMimeType);
+    // Elementary stream specific.
     dest.writeString(sampleMimeType);
-    dest.writeString(codecs);
-    dest.writeInt(bitrate);
     dest.writeInt(maxInputSize);
+    int initializationDataSize = initializationData.size();
+    dest.writeInt(initializationDataSize);
+    for (int i = 0; i < initializationDataSize; i++) {
+      dest.writeByteArray(initializationData.get(i));
+    }
+    dest.writeParcelable(drmInitData, 0);
+    dest.writeLong(subsampleOffsetUs);
+    // Video specific.
     dest.writeInt(width);
     dest.writeInt(height);
     dest.writeFloat(frameRate);
@@ -1470,22 +1593,15 @@ public void writeToParcel(Parcel dest, int flags) {
     }
     dest.writeInt(stereoMode);
     dest.writeParcelable(colorInfo, flags);
+    // Audio specific.
     dest.writeInt(channelCount);
     dest.writeInt(sampleRate);
     dest.writeInt(pcmEncoding);
     dest.writeInt(encoderDelay);
     dest.writeInt(encoderPadding);
-    dest.writeInt(selectionFlags);
+    // Audio and text specific.
     dest.writeString(language);
     dest.writeInt(accessibilityChannel);
-    dest.writeLong(subsampleOffsetUs);
-    int initializationDataSize = initializationData.size();
-    dest.writeInt(initializationDataSize);
-    for (int i = 0; i < initializationDataSize; i++) {
-      dest.writeByteArray(initializationData.get(i));
-    }
-    dest.writeParcelable(drmInitData, 0);
-    dest.writeParcelable(metadata, 0);
   }
 
   public static final Creator<Format> CREATOR = new Creator<Format>() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java
index 8c7ba1eb91..5da8d0f9f5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/FormatHolder.java
@@ -15,13 +15,25 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.drm.DecryptionResource;
 
 /**
  * Holds a {@link Format}.
  */
 public final class FormatHolder {
 
+  /**
+   * Whether the object expected to populate {@link #format} is also expected to populate {@link
+   * #decryptionResource}.
+   */
+  // TODO: Remove once all Renderers and MediaSources have migrated to the new DRM model [Internal
+  // ref: b/129764794].
+  public boolean decryptionResourceIsProvided;
+
+  /** An accompanying context for decrypting samples in the format. */
+  @Nullable public DecryptionResource<?> decryptionResource;
+
   /** The held {@link Format}. */
-  public @Nullable Format format;
+  @Nullable public Format format;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 5925c8f383..5950bc627f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -15,10 +15,12 @@
  */
 package com.google.android.exoplayer2;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.ClippingMediaPeriod;
 import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -28,30 +30,38 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** Holds a {@link MediaPeriod} with information required to play it as part of a timeline. */
 /* package */ final class MediaPeriodHolder {
 
   private static final String TAG = "MediaPeriodHolder";
 
+  /** The {@link MediaPeriod} wrapped by this class. */
   public final MediaPeriod mediaPeriod;
+  /** The unique timeline period identifier the media period belongs to. */
   public final Object uid;
-  public final SampleStream[] sampleStreams;
-  public final boolean[] mayRetainStreamFlags;
+  /**
+   * The sample streams for each renderer associated with this period. May contain null elements.
+   */
+  public final @NullableType SampleStream[] sampleStreams;
 
+  /** Whether the media period has finished preparing. */
   public boolean prepared;
+  /** Whether any of the tracks of this media period are enabled. */
   public boolean hasEnabledTracks;
+  /** {@link MediaPeriodInfo} about this media period. */
   public MediaPeriodInfo info;
-  public MediaPeriodHolder next;
-  public TrackGroupArray trackGroups;
-  public TrackSelectorResult trackSelectorResult;
 
+  private final boolean[] mayRetainStreamFlags;
   private final RendererCapabilities[] rendererCapabilities;
   private final TrackSelector trackSelector;
   private final MediaSource mediaSource;
 
+  @Nullable private MediaPeriodHolder next;
+  @Nullable private TrackGroupArray trackGroups;
+  @Nullable private TrackSelectorResult trackSelectorResult;
   private long rendererPositionOffsetUs;
-  private TrackSelectorResult periodTrackSelectorResult;
 
   /**
    * Creates a new holder with information required to play it as part of a timeline.
@@ -75,47 +85,47 @@ public MediaPeriodHolder(
     this.rendererPositionOffsetUs = rendererPositionOffsetUs - info.startPositionUs;
     this.trackSelector = trackSelector;
     this.mediaSource = mediaSource;
-    this.uid = Assertions.checkNotNull(info.id.periodUid);
+    this.uid = info.id.periodUid;
     this.info = info;
     sampleStreams = new SampleStream[rendererCapabilities.length];
     mayRetainStreamFlags = new boolean[rendererCapabilities.length];
-    MediaPeriod mediaPeriod = mediaSource.createPeriod(info.id, allocator);
-    if (info.id.endPositionUs != C.TIME_END_OF_SOURCE) {
-      mediaPeriod =
-          new ClippingMediaPeriod(
-              mediaPeriod,
-              /* enableInitialDiscontinuity= */ true,
-              /* startUs= */ 0,
-              info.id.endPositionUs);
-    }
-    this.mediaPeriod = mediaPeriod;
+    mediaPeriod =
+        createMediaPeriod(
+            info.id, mediaSource, allocator, info.startPositionUs, info.endPositionUs);
   }
 
+  /**
+   * Converts time relative to the start of the period to the respective renderer time using {@link
+   * #getRendererOffset()}, in microseconds.
+   */
   public long toRendererTime(long periodTimeUs) {
     return periodTimeUs + getRendererOffset();
   }
 
+  /**
+   * Converts renderer time to the respective time relative to the start of the period using {@link
+   * #getRendererOffset()}, in microseconds.
+   */
   public long toPeriodTime(long rendererTimeUs) {
     return rendererTimeUs - getRendererOffset();
   }
 
+  /** Returns the renderer time of the start of the period, in microseconds. */
   public long getRendererOffset() {
     return rendererPositionOffsetUs;
   }
 
+  /** Returns start position of period in renderer time. */
   public long getStartPositionRendererTime() {
     return info.startPositionUs + rendererPositionOffsetUs;
   }
 
+  /** Returns whether the period is fully buffered. */
   public boolean isFullyBuffered() {
     return prepared
         && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
   }
 
-  public long getDurationUs() {
-    return info.durationUs;
-  }
-
   /**
    * Returns the buffered position in microseconds. If the period is buffered to the end, then the
    * period duration is returned.
@@ -131,63 +141,132 @@ public long getBufferedPositionUs() {
     return bufferedPositionUs == C.TIME_END_OF_SOURCE ? info.durationUs : bufferedPositionUs;
   }
 
+  /**
+   * Returns the next load time relative to the start of the period, or {@link C#TIME_END_OF_SOURCE}
+   * if loading has finished.
+   */
   public long getNextLoadPositionUs() {
     return !prepared ? 0 : mediaPeriod.getNextLoadPositionUs();
   }
 
-  public void handlePrepared(float playbackSpeed) throws ExoPlaybackException {
+  /**
+   * Handles period preparation.
+   *
+   * @param playbackSpeed The current playback speed.
+   * @param timeline The current {@link Timeline}.
+   * @throws ExoPlaybackException If an error occurs during track selection.
+   */
+  public void handlePrepared(float playbackSpeed, Timeline timeline) throws ExoPlaybackException {
     prepared = true;
     trackGroups = mediaPeriod.getTrackGroups();
-    selectTracks(playbackSpeed);
-    long newStartPositionUs = applyTrackSelection(info.startPositionUs, false);
+    TrackSelectorResult selectorResult =
+        Assertions.checkNotNull(selectTracks(playbackSpeed, timeline));
+    long newStartPositionUs =
+        applyTrackSelection(
+            selectorResult, info.startPositionUs, /* forceRecreateStreams= */ false);
     rendererPositionOffsetUs += info.startPositionUs - newStartPositionUs;
     info = info.copyWithStartPositionUs(newStartPositionUs);
   }
 
+  /**
+   * Reevaluates the buffer of the media period at the given renderer position. Should only be
+   * called if this is the loading media period.
+   *
+   * @param rendererPositionUs The playing position in renderer time, in microseconds.
+   */
   public void reevaluateBuffer(long rendererPositionUs) {
+    Assertions.checkState(isLoadingMediaPeriod());
     if (prepared) {
       mediaPeriod.reevaluateBuffer(toPeriodTime(rendererPositionUs));
     }
   }
 
+  /**
+   * Continues loading the media period at the given renderer position. Should only be called if
+   * this is the loading media period.
+   *
+   * @param rendererPositionUs The load position in renderer time, in microseconds.
+   */
   public void continueLoading(long rendererPositionUs) {
+    Assertions.checkState(isLoadingMediaPeriod());
     long loadingPeriodPositionUs = toPeriodTime(rendererPositionUs);
     mediaPeriod.continueLoading(loadingPeriodPositionUs);
   }
 
-  public boolean selectTracks(float playbackSpeed) throws ExoPlaybackException {
+  /**
+   * Selects tracks for the period and returns the new result if the selection changed. Must only be
+   * called if {@link #prepared} is {@code true}.
+   *
+   * @param playbackSpeed The current playback speed.
+   * @param timeline The current {@link Timeline}.
+   * @return The {@link TrackSelectorResult} if the result changed. Or null if nothing changed.
+   * @throws ExoPlaybackException If an error occurs during track selection.
+   */
+  @Nullable
+  public TrackSelectorResult selectTracks(float playbackSpeed, Timeline timeline)
+      throws ExoPlaybackException {
     TrackSelectorResult selectorResult =
-        trackSelector.selectTracks(rendererCapabilities, trackGroups);
-    if (selectorResult.isEquivalent(periodTrackSelectorResult)) {
-      return false;
+        trackSelector.selectTracks(rendererCapabilities, getTrackGroups(), info.id, timeline);
+    if (selectorResult.isEquivalent(trackSelectorResult)) {
+      return null;
     }
-    trackSelectorResult = selectorResult;
-    for (TrackSelection trackSelection : trackSelectorResult.selections.getAll()) {
+    for (TrackSelection trackSelection : selectorResult.selections.getAll()) {
       if (trackSelection != null) {
         trackSelection.onPlaybackSpeed(playbackSpeed);
       }
     }
-    return true;
+    return selectorResult;
   }
 
-  public long applyTrackSelection(long positionUs, boolean forceRecreateStreams) {
+  /**
+   * Applies a {@link TrackSelectorResult} to the period.
+   *
+   * @param trackSelectorResult The {@link TrackSelectorResult} to apply.
+   * @param positionUs The position relative to the start of the period at which to apply the new
+   *     track selections, in microseconds.
+   * @param forceRecreateStreams Whether all streams are forced to be recreated.
+   * @return The actual position relative to the start of the period at which the new track
+   *     selections are applied.
+   */
+  public long applyTrackSelection(
+      TrackSelectorResult trackSelectorResult, long positionUs, boolean forceRecreateStreams) {
     return applyTrackSelection(
-        positionUs, forceRecreateStreams, new boolean[rendererCapabilities.length]);
+        trackSelectorResult,
+        positionUs,
+        forceRecreateStreams,
+        new boolean[rendererCapabilities.length]);
   }
 
+  /**
+   * Applies a {@link TrackSelectorResult} to the period.
+   *
+   * @param newTrackSelectorResult The {@link TrackSelectorResult} to apply.
+   * @param positionUs The position relative to the start of the period at which to apply the new
+   *     track selections, in microseconds.
+   * @param forceRecreateStreams Whether all streams are forced to be recreated.
+   * @param streamResetFlags Will be populated to indicate which streams have been reset or were
+   *     newly created.
+   * @return The actual position relative to the start of the period at which the new track
+   *     selections are applied.
+   */
   public long applyTrackSelection(
-      long positionUs, boolean forceRecreateStreams, boolean[] streamResetFlags) {
-    for (int i = 0; i < trackSelectorResult.length; i++) {
+      TrackSelectorResult newTrackSelectorResult,
+      long positionUs,
+      boolean forceRecreateStreams,
+      boolean[] streamResetFlags) {
+    for (int i = 0; i < newTrackSelectorResult.length; i++) {
       mayRetainStreamFlags[i] =
-          !forceRecreateStreams && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
+          !forceRecreateStreams && newTrackSelectorResult.isEquivalent(trackSelectorResult, i);
     }
 
     // Undo the effect of previous call to associate no-sample renderers with empty tracks
     // so the mediaPeriod receives back whatever it sent us before.
     disassociateNoSampleRenderersWithEmptySampleStream(sampleStreams);
-    updatePeriodTrackSelectorResult(trackSelectorResult);
+    disableTrackSelectionsInResult();
+    trackSelectorResult = newTrackSelectorResult;
+    enableTrackSelectionsInResult();
     // Disable streams on the period and get new streams for updated/newly-enabled tracks.
-    TrackSelectionArray trackSelections = trackSelectorResult.selections;
+    TrackSelectionArray trackSelections = newTrackSelectorResult.selections;
     positionUs =
         mediaPeriod.selectTracks(
             trackSelections.getAll(),
@@ -201,7 +280,7 @@ public long applyTrackSelection(
     hasEnabledTracks = false;
     for (int i = 0; i < sampleStreams.length; i++) {
       if (sampleStreams[i] != null) {
-        Assertions.checkState(trackSelectorResult.isRendererEnabled(i));
+        Assertions.checkState(newTrackSelectorResult.isRendererEnabled(i));
         // hasEnabledTracks should be true only when non-empty streams exists.
         if (rendererCapabilities[i].getTrackType() != C.TRACK_TYPE_NONE) {
           hasEnabledTracks = true;
@@ -213,31 +292,58 @@ public long applyTrackSelection(
     return positionUs;
   }
 
+  /** Releases the media period. No other method should be called after the release. */
   public void release() {
-    updatePeriodTrackSelectorResult(null);
-    try {
-      if (info.id.endPositionUs != C.TIME_END_OF_SOURCE) {
-        mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
-      } else {
-        mediaSource.releasePeriod(mediaPeriod);
-      }
-    } catch (RuntimeException e) {
-      // There's nothing we can do.
-      Log.e(TAG, "Period release failed.", e);
-    }
+    disableTrackSelectionsInResult();
+    trackSelectorResult = null;
+    releaseMediaPeriod(info.endPositionUs, mediaSource, mediaPeriod);
   }
 
-  private void updatePeriodTrackSelectorResult(TrackSelectorResult trackSelectorResult) {
-    if (periodTrackSelectorResult != null) {
-      disableTrackSelectionsInResult(periodTrackSelectorResult);
-    }
-    periodTrackSelectorResult = trackSelectorResult;
-    if (periodTrackSelectorResult != null) {
-      enableTrackSelectionsInResult(periodTrackSelectorResult);
+  /**
+   * Sets the next media period holder in the queue.
+   *
+   * @param nextMediaPeriodHolder The next holder, or null if this will be the new loading media
+   *     period holder at the end of the queue.
+   */
+  public void setNext(@Nullable MediaPeriodHolder nextMediaPeriodHolder) {
+    if (nextMediaPeriodHolder == next) {
+      return;
     }
+    disableTrackSelectionsInResult();
+    next = nextMediaPeriodHolder;
+    enableTrackSelectionsInResult();
+  }
+
+  /**
+   * Returns the next media period holder in the queue, or null if this is the last media period
+   * (and thus the loading media period).
+   */
+  @Nullable
+  public MediaPeriodHolder getNext() {
+    return next;
   }
 
-  private void enableTrackSelectionsInResult(TrackSelectorResult trackSelectorResult) {
+  /**
+   * Returns the {@link TrackGroupArray} exposed by this media period. Must only be called if {@link
+   * #prepared} is {@code true}.
+   */
+  public TrackGroupArray getTrackGroups() {
+    return Assertions.checkNotNull(trackGroups);
+  }
+
+  /**
+   * Returns the {@link TrackSelectorResult} which is currently applied. Must only be called if
+   * {@link #prepared} is {@code true}.
+   */
+  public TrackSelectorResult getTrackSelectorResult() {
+    return Assertions.checkNotNull(trackSelectorResult);
+  }
+
+  private void enableTrackSelectionsInResult() {
+    TrackSelectorResult trackSelectorResult = this.trackSelectorResult;
+    if (!isLoadingMediaPeriod() || trackSelectorResult == null) {
+      return;
+    }
     for (int i = 0; i < trackSelectorResult.length; i++) {
       boolean rendererEnabled = trackSelectorResult.isRendererEnabled(i);
       TrackSelection trackSelection = trackSelectorResult.selections.get(i);
@@ -247,7 +353,11 @@ private void enableTrackSelectionsInResult(TrackSelectorResult trackSelectorResu
     }
   }
 
-  private void disableTrackSelectionsInResult(TrackSelectorResult trackSelectorResult) {
+  private void disableTrackSelectionsInResult() {
+    TrackSelectorResult trackSelectorResult = this.trackSelectorResult;
+    if (!isLoadingMediaPeriod() || trackSelectorResult == null) {
+      return;
+    }
     for (int i = 0; i < trackSelectorResult.length; i++) {
       boolean rendererEnabled = trackSelectorResult.isRendererEnabled(i);
       TrackSelection trackSelection = trackSelectorResult.selections.get(i);
@@ -261,7 +371,8 @@ private void disableTrackSelectionsInResult(TrackSelectorResult trackSelectorRes
    * For each renderer of type {@link C#TRACK_TYPE_NONE}, we will remove the dummy {@link
    * EmptySampleStream} that was associated with it.
    */
-  private void disassociateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
+  private void disassociateNoSampleRenderersWithEmptySampleStream(
+      @NullableType SampleStream[] sampleStreams) {
     for (int i = 0; i < rendererCapabilities.length; i++) {
       if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE) {
         sampleStreams[i] = null;
@@ -273,7 +384,9 @@ private void disassociateNoSampleRenderersWithEmptySampleStream(SampleStream[] s
    * For each renderer of type {@link C#TRACK_TYPE_NONE} that was enabled, we will associate it with
    * a dummy {@link EmptySampleStream}.
    */
-  private void associateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
+  private void associateNoSampleRenderersWithEmptySampleStream(
+      @NullableType SampleStream[] sampleStreams) {
+    TrackSelectorResult trackSelectorResult = Assertions.checkNotNull(this.trackSelectorResult);
     for (int i = 0; i < rendererCapabilities.length; i++) {
       if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE
           && trackSelectorResult.isRendererEnabled(i)) {
@@ -281,4 +394,39 @@ private void associateNoSampleRenderersWithEmptySampleStream(SampleStream[] samp
       }
     }
   }
+
+  private boolean isLoadingMediaPeriod() {
+    return next == null;
+  }
+
+  /** Returns a media period corresponding to the given {@code id}. */
+  private static MediaPeriod createMediaPeriod(
+      MediaPeriodId id,
+      MediaSource mediaSource,
+      Allocator allocator,
+      long startPositionUs,
+      long endPositionUs) {
+    MediaPeriod mediaPeriod = mediaSource.createPeriod(id, allocator, startPositionUs);
+    if (endPositionUs != C.TIME_UNSET && endPositionUs != C.TIME_END_OF_SOURCE) {
+      mediaPeriod =
+          new ClippingMediaPeriod(
+              mediaPeriod, /* enableInitialDiscontinuity= */ true, /* startUs= */ 0, endPositionUs);
+    }
+    return mediaPeriod;
+  }
+
+  /** Releases the given {@code mediaPeriod}, logging and suppressing any errors. */
+  private static void releaseMediaPeriod(
+      long endPositionUs, MediaSource mediaSource, MediaPeriod mediaPeriod) {
+    try {
+      if (endPositionUs != C.TIME_UNSET && endPositionUs != C.TIME_END_OF_SOURCE) {
+        mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+      } else {
+        mediaSource.releasePeriod(mediaPeriod);
+      }
+    } catch (RuntimeException e) {
+      // There's nothing we can do.
+      Log.e(TAG, "Period release failed.", e);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
index ba19b54c3f..bc1ea7b1e1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.util.Util;
 
 /** Stores the information required to load and play a {@link MediaPeriod}. */
 /* package */ final class MediaPeriodInfo {
@@ -31,9 +33,16 @@
    */
   public final long contentPositionUs;
   /**
-   * The duration of the media period, like {@link MediaPeriodId#endPositionUs} but with {@link
-   * C#TIME_END_OF_SOURCE} resolved to the timeline period duration. May be {@link C#TIME_UNSET} if
-   * the end position is not known.
+   * The end position to which the media period's content is clipped in order to play a following ad
+   * group, in microseconds, or {@link C#TIME_UNSET} if there is no following ad group or if this
+   * media period is an ad. The value {@link C#TIME_END_OF_SOURCE} indicates that a postroll ad
+   * follows at the end of this content media period.
+   */
+  public final long endPositionUs;
+  /**
+   * The duration of the media period, like {@link #endPositionUs} but with {@link
+   * C#TIME_END_OF_SOURCE} and {@link C#TIME_UNSET} resolved to the timeline period duration if
+   * known.
    */
   public final long durationUs;
   /**
@@ -51,25 +60,81 @@
       MediaPeriodId id,
       long startPositionUs,
       long contentPositionUs,
+      long endPositionUs,
       long durationUs,
       boolean isLastInTimelinePeriod,
       boolean isFinal) {
     this.id = id;
     this.startPositionUs = startPositionUs;
     this.contentPositionUs = contentPositionUs;
+    this.endPositionUs = endPositionUs;
     this.durationUs = durationUs;
     this.isLastInTimelinePeriod = isLastInTimelinePeriod;
     this.isFinal = isFinal;
   }
 
-  /** Returns a copy of this instance with the start position set to the specified value. */
+  /**
+   * Returns a copy of this instance with the start position set to the specified value. May return
+   * the same instance if nothing changed.
+   */
   public MediaPeriodInfo copyWithStartPositionUs(long startPositionUs) {
-    return new MediaPeriodInfo(
-        id,
-        startPositionUs,
-        contentPositionUs,
-        durationUs,
-        isLastInTimelinePeriod,
-        isFinal);
+    return startPositionUs == this.startPositionUs
+        ? this
+        : new MediaPeriodInfo(
+            id,
+            startPositionUs,
+            contentPositionUs,
+            endPositionUs,
+            durationUs,
+            isLastInTimelinePeriod,
+            isFinal);
+  }
+
+  /**
+   * Returns a copy of this instance with the content position set to the specified value. May
+   * return the same instance if nothing changed.
+   */
+  public MediaPeriodInfo copyWithContentPositionUs(long contentPositionUs) {
+    return contentPositionUs == this.contentPositionUs
+        ? this
+        : new MediaPeriodInfo(
+            id,
+            startPositionUs,
+            contentPositionUs,
+            endPositionUs,
+            durationUs,
+            isLastInTimelinePeriod,
+            isFinal);
+  }
+
+  @Override
+  public boolean equals(@Nullable Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    MediaPeriodInfo that = (MediaPeriodInfo) o;
+    return startPositionUs == that.startPositionUs
+        && contentPositionUs == that.contentPositionUs
+        && endPositionUs == that.endPositionUs
+        && durationUs == that.durationUs
+        && isLastInTimelinePeriod == that.isLastInTimelinePeriod
+        && isFinal == that.isFinal
+        && Util.areEqual(id, that.id);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + id.hashCode();
+    result = 31 * result + (int) startPositionUs;
+    result = 31 * result + (int) contentPositionUs;
+    result = 31 * result + (int) endPositionUs;
+    result = 31 * result + (int) durationUs;
+    result = 31 * result + (isLastInTimelinePeriod ? 1 : 0);
+    result = 31 * result + (isFinal ? 1 : 0);
+    return result;
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index c51c1cc149..249548340e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.Player.RepeatMode;
 import com.google.android.exoplayer2.source.MediaPeriod;
@@ -61,8 +61,8 @@ public MediaPeriodQueue() {
   }
 
   /**
-   * Sets the {@link Timeline}. Call {@link #updateQueuedPeriods(MediaPeriodId, long)} to update the
-   * queued media periods to take into account the new timeline.
+   * Sets the {@link Timeline}. Call {@link #updateQueuedPeriods(long, long)} to update the queued
+   * media periods to take into account the new timeline.
    */
   public void setTimeline(Timeline timeline) {
     this.timeline = timeline;
@@ -156,7 +156,7 @@ public MediaPeriod enqueueNextMediaPeriod(
             info);
     if (loading != null) {
       Assertions.checkState(hasPlayingPeriod());
-      loading.next = newPeriodHolder;
+      loading.setNext(newPeriodHolder);
     }
     oldFrontPeriodUid = null;
     loading = newPeriodHolder;
@@ -207,8 +207,8 @@ public boolean hasPlayingPeriod() {
    * @return The updated reading period holder.
    */
   public MediaPeriodHolder advanceReadingPeriod() {
-    Assertions.checkState(reading != null && reading.next != null);
-    reading = reading.next;
+    Assertions.checkState(reading != null && reading.getNext() != null);
+    reading = reading.getNext();
     return reading;
   }
 
@@ -222,7 +222,7 @@ public MediaPeriodHolder advanceReadingPeriod() {
   public MediaPeriodHolder advancePlayingPeriod() {
     if (playing != null) {
       if (playing == reading) {
-        reading = playing.next;
+        reading = playing.getNext();
       }
       playing.release();
       length--;
@@ -231,7 +231,7 @@ public MediaPeriodHolder advancePlayingPeriod() {
         oldFrontPeriodUid = playing.uid;
         oldFrontPeriodWindowSequenceNumber = playing.info.id.windowSequenceNumber;
       }
-      playing = playing.next;
+      playing = playing.getNext();
     } else {
       playing = loading;
       reading = loading;
@@ -251,8 +251,8 @@ public boolean removeAfter(MediaPeriodHolder mediaPeriodHolder) {
     Assertions.checkState(mediaPeriodHolder != null);
     boolean removedReading = false;
     loading = mediaPeriodHolder;
-    while (mediaPeriodHolder.next != null) {
-      mediaPeriodHolder = mediaPeriodHolder.next;
+    while (mediaPeriodHolder.getNext() != null) {
+      mediaPeriodHolder = mediaPeriodHolder.getNext();
       if (mediaPeriodHolder == reading) {
         reading = playing;
         removedReading = true;
@@ -260,7 +260,7 @@ public boolean removeAfter(MediaPeriodHolder mediaPeriodHolder) {
       mediaPeriodHolder.release();
       length--;
     }
-    loading.next = null;
+    loading.setNext(null);
     return removedReading;
   }
 
@@ -292,52 +292,60 @@ public void clear(boolean keepFrontPeriodUid) {
    * current playback position. The method assumes that the first media period in the queue is still
    * consistent with the new timeline.
    *
-   * @param playingPeriodId The current playing media period identifier.
    * @param rendererPositionUs The current renderer position in microseconds.
+   * @param maxRendererReadPositionUs The maximum renderer position up to which renderers have read
+   *     the current reading media period in microseconds, or {@link C#TIME_END_OF_SOURCE} if they
+   *     have read to the end.
    * @return Whether the timeline change has been handled completely.
    */
-  public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId, long rendererPositionUs) {
+  public boolean updateQueuedPeriods(long rendererPositionUs, long maxRendererReadPositionUs) {
     // TODO: Merge this into setTimeline so that the queue gets updated as soon as the new timeline
     // is set, once all cases handled by ExoPlayerImplInternal.handleSourceInfoRefreshed can be
     // handled here.
-    int periodIndex = timeline.getIndexOfPeriod(playingPeriodId.periodUid);
-    // The front period is either playing now, or is being loaded and will become the playing
-    // period.
     MediaPeriodHolder previousPeriodHolder = null;
     MediaPeriodHolder periodHolder = getFrontPeriod();
     while (periodHolder != null) {
+      MediaPeriodInfo oldPeriodInfo = periodHolder.info;
+
+      // Get period info based on new timeline.
+      MediaPeriodInfo newPeriodInfo;
       if (previousPeriodHolder == null) {
-        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info);
+        // The id and start position of the first period have already been verified by
+        // ExoPlayerImplInternal.handleSourceInfoRefreshed. Just update duration, isLastInTimeline
+        // and isLastInPeriod flags.
+        newPeriodInfo = getUpdatedMediaPeriodInfo(oldPeriodInfo);
       } else {
-        // Check this period holder still follows the previous one, based on the new timeline.
-        if (periodIndex == C.INDEX_UNSET
-            || !periodHolder.uid.equals(timeline.getUidOfPeriod(periodIndex))) {
-          // The holder uid is inconsistent with the new timeline.
-          return !removeAfter(previousPeriodHolder);
-        }
-        MediaPeriodInfo periodInfo =
-            getFollowingMediaPeriodInfo(previousPeriodHolder, rendererPositionUs);
-        if (periodInfo == null) {
+        newPeriodInfo = getFollowingMediaPeriodInfo(previousPeriodHolder, rendererPositionUs);
+        if (newPeriodInfo == null) {
           // We've loaded a next media period that is not in the new timeline.
           return !removeAfter(previousPeriodHolder);
         }
-        // Update the period holder.
-        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info);
-        // Check the media period information matches the new timeline.
-        if (!canKeepMediaPeriodHolder(periodHolder, periodInfo)) {
+        if (!canKeepMediaPeriodHolder(oldPeriodInfo, newPeriodInfo)) {
+          // The new media period has a different id or start position.
           return !removeAfter(previousPeriodHolder);
         }
       }
 
-      if (periodHolder.info.isLastInTimelinePeriod) {
-        // Move on to the next timeline period index, if there is one.
-        periodIndex =
-            timeline.getNextPeriodIndex(
-                periodIndex, period, window, repeatMode, shuffleModeEnabled);
+      // Use new period info, but keep old content position.
+      periodHolder.info = newPeriodInfo.copyWithContentPositionUs(oldPeriodInfo.contentPositionUs);
+
+      if (!areDurationsCompatible(oldPeriodInfo.durationUs, newPeriodInfo.durationUs)) {
+        // The period duration changed. Remove all subsequent periods and check whether we read
+        // beyond the new duration.
+        long newDurationInRendererTime =
+            newPeriodInfo.durationUs == C.TIME_UNSET
+                ? Long.MAX_VALUE
+                : periodHolder.toRendererTime(newPeriodInfo.durationUs);
+        boolean isReadingAndReadBeyondNewDuration =
+            periodHolder == reading
+                && (maxRendererReadPositionUs == C.TIME_END_OF_SOURCE
+                    || maxRendererReadPositionUs >= newDurationInRendererTime);
+        boolean readingPeriodRemoved = removeAfter(periodHolder);
+        return !readingPeriodRemoved && !isReadingAndReadBeyondNewDuration;
       }
 
       previousPeriodHolder = periodHolder;
-      periodHolder = periodHolder.next;
+      periodHolder = periodHolder.getNext();
     }
     return true;
   }
@@ -351,19 +359,21 @@ public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId, long rendererP
    * @return The updated media period info for the current timeline.
    */
   public MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo info) {
-    boolean isLastInPeriod = isLastInPeriod(info.id);
-    boolean isLastInTimeline = isLastInTimeline(info.id, isLastInPeriod);
+    MediaPeriodId id = info.id;
+    boolean isLastInPeriod = isLastInPeriod(id);
+    boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
     timeline.getPeriodByUid(info.id.periodUid, period);
     long durationUs =
-        info.id.isAd()
-            ? period.getAdDurationUs(info.id.adGroupIndex, info.id.adIndexInAdGroup)
-            : (info.id.endPositionUs == C.TIME_END_OF_SOURCE
+        id.isAd()
+            ? period.getAdDurationUs(id.adGroupIndex, id.adIndexInAdGroup)
+            : (info.endPositionUs == C.TIME_UNSET || info.endPositionUs == C.TIME_END_OF_SOURCE
                 ? period.getDurationUs()
-                : info.id.endPositionUs);
+                : info.endPositionUs);
     return new MediaPeriodInfo(
-        info.id,
+        id,
         info.startPositionUs,
         info.contentPositionUs,
+        info.endPositionUs,
         durationUs,
         isLastInPeriod,
         isLastInTimeline);
@@ -402,11 +412,7 @@ private MediaPeriodId resolveMediaPeriodIdForAds(
     int adGroupIndex = period.getAdGroupIndexForPositionUs(positionUs);
     if (adGroupIndex == C.INDEX_UNSET) {
       int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(positionUs);
-      long endPositionUs =
-          nextAdGroupIndex == C.INDEX_UNSET
-              ? C.TIME_END_OF_SOURCE
-              : period.getAdGroupTimeUs(nextAdGroupIndex);
-      return new MediaPeriodId(periodUid, windowSequenceNumber, endPositionUs);
+      return new MediaPeriodId(periodUid, windowSequenceNumber, nextAdGroupIndex);
     } else {
       int adIndexInAdGroup = period.getFirstAdIndexToPlay(adGroupIndex);
       return new MediaPeriodId(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
@@ -439,7 +445,7 @@ private long resolvePeriodIndexToWindowSequenceNumber(Object periodUid) {
         // Reuse window sequence number of first exact period match.
         return mediaPeriodHolder.info.id.windowSequenceNumber;
       }
-      mediaPeriodHolder = mediaPeriodHolder.next;
+      mediaPeriodHolder = mediaPeriodHolder.getNext();
     }
     mediaPeriodHolder = getFrontPeriod();
     while (mediaPeriodHolder != null) {
@@ -451,20 +457,25 @@ private long resolvePeriodIndexToWindowSequenceNumber(Object periodUid) {
           return mediaPeriodHolder.info.id.windowSequenceNumber;
         }
       }
-      mediaPeriodHolder = mediaPeriodHolder.next;
+      mediaPeriodHolder = mediaPeriodHolder.getNext();
     }
     // If no match is found, create new sequence number.
     return nextWindowSequenceNumber++;
   }
 
   /**
-   * Returns whether {@code periodHolder} can be kept for playing the media period described by
-   * {@code info}.
+   * Returns whether a period described by {@code oldInfo} can be kept for playing the media period
+   * described by {@code newInfo}.
+   */
+  private boolean canKeepMediaPeriodHolder(MediaPeriodInfo oldInfo, MediaPeriodInfo newInfo) {
+    return oldInfo.startPositionUs == newInfo.startPositionUs && oldInfo.id.equals(newInfo.id);
+  }
+
+  /**
+   * Returns whether a duration change of a period is compatible with keeping the following periods.
    */
-  private boolean canKeepMediaPeriodHolder(MediaPeriodHolder periodHolder, MediaPeriodInfo info) {
-    MediaPeriodInfo periodHolderInfo = periodHolder.info;
-    return periodHolderInfo.startPositionUs == info.startPositionUs
-        && periodHolderInfo.id.equals(info.id);
+  private boolean areDurationsCompatible(long previousDurationUs, long newDurationUs) {
+    return previousDurationUs == C.TIME_UNSET || previousDurationUs == newDurationUs;
   }
 
   /**
@@ -482,19 +493,20 @@ private boolean updateForPlaybackModeChange() {
       int nextPeriodIndex =
           timeline.getNextPeriodIndex(
               currentPeriodIndex, period, window, repeatMode, shuffleModeEnabled);
-      while (lastValidPeriodHolder.next != null
+      while (lastValidPeriodHolder.getNext() != null
           && !lastValidPeriodHolder.info.isLastInTimelinePeriod) {
-        lastValidPeriodHolder = lastValidPeriodHolder.next;
+        lastValidPeriodHolder = lastValidPeriodHolder.getNext();
       }
 
-      if (nextPeriodIndex == C.INDEX_UNSET || lastValidPeriodHolder.next == null) {
+      MediaPeriodHolder nextMediaPeriodHolder = lastValidPeriodHolder.getNext();
+      if (nextPeriodIndex == C.INDEX_UNSET || nextMediaPeriodHolder == null) {
         break;
       }
-      int nextPeriodHolderPeriodIndex = timeline.getIndexOfPeriod(lastValidPeriodHolder.next.uid);
+      int nextPeriodHolderPeriodIndex = timeline.getIndexOfPeriod(nextMediaPeriodHolder.uid);
       if (nextPeriodHolderPeriodIndex != nextPeriodIndex) {
         break;
       }
-      lastValidPeriodHolder = lastValidPeriodHolder.next;
+      lastValidPeriodHolder = nextMediaPeriodHolder;
       currentPeriodIndex = nextPeriodIndex;
     }
 
@@ -568,8 +580,9 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
         }
         nextPeriodUid = defaultPosition.first;
         startPositionUs = defaultPosition.second;
-        if (mediaPeriodHolder.next != null && mediaPeriodHolder.next.uid.equals(nextPeriodUid)) {
-          windowSequenceNumber = mediaPeriodHolder.next.info.id.windowSequenceNumber;
+        MediaPeriodHolder nextMediaPeriodHolder = mediaPeriodHolder.getNext();
+        if (nextMediaPeriodHolder != null && nextMediaPeriodHolder.uid.equals(nextPeriodUid)) {
+          windowSequenceNumber = nextMediaPeriodHolder.info.id.windowSequenceNumber;
         } else {
           windowSequenceNumber = nextWindowSequenceNumber++;
         }
@@ -578,7 +591,8 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
       }
       MediaPeriodId periodId =
           resolveMediaPeriodIdForAds(nextPeriodUid, startPositionUs, windowSequenceNumber);
-      return getMediaPeriodInfo(periodId, startPositionUs, startPositionUs);
+      return getMediaPeriodInfo(
+          periodId, /* contentPositionUs= */ startPositionUs, startPositionUs);
     }
 
     MediaPeriodId currentPeriodId = mediaPeriodInfo.id;
@@ -624,14 +638,14 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
         return getMediaPeriodInfoForContent(
             currentPeriodId.periodUid, startPositionUs, currentPeriodId.windowSequenceNumber);
       }
-    } else if (mediaPeriodInfo.id.endPositionUs != C.TIME_END_OF_SOURCE) {
+    } else {
       // Play the next ad group if it's available.
-      int nextAdGroupIndex = period.getAdGroupIndexForPositionUs(mediaPeriodInfo.id.endPositionUs);
+      int nextAdGroupIndex = period.getAdGroupIndexForPositionUs(mediaPeriodInfo.endPositionUs);
       if (nextAdGroupIndex == C.INDEX_UNSET) {
-        // The next ad group can't be played. Play content from the ad group position instead.
+        // The next ad group can't be played. Play content from the previous end position instead.
         return getMediaPeriodInfoForContent(
             currentPeriodId.periodUid,
-            mediaPeriodInfo.id.endPositionUs,
+            /* startPositionUs= */ mediaPeriodInfo.durationUs,
             currentPeriodId.windowSequenceNumber);
       }
       int adIndexInAdGroup = period.getFirstAdIndexToPlay(nextAdGroupIndex);
@@ -641,30 +655,8 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
               currentPeriodId.periodUid,
               nextAdGroupIndex,
               adIndexInAdGroup,
-              mediaPeriodInfo.id.endPositionUs,
+              /* contentPositionUs= */ mediaPeriodInfo.durationUs,
               currentPeriodId.windowSequenceNumber);
-    } else {
-      // Check if the postroll ad should be played.
-      int adGroupCount = period.getAdGroupCount();
-      if (adGroupCount == 0) {
-        return null;
-      }
-      int adGroupIndex = adGroupCount - 1;
-      if (period.getAdGroupTimeUs(adGroupIndex) != C.TIME_END_OF_SOURCE
-          || period.hasPlayedAdGroup(adGroupIndex)) {
-        return null;
-      }
-      int adIndexInAdGroup = period.getFirstAdIndexToPlay(adGroupIndex);
-      if (!period.isAdAvailable(adGroupIndex, adIndexInAdGroup)) {
-        return null;
-      }
-      long contentDurationUs = period.getDurationUs();
-      return getMediaPeriodInfoForAd(
-          currentPeriodId.periodUid,
-          adGroupIndex,
-          adIndexInAdGroup,
-          contentDurationUs,
-          currentPeriodId.windowSequenceNumber);
     }
   }
 
@@ -694,8 +686,6 @@ private MediaPeriodInfo getMediaPeriodInfoForAd(
       long windowSequenceNumber) {
     MediaPeriodId id =
         new MediaPeriodId(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
-    boolean isLastInPeriod = isLastInPeriod(id);
-    boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
     long durationUs =
         timeline
             .getPeriodByUid(id.periodUid, period)
@@ -708,50 +698,38 @@ private MediaPeriodInfo getMediaPeriodInfoForAd(
         id,
         startPositionUs,
         contentPositionUs,
+        /* endPositionUs= */ C.TIME_UNSET,
         durationUs,
-        isLastInPeriod,
-        isLastInTimeline);
+        /* isLastInTimelinePeriod= */ false,
+        /* isFinal= */ false);
   }
 
   private MediaPeriodInfo getMediaPeriodInfoForContent(
       Object periodUid, long startPositionUs, long windowSequenceNumber) {
     int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(startPositionUs);
-    long endPositionUs =
-        nextAdGroupIndex == C.INDEX_UNSET
-            ? C.TIME_END_OF_SOURCE
-            : period.getAdGroupTimeUs(nextAdGroupIndex);
-    MediaPeriodId id = new MediaPeriodId(periodUid, windowSequenceNumber, endPositionUs);
-    timeline.getPeriodByUid(id.periodUid, period);
+    MediaPeriodId id = new MediaPeriodId(periodUid, windowSequenceNumber, nextAdGroupIndex);
     boolean isLastInPeriod = isLastInPeriod(id);
     boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
+    long endPositionUs =
+        nextAdGroupIndex != C.INDEX_UNSET
+            ? period.getAdGroupTimeUs(nextAdGroupIndex)
+            : C.TIME_UNSET;
     long durationUs =
-        endPositionUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endPositionUs;
+        endPositionUs == C.TIME_UNSET || endPositionUs == C.TIME_END_OF_SOURCE
+            ? period.durationUs
+            : endPositionUs;
     return new MediaPeriodInfo(
-        id, startPositionUs, C.TIME_UNSET, durationUs, isLastInPeriod, isLastInTimeline);
+        id,
+        startPositionUs,
+        /* contentPositionUs= */ C.TIME_UNSET,
+        endPositionUs,
+        durationUs,
+        isLastInPeriod,
+        isLastInTimeline);
   }
 
   private boolean isLastInPeriod(MediaPeriodId id) {
-    int adGroupCount = timeline.getPeriodByUid(id.periodUid, period).getAdGroupCount();
-    if (adGroupCount == 0) {
-      return true;
-    }
-
-    int lastAdGroupIndex = adGroupCount - 1;
-    boolean isAd = id.isAd();
-    if (period.getAdGroupTimeUs(lastAdGroupIndex) != C.TIME_END_OF_SOURCE) {
-      // There's no postroll ad.
-      return !isAd && id.endPositionUs == C.TIME_END_OF_SOURCE;
-    }
-
-    int postrollAdCount = period.getAdCountInAdGroup(lastAdGroupIndex);
-    if (postrollAdCount == C.LENGTH_UNSET) {
-      // We won't know if this is the last ad until we know how many postroll ads there are.
-      return false;
-    }
-
-    boolean isLastAd =
-        isAd && id.adGroupIndex == lastAdGroupIndex && id.adIndexInAdGroup == postrollAdCount - 1;
-    return isLastAd || (!isAd && period.getFirstAdIndexToPlay(lastAdGroupIndex) == postrollAdCount);
+    return !id.isAd() && id.nextAdGroupIndex == C.INDEX_UNSET;
   }
 
   private boolean isLastInTimeline(MediaPeriodId id, boolean isLastMediaPeriodInPeriod) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
index 45d6537b84..e901025a07 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
@@ -122,6 +122,11 @@ public final boolean hasReadStreamToEnd() {
     return true;
   }
 
+  @Override
+  public long getReadingPositionUs() {
+    return C.TIME_END_OF_SOURCE;
+  }
+
   @Override
   public final void setCurrentStreamFinal() {
     streamIsFinal = true;
@@ -158,6 +163,12 @@ public final void disable() {
     onDisabled();
   }
 
+  @Override
+  public final void reset() {
+    Assertions.checkState(state == STATE_DISABLED);
+    onReset();
+  }
+
   @Override
   public boolean isReady() {
     return true;
@@ -260,6 +271,15 @@ protected void onDisabled() {
     // Do nothing.
   }
 
+  /**
+   * Called when the renderer is reset.
+   *
+   * <p>The default implementation is a no-op.
+   */
+  protected void onReset() {
+    // Do nothing.
+  }
+
   // Methods to be called by subclasses.
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index 4333f51bf7..0792bf0c7d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.CheckResult;
-import android.support.annotation.Nullable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java
index 6f2db4ff5e..057cb371e5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index e3441fb2a7..8885be2e02 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2;
 
 import android.os.Looper;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
index d60d428563..7904942c1b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
index c6456e5f7f..9f52e8d9de 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.MediaClock;
 import java.io.IOException;
@@ -44,12 +44,16 @@
   @IntDef({STATE_DISABLED, STATE_ENABLED, STATE_STARTED})
   @interface State {}
   /**
-   * The renderer is disabled.
+   * The renderer is disabled. A renderer in this state may hold resources that it requires for
+   * rendering (e.g. media decoders), for use if it's subsequently enabled. {@link #reset()} can be
+   * called to force the renderer to release these resources.
    */
   int STATE_DISABLED = 0;
   /**
-   * The renderer is enabled but not started. A renderer in this state is not actively rendering
-   * media, but will typically hold resources that it requires for rendering (e.g. media decoders).
+   * The renderer is enabled but not started. A renderer in this state may render media at the
+   * current position (e.g. an initial video frame), but the position will not advance. A renderer
+   * in this state will typically hold resources that it requires for rendering (e.g. media
+   * decoders).
    */
   int STATE_ENABLED = 1;
   /**
@@ -156,6 +160,16 @@ void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
    */
   boolean hasReadStreamToEnd();
 
+  /**
+   * Returns the playback position up to which the renderer has read samples from the current {@link
+   * SampleStream}, in microseconds, or {@link C#TIME_END_OF_SOURCE} if the renderer has read the
+   * current {@link SampleStream} to the end.
+   *
+   * <p>This method may be called when the renderer is in the following states: {@link
+   * #STATE_ENABLED}, {@link #STATE_STARTED}.
+   */
+  long getReadingPositionUs();
+
   /**
    * Signals to the renderer that the current {@link SampleStream} will be the final one supplied
    * before it is next disabled or reset.
@@ -279,4 +293,12 @@ default void setOperatingRate(float operatingRate) throws ExoPlaybackException {
    */
   void disable();
 
+  /**
+   * Forces the renderer to give up any resources (e.g. media decoders) that it may be holding. If
+   * the renderer is not holding any resources, the call is a no-op.
+   *
+   * <p>This method may be called when the renderer is in the following states: {@link
+   * #STATE_DISABLED}.
+   */
+  void reset();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java b/library/core/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
index 684072efc6..bc8c6ff633 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * The configuration of a {@link Renderer}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java
index e221898471..6f0d125bcf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java b/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java
index ca0433f96d..7a0ad67a28 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index fe52cc7e8c..910404a875 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -23,7 +23,7 @@
 import android.media.PlaybackParams;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
@@ -48,8 +48,10 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
@@ -63,7 +65,6 @@
  * An {@link ExoPlayer} implementation that uses default {@link Renderer} components. Instances can
  * be obtained from {@link ExoPlayerFactory}.
  */
-@TargetApi(16)
 public class SimpleExoPlayer extends BasePlayer
     implements ExoPlayer,
         Player.AudioComponent,
@@ -94,26 +95,28 @@
 
   private final AudioFocusManager audioFocusManager;
 
-  private Format videoFormat;
-  private Format audioFormat;
+  @Nullable private Format videoFormat;
+  @Nullable private Format audioFormat;
 
-  private Surface surface;
+  @Nullable private Surface surface;
   private boolean ownsSurface;
   private @C.VideoScalingMode int videoScalingMode;
-  private SurfaceHolder surfaceHolder;
-  private TextureView textureView;
+  @Nullable private SurfaceHolder surfaceHolder;
+  @Nullable private TextureView textureView;
   private int surfaceWidth;
   private int surfaceHeight;
-  private DecoderCounters videoDecoderCounters;
-  private DecoderCounters audioDecoderCounters;
+  @Nullable private DecoderCounters videoDecoderCounters;
+  @Nullable private DecoderCounters audioDecoderCounters;
   private int audioSessionId;
   private AudioAttributes audioAttributes;
   private float audioVolume;
-  private MediaSource mediaSource;
+  @Nullable private MediaSource mediaSource;
   private List<Cue> currentCues;
-  private VideoFrameMetadataListener videoFrameMetadataListener;
-  private CameraMotionListener cameraMotionListener;
+  @Nullable private VideoFrameMetadataListener videoFrameMetadataListener;
+  @Nullable private CameraMotionListener cameraMotionListener;
   private boolean hasNotifiedFullWrongThreadWarning;
+  @Nullable private PriorityTaskManager priorityTaskManager;
+  private boolean isPriorityTaskManagerRegistered;
 
   /**
    * @param context A {@link Context}.
@@ -234,6 +237,7 @@ protected SimpleExoPlayer(
         new ExoPlayerImpl(renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
     analyticsCollector = analyticsCollectorFactory.createAnalyticsCollector(player, clock);
     addListener(analyticsCollector);
+    addListener(componentListener);
     videoDebugListeners.add(analyticsCollector);
     videoListeners.add(analyticsCollector);
     audioDebugListeners.add(analyticsCollector);
@@ -539,6 +543,31 @@ public void removeAnalyticsListener(AnalyticsListener listener) {
     analyticsCollector.removeListener(listener);
   }
 
+  /**
+   * Sets a {@link PriorityTaskManager}, or null to clear a previously set priority task manager.
+   *
+   * <p>The priority {@link C#PRIORITY_PLAYBACK} will be set while the player is loading.
+   *
+   * @param priorityTaskManager The {@link PriorityTaskManager}, or null to clear a previously set
+   *     priority task manager.
+   */
+  public void setPriorityTaskManager(@Nullable PriorityTaskManager priorityTaskManager) {
+    verifyApplicationThread();
+    if (Util.areEqual(this.priorityTaskManager, priorityTaskManager)) {
+      return;
+    }
+    if (isPriorityTaskManagerRegistered) {
+      Assertions.checkNotNull(this.priorityTaskManager).remove(C.PRIORITY_PLAYBACK);
+    }
+    if (priorityTaskManager != null && isLoading()) {
+      priorityTaskManager.add(C.PRIORITY_PLAYBACK);
+      isPriorityTaskManagerRegistered = true;
+    } else {
+      isPriorityTaskManagerRegistered = false;
+    }
+    this.priorityTaskManager = priorityTaskManager;
+  }
+
   /**
    * Sets the {@link PlaybackParams} governing audio playback.
    *
@@ -558,30 +587,26 @@ public void setPlaybackParams(@Nullable PlaybackParams params) {
     setPlaybackParameters(playbackParameters);
   }
 
-  /**
-   * Returns the video format currently being played, or null if no video is being played.
-   */
+  /** Returns the video format currently being played, or null if no video is being played. */
+  @Nullable
   public Format getVideoFormat() {
     return videoFormat;
   }
 
-  /**
-   * Returns the audio format currently being played, or null if no audio is being played.
-   */
+  /** Returns the audio format currently being played, or null if no audio is being played. */
+  @Nullable
   public Format getAudioFormat() {
     return audioFormat;
   }
 
-  /**
-   * Returns {@link DecoderCounters} for video, or null if no video is being played.
-   */
+  /** Returns {@link DecoderCounters} for video, or null if no video is being played. */
+  @Nullable
   public DecoderCounters getVideoDecoderCounters() {
     return videoDecoderCounters;
   }
 
-  /**
-   * Returns {@link DecoderCounters} for audio, or null if no audio is being played.
-   */
+  /** Returns {@link DecoderCounters} for audio, or null if no audio is being played. */
+  @Nullable
   public DecoderCounters getAudioDecoderCounters() {
     return audioDecoderCounters;
   }
@@ -963,6 +988,11 @@ public SeekParameters getSeekParameters() {
     return player.getSeekParameters();
   }
 
+  @Override
+  public void setForegroundMode(boolean foregroundMode) {
+    player.setForegroundMode(foregroundMode);
+  }
+
   @Override
   public void stop(boolean reset) {
     verifyApplicationThread();
@@ -980,6 +1010,7 @@ public void stop(boolean reset) {
 
   @Override
   public void release() {
+    verifyApplicationThread();
     audioFocusManager.handleStop();
     player.release();
     removeSurfaceCallbacks();
@@ -993,6 +1024,10 @@ public void release() {
       mediaSource.removeEventListener(analyticsCollector);
       mediaSource = null;
     }
+    if (isPriorityTaskManagerRegistered) {
+      Assertions.checkNotNull(priorityTaskManager).remove(C.PRIORITY_PLAYBACK);
+      isPriorityTaskManagerRegistered = false;
+    }
     bandwidthMeter.removeEventListener(analyticsCollector);
     currentCues = Collections.emptyList();
   }
@@ -1048,7 +1083,8 @@ public Timeline getCurrentTimeline() {
   }
 
   @Override
-  public @Nullable Object getCurrentManifest() {
+  @Nullable
+  public Object getCurrentManifest() {
     verifyApplicationThread();
     return player.getCurrentManifest();
   }
@@ -1195,7 +1231,7 @@ private void verifyApplicationThread() {
       Log.w(
           TAG,
           "Player is accessed on the wrong thread. See "
-              + "https://google.github.io/ExoPlayer/faqs.html#"
+              + "https://exoplayer.dev/faqs.html#"
               + "what-do-player-is-accessed-on-the-wrong-thread-warnings-mean",
           hasNotifiedFullWrongThreadWarning ? null : new IllegalStateException());
       hasNotifiedFullWrongThreadWarning = true;
@@ -1209,7 +1245,8 @@ private void verifyApplicationThread() {
           MetadataOutput,
           SurfaceHolder.Callback,
           TextureView.SurfaceTextureListener,
-          AudioFocusManager.PlayerControl {
+          AudioFocusManager.PlayerControl,
+          Player.EventListener {
 
     // VideoRendererEventListener implementation
 
@@ -1419,5 +1456,20 @@ public void setVolumeMultiplier(float volumeMultiplier) {
     public void executePlayerCommand(@AudioFocusManager.PlayerCommand int playerCommand) {
       updatePlayWhenReady(getPlayWhenReady(), playerCommand);
     }
+
+    // Player.EventListener implementation.
+
+    @Override
+    public void onLoadingChanged(boolean isLoading) {
+      if (priorityTaskManager != null) {
+        if (isLoading && !isPriorityTaskManagerRegistered) {
+          priorityTaskManager.add(C.PRIORITY_PLAYBACK);
+          isPriorityTaskManagerRegistered = true;
+        } else if (!isLoading && isPriorityTaskManagerRegistered) {
+          priorityTaskManager.remove(C.PRIORITY_PLAYBACK);
+          isPriorityTaskManagerRegistered = false;
+        }
+      }
+    }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index bb7f027726..9c26b546bd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.source.ads.AdPlaybackState;
 import com.google.android.exoplayer2.util.Assertions;
@@ -120,7 +120,7 @@
   public static final class Window {
 
     /** A tag for the window. Not necessarily unique. */
-    public @Nullable Object tag;
+    @Nullable public Object tag;
 
     /**
      * The start time of the presentation to which this window belongs in milliseconds since the
@@ -267,14 +267,15 @@ public long getPositionInFirstPeriodUs() {
   public static final class Period {
 
     /**
-     * An identifier for the period. Not necessarily unique.
+     * An identifier for the period. Not necessarily unique. May be null if the ids of the period
+     * are not required.
      */
-    public Object id;
+    @Nullable public Object id;
 
     /**
-     * A unique identifier for the period.
+     * A unique identifier for the period. May be null if the ids of the period are not required.
      */
-    public Object uid;
+    @Nullable public Object uid;
 
     /**
      * The index of the window to which this period belongs.
@@ -289,11 +290,18 @@ public long getPositionInFirstPeriodUs() {
     private long positionInWindowUs;
     private AdPlaybackState adPlaybackState;
 
+    /** Creates a new instance with no ad playback state. */
+    public Period() {
+      adPlaybackState = AdPlaybackState.NONE;
+    }
+
     /**
      * Sets the data held by this period.
      *
-     * @param id An identifier for the period. Not necessarily unique.
-     * @param uid A unique identifier for the period.
+     * @param id An identifier for the period. Not necessarily unique. May be null if the ids of the
+     *     period are not required.
+     * @param uid A unique identifier for the period. May be null if the ids of the period are not
+     *     required.
      * @param windowIndex The index of the window to which this period belongs.
      * @param durationUs The duration of this period in microseconds, or {@link C#TIME_UNSET} if
      *     unknown.
@@ -302,7 +310,11 @@ public long getPositionInFirstPeriodUs() {
      *     period is not within the window.
      * @return This period, for convenience.
      */
-    public Period set(Object id, Object uid, int windowIndex, long durationUs,
+    public Period set(
+        @Nullable Object id,
+        @Nullable Object uid,
+        int windowIndex,
+        long durationUs,
         long positionInWindowUs) {
       return set(id, uid, windowIndex, durationUs, positionInWindowUs, AdPlaybackState.NONE);
     }
@@ -310,8 +322,10 @@ public Period set(Object id, Object uid, int windowIndex, long durationUs,
     /**
      * Sets the data held by this period.
      *
-     * @param id An identifier for the period. Not necessarily unique.
-     * @param uid A unique identifier for the period.
+     * @param id An identifier for the period. Not necessarily unique. May be null if the ids of the
+     *     period are not required.
+     * @param uid A unique identifier for the period. May be null if the ids of the period are not
+     *     required.
      * @param windowIndex The index of the window to which this period belongs.
      * @param durationUs The duration of this period in microseconds, or {@link C#TIME_UNSET} if
      *     unknown.
@@ -323,8 +337,8 @@ public Period set(Object id, Object uid, int windowIndex, long durationUs,
      * @return This period, for convenience.
      */
     public Period set(
-        Object id,
-        Object uid,
+        @Nullable Object id,
+        @Nullable Object uid,
         int windowIndex,
         long durationUs,
         long positionInWindowUs,
@@ -444,7 +458,7 @@ public int getAdGroupIndexForPositionUs(long positionUs) {
      * @return The index of the ad group, or {@link C#INDEX_UNSET}.
      */
     public int getAdGroupIndexAfterPositionUs(long positionUs) {
-      return adPlaybackState.getAdGroupIndexAfterPositionUs(positionUs);
+      return adPlaybackState.getAdGroupIndexAfterPositionUs(positionUs, durationUs);
     }
 
     /**
@@ -707,7 +721,9 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
    */
   public final Pair<Object, Long> getPeriodPosition(
       Window window, Period period, int windowIndex, long windowPositionUs) {
-    return getPeriodPosition(window, period, windowIndex, windowPositionUs, 0);
+    return Assertions.checkNotNull(
+        getPeriodPosition(
+            window, period, windowIndex, windowPositionUs, /* defaultPositionProjectionUs= */ 0));
   }
 
   /**
@@ -724,6 +740,7 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
    *     is {@link C#TIME_UNSET}, {@code defaultPositionProjectionUs} is non-zero, and the window's
    *     position could not be projected by {@code defaultPositionProjectionUs}.
    */
+  @Nullable
   public final Pair<Object, Long> getPeriodPosition(
       Window window,
       Period period,
@@ -746,7 +763,7 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
       periodPositionUs -= periodDurationUs;
       periodDurationUs = getPeriod(++periodIndex, period, /* setIds= */ true).getDurationUs();
     }
-    return Pair.create(period.uid, periodPositionUs);
+    return Pair.create(Assertions.checkNotNull(period.uid), periodPositionUs);
   }
 
   /**
@@ -761,8 +778,8 @@ public Period getPeriodByUid(Object periodUid, Period period) {
   }
 
   /**
-   * Populates a {@link Period} with data for the period at the specified index. Does not populate
-   * {@link Period#id} and {@link Period#uid}.
+   * Populates a {@link Period} with data for the period at the specified index. {@link Period#id}
+   * and {@link Period#uid} will be set to null.
    *
    * @param periodIndex The index of the period.
    * @param period The {@link Period} to populate. Must not be null.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
index 113add612a..c0d96e8e88 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.analytics;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -129,12 +129,13 @@ public void removeListener(AnalyticsListener listener) {
 
   /**
    * Sets the player for which data will be collected. Must only be called if no player has been set
-   * yet.
+   * yet or the current player is idle.
    *
    * @param player The {@link Player} for which data will be collected.
    */
   public void setPlayer(Player player) {
-    Assertions.checkState(this.player == null);
+    Assertions.checkState(
+        this.player == null || mediaPeriodQueueTracker.mediaPeriodInfoQueue.isEmpty());
     this.player = Assertions.checkNotNull(player);
   }
 
@@ -488,7 +489,10 @@ public final void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
 
   @Override
   public final void onPlayerError(ExoPlaybackException error) {
-    EventTime eventTime = generatePlayingMediaPeriodEventTime();
+    EventTime eventTime =
+        error.type == ExoPlaybackException.TYPE_SOURCE
+            ? generateLoadingMediaPeriodEventTime()
+            : generatePlayingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
       listener.onPlayerError(eventTime, error);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
index e5ed530268..7f74216cc8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.analytics;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index 230b96d01f..4e4964e817 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2.audio;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.Ac3Util.SyncFrameInfo.StreamType;
@@ -55,10 +56,10 @@
     public static final int STREAM_TYPE_TYPE2 = 2;
 
     /**
-     * The sample mime type of the bitstream. One of {@link MimeTypes#AUDIO_AC3} and
-     * {@link MimeTypes#AUDIO_E_AC3}.
+     * The sample mime type of the bitstream. One of {@link MimeTypes#AUDIO_AC3} and {@link
+     * MimeTypes#AUDIO_E_AC3}.
      */
-    public final String mimeType;
+    @Nullable public final String mimeType;
     /**
      * The type of the stream if {@link #mimeType} is {@link MimeTypes#AUDIO_E_AC3}, or {@link
      * #STREAM_TYPE_UNDEFINED} otherwise.
@@ -82,7 +83,7 @@
     public final int sampleCount;
 
     private SyncFrameInfo(
-        String mimeType,
+        @Nullable String mimeType,
         @StreamType int streamType,
         int channelCount,
         int sampleRate,
@@ -433,6 +434,11 @@ public static SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
       mimeType = MimeTypes.AUDIO_AC3;
       data.skipBits(16 + 16); // syncword, crc1
       int fscod = data.readBits(2);
+      if (fscod == 3) {
+        // fscod '11' indicates that the decoder should not attempt to decode audio. We invalidate
+        // the mime type to prevent association with a renderer.
+        mimeType = null;
+      }
       int frmsizecod = data.readBits(6);
       frameSize = getAc3SyncframeSize(fscod, frmsizecod);
       data.skipBits(5 + 3); // bsid, bsmod
@@ -446,7 +452,8 @@ public static SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
       if (acmod == 2) {
         data.skipBits(2); // dsurmod
       }
-      sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
+      sampleRate =
+          fscod < SAMPLE_RATE_BY_FSCOD.length ? SAMPLE_RATE_BY_FSCOD[fscod] : Format.NO_VALUE;
       sampleCount = AC3_SYNCFRAME_AUDIO_SAMPLE_COUNT;
       lfeon = data.readBit();
       channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java
new file mode 100644
index 0000000000..74bd5bfe98
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.nio.ByteBuffer;
+
+/** Utility methods for parsing AC-4 frames, which are access units in AC-4 bitstreams. */
+public final class Ac4Util {
+
+  /** Holds sample format information as presented by a syncframe header. */
+  public static final class SyncFrameInfo {
+
+    /** The bitstream version. */
+    public final int bitstreamVersion;
+    /** The audio sampling rate in Hz. */
+    public final int sampleRate;
+    /** The number of audio channels */
+    public final int channelCount;
+    /** The size of the frame. */
+    public final int frameSize;
+    /** Number of audio samples in the frame. */
+    public final int sampleCount;
+
+    private SyncFrameInfo(
+        int bitstreamVersion, int channelCount, int sampleRate, int frameSize, int sampleCount) {
+      this.bitstreamVersion = bitstreamVersion;
+      this.channelCount = channelCount;
+      this.sampleRate = sampleRate;
+      this.frameSize = frameSize;
+      this.sampleCount = sampleCount;
+    }
+  }
+
+  public static final int AC40_SYNCWORD = 0xAC40;
+  public static final int AC41_SYNCWORD = 0xAC41;
+
+  /** The channel count of AC-4 stream. */
+  // TODO: Parse AC-4 stream channel count.
+  private static final int CHANNEL_COUNT_2 = 2;
+  /**
+   * The header size for AC-4 parser. Only needs to be as big as we need to read, not the full
+   * header size.
+   */
+  public static final int HEADER_SIZE_FOR_PARSER = 16;
+  /**
+   * Number of audio samples in the frame. Defined in IEC61937-14:2017 table 5 and 6. This table
+   * provides the number of samples per frame at the playback sampling frequency of 48 kHz. For 44.1
+   * kHz, only frame_rate_index(13) is valid and corresponding sample count is 2048.
+   */
+  private static final int[] SAMPLE_COUNT =
+      new int[] {
+        /* [ 0]  23.976 fps */ 2002,
+        /* [ 1]  24     fps */ 2000,
+        /* [ 2]  25     fps */ 1920,
+        /* [ 3]  29.97  fps */ 1601, // 1601 | 1602 | 1601 | 1602 | 1602
+        /* [ 4]  30     fps */ 1600,
+        /* [ 5]  47.95  fps */ 1001,
+        /* [ 6]  48     fps */ 1000,
+        /* [ 7]  50     fps */ 960,
+        /* [ 8]  59.94  fps */ 800, //  800 |  801 |  801 |  801 |  801
+        /* [ 9]  60     fps */ 800,
+        /* [10] 100     fps */ 480,
+        /* [11] 119.88  fps */ 400, //  400 |  400 |  401 |  400 |  401
+        /* [12] 120     fps */ 400,
+        /* [13]  23.438 fps */ 2048
+      };
+
+  /**
+   * Returns the AC-4 format given {@code data} containing the AC4SpecificBox according to ETSI TS
+   * 103 190-1 Annex E. The reading position of {@code data} will be modified.
+   *
+   * @param data The AC4SpecificBox to parse.
+   * @param trackId The track identifier to set on the format.
+   * @param language The language to set on the format.
+   * @param drmInitData {@link DrmInitData} to be included in the format.
+   * @return The AC-4 format parsed from data in the header.
+   */
+  public static Format parseAc4AnnexEFormat(
+      ParsableByteArray data, String trackId, String language, DrmInitData drmInitData) {
+    data.skipBytes(1); // ac4_dsi_version, bitstream_version[0:5]
+    int sampleRate = ((data.readUnsignedByte() & 0x20) >> 5 == 1) ? 48000 : 44100;
+    return Format.createAudioSampleFormat(
+        trackId,
+        MimeTypes.AUDIO_AC4,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* maxInputSize= */ Format.NO_VALUE,
+        CHANNEL_COUNT_2,
+        sampleRate,
+        /* initializationData= */ null,
+        drmInitData,
+        /* selectionFlags= */ 0,
+        language);
+  }
+
+  /**
+   * Returns AC-4 format information given {@code data} containing a syncframe. The reading position
+   * of {@code data} will be modified.
+   *
+   * @param data The data to parse, positioned at the start of the syncframe.
+   * @return The AC-4 format data parsed from the header.
+   */
+  public static SyncFrameInfo parseAc4SyncframeInfo(ParsableBitArray data) {
+    int headerSize = 0;
+    int syncWord = data.readBits(16);
+    headerSize += 2;
+    int frameSize = data.readBits(16);
+    headerSize += 2;
+    if (frameSize == 0xFFFF) {
+      frameSize = data.readBits(24);
+      headerSize += 3; // Extended frame_size
+    }
+    frameSize += headerSize;
+    if (syncWord == AC41_SYNCWORD) {
+      frameSize += 2; // crc_word
+    }
+    int bitstreamVersion = data.readBits(2);
+    if (bitstreamVersion == 3) {
+      bitstreamVersion += readVariableBits(data, /* bitsPerRead= */ 2);
+    }
+    int sequenceCounter = data.readBits(10);
+    if (data.readBit()) { // b_wait_frames
+      if (data.readBits(3) > 0) { // wait_frames
+        data.skipBits(2); // reserved
+      }
+    }
+    int sampleRate = data.readBit() ? 48000 : 44100;
+    int frameRateIndex = data.readBits(4);
+    int sampleCount = 0;
+    if (sampleRate == 44100 && frameRateIndex == 13) {
+      sampleCount = SAMPLE_COUNT[frameRateIndex];
+    } else if (sampleRate == 48000 && frameRateIndex < SAMPLE_COUNT.length) {
+      sampleCount = SAMPLE_COUNT[frameRateIndex];
+      switch (sequenceCounter % 5) {
+        case 1: // fall through
+        case 3:
+          if (frameRateIndex == 3 || frameRateIndex == 8) {
+            sampleCount++;
+          }
+          break;
+        case 2:
+          if (frameRateIndex == 8 || frameRateIndex == 11) {
+            sampleCount++;
+          }
+          break;
+        case 4:
+          if (frameRateIndex == 3 || frameRateIndex == 8 || frameRateIndex == 11) {
+            sampleCount++;
+          }
+          break;
+        default:
+          break;
+      }
+    }
+    return new SyncFrameInfo(bitstreamVersion, CHANNEL_COUNT_2, sampleRate, frameSize, sampleCount);
+  }
+
+  /**
+   * Returns the size in bytes of the given AC-4 syncframe.
+   *
+   * @param data The syncframe to parse.
+   * @param syncword The syncword value for the syncframe.
+   * @return The syncframe size in bytes, or {@link C#LENGTH_UNSET} if the input is invalid.
+   */
+  public static int parseAc4SyncframeSize(byte[] data, int syncword) {
+    if (data.length < 7) {
+      return C.LENGTH_UNSET;
+    }
+    int headerSize = 2; // syncword
+    int frameSize = ((data[2] & 0xFF) << 8) | (data[3] & 0xFF);
+    headerSize += 2;
+    if (frameSize == 0xFFFF) {
+      frameSize = ((data[4] & 0xFF) << 16) | ((data[5] & 0xFF) << 8) | (data[6] & 0xFF);
+      headerSize += 3;
+    }
+    if (syncword == AC41_SYNCWORD) {
+      headerSize += 2;
+    }
+    frameSize += headerSize;
+    return frameSize;
+  }
+
+  /**
+   * Reads the number of audio samples represented by the given AC-4 syncframe. The buffer's
+   * position is not modified.
+   *
+   * @param buffer The {@link ByteBuffer} from which to read the syncframe.
+   * @return The number of audio samples represented by the syncframe.
+   */
+  public static int parseAc4SyncframeAudioSampleCount(ByteBuffer buffer) {
+    byte[] bufferBytes = new byte[HEADER_SIZE_FOR_PARSER];
+    int position = buffer.position();
+    buffer.get(bufferBytes);
+    buffer.position(position);
+    return parseAc4SyncframeInfo(new ParsableBitArray(bufferBytes)).sampleCount;
+  }
+
+  /** Populates {@code buffer} with an AC-4 sample header for a sample of the specified size. */
+  public static void getAc4SampleHeader(int size, ParsableByteArray buffer) {
+    // See ETSI TS 103 190-1 V1.3.1, Annex G.
+    buffer.reset(/* limit= */ 7);
+    buffer.data[0] = (byte) 0xAC;
+    buffer.data[1] = 0x40;
+    buffer.data[2] = (byte) 0xFF;
+    buffer.data[3] = (byte) 0xFF;
+    buffer.data[4] = (byte) ((size >> 16) & 0xFF);
+    buffer.data[5] = (byte) ((size >> 8) & 0xFF);
+    buffer.data[6] = (byte) (size & 0xFF);
+  }
+
+  private static int readVariableBits(ParsableBitArray data, int bitsPerRead) {
+    int value = 0;
+    while (true) {
+      value += data.readBits(bitsPerRead);
+      if (!data.readBit()) {
+        break;
+      }
+      value++;
+      value <<= bitsPerRead;
+    }
+    return value;
+  }
+
+  private Ac4Util() {}
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
index 848b3ee10c..9c63eb42c6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.audio;
 
 import android.annotation.TargetApi;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
index 6a5e58ef2a..25c0e70ae5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
@@ -22,7 +22,10 @@
 import android.content.IntentFilter;
 import android.media.AudioFormat;
 import android.media.AudioManager;
-import android.support.annotation.Nullable;
+import android.net.Uri;
+import android.provider.Settings.Global;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
 /** Represents the set of audio formats that a device is capable of playing. */
@@ -35,6 +38,17 @@
   public static final AudioCapabilities DEFAULT_AUDIO_CAPABILITIES =
       new AudioCapabilities(new int[] {AudioFormat.ENCODING_PCM_16BIT}, DEFAULT_MAX_CHANNEL_COUNT);
 
+  /** Audio capabilities when the device specifies external surround sound. */
+  private static final AudioCapabilities EXTERNAL_SURROUND_SOUND_CAPABILITIES =
+      new AudioCapabilities(
+          new int[] {
+            AudioFormat.ENCODING_PCM_16BIT, AudioFormat.ENCODING_AC3, AudioFormat.ENCODING_E_AC3
+          },
+          DEFAULT_MAX_CHANNEL_COUNT);
+
+  /** Global settings key for devices that can specify external surround sound. */
+  private static final String EXTERNAL_SURROUND_SOUND_KEY = "external_surround_sound_enabled";
+
   /**
    * Returns the current audio capabilities for the device.
    *
@@ -43,12 +57,18 @@
    */
   @SuppressWarnings("InlinedApi")
   public static AudioCapabilities getCapabilities(Context context) {
-    return getCapabilities(
-        context.registerReceiver(null, new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG)));
+    Intent intent =
+        context.registerReceiver(
+            /* receiver= */ null, new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG));
+    return getCapabilities(context, intent);
   }
 
   @SuppressLint("InlinedApi")
-  /* package */ static AudioCapabilities getCapabilities(@Nullable Intent intent) {
+  /* package */ static AudioCapabilities getCapabilities(Context context, @Nullable Intent intent) {
+    if (deviceMaySetExternalSurroundSoundGlobalSetting()
+        && Global.getInt(context.getContentResolver(), EXTERNAL_SURROUND_SOUND_KEY, 0) == 1) {
+      return EXTERNAL_SURROUND_SOUND_CAPABILITIES;
+    }
     if (intent == null || intent.getIntExtra(AudioManager.EXTRA_AUDIO_PLUG_STATE, 0) == 0) {
       return DEFAULT_AUDIO_CAPABILITIES;
     }
@@ -58,6 +78,17 @@ public static AudioCapabilities getCapabilities(Context context) {
             AudioManager.EXTRA_MAX_CHANNEL_COUNT, /* defaultValue= */ DEFAULT_MAX_CHANNEL_COUNT));
   }
 
+  /**
+   * Returns the global settings {@link Uri} used by the device to specify external surround sound,
+   * or null if the device does not support this functionality.
+   */
+  @Nullable
+  /* package */ static Uri getExternalSurroundSoundGlobalSettingUri() {
+    return deviceMaySetExternalSurroundSoundGlobalSetting()
+        ? Global.getUriFor(EXTERNAL_SURROUND_SOUND_KEY)
+        : null;
+  }
+
   private final int[] supportedEncodings;
   private final int maxChannelCount;
 
@@ -124,4 +155,7 @@ public String toString() {
         + ", supportedEncodings=" + Arrays.toString(supportedEncodings) + "]";
   }
 
+  private static boolean deviceMaySetExternalSurroundSoundGlobalSetting() {
+    return Util.SDK_INT >= 17 && "Amazon".equals(Util.MANUFACTURER);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java
index aa610db8b1..fe84c49656 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilitiesReceiver.java
@@ -16,12 +16,15 @@
 package com.google.android.exoplayer2.audio;
 
 import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.database.ContentObserver;
 import android.media.AudioManager;
+import android.net.Uri;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
@@ -46,31 +49,30 @@
   }
 
   private final Context context;
-  private final @Nullable Handler handler;
   private final Listener listener;
-  private final @Nullable BroadcastReceiver receiver;
+  private final Handler handler;
+  @Nullable private final BroadcastReceiver receiver;
+  @Nullable private final ExternalSurroundSoundSettingObserver externalSurroundSoundSettingObserver;
 
   /* package */ @Nullable AudioCapabilities audioCapabilities;
+  private boolean registered;
 
   /**
    * @param context A context for registering the receiver.
    * @param listener The listener to notify when audio capabilities change.
    */
   public AudioCapabilitiesReceiver(Context context, Listener listener) {
-    this(context, /* handler= */ null, listener);
-  }
-
-  /**
-   * @param context A context for registering the receiver.
-   * @param handler The handler to which {@link Listener} events will be posted. If null, listener
-   *     methods are invoked on the main thread.
-   * @param listener The listener to notify when audio capabilities change.
-   */
-  public AudioCapabilitiesReceiver(Context context, @Nullable Handler handler, Listener listener) {
-    this.context = Assertions.checkNotNull(context);
-    this.handler = handler;
+    context = context.getApplicationContext();
+    this.context = context;
     this.listener = Assertions.checkNotNull(listener);
-    this.receiver = Util.SDK_INT >= 21 ? new HdmiAudioPlugBroadcastReceiver() : null;
+    handler = new Handler(Util.getLooper());
+    receiver = Util.SDK_INT >= 21 ? new HdmiAudioPlugBroadcastReceiver() : null;
+    Uri externalSurroundSoundUri = AudioCapabilities.getExternalSurroundSoundGlobalSettingUri();
+    externalSurroundSoundSettingObserver =
+        externalSurroundSoundUri != null
+            ? new ExternalSurroundSoundSettingObserver(
+                handler, context.getContentResolver(), externalSurroundSoundUri)
+            : null;
   }
 
   /**
@@ -82,18 +84,21 @@ public AudioCapabilitiesReceiver(Context context, @Nullable Handler handler, Lis
    */
   @SuppressWarnings("InlinedApi")
   public AudioCapabilities register() {
+    if (registered) {
+      return Assertions.checkNotNull(audioCapabilities);
+    }
+    registered = true;
+    if (externalSurroundSoundSettingObserver != null) {
+      externalSurroundSoundSettingObserver.register();
+    }
     Intent stickyIntent = null;
     if (receiver != null) {
       IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG);
-      if (handler != null) {
-        stickyIntent =
-            context.registerReceiver(
-                receiver, intentFilter, /* broadcastPermission= */ null, handler);
-      } else {
-        stickyIntent = context.registerReceiver(receiver, intentFilter);
-      }
+      stickyIntent =
+          context.registerReceiver(
+              receiver, intentFilter, /* broadcastPermission= */ null, handler);
     }
-    audioCapabilities = AudioCapabilities.getCapabilities(stickyIntent);
+    audioCapabilities = AudioCapabilities.getCapabilities(context, stickyIntent);
     return audioCapabilities;
   }
 
@@ -102,9 +107,24 @@ public AudioCapabilities register() {
    * changes occur.
    */
   public void unregister() {
+    if (!registered) {
+      return;
+    }
+    audioCapabilities = null;
     if (receiver != null) {
       context.unregisterReceiver(receiver);
     }
+    if (externalSurroundSoundSettingObserver != null) {
+      externalSurroundSoundSettingObserver.unregister();
+    }
+    registered = false;
+  }
+
+  private void onNewAudioCapabilities(AudioCapabilities newAudioCapabilities) {
+    if (registered && !newAudioCapabilities.equals(audioCapabilities)) {
+      audioCapabilities = newAudioCapabilities;
+      listener.onAudioCapabilitiesChanged(newAudioCapabilities);
+    }
   }
 
   private final class HdmiAudioPlugBroadcastReceiver extends BroadcastReceiver {
@@ -112,14 +132,35 @@ public void unregister() {
     @Override
     public void onReceive(Context context, Intent intent) {
       if (!isInitialStickyBroadcast()) {
-        AudioCapabilities newAudioCapabilities = AudioCapabilities.getCapabilities(intent);
-        if (!newAudioCapabilities.equals(audioCapabilities)) {
-          audioCapabilities = newAudioCapabilities;
-          listener.onAudioCapabilitiesChanged(newAudioCapabilities);
-        }
+        onNewAudioCapabilities(AudioCapabilities.getCapabilities(context, intent));
       }
     }
+  }
+
+  private final class ExternalSurroundSoundSettingObserver extends ContentObserver {
+
+    private final ContentResolver resolver;
+    private final Uri settingUri;
+
+    public ExternalSurroundSoundSettingObserver(
+        Handler handler, ContentResolver resolver, Uri settingUri) {
+      super(handler);
+      this.resolver = resolver;
+      this.settingUri = settingUri;
+    }
 
+    public void register() {
+      resolver.registerContentObserver(settingUri, /* notifyForDescendants= */ false, this);
+    }
+
+    public void unregister() {
+      resolver.unregisterContentObserver(this);
+    }
+
+    @Override
+    public void onChange(boolean selfChange) {
+      onNewAudioCapabilities(AudioCapabilities.getCapabilities(context));
+    }
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
index 7146426a4a..3cc05e87df 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
@@ -18,9 +18,10 @@
 import android.content.Context;
 import android.media.AudioFocusRequest;
 import android.media.AudioManager;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import android.support.annotation.RequiresApi;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
@@ -99,7 +100,7 @@
   private static final float VOLUME_MULTIPLIER_DUCK = 0.2f;
   private static final float VOLUME_MULTIPLIER_DEFAULT = 1.0f;
 
-  private final @Nullable AudioManager audioManager;
+  private final AudioManager audioManager;
   private final AudioFocusListener focusListener;
   private final PlayerControl playerControl;
   private @Nullable AudioAttributes audioAttributes;
@@ -117,12 +118,9 @@
    * @param context The current context.
    * @param playerControl A {@link PlayerControl} to handle commands from this instance.
    */
-  public AudioFocusManager(@Nullable Context context, PlayerControl playerControl) {
+  public AudioFocusManager(Context context, PlayerControl playerControl) {
     this.audioManager =
-        context == null
-            ? null
-            : (AudioManager)
-                context.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        (AudioManager) context.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
     this.playerControl = playerControl;
     this.focusListener = new AudioFocusListener();
     this.audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
@@ -142,14 +140,9 @@ public float getVolumeMultiplier() {
    * @param playerState The current player state; {@link ExoPlayer#getPlaybackState()}.
    * @return A {@link PlayerCommand} to execute on the player.
    */
-  public @PlayerCommand int setAudioAttributes(
+  @PlayerCommand
+  public int setAudioAttributes(
       @Nullable AudioAttributes audioAttributes, boolean playWhenReady, int playerState) {
-    if (this.audioAttributes == null && audioAttributes == null) {
-      return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
-    }
-
-    Assertions.checkNotNull(
-        audioManager, "SimpleExoPlayer must be created with a context to handle audio focus.");
     if (!Util.areEqual(this.audioAttributes, audioAttributes)) {
       this.audioAttributes = audioAttributes;
       focusGain = convertAudioAttributesToFocusGain(audioAttributes);
@@ -174,11 +167,8 @@ public float getVolumeMultiplier() {
    * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
    * @return A {@link PlayerCommand} to execute on the player.
    */
-  public @PlayerCommand int handlePrepare(boolean playWhenReady) {
-    if (audioManager == null) {
-      return PLAYER_COMMAND_PLAY_WHEN_READY;
-    }
-
+  @PlayerCommand
+  public int handlePrepare(boolean playWhenReady) {
     return playWhenReady ? requestAudioFocus() : PLAYER_COMMAND_DO_NOT_PLAY;
   }
 
@@ -189,11 +179,8 @@ public float getVolumeMultiplier() {
    * @param playerState The current state of the player.
    * @return A {@link PlayerCommand} to execute on the player.
    */
-  public @PlayerCommand int handleSetPlayWhenReady(boolean playWhenReady, int playerState) {
-    if (audioManager == null) {
-      return PLAYER_COMMAND_PLAY_WHEN_READY;
-    }
-
+  @PlayerCommand
+  public int handleSetPlayWhenReady(boolean playWhenReady, int playerState) {
     if (!playWhenReady) {
       abandonAudioFocus();
       return PLAYER_COMMAND_DO_NOT_PLAY;
@@ -204,21 +191,23 @@ public float getVolumeMultiplier() {
 
   /** Called by the player as part of {@link ExoPlayer#stop(boolean)}. */
   public void handleStop() {
-    if (audioManager == null) {
-      return;
-    }
-
     abandonAudioFocus(/* forceAbandon= */ true);
   }
 
   // Internal methods.
 
+  @VisibleForTesting
+  /* package */ AudioManager.OnAudioFocusChangeListener getFocusListener() {
+    return focusListener;
+  }
+
   @PlayerCommand
   private int handleIdle(boolean playWhenReady) {
     return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
   }
 
-  private @PlayerCommand int requestAudioFocus() {
+  @PlayerCommand
+  private int requestAudioFocus() {
     int focusRequestResult;
 
     if (focusGain == C.AUDIOFOCUS_NONE) {
@@ -271,7 +260,6 @@ private void abandonAudioFocus(boolean forceAbandon) {
   }
 
   private int requestAudioFocusDefault() {
-    AudioManager audioManager = Assertions.checkNotNull(this.audioManager);
     return audioManager.requestAudioFocus(
         focusListener,
         Util.getStreamTypeForAudioUsage(Assertions.checkNotNull(audioAttributes).usage),
@@ -296,17 +284,17 @@ private int requestAudioFocusV26() {
 
       rebuildAudioFocusRequest = false;
     }
-    return Assertions.checkNotNull(audioManager).requestAudioFocus(audioFocusRequest);
+    return audioManager.requestAudioFocus(audioFocusRequest);
   }
 
   private void abandonAudioFocusDefault() {
-    Assertions.checkNotNull(audioManager).abandonAudioFocus(focusListener);
+    audioManager.abandonAudioFocus(focusListener);
   }
 
   @RequiresApi(26)
   private void abandonAudioFocusV26() {
     if (audioFocusRequest != null) {
-      Assertions.checkNotNull(audioManager).abandonAudioFocusRequest(audioFocusRequest);
+      audioManager.abandonAudioFocusRequest(audioFocusRequest);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
index f82be31f72..1bf141cb43 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
@@ -24,11 +24,10 @@
  * modifying its channel count, encoding and/or sample rate.
  *
  * <p>Call {@link #configure(int, int, int)} to configure the processor to receive input audio, then
- * call {@link #isActive()} to determine whether the processor is active. {@link
- * #queueInput(ByteBuffer)}, {@link #queueEndOfStream()}, {@link #getOutput()}, {@link #isEnded()},
- * {@link #getOutputChannelCount()}, {@link #getOutputEncoding()} and {@link
- * #getOutputSampleRateHz()} may only be called if the processor is active. Call {@link #reset()} to
- * reset the processor to its unconfigured state and release any resources.
+ * call {@link #isActive()} to determine whether the processor is active in the new configuration.
+ * {@link #queueInput(ByteBuffer)}, {@link #getOutputChannelCount()}, {@link #getOutputEncoding()}
+ * and {@link #getOutputSampleRateHz()} may only be called if the processor is active. Call {@link
+ * #reset()} to reset the processor to its unconfigured state and release any resources.
  *
  * <p>In addition to being able to modify the format of audio, implementations may allow parameters
  * to be set that affect the output audio and whether the processor is active/inactive.
@@ -38,7 +37,8 @@
   /** Exception thrown when a processor can't be configured for a given input audio format. */
   final class UnhandledFormatException extends Exception {
 
-    public UnhandledFormatException(int sampleRateHz, int channelCount, @C.Encoding int encoding) {
+    public UnhandledFormatException(
+        int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
       super("Unhandled format: " + sampleRateHz + " Hz, " + channelCount + " channels in encoding "
           + encoding);
     }
@@ -49,18 +49,24 @@ public UnhandledFormatException(int sampleRateHz, int channelCount, @C.Encoding
   ByteBuffer EMPTY_BUFFER = ByteBuffer.allocateDirect(0).order(ByteOrder.nativeOrder());
 
   /**
-   * Configures the processor to process input audio with the specified format and returns whether
-   * to {@link #flush()} it. After calling this method, if the processor is active, {@link
-   * #getOutputSampleRateHz()}, {@link #getOutputChannelCount()} and {@link #getOutputEncoding()}
-   * return its output format.
+   * Configures the processor to process input audio with the specified format. After calling this
+   * method, call {@link #isActive()} to determine whether the audio processor is active.
+   *
+   * <p>If the audio processor is active after configuration, call {@link #getOutputSampleRateHz()},
+   * {@link #getOutputChannelCount()} and {@link #getOutputEncoding()} to get its new output format.
+   *
+   * <p>If this method returns {@code true}, it is necessary to {@link #flush()} the processor
+   * before queueing more data, but you can (optionally) first drain output in the previous
+   * configuration by calling {@link #queueEndOfStream()} and {@link #getOutput()}. If this method
+   * returns {@code false}, it is safe to queue new input immediately.
    *
    * @param sampleRateHz The sample rate of input audio in Hz.
    * @param channelCount The number of interleaved channels in input audio.
    * @param encoding The encoding of input audio.
-   * @return Whether to {@link #flush()} the processor.
+   * @return Whether the processor must be {@link #flush() flushed} before queueing more input.
    * @throws UnhandledFormatException Thrown if the specified format can't be handled as input.
    */
-  boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+  boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
       throws UnhandledFormatException;
 
   /** Returns whether the processor is configured and will process input buffers. */
@@ -68,23 +74,20 @@ boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
 
   /**
    * Returns the number of audio channels in the data output by the processor. The value may change
-   * as a result of calling {@link #configure(int, int, int)} and is undefined if the instance is
-   * not active.
+   * as a result of calling {@link #configure(int, int, int)}.
    */
   int getOutputChannelCount();
 
   /**
    * Returns the audio encoding used in the data output by the processor. The value may change as a
-   * result of calling {@link #configure(int, int, int)} and is undefined if the instance is not
-   * active.
+   * result of calling {@link #configure(int, int, int)}.
    */
-  @C.Encoding
+  @C.PcmEncoding
   int getOutputEncoding();
 
   /**
    * Returns the sample rate of audio output by the processor, in hertz. The value may change as a
-   * result of calling {@link #configure(int, int, int)} and is undefined if the instance is not
-   * active.
+   * result of calling {@link #configure(int, int, int)}.
    */
   int getOutputSampleRateHz();
 
@@ -123,7 +126,10 @@ boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
    */
   boolean isEnded();
 
-  /** Clears any state in preparation for receiving a new stream of input buffers. */
+  /**
+   * Clears any buffered data and pending output. If the audio processor is active, also prepares
+   * the audio processor to receive a new stream of input in the last configured (pending) format.
+   */
   void flush();
 
   /** Resets the processor to its unconfigured state. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
index eff7bc8de2..042738b4f6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
@@ -17,7 +17,7 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Renderer;
@@ -147,6 +147,7 @@ public void audioTrackUnderrun(final int bufferSize, final long bufferSizeMs,
      * Invokes {@link AudioRendererEventListener#onAudioDisabled(DecoderCounters)}.
      */
     public void disabled(final DecoderCounters counters) {
+      counters.ensureUpdated();
       if (listener != null) {
         handler.post(
             () -> {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
index 24d218bf3c..393380453c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.audio;
 
 import android.media.AudioTrack;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -24,29 +24,30 @@
 
 /**
  * A sink that consumes audio data.
- * <p>
- * Before starting playback, specify the input audio format by calling
- * {@link #configure(int, int, int, int, int[], int, int)}.
- * <p>
- * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
+ *
+ * <p>Before starting playback, specify the input audio format by calling {@link #configure(int,
+ * int, int, int, int[], int, int)}.
+ *
+ * <p>Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
  * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
- * <p>
- * Call {@link #configure(int, int, int, int, int[], int, int)} whenever the input format changes.
- * The sink will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long)}.
- * <p>
- * Call {@link #reset()} to prepare the sink to receive audio data from a new playback position.
- * <p>
- * Call {@link #playToEndOfStream()} repeatedly to play out all data when no more input buffers will
- * be provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #reset()}. Call
- * {@link #release()} when the instance is no longer required.
- * <p>
- * The implementation may be backed by a platform {@link AudioTrack}. In this case,
- * {@link #setAudioSessionId(int)}, {@link #setAudioAttributes(AudioAttributes)},
- * {@link #enableTunnelingV21(int)} and/or {@link #disableTunneling()} may be called before writing
- * data to the sink. These methods may also be called after writing data to the sink, in which case
- * it will be reinitialized as required. For implementations that are not based on platform
- * {@link AudioTrack}s, calling methods relating to audio sessions, audio attributes, and tunneling
- * may have no effect.
+ *
+ * <p>Call {@link #configure(int, int, int, int, int[], int, int)} whenever the input format
+ * changes. The sink will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer,
+ * long)}.
+ *
+ * <p>Call {@link #flush()} to prepare the sink to receive audio data from a new playback position.
+ *
+ * <p>Call {@link #playToEndOfStream()} repeatedly to play out all data when no more input buffers
+ * will be provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #flush()}.
+ * Call {@link #reset()} when the instance is no longer required.
+ *
+ * <p>The implementation may be backed by a platform {@link AudioTrack}. In this case, {@link
+ * #setAudioSessionId(int)}, {@link #setAudioAttributes(AudioAttributes)}, {@link
+ * #enableTunnelingV21(int)} and/or {@link #disableTunneling()} may be called before writing data to
+ * the sink. These methods may also be called after writing data to the sink, in which case it will
+ * be reinitialized as required. For implementations that are not based on platform {@link
+ * AudioTrack}s, calling methods relating to audio sessions, audio attributes, and tunneling may
+ * have no effect.
  */
 public interface AudioSink {
 
@@ -199,7 +200,7 @@ public WriteException(int errorCode) {
    * @param trimStartFrames The number of audio frames to trim from the start of data written to the
    *     sink after this call.
    * @param trimEndFrames The number of audio frames to trim from data written to the sink
-   *     immediately preceding the next call to {@link #reset()} or this method.
+   *     immediately preceding the next call to {@link #flush()} or this method.
    * @throws ConfigurationException If an error occurs configuring the sink.
    */
   void configure(
@@ -225,11 +226,11 @@ void configure(
    * ending at its limit (exclusive). The position of the {@link ByteBuffer} is advanced by the
    * number of bytes that were handled. {@link Listener#onPositionDiscontinuity()} will be called if
    * {@code presentationTimeUs} is discontinuous with the last buffer handled since the last reset.
-   * <p>
-   * Returns whether the data was handled in full. If the data was not handled in full then the same
-   * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
-   * except in the case of an intervening call to {@link #reset()} (or to
-   * {@link #configure(int, int, int, int, int[], int, int)} that causes the sink to be reset).
+   *
+   * <p>Returns whether the data was handled in full. If the data was not handled in full then the
+   * same {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
+   * except in the case of an intervening call to {@link #flush()} (or to {@link #configure(int,
+   * int, int, int, int[], int, int)} that causes the sink to be flushed).
    *
    * @param buffer The buffer containing audio data.
    * @param presentationTimeUs The presentation timestamp of the buffer in microseconds.
@@ -318,15 +319,12 @@ boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
   void pause();
 
   /**
-   * Resets the sink, after which it is ready to receive buffers from a new playback position.
-   * <p>
-   * The audio session may remain active until {@link #release()} is called.
-   */
-  void reset();
-
-  /**
-   * Releases any resources associated with this instance.
+   * Flushes the sink, after which it is ready to receive buffers from a new playback position.
+   *
+   * <p>The audio session may remain active until {@link #reset()} is called.
    */
-  void release();
+  void flush();
 
+  /** Resets the renderer, releasing any resources that it currently holds. */
+  void reset();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
index 569260efeb..d43972d7b0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
@@ -18,8 +18,8 @@
 import android.annotation.TargetApi;
 import android.media.AudioTimestamp;
 import android.media.AudioTrack;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
index 62b120f00a..e87e49d2da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
@@ -20,8 +20,8 @@
 import android.media.AudioTimestamp;
 import android.media.AudioTrack;
 import android.os.SystemClock;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -517,7 +517,7 @@ private long getPlaybackHeadPosition() {
       rawPlaybackHeadPosition += passthroughWorkaroundPauseOffset;
     }
 
-    if (Util.SDK_INT <= 28) {
+    if (Util.SDK_INT <= 29) {
       if (rawPlaybackHeadPosition == 0
           && lastRawPlaybackHeadPosition > 0
           && state == PLAYSTATE_PLAYING) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java
index 7462a9c4b0..968d8acebd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AuxEffectInfo.java
@@ -17,7 +17,7 @@
 
 import android.media.AudioTrack;
 import android.media.audiofx.AudioEffect;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * Represents auxiliary effect information, which can be used to attach an auxiliary effect to an
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java
new file mode 100644
index 0000000000..a3a85bb43a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import androidx.annotation.CallSuper;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Base class for audio processors that keep an output buffer and an internal buffer that is reused
+ * whenever input is queued.
+ */
+public abstract class BaseAudioProcessor implements AudioProcessor {
+
+  /** The configured input sample rate, in Hertz, or {@link Format#NO_VALUE} if not configured. */
+  protected int sampleRateHz;
+  /** The configured input channel count, or {@link Format#NO_VALUE} if not configured. */
+  protected int channelCount;
+  /** The configured input encoding, or {@link Format#NO_VALUE} if not configured. */
+  @C.PcmEncoding protected int encoding;
+
+  private ByteBuffer buffer;
+  private ByteBuffer outputBuffer;
+  private boolean inputEnded;
+
+  public BaseAudioProcessor() {
+    buffer = EMPTY_BUFFER;
+    outputBuffer = EMPTY_BUFFER;
+    channelCount = Format.NO_VALUE;
+    sampleRateHz = Format.NO_VALUE;
+    encoding = Format.NO_VALUE;
+  }
+
+  @Override
+  public boolean isActive() {
+    return sampleRateHz != Format.NO_VALUE;
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return channelCount;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return encoding;
+  }
+
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
+  @Override
+  public final void queueEndOfStream() {
+    inputEnded = true;
+    onQueueEndOfStream();
+  }
+
+  @CallSuper
+  @Override
+  public ByteBuffer getOutput() {
+    ByteBuffer outputBuffer = this.outputBuffer;
+    this.outputBuffer = EMPTY_BUFFER;
+    return outputBuffer;
+  }
+
+  @CallSuper
+  @SuppressWarnings("ReferenceEquality")
+  @Override
+  public boolean isEnded() {
+    return inputEnded && outputBuffer == EMPTY_BUFFER;
+  }
+
+  @Override
+  public final void flush() {
+    outputBuffer = EMPTY_BUFFER;
+    inputEnded = false;
+    onFlush();
+  }
+
+  @Override
+  public final void reset() {
+    flush();
+    buffer = EMPTY_BUFFER;
+    sampleRateHz = Format.NO_VALUE;
+    channelCount = Format.NO_VALUE;
+    encoding = Format.NO_VALUE;
+    onReset();
+  }
+
+  /** Sets the input format of this processor, returning whether the input format has changed. */
+  protected final boolean setInputFormat(
+      int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
+    if (sampleRateHz == this.sampleRateHz
+        && channelCount == this.channelCount
+        && encoding == this.encoding) {
+      return false;
+    }
+    this.sampleRateHz = sampleRateHz;
+    this.channelCount = channelCount;
+    this.encoding = encoding;
+    return true;
+  }
+
+  /**
+   * Replaces the current output buffer with a buffer of at least {@code count} bytes and returns
+   * it. Callers should write to the returned buffer then {@link ByteBuffer#flip()} it so it can be
+   * read via {@link #getOutput()}.
+   */
+  protected final ByteBuffer replaceOutputBuffer(int count) {
+    if (buffer.capacity() < count) {
+      buffer = ByteBuffer.allocateDirect(count).order(ByteOrder.nativeOrder());
+    } else {
+      buffer.clear();
+    }
+    outputBuffer = buffer;
+    return buffer;
+  }
+
+  /** Returns whether the current output buffer has any data remaining. */
+  protected final boolean hasPendingOutput() {
+    return outputBuffer.hasRemaining();
+  }
+
+  /** Called when the end-of-stream is queued to the processor. */
+  protected void onQueueEndOfStream() {
+    // Do nothing.
+  }
+
+  /** Called when the processor is flushed, directly or as part of resetting. */
+  protected void onFlush() {
+    // Do nothing.
+  }
+
+  /** Called when the processor is reset. */
+  protected void onReset() {
+    // Do nothing.
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
index e53eb08c83..ea155323bb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
@@ -15,38 +15,22 @@
  */
 package com.google.android.exoplayer2.audio;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.C.Encoding;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 import java.util.Arrays;
 
 /**
  * An {@link AudioProcessor} that applies a mapping from input channels onto specified output
  * channels. This can be used to reorder, duplicate or discard channels.
  */
-/* package */ final class ChannelMappingAudioProcessor implements AudioProcessor {
+/* package */ final class ChannelMappingAudioProcessor extends BaseAudioProcessor {
 
-  private int channelCount;
-  private int sampleRateHz;
-  private @Nullable int[] pendingOutputChannels;
+  @Nullable private int[] pendingOutputChannels;
 
   private boolean active;
-  private @Nullable int[] outputChannels;
-  private ByteBuffer buffer;
-  private ByteBuffer outputBuffer;
-  private boolean inputEnded;
-
-  /** Creates a new processor that applies a channel mapping. */
-  public ChannelMappingAudioProcessor() {
-    buffer = EMPTY_BUFFER;
-    outputBuffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
-  }
+  @Nullable private int[] outputChannels;
 
   /**
    * Resets the channel mapping. After calling this method, call {@link #configure(int, int, int)}
@@ -61,10 +45,12 @@ public void setChannelMap(@Nullable int[] outputChannels) {
   }
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @Encoding int encoding)
+  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
       throws UnhandledFormatException {
     boolean outputChannelsChanged = !Arrays.equals(pendingOutputChannels, outputChannels);
     outputChannels = pendingOutputChannels;
+
+    int[] outputChannels = this.outputChannels;
     if (outputChannels == null) {
       active = false;
       return outputChannelsChanged;
@@ -72,12 +58,9 @@ public boolean configure(int sampleRateHz, int channelCount, @Encoding int encod
     if (encoding != C.ENCODING_PCM_16BIT) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
-    if (!outputChannelsChanged && this.sampleRateHz == sampleRateHz
-        && this.channelCount == channelCount) {
+    if (!outputChannelsChanged && !setInputFormat(sampleRateHz, channelCount, encoding)) {
       return false;
     }
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
 
     active = channelCount != outputChannels.length;
     for (int i = 0; i < outputChannels.length; i++) {
@@ -100,28 +83,14 @@ public int getOutputChannelCount() {
     return outputChannels == null ? channelCount : outputChannels.length;
   }
 
-  @Override
-  public int getOutputEncoding() {
-    return C.ENCODING_PCM_16BIT;
-  }
-
-  @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
-  }
-
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
-    Assertions.checkState(outputChannels != null);
+    int[] outputChannels = Assertions.checkNotNull(this.outputChannels);
     int position = inputBuffer.position();
     int limit = inputBuffer.limit();
     int frameCount = (limit - position) / (2 * channelCount);
     int outputSize = frameCount * outputChannels.length * 2;
-    if (buffer.capacity() < outputSize) {
-      buffer = ByteBuffer.allocateDirect(outputSize).order(ByteOrder.nativeOrder());
-    } else {
-      buffer.clear();
-    }
+    ByteBuffer buffer = replaceOutputBuffer(outputSize);
     while (position < limit) {
       for (int channelIndex : outputChannels) {
         buffer.putShort(inputBuffer.getShort(position + 2 * channelIndex));
@@ -130,39 +99,10 @@ public void queueInput(ByteBuffer inputBuffer) {
     }
     inputBuffer.position(limit);
     buffer.flip();
-    outputBuffer = buffer;
-  }
-
-  @Override
-  public void queueEndOfStream() {
-    inputEnded = true;
-  }
-
-  @Override
-  public ByteBuffer getOutput() {
-    ByteBuffer outputBuffer = this.outputBuffer;
-    this.outputBuffer = EMPTY_BUFFER;
-    return outputBuffer;
-  }
-
-  @SuppressWarnings("ReferenceEquality")
-  @Override
-  public boolean isEnded() {
-    return inputEnded && outputBuffer == EMPTY_BUFFER;
-  }
-
-  @Override
-  public void flush() {
-    outputBuffer = EMPTY_BUFFER;
-    inputEnded = false;
   }
 
   @Override
-  public void reset() {
-    flush();
-    buffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
+  protected void onReset() {
     outputChannels = null;
     pendingOutputChannels = null;
     active = false;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 429510bcaf..ffcd893e7b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -22,8 +22,8 @@
 import android.media.AudioTrack;
 import android.os.ConditionVariable;
 import android.os.SystemClock;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -242,18 +242,11 @@ public long getSkippedOutputFrameCount() {
   /** Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}). */
   @Nullable private AudioTrack keepSessionIdAudioTrack;
 
+  @Nullable private Configuration pendingConfiguration;
+  private Configuration configuration;
   private AudioTrack audioTrack;
-  private boolean isInputPcm;
-  private boolean shouldConvertHighResIntPcmToFloat;
-  private int inputSampleRate;
-  private int outputSampleRate;
-  private int outputChannelConfig;
-  private @C.Encoding int outputEncoding;
-  private AudioAttributes audioAttributes;
-  private boolean processingEnabled;
-  private boolean canApplyPlaybackParameters;
-  private int bufferSize;
 
+  private AudioAttributes audioAttributes;
   @Nullable private PlaybackParameters afterDrainPlaybackParameters;
   private PlaybackParameters playbackParameters;
   private long playbackParametersOffsetUs;
@@ -262,10 +255,8 @@ public long getSkippedOutputFrameCount() {
   @Nullable private ByteBuffer avSyncHeader;
   private int bytesUntilNextAvSync;
 
-  private int pcmFrameSize;
   private long submittedPcmBytes;
   private long submittedEncodedFrames;
-  private int outputPcmFrameSize;
   private long writtenPcmBytes;
   private long writtenEncodedFrames;
   private int framesPerEncodedSample;
@@ -354,8 +345,7 @@ public DefaultAudioSink(
         channelMappingAudioProcessor,
         trimmingAudioProcessor);
     Collections.addAll(toIntPcmAudioProcessors, audioProcessorChain.getAudioProcessors());
-    toIntPcmAvailableAudioProcessors =
-        toIntPcmAudioProcessors.toArray(new AudioProcessor[toIntPcmAudioProcessors.size()]);
+    toIntPcmAvailableAudioProcessors = toIntPcmAudioProcessors.toArray(new AudioProcessor[0]);
     toFloatPcmAvailableAudioProcessors = new AudioProcessor[] {new FloatResamplingAudioProcessor()};
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
@@ -398,7 +388,7 @@ public long getCurrentPositionUs(boolean sourceEnded) {
       return CURRENT_POSITION_NOT_SET;
     }
     long positionUs = audioTrackPositionTracker.getCurrentPositionUs(sourceEnded);
-    positionUs = Math.min(positionUs, framesToDurationUs(getWrittenFrames()));
+    positionUs = Math.min(positionUs, configuration.framesToDurationUs(getWrittenFrames()));
     return startMediaTimeUs + applySkipping(applySpeedup(positionUs));
   }
 
@@ -412,23 +402,7 @@ public void configure(
       int trimStartFrames,
       int trimEndFrames)
       throws ConfigurationException {
-    boolean flush = false;
-    this.inputSampleRate = inputSampleRate;
-    int channelCount = inputChannelCount;
-    int sampleRate = inputSampleRate;
-    isInputPcm = Util.isEncodingLinearPcm(inputEncoding);
-    shouldConvertHighResIntPcmToFloat =
-        enableConvertHighResIntPcmToFloat
-            && supportsOutput(channelCount, C.ENCODING_PCM_32BIT)
-            && Util.isEncodingHighResolutionIntegerPcm(inputEncoding);
-    if (isInputPcm) {
-      pcmFrameSize = Util.getPcmFrameSize(inputEncoding, channelCount);
-    }
-    @C.Encoding int encoding = inputEncoding;
-    boolean processingEnabled = isInputPcm && inputEncoding != C.ENCODING_PCM_FLOAT;
-    canApplyPlaybackParameters = processingEnabled && !shouldConvertHighResIntPcmToFloat;
-
-    if (Util.SDK_INT < 21 && channelCount == 8 && outputChannels == null) {
+    if (Util.SDK_INT < 21 && inputChannelCount == 8 && outputChannels == null) {
       // AudioTrack doesn't support 8 channel output before Android L. Discard the last two (side)
       // channels to give a 6 channel stream that is supported.
       outputChannels = new int[6];
@@ -437,12 +411,26 @@ public void configure(
       }
     }
 
+    boolean isInputPcm = Util.isEncodingLinearPcm(inputEncoding);
+    boolean processingEnabled = isInputPcm && inputEncoding != C.ENCODING_PCM_FLOAT;
+    int sampleRate = inputSampleRate;
+    int channelCount = inputChannelCount;
+    @C.Encoding int encoding = inputEncoding;
+    boolean shouldConvertHighResIntPcmToFloat =
+        enableConvertHighResIntPcmToFloat
+            && supportsOutput(inputChannelCount, C.ENCODING_PCM_FLOAT)
+            && Util.isEncodingHighResolutionIntegerPcm(inputEncoding);
+    AudioProcessor[] availableAudioProcessors =
+        shouldConvertHighResIntPcmToFloat
+            ? toFloatPcmAvailableAudioProcessors
+            : toIntPcmAvailableAudioProcessors;
+    boolean flushAudioProcessors = false;
     if (processingEnabled) {
       trimmingAudioProcessor.setTrimFrameCount(trimStartFrames, trimEndFrames);
       channelMappingAudioProcessor.setChannelMap(outputChannels);
-      for (AudioProcessor audioProcessor : getAvailableAudioProcessors()) {
+      for (AudioProcessor audioProcessor : availableAudioProcessors) {
         try {
-          flush |= audioProcessor.configure(sampleRate, channelCount, encoding);
+          flushAudioProcessors |= audioProcessor.configure(sampleRate, channelCount, encoding);
         } catch (AudioProcessor.UnhandledFormatException e) {
           throw new ConfigurationException(e);
         }
@@ -454,53 +442,48 @@ public void configure(
       }
     }
 
-    int channelConfig = getChannelConfig(channelCount, isInputPcm);
-    if (channelConfig == AudioFormat.CHANNEL_INVALID) {
+    int outputChannelConfig = getChannelConfig(channelCount, isInputPcm);
+    if (outputChannelConfig == AudioFormat.CHANNEL_INVALID) {
       throw new ConfigurationException("Unsupported channel count: " + channelCount);
     }
 
-    if (!flush
-        && isInitialized()
-        && outputEncoding == encoding
-        && outputSampleRate == sampleRate
-        && outputChannelConfig == channelConfig) {
-      // We already have an audio track with the correct sample rate, channel config and encoding.
-      return;
-    }
-
-    reset();
-
-    this.processingEnabled = processingEnabled;
-    outputSampleRate = sampleRate;
-    outputChannelConfig = channelConfig;
-    outputEncoding = encoding;
-    outputPcmFrameSize =
-        isInputPcm ? Util.getPcmFrameSize(outputEncoding, channelCount) : C.LENGTH_UNSET;
-    bufferSize = specifiedBufferSize != 0 ? specifiedBufferSize : getDefaultBufferSize();
-  }
-
-  private int getDefaultBufferSize() {
-    if (isInputPcm) {
-      int minBufferSize =
-          AudioTrack.getMinBufferSize(outputSampleRate, outputChannelConfig, outputEncoding);
-      Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
-      int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
-      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
-      int maxAppBufferSize = (int) Math.max(minBufferSize,
-          durationUsToFrames(MAX_BUFFER_DURATION_US) * outputPcmFrameSize);
-      return Util.constrainValue(multipliedBufferSize, minAppBufferSize, maxAppBufferSize);
-    } else {
-      int rate = getMaximumEncodedRateBytesPerSecond(outputEncoding);
-      if (outputEncoding == C.ENCODING_AC3) {
-        rate *= AC3_BUFFER_MULTIPLICATION_FACTOR;
+    int inputPcmFrameSize =
+        isInputPcm ? Util.getPcmFrameSize(inputEncoding, inputChannelCount) : C.LENGTH_UNSET;
+    int outputPcmFrameSize =
+        isInputPcm ? Util.getPcmFrameSize(encoding, channelCount) : C.LENGTH_UNSET;
+    boolean canApplyPlaybackParameters = processingEnabled && !shouldConvertHighResIntPcmToFloat;
+    Configuration pendingConfiguration =
+        new Configuration(
+            isInputPcm,
+            inputPcmFrameSize,
+            inputSampleRate,
+            outputPcmFrameSize,
+            sampleRate,
+            outputChannelConfig,
+            encoding,
+            specifiedBufferSize,
+            processingEnabled,
+            canApplyPlaybackParameters,
+            availableAudioProcessors);
+    if (isInitialized()) {
+      if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
+        // We need a new AudioTrack before we can handle more input. We should first stop() the
+        // track and wait for audio to play out (tracked by [Internal: b/33161961]), but for now we
+        // discard the audio track immediately.
+        flush();
+      } else if (flushAudioProcessors) {
+        // We don't need a new AudioTrack but audio processors need to be drained and flushed.
+        this.pendingConfiguration = pendingConfiguration;
+        return;
       }
-      return (int) (PASSTHROUGH_BUFFER_DURATION_US * rate / C.MICROS_PER_SECOND);
     }
+    configuration = pendingConfiguration;
   }
 
   private void setupAudioProcessors() {
+    AudioProcessor[] audioProcessors = configuration.availableAudioProcessors;
     ArrayList<AudioProcessor> newAudioProcessors = new ArrayList<>();
-    for (AudioProcessor audioProcessor : getAvailableAudioProcessors()) {
+    for (AudioProcessor audioProcessor : audioProcessors) {
       if (audioProcessor.isActive()) {
         newAudioProcessors.add(audioProcessor);
       } else {
@@ -529,7 +512,9 @@ private void initialize() throws InitializationException {
     // initialization of the audio track to fail.
     releasingConditionVariable.block();
 
-    audioTrack = initializeAudioTrack();
+    audioTrack =
+        Assertions.checkNotNull(configuration)
+            .buildAudioTrack(tunneling, audioAttributes, audioSessionId);
     int audioSessionId = audioTrack.getAudioSessionId();
     if (enablePreV21AudioSessionWorkaround) {
       if (Util.SDK_INT < 21) {
@@ -552,13 +537,16 @@ private void initialize() throws InitializationException {
     }
 
     playbackParameters =
-        canApplyPlaybackParameters
+        configuration.canApplyPlaybackParameters
             ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
             : PlaybackParameters.DEFAULT;
     setupAudioProcessors();
 
     audioTrackPositionTracker.setAudioTrack(
-        audioTrack, outputEncoding, outputPcmFrameSize, bufferSize);
+        audioTrack,
+        configuration.outputEncoding,
+        configuration.outputPcmFrameSize,
+        configuration.bufferSize);
     setVolumeInternal();
 
     if (auxEffectInfo.effectId != AuxEffectInfo.NO_AUX_EFFECT_ID) {
@@ -589,6 +577,21 @@ public void handleDiscontinuity() {
   public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       throws InitializationException, WriteException {
     Assertions.checkArgument(inputBuffer == null || buffer == inputBuffer);
+
+    if (pendingConfiguration != null) {
+      // We are waiting for audio processors to drain before applying a the new configuration.
+      if (!drainAudioProcessorsToEndOfStream()) {
+        return false;
+      }
+      configuration = pendingConfiguration;
+      pendingConfiguration = null;
+      playbackParameters =
+          configuration.canApplyPlaybackParameters
+              ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
+              : PlaybackParameters.DEFAULT;
+      setupAudioProcessors();
+    }
+
     if (!isInitialized()) {
       initialize();
       if (playing) {
@@ -607,9 +610,9 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         return true;
       }
 
-      if (!isInputPcm && framesPerEncodedSample == 0) {
+      if (!configuration.isInputPcm && framesPerEncodedSample == 0) {
         // If this is the first encoded sample, calculate the sample size in frames.
-        framesPerEncodedSample = getFramesPerEncodedSample(outputEncoding, buffer);
+        framesPerEncodedSample = getFramesPerEncodedSample(configuration.outputEncoding, buffer);
         if (framesPerEncodedSample == 0) {
           // We still don't know the number of frames per sample, so drop the buffer.
           // For TrueHD this can occur after some seek operations, as not every sample starts with
@@ -632,7 +635,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
             new PlaybackParametersCheckpoint(
                 newPlaybackParameters,
                 Math.max(0, presentationTimeUs),
-                framesToDurationUs(getWrittenFrames())));
+                configuration.framesToDurationUs(getWrittenFrames())));
         // Update the set of active audio processors to take into account the new parameters.
         setupAudioProcessors();
       }
@@ -644,7 +647,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         // Sanity check that presentationTimeUs is consistent with the expected value.
         long expectedPresentationTimeUs =
             startMediaTimeUs
-                + inputFramesToDurationUs(
+                + configuration.inputFramesToDurationUs(
                     getSubmittedFrames() - trimmingAudioProcessor.getTrimmedFrameCount());
         if (startMediaTimeState == START_IN_SYNC
             && Math.abs(expectedPresentationTimeUs - presentationTimeUs) > 200000) {
@@ -664,7 +667,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         }
       }
 
-      if (isInputPcm) {
+      if (configuration.isInputPcm) {
         submittedPcmBytes += buffer.remaining();
       } else {
         submittedEncodedFrames += framesPerEncodedSample;
@@ -673,7 +676,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       inputBuffer = buffer;
     }
 
-    if (processingEnabled) {
+    if (configuration.processingEnabled) {
       processBuffers(presentationTimeUs);
     } else {
       writeBuffer(inputBuffer, presentationTimeUs);
@@ -686,7 +689,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
 
     if (audioTrackPositionTracker.isStalled(getWrittenFrames())) {
       Log.w(TAG, "Resetting stalled audio track");
-      reset();
+      flush();
       return true;
     }
 
@@ -770,11 +773,11 @@ private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throw
       throw new WriteException(bytesWritten);
     }
 
-    if (isInputPcm) {
+    if (configuration.isInputPcm) {
       writtenPcmBytes += bytesWritten;
     }
     if (bytesWritten == bytesRemaining) {
-      if (!isInputPcm) {
+      if (!configuration.isInputPcm) {
         writtenEncodedFrames += framesPerEncodedSample;
       }
       outputBuffer = null;
@@ -799,7 +802,8 @@ public void playToEndOfStream() throws WriteException {
   private boolean drainAudioProcessorsToEndOfStream() throws WriteException {
     boolean audioProcessorNeedsEndOfStream = false;
     if (drainingAudioProcessorIndex == C.INDEX_UNSET) {
-      drainingAudioProcessorIndex = processingEnabled ? 0 : activeAudioProcessors.length;
+      drainingAudioProcessorIndex =
+          configuration.processingEnabled ? 0 : activeAudioProcessors.length;
       audioProcessorNeedsEndOfStream = true;
     }
     while (drainingAudioProcessorIndex < activeAudioProcessors.length) {
@@ -838,7 +842,7 @@ public boolean hasPendingData() {
 
   @Override
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
-    if (isInitialized() && !canApplyPlaybackParameters) {
+    if (configuration != null && !configuration.canApplyPlaybackParameters) {
       this.playbackParameters = PlaybackParameters.DEFAULT;
       return this.playbackParameters;
     }
@@ -876,7 +880,7 @@ public void setAudioAttributes(AudioAttributes audioAttributes) {
       // The audio attributes are ignored in tunneling mode, so no need to reset.
       return;
     }
-    reset();
+    flush();
     audioSessionId = C.AUDIO_SESSION_ID_UNSET;
   }
 
@@ -884,7 +888,7 @@ public void setAudioAttributes(AudioAttributes audioAttributes) {
   public void setAudioSessionId(int audioSessionId) {
     if (this.audioSessionId != audioSessionId) {
       this.audioSessionId = audioSessionId;
-      reset();
+      flush();
     }
   }
 
@@ -912,7 +916,7 @@ public void enableTunnelingV21(int tunnelingAudioSessionId) {
     if (!tunneling || audioSessionId != tunnelingAudioSessionId) {
       tunneling = true;
       audioSessionId = tunnelingAudioSessionId;
-      reset();
+      flush();
     }
   }
 
@@ -921,7 +925,7 @@ public void disableTunneling() {
     if (tunneling) {
       tunneling = false;
       audioSessionId = C.AUDIO_SESSION_ID_UNSET;
-      reset();
+      flush();
     }
   }
 
@@ -952,7 +956,7 @@ public void pause() {
   }
 
   @Override
-  public void reset() {
+  public void flush() {
     if (isInitialized()) {
       submittedPcmBytes = 0;
       submittedEncodedFrames = 0;
@@ -969,9 +973,9 @@ public void reset() {
       playbackParametersOffsetUs = 0;
       playbackParametersPositionUs = 0;
       trimmingAudioProcessor.resetTrimmedFrameCount();
+      flushAudioProcessors();
       inputBuffer = null;
       outputBuffer = null;
-      flushAudioProcessors();
       handledEndOfStream = false;
       drainingAudioProcessorIndex = C.INDEX_UNSET;
       avSyncHeader = null;
@@ -983,6 +987,10 @@ public void reset() {
       // AudioTrack.release can take some time, so we call it on a background thread.
       final AudioTrack toRelease = audioTrack;
       audioTrack = null;
+      if (pendingConfiguration != null) {
+        configuration = pendingConfiguration;
+        pendingConfiguration = null;
+      }
       audioTrackPositionTracker.reset();
       releasingConditionVariable.close();
       new Thread() {
@@ -1000,8 +1008,8 @@ public void run() {
   }
 
   @Override
-  public void release() {
-    reset();
+  public void reset() {
+    flush();
     releaseKeepSessionIdAudioTrack();
     for (AudioProcessor audioProcessor : toIntPcmAvailableAudioProcessors) {
       audioProcessor.reset();
@@ -1061,99 +1069,27 @@ private long applySpeedup(long positionUs) {
   }
 
   private long applySkipping(long positionUs) {
-    return positionUs + framesToDurationUs(audioProcessorChain.getSkippedOutputFrameCount());
+    return positionUs
+        + configuration.framesToDurationUs(audioProcessorChain.getSkippedOutputFrameCount());
   }
 
   private boolean isInitialized() {
     return audioTrack != null;
   }
 
-  private long inputFramesToDurationUs(long frameCount) {
-    return (frameCount * C.MICROS_PER_SECOND) / inputSampleRate;
-  }
-
-  private long framesToDurationUs(long frameCount) {
-    return (frameCount * C.MICROS_PER_SECOND) / outputSampleRate;
-  }
-
-  private long durationUsToFrames(long durationUs) {
-    return (durationUs * outputSampleRate) / C.MICROS_PER_SECOND;
-  }
-
   private long getSubmittedFrames() {
-    return isInputPcm ? (submittedPcmBytes / pcmFrameSize) : submittedEncodedFrames;
+    return configuration.isInputPcm
+        ? (submittedPcmBytes / configuration.inputPcmFrameSize)
+        : submittedEncodedFrames;
   }
 
   private long getWrittenFrames() {
-    return isInputPcm ? (writtenPcmBytes / outputPcmFrameSize) : writtenEncodedFrames;
+    return configuration.isInputPcm
+        ? (writtenPcmBytes / configuration.outputPcmFrameSize)
+        : writtenEncodedFrames;
   }
 
-  private AudioTrack initializeAudioTrack() throws InitializationException {
-    AudioTrack audioTrack;
-    if (Util.SDK_INT >= 21) {
-      audioTrack = createAudioTrackV21();
-    } else {
-      int streamType = Util.getStreamTypeForAudioUsage(audioAttributes.usage);
-      if (audioSessionId == C.AUDIO_SESSION_ID_UNSET) {
-        audioTrack =
-            new AudioTrack(
-                streamType,
-                outputSampleRate,
-                outputChannelConfig,
-                outputEncoding,
-                bufferSize,
-                MODE_STREAM);
-      } else {
-        // Re-attach to the same audio session.
-        audioTrack =
-            new AudioTrack(
-                streamType,
-                outputSampleRate,
-                outputChannelConfig,
-                outputEncoding,
-                bufferSize,
-                MODE_STREAM,
-                audioSessionId);
-      }
-    }
-
-    int state = audioTrack.getState();
-    if (state != STATE_INITIALIZED) {
-      try {
-        audioTrack.release();
-      } catch (Exception e) {
-        // The track has already failed to initialize, so it wouldn't be that surprising if release
-        // were to fail too. Swallow the exception.
-      }
-      throw new InitializationException(state, outputSampleRate, outputChannelConfig, bufferSize);
-    }
-    return audioTrack;
-  }
-
-  @TargetApi(21)
-  private AudioTrack createAudioTrackV21() {
-    android.media.AudioAttributes attributes;
-    if (tunneling) {
-      attributes = new android.media.AudioAttributes.Builder()
-          .setContentType(android.media.AudioAttributes.CONTENT_TYPE_MOVIE)
-          .setFlags(android.media.AudioAttributes.FLAG_HW_AV_SYNC)
-          .setUsage(android.media.AudioAttributes.USAGE_MEDIA)
-          .build();
-    } else {
-      attributes = audioAttributes.getAudioAttributesV21();
-    }
-    AudioFormat format =
-        new AudioFormat.Builder()
-            .setChannelMask(outputChannelConfig)
-            .setEncoding(outputEncoding)
-            .setSampleRate(outputSampleRate)
-            .build();
-    int audioSessionId = this.audioSessionId != C.AUDIO_SESSION_ID_UNSET ? this.audioSessionId
-        : AudioManager.AUDIO_SESSION_ID_GENERATE;
-    return new AudioTrack(attributes, format, bufferSize, MODE_STREAM, audioSessionId);
-  }
-
-  private AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
+  private static AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
     int sampleRate = 4000; // Equal to private AudioTrack.MIN_SAMPLE_RATE.
     int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
     @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;
@@ -1162,12 +1098,6 @@ private AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
         MODE_STATIC, audioSessionId);
   }
 
-  private AudioProcessor[] getAvailableAudioProcessors() {
-    return shouldConvertHighResIntPcmToFloat
-        ? toFloatPcmAvailableAudioProcessors
-        : toIntPcmAvailableAudioProcessors;
-  }
-
   private static int getChannelConfig(int channelCount, boolean isInputPcm) {
     if (Util.SDK_INT <= 28 && !isInputPcm) {
       // In passthrough mode the channel count used to configure the audio track doesn't affect how
@@ -1196,6 +1126,8 @@ private static int getMaximumEncodedRateBytesPerSecond(@C.Encoding int encoding)
         return 640 * 1000 / 8;
       case C.ENCODING_E_AC3:
         return 6144 * 1000 / 8;
+      case C.ENCODING_AC4:
+        return 2688 * 1000 / 8;
       case C.ENCODING_DTS:
         // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
         return 1536 * 1000 / 8;
@@ -1224,6 +1156,8 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
       return Ac3Util.getAc3SyncframeAudioSampleCount();
     } else if (encoding == C.ENCODING_E_AC3) {
       return Ac3Util.parseEAc3SyncframeAudioSampleCount(buffer);
+    } else if (encoding == C.ENCODING_AC4) {
+      return Ac4Util.parseAc4SyncframeAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_DOLBY_TRUEHD) {
       int syncframeOffset = Ac3Util.findTrueHdSyncframeOffset(buffer);
       return syncframeOffset == C.INDEX_UNSET
@@ -1289,9 +1223,7 @@ private static void setVolumeInternalV3(AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
-  /**
-   * Stores playback parameters with the position and media time at which they apply.
-   */
+  /** Stores playback parameters with the position and media time at which they apply. */
   private static final class PlaybackParametersCheckpoint {
 
     private final PlaybackParameters playbackParameters;
@@ -1372,4 +1304,159 @@ public void onUnderrun(int bufferSize, long bufferSizeMs) {
       }
     }
   }
+
+  /** Stores configuration relating to the audio format. */
+  private static final class Configuration {
+
+    public final boolean isInputPcm;
+    public final int inputPcmFrameSize;
+    public final int inputSampleRate;
+    public final int outputPcmFrameSize;
+    public final int outputSampleRate;
+    public final int outputChannelConfig;
+    @C.Encoding public final int outputEncoding;
+    public final int bufferSize;
+    public final boolean processingEnabled;
+    public final boolean canApplyPlaybackParameters;
+    public final AudioProcessor[] availableAudioProcessors;
+
+    public Configuration(
+        boolean isInputPcm,
+        int inputPcmFrameSize,
+        int inputSampleRate,
+        int outputPcmFrameSize,
+        int outputSampleRate,
+        int outputChannelConfig,
+        int outputEncoding,
+        int specifiedBufferSize,
+        boolean processingEnabled,
+        boolean canApplyPlaybackParameters,
+        AudioProcessor[] availableAudioProcessors) {
+      this.isInputPcm = isInputPcm;
+      this.inputPcmFrameSize = inputPcmFrameSize;
+      this.inputSampleRate = inputSampleRate;
+      this.outputPcmFrameSize = outputPcmFrameSize;
+      this.outputSampleRate = outputSampleRate;
+      this.outputChannelConfig = outputChannelConfig;
+      this.outputEncoding = outputEncoding;
+      this.bufferSize = specifiedBufferSize != 0 ? specifiedBufferSize : getDefaultBufferSize();
+      this.processingEnabled = processingEnabled;
+      this.canApplyPlaybackParameters = canApplyPlaybackParameters;
+      this.availableAudioProcessors = availableAudioProcessors;
+    }
+
+    public boolean canReuseAudioTrack(Configuration audioTrackConfiguration) {
+      return audioTrackConfiguration.outputEncoding == outputEncoding
+          && audioTrackConfiguration.outputSampleRate == outputSampleRate
+          && audioTrackConfiguration.outputChannelConfig == outputChannelConfig;
+    }
+
+    public long inputFramesToDurationUs(long frameCount) {
+      return (frameCount * C.MICROS_PER_SECOND) / inputSampleRate;
+    }
+
+    public long framesToDurationUs(long frameCount) {
+      return (frameCount * C.MICROS_PER_SECOND) / outputSampleRate;
+    }
+
+    public long durationUsToFrames(long durationUs) {
+      return (durationUs * outputSampleRate) / C.MICROS_PER_SECOND;
+    }
+
+    public AudioTrack buildAudioTrack(
+        boolean tunneling, AudioAttributes audioAttributes, int audioSessionId)
+        throws InitializationException {
+      AudioTrack audioTrack;
+      if (Util.SDK_INT >= 21) {
+        audioTrack = createAudioTrackV21(tunneling, audioAttributes, audioSessionId);
+      } else {
+        int streamType = Util.getStreamTypeForAudioUsage(audioAttributes.usage);
+        if (audioSessionId == C.AUDIO_SESSION_ID_UNSET) {
+          audioTrack =
+              new AudioTrack(
+                  streamType,
+                  outputSampleRate,
+                  outputChannelConfig,
+                  outputEncoding,
+                  bufferSize,
+                  MODE_STREAM);
+        } else {
+          // Re-attach to the same audio session.
+          audioTrack =
+              new AudioTrack(
+                  streamType,
+                  outputSampleRate,
+                  outputChannelConfig,
+                  outputEncoding,
+                  bufferSize,
+                  MODE_STREAM,
+                  audioSessionId);
+        }
+      }
+
+      int state = audioTrack.getState();
+      if (state != STATE_INITIALIZED) {
+        try {
+          audioTrack.release();
+        } catch (Exception e) {
+          // The track has already failed to initialize, so it wouldn't be that surprising if
+          // release were to fail too. Swallow the exception.
+        }
+        throw new InitializationException(state, outputSampleRate, outputChannelConfig, bufferSize);
+      }
+      return audioTrack;
+    }
+
+    @TargetApi(21)
+    private AudioTrack createAudioTrackV21(
+        boolean tunneling, AudioAttributes audioAttributes, int audioSessionId) {
+      android.media.AudioAttributes attributes;
+      if (tunneling) {
+        attributes =
+            new android.media.AudioAttributes.Builder()
+                .setContentType(android.media.AudioAttributes.CONTENT_TYPE_MOVIE)
+                .setFlags(android.media.AudioAttributes.FLAG_HW_AV_SYNC)
+                .setUsage(android.media.AudioAttributes.USAGE_MEDIA)
+                .build();
+      } else {
+        attributes = audioAttributes.getAudioAttributesV21();
+      }
+      AudioFormat format =
+          new AudioFormat.Builder()
+              .setChannelMask(outputChannelConfig)
+              .setEncoding(outputEncoding)
+              .setSampleRate(outputSampleRate)
+              .build();
+      return new AudioTrack(
+          attributes,
+          format,
+          bufferSize,
+          MODE_STREAM,
+          audioSessionId != C.AUDIO_SESSION_ID_UNSET
+              ? audioSessionId
+              : AudioManager.AUDIO_SESSION_ID_GENERATE);
+    }
+
+    private int getDefaultBufferSize() {
+      if (isInputPcm) {
+        int minBufferSize =
+            AudioTrack.getMinBufferSize(outputSampleRate, outputChannelConfig, outputEncoding);
+        Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
+        int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
+        int minAppBufferSize =
+            (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
+        int maxAppBufferSize =
+            (int)
+                Math.max(
+                    minBufferSize, durationUsToFrames(MAX_BUFFER_DURATION_US) * outputPcmFrameSize);
+        return Util.constrainValue(multipliedBufferSize, minAppBufferSize, maxAppBufferSize);
+      } else {
+        int rate = getMaximumEncodedRateBytesPerSecond(outputEncoding);
+        if (outputEncoding == C.ENCODING_AC3) {
+          rate *= AC3_BUFFER_MULTIPLICATION_FACTOR;
+        }
+        return (int) (PASSTHROUGH_BUFFER_DURATION_US * rate / C.MICROS_PER_SECOND);
+      }
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
index e3c91cd344..2274d53b55 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
@@ -16,61 +16,30 @@
 package com.google.android.exoplayer2.audio;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 
 /**
  * An {@link AudioProcessor} that converts 24-bit and 32-bit integer PCM audio to 32-bit float PCM
  * audio.
  */
-/* package */ final class FloatResamplingAudioProcessor implements AudioProcessor {
+/* package */ final class FloatResamplingAudioProcessor extends BaseAudioProcessor {
 
   private static final int FLOAT_NAN_AS_INT = Float.floatToIntBits(Float.NaN);
   private static final double PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR = 1.0 / 0x7FFFFFFF;
 
-  private int sampleRateHz;
-  private int channelCount;
-  private @C.PcmEncoding int sourceEncoding;
-  private ByteBuffer buffer;
-  private ByteBuffer outputBuffer;
-  private boolean inputEnded;
-
-  /** Creates a new audio processor that converts audio data to {@link C#ENCODING_PCM_FLOAT}. */
-  public FloatResamplingAudioProcessor() {
-    sampleRateHz = Format.NO_VALUE;
-    channelCount = Format.NO_VALUE;
-    sourceEncoding = C.ENCODING_INVALID;
-    buffer = EMPTY_BUFFER;
-    outputBuffer = EMPTY_BUFFER;
-  }
-
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
       throws UnhandledFormatException {
     if (!Util.isEncodingHighResolutionIntegerPcm(encoding)) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
-    if (this.sampleRateHz == sampleRateHz
-        && this.channelCount == channelCount
-        && sourceEncoding == encoding) {
-      return false;
-    }
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
-    sourceEncoding = encoding;
-    return true;
+    return setInputFormat(sampleRateHz, channelCount, encoding);
   }
 
   @Override
   public boolean isActive() {
-    return Util.isEncodingHighResolutionIntegerPcm(sourceEncoding);
-  }
-
-  @Override
-  public int getOutputChannelCount() {
-    return channelCount;
+    return Util.isEncodingHighResolutionIntegerPcm(encoding);
   }
 
   @Override
@@ -78,24 +47,15 @@ public int getOutputEncoding() {
     return C.ENCODING_PCM_FLOAT;
   }
 
-  @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
-  }
-
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
-    boolean isInput32Bit = sourceEncoding == C.ENCODING_PCM_32BIT;
+    boolean isInput32Bit = encoding == C.ENCODING_PCM_32BIT;
     int position = inputBuffer.position();
     int limit = inputBuffer.limit();
     int size = limit - position;
 
     int resampledSize = isInput32Bit ? size : (size / 3) * 4;
-    if (buffer.capacity() < resampledSize) {
-      buffer = ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
-    } else {
-      buffer.clear();
-    }
+    ByteBuffer buffer = replaceOutputBuffer(resampledSize);
     if (isInput32Bit) {
       for (int i = position; i < limit; i += 4) {
         int pcm32BitInteger =
@@ -117,40 +77,6 @@ public void queueInput(ByteBuffer inputBuffer) {
 
     inputBuffer.position(inputBuffer.limit());
     buffer.flip();
-    outputBuffer = buffer;
-  }
-
-  @Override
-  public void queueEndOfStream() {
-    inputEnded = true;
-  }
-
-  @Override
-  public ByteBuffer getOutput() {
-    ByteBuffer outputBuffer = this.outputBuffer;
-    this.outputBuffer = EMPTY_BUFFER;
-    return outputBuffer;
-  }
-
-  @SuppressWarnings("ReferenceEquality")
-  @Override
-  public boolean isEnded() {
-    return inputEnded && outputBuffer == EMPTY_BUFFER;
-  }
-
-  @Override
-  public void flush() {
-    outputBuffer = EMPTY_BUFFER;
-    inputEnded = false;
-  }
-
-  @Override
-  public void reset() {
-    flush();
-    sampleRateHz = Format.NO_VALUE;
-    channelCount = Format.NO_VALUE;
-    sourceEncoding = C.ENCODING_INVALID;
-    buffer = EMPTY_BUFFER;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index daa0447905..07769e7d85 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -16,16 +16,14 @@
 package com.google.android.exoplayer2.audio;
 
 import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.content.pm.PackageManager;
 import android.media.MediaCodec;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
-import android.support.annotation.CallSuper;
-import android.support.annotation.Nullable;
+import androidx.annotation.CallSuper;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
@@ -67,7 +65,6 @@
  *       underlying audio track.
  * </ul>
  */
-@TargetApi(16)
 public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock {
 
   /**
@@ -253,6 +250,7 @@ public MediaCodecAudioRenderer(
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        /* enableDecoderFallback= */ false,
         /* assumedMinimumCodecOperatingRate= */ 44100);
     this.context = context.getApplicationContext();
     this.audioSink = audioSink;
@@ -291,11 +289,15 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
       }
     }
     List<MediaCodecInfo> decoderInfos =
-        mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecryption);
+        mediaCodecSelector.getDecoderInfos(
+            format.sampleMimeType, requiresSecureDecryption, /* requiresTunnelingDecoder= */ false);
     if (decoderInfos.isEmpty()) {
       return requiresSecureDecryption
               && !mediaCodecSelector
-                  .getDecoderInfos(format.sampleMimeType, /* requiresSecureDecoder= */ false)
+                  .getDecoderInfos(
+                      format.sampleMimeType,
+                      /* requiresSecureDecoder= */ false,
+                      /* requiresTunnelingDecoder= */ false)
                   .isEmpty()
           ? FORMAT_UNSUPPORTED_DRM
           : FORMAT_UNSUPPORTED_SUBTYPE;
@@ -324,7 +326,8 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         return Collections.singletonList(passthroughDecoderInfo);
       }
     }
-    return super.getDecoderInfos(mediaCodecSelector, format, requiresSecureDecoder);
+    return mediaCodecSelector.getDecoderInfos(
+        format.sampleMimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
   }
 
   /**
@@ -352,7 +355,7 @@ protected void configureCodec(
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
     codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);
     passthroughEnabled = codecInfo.passthrough;
-    String codecMimeType = codecInfo.mimeType == null ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
+    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
     MediaFormat mediaFormat =
         getMediaFormat(format, codecMimeType, codecMaxInputSize, codecOperatingRate);
     codec.configure(mediaFormat, /* surface= */ null, crypto, /* flags= */ 0);
@@ -368,14 +371,22 @@ protected void configureCodec(
   @Override
   protected @KeepCodecResult int canKeepCodec(
       MediaCodec codec, MediaCodecInfo codecInfo, Format oldFormat, Format newFormat) {
-    if (getCodecMaxInputSize(codecInfo, newFormat) <= codecMaxInputSize
-        && codecInfo.isSeamlessAdaptationSupported(
-            oldFormat, newFormat, /* isNewFormatComplete= */ true)
-        && oldFormat.encoderDelay == 0
-        && oldFormat.encoderPadding == 0
-        && newFormat.encoderDelay == 0
-        && newFormat.encoderPadding == 0) {
+    // TODO: We currently rely on recreating the codec when encoder delay or padding is non-zero.
+    // Re-creating the codec is necessary to guarantee that onOutputFormatChanged is called, which
+    // is where encoder delay and padding are propagated to the sink. We should find a better way to
+    // propagate these values, and then allow the codec to be re-used in cases where this would
+    // otherwise be possible.
+    if (getCodecMaxInputSize(codecInfo, newFormat) > codecMaxInputSize
+        || oldFormat.encoderDelay != 0
+        || oldFormat.encoderPadding != 0
+        || newFormat.encoderDelay != 0
+        || newFormat.encoderPadding != 0) {
+      return KEEP_CODEC_RESULT_NO;
+    } else if (codecInfo.isSeamlessAdaptationSupported(
+        oldFormat, newFormat, /* isNewFormatComplete= */ true)) {
       return KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION;
+    } else if (areCodecConfigurationCompatible(oldFormat, newFormat)) {
+      return KEEP_CODEC_RESULT_YES_WITH_FLUSH;
     } else {
       return KEEP_CODEC_RESULT_NO;
     }
@@ -387,7 +398,7 @@ public MediaClock getMediaClock() {
   }
 
   @Override
-  protected float getCodecOperatingRate(
+  protected float getCodecOperatingRateV23(
       float operatingRate, Format format, Format[] streamFormats) {
     // Use the highest known stream sample-rate up front, to avoid having to reconfigure the codec
     // should an adaptive switch to that stream occur.
@@ -510,7 +521,7 @@ protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlayba
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     super.onPositionReset(positionUs, joining);
-    audioSink.reset();
+    audioSink.flush();
     currentPositionUs = positionUs;
     allowFirstBufferPositionDiscontinuity = true;
     allowPositionDiscontinuity = true;
@@ -536,17 +547,25 @@ protected void onDisabled() {
     try {
       lastInputTimeUs = C.TIME_UNSET;
       pendingStreamChangeCount = 0;
-      audioSink.release();
+      audioSink.flush();
     } finally {
       try {
         super.onDisabled();
       } finally {
-        decoderCounters.ensureUpdated();
         eventDispatcher.disabled(decoderCounters);
       }
     }
   }
 
+  @Override
+  protected void onReset() {
+    try {
+      super.onReset();
+    } finally {
+      audioSink.reset();
+    }
+  }
+
   @Override
   public boolean isEnded() {
     return super.isEnded() && audioSink.isEnded();
@@ -712,27 +731,36 @@ protected int getCodecMaxInputSize(
    *     be determined.
    */
   private int getCodecMaxInputSize(MediaCodecInfo codecInfo, Format format) {
-    if (Util.SDK_INT < 24 && "OMX.google.raw.decoder".equals(codecInfo.name)) {
-      // OMX.google.raw.decoder didn't resize its output buffers correctly prior to N, so there's no
-      // point requesting a non-default input size. Doing so may cause a native crash, where-as not
-      // doing so will cause a more controlled failure when attempting to fill an input buffer. See:
-      // https://github.com/google/ExoPlayer/issues/4057.
-      boolean needsRawDecoderWorkaround = true;
-      if (Util.SDK_INT == 23) {
-        PackageManager packageManager = context.getPackageManager();
-        if (packageManager != null
-            && packageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
-          // The workaround is not required for AndroidTV devices running M.
-          needsRawDecoderWorkaround = false;
-        }
-      }
-      if (needsRawDecoderWorkaround) {
+    if ("OMX.google.raw.decoder".equals(codecInfo.name)) {
+      // OMX.google.raw.decoder didn't resize its output buffers correctly prior to N, except on
+      // Android TV running M, so there's no point requesting a non-default input size. Doing so may
+      // cause a native crash, whereas not doing so will cause a more controlled failure when
+      // attempting to fill an input buffer. See: https://github.com/google/ExoPlayer/issues/4057.
+      if (Util.SDK_INT < 24 && !(Util.SDK_INT == 23 && Util.isTv(context))) {
         return Format.NO_VALUE;
       }
     }
     return format.maxInputSize;
   }
 
+  /**
+   * Returns whether two {@link Format}s will cause the same codec to be configured in an identical
+   * way, excluding {@link MediaFormat#KEY_MAX_INPUT_SIZE} and configuration that does not come from
+   * the {@link Format}.
+   *
+   * @param oldFormat The first format.
+   * @param newFormat The second format.
+   * @return Whether the two formats will cause a codec to be configured in an identical way,
+   *     excluding {@link MediaFormat#KEY_MAX_INPUT_SIZE} and configuration that does not come from
+   *     the {@link Format}.
+   */
+  protected boolean areCodecConfigurationCompatible(Format oldFormat, Format newFormat) {
+    return Util.areEqual(oldFormat.sampleMimeType, newFormat.sampleMimeType)
+        && oldFormat.channelCount == newFormat.channelCount
+        && oldFormat.sampleRate == newFormat.sampleRate
+        && oldFormat.initializationDataEquals(newFormat);
+  }
+
   /**
    * Returns the framework {@link MediaFormat} that can be used to configure a {@link MediaCodec}
    * for decoding the given {@link Format} for playback.
@@ -762,6 +790,11 @@ protected MediaFormat getMediaFormat(
         mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
       }
     }
+    if (Util.SDK_INT <= 28 && MimeTypes.AUDIO_AC4.equals(format.sampleMimeType)) {
+      // On some older builds, the AC-4 decoder expects to receive samples formatted as raw frames
+      // not sync frames. Set a format key to override this.
+      mediaFormat.setInteger("ac4-is-sync", 1);
+    }
     return mediaFormat;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
index 3ae1a393f9..d0c057b676 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
@@ -18,45 +18,21 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 
 /**
  * An {@link AudioProcessor} that converts 8-bit, 24-bit and 32-bit integer PCM audio to 16-bit
  * integer PCM audio.
  */
-/* package */ final class ResamplingAudioProcessor implements AudioProcessor {
-
-  private int sampleRateHz;
-  private int channelCount;
-  private @C.PcmEncoding int encoding;
-  private ByteBuffer buffer;
-  private ByteBuffer outputBuffer;
-  private boolean inputEnded;
-
-  /** Creates a new audio processor that converts audio data to {@link C#ENCODING_PCM_16BIT}. */
-  public ResamplingAudioProcessor() {
-    sampleRateHz = Format.NO_VALUE;
-    channelCount = Format.NO_VALUE;
-    encoding = C.ENCODING_INVALID;
-    buffer = EMPTY_BUFFER;
-    outputBuffer = EMPTY_BUFFER;
-  }
+/* package */ final class ResamplingAudioProcessor extends BaseAudioProcessor {
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
       throws UnhandledFormatException {
     if (encoding != C.ENCODING_PCM_8BIT && encoding != C.ENCODING_PCM_16BIT
         && encoding != C.ENCODING_PCM_24BIT && encoding != C.ENCODING_PCM_32BIT) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
-    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount
-        && this.encoding == encoding) {
-      return false;
-    }
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
-    this.encoding = encoding;
-    return true;
+    return setInputFormat(sampleRateHz, channelCount, encoding);
   }
 
   @Override
@@ -64,21 +40,11 @@ public boolean isActive() {
     return encoding != C.ENCODING_INVALID && encoding != C.ENCODING_PCM_16BIT;
   }
 
-  @Override
-  public int getOutputChannelCount() {
-    return channelCount;
-  }
-
   @Override
   public int getOutputEncoding() {
     return C.ENCODING_PCM_16BIT;
   }
 
-  @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
-  }
-
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
     // Prepare the output buffer.
@@ -105,13 +71,9 @@ public void queueInput(ByteBuffer inputBuffer) {
       default:
         throw new IllegalStateException();
     }
-    if (buffer.capacity() < resampledSize) {
-      buffer = ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
-    } else {
-      buffer.clear();
-    }
 
     // Resample the little endian input and update the input/output buffers.
+    ByteBuffer buffer = replaceOutputBuffer(resampledSize);
     switch (encoding) {
       case C.ENCODING_PCM_8BIT:
         // 8->16 bit resampling. Shift each byte from [0, 256) to [-128, 128) and scale up.
@@ -146,40 +108,6 @@ public void queueInput(ByteBuffer inputBuffer) {
     }
     inputBuffer.position(inputBuffer.limit());
     buffer.flip();
-    outputBuffer = buffer;
-  }
-
-  @Override
-  public void queueEndOfStream() {
-    inputEnded = true;
-  }
-
-  @Override
-  public ByteBuffer getOutput() {
-    ByteBuffer outputBuffer = this.outputBuffer;
-    this.outputBuffer = EMPTY_BUFFER;
-    return outputBuffer;
-  }
-
-  @SuppressWarnings("ReferenceEquality")
-  @Override
-  public boolean isEnded() {
-    return inputEnded && outputBuffer == EMPTY_BUFFER;
-  }
-
-  @Override
-  public void flush() {
-    outputBuffer = EMPTY_BUFFER;
-    inputEnded = false;
-  }
-
-  @Override
-  public void reset() {
-    flush();
-    sampleRateHz = Format.NO_VALUE;
-    channelCount = Format.NO_VALUE;
-    encoding = C.ENCODING_INVALID;
-    buffer = EMPTY_BUFFER;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
index a1ff7028c1..caf8a61651 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
@@ -15,21 +15,19 @@
  */
 package com.google.android.exoplayer2.audio;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 
 /**
  * An {@link AudioProcessor} that skips silence in the input stream. Input and output are 16-bit
  * PCM.
  */
-public final class SilenceSkippingAudioProcessor implements AudioProcessor {
+public final class SilenceSkippingAudioProcessor extends BaseAudioProcessor {
 
   /**
    * The minimum duration of audio that must be below {@link #SILENCE_THRESHOLD_LEVEL} to classify
@@ -70,16 +68,10 @@
   /** State when the input is silent. */
   private static final int STATE_SILENT = 2;
 
-  private int channelCount;
-  private int sampleRateHz;
   private int bytesPerFrame;
 
   private boolean enabled;
 
-  private ByteBuffer buffer;
-  private ByteBuffer outputBuffer;
-  private boolean inputEnded;
-
   /**
    * Buffers audio data that may be classified as silence while in {@link #STATE_MAYBE_SILENT}. If
    * the input becomes noisy before the buffer has filled, it will be output. Otherwise, the buffer
@@ -93,7 +85,7 @@
    */
   private byte[] paddingBuffer;
 
-  private @State int state;
+  @State private int state;
   private int maybeSilenceBufferSize;
   private int paddingSize;
   private boolean hasOutputNoise;
@@ -101,10 +93,6 @@
 
   /** Creates a new silence trimming audio processor. */
   public SilenceSkippingAudioProcessor() {
-    buffer = EMPTY_BUFFER;
-    outputBuffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
     maybeSilenceBuffer = Util.EMPTY_BYTE_ARRAY;
     paddingBuffer = Util.EMPTY_BYTE_ARRAY;
   }
@@ -131,43 +119,23 @@ public long getSkippedFrames() {
   // AudioProcessor implementation.
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, int encoding)
+  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
       throws UnhandledFormatException {
     if (encoding != C.ENCODING_PCM_16BIT) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
-    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount) {
-      return false;
-    }
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
     bytesPerFrame = channelCount * 2;
-    return true;
+    return setInputFormat(sampleRateHz, channelCount, encoding);
   }
 
   @Override
   public boolean isActive() {
-    return sampleRateHz != Format.NO_VALUE && enabled;
-  }
-
-  @Override
-  public int getOutputChannelCount() {
-    return channelCount;
-  }
-
-  @Override
-  public @C.Encoding int getOutputEncoding() {
-    return C.ENCODING_PCM_16BIT;
-  }
-
-  @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
+    return super.isActive() && enabled;
   }
 
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
-    while (inputBuffer.hasRemaining() && !outputBuffer.hasRemaining()) {
+    while (inputBuffer.hasRemaining() && !hasPendingOutput()) {
       switch (state) {
         case STATE_NOISY:
           processNoisy(inputBuffer);
@@ -185,8 +153,7 @@ public void queueInput(ByteBuffer inputBuffer) {
   }
 
   @Override
-  public void queueEndOfStream() {
-    inputEnded = true;
+  protected void onQueueEndOfStream() {
     if (maybeSilenceBufferSize > 0) {
       // We haven't received enough silence to transition to the silent state, so output the buffer.
       output(maybeSilenceBuffer, maybeSilenceBufferSize);
@@ -197,20 +164,7 @@ public void queueEndOfStream() {
   }
 
   @Override
-  public ByteBuffer getOutput() {
-    ByteBuffer outputBuffer = this.outputBuffer;
-    this.outputBuffer = EMPTY_BUFFER;
-    return outputBuffer;
-  }
-
-  @SuppressWarnings("ReferenceEquality")
-  @Override
-  public boolean isEnded() {
-    return inputEnded && outputBuffer == EMPTY_BUFFER;
-  }
-
-  @Override
-  public void flush() {
+  protected void onFlush() {
     if (isActive()) {
       int maybeSilenceBufferSize = durationUsToFrames(MINIMUM_SILENCE_DURATION_US) * bytesPerFrame;
       if (maybeSilenceBuffer.length != maybeSilenceBufferSize) {
@@ -222,20 +176,14 @@ public void flush() {
       }
     }
     state = STATE_NOISY;
-    outputBuffer = EMPTY_BUFFER;
-    inputEnded = false;
     skippedFrames = 0;
     maybeSilenceBufferSize = 0;
     hasOutputNoise = false;
   }
 
   @Override
-  public void reset() {
+  protected void onReset() {
     enabled = false;
-    flush();
-    buffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
     paddingSize = 0;
     maybeSilenceBuffer = Util.EMPTY_BYTE_ARRAY;
     paddingBuffer = Util.EMPTY_BYTE_ARRAY;
@@ -330,30 +278,19 @@ private void processSilence(ByteBuffer inputBuffer) {
    * processor.
    */
   private void output(byte[] data, int length) {
-    prepareForOutput(length);
-    buffer.put(data, 0, length);
-    buffer.flip();
-    outputBuffer = buffer;
+    replaceOutputBuffer(length).put(data, 0, length).flip();
+    if (length > 0) {
+      hasOutputNoise = true;
+    }
   }
 
   /**
    * Copies remaining bytes from {@code data} to populate a new output buffer from the processor.
    */
   private void output(ByteBuffer data) {
-    prepareForOutput(data.remaining());
-    buffer.put(data);
-    buffer.flip();
-    outputBuffer = buffer;
-  }
-
-  /** Prepares to output {@code size} bytes in {@code buffer}. */
-  private void prepareForOutput(int size) {
-    if (buffer.capacity() < size) {
-      buffer = ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());
-    } else {
-      buffer.clear();
-    }
-    if (size > 0) {
+    int length = data.remaining();
+    replaceOutputBuffer(length).put(data).flip();
+    if (length > 0) {
       hasOutputNoise = true;
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 9b6be57e4c..553dfb1187 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -19,8 +19,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -106,8 +106,8 @@
         ? extends AudioDecoderException> decoder;
   private DecoderInputBuffer inputBuffer;
   private SimpleOutputBuffer outputBuffer;
-  private DrmSession<ExoMediaCrypto> drmSession;
-  private DrmSession<ExoMediaCrypto> pendingDrmSession;
+  @Nullable private DrmSession<ExoMediaCrypto> decoderDrmSession;
+  @Nullable private DrmSession<ExoMediaCrypto> sourceDrmSession;
 
   @ReinitializationState private int decoderReinitializationState;
   private boolean decoderReceivedBuffers;
@@ -366,7 +366,10 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
       if (outputBuffer == null) {
         return false;
       }
-      decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+      if (outputBuffer.skippedOutputBufferCount > 0) {
+        decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+        audioSink.handleDiscontinuity();
+      }
     }
 
     if (outputBuffer.isEndOfStream()) {
@@ -459,12 +462,12 @@ private boolean feedInputBuffer() throws AudioDecoderException, ExoPlaybackExcep
   }
 
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (drmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+    if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
       return false;
     }
-    @DrmSession.State int drmSessionState = drmSession.getState();
+    @DrmSession.State int drmSessionState = decoderDrmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+      throw ExoPlaybackException.createForRenderer(decoderDrmSession.getError(), getIndex());
     }
     return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
   }
@@ -537,7 +540,7 @@ protected void onEnabled(boolean joining) throws ExoPlaybackException {
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
-    audioSink.reset();
+    audioSink.flush();
     currentPositionUs = positionUs;
     allowFirstBufferPositionDiscontinuity = true;
     allowPositionDiscontinuity = true;
@@ -565,25 +568,11 @@ protected void onDisabled() {
     audioTrackNeedsConfigure = true;
     waitingForKeys = false;
     try {
+      setSourceDrmSession(null);
       releaseDecoder();
-      audioSink.release();
+      audioSink.reset();
     } finally {
-      try {
-        if (drmSession != null) {
-          drmSessionManager.releaseSession(drmSession);
-        }
-      } finally {
-        try {
-          if (pendingDrmSession != null && pendingDrmSession != drmSession) {
-            drmSessionManager.releaseSession(pendingDrmSession);
-          }
-        } finally {
-          drmSession = null;
-          pendingDrmSession = null;
-          decoderCounters.ensureUpdated();
-          eventDispatcher.disabled(decoderCounters);
-        }
-      }
+      eventDispatcher.disabled(decoderCounters);
     }
   }
 
@@ -612,12 +601,13 @@ private void maybeInitDecoder() throws ExoPlaybackException {
       return;
     }
 
-    drmSession = pendingDrmSession;
+    setDecoderDrmSession(sourceDrmSession);
+
     ExoMediaCrypto mediaCrypto = null;
-    if (drmSession != null) {
-      mediaCrypto = drmSession.getMediaCrypto();
+    if (decoderDrmSession != null) {
+      mediaCrypto = decoderDrmSession.getMediaCrypto();
       if (mediaCrypto == null) {
-        DrmSessionException drmError = drmSession.getError();
+        DrmSessionException drmError = decoderDrmSession.getError();
         if (drmError != null) {
           // Continue for now. We may be able to avoid failure if the session recovers, or if a new
           // input format causes the session to be replaced before it's used.
@@ -643,17 +633,34 @@ private void maybeInitDecoder() throws ExoPlaybackException {
   }
 
   private void releaseDecoder() {
-    if (decoder == null) {
-      return;
-    }
-
     inputBuffer = null;
     outputBuffer = null;
-    decoder.release();
-    decoder = null;
-    decoderCounters.decoderReleaseCount++;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     decoderReceivedBuffers = false;
+    if (decoder != null) {
+      decoder.release();
+      decoder = null;
+      decoderCounters.decoderReleaseCount++;
+    }
+    setDecoderDrmSession(null);
+  }
+
+  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession<ExoMediaCrypto> previous = sourceDrmSession;
+    sourceDrmSession = session;
+    releaseDrmSessionIfUnused(previous);
+  }
+
+  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession<ExoMediaCrypto> previous = decoderDrmSession;
+    decoderDrmSession = session;
+    releaseDrmSessionIfUnused(previous);
+  }
+
+  private void releaseDrmSessionIfUnused(@Nullable DrmSession<ExoMediaCrypto> session) {
+    if (session != null && session != decoderDrmSession && session != sourceDrmSession) {
+      drmSessionManager.releaseSession(session);
+    }
   }
 
   private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
@@ -668,13 +675,16 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
           throw ExoPlaybackException.createForRenderer(
               new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
         }
-        pendingDrmSession = drmSessionManager.acquireSession(Looper.myLooper(),
-            inputFormat.drmInitData);
-        if (pendingDrmSession == drmSession) {
-          drmSessionManager.releaseSession(pendingDrmSession);
+        DrmSession<ExoMediaCrypto> session =
+            drmSessionManager.acquireSession(Looper.myLooper(), newFormat.drmInitData);
+        if (session == decoderDrmSession || session == sourceDrmSession) {
+          // We already had this session. The manager must be reference counting, so release it once
+          // to get the count attributed to this renderer back down to 1.
+          drmSessionManager.releaseSession(session);
         }
+        setSourceDrmSession(session);
       } else {
-        pendingDrmSession = null;
+        setSourceDrmSession(null);
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
index 2ca2d47828..0d938d33f4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.audio;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.Encoding;
 import com.google.android.exoplayer2.Format;
@@ -69,7 +69,8 @@
   private int outputSampleRateHz;
   private int pendingOutputSampleRateHz;
 
-  private @Nullable Sonic sonic;
+  private boolean pendingSonicRecreation;
+  @Nullable private Sonic sonic;
   private ByteBuffer buffer;
   private ShortBuffer shortBuffer;
   private ByteBuffer outputBuffer;
@@ -103,7 +104,7 @@ public float setSpeed(float speed) {
     speed = Util.constrainValue(speed, MINIMUM_SPEED, MAXIMUM_SPEED);
     if (this.speed != speed) {
       this.speed = speed;
-      sonic = null;
+      pendingSonicRecreation = true;
     }
     flush();
     return speed;
@@ -120,7 +121,7 @@ public float setPitch(float pitch) {
     pitch = Util.constrainValue(pitch, MINIMUM_PITCH, MAXIMUM_PITCH);
     if (this.pitch != pitch) {
       this.pitch = pitch;
-      sonic = null;
+      pendingSonicRecreation = true;
     }
     flush();
     return pitch;
@@ -172,7 +173,7 @@ public boolean configure(int sampleRateHz, int channelCount, @Encoding int encod
     this.sampleRateHz = sampleRateHz;
     this.channelCount = channelCount;
     this.outputSampleRateHz = outputSampleRateHz;
-    sonic = null;
+    pendingSonicRecreation = true;
     return true;
   }
 
@@ -201,7 +202,7 @@ public int getOutputSampleRateHz() {
 
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
-    Assertions.checkState(sonic != null);
+    Sonic sonic = Assertions.checkNotNull(this.sonic);
     if (inputBuffer.hasRemaining()) {
       ShortBuffer shortBuffer = inputBuffer.asShortBuffer();
       int inputSize = inputBuffer.remaining();
@@ -227,8 +228,9 @@ public void queueInput(ByteBuffer inputBuffer) {
 
   @Override
   public void queueEndOfStream() {
-    Assertions.checkState(sonic != null);
-    sonic.queueEndOfStream();
+    if (sonic != null) {
+      sonic.queueEndOfStream();
+    }
     inputEnded = true;
   }
 
@@ -247,9 +249,9 @@ public boolean isEnded() {
   @Override
   public void flush() {
     if (isActive()) {
-      if (sonic == null) {
+      if (pendingSonicRecreation) {
         sonic = new Sonic(sampleRateHz, channelCount, speed, pitch, outputSampleRateHz);
-      } else {
+      } else if (sonic != null) {
         sonic.flush();
       }
     }
@@ -270,6 +272,7 @@ public void reset() {
     shortBuffer = buffer.asShortBuffer();
     outputBuffer = EMPTY_BUFFER;
     pendingOutputSampleRateHz = SAMPLE_RATE_NO_CHANGE;
+    pendingSonicRecreation = false;
     sonic = null;
     inputBytes = 0;
     outputBytes = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
index 0072b7c2a3..6e4c97701a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
@@ -15,9 +15,8 @@
  */
 package com.google.android.exoplayer2.audio;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
@@ -36,13 +35,13 @@
  * custom {@link com.google.android.exoplayer2.audio.DefaultAudioSink.AudioProcessorChain} when
  * creating the audio sink, and include this audio processor after all other audio processors.
  */
-public final class TeeAudioProcessor implements AudioProcessor {
+public final class TeeAudioProcessor extends BaseAudioProcessor {
 
   /** A sink for audio buffers handled by the audio processor. */
   public interface AudioBufferSink {
 
     /** Called when the audio processor is flushed with a format of subsequent input. */
-    void flush(int sampleRateHz, int channelCount, @C.Encoding int encoding);
+    void flush(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding);
 
     /**
      * Called when data is written to the audio processor.
@@ -54,15 +53,6 @@
 
   private final AudioBufferSink audioBufferSink;
 
-  private int sampleRateHz;
-  private int channelCount;
-  private @C.Encoding int encoding;
-  private boolean isActive;
-
-  private ByteBuffer buffer;
-  private ByteBuffer outputBuffer;
-  private boolean inputEnded;
-
   /**
    * Creates a new tee audio processor, sending incoming data to the given {@link AudioBufferSink}.
    *
@@ -71,98 +61,28 @@
    */
   public TeeAudioProcessor(AudioBufferSink audioBufferSink) {
     this.audioBufferSink = Assertions.checkNotNull(audioBufferSink);
-
-    buffer = EMPTY_BUFFER;
-    outputBuffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
-  }
-
-  @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
-      throws UnhandledFormatException {
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
-    this.encoding = encoding;
-    boolean wasActive = isActive;
-    isActive = true;
-    return !wasActive;
-  }
-
-  @Override
-  public boolean isActive() {
-    return isActive;
   }
 
   @Override
-  public int getOutputChannelCount() {
-    return channelCount;
+  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
+    return setInputFormat(sampleRateHz, channelCount, encoding);
   }
 
   @Override
-  public int getOutputEncoding() {
-    return encoding;
-  }
-
-  @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
-  }
-
-  @Override
-  public void queueInput(ByteBuffer buffer) {
-    int remaining = buffer.remaining();
+  public void queueInput(ByteBuffer inputBuffer) {
+    int remaining = inputBuffer.remaining();
     if (remaining == 0) {
       return;
     }
-
-    audioBufferSink.handleBuffer(buffer.asReadOnlyBuffer());
-
-    if (this.buffer.capacity() < remaining) {
-      this.buffer = ByteBuffer.allocateDirect(remaining).order(ByteOrder.nativeOrder());
-    } else {
-      this.buffer.clear();
-    }
-
-    this.buffer.put(buffer);
-
-    this.buffer.flip();
-    outputBuffer = this.buffer;
-  }
-
-  @Override
-  public void queueEndOfStream() {
-    inputEnded = true;
-  }
-
-  @Override
-  public ByteBuffer getOutput() {
-    ByteBuffer outputBuffer = this.outputBuffer;
-    this.outputBuffer = EMPTY_BUFFER;
-    return outputBuffer;
+    audioBufferSink.handleBuffer(inputBuffer.asReadOnlyBuffer());
+    replaceOutputBuffer(remaining).put(inputBuffer).flip();
   }
 
-  @SuppressWarnings("ReferenceEquality")
   @Override
-  public boolean isEnded() {
-    return inputEnded && buffer == EMPTY_BUFFER;
-  }
-
-  @Override
-  public void flush() {
-    outputBuffer = EMPTY_BUFFER;
-    inputEnded = false;
-
-    audioBufferSink.flush(sampleRateHz, channelCount, encoding);
-  }
-
-  @Override
-  public void reset() {
-    flush();
-    buffer = EMPTY_BUFFER;
-    sampleRateHz = Format.NO_VALUE;
-    channelCount = Format.NO_VALUE;
-    encoding = Format.NO_VALUE;
+  protected void onFlush() {
+    if (isActive()) {
+      audioBufferSink.flush(sampleRateHz, channelCount, encoding);
+    }
   }
 
   /**
@@ -187,8 +107,8 @@ public void reset() {
 
     private int sampleRateHz;
     private int channelCount;
-    private @C.Encoding int encoding;
-    private @Nullable RandomAccessFile randomAccessFile;
+    @C.PcmEncoding private int encoding;
+    @Nullable private RandomAccessFile randomAccessFile;
     private int counter;
     private int bytesWritten;
 
@@ -204,7 +124,7 @@ public WavFileAudioBufferSink(String outputFileNamePrefix) {
     }
 
     @Override
-    public void flush(int sampleRateHz, int channelCount, int encoding) {
+    public void flush(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
       try {
         reset();
       } catch (IOException e) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
index 7b66bd63d2..c9e9f921c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
@@ -16,39 +16,27 @@
 package com.google.android.exoplayer2.audio;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.C.Encoding;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 
 /** Audio processor for trimming samples from the start/end of data. */
-/* package */ final class TrimmingAudioProcessor implements AudioProcessor {
+/* package */ final class TrimmingAudioProcessor extends BaseAudioProcessor {
 
-  private static final int OUTPUT_ENCODING = C.ENCODING_PCM_16BIT;
+  @C.PcmEncoding private static final int OUTPUT_ENCODING = C.ENCODING_PCM_16BIT;
 
   private boolean isActive;
   private int trimStartFrames;
   private int trimEndFrames;
-  private int channelCount;
-  private int sampleRateHz;
   private int bytesPerFrame;
   private boolean receivedInputSinceConfigure;
 
   private int pendingTrimStartBytes;
-  private ByteBuffer buffer;
-  private ByteBuffer outputBuffer;
   private byte[] endBuffer;
   private int endBufferSize;
-  private boolean inputEnded;
   private long trimmedFrameCount;
 
   /** Creates a new audio processor for trimming samples from the start/end of data. */
   public TrimmingAudioProcessor() {
-    buffer = EMPTY_BUFFER;
-    outputBuffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
     endBuffer = Util.EMPTY_BYTE_ARRAY;
   }
 
@@ -80,7 +68,7 @@ public long getTrimmedFrameCount() {
   }
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @Encoding int encoding)
+  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
       throws UnhandledFormatException {
     if (encoding != OUTPUT_ENCODING) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
@@ -88,8 +76,6 @@ public boolean configure(int sampleRateHz, int channelCount, @Encoding int encod
     if (endBufferSize > 0) {
       trimmedFrameCount += endBufferSize / bytesPerFrame;
     }
-    this.channelCount = channelCount;
-    this.sampleRateHz = sampleRateHz;
     bytesPerFrame = Util.getPcmFrameSize(OUTPUT_ENCODING, channelCount);
     endBuffer = new byte[trimEndFrames * bytesPerFrame];
     endBufferSize = 0;
@@ -97,6 +83,7 @@ public boolean configure(int sampleRateHz, int channelCount, @Encoding int encod
     boolean wasActive = isActive;
     isActive = trimStartFrames != 0 || trimEndFrames != 0;
     receivedInputSinceConfigure = false;
+    setInputFormat(sampleRateHz, channelCount, encoding);
     return wasActive != isActive;
   }
 
@@ -105,21 +92,6 @@ public boolean isActive() {
     return isActive;
   }
 
-  @Override
-  public int getOutputChannelCount() {
-    return channelCount;
-  }
-
-  @Override
-  public int getOutputEncoding() {
-    return OUTPUT_ENCODING;
-  }
-
-  @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
-  }
-
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
     int position = inputBuffer.position();
@@ -147,11 +119,7 @@ public void queueInput(ByteBuffer inputBuffer) {
     // endBuffer as full as possible, the output should be any surplus bytes currently in endBuffer
     // followed by any surplus bytes in the new inputBuffer.
     int remainingBytesToOutput = endBufferSize + remaining - endBuffer.length;
-    if (buffer.capacity() < remainingBytesToOutput) {
-      buffer = ByteBuffer.allocateDirect(remainingBytesToOutput).order(ByteOrder.nativeOrder());
-    } else {
-      buffer.clear();
-    }
+    ByteBuffer buffer = replaceOutputBuffer(remainingBytesToOutput);
 
     // Output from endBuffer.
     int endBufferBytesToOutput = Util.constrainValue(remainingBytesToOutput, 0, endBufferSize);
@@ -172,48 +140,31 @@ public void queueInput(ByteBuffer inputBuffer) {
     endBufferSize += remaining;
 
     buffer.flip();
-    outputBuffer = buffer;
-  }
-
-  @Override
-  public void queueEndOfStream() {
-    inputEnded = true;
   }
 
   @SuppressWarnings("ReferenceEquality")
   @Override
   public ByteBuffer getOutput() {
-    ByteBuffer outputBuffer = this.outputBuffer;
-    if (inputEnded && endBufferSize > 0 && outputBuffer == EMPTY_BUFFER) {
+    if (super.isEnded() && endBufferSize > 0) {
       // Because audio processors may be drained in the middle of the stream we assume that the
-      // contents of the end buffer need to be output. Gapless transitions don't involve a call to
-      // queueEndOfStream so won't be affected. When audio is actually ending we play the padding
-      // data which is incorrect. This behavior can be fixed once we have the timestamps associated
-      // with input buffers.
-      if (buffer.capacity() < endBufferSize) {
-        buffer = ByteBuffer.allocateDirect(endBufferSize).order(ByteOrder.nativeOrder());
-      } else {
-        buffer.clear();
-      }
-      buffer.put(endBuffer, 0, endBufferSize);
+      // contents of the end buffer need to be output. For gapless transitions, configure will be
+      // always be called, which clears the end buffer as needed. When audio is actually ending we
+      // play the padding data which is incorrect. This behavior can be fixed once we have the
+      // timestamps associated with input buffers.
+      replaceOutputBuffer(endBufferSize).put(endBuffer, 0, endBufferSize).flip();
       endBufferSize = 0;
-      buffer.flip();
-      outputBuffer = buffer;
     }
-    this.outputBuffer = EMPTY_BUFFER;
-    return outputBuffer;
+    return super.getOutput();
   }
 
   @SuppressWarnings("ReferenceEquality")
   @Override
   public boolean isEnded() {
-    return inputEnded && endBufferSize == 0 && outputBuffer == EMPTY_BUFFER;
+    return super.isEnded() && endBufferSize == 0;
   }
 
   @Override
-  public void flush() {
-    outputBuffer = EMPTY_BUFFER;
-    inputEnded = false;
+  protected void onFlush() {
     if (receivedInputSinceConfigure) {
       // Audio processors are flushed after initial configuration, so we leave the pending trim
       // start byte count unmodified if the processor was just configured. Otherwise we (possibly
@@ -226,11 +177,7 @@ public void flush() {
   }
 
   @Override
-  public void reset() {
-    flush();
-    buffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
+  protected void onReset() {
     endBuffer = Util.EMPTY_BYTE_ARRAY;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/database/DatabaseIOException.java b/library/core/src/main/java/com/google/android/exoplayer2/database/DatabaseIOException.java
new file mode 100644
index 0000000000..b0fd1cf2f0
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/database/DatabaseIOException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.database;
+
+import android.database.SQLException;
+import java.io.IOException;
+
+/** An {@link IOException} whose cause is an {@link SQLException}. */
+public final class DatabaseIOException extends IOException {
+
+  public DatabaseIOException(SQLException cause) {
+    super(cause);
+  }
+
+  public DatabaseIOException(SQLException cause, String message) {
+    super(message, cause);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/database/DatabaseProvider.java b/library/core/src/main/java/com/google/android/exoplayer2/database/DatabaseProvider.java
new file mode 100644
index 0000000000..2bb5f260ba
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/database/DatabaseProvider.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.database;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+
+/**
+ * Provides {@link SQLiteDatabase} instances to ExoPlayer components, which may read and write
+ * tables prefixed with {@link #TABLE_PREFIX}.
+ */
+public interface DatabaseProvider {
+
+  /** Prefix for tables that can be read and written by ExoPlayer components. */
+  String TABLE_PREFIX = "ExoPlayer";
+
+  /**
+   * Creates and/or opens a database that will be used for reading and writing.
+   *
+   * <p>Once opened successfully, the database is cached, so you can call this method every time you
+   * need to write to the database. Errors such as bad permissions or a full disk may cause this
+   * method to fail, but future attempts may succeed if the problem is fixed.
+   *
+   * @throws SQLiteException If the database cannot be opened for writing.
+   * @return A read/write database object.
+   */
+  SQLiteDatabase getWritableDatabase();
+
+  /**
+   * Creates and/or opens a database. This will be the same object returned by {@link
+   * #getWritableDatabase()} unless some problem, such as a full disk, requires the database to be
+   * opened read-only. In that case, a read-only database object will be returned. If the problem is
+   * fixed, a future call to {@link #getWritableDatabase()} may succeed, in which case the read-only
+   * database object will be closed and the read/write object will be returned in the future.
+   *
+   * <p>Once opened successfully, the database is cached, so you can call this method every time you
+   * need to read from the database.
+   *
+   * @throws SQLiteException If the database cannot be opened.
+   * @return A database object valid until {@link #getWritableDatabase()} is called.
+   */
+  SQLiteDatabase getReadableDatabase();
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/database/DefaultDatabaseProvider.java b/library/core/src/main/java/com/google/android/exoplayer2/database/DefaultDatabaseProvider.java
new file mode 100644
index 0000000000..c04683b434
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/database/DefaultDatabaseProvider.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.database;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+
+/** A {@link DatabaseProvider} that provides instances obtained from a {@link SQLiteOpenHelper}. */
+public final class DefaultDatabaseProvider implements DatabaseProvider {
+
+  private final SQLiteOpenHelper sqliteOpenHelper;
+
+  /**
+   * @param sqliteOpenHelper An {@link SQLiteOpenHelper} from which to obtain database instances.
+   */
+  public DefaultDatabaseProvider(SQLiteOpenHelper sqliteOpenHelper) {
+    this.sqliteOpenHelper = sqliteOpenHelper;
+  }
+
+  @Override
+  public SQLiteDatabase getWritableDatabase() {
+    return sqliteOpenHelper.getWritableDatabase();
+  }
+
+  @Override
+  public SQLiteDatabase getReadableDatabase() {
+    return sqliteOpenHelper.getReadableDatabase();
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/database/ExoDatabaseProvider.java b/library/core/src/main/java/com/google/android/exoplayer2/database/ExoDatabaseProvider.java
new file mode 100644
index 0000000000..32dda5965c
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/database/ExoDatabaseProvider.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.database;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import com.google.android.exoplayer2.util.Log;
+
+/**
+ * An {@link SQLiteOpenHelper} that provides instances of a standalone ExoPlayer database.
+ *
+ * <p>Suitable for use by applications that do not already have their own database, or that would
+ * prefer to keep ExoPlayer tables isolated in their own database. Other applications should prefer
+ * to use {@link DefaultDatabaseProvider} with their own {@link SQLiteOpenHelper}.
+ */
+public final class ExoDatabaseProvider extends SQLiteOpenHelper implements DatabaseProvider {
+
+  /** The file name used for the standalone ExoPlayer database. */
+  public static final String DATABASE_NAME = "exoplayer_internal.db";
+
+  private static final int VERSION = 1;
+  private static final String TAG = "ExoDatabaseProvider";
+
+  /**
+   * Provides instances of the database located by passing {@link #DATABASE_NAME} to {@link
+   * Context#getDatabasePath(String)}.
+   *
+   * @param context Any context.
+   */
+  public ExoDatabaseProvider(Context context) {
+    super(context.getApplicationContext(), DATABASE_NAME, /* factory= */ null, VERSION);
+  }
+
+  @Override
+  public void onCreate(SQLiteDatabase db) {
+    // Features create their own tables.
+  }
+
+  @Override
+  public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    // Features handle their own upgrades.
+  }
+
+  @Override
+  public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    wipeDatabase(db);
+  }
+
+  /**
+   * Makes a best effort to wipe the existing database. The wipe may be incomplete if the database
+   * contains foreign key constraints.
+   */
+  private static void wipeDatabase(SQLiteDatabase db) {
+    String[] columns = {"type", "name"};
+    try (Cursor cursor =
+        db.query(
+            "sqlite_master",
+            columns,
+            /* selection= */ null,
+            /* selectionArgs= */ null,
+            /* groupBy= */ null,
+            /* having= */ null,
+            /* orderBy= */ null)) {
+      while (cursor.moveToNext()) {
+        String type = cursor.getString(0);
+        String name = cursor.getString(1);
+        if (!"sqlite_sequence".equals(name)) {
+          // If it's not an SQL-controlled entity, drop it
+          String sql = "DROP " + type + " IF EXISTS " + name;
+          try {
+            db.execSQL(sql);
+          } catch (SQLException e) {
+            Log.e(TAG, "Error executing " + sql, e);
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/database/VersionTable.java b/library/core/src/main/java/com/google/android/exoplayer2/database/VersionTable.java
new file mode 100644
index 0000000000..be367d2f22
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/database/VersionTable.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.database;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import androidx.annotation.IntDef;
+import androidx.annotation.VisibleForTesting;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Utility methods for accessing versions of ExoPlayer database components. This allows them to be
+ * versioned independently to the version of the containing database.
+ */
+public final class VersionTable {
+
+  /** Returned by {@link #getVersion(SQLiteDatabase, int, String)} if the version is unset. */
+  public static final int VERSION_UNSET = -1;
+  /** Version of tables used for offline functionality. */
+  public static final int FEATURE_OFFLINE = 0;
+  /** Version of tables used for cache content metadata. */
+  public static final int FEATURE_CACHE_CONTENT_METADATA = 1;
+  /** Version of tables used for cache file metadata. */
+  public static final int FEATURE_CACHE_FILE_METADATA = 2;
+
+  private static final String TABLE_NAME = DatabaseProvider.TABLE_PREFIX + "Versions";
+
+  private static final String COLUMN_FEATURE = "feature";
+  private static final String COLUMN_INSTANCE_UID = "instance_uid";
+  private static final String COLUMN_VERSION = "version";
+
+  private static final String WHERE_FEATURE_AND_INSTANCE_UID_EQUALS =
+      COLUMN_FEATURE + " = ? AND " + COLUMN_INSTANCE_UID + " = ?";
+
+  private static final String PRIMARY_KEY =
+      "PRIMARY KEY (" + COLUMN_FEATURE + ", " + COLUMN_INSTANCE_UID + ")";
+  private static final String SQL_CREATE_TABLE_IF_NOT_EXISTS =
+      "CREATE TABLE IF NOT EXISTS "
+          + TABLE_NAME
+          + " ("
+          + COLUMN_FEATURE
+          + " INTEGER NOT NULL,"
+          + COLUMN_INSTANCE_UID
+          + " TEXT NOT NULL,"
+          + COLUMN_VERSION
+          + " INTEGER NOT NULL,"
+          + PRIMARY_KEY
+          + ")";
+
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({FEATURE_OFFLINE, FEATURE_CACHE_CONTENT_METADATA, FEATURE_CACHE_FILE_METADATA})
+  private @interface Feature {}
+
+  private VersionTable() {}
+
+  /**
+   * Sets the version of a specified instance of a specified feature.
+   *
+   * @param writableDatabase The database to update.
+   * @param feature The feature.
+   * @param instanceUid The unique identifier of the instance of the feature.
+   * @param version The version.
+   * @throws DatabaseIOException If an error occurs executing the SQL.
+   */
+  public static void setVersion(
+      SQLiteDatabase writableDatabase, @Feature int feature, String instanceUid, int version)
+      throws DatabaseIOException {
+    try {
+      writableDatabase.execSQL(SQL_CREATE_TABLE_IF_NOT_EXISTS);
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_FEATURE, feature);
+      values.put(COLUMN_INSTANCE_UID, instanceUid);
+      values.put(COLUMN_VERSION, version);
+      writableDatabase.replaceOrThrow(TABLE_NAME, /* nullColumnHack= */ null, values);
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /**
+   * Removes the version of a specified instance of a feature.
+   *
+   * @param writableDatabase The database to update.
+   * @param feature The feature.
+   * @param instanceUid The unique identifier of the instance of the feature.
+   * @throws DatabaseIOException If an error occurs executing the SQL.
+   */
+  public static void removeVersion(
+      SQLiteDatabase writableDatabase, @Feature int feature, String instanceUid)
+      throws DatabaseIOException {
+    try {
+      if (!tableExists(writableDatabase, TABLE_NAME)) {
+        return;
+      }
+      writableDatabase.delete(
+          TABLE_NAME,
+          WHERE_FEATURE_AND_INSTANCE_UID_EQUALS,
+          featureAndInstanceUidArguments(feature, instanceUid));
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /**
+   * Returns the version of a specified instance of a feature, or {@link #VERSION_UNSET} if no
+   * version is set.
+   *
+   * @param database The database to query.
+   * @param feature The feature.
+   * @param instanceUid The unique identifier of the instance of the feature.
+   * @return The version, or {@link #VERSION_UNSET} if no version is set.
+   * @throws DatabaseIOException If an error occurs executing the SQL.
+   */
+  public static int getVersion(SQLiteDatabase database, @Feature int feature, String instanceUid)
+      throws DatabaseIOException {
+    try {
+      if (!tableExists(database, TABLE_NAME)) {
+        return VERSION_UNSET;
+      }
+      try (Cursor cursor =
+          database.query(
+              TABLE_NAME,
+              new String[] {COLUMN_VERSION},
+              WHERE_FEATURE_AND_INSTANCE_UID_EQUALS,
+              featureAndInstanceUidArguments(feature, instanceUid),
+              /* groupBy= */ null,
+              /* having= */ null,
+              /* orderBy= */ null)) {
+        if (cursor.getCount() == 0) {
+          return VERSION_UNSET;
+        }
+        cursor.moveToNext();
+        return cursor.getInt(/* COLUMN_VERSION index */ 0);
+      }
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  @VisibleForTesting
+  /* package */ static boolean tableExists(SQLiteDatabase readableDatabase, String tableName) {
+    long count =
+        DatabaseUtils.queryNumEntries(
+            readableDatabase, "sqlite_master", "tbl_name = ?", new String[] {tableName});
+    return count > 0;
+  }
+
+  private static String[] featureAndInstanceUidArguments(int feature, String instance) {
+    return new String[] {Integer.toString(feature), instance};
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java
index ec17de8d74..379ca971b5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java
@@ -62,7 +62,7 @@
   private final PatternHolderV24 patternHolder;
 
   public CryptoInfo() {
-    frameworkCryptoInfo = Util.SDK_INT >= 16 ? newFrameworkCryptoInfoV16() : null;
+    frameworkCryptoInfo = new android.media.MediaCodec.CryptoInfo();
     patternHolder = Util.SDK_INT >= 24 ? new PatternHolderV24(frameworkCryptoInfo) : null;
   }
 
@@ -79,43 +79,36 @@ public void set(int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEn
     this.mode = mode;
     this.encryptedBlocks = encryptedBlocks;
     this.clearBlocks = clearBlocks;
-    if (Util.SDK_INT >= 16) {
-      updateFrameworkCryptoInfoV16();
+    // Update frameworkCryptoInfo fields directly because CryptoInfo.set performs an unnecessary
+    // object allocation on Android N.
+    frameworkCryptoInfo.numSubSamples = numSubSamples;
+    frameworkCryptoInfo.numBytesOfClearData = numBytesOfClearData;
+    frameworkCryptoInfo.numBytesOfEncryptedData = numBytesOfEncryptedData;
+    frameworkCryptoInfo.key = key;
+    frameworkCryptoInfo.iv = iv;
+    frameworkCryptoInfo.mode = mode;
+    if (Util.SDK_INT >= 24) {
+      patternHolder.set(encryptedBlocks, clearBlocks);
     }
   }
 
   /**
    * Returns an equivalent {@link android.media.MediaCodec.CryptoInfo} instance.
-   * <p>
-   * Successive calls to this method on a single {@link CryptoInfo} will return the same instance.
-   * Changes to the {@link CryptoInfo} will be reflected in the returned object. The return object
-   * should not be modified directly.
+   *
+   * <p>Successive calls to this method on a single {@link CryptoInfo} will return the same
+   * instance. Changes to the {@link CryptoInfo} will be reflected in the returned object. The
+   * return object should not be modified directly.
    *
    * @return The equivalent {@link android.media.MediaCodec.CryptoInfo} instance.
    */
-  @TargetApi(16)
-  public android.media.MediaCodec.CryptoInfo getFrameworkCryptoInfoV16() {
+  public android.media.MediaCodec.CryptoInfo getFrameworkCryptoInfo() {
     return frameworkCryptoInfo;
   }
 
-  @TargetApi(16)
-  private android.media.MediaCodec.CryptoInfo newFrameworkCryptoInfoV16() {
-    return new android.media.MediaCodec.CryptoInfo();
-  }
-
-  @TargetApi(16)
-  private void updateFrameworkCryptoInfoV16() {
-    // Update fields directly because the framework's CryptoInfo.set performs an unnecessary object
-    // allocation on Android N.
-    frameworkCryptoInfo.numSubSamples = numSubSamples;
-    frameworkCryptoInfo.numBytesOfClearData = numBytesOfClearData;
-    frameworkCryptoInfo.numBytesOfEncryptedData = numBytesOfEncryptedData;
-    frameworkCryptoInfo.key = key;
-    frameworkCryptoInfo.iv = iv;
-    frameworkCryptoInfo.mode = mode;
-    if (Util.SDK_INT >= 24) {
-      patternHolder.set(encryptedBlocks, clearBlocks);
-    }
+  /** @deprecated Use {@link #getFrameworkCryptoInfo()}. */
+  @Deprecated
+  public android.media.MediaCodec.CryptoInfo getFrameworkCryptoInfoV16() {
+    return getFrameworkCryptoInfo();
   }
 
   @TargetApi(24)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index 983c96f89d..7fc6fb625a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.decoder;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
index 7e5ae694ce..f8204f6be3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.decoder;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.util.ArrayDeque;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DecryptionResource.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DecryptionResource.java
new file mode 100644
index 0000000000..dbe5c93172
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DecryptionResource.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+/**
+ * A reference-counted resource used in the decryption of media samples.
+ *
+ * @param <T> The reference type with which to make {@link Owner#onLastReferenceReleased} calls.
+ *     Subclasses are expected to pass themselves.
+ */
+public abstract class DecryptionResource<T extends DecryptionResource<T>> {
+
+  /**
+   * Implemented by the class in charge of managing a {@link DecryptionResource resource's}
+   * lifecycle.
+   */
+  public interface Owner<T extends DecryptionResource<T>> {
+
+    /**
+     * Called when the last reference to a {@link DecryptionResource} is {@link #releaseReference()
+     * released}.
+     */
+    void onLastReferenceReleased(T resource);
+  }
+
+  // TODO: Consider adding a handler on which the owner should be called.
+  private final DecryptionResource.Owner<T> owner;
+  private int referenceCount;
+
+  /**
+   * Creates a new instance with reference count zero.
+   *
+   * @param owner The owner of this instance.
+   */
+  public DecryptionResource(Owner<T> owner) {
+    this.owner = owner;
+    referenceCount = 0;
+  }
+
+  /** Increases by one the reference count for this resource. */
+  public void acquireReference() {
+    referenceCount++;
+  }
+
+  /**
+   * Decreases by one the reference count for this resource, and notifies the owner if said count
+   * reached zero as a result of this operation.
+   *
+   * <p>Must only be called as releasing counter-part of {@link #acquireReference()}.
+   */
+  @SuppressWarnings("unchecked")
+  public void releaseReference() {
+    if (--referenceCount == 0) {
+      owner.onLastReferenceReleased((T) this);
+    } else if (referenceCount < 0) {
+      throw new IllegalStateException("Illegal release of resource.");
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
index 0b1b4ba380..775d56f40b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
@@ -22,20 +22,25 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.EventDispatcher;
 import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * A {@link DrmSession} that supports playbacks using {@link ExoMediaDrm}.
@@ -84,7 +89,7 @@
   private final ExoMediaDrm<T> mediaDrm;
   private final ProvisioningManager<T> provisioningManager;
   private final @DefaultDrmSessionManager.Mode int mode;
-  private final HashMap<String, String> optionalKeyRequestParameters;
+  private final @Nullable HashMap<String, String> optionalKeyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final int initialDrmRequestRetryCount;
 
@@ -96,13 +101,13 @@
   private int openCount;
   private HandlerThread requestHandlerThread;
   private PostRequestHandler postRequestHandler;
-  private T mediaCrypto;
-  private DrmSessionException lastException;
-  private byte[] sessionId;
-  private @Nullable byte[] offlineLicenseKeySetId;
+  private @Nullable T mediaCrypto;
+  private @Nullable DrmSessionException lastException;
+  private byte @MonotonicNonNull [] sessionId;
+  private byte @MonotonicNonNull [] offlineLicenseKeySetId;
 
-  private KeyRequest currentKeyRequest;
-  private ProvisionRequest currentProvisionRequest;
+  private @Nullable KeyRequest currentKeyRequest;
+  private @Nullable ProvisionRequest currentProvisionRequest;
 
   /**
    * Instantiates a new DRM session.
@@ -129,18 +134,25 @@ public DefaultDrmSession(
       @Nullable List<SchemeData> schemeDatas,
       @DefaultDrmSessionManager.Mode int mode,
       @Nullable byte[] offlineLicenseKeySetId,
-      HashMap<String, String> optionalKeyRequestParameters,
+      @Nullable HashMap<String, String> optionalKeyRequestParameters,
       MediaDrmCallback callback,
       Looper playbackLooper,
       EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher,
       int initialDrmRequestRetryCount) {
+    if (mode == DefaultDrmSessionManager.MODE_QUERY
+        || mode == DefaultDrmSessionManager.MODE_RELEASE) {
+      Assertions.checkNotNull(offlineLicenseKeySetId);
+    }
     this.uuid = uuid;
     this.provisioningManager = provisioningManager;
     this.mediaDrm = mediaDrm;
     this.mode = mode;
-    this.offlineLicenseKeySetId = offlineLicenseKeySetId;
-    this.schemeDatas =
-        offlineLicenseKeySetId == null ? Collections.unmodifiableList(schemeDatas) : null;
+    if (offlineLicenseKeySetId != null) {
+      this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+      this.schemeDatas = null;
+    } else {
+      this.schemeDatas = Collections.unmodifiableList(Assertions.checkNotNull(schemeDatas));
+    }
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.callback = callback;
     this.initialDrmRequestRetryCount = initialDrmRequestRetryCount;
@@ -166,9 +178,9 @@ public void acquire() {
     }
   }
 
-  /**
-   * @return True if the session is closed and cleaned up, false otherwise.
-   */
+  /** @return True if the session is closed and cleaned up, false otherwise. */
+  // Assigning null to various non-null variables for clean-up. Class won't be used after release.
+  @SuppressWarnings("assignment.type.incompatible")
   public boolean release() {
     if (--openCount == 0) {
       state = STATE_RELEASED;
@@ -195,24 +207,10 @@ public boolean hasSessionId(byte[] sessionId) {
     return Arrays.equals(this.sessionId, sessionId);
   }
 
-  @SuppressWarnings("deprecation")
   public void onMediaDrmEvent(int what) {
-    if (!isOpen()) {
-      return;
-    }
     switch (what) {
       case ExoMediaDrm.EVENT_KEY_REQUIRED:
-        doLicense(false);
-        break;
-      case ExoMediaDrm.EVENT_KEY_EXPIRED:
-        // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
-        // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
-        // waiting for key response.
-        onKeysExpired();
-        break;
-      case ExoMediaDrm.EVENT_PROVISION_REQUIRED:
-        state = STATE_OPENED;
-        provisioningManager.provisionRequired(this);
+        onKeysRequired();
         break;
       default:
         break;
@@ -245,33 +243,35 @@ public final int getState() {
   }
 
   @Override
-  public final DrmSessionException getError() {
+  public final @Nullable DrmSessionException getError() {
     return state == STATE_ERROR ? lastException : null;
   }
 
   @Override
-  public final T getMediaCrypto() {
+  public final @Nullable T getMediaCrypto() {
     return mediaCrypto;
   }
 
   @Override
-  public Map<String, String> queryKeyStatus() {
+  public @Nullable Map<String, String> queryKeyStatus() {
     return sessionId == null ? null : mediaDrm.queryKeyStatus(sessionId);
   }
 
   @Override
-  public byte[] getOfflineLicenseKeySetId() {
+  public @Nullable byte[] getOfflineLicenseKeySetId() {
     return offlineLicenseKeySetId;
   }
 
   // Internal methods.
 
   /**
-   *  Try to open a session, do provisioning if necessary.
-   *  @param allowProvisioning if provisioning is allowed, set this to false when calling from
-   *      processing provision response.
-   *  @return true on success, false otherwise.
+   * Try to open a session, do provisioning if necessary.
+   *
+   * @param allowProvisioning if provisioning is allowed, set this to false when calling from
+   *     processing provision response.
+   * @return true on success, false otherwise.
    */
+  @EnsuresNonNullIf(result = true, expression = "sessionId")
   private boolean openInternal(boolean allowProvisioning) {
     if (isOpen()) {
       // Already opened
@@ -319,19 +319,20 @@ private void onProvisionResponse(Object request, Object response) {
     provisioningManager.onProvisionCompleted();
   }
 
+  @RequiresNonNull("sessionId")
   private void doLicense(boolean allowRetry) {
     switch (mode) {
       case DefaultDrmSessionManager.MODE_PLAYBACK:
       case DefaultDrmSessionManager.MODE_QUERY:
         if (offlineLicenseKeySetId == null) {
-          postKeyRequest(ExoMediaDrm.KEY_TYPE_STREAMING, allowRetry);
+          postKeyRequest(sessionId, ExoMediaDrm.KEY_TYPE_STREAMING, allowRetry);
         } else if (state == STATE_OPENED_WITH_KEYS || restoreKeys()) {
           long licenseDurationRemainingSec = getLicenseDurationRemainingSec();
           if (mode == DefaultDrmSessionManager.MODE_PLAYBACK
               && licenseDurationRemainingSec <= MAX_LICENSE_DURATION_TO_RENEW) {
             Log.d(TAG, "Offline license has expired or will expire soon. "
                 + "Remaining seconds: " + licenseDurationRemainingSec);
-            postKeyRequest(ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
+            postKeyRequest(sessionId, ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
           } else if (licenseDurationRemainingSec <= 0) {
             onError(new KeysExpiredException());
           } else {
@@ -342,19 +343,20 @@ private void doLicense(boolean allowRetry) {
         break;
       case DefaultDrmSessionManager.MODE_DOWNLOAD:
         if (offlineLicenseKeySetId == null) {
-          postKeyRequest(ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
+          postKeyRequest(sessionId, ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
         } else {
           // Renew
           if (restoreKeys()) {
-            postKeyRequest(ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
+            postKeyRequest(sessionId, ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
           }
         }
         break;
       case DefaultDrmSessionManager.MODE_RELEASE:
+        Assertions.checkNotNull(offlineLicenseKeySetId);
         // It's not necessary to restore the key (and open a session to do that) before releasing it
         // but this serves as a good sanity/fast-failure check.
         if (restoreKeys()) {
-          postKeyRequest(ExoMediaDrm.KEY_TYPE_RELEASE, allowRetry);
+          postKeyRequest(offlineLicenseKeySetId, ExoMediaDrm.KEY_TYPE_RELEASE, allowRetry);
         }
         break;
       default:
@@ -362,6 +364,7 @@ private void doLicense(boolean allowRetry) {
     }
   }
 
+  @RequiresNonNull({"sessionId", "offlineLicenseKeySetId"})
   private boolean restoreKeys() {
     try {
       mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
@@ -377,12 +380,12 @@ private long getLicenseDurationRemainingSec() {
     if (!C.WIDEVINE_UUID.equals(uuid)) {
       return Long.MAX_VALUE;
     }
-    Pair<Long, Long> pair = WidevineUtil.getLicenseDurationRemainingSec(this);
+    Pair<Long, Long> pair =
+        Assertions.checkNotNull(WidevineUtil.getLicenseDurationRemainingSec(this));
     return Math.min(pair.first, pair.second);
   }
 
-  private void postKeyRequest(int type, boolean allowRetry) {
-    byte[] scope = type == ExoMediaDrm.KEY_TYPE_RELEASE ? offlineLicenseKeySetId : sessionId;
+  private void postKeyRequest(byte[] scope, int type, boolean allowRetry) {
     try {
       currentKeyRequest =
           mediaDrm.getKeyRequest(scope, schemeDatas, type, optionalKeyRequestParameters);
@@ -407,7 +410,7 @@ private void onKeyResponse(Object request, Object response) {
     try {
       byte[] responseData = (byte[]) response;
       if (mode == DefaultDrmSessionManager.MODE_RELEASE) {
-        mediaDrm.provideKeyResponse(offlineLicenseKeySetId, responseData);
+        mediaDrm.provideKeyResponse(Util.castNonNull(offlineLicenseKeySetId), responseData);
         eventDispatcher.dispatch(DefaultDrmSessionEventListener::onDrmKeysRestored);
       } else {
         byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, responseData);
@@ -424,10 +427,10 @@ private void onKeyResponse(Object request, Object response) {
     }
   }
 
-  private void onKeysExpired() {
-    if (state == STATE_OPENED_WITH_KEYS) {
-      state = STATE_OPENED;
-      onError(new KeysExpiredException());
+  private void onKeysRequired() {
+    if (mode == DefaultDrmSessionManager.MODE_PLAYBACK && state == STATE_OPENED_WITH_KEYS) {
+      Util.castNonNull(sessionId);
+      doLicense(/* allowRetry= */ false);
     }
   }
 
@@ -447,6 +450,8 @@ private void onError(final Exception e) {
     }
   }
 
+  @EnsuresNonNullIf(result = true, expression = "sessionId")
+  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   private boolean isOpen() {
     return state == STATE_OPENED || state == STATE_OPENED_WITH_KEYS;
   }
@@ -461,8 +466,9 @@ public PostResponseHandler(Looper looper) {
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public void handleMessage(Message msg) {
-      Pair<?, ?> requestAndResponse = (Pair<?, ?>) msg.obj;
+      Pair<Object, Object> requestAndResponse = (Pair<Object, Object>) msg.obj;
       Object request = requestAndResponse.first;
       Object response = requestAndResponse.second;
       switch (msg.what) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 6062a6652a..3820836e49 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -20,8 +20,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import android.support.annotation.IntDef;
-import android.support.annotation.NonNull;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DefaultDrmSession.ProvisioningManager;
@@ -47,10 +47,6 @@
 public class DefaultDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
     ProvisioningManager<T> {
 
-  /** @deprecated Use {@link DefaultDrmSessionEventListener}. */
-  @Deprecated
-  public interface EventListener extends DefaultDrmSessionEventListener {}
-
   /**
    * Signals that the {@link DrmInitData} passed to {@link #acquireSession} does not contain does
    * not contain scheme data for the required UUID.
@@ -96,7 +92,7 @@ private MissingSchemeDataException(UUID uuid) {
   private final UUID uuid;
   private final ExoMediaDrm<T> mediaDrm;
   private final MediaDrmCallback callback;
-  private final HashMap<String, String> optionalKeyRequestParameters;
+  private final @Nullable HashMap<String, String> optionalKeyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final boolean multiSession;
   private final int initialDrmRequestRetryCount;
@@ -104,30 +100,11 @@ private MissingSchemeDataException(UUID uuid) {
   private final List<DefaultDrmSession<T>> sessions;
   private final List<DefaultDrmSession<T>> provisioningSessions;
 
-  private Looper playbackLooper;
+  private @Nullable Looper playbackLooper;
   private int mode;
-  private byte[] offlineLicenseKeySetId;
-
-  /* package */ volatile MediaDrmHandler mediaDrmHandler;
+  private @Nullable byte[] offlineLicenseKeySetId;
 
-  /**
-   * @deprecated Use {@link #newWidevineInstance(MediaDrmCallback, HashMap)} and {@link
-   *     #addListener(Handler, DefaultDrmSessionEventListener)}.
-   */
-  @Deprecated
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
-      MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
-      Handler eventHandler,
-      DefaultDrmSessionEventListener eventListener)
-      throws UnsupportedDrmException {
-    DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager =
-        newWidevineInstance(callback, optionalKeyRequestParameters);
-    if (eventHandler != null && eventListener != null) {
-      drmSessionManager.addListener(eventHandler, eventListener);
-    }
-    return drmSessionManager;
-  }
+  /* package */ volatile @Nullable MediaDrmHandler mediaDrmHandler;
 
   /**
    * Instantiates a new instance using the Widevine scheme.
@@ -138,30 +115,11 @@ private MissingSchemeDataException(UUID uuid) {
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
-      MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters)
+      MediaDrmCallback callback, @Nullable HashMap<String, String> optionalKeyRequestParameters)
       throws UnsupportedDrmException {
     return newFrameworkInstance(C.WIDEVINE_UUID, callback, optionalKeyRequestParameters);
   }
 
-  /**
-   * @deprecated Use {@link #newPlayReadyInstance(MediaDrmCallback, String)} and {@link
-   *     #addListener(Handler, DefaultDrmSessionEventListener)}.
-   */
-  @Deprecated
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
-      MediaDrmCallback callback,
-      String customData,
-      Handler eventHandler,
-      DefaultDrmSessionEventListener eventListener)
-      throws UnsupportedDrmException {
-    DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager =
-        newPlayReadyInstance(callback, customData);
-    if (eventHandler != null && eventListener != null) {
-      drmSessionManager.addListener(eventHandler, eventListener);
-    }
-    return drmSessionManager;
-  }
-
   /**
    * Instantiates a new instance using the PlayReady scheme.
    *
@@ -173,7 +131,7 @@ private MissingSchemeDataException(UUID uuid) {
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
-      MediaDrmCallback callback, String customData) throws UnsupportedDrmException {
+      MediaDrmCallback callback, @Nullable String customData) throws UnsupportedDrmException {
     HashMap<String, String> optionalKeyRequestParameters;
     if (!TextUtils.isEmpty(customData)) {
       optionalKeyRequestParameters = new HashMap<>();
@@ -184,26 +142,6 @@ private MissingSchemeDataException(UUID uuid) {
     return newFrameworkInstance(C.PLAYREADY_UUID, callback, optionalKeyRequestParameters);
   }
 
-  /**
-   * @deprecated Use {@link #newFrameworkInstance(UUID, MediaDrmCallback, HashMap)} and {@link
-   *     #addListener(Handler, DefaultDrmSessionEventListener)}.
-   */
-  @Deprecated
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
-      UUID uuid,
-      MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
-      Handler eventHandler,
-      DefaultDrmSessionEventListener eventListener)
-      throws UnsupportedDrmException {
-    DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager =
-        newFrameworkInstance(uuid, callback, optionalKeyRequestParameters);
-    if (eventHandler != null && eventListener != null) {
-      drmSessionManager.addListener(eventHandler, eventListener);
-    }
-    return drmSessionManager;
-  }
-
   /**
    * Instantiates a new instance.
    *
@@ -214,7 +152,9 @@ private MissingSchemeDataException(UUID uuid) {
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
-      UUID uuid, MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters)
+      UUID uuid,
+      MediaDrmCallback callback,
+      @Nullable HashMap<String, String> optionalKeyRequestParameters)
       throws UnsupportedDrmException {
     return new DefaultDrmSessionManager<>(
         uuid,
@@ -225,24 +165,6 @@ private MissingSchemeDataException(UUID uuid) {
         INITIAL_DRM_REQUEST_RETRY_COUNT);
   }
 
-  /**
-   * @deprecated Use {@link #DefaultDrmSessionManager(UUID, ExoMediaDrm, MediaDrmCallback, HashMap)}
-   *     and {@link #addListener(Handler, DefaultDrmSessionEventListener)}.
-   */
-  @Deprecated
-  public DefaultDrmSessionManager(
-      UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
-      MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
-      Handler eventHandler,
-      DefaultDrmSessionEventListener eventListener) {
-    this(uuid, mediaDrm, callback, optionalKeyRequestParameters);
-    if (eventHandler != null && eventListener != null) {
-      addListener(eventHandler, eventListener);
-    }
-  }
-
   /**
    * @param uuid The UUID of the drm scheme.
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
@@ -254,7 +176,7 @@ public DefaultDrmSessionManager(
       UUID uuid,
       ExoMediaDrm<T> mediaDrm,
       MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters) {
+      @Nullable HashMap<String, String> optionalKeyRequestParameters) {
     this(
         uuid,
         mediaDrm,
@@ -264,25 +186,6 @@ public DefaultDrmSessionManager(
         INITIAL_DRM_REQUEST_RETRY_COUNT);
   }
 
-  /**
-   * @deprecated Use {@link #DefaultDrmSessionManager(UUID, ExoMediaDrm, MediaDrmCallback, HashMap,
-   *     boolean)} and {@link #addListener(Handler, DefaultDrmSessionEventListener)}.
-   */
-  @Deprecated
-  public DefaultDrmSessionManager(
-      UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
-      MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
-      Handler eventHandler,
-      DefaultDrmSessionEventListener eventListener,
-      boolean multiSession) {
-    this(uuid, mediaDrm, callback, optionalKeyRequestParameters, multiSession);
-    if (eventHandler != null && eventListener != null) {
-      addListener(eventHandler, eventListener);
-    }
-  }
-
   /**
    * @param uuid The UUID of the drm scheme.
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
@@ -296,7 +199,7 @@ public DefaultDrmSessionManager(
       UUID uuid,
       ExoMediaDrm<T> mediaDrm,
       MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
+      @Nullable HashMap<String, String> optionalKeyRequestParameters,
       boolean multiSession) {
     this(
         uuid,
@@ -307,32 +210,6 @@ public DefaultDrmSessionManager(
         INITIAL_DRM_REQUEST_RETRY_COUNT);
   }
 
-  /**
-   * @deprecated Use {@link #DefaultDrmSessionManager(UUID, ExoMediaDrm, MediaDrmCallback, HashMap,
-   *     boolean, int)} and {@link #addListener(Handler, DefaultDrmSessionEventListener)}.
-   */
-  @Deprecated
-  public DefaultDrmSessionManager(
-      UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
-      MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
-      Handler eventHandler,
-      DefaultDrmSessionEventListener eventListener,
-      boolean multiSession,
-      int initialDrmRequestRetryCount) {
-    this(
-        uuid,
-        mediaDrm,
-        callback,
-        optionalKeyRequestParameters,
-        multiSession,
-        initialDrmRequestRetryCount);
-    if (eventHandler != null && eventListener != null) {
-      addListener(eventHandler, eventListener);
-    }
-  }
-
   /**
    * @param uuid The UUID of the drm scheme.
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
@@ -348,7 +225,7 @@ public DefaultDrmSessionManager(
       UUID uuid,
       ExoMediaDrm<T> mediaDrm,
       MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters,
+      @Nullable HashMap<String, String> optionalKeyRequestParameters,
       boolean multiSession,
       int initialDrmRequestRetryCount) {
     Assertions.checkNotNull(uuid);
@@ -449,21 +326,22 @@ public final void setPropertyByteArray(String key, byte[] value) {
    * required.
    *
    * <p>{@code mode} must be one of these:
+   *
    * <ul>
-   * <li>{@link #MODE_PLAYBACK}: If {@code offlineLicenseKeySetId} is null, a streaming license is
-   *     requested otherwise the offline license is restored.
-   * <li>{@link #MODE_QUERY}: {@code offlineLicenseKeySetId} can not be null. The offline license
-   *     is restored.
-   * <li>{@link #MODE_DOWNLOAD}: If {@code offlineLicenseKeySetId} is null, an offline license is
-   *     requested otherwise the offline license is renewed.
-   * <li>{@link #MODE_RELEASE}: {@code offlineLicenseKeySetId} can not be null. The offline license
-   *     is released.
+   *   <li>{@link #MODE_PLAYBACK}: If {@code offlineLicenseKeySetId} is null, a streaming license is
+   *       requested otherwise the offline license is restored.
+   *   <li>{@link #MODE_QUERY}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *       is restored.
+   *   <li>{@link #MODE_DOWNLOAD}: If {@code offlineLicenseKeySetId} is null, an offline license is
+   *       requested otherwise the offline license is renewed.
+   *   <li>{@link #MODE_RELEASE}: {@code offlineLicenseKeySetId} can not be null. The offline
+   *       license is released.
    * </ul>
    *
    * @param mode The mode to be set.
    * @param offlineLicenseKeySetId The key set id of the license to be used with the given mode.
    */
-  public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
+  public void setMode(@Mode int mode, @Nullable byte[] offlineLicenseKeySetId) {
     Assertions.checkState(sessions.isEmpty());
     if (mode == MODE_QUERY || mode == MODE_RELEASE) {
       Assertions.checkNotNull(offlineLicenseKeySetId);
@@ -475,7 +353,7 @@ public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
   // DrmSessionManager implementation.
 
   @Override
-  public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
+  public boolean canAcquireSession(DrmInitData drmInitData) {
     if (offlineLicenseKeySetId != null) {
       // An offline license can be restored so a session can always be acquired.
       return true;
@@ -583,6 +461,10 @@ public void releaseSession(DrmSession<T> session) {
 
   @Override
   public void provisionRequired(DefaultDrmSession<T> session) {
+    if (provisioningSessions.contains(session)) {
+      // The session has already requested provisioning.
+      return;
+    }
     provisioningSessions.add(session);
     if (provisioningSessions.size() == 1) {
       // This is the first session requesting provisioning, so have it perform the operation.
@@ -643,6 +525,10 @@ public MediaDrmHandler(Looper looper) {
     @Override
     public void handleMessage(Message msg) {
       byte[] sessionId = (byte[]) msg.obj;
+      if (sessionId == null) {
+        // The event is not associated with any particular session.
+        return;
+      }
       for (DefaultDrmSession<T> session : sessions) {
         if (session.hasSessionId(sessionId)) {
           session.onMediaDrmEvent(msg.what);
@@ -656,11 +542,13 @@ public void handleMessage(Message msg) {
   private class MediaDrmEventListener implements OnEventListener<T> {
 
     @Override
-    public void onEvent(ExoMediaDrm<? extends T> md, byte[] sessionId, int event, int extra,
-        byte[] data) {
-      if (mode == DefaultDrmSessionManager.MODE_PLAYBACK) {
-        mediaDrmHandler.obtainMessage(event, sessionId).sendToTarget();
-      }
+    public void onEvent(
+        ExoMediaDrm<? extends T> md,
+        byte[] sessionId,
+        int event,
+        int extra,
+        @Nullable byte[] data) {
+      Assertions.checkNotNull(mediaDrmHandler).obtainMessage(event, sessionId).sendToTarget();
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
index b9415c74af..4fde9f05d3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
@@ -17,7 +17,8 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.util.Assertions;
@@ -85,10 +86,8 @@
   // Lazily initialized hashcode.
   private int hashCode;
 
-  /**
-   * The protection scheme type, or null if not applicable or unknown.
-   */
-  @Nullable public final String schemeType;
+  /** The protection scheme type, or null if not applicable or unknown. */
+  public final @Nullable String schemeType;
 
   /**
    * Number of {@link SchemeData}s.
@@ -99,15 +98,15 @@
    * @param schemeDatas Scheme initialization data for possibly multiple DRM schemes.
    */
   public DrmInitData(List<SchemeData> schemeDatas) {
-    this(null, false, schemeDatas.toArray(new SchemeData[schemeDatas.size()]));
+    this(null, false, schemeDatas.toArray(new SchemeData[0]));
   }
 
   /**
    * @param schemeType See {@link #schemeType}.
    * @param schemeDatas Scheme initialization data for possibly multiple DRM schemes.
    */
-  public DrmInitData(String schemeType, List<SchemeData> schemeDatas) {
-    this(schemeType, false, schemeDatas.toArray(new SchemeData[schemeDatas.size()]));
+  public DrmInitData(@Nullable String schemeType, List<SchemeData> schemeDatas) {
+    this(schemeType, false, schemeDatas.toArray(new SchemeData[0]));
   }
 
   /**
@@ -131,16 +130,17 @@ private DrmInitData(@Nullable String schemeType, boolean cloneSchemeDatas,
     if (cloneSchemeDatas) {
       schemeDatas = schemeDatas.clone();
     }
-    // Sorting ensures that universal scheme data (i.e. data that applies to all schemes) is matched
-    // last. It's also required by the equals and hashcode implementations.
-    Arrays.sort(schemeDatas, this);
     this.schemeDatas = schemeDatas;
     schemeDataCount = schemeDatas.length;
+    // Sorting ensures that universal scheme data (i.e. data that applies to all schemes) is matched
+    // last. It's also required by the equals and hashcode implementations.
+    Arrays.sort(this.schemeDatas, this);
   }
 
-  /* package */ DrmInitData(Parcel in) {
+  /* package */
+  DrmInitData(Parcel in) {
     schemeType = in.readString();
-    schemeDatas = in.createTypedArray(SchemeData.CREATOR);
+    schemeDatas = Util.castNonNull(in.createTypedArray(SchemeData.CREATOR));
     schemeDataCount = schemeDatas.length;
   }
 
@@ -152,7 +152,7 @@ private DrmInitData(@Nullable String schemeType, boolean cloneSchemeDatas,
    * @return The initialization data for the scheme, or null if the scheme is not supported.
    */
   @Deprecated
-  public SchemeData get(UUID uuid) {
+  public @Nullable SchemeData get(UUID uuid) {
     for (SchemeData schemeData : schemeDatas) {
       if (schemeData.matches(uuid)) {
         return schemeData;
@@ -184,6 +184,25 @@ public DrmInitData copyWithSchemeType(@Nullable String schemeType) {
     return new DrmInitData(schemeType, false, schemeDatas);
   }
 
+  /**
+   * Returns an instance containing the {@link #schemeDatas} from both this and {@code other}. The
+   * {@link #schemeType} of the instances being merged must either match, or at least one scheme
+   * type must be {@code null}.
+   *
+   * @param drmInitData The instance to merge.
+   * @return The merged result.
+   */
+  public DrmInitData merge(DrmInitData drmInitData) {
+    Assertions.checkState(
+        schemeType == null
+            || drmInitData.schemeType == null
+            || TextUtils.equals(schemeType, drmInitData.schemeType));
+    String mergedSchemeType = schemeType != null ? this.schemeType : drmInitData.schemeType;
+    SchemeData[] mergedSchemeDatas =
+        Util.nullSafeArrayConcatenation(schemeDatas, drmInitData.schemeDatas);
+    return new DrmInitData(mergedSchemeType, mergedSchemeDatas);
+  }
+
   @Override
   public int hashCode() {
     if (hashCode == 0) {
@@ -270,10 +289,8 @@ private static boolean containsSchemeDataWithUuid(
     public final @Nullable String licenseServerUrl;
     /** The mimeType of {@link #data}. */
     public final String mimeType;
-    /**
-     * The initialization data. May be null for scheme support checks only.
-     */
-    public final byte[] data;
+    /** The initialization data. May be null for scheme support checks only. */
+    public final @Nullable byte[] data;
     /**
      * Whether secure decryption is required.
      */
@@ -285,7 +302,7 @@ private static boolean containsSchemeDataWithUuid(
      * @param mimeType See {@link #mimeType}.
      * @param data See {@link #data}.
      */
-    public SchemeData(UUID uuid, String mimeType, byte[] data) {
+    public SchemeData(UUID uuid, String mimeType, @Nullable byte[] data) {
       this(uuid, mimeType, data, false);
     }
 
@@ -296,7 +313,8 @@ public SchemeData(UUID uuid, String mimeType, byte[] data) {
      * @param data See {@link #data}.
      * @param requiresSecureDecryption See {@link #requiresSecureDecryption}.
      */
-    public SchemeData(UUID uuid, String mimeType, byte[] data, boolean requiresSecureDecryption) {
+    public SchemeData(
+        UUID uuid, String mimeType, @Nullable byte[] data, boolean requiresSecureDecryption) {
       this(uuid, /* licenseServerUrl= */ null, mimeType, data, requiresSecureDecryption);
     }
 
@@ -312,7 +330,7 @@ public SchemeData(
         UUID uuid,
         @Nullable String licenseServerUrl,
         String mimeType,
-        byte[] data,
+        @Nullable byte[] data,
         boolean requiresSecureDecryption) {
       this.uuid = Assertions.checkNotNull(uuid);
       this.licenseServerUrl = licenseServerUrl;
@@ -324,7 +342,7 @@ public SchemeData(
     /* package */ SchemeData(Parcel in) {
       uuid = new UUID(in.readLong(), in.readLong());
       licenseServerUrl = in.readString();
-      mimeType = in.readString();
+      mimeType = Util.castNonNull(in.readString());
       data = in.createByteArray();
       requiresSecureDecryption = in.readByte() != 0;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index f2fbe94895..392b0734b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -15,9 +15,9 @@
  */
 package com.google.android.exoplayer2.drm;
 
-import android.annotation.TargetApi;
 import android.media.MediaDrm;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -26,7 +26,6 @@
 /**
  * A DRM session.
  */
-@TargetApi(16)
 public interface DrmSession<T extends ExoMediaCrypto> {
 
   /**
@@ -77,21 +76,24 @@ public DrmSessionException(Throwable cause) {
   @State int getState();
 
   /**
-   * Returns the cause of the error state.
+   * Returns the cause of the error state, or null if {@link #getState()} is not {@link
+   * #STATE_ERROR}.
    */
+  @Nullable
   DrmSessionException getError();
 
   /**
    * Returns a {@link ExoMediaCrypto} for the open session, or null if called before the session has
    * been opened or after it's been released.
    */
+  @Nullable
   T getMediaCrypto();
 
   /**
    * Returns a map describing the key status for the session, or null if called before the session
    * has been opened or after it's been released.
-   * <p>
-   * Since DRM license policies vary by vendor, the specific status field names are determined by
+   *
+   * <p>Since DRM license policies vary by vendor, the specific status field names are determined by
    * each DRM vendor. Refer to your DRM provider documentation for definitions of the field names
    * for a particular DRM engine plugin.
    *
@@ -99,12 +101,13 @@ public DrmSessionException(Throwable cause) {
    *     has been opened or after it's been released.
    * @see MediaDrm#queryKeyStatus(byte[])
    */
+  @Nullable
   Map<String, String> queryKeyStatus();
 
   /**
    * Returns the key set id of the offline license loaded into this session, or null if there isn't
    * one.
    */
+  @Nullable
   byte[] getOfflineLicenseKeySetId();
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
index cf3d97d0b2..d8093507a4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
@@ -15,14 +15,12 @@
  */
 package com.google.android.exoplayer2.drm;
 
-import android.annotation.TargetApi;
 import android.os.Looper;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 
 /**
  * Manages a DRM session.
  */
-@TargetApi(16)
 public interface DrmSessionManager<T extends ExoMediaCrypto> {
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
index d30e670c3f..82fd9a5549 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 import java.util.Map;
 
@@ -33,22 +34,22 @@ public int getState() {
   }
 
   @Override
-  public DrmSessionException getError() {
+  public @Nullable DrmSessionException getError() {
     return error;
   }
 
   @Override
-  public T getMediaCrypto() {
+  public @Nullable T getMediaCrypto() {
     return null;
   }
 
   @Override
-  public Map<String, String> queryKeyStatus() {
+  public @Nullable Map<String, String> queryKeyStatus() {
     return null;
   }
 
   @Override
-  public byte[] getOfflineLicenseKeySetId() {
+  public @Nullable byte[] getOfflineLicenseKeySetId() {
     return null;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaCrypto.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaCrypto.java
index d5a4f6add5..feba7eaaf4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaCrypto.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaCrypto.java
@@ -15,14 +15,5 @@
  */
 package com.google.android.exoplayer2.drm;
 
-/**
- * An opaque {@link android.media.MediaCrypto} equivalent.
- */
-public interface ExoMediaCrypto {
-
-  /**
-   * @see android.media.MediaCrypto#requiresSecureDecoderComponent(String)
-   */
-  boolean requiresSecureDecoderComponent(String mimeType);
-
-}
+/** An opaque {@link android.media.MediaCrypto} equivalent. */
+public interface ExoMediaCrypto {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
index 24c3ddbbd0..49915f3af5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
@@ -21,7 +21,7 @@
 import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import java.util.HashMap;
 import java.util.List;
@@ -265,11 +265,9 @@ KeyRequest getKeyRequest(
 
   /**
    * @see android.media.MediaCrypto#MediaCrypto(UUID, byte[])
-   *
-   * @param initData Opaque initialization data specific to the crypto scheme.
+   * @param sessionId The DRM session ID.
    * @return An object extends {@link ExoMediaCrypto}, using opaque crypto scheme specific data.
    * @throws MediaCryptoException If the instance can't be created.
    */
-  T createMediaCrypto(byte[] initData) throws MediaCryptoException;
-
+  T createMediaCrypto(byte[] sessionId) throws MediaCryptoException;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
index 4e58ed6a31..7211b5fcde 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
@@ -15,50 +15,35 @@
  */
 package com.google.android.exoplayer2.drm;
 
-import android.annotation.TargetApi;
 import android.media.MediaCrypto;
-import com.google.android.exoplayer2.util.Assertions;
+import java.util.UUID;
 
 /**
- * An {@link ExoMediaCrypto} implementation that wraps the framework {@link MediaCrypto}.
+ * An {@link ExoMediaCrypto} implementation that contains the necessary information to build or
+ * update a framework {@link MediaCrypto}.
  */
-@TargetApi(16)
 public final class FrameworkMediaCrypto implements ExoMediaCrypto {
 
-  private final MediaCrypto mediaCrypto;
-  private final boolean forceAllowInsecureDecoderComponents;
-
+  /** The DRM scheme UUID. */
+  public final UUID uuid;
+  /** The DRM session id. */
+  public final byte[] sessionId;
   /**
-   * @param mediaCrypto The {@link MediaCrypto} to wrap.
+   * Whether to allow use of insecure decoder components even if the underlying platform says
+   * otherwise.
    */
-  public FrameworkMediaCrypto(MediaCrypto mediaCrypto) {
-    this(mediaCrypto, false);
-  }
+  public final boolean forceAllowInsecureDecoderComponents;
 
   /**
-   * @param mediaCrypto The {@link MediaCrypto} to wrap.
-   * @param forceAllowInsecureDecoderComponents Whether to force
-   *     {@link #requiresSecureDecoderComponent(String)} to return {@code false}, rather than
-   *     {@link MediaCrypto#requiresSecureDecoderComponent(String)} of the wrapped
-   *     {@link MediaCrypto}.
+   * @param uuid The DRM scheme UUID.
+   * @param sessionId The DRM session id.
+   * @param forceAllowInsecureDecoderComponents Whether to allow use of insecure decoder components
+   *     even if the underlying platform says otherwise.
    */
-  public FrameworkMediaCrypto(MediaCrypto mediaCrypto,
-      boolean forceAllowInsecureDecoderComponents) {
-    this.mediaCrypto = Assertions.checkNotNull(mediaCrypto);
+  public FrameworkMediaCrypto(
+      UUID uuid, byte[] sessionId, boolean forceAllowInsecureDecoderComponents) {
+    this.uuid = uuid;
+    this.sessionId = sessionId;
     this.forceAllowInsecureDecoderComponents = forceAllowInsecureDecoderComponents;
   }
-
-  /**
-   * Returns the wrapped {@link MediaCrypto}.
-   */
-  public MediaCrypto getWrappedMediaCrypto() {
-    return mediaCrypto;
-  }
-
-  @Override
-  public boolean requiresSecureDecoderComponent(String mimeType) {
-    return !forceAllowInsecureDecoderComponents
-        && mediaCrypto.requiresSecureDecoderComponent(mimeType);
-  }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index d2a5b6a0d6..615aa0e7b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -18,20 +18,24 @@
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.media.DeniedByServerException;
-import android.media.MediaCrypto;
 import android.media.MediaCryptoException;
 import android.media.MediaDrm;
 import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
 import android.media.UnsupportedSchemeException;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -45,6 +49,10 @@
 public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto> {
 
   private static final String CENC_SCHEME_MIME_TYPE = "cenc";
+  private static final String MOCK_LA_URL_VALUE = "https://x";
+  private static final String MOCK_LA_URL = "<LA_URL>" + MOCK_LA_URL_VALUE + "</LA_URL>";
+  private static final int UTF_16_BYTES_PER_CHARACTER = 2;
+  private static final String TAG = "FrameworkMediaDrm";
 
   private final UUID uuid;
   private final MediaDrm mediaDrm;
@@ -76,6 +84,8 @@ private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
     }
   }
 
+  // FIXME: incompatible types in argument.
+  @SuppressWarnings("nullness:argument.type.incompatible")
   @Override
   public void setOnEventListener(
       final ExoMediaDrm.OnEventListener<? super FrameworkMediaCrypto> listener) {
@@ -129,7 +139,7 @@ public KeyRequest getKeyRequest(
     String mimeType = null;
     if (schemeDatas != null) {
       schemeData = getSchemeData(uuid, schemeDatas);
-      initData = adjustRequestInitData(uuid, schemeData.data);
+      initData = adjustRequestInitData(uuid, Assertions.checkNotNull(schemeData.data));
       mimeType = adjustRequestMimeType(uuid, schemeData.mimeType);
     }
     MediaDrm.KeyRequest request =
@@ -138,6 +148,9 @@ public KeyRequest getKeyRequest(
     byte[] requestData = adjustRequestData(uuid, request.getData());
 
     String licenseServerUrl = request.getDefaultUrl();
+    if (MOCK_LA_URL_VALUE.equals(licenseServerUrl)) {
+      licenseServerUrl = "";
+    }
     if (TextUtils.isEmpty(licenseServerUrl)
         && schemeData != null
         && !TextUtils.isEmpty(schemeData.licenseServerUrl)) {
@@ -147,6 +160,8 @@ public KeyRequest getKeyRequest(
     return new KeyRequest(requestData, licenseServerUrl);
   }
 
+  // FIXME: incompatible types in return.
+  @SuppressWarnings("nullness:return.type.incompatible")
   @Override
   public byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException {
@@ -210,7 +225,7 @@ public FrameworkMediaCrypto createMediaCrypto(byte[] initData) throws MediaCrypt
     boolean forceAllowInsecureDecoderComponents = Util.SDK_INT < 21
         && C.WIDEVINE_UUID.equals(uuid) && "L3".equals(getPropertyString("securityLevel"));
     return new FrameworkMediaCrypto(
-        new MediaCrypto(adjustUuid(uuid), initData), forceAllowInsecureDecoderComponents);
+        adjustUuid(uuid), initData, forceAllowInsecureDecoderComponents);
   }
 
   private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas) {
@@ -226,11 +241,12 @@ private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas)
       boolean canConcatenateData = true;
       for (int i = 0; i < schemeDatas.size(); i++) {
         SchemeData schemeData = schemeDatas.get(i);
+        byte[] schemeDataData = Util.castNonNull(schemeData.data);
         if (schemeData.requiresSecureDecryption == firstSchemeData.requiresSecureDecryption
             && Util.areEqual(schemeData.mimeType, firstSchemeData.mimeType)
             && Util.areEqual(schemeData.licenseServerUrl, firstSchemeData.licenseServerUrl)
-            && PsshAtomUtil.isPsshAtom(schemeData.data)) {
-          concatenatedDataLength += schemeData.data.length;
+            && PsshAtomUtil.isPsshAtom(schemeDataData)) {
+          concatenatedDataLength += schemeDataData.length;
         } else {
           canConcatenateData = false;
           break;
@@ -241,9 +257,10 @@ private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas)
         int concatenatedDataPosition = 0;
         for (int i = 0; i < schemeDatas.size(); i++) {
           SchemeData schemeData = schemeDatas.get(i);
-          int schemeDataLength = schemeData.data.length;
+          byte[] schemeDataData = Util.castNonNull(schemeData.data);
+          int schemeDataLength = schemeDataData.length;
           System.arraycopy(
-              schemeData.data, 0, concatenatedData, concatenatedDataPosition, schemeDataLength);
+              schemeDataData, 0, concatenatedData, concatenatedDataPosition, schemeDataLength);
           concatenatedDataPosition += schemeDataLength;
         }
         return firstSchemeData.copyWithData(concatenatedData);
@@ -254,7 +271,7 @@ private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas)
     // the first V0 box.
     for (int i = 0; i < schemeDatas.size(); i++) {
       SchemeData schemeData = schemeDatas.get(i);
-      int version = PsshAtomUtil.parseVersion(schemeData.data);
+      int version = PsshAtomUtil.parseVersion(Util.castNonNull(schemeData.data));
       if (Util.SDK_INT < 23 && version == 0) {
         return schemeData;
       } else if (Util.SDK_INT >= 23 && version == 1) {
@@ -272,6 +289,18 @@ private static UUID adjustUuid(UUID uuid) {
   }
 
   private static byte[] adjustRequestInitData(UUID uuid, byte[] initData) {
+    // TODO: Add API level check once [Internal ref: b/112142048] is fixed.
+    if (C.PLAYREADY_UUID.equals(uuid)) {
+      byte[] schemeSpecificData = PsshAtomUtil.parseSchemeSpecificData(initData, uuid);
+      if (schemeSpecificData == null) {
+        // The init data is not contained in a pssh box.
+        schemeSpecificData = initData;
+      }
+      initData =
+          PsshAtomUtil.buildPsshAtom(
+              C.PLAYREADY_UUID, addLaUrlAttributeIfMissing(schemeSpecificData));
+    }
+
     // Prior to L the Widevine CDM required data to be extracted from the PSSH atom. Some Amazon
     // devices also required data to be extracted from the PSSH atom for PlayReady.
     if ((Util.SDK_INT < 21 && C.WIDEVINE_UUID.equals(uuid))
@@ -319,4 +348,47 @@ private static void forceWidevineL3(MediaDrm mediaDrm) {
   private static boolean needsForceWidevineL3Workaround() {
     return "ASUS_Z00AD".equals(Util.MODEL);
   }
+
+  /**
+   * If the LA_URL tag is missing, injects a mock LA_URL value to avoid causing the CDM to throw
+   * when creating the key request. The LA_URL attribute is optional but some Android PlayReady
+   * implementations are known to require it. Does nothing it the provided {@code data} already
+   * contains an LA_URL value.
+   */
+  private static byte[] addLaUrlAttributeIfMissing(byte[] data) {
+    ParsableByteArray byteArray = new ParsableByteArray(data);
+    // See https://docs.microsoft.com/en-us/playready/specifications/specifications for more
+    // information about the init data format.
+    int length = byteArray.readLittleEndianInt();
+    int objectRecordCount = byteArray.readLittleEndianShort();
+    int recordType = byteArray.readLittleEndianShort();
+    if (objectRecordCount != 1 || recordType != 1) {
+      Log.i(TAG, "Unexpected record count or type. Skipping LA_URL workaround.");
+      return data;
+    }
+    int recordLength = byteArray.readLittleEndianShort();
+    String xml = byteArray.readString(recordLength, Charset.forName(C.UTF16LE_NAME));
+    if (xml.contains("<LA_URL>")) {
+      // LA_URL already present. Do nothing.
+      return data;
+    }
+    // This PlayReady object record does not include an LA_URL. We add a mock value for it.
+    int endOfDataTagIndex = xml.indexOf("</DATA>");
+    if (endOfDataTagIndex == -1) {
+      Log.w(TAG, "Could not find the </DATA> tag. Skipping LA_URL workaround.");
+    }
+    String xmlWithMockLaUrl =
+        xml.substring(/* beginIndex= */ 0, /* endIndex= */ endOfDataTagIndex)
+            + MOCK_LA_URL
+            + xml.substring(/* beginIndex= */ endOfDataTagIndex);
+    int extraBytes = MOCK_LA_URL.length() * UTF_16_BYTES_PER_CHARACTER;
+    ByteBuffer newData = ByteBuffer.allocate(length + extraBytes);
+    newData.order(ByteOrder.LITTLE_ENDIAN);
+    newData.putInt(length + extraBytes);
+    newData.putShort((short) objectRecordCount);
+    newData.putShort((short) recordType);
+    newData.putShort((short) (xmlWithMockLaUrl.length() * UTF_16_BYTES_PER_CHARACTER));
+    newData.put(xmlWithMockLaUrl.getBytes(Charset.forName(C.UTF16LE_NAME)));
+    return newData.array();
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
index 8b8c3bec99..a3e602e404 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
@@ -17,6 +17,7 @@
 
 import android.annotation.TargetApi;
 import android.net.Uri;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
@@ -135,8 +136,12 @@ public void clearAllKeyRequestProperties() {
     return executePost(dataSourceFactory, url, request.getData(), requestProperties);
   }
 
-  private static byte[] executePost(HttpDataSource.Factory dataSourceFactory, String url,
-      byte[] data, Map<String, String> requestProperties) throws IOException {
+  private static byte[] executePost(
+      HttpDataSource.Factory dataSourceFactory,
+      String url,
+      byte[] data,
+      @Nullable Map<String, String> requestProperties)
+      throws IOException {
     HttpDataSource dataSource = dataSourceFactory.createDataSource();
     if (requestProperties != null) {
       for (Map.Entry<String, String> requestProperty : requestProperties.entrySet()) {
@@ -164,17 +169,18 @@ public void clearAllKeyRequestProperties() {
         boolean manuallyRedirect =
             (e.responseCode == 307 || e.responseCode == 308)
                 && manualRedirectCount++ < MAX_MANUAL_REDIRECTS;
-        url = manuallyRedirect ? getRedirectUrl(e) : null;
-        if (url == null) {
+        String redirectUrl = manuallyRedirect ? getRedirectUrl(e) : null;
+        if (redirectUrl == null) {
           throw e;
         }
+        url = redirectUrl;
       } finally {
         Util.closeQuietly(inputStream);
       }
     }
   }
 
-  private static String getRedirectUrl(InvalidResponseCodeException exception) {
+  private static @Nullable String getRedirectUrl(InvalidResponseCodeException exception) {
     Map<String, List<String>> headerFields = exception.headerFields;
     if (headerFields != null) {
       List<String> locationHeaders = headerFields.get("Location");
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
index 9298c16cb0..55a7a901ac 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -19,6 +19,7 @@
 import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.HandlerThread;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.Mode;
@@ -34,6 +35,8 @@
  */
 public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
 
+  private static final DrmInitData DUMMY_DRM_INIT_DATA = new DrmInitData();
+
   private final ConditionVariable conditionVariable;
   private final DefaultDrmSessionManager<T> drmSessionManager;
   private final HandlerThread handlerThread;
@@ -89,13 +92,13 @@
    * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
    *     instantiated.
    * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
-   *     MediaDrmCallback, HashMap, Handler, DefaultDrmSessionEventListener)
+   *     MediaDrmCallback, HashMap)
    */
   public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
       String defaultLicenseUrl,
       boolean forceDefaultLicenseUrl,
       Factory httpDataSourceFactory,
-      HashMap<String, String> optionalKeyRequestParameters)
+      @Nullable HashMap<String, String> optionalKeyRequestParameters)
       throws UnsupportedDrmException {
     return new OfflineLicenseHelper<>(C.WIDEVINE_UUID,
         FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID),
@@ -112,13 +115,13 @@
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
    *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
    * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
-   *     MediaDrmCallback, HashMap, Handler, DefaultDrmSessionEventListener)
+   *     MediaDrmCallback, HashMap)
    */
   public OfflineLicenseHelper(
       UUID uuid,
       ExoMediaDrm<T> mediaDrm,
       MediaDrmCallback callback,
-      HashMap<String, String> optionalKeyRequestParameters) {
+      @Nullable HashMap<String, String> optionalKeyRequestParameters) {
     handlerThread = new HandlerThread("OfflineLicenseHelper");
     handlerThread.start();
     conditionVariable = new ConditionVariable();
@@ -199,7 +202,8 @@ public synchronized void setPropertyString(String key, String value) {
   public synchronized byte[] renewLicense(byte[] offlineLicenseKeySetId)
       throws DrmSessionException {
     Assertions.checkNotNull(offlineLicenseKeySetId);
-    return blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, offlineLicenseKeySetId, null);
+    return blockingKeyRequest(
+        DefaultDrmSessionManager.MODE_DOWNLOAD, offlineLicenseKeySetId, DUMMY_DRM_INIT_DATA);
   }
 
   /**
@@ -211,7 +215,8 @@ public synchronized void setPropertyString(String key, String value) {
   public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)
       throws DrmSessionException {
     Assertions.checkNotNull(offlineLicenseKeySetId);
-    blockingKeyRequest(DefaultDrmSessionManager.MODE_RELEASE, offlineLicenseKeySetId, null);
+    blockingKeyRequest(
+        DefaultDrmSessionManager.MODE_RELEASE, offlineLicenseKeySetId, DUMMY_DRM_INIT_DATA);
   }
 
   /**
@@ -224,8 +229,9 @@ public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)
   public synchronized Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)
       throws DrmSessionException {
     Assertions.checkNotNull(offlineLicenseKeySetId);
-    DrmSession<T> drmSession = openBlockingKeyRequest(DefaultDrmSessionManager.MODE_QUERY,
-        offlineLicenseKeySetId, null);
+    DrmSession<T> drmSession =
+        openBlockingKeyRequest(
+            DefaultDrmSessionManager.MODE_QUERY, offlineLicenseKeySetId, DUMMY_DRM_INIT_DATA);
     DrmSessionException error = drmSession.getError();
     Pair<Long, Long> licenseDurationRemainingSec =
         WidevineUtil.getLicenseDurationRemainingSec(drmSession);
@@ -236,7 +242,7 @@ public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)
       }
       throw error;
     }
-    return licenseDurationRemainingSec;
+    return Assertions.checkNotNull(licenseDurationRemainingSec);
   }
 
   /**
@@ -246,8 +252,9 @@ public void release() {
     handlerThread.quit();
   }
 
-  private byte[] blockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
-      DrmInitData drmInitData) throws DrmSessionException {
+  private byte[] blockingKeyRequest(
+      @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, DrmInitData drmInitData)
+      throws DrmSessionException {
     DrmSession<T> drmSession = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId,
         drmInitData);
     DrmSessionException error = drmSession.getError();
@@ -256,11 +263,11 @@ public void release() {
     if (error != null) {
       throw error;
     }
-    return keySetId;
+    return Assertions.checkNotNull(keySetId);
   }
 
-  private DrmSession<T> openBlockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
-      DrmInitData drmInitData) {
+  private DrmSession<T> openBlockingKeyRequest(
+      @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, DrmInitData drmInitData) {
     drmSessionManager.setMode(licenseMode, offlineLicenseKeySetId);
     conditionVariable.close();
     DrmSession<T> drmSession = drmSessionManager.acquireSession(handlerThread.getLooper(),
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
index 7f4a0f5f03..a89196dc04 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.drm;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
index 45c38b3609..9fed3b38e8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import java.util.Map;
@@ -38,7 +39,8 @@ private WidevineUtil() {}
    * @return A {@link Pair} consisting of the remaining license and playback durations in seconds,
    *     or null if called before the session has been opened or after it's been released.
    */
-  public static Pair<Long, Long> getLicenseDurationRemainingSec(DrmSession<?> drmSession) {
+  public static @Nullable Pair<Long, Long> getLicenseDurationRemainingSec(
+      DrmSession<?> drmSession) {
     Map<String, String> keyStatus = drmSession.queryKeyStatus();
     if (keyStatus == null) {
       return null;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
index e8b6e736ba..06d3ed603e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -69,8 +69,9 @@ default void onSeekFinished() {}
    */
   public static final class OutputFrameHolder {
 
+    public final ByteBuffer byteBuffer;
+
     public long timeUs;
-    public ByteBuffer byteBuffer;
 
     /** Constructs an instance, wrapping the given byte buffer. */
     public OutputFrameHolder(ByteBuffer outputByteBuffer) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
index 54bb617c58..54c78eb33d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
 import com.google.android.exoplayer2.extractor.ogg.OggExtractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.Ac4Extractor;
 import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
 import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory;
 import com.google.android.exoplayer2.extractor.ts.PsExtractor;
@@ -47,6 +48,7 @@
  *   <li>FLV ({@link FlvExtractor})
  *   <li>WAV ({@link WavExtractor})
  *   <li>AC3 ({@link Ac3Extractor})
+ *   <li>AC4 ({@link Ac4Extractor})
  *   <li>AMR ({@link AmrExtractor})
  *   <li>FLAC (only available if the FLAC extension is built and included)
  * </ul>
@@ -206,7 +208,7 @@ public synchronized DefaultExtractorsFactory setTsExtractorFlags(
 
   @Override
   public synchronized Extractor[] createExtractors() {
-    Extractor[] extractors = new Extractor[FLAC_EXTRACTOR_CONSTRUCTOR == null ? 12 : 13];
+    Extractor[] extractors = new Extractor[FLAC_EXTRACTOR_CONSTRUCTOR == null ? 13 : 14];
     extractors[0] = new MatroskaExtractor(matroskaFlags);
     extractors[1] = new FragmentedMp4Extractor(fragmentedMp4Flags);
     extractors[2] = new Mp4Extractor(mp4Flags);
@@ -235,9 +237,10 @@ public synchronized DefaultExtractorsFactory setTsExtractorFlags(
                 | (constantBitrateSeekingEnabled
                     ? AmrExtractor.FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
                     : 0));
+    extractors[12] = new Ac4Extractor();
     if (FLAC_EXTRACTOR_CONSTRUCTOR != null) {
       try {
-        extractors[12] = FLAC_EXTRACTOR_CONSTRUCTOR.newInstance();
+        extractors[13] = FLAC_EXTRACTOR_CONSTRUCTOR.newInstance();
       } catch (Exception e) {
         // Should never happen.
         throw new IllegalStateException("Unexpected error creating FLAC extractor", e);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
index 9eaf0f7ef7..f1aeccacb7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.ParsableByteArray;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 05f5d98d3c..083f31bcc3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 import java.lang.annotation.Documented;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Id3Peeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Id3Peeker.java
index 8dbcfafaf2..255799c026 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Id3Peeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Id3Peeker.java
@@ -16,7 +16,7 @@
 
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.util.ParsableByteArray;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
index b7aaa2a31b..0cb55dffa5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java
index 8b920bc024..182db85c9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /** Defines a seek point in a media stream. */
 public final class SeekPoint {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
index 7b832eb400..d7a1c75302 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.ParsableByteArray;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
index b93969acfe..caf12948ad 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.amr;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 4211cab489..0a2c0c46f6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
index 0987bc473f..b5da6dbf2f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -52,7 +52,7 @@
   private final ArrayDeque<MasterElement> masterElementsStack;
   private final VarintReader varintReader;
 
-  private EbmlReaderOutput output;
+  private EbmlProcessor processor;
   private @ElementState int elementState;
   private int elementId;
   private long elementContentSize;
@@ -64,8 +64,8 @@ public DefaultEbmlReader() {
   }
 
   @Override
-  public void init(EbmlReaderOutput eventHandler) {
-    this.output = eventHandler;
+  public void init(EbmlProcessor processor) {
+    this.processor = processor;
   }
 
   @Override
@@ -77,11 +77,11 @@ public void reset() {
 
   @Override
   public boolean read(ExtractorInput input) throws IOException, InterruptedException {
-    Assertions.checkState(output != null);
+    Assertions.checkNotNull(processor);
     while (true) {
       if (!masterElementsStack.isEmpty()
           && input.getPosition() >= masterElementsStack.peek().elementEndPosition) {
-        output.endMasterElement(masterElementsStack.pop().elementId);
+        processor.endMasterElement(masterElementsStack.pop().elementId);
         return true;
       }
 
@@ -103,42 +103,42 @@ public boolean read(ExtractorInput input) throws IOException, InterruptedExcepti
         elementState = ELEMENT_STATE_READ_CONTENT;
       }
 
-      @EbmlReaderOutput.ElementType int type = output.getElementType(elementId);
+      @EbmlProcessor.ElementType int type = processor.getElementType(elementId);
       switch (type) {
-        case EbmlReaderOutput.TYPE_MASTER:
+        case EbmlProcessor.ELEMENT_TYPE_MASTER:
           long elementContentPosition = input.getPosition();
           long elementEndPosition = elementContentPosition + elementContentSize;
           masterElementsStack.push(new MasterElement(elementId, elementEndPosition));
-          output.startMasterElement(elementId, elementContentPosition, elementContentSize);
+          processor.startMasterElement(elementId, elementContentPosition, elementContentSize);
           elementState = ELEMENT_STATE_READ_ID;
           return true;
-        case EbmlReaderOutput.TYPE_UNSIGNED_INT:
+        case EbmlProcessor.ELEMENT_TYPE_UNSIGNED_INT:
           if (elementContentSize > MAX_INTEGER_ELEMENT_SIZE_BYTES) {
             throw new ParserException("Invalid integer size: " + elementContentSize);
           }
-          output.integerElement(elementId, readInteger(input, (int) elementContentSize));
+          processor.integerElement(elementId, readInteger(input, (int) elementContentSize));
           elementState = ELEMENT_STATE_READ_ID;
           return true;
-        case EbmlReaderOutput.TYPE_FLOAT:
+        case EbmlProcessor.ELEMENT_TYPE_FLOAT:
           if (elementContentSize != VALID_FLOAT32_ELEMENT_SIZE_BYTES
               && elementContentSize != VALID_FLOAT64_ELEMENT_SIZE_BYTES) {
             throw new ParserException("Invalid float size: " + elementContentSize);
           }
-          output.floatElement(elementId, readFloat(input, (int) elementContentSize));
+          processor.floatElement(elementId, readFloat(input, (int) elementContentSize));
           elementState = ELEMENT_STATE_READ_ID;
           return true;
-        case EbmlReaderOutput.TYPE_STRING:
+        case EbmlProcessor.ELEMENT_TYPE_STRING:
           if (elementContentSize > Integer.MAX_VALUE) {
             throw new ParserException("String element size: " + elementContentSize);
           }
-          output.stringElement(elementId, readString(input, (int) elementContentSize));
+          processor.stringElement(elementId, readString(input, (int) elementContentSize));
           elementState = ELEMENT_STATE_READ_ID;
           return true;
-        case EbmlReaderOutput.TYPE_BINARY:
-          output.binaryElement(elementId, (int) elementContentSize, input);
+        case EbmlProcessor.ELEMENT_TYPE_BINARY:
+          processor.binaryElement(elementId, (int) elementContentSize, input);
           elementState = ELEMENT_STATE_READ_ID;
           return true;
-        case EbmlReaderOutput.TYPE_UNKNOWN:
+        case EbmlProcessor.ELEMENT_TYPE_UNKNOWN:
           input.skipFully((int) elementContentSize);
           elementState = ELEMENT_STATE_READ_ID;
           break;
@@ -167,7 +167,7 @@ private long maybeResyncToNextLevel1Element(ExtractorInput input) throws IOExcep
       int varintLength = VarintReader.parseUnsignedVarintLength(scratch[0]);
       if (varintLength != C.LENGTH_UNSET && varintLength <= MAX_ID_BYTES) {
         int potentialId = (int) VarintReader.assembleVarint(scratch, varintLength, false);
-        if (output.isLevel1Element(potentialId)) {
+        if (processor.isLevel1Element(potentialId)) {
           input.skipFully(varintLength);
           return potentialId;
         }
@@ -243,7 +243,7 @@ private String readString(ExtractorInput input, int byteLength)
 
   /**
    * Used in {@link #masterElementsStack} to track when the current master element ends, so that
-   * {@link EbmlReaderOutput#endMasterElement(int)} can be called.
+   * {@link EbmlProcessor#endMasterElement(int)} can be called.
    */
   private static final class MasterElement {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlProcessor.java
similarity index 79%
rename from library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
rename to library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlProcessor.java
index cc17af5632..01fe5ff984 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlProcessor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2019 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import java.io.IOException;
@@ -23,41 +23,48 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
-/**
- * Defines EBML element IDs/types and reacts to events.
- */
-/* package */ interface EbmlReaderOutput {
+/** Defines EBML element IDs/types and processes events. */
+public interface EbmlProcessor {
 
   /**
-   * EBML element types. One of {@link #TYPE_UNKNOWN}, {@link #TYPE_MASTER}, {@link
-   * #TYPE_UNSIGNED_INT}, {@link #TYPE_STRING}, {@link #TYPE_BINARY} or {@link #TYPE_FLOAT}.
+   * EBML element types. One of {@link #ELEMENT_TYPE_UNKNOWN}, {@link #ELEMENT_TYPE_MASTER}, {@link
+   * #ELEMENT_TYPE_UNSIGNED_INT}, {@link #ELEMENT_TYPE_STRING}, {@link #ELEMENT_TYPE_BINARY} or
+   * {@link #ELEMENT_TYPE_FLOAT}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TYPE_UNKNOWN, TYPE_MASTER, TYPE_UNSIGNED_INT, TYPE_STRING, TYPE_BINARY, TYPE_FLOAT})
+  @IntDef({
+    ELEMENT_TYPE_UNKNOWN,
+    ELEMENT_TYPE_MASTER,
+    ELEMENT_TYPE_UNSIGNED_INT,
+    ELEMENT_TYPE_STRING,
+    ELEMENT_TYPE_BINARY,
+    ELEMENT_TYPE_FLOAT
+  })
   @interface ElementType {}
   /** Type for unknown elements. */
-  int TYPE_UNKNOWN = 0;
+  int ELEMENT_TYPE_UNKNOWN = 0;
   /** Type for elements that contain child elements. */
-  int TYPE_MASTER = 1;
+  int ELEMENT_TYPE_MASTER = 1;
   /** Type for integer value elements of up to 8 bytes. */
-  int TYPE_UNSIGNED_INT = 2;
+  int ELEMENT_TYPE_UNSIGNED_INT = 2;
   /** Type for string elements. */
-  int TYPE_STRING = 3;
+  int ELEMENT_TYPE_STRING = 3;
   /** Type for binary elements. */
-  int TYPE_BINARY = 4;
+  int ELEMENT_TYPE_BINARY = 4;
   /** Type for IEEE floating point value elements of either 4 or 8 bytes. */
-  int TYPE_FLOAT = 5;
+  int ELEMENT_TYPE_FLOAT = 5;
 
   /**
    * Maps an element ID to a corresponding type.
    *
-   * <p>If {@link #TYPE_UNKNOWN} is returned then the element is skipped. Note that all children of
-   * a skipped element are also skipped.
+   * <p>If {@link #ELEMENT_TYPE_UNKNOWN} is returned then the element is skipped. Note that all
+   * children of a skipped element are also skipped.
    *
    * @param id The element ID to map.
-   * @return One of {@link #TYPE_UNKNOWN}, {@link #TYPE_MASTER}, {@link #TYPE_UNSIGNED_INT}, {@link
-   *     #TYPE_STRING}, {@link #TYPE_BINARY} and {@link #TYPE_FLOAT}.
+   * @return One of {@link #ELEMENT_TYPE_UNKNOWN}, {@link #ELEMENT_TYPE_MASTER}, {@link
+   *     #ELEMENT_TYPE_UNSIGNED_INT}, {@link #ELEMENT_TYPE_STRING}, {@link #ELEMENT_TYPE_BINARY} and
+   *     {@link #ELEMENT_TYPE_FLOAT}.
    */
   @ElementType
   int getElementType(int id);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReader.java
index 9987b3c8e6..c3f00a222f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReader.java
@@ -20,20 +20,20 @@
 import java.io.IOException;
 
 /**
- * Event-driven EBML reader that delivers events to an {@link EbmlReaderOutput}.
- * <p>
- * EBML can be summarized as a binary XML format somewhat similar to Protocol Buffers. It was
- * originally designed for the Matroska container format. More information about EBML and
- * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
+ * Event-driven EBML reader that delivers events to an {@link EbmlProcessor}.
+ *
+ * <p>EBML can be summarized as a binary XML format somewhat similar to Protocol Buffers. It was
+ * originally designed for the Matroska container format. More information about EBML and Matroska
+ * is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
  */
 /* package */ interface EbmlReader {
 
   /**
-   * Initializes the extractor with an {@link EbmlReaderOutput}.
+   * Initializes the extractor with an {@link EbmlProcessor}.
    *
-   * @param output An {@link EbmlReaderOutput} to receive events.
+   * @param processor An {@link EbmlProcessor} to process events.
    */
-  void init(EbmlReaderOutput output);
+  void init(EbmlProcessor processor);
 
   /**
    * Resets the state of the reader.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 86b750e821..c785865f6a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -15,8 +15,9 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.CallSuper;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
@@ -57,10 +58,8 @@
 import java.util.Locale;
 import java.util.UUID;
 
-/**
- * Extracts data from the Matroska and WebM container formats.
- */
-public final class MatroskaExtractor implements Extractor {
+/** Extracts data from the Matroska and WebM container formats. */
+public class MatroskaExtractor implements Extractor {
 
   /** Factory for {@link MatroskaExtractor} instances. */
   public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new MatroskaExtractor()};
@@ -97,6 +96,7 @@
   private static final String DOC_TYPE_WEBM = "webm";
   private static final String CODEC_ID_VP8 = "V_VP8";
   private static final String CODEC_ID_VP9 = "V_VP9";
+  private static final String CODEC_ID_AV1 = "V_AV1";
   private static final String CODEC_ID_MPEG2 = "V_MPEG2";
   private static final String CODEC_ID_MPEG4_SP = "V_MPEG4/ISO/SP";
   private static final String CODEC_ID_MPEG4_ASP = "V_MPEG4/ISO/ASP";
@@ -191,7 +191,11 @@
   private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
   private static final int ID_LANGUAGE = 0x22B59C;
   private static final int ID_PROJECTION = 0x7670;
+  private static final int ID_PROJECTION_TYPE = 0x7671;
   private static final int ID_PROJECTION_PRIVATE = 0x7672;
+  private static final int ID_PROJECTION_POSE_YAW = 0x7673;
+  private static final int ID_PROJECTION_POSE_PITCH = 0x7674;
+  private static final int ID_PROJECTION_POSE_ROLL = 0x7675;
   private static final int ID_STEREO_MODE = 0x53B8;
   private static final int ID_COLOUR = 0x55B0;
   private static final int ID_COLOUR_RANGE = 0x55B9;
@@ -216,8 +220,9 @@
   private static final int LACING_FIXED_SIZE = 2;
   private static final int LACING_EBML = 3;
 
-  private static final int FOURCC_COMPRESSION_VC1 = 0x31435657;
   private static final int FOURCC_COMPRESSION_DIVX = 0x58564944;
+  private static final int FOURCC_COMPRESSION_H263 = 0x33363248;
+  private static final int FOURCC_COMPRESSION_VC1 = 0x31435657;
 
   /**
    * A template for the prefix that must be added to each subrip sample. The 12 byte end timecode
@@ -383,7 +388,7 @@ public MatroskaExtractor(@Flags int flags) {
 
   /* package */ MatroskaExtractor(EbmlReader reader, @Flags int flags) {
     this.reader = reader;
-    this.reader.init(new InnerEbmlReaderOutput());
+    this.reader.init(new InnerEbmlProcessor());
     seekForCuesEnabled = (flags & FLAG_DISABLE_SEEK_FOR_CUES) == 0;
     varintReader = new VarintReader();
     tracks = new SparseArray<>();
@@ -399,15 +404,16 @@ public MatroskaExtractor(@Flags int flags) {
   }
 
   @Override
-  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+  public final boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     return new Sniffer().sniff(input);
   }
 
   @Override
-  public void init(ExtractorOutput output) {
+  public final void init(ExtractorOutput output) {
     extractorOutput = output;
   }
 
+  @CallSuper
   @Override
   public void seek(long position, long timeUs) {
     clusterTimecodeUs = C.TIME_UNSET;
@@ -421,13 +427,13 @@ public void seek(long position, long timeUs) {
   }
 
   @Override
-  public void release() {
+  public final void release() {
     // Do nothing
   }
 
   @Override
-  public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException,
-      InterruptedException {
+  public final int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
     sampleRead = false;
     boolean continueReading = true;
     while (continueReading && !sampleRead) {
@@ -445,7 +451,125 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
     return Extractor.RESULT_CONTINUE;
   }
 
-  /* package */ void startMasterElement(int id, long contentPosition, long contentSize)
+  /**
+   * Maps an element ID to a corresponding type.
+   *
+   * @see EbmlProcessor#getElementType(int)
+   */
+  @CallSuper
+  @EbmlProcessor.ElementType
+  protected int getElementType(int id) {
+    switch (id) {
+      case ID_EBML:
+      case ID_SEGMENT:
+      case ID_SEEK_HEAD:
+      case ID_SEEK:
+      case ID_INFO:
+      case ID_CLUSTER:
+      case ID_TRACKS:
+      case ID_TRACK_ENTRY:
+      case ID_AUDIO:
+      case ID_VIDEO:
+      case ID_CONTENT_ENCODINGS:
+      case ID_CONTENT_ENCODING:
+      case ID_CONTENT_COMPRESSION:
+      case ID_CONTENT_ENCRYPTION:
+      case ID_CONTENT_ENCRYPTION_AES_SETTINGS:
+      case ID_CUES:
+      case ID_CUE_POINT:
+      case ID_CUE_TRACK_POSITIONS:
+      case ID_BLOCK_GROUP:
+      case ID_PROJECTION:
+      case ID_COLOUR:
+      case ID_MASTERING_METADATA:
+        return EbmlProcessor.ELEMENT_TYPE_MASTER;
+      case ID_EBML_READ_VERSION:
+      case ID_DOC_TYPE_READ_VERSION:
+      case ID_SEEK_POSITION:
+      case ID_TIMECODE_SCALE:
+      case ID_TIME_CODE:
+      case ID_BLOCK_DURATION:
+      case ID_PIXEL_WIDTH:
+      case ID_PIXEL_HEIGHT:
+      case ID_DISPLAY_WIDTH:
+      case ID_DISPLAY_HEIGHT:
+      case ID_DISPLAY_UNIT:
+      case ID_TRACK_NUMBER:
+      case ID_TRACK_TYPE:
+      case ID_FLAG_DEFAULT:
+      case ID_FLAG_FORCED:
+      case ID_DEFAULT_DURATION:
+      case ID_CODEC_DELAY:
+      case ID_SEEK_PRE_ROLL:
+      case ID_CHANNELS:
+      case ID_AUDIO_BIT_DEPTH:
+      case ID_CONTENT_ENCODING_ORDER:
+      case ID_CONTENT_ENCODING_SCOPE:
+      case ID_CONTENT_COMPRESSION_ALGORITHM:
+      case ID_CONTENT_ENCRYPTION_ALGORITHM:
+      case ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE:
+      case ID_CUE_TIME:
+      case ID_CUE_CLUSTER_POSITION:
+      case ID_REFERENCE_BLOCK:
+      case ID_STEREO_MODE:
+      case ID_COLOUR_RANGE:
+      case ID_COLOUR_TRANSFER:
+      case ID_COLOUR_PRIMARIES:
+      case ID_MAX_CLL:
+      case ID_MAX_FALL:
+      case ID_PROJECTION_TYPE:
+        return EbmlProcessor.ELEMENT_TYPE_UNSIGNED_INT;
+      case ID_DOC_TYPE:
+      case ID_NAME:
+      case ID_CODEC_ID:
+      case ID_LANGUAGE:
+        return EbmlProcessor.ELEMENT_TYPE_STRING;
+      case ID_SEEK_ID:
+      case ID_CONTENT_COMPRESSION_SETTINGS:
+      case ID_CONTENT_ENCRYPTION_KEY_ID:
+      case ID_SIMPLE_BLOCK:
+      case ID_BLOCK:
+      case ID_CODEC_PRIVATE:
+      case ID_PROJECTION_PRIVATE:
+        return EbmlProcessor.ELEMENT_TYPE_BINARY;
+      case ID_DURATION:
+      case ID_SAMPLING_FREQUENCY:
+      case ID_PRIMARY_R_CHROMATICITY_X:
+      case ID_PRIMARY_R_CHROMATICITY_Y:
+      case ID_PRIMARY_G_CHROMATICITY_X:
+      case ID_PRIMARY_G_CHROMATICITY_Y:
+      case ID_PRIMARY_B_CHROMATICITY_X:
+      case ID_PRIMARY_B_CHROMATICITY_Y:
+      case ID_WHITE_POINT_CHROMATICITY_X:
+      case ID_WHITE_POINT_CHROMATICITY_Y:
+      case ID_LUMNINANCE_MAX:
+      case ID_LUMNINANCE_MIN:
+      case ID_PROJECTION_POSE_YAW:
+      case ID_PROJECTION_POSE_PITCH:
+      case ID_PROJECTION_POSE_ROLL:
+        return EbmlProcessor.ELEMENT_TYPE_FLOAT;
+      default:
+        return EbmlProcessor.ELEMENT_TYPE_UNKNOWN;
+    }
+  }
+
+  /**
+   * Checks if the given id is that of a level 1 element.
+   *
+   * @see EbmlProcessor#isLevel1Element(int)
+   */
+  @CallSuper
+  protected boolean isLevel1Element(int id) {
+    return id == ID_SEGMENT_INFO || id == ID_CLUSTER || id == ID_CUES || id == ID_TRACKS;
+  }
+
+  /**
+   * Called when the start of a master element is encountered.
+   *
+   * @see EbmlProcessor#startMasterElement(int, long, long)
+   */
+  @CallSuper
+  protected void startMasterElement(int id, long contentPosition, long contentSize)
       throws ParserException {
     switch (id) {
       case ID_SEGMENT:
@@ -501,7 +625,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
     }
   }
 
-  /* package */ void endMasterElement(int id) throws ParserException {
+  /**
+   * Called when the end of a master element is encountered.
+   *
+   * @see EbmlProcessor#endMasterElement(int)
+   */
+  @CallSuper
+  protected void endMasterElement(int id) throws ParserException {
     switch (id) {
       case ID_SEGMENT_INFO:
         if (timecodeScale == C.TIME_UNSET) {
@@ -572,7 +702,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
     }
   }
 
-  /* package */ void integerElement(int id, long value) throws ParserException {
+  /**
+   * Called when an integer element is encountered.
+   *
+   * @see EbmlProcessor#integerElement(int, long)
+   */
+  @CallSuper
+  protected void integerElement(int id, long value) throws ParserException {
     switch (id) {
       case ID_EBML_READ_VERSION:
         // Validate that EBMLReadVersion is supported. This extractor only supports v1.
@@ -760,12 +896,36 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_MAX_FALL:
         currentTrack.maxFrameAverageLuminance = (int) value;
         break;
+      case ID_PROJECTION_TYPE:
+        switch ((int) value) {
+          case 0:
+            currentTrack.projectionType = C.PROJECTION_RECTANGULAR;
+            break;
+          case 1:
+            currentTrack.projectionType = C.PROJECTION_EQUIRECTANGULAR;
+            break;
+          case 2:
+            currentTrack.projectionType = C.PROJECTION_CUBEMAP;
+            break;
+          case 3:
+            currentTrack.projectionType = C.PROJECTION_MESH;
+            break;
+          default:
+            break;
+        }
+        break;
       default:
         break;
     }
   }
 
-  /* package */ void floatElement(int id, double value) {
+  /**
+   * Called when a float element is encountered.
+   *
+   * @see EbmlProcessor#floatElement(int, double)
+   */
+  @CallSuper
+  protected void floatElement(int id, double value) throws ParserException {
     switch (id) {
       case ID_DURATION:
         durationTimecode = (long) value;
@@ -803,12 +963,27 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_LUMNINANCE_MIN:
         currentTrack.minMasteringLuminance = (float) value;
         break;
+      case ID_PROJECTION_POSE_YAW:
+        currentTrack.projectionPoseYaw = (float) value;
+        break;
+      case ID_PROJECTION_POSE_PITCH:
+        currentTrack.projectionPosePitch = (float) value;
+        break;
+      case ID_PROJECTION_POSE_ROLL:
+        currentTrack.projectionPoseRoll = (float) value;
+        break;
       default:
         break;
     }
   }
 
-  /* package */ void stringElement(int id, String value) throws ParserException {
+  /**
+   * Called when a string element is encountered.
+   *
+   * @see EbmlProcessor#stringElement(int, String)
+   */
+  @CallSuper
+  protected void stringElement(int id, String value) throws ParserException {
     switch (id) {
       case ID_DOC_TYPE:
         // Validate that DocType is supported.
@@ -830,7 +1005,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
     }
   }
 
-  /* package */ void binaryElement(int id, int contentSize, ExtractorInput input)
+  /**
+   * Called when a binary element is encountered.
+   *
+   * @see EbmlProcessor#binaryElement(int, int, ExtractorInput)
+   */
+  @CallSuper
+  protected void binaryElement(int id, int contentSize, ExtractorInput input)
       throws IOException, InterruptedException {
     switch (id) {
       case ID_SEEK_ID:
@@ -1356,6 +1537,7 @@ private long scaleTimecodeToUs(long unscaledTimecode) throws ParserException {
   private static boolean isCodecSupported(String codecId) {
     return CODEC_ID_VP8.equals(codecId)
         || CODEC_ID_VP9.equals(codecId)
+        || CODEC_ID_AV1.equals(codecId)
         || CODEC_ID_MPEG2.equals(codecId)
         || CODEC_ID_MPEG4_SP.equals(codecId)
         || CODEC_ID_MPEG4_ASP.equals(codecId)
@@ -1400,106 +1582,18 @@ private static boolean isCodecSupported(String codecId) {
     }
   }
 
-  /**
-   * Passes events through to the outer {@link MatroskaExtractor}.
-   */
-  private final class InnerEbmlReaderOutput implements EbmlReaderOutput {
+  /** Passes events through to the outer {@link MatroskaExtractor}. */
+  private final class InnerEbmlProcessor implements EbmlProcessor {
 
     @Override
+    @ElementType
     public int getElementType(int id) {
-      switch (id) {
-        case ID_EBML:
-        case ID_SEGMENT:
-        case ID_SEEK_HEAD:
-        case ID_SEEK:
-        case ID_INFO:
-        case ID_CLUSTER:
-        case ID_TRACKS:
-        case ID_TRACK_ENTRY:
-        case ID_AUDIO:
-        case ID_VIDEO:
-        case ID_CONTENT_ENCODINGS:
-        case ID_CONTENT_ENCODING:
-        case ID_CONTENT_COMPRESSION:
-        case ID_CONTENT_ENCRYPTION:
-        case ID_CONTENT_ENCRYPTION_AES_SETTINGS:
-        case ID_CUES:
-        case ID_CUE_POINT:
-        case ID_CUE_TRACK_POSITIONS:
-        case ID_BLOCK_GROUP:
-        case ID_PROJECTION:
-        case ID_COLOUR:
-        case ID_MASTERING_METADATA:
-          return TYPE_MASTER;
-        case ID_EBML_READ_VERSION:
-        case ID_DOC_TYPE_READ_VERSION:
-        case ID_SEEK_POSITION:
-        case ID_TIMECODE_SCALE:
-        case ID_TIME_CODE:
-        case ID_BLOCK_DURATION:
-        case ID_PIXEL_WIDTH:
-        case ID_PIXEL_HEIGHT:
-        case ID_DISPLAY_WIDTH:
-        case ID_DISPLAY_HEIGHT:
-        case ID_DISPLAY_UNIT:
-        case ID_TRACK_NUMBER:
-        case ID_TRACK_TYPE:
-        case ID_FLAG_DEFAULT:
-        case ID_FLAG_FORCED:
-        case ID_DEFAULT_DURATION:
-        case ID_CODEC_DELAY:
-        case ID_SEEK_PRE_ROLL:
-        case ID_CHANNELS:
-        case ID_AUDIO_BIT_DEPTH:
-        case ID_CONTENT_ENCODING_ORDER:
-        case ID_CONTENT_ENCODING_SCOPE:
-        case ID_CONTENT_COMPRESSION_ALGORITHM:
-        case ID_CONTENT_ENCRYPTION_ALGORITHM:
-        case ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE:
-        case ID_CUE_TIME:
-        case ID_CUE_CLUSTER_POSITION:
-        case ID_REFERENCE_BLOCK:
-        case ID_STEREO_MODE:
-        case ID_COLOUR_RANGE:
-        case ID_COLOUR_TRANSFER:
-        case ID_COLOUR_PRIMARIES:
-        case ID_MAX_CLL:
-        case ID_MAX_FALL:
-          return TYPE_UNSIGNED_INT;
-        case ID_DOC_TYPE:
-        case ID_NAME:
-        case ID_CODEC_ID:
-        case ID_LANGUAGE:
-          return TYPE_STRING;
-        case ID_SEEK_ID:
-        case ID_CONTENT_COMPRESSION_SETTINGS:
-        case ID_CONTENT_ENCRYPTION_KEY_ID:
-        case ID_SIMPLE_BLOCK:
-        case ID_BLOCK:
-        case ID_CODEC_PRIVATE:
-        case ID_PROJECTION_PRIVATE:
-          return TYPE_BINARY;
-        case ID_DURATION:
-        case ID_SAMPLING_FREQUENCY:
-        case ID_PRIMARY_R_CHROMATICITY_X:
-        case ID_PRIMARY_R_CHROMATICITY_Y:
-        case ID_PRIMARY_G_CHROMATICITY_X:
-        case ID_PRIMARY_G_CHROMATICITY_Y:
-        case ID_PRIMARY_B_CHROMATICITY_X:
-        case ID_PRIMARY_B_CHROMATICITY_Y:
-        case ID_WHITE_POINT_CHROMATICITY_X:
-        case ID_WHITE_POINT_CHROMATICITY_Y:
-        case ID_LUMNINANCE_MAX:
-        case ID_LUMNINANCE_MIN:
-          return TYPE_FLOAT;
-        default:
-          return TYPE_UNKNOWN;
-      }
+      return MatroskaExtractor.this.getElementType(id);
     }
 
     @Override
     public boolean isLevel1Element(int id) {
-      return id == ID_SEGMENT_INFO || id == ID_CLUSTER || id == ID_CUES || id == ID_TRACKS;
+      return MatroskaExtractor.this.isLevel1Element(id);
     }
 
     @Override
@@ -1631,6 +1725,10 @@ public void outputPendingSampleMetadata(Track track) {
     public int displayWidth = Format.NO_VALUE;
     public int displayHeight = Format.NO_VALUE;
     public int displayUnit = DISPLAY_UNIT_PIXELS;
+    @C.Projection public int projectionType = Format.NO_VALUE;
+    public float projectionPoseYaw = 0f;
+    public float projectionPosePitch = 0f;
+    public float projectionPoseRoll = 0f;
     public byte[] projectionData = null;
     @C.StereoMode
     public int stereoMode = Format.NO_VALUE;
@@ -1684,6 +1782,9 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
         case CODEC_ID_VP9:
           mimeType = MimeTypes.VIDEO_VP9;
           break;
+        case CODEC_ID_AV1:
+          mimeType = MimeTypes.VIDEO_AV1;
+          break;
         case CODEC_ID_MPEG2:
           mimeType = MimeTypes.VIDEO_MPEG2;
           break;
@@ -1850,6 +1951,21 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
         } else if ("htc_video_rotA-270".equals(name)) {
           rotationDegrees = 270;
         }
+        if (projectionType == C.PROJECTION_RECTANGULAR
+            && Float.compare(projectionPoseYaw, 0f) == 0
+            && Float.compare(projectionPosePitch, 0f) == 0) {
+          // The range of projectionPoseRoll is [-180, 180].
+          if (Float.compare(projectionPoseRoll, 0f) == 0) {
+            rotationDegrees = 0;
+          } else if (Float.compare(projectionPosePitch, 90f) == 0) {
+            rotationDegrees = 90;
+          } else if (Float.compare(projectionPosePitch, -180f) == 0
+              || Float.compare(projectionPosePitch, 180f) == 0) {
+            rotationDegrees = 180;
+          } else if (Float.compare(projectionPosePitch, -90f) == 0) {
+            rotationDegrees = 270;
+          }
+        }
         format =
             Format.createVideoSampleFormat(
                 Integer.toString(trackId),
@@ -1948,8 +2064,6 @@ public void reset() {
     /**
      * Builds initialization data for a {@link Format} from FourCC codec private data.
      *
-     * <p>VC1 and H263 are the only supported compression types.
-     *
      * @return The codec mime type and initialization data. If the compression type is not supported
      *     then the mime type is set to {@link MimeTypes#VIDEO_UNKNOWN} and the initialization data
      *     is {@code null}.
@@ -1961,6 +2075,8 @@ public void reset() {
         buffer.skipBytes(16); // size(4), width(4), height(4), planes(2), bitcount(2).
         long compression = buffer.readLittleEndianUnsignedInt();
         if (compression == FOURCC_COMPRESSION_DIVX) {
+          return new Pair<>(MimeTypes.VIDEO_DIVX, null);
+        } else if (compression == FOURCC_COMPRESSION_H263) {
           return new Pair<>(MimeTypes.VIDEO_H263, null);
         } else if (compression == FOURCC_COMPRESSION_VC1) {
           // Search for the initialization data from the end of the BITMAPINFOHEADER. The last 20
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index e8848bf983..c65ad0bc67 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -341,9 +341,19 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
    */
   private boolean peekEndOfStreamOrHeader(ExtractorInput extractorInput)
       throws IOException, InterruptedException {
-    return (seeker != null && extractorInput.getPeekPosition() == seeker.getDataEndPosition())
-        || !extractorInput.peekFully(
-            scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true);
+    if (seeker != null) {
+      long dataEndPosition = seeker.getDataEndPosition();
+      if (dataEndPosition != C.POSITION_UNSET
+          && extractorInput.getPeekPosition() > dataEndPosition - 4) {
+        return true;
+      }
+    }
+    try {
+      return !extractorInput.peekFully(
+          scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true);
+    } catch (EOFException e) {
+      return true;
+    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
index 15e778115d..ba8b26b7c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.SeekPoint;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
index 42752e55fb..116a123094 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.SeekPoint;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index f51c97389b..f66c1f5d2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
@@ -23,7 +23,7 @@
 import java.util.List;
 
 @SuppressWarnings("ConstantField")
-/* package*/ abstract class Atom {
+/* package */ abstract class Atom {
 
   /**
    * Size of an atom header, in bytes.
@@ -50,104 +50,334 @@
    */
   public static final int EXTENDS_TO_END_SIZE = 0;
 
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ftyp = Util.getIntegerCodeForString("ftyp");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_avc1 = Util.getIntegerCodeForString("avc1");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_avc3 = Util.getIntegerCodeForString("avc3");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_avcC = Util.getIntegerCodeForString("avcC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_hvc1 = Util.getIntegerCodeForString("hvc1");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_hev1 = Util.getIntegerCodeForString("hev1");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_hvcC = Util.getIntegerCodeForString("hvcC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_av01 = Util.getIntegerCodeForString("av01");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_av1C = Util.getIntegerCodeForString("av1C");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dvav = Util.getIntegerCodeForString("dvav");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dva1 = Util.getIntegerCodeForString("dva1");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dvhe = Util.getIntegerCodeForString("dvhe");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dvh1 = Util.getIntegerCodeForString("dvh1");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dvcC = Util.getIntegerCodeForString("dvcC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dvvC = Util.getIntegerCodeForString("dvvC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_s263 = Util.getIntegerCodeForString("s263");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_d263 = Util.getIntegerCodeForString("d263");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE__mp3 = Util.getIntegerCodeForString(".mp3");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_wave = Util.getIntegerCodeForString("wave");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_lpcm = Util.getIntegerCodeForString("lpcm");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sowt = Util.getIntegerCodeForString("sowt");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dac3 = Util.getIntegerCodeForString("dac3");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ec_3 = Util.getIntegerCodeForString("ec-3");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dec3 = Util.getIntegerCodeForString("dec3");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_ac_4 = Util.getIntegerCodeForString("ac-4");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_dac4 = Util.getIntegerCodeForString("dac4");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dtsc = Util.getIntegerCodeForString("dtsc");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dtsh = Util.getIntegerCodeForString("dtsh");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dtsl = Util.getIntegerCodeForString("dtsl");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dtse = Util.getIntegerCodeForString("dtse");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ddts = Util.getIntegerCodeForString("ddts");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_tfdt = Util.getIntegerCodeForString("tfdt");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_tfhd = Util.getIntegerCodeForString("tfhd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_trex = Util.getIntegerCodeForString("trex");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_trun = Util.getIntegerCodeForString("trun");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sidx = Util.getIntegerCodeForString("sidx");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_moov = Util.getIntegerCodeForString("moov");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mvhd = Util.getIntegerCodeForString("mvhd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_trak = Util.getIntegerCodeForString("trak");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mdia = Util.getIntegerCodeForString("mdia");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_minf = Util.getIntegerCodeForString("minf");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stbl = Util.getIntegerCodeForString("stbl");
-  public static final int TYPE_avcC = Util.getIntegerCodeForString("avcC");
-  public static final int TYPE_hvcC = Util.getIntegerCodeForString("hvcC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_esds = Util.getIntegerCodeForString("esds");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_moof = Util.getIntegerCodeForString("moof");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_traf = Util.getIntegerCodeForString("traf");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mvex = Util.getIntegerCodeForString("mvex");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mehd = Util.getIntegerCodeForString("mehd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_tkhd = Util.getIntegerCodeForString("tkhd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_edts = Util.getIntegerCodeForString("edts");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_elst = Util.getIntegerCodeForString("elst");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mdhd = Util.getIntegerCodeForString("mdhd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_hdlr = Util.getIntegerCodeForString("hdlr");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stsd = Util.getIntegerCodeForString("stsd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_pssh = Util.getIntegerCodeForString("pssh");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sinf = Util.getIntegerCodeForString("sinf");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_schm = Util.getIntegerCodeForString("schm");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_schi = Util.getIntegerCodeForString("schi");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_tenc = Util.getIntegerCodeForString("tenc");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_encv = Util.getIntegerCodeForString("encv");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_enca = Util.getIntegerCodeForString("enca");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_frma = Util.getIntegerCodeForString("frma");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_saiz = Util.getIntegerCodeForString("saiz");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_saio = Util.getIntegerCodeForString("saio");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sbgp = Util.getIntegerCodeForString("sbgp");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sgpd = Util.getIntegerCodeForString("sgpd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_uuid = Util.getIntegerCodeForString("uuid");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_senc = Util.getIntegerCodeForString("senc");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_pasp = Util.getIntegerCodeForString("pasp");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_TTML = Util.getIntegerCodeForString("TTML");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_vmhd = Util.getIntegerCodeForString("vmhd");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mp4v = Util.getIntegerCodeForString("mp4v");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stts = Util.getIntegerCodeForString("stts");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stss = Util.getIntegerCodeForString("stss");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ctts = Util.getIntegerCodeForString("ctts");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stsc = Util.getIntegerCodeForString("stsc");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stsz = Util.getIntegerCodeForString("stsz");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stz2 = Util.getIntegerCodeForString("stz2");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stco = Util.getIntegerCodeForString("stco");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_co64 = Util.getIntegerCodeForString("co64");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_tx3g = Util.getIntegerCodeForString("tx3g");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_wvtt = Util.getIntegerCodeForString("wvtt");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_stpp = Util.getIntegerCodeForString("stpp");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_c608 = Util.getIntegerCodeForString("c608");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_samr = Util.getIntegerCodeForString("samr");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sawb = Util.getIntegerCodeForString("sawb");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_udta = Util.getIntegerCodeForString("udta");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+
+  @SuppressWarnings("ConstantCaseForConstants")
+  public static final int TYPE_keys = Util.getIntegerCodeForString("keys");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ilst = Util.getIntegerCodeForString("ilst");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
-  public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
-  public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
-  public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_alaw = Util.getIntegerCodeForString("alaw");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_ulaw = Util.getIntegerCodeForString("ulaw");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_Opus = Util.getIntegerCodeForString("Opus");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dOps = Util.getIntegerCodeForString("dOps");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_fLaC = Util.getIntegerCodeForString("fLaC");
+
+  @SuppressWarnings("ConstantCaseForConstants")
   public static final int TYPE_dfLa = Util.getIntegerCodeForString("dfLa");
 
   public final int type;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index d085156f2b..0185a6d8af 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -17,11 +17,13 @@
 
 import static com.google.android.exoplayer2.util.MimeTypes.getMimeTypeFromMp4ObjectType;
 
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.audio.Ac3Util;
+import com.google.android.exoplayer2.audio.Ac4Util;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
 import com.google.android.exoplayer2.metadata.Metadata;
@@ -32,6 +34,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.AvcConfig;
+import com.google.android.exoplayer2.video.DolbyVisionConfig;
 import com.google.android.exoplayer2.video.HevcConfig;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -39,7 +42,7 @@
 import java.util.List;
 
 /** Utility methods for parsing MP4 format atom payloads according to ISO 14496-12. */
-@SuppressWarnings("ConstantField")
+@SuppressWarnings({"ConstantField", "ConstantCaseForConstants"})
 /* package */ final class AtomParsers {
 
   private static final String TAG = "AtomParsers";
@@ -51,6 +54,7 @@
   private static final int TYPE_subt = Util.getIntegerCodeForString("subt");
   private static final int TYPE_clcp = Util.getIntegerCodeForString("clcp");
   private static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+  private static final int TYPE_mdta = Util.getIntegerCodeForString("mdta");
 
   /**
    * The threshold number of samples to trim from the start/end of an audio track when applying an
@@ -77,7 +81,7 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long
       DrmInitData drmInitData, boolean ignoreEditLists, boolean isQuickTime)
       throws ParserException {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
-    int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
+    int trackType = getTrackTypeForHdlr(parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data));
     if (trackType == C.TRACK_TYPE_UNKNOWN) {
       return null;
     }
@@ -485,6 +489,7 @@ public static TrackSampleTable parseStbl(
    * @param isQuickTime True for QuickTime media. False otherwise.
    * @return Parsed metadata, or null.
    */
+  @Nullable
   public static Metadata parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
     if (isQuickTime) {
       // Meta boxes are regular boxes rather than full boxes in QuickTime. For now, don't try and
@@ -499,14 +504,69 @@ public static Metadata parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
       int atomType = udtaData.readInt();
       if (atomType == Atom.TYPE_meta) {
         udtaData.setPosition(atomPosition);
-        return parseMetaAtom(udtaData, atomPosition + atomSize);
+        return parseUdtaMeta(udtaData, atomPosition + atomSize);
       }
-      udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
+      udtaData.setPosition(atomPosition + atomSize);
     }
     return null;
   }
 
-  private static Metadata parseMetaAtom(ParsableByteArray meta, int limit) {
+  /**
+   * Parses a metadata meta atom if it contains metadata with handler 'mdta'.
+   *
+   * @param meta The metadata atom to decode.
+   * @return Parsed metadata, or null.
+   */
+  @Nullable
+  public static Metadata parseMdtaFromMeta(Atom.ContainerAtom meta) {
+    Atom.LeafAtom hdlrAtom = meta.getLeafAtomOfType(Atom.TYPE_hdlr);
+    Atom.LeafAtom keysAtom = meta.getLeafAtomOfType(Atom.TYPE_keys);
+    Atom.LeafAtom ilstAtom = meta.getLeafAtomOfType(Atom.TYPE_ilst);
+    if (hdlrAtom == null
+        || keysAtom == null
+        || ilstAtom == null
+        || AtomParsers.parseHdlr(hdlrAtom.data) != TYPE_mdta) {
+      // There isn't enough information to parse the metadata, or the handler type is unexpected.
+      return null;
+    }
+
+    // Parse metadata keys.
+    ParsableByteArray keys = keysAtom.data;
+    keys.setPosition(Atom.FULL_HEADER_SIZE);
+    int entryCount = keys.readInt();
+    String[] keyNames = new String[entryCount];
+    for (int i = 0; i < entryCount; i++) {
+      int entrySize = keys.readInt();
+      keys.skipBytes(4); // keyNamespace
+      int keySize = entrySize - 8;
+      keyNames[i] = keys.readString(keySize);
+    }
+
+    // Parse metadata items.
+    ParsableByteArray ilst = ilstAtom.data;
+    ilst.setPosition(Atom.HEADER_SIZE);
+    ArrayList<Metadata.Entry> entries = new ArrayList<>();
+    while (ilst.bytesLeft() > Atom.HEADER_SIZE) {
+      int atomPosition = ilst.getPosition();
+      int atomSize = ilst.readInt();
+      int keyIndex = ilst.readInt() - 1;
+      if (keyIndex >= 0 && keyIndex < keyNames.length) {
+        String key = keyNames[keyIndex];
+        Metadata.Entry entry =
+            MetadataUtil.parseMdtaMetadataEntryFromIlst(ilst, atomPosition + atomSize, key);
+        if (entry != null) {
+          entries.add(entry);
+        }
+      } else {
+        Log.w(TAG, "Skipped metadata with unknown key index: " + keyIndex);
+      }
+      ilst.setPosition(atomPosition + atomSize);
+    }
+    return entries.isEmpty() ? null : new Metadata(entries);
+  }
+
+  @Nullable
+  private static Metadata parseUdtaMeta(ParsableByteArray meta, int limit) {
     meta.skipBytes(Atom.FULL_HEADER_SIZE);
     while (meta.getPosition() < limit) {
       int atomPosition = meta.getPosition();
@@ -516,11 +576,12 @@ private static Metadata parseMetaAtom(ParsableByteArray meta, int limit) {
         meta.setPosition(atomPosition);
         return parseIlst(meta, atomPosition + atomSize);
       }
-      meta.skipBytes(atomSize - Atom.HEADER_SIZE);
+      meta.setPosition(atomPosition + atomSize);
     }
     return null;
   }
 
+  @Nullable
   private static Metadata parseIlst(ParsableByteArray ilst, int limit) {
     ilst.skipBytes(Atom.HEADER_SIZE);
     ArrayList<Metadata.Entry> entries = new ArrayList<>();
@@ -610,19 +671,22 @@ private static TkhdData parseTkhd(ParsableByteArray tkhd) {
    * Parses an hdlr atom.
    *
    * @param hdlr The hdlr atom to decode.
-   * @return The track type.
+   * @return The handler value.
    */
   private static int parseHdlr(ParsableByteArray hdlr) {
     hdlr.setPosition(Atom.FULL_HEADER_SIZE + 4);
-    int trackType = hdlr.readInt();
-    if (trackType == TYPE_soun) {
+    return hdlr.readInt();
+  }
+
+  /** Returns the track type for a given handler value. */
+  private static int getTrackTypeForHdlr(int hdlr) {
+    if (hdlr == TYPE_soun) {
       return C.TRACK_TYPE_AUDIO;
-    } else if (trackType == TYPE_vide) {
+    } else if (hdlr == TYPE_vide) {
       return C.TRACK_TYPE_VIDEO;
-    } else if (trackType == TYPE_text || trackType == TYPE_sbtl || trackType == TYPE_subt
-        || trackType == TYPE_clcp) {
+    } else if (hdlr == TYPE_text || hdlr == TYPE_sbtl || hdlr == TYPE_subt || hdlr == TYPE_clcp) {
       return C.TRACK_TYPE_TEXT;
-    } else if (trackType == TYPE_meta) {
+    } else if (hdlr == TYPE_meta) {
       return C.TRACK_TYPE_METADATA;
     } else {
       return C.TRACK_TYPE_UNKNOWN;
@@ -673,17 +737,27 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
       int childAtomSize = stsd.readInt();
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = stsd.readInt();
-      if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
-          || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v
-          || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1
-          || childAtomType == Atom.TYPE_s263 || childAtomType == Atom.TYPE_vp08
-          || childAtomType == Atom.TYPE_vp09) {
+      if (childAtomType == Atom.TYPE_avc1
+          || childAtomType == Atom.TYPE_avc3
+          || childAtomType == Atom.TYPE_encv
+          || childAtomType == Atom.TYPE_mp4v
+          || childAtomType == Atom.TYPE_hvc1
+          || childAtomType == Atom.TYPE_hev1
+          || childAtomType == Atom.TYPE_s263
+          || childAtomType == Atom.TYPE_vp08
+          || childAtomType == Atom.TYPE_vp09
+          || childAtomType == Atom.TYPE_av01
+          || childAtomType == Atom.TYPE_dvav
+          || childAtomType == Atom.TYPE_dva1
+          || childAtomType == Atom.TYPE_dvhe
+          || childAtomType == Atom.TYPE_dvh1) {
         parseVideoSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             rotationDegrees, drmInitData, out, i);
       } else if (childAtomType == Atom.TYPE_mp4a
           || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3
           || childAtomType == Atom.TYPE_ec_3
+          || childAtomType == Atom.TYPE_ac_4
           || childAtomType == Atom.TYPE_dtsc
           || childAtomType == Atom.TYPE_dtse
           || childAtomType == Atom.TYPE_dtsh
@@ -790,6 +864,7 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
 
     List<byte[]> initializationData = null;
     String mimeType = null;
+    String codecs = null;
     byte[] projectionData = null;
     @C.StereoMode
     int stereoMode = Format.NO_VALUE;
@@ -820,9 +895,19 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
         HevcConfig hevcConfig = HevcConfig.parse(parent);
         initializationData = hevcConfig.initializationData;
         out.nalUnitLengthFieldLength = hevcConfig.nalUnitLengthFieldLength;
+      } else if (childAtomType == Atom.TYPE_dvcC || childAtomType == Atom.TYPE_dvvC) {
+        DolbyVisionConfig dolbyVisionConfig = DolbyVisionConfig.parse(parent);
+        // TODO: Support profiles 4, 8 and 9 once we have a way to fall back to AVC/HEVC decoding.
+        if (dolbyVisionConfig != null && dolbyVisionConfig.profile == 5) {
+          codecs = dolbyVisionConfig.codecs;
+          mimeType = MimeTypes.VIDEO_DOLBY_VISION;
+        }
       } else if (childAtomType == Atom.TYPE_vpcC) {
         Assertions.checkState(mimeType == null);
         mimeType = (atomType == Atom.TYPE_vp08) ? MimeTypes.VIDEO_VP8 : MimeTypes.VIDEO_VP9;
+      } else if (childAtomType == Atom.TYPE_av1C) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_AV1;
       } else if (childAtomType == Atom.TYPE_d263) {
         Assertions.checkState(mimeType == null);
         mimeType = MimeTypes.VIDEO_H263;
@@ -868,9 +953,23 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
       return;
     }
 
-    out.format = Format.createVideoSampleFormat(Integer.toString(trackId), mimeType, null,
-        Format.NO_VALUE, Format.NO_VALUE, width, height, Format.NO_VALUE, initializationData,
-        rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode, null, drmInitData);
+    out.format =
+        Format.createVideoSampleFormat(
+            Integer.toString(trackId),
+            mimeType,
+            codecs,
+            /* bitrate= */ Format.NO_VALUE,
+            /* maxInputSize= */ Format.NO_VALUE,
+            width,
+            height,
+            /* frameRate= */ Format.NO_VALUE,
+            initializationData,
+            rotationDegrees,
+            pixelWidthHeightRatio,
+            projectionData,
+            stereoMode,
+            /* colorInfo= */ null,
+            drmInitData);
   }
 
   /**
@@ -974,6 +1073,8 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_AC3;
     } else if (atomType == Atom.TYPE_ec_3) {
       mimeType = MimeTypes.AUDIO_E_AC3;
+    } else if (atomType == Atom.TYPE_ac_4) {
+      mimeType = MimeTypes.AUDIO_AC4;
     } else if (atomType == Atom.TYPE_dtsc) {
       mimeType = MimeTypes.AUDIO_DTS;
     } else if (atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl) {
@@ -1031,6 +1132,10 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         parent.setPosition(Atom.HEADER_SIZE + childPosition);
         out.format = Ac3Util.parseEAc3AnnexFFormat(parent, Integer.toString(trackId), language,
             drmInitData);
+      } else if (childAtomType == Atom.TYPE_dac4) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
+        out.format =
+            Ac4Util.parseAc4AnnexEFormat(parent, Integer.toString(trackId), language, drmInitData);
       } else if (childAtomType == Atom.TYPE_ddts) {
         out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index 0f1fd8f649..4f45e85762 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.audio.Ac4Util;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
@@ -53,10 +54,8 @@
 import java.util.List;
 import java.util.UUID;
 
-/**
- * Extracts data from the FMP4 container format.
- */
-public final class FragmentedMp4Extractor implements Extractor {
+/** Extracts data from the FMP4 container format. */
+public class FragmentedMp4Extractor implements Extractor {
 
   /** Factory for {@link FragmentedMp4Extractor} instances. */
   public static final ExtractorsFactory FACTORY =
@@ -135,13 +134,14 @@
   private final ParsableByteArray nalStartCode;
   private final ParsableByteArray nalPrefix;
   private final ParsableByteArray nalBuffer;
+  private final byte[] scratchBytes;
+  private final ParsableByteArray scratch;
 
   // Adjusts sample timestamps.
   private final @Nullable TimestampAdjuster timestampAdjuster;
 
   // Parser state.
   private final ParsableByteArray atomHeader;
-  private final byte[] extendedTypeScratch;
   private final ArrayDeque<ContainerAtom> containerAtoms;
   private final ArrayDeque<MetadataSampleInfo> pendingMetadataSampleInfos;
   private final @Nullable TrackOutput additionalEmsgTrackOutput;
@@ -162,6 +162,7 @@
   private int sampleBytesWritten;
   private int sampleCurrentNalBytesRemaining;
   private boolean processSeiNalUnitPayload;
+  private boolean isAc4HeaderRequired;
 
   // Extractor output.
   private ExtractorOutput extractorOutput;
@@ -256,7 +257,8 @@ public FragmentedMp4Extractor(
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalPrefix = new ParsableByteArray(5);
     nalBuffer = new ParsableByteArray();
-    extendedTypeScratch = new byte[16];
+    scratchBytes = new byte[16];
+    scratch = new ParsableByteArray(scratchBytes);
     containerAtoms = new ArrayDeque<>();
     pendingMetadataSampleInfos = new ArrayDeque<>();
     trackBundles = new SparseArray<>();
@@ -293,6 +295,7 @@ public void seek(long position, long timeUs) {
     pendingMetadataSampleBytes = 0;
     pendingSeekTimeUs = timeUs;
     containerAtoms.clear();
+    isAc4HeaderRequired = false;
     enterReadingAtomHeaderState();
   }
 
@@ -486,8 +489,15 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
     for (int i = 0; i < moovContainerChildrenSize; i++) {
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
       if (atom.type == Atom.TYPE_trak) {
-        Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd), duration,
-            drmInitData, (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0, false);
+        Track track =
+            modifyTrack(
+                AtomParsers.parseTrak(
+                    atom,
+                    moov.getLeafAtomOfType(Atom.TYPE_mvhd),
+                    duration,
+                    drmInitData,
+                    (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0,
+                    false));
         if (track != null) {
           tracks.put(track.id, track);
         }
@@ -517,6 +527,11 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
     }
   }
 
+  @Nullable
+  protected Track modifyTrack(@Nullable Track track) {
+    return track;
+  }
+
   private DefaultSampleValues getDefaultSampleValues(
       SparseArray<DefaultSampleValues> defaultSampleValuesArray, int trackId) {
     if (defaultSampleValuesArray.size() == 1) {
@@ -528,7 +543,7 @@ private DefaultSampleValues getDefaultSampleValues(
   }
 
   private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException {
-    parseMoof(moof, trackBundles, flags, extendedTypeScratch);
+    parseMoof(moof, trackBundles, flags, scratchBytes);
     // If drm init data is sideloaded, we ignore pssh boxes.
     DrmInitData drmInitData = sideloadedDrmInitData != null ? null
         : getDrmInitDataFromAtoms(moof.leafChildren);
@@ -591,6 +606,14 @@ private void onEmsgLeafAtomRead(ParsableByteArray atom) {
     long presentationTimeDeltaUs =
         Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
 
+    // The presentation_time_delta is accounted for by adjusting the sample timestamp, so we zero it
+    // in the sample data before writing it to the track outputs.
+    int position = atom.getPosition();
+    atom.data[position - 4] = 0;
+    atom.data[position - 3] = 0;
+    atom.data[position - 2] = 0;
+    atom.data[position - 1] = 0;
+
     // Output the sample data.
     for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
       atom.setPosition(Atom.FULL_HEADER_SIZE);
@@ -1041,7 +1064,7 @@ private static void parseSgpd(ParsableByteArray sbgp, ParsableByteArray sgpd, St
     byte[] keyId = new byte[16];
     sgpd.readBytes(keyId, 0, keyId.length);
     byte[] constantIv = null;
-    if (isProtected && perSampleIvSize == 0) {
+    if (perSampleIvSize == 0) {
       int constantIvSize = sgpd.readUnsignedByte();
       constantIv = new byte[constantIvSize];
       sgpd.readBytes(constantIv, 0, constantIvSize);
@@ -1206,6 +1229,8 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
       sampleSize += sampleBytesWritten;
       parserState = STATE_READING_SAMPLE_CONTINUE;
       sampleCurrentNalBytesRemaining = 0;
+      isAc4HeaderRequired =
+          MimeTypes.AUDIO_AC4.equals(currentTrackBundle.track.format.sampleMimeType);
     }
 
     TrackFragment fragment = currentTrackBundle.fragment;
@@ -1233,7 +1258,11 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           // Read the NAL length so that we know where we find the next one, and its type.
           input.readFully(nalPrefixData, nalUnitLengthFieldLengthDiff, nalUnitPrefixLength);
           nalPrefix.setPosition(0);
-          sampleCurrentNalBytesRemaining = nalPrefix.readUnsignedIntToInt() - 1;
+          int nalLengthInt = nalPrefix.readInt();
+          if (nalLengthInt < 1) {
+            throw new ParserException("Invalid NAL length");
+          }
+          sampleCurrentNalBytesRemaining = nalLengthInt - 1;
           // Write a start code for the current NAL unit.
           nalStartCode.setPosition(0);
           output.sampleData(nalStartCode, 4);
@@ -1266,6 +1295,14 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
         }
       }
     } else {
+      if (isAc4HeaderRequired) {
+        Ac4Util.getAc4SampleHeader(sampleSize, scratch);
+        int length = scratch.limit();
+        output.sampleData(scratch, length);
+        sampleSize += length;
+        sampleBytesWritten += length;
+        isAc4HeaderRequired = false;
+      }
       while (sampleBytesWritten < sampleSize) {
         int writtenBytes = output.sampleData(input, sampleSize - sampleBytesWritten, false);
         sampleBytesWritten += writtenBytes;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntry.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntry.java
new file mode 100644
index 0000000000..e50fbd54f7
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntry.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp4;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Stores extensible metadata with handler type 'mdta'. See also the QuickTime File Format
+ * Specification.
+ */
+public final class MdtaMetadataEntry implements Metadata.Entry {
+
+  /** The metadata key name. */
+  public final String key;
+  /** The payload. The interpretation of the value depends on {@link #typeIndicator}. */
+  public final byte[] value;
+  /** The four byte locale indicator. */
+  public final int localeIndicator;
+  /** The four byte type indicator. */
+  public final int typeIndicator;
+
+  /** Creates a new metadata entry for the specified metadata key/value. */
+  public MdtaMetadataEntry(String key, byte[] value, int localeIndicator, int typeIndicator) {
+    this.key = key;
+    this.value = value;
+    this.localeIndicator = localeIndicator;
+    this.typeIndicator = typeIndicator;
+  }
+
+  private MdtaMetadataEntry(Parcel in) {
+    key = Util.castNonNull(in.readString());
+    value = new byte[in.readInt()];
+    in.readByteArray(value);
+    localeIndicator = in.readInt();
+    typeIndicator = in.readInt();
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    MdtaMetadataEntry other = (MdtaMetadataEntry) obj;
+    return key.equals(other.key)
+        && Arrays.equals(value, other.value)
+        && localeIndicator == other.localeIndicator
+        && typeIndicator == other.typeIndicator;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + Arrays.hashCode(value);
+    result = 31 * result + localeIndicator;
+    result = 31 * result + typeIndicator;
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "mdta: key=" + key;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(key);
+    dest.writeInt(value.length);
+    dest.writeByteArray(value);
+    dest.writeInt(localeIndicator);
+    dest.writeInt(typeIndicator);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<MdtaMetadataEntry> CREATOR =
+      new Parcelable.Creator<MdtaMetadataEntry>() {
+
+        @Override
+        public MdtaMetadataEntry createFromParcel(Parcel in) {
+          return new MdtaMetadataEntry(in);
+        }
+
+        @Override
+        public MdtaMetadataEntry[] newArray(int size) {
+          return new MdtaMetadataEntry[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
index 670fe116a6..e9c9f7faf5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
@@ -25,10 +28,9 @@
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
 
-/**
- * Parses metadata items stored in ilst atoms.
- */
+/** Utilities for handling metadata in MP4. */
 /* package */ final class MetadataUtil {
 
   private static final String TAG = "MetadataUtil";
@@ -103,24 +105,73 @@
 
   private static final String LANGUAGE_UNDEFINED = "und";
 
+  private static final int TYPE_TOP_BYTE_COPYRIGHT = 0xA9;
+  private static final int TYPE_TOP_BYTE_REPLACEMENT = 0xFD; // Truncated value of \uFFFD.
+
+  private static final String MDTA_KEY_ANDROID_CAPTURE_FPS = "com.android.capture.fps";
+  private static final int MDTA_TYPE_INDICATOR_FLOAT = 23;
+
   private MetadataUtil() {}
 
   /**
-   * Parses a single ilst element from a {@link ParsableByteArray}. The element is read starting
-   * from the current position of the {@link ParsableByteArray}, and the position is advanced by the
-   * size of the element. The position is advanced even if the element's type is unrecognized.
+   * Returns a {@link Format} that is the same as the input format but includes information from the
+   * specified sources of metadata.
+   */
+  public static Format getFormatWithMetadata(
+      int trackType,
+      Format format,
+      @Nullable Metadata udtaMetadata,
+      @Nullable Metadata mdtaMetadata,
+      GaplessInfoHolder gaplessInfoHolder) {
+    if (trackType == C.TRACK_TYPE_AUDIO) {
+      if (gaplessInfoHolder.hasGaplessInfo()) {
+        format =
+            format.copyWithGaplessInfo(
+                gaplessInfoHolder.encoderDelay, gaplessInfoHolder.encoderPadding);
+      }
+      // We assume all udta metadata is associated with the audio track.
+      if (udtaMetadata != null) {
+        format = format.copyWithMetadata(udtaMetadata);
+      }
+    } else if (trackType == C.TRACK_TYPE_VIDEO && mdtaMetadata != null) {
+      // Populate only metadata keys that are known to be specific to video.
+      for (int i = 0; i < mdtaMetadata.length(); i++) {
+        Metadata.Entry entry = mdtaMetadata.get(i);
+        if (entry instanceof MdtaMetadataEntry) {
+          MdtaMetadataEntry mdtaMetadataEntry = (MdtaMetadataEntry) entry;
+          if (MDTA_KEY_ANDROID_CAPTURE_FPS.equals(mdtaMetadataEntry.key)
+              && mdtaMetadataEntry.typeIndicator == MDTA_TYPE_INDICATOR_FLOAT) {
+            try {
+              float fps = ByteBuffer.wrap(mdtaMetadataEntry.value).asFloatBuffer().get();
+              format = format.copyWithFrameRate(fps);
+              format = format.copyWithMetadata(new Metadata(mdtaMetadataEntry));
+            } catch (NumberFormatException e) {
+              Log.w(TAG, "Ignoring invalid framerate");
+            }
+          }
+        }
+      }
+    }
+    return format;
+  }
+
+  /**
+   * Parses a single userdata ilst element from a {@link ParsableByteArray}. The element is read
+   * starting from the current position of the {@link ParsableByteArray}, and the position is
+   * advanced by the size of the element. The position is advanced even if the element's type is
+   * unrecognized.
    *
    * @param ilst Holds the data to be parsed.
    * @return The parsed element, or null if the element's type was not recognized.
    */
-  public static @Nullable Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
+  @Nullable
+  public static Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
     int position = ilst.getPosition();
     int endPosition = position + ilst.readInt();
     int type = ilst.readInt();
     int typeTopByte = (type >> 24) & 0xFF;
     try {
-      if (typeTopByte == '\u00A9' /* Copyright char */
-          || typeTopByte == '\uFFFD' /* Replacement char */) {
+      if (typeTopByte == TYPE_TOP_BYTE_COPYRIGHT || typeTopByte == TYPE_TOP_BYTE_REPLACEMENT) {
         int shortType = type & 0x00FFFFFF;
         if (shortType == SHORT_TYPE_COMMENT) {
           return parseCommentAttribute(type, ilst);
@@ -185,7 +236,36 @@ private MetadataUtil() {}
     }
   }
 
-  private static @Nullable TextInformationFrame parseTextAttribute(
+  /**
+   * Parses an 'mdta' metadata entry starting at the current position in an ilst box.
+   *
+   * @param ilst The ilst box.
+   * @param endPosition The end position of the entry in the ilst box.
+   * @param key The mdta metadata entry key for the entry.
+   * @return The parsed element, or null if the entry wasn't recognized.
+   */
+  @Nullable
+  public static MdtaMetadataEntry parseMdtaMetadataEntryFromIlst(
+      ParsableByteArray ilst, int endPosition, String key) {
+    int atomPosition;
+    while ((atomPosition = ilst.getPosition()) < endPosition) {
+      int atomSize = ilst.readInt();
+      int atomType = ilst.readInt();
+      if (atomType == Atom.TYPE_data) {
+        int typeIndicator = ilst.readInt();
+        int localeIndicator = ilst.readInt();
+        int dataSize = atomSize - 16;
+        byte[] value = new byte[dataSize];
+        ilst.readBytes(value, 0, dataSize);
+        return new MdtaMetadataEntry(key, value, localeIndicator, typeIndicator);
+      }
+      ilst.setPosition(atomPosition + atomSize);
+    }
+    return null;
+  }
+
+  @Nullable
+  private static TextInformationFrame parseTextAttribute(
       int type, String id, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
@@ -198,7 +278,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
+  @Nullable
+  private static CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
@@ -210,7 +291,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable Id3Frame parseUint8Attribute(
+  @Nullable
+  private static Id3Frame parseUint8Attribute(
       int type,
       String id,
       ParsableByteArray data,
@@ -229,7 +311,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable TextInformationFrame parseIndexAndCountAttribute(
+  @Nullable
+  private static TextInformationFrame parseIndexAndCountAttribute(
       int type, String attributeName, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
@@ -249,8 +332,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable TextInformationFrame parseStandardGenreAttribute(
-      ParsableByteArray data) {
+  @Nullable
+  private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArray data) {
     int genreCode = parseUint8AttributeValue(data);
     String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
         ? STANDARD_GENRES[genreCode - 1] : null;
@@ -261,7 +344,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable ApicFrame parseCoverArt(ParsableByteArray data) {
+  @Nullable
+  private static ApicFrame parseCoverArt(ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
@@ -285,8 +369,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable Id3Frame parseInternalAttribute(
-      ParsableByteArray data, int endPosition) {
+  @Nullable
+  private static Id3Frame parseInternalAttribute(ParsableByteArray data, int endPosition) {
     String domain = null;
     String name = null;
     int dataAtomPosition = -1;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index 17c82c2c5b..75966bff66 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.audio.Ac4Util;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -31,6 +32,7 @@
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -75,7 +77,7 @@
   private static final int STATE_READING_ATOM_PAYLOAD = 1;
   private static final int STATE_READING_SAMPLE = 2;
 
-  // Brand stored in the ftyp atom for QuickTime media.
+  /** Brand stored in the ftyp atom for QuickTime media. */
   private static final int BRAND_QUICKTIME = Util.getIntegerCodeForString("qt  ");
 
   /**
@@ -95,6 +97,7 @@
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
   private final ParsableByteArray nalLength;
+  private final ParsableByteArray scratch;
 
   private final ParsableByteArray atomHeader;
   private final ArrayDeque<ContainerAtom> containerAtoms;
@@ -108,6 +111,7 @@
   private int sampleTrackIndex;
   private int sampleBytesWritten;
   private int sampleCurrentNalBytesRemaining;
+  private boolean isAc4HeaderRequired;
 
   // Extractor outputs.
   private ExtractorOutput extractorOutput;
@@ -136,6 +140,7 @@ public Mp4Extractor(@Flags int flags) {
     containerAtoms = new ArrayDeque<>();
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
+    scratch = new ParsableByteArray();
     sampleTrackIndex = C.INDEX_UNSET;
   }
 
@@ -156,6 +161,7 @@ public void seek(long position, long timeUs) {
     sampleTrackIndex = C.INDEX_UNSET;
     sampleBytesWritten = 0;
     sampleCurrentNalBytesRemaining = 0;
+    isAc4HeaderRequired = false;
     if (position == 0) {
       enterReadingAtomHeaderState();
     } else if (tracks != null) {
@@ -303,6 +309,9 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       if (atomSize == atomHeaderBytesRead) {
         processAtomEnded(endPosition);
       } else {
+        if (atomType == Atom.TYPE_meta) {
+          maybeSkipRemainingMetaAtomHeaderBytes(input);
+        }
         // Start reading the first child atom.
         enterReadingAtomHeaderState();
       }
@@ -377,15 +386,21 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
     long durationUs = C.TIME_UNSET;
     List<Mp4Track> tracks = new ArrayList<>();
 
-    Metadata metadata = null;
+    // Process metadata.
+    Metadata udtaMetadata = null;
     GaplessInfoHolder gaplessInfoHolder = new GaplessInfoHolder();
     Atom.LeafAtom udta = moov.getLeafAtomOfType(Atom.TYPE_udta);
     if (udta != null) {
-      metadata = AtomParsers.parseUdta(udta, isQuickTime);
-      if (metadata != null) {
-        gaplessInfoHolder.setFromMetadata(metadata);
+      udtaMetadata = AtomParsers.parseUdta(udta, isQuickTime);
+      if (udtaMetadata != null) {
+        gaplessInfoHolder.setFromMetadata(udtaMetadata);
       }
     }
+    Metadata mdtaMetadata = null;
+    Atom.ContainerAtom meta = moov.getContainerAtomOfType(Atom.TYPE_meta);
+    if (meta != null) {
+      mdtaMetadata = AtomParsers.parseMdtaFromMeta(meta);
+    }
 
     boolean ignoreEditLists = (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0;
     ArrayList<TrackSampleTable> trackSampleTables =
@@ -395,27 +410,27 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
     for (int i = 0; i < trackCount; i++) {
       TrackSampleTable trackSampleTable = trackSampleTables.get(i);
       Track track = trackSampleTable.track;
+      long trackDurationUs =
+          track.durationUs != C.TIME_UNSET ? track.durationUs : trackSampleTable.durationUs;
+      durationUs = Math.max(durationUs, trackDurationUs);
       Mp4Track mp4Track = new Mp4Track(track, trackSampleTable,
           extractorOutput.track(i, track.type));
+
       // Each sample has up to three bytes of overhead for the start code that replaces its length.
       // Allow ten source samples per output sample, like the platform extractor.
       int maxInputSize = trackSampleTable.maximumSize + 3 * 10;
       Format format = track.format.copyWithMaxInputSize(maxInputSize);
-      if (track.type == C.TRACK_TYPE_AUDIO) {
-        if (gaplessInfoHolder.hasGaplessInfo()) {
-          format = format.copyWithGaplessInfo(gaplessInfoHolder.encoderDelay,
-              gaplessInfoHolder.encoderPadding);
-        }
-        if (metadata != null) {
-          format = format.copyWithMetadata(metadata);
-        }
+      if (track.type == C.TRACK_TYPE_VIDEO
+          && trackDurationUs > 0
+          && trackSampleTable.sampleCount > 1) {
+        float frameRate = trackSampleTable.sampleCount / (trackDurationUs / 1000000f);
+        format = format.copyWithFrameRate(frameRate);
       }
+      format =
+          MetadataUtil.getFormatWithMetadata(
+              track.type, format, udtaMetadata, mdtaMetadata, gaplessInfoHolder);
       mp4Track.trackOutput.format(format);
 
-      durationUs =
-          Math.max(
-              durationUs,
-              track.durationUs != C.TIME_UNSET ? track.durationUs : trackSampleTable.durationUs);
       if (track.type == C.TRACK_TYPE_VIDEO && firstVideoTrackIndex == C.INDEX_UNSET) {
         firstVideoTrackIndex = tracks.size();
       }
@@ -423,7 +438,7 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
     }
     this.firstVideoTrackIndex = firstVideoTrackIndex;
     this.durationUs = durationUs;
-    this.tracks = tracks.toArray(new Mp4Track[tracks.size()]);
+    this.tracks = tracks.toArray(new Mp4Track[0]);
     accumulatedSampleSizes = calculateAccumulatedSampleSizes(this.tracks);
 
     extractorOutput.endTracks();
@@ -487,6 +502,8 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
       if (sampleTrackIndex == C.INDEX_UNSET) {
         return RESULT_END_OF_INPUT;
       }
+      isAc4HeaderRequired =
+          MimeTypes.AUDIO_AC4.equals(tracks[sampleTrackIndex].track.format.sampleMimeType);
     }
     Mp4Track track = tracks[sampleTrackIndex];
     TrackOutput trackOutput = track.trackOutput;
@@ -520,9 +537,13 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
       while (sampleBytesWritten < sampleSize) {
         if (sampleCurrentNalBytesRemaining == 0) {
           // Read the NAL length so that we know where we find the next one.
-          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+          input.readFully(nalLengthData, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
           nalLength.setPosition(0);
-          sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
+          int nalLengthInt = nalLength.readInt();
+          if (nalLengthInt < 0) {
+            throw new ParserException("Invalid NAL length");
+          }
+          sampleCurrentNalBytesRemaining = nalLengthInt;
           // Write a start code for the current NAL unit.
           nalStartCode.setPosition(0);
           trackOutput.sampleData(nalStartCode, 4);
@@ -536,6 +557,14 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
         }
       }
     } else {
+      if (isAc4HeaderRequired) {
+        Ac4Util.getAc4SampleHeader(sampleSize, scratch);
+        int length = scratch.limit();
+        trackOutput.sampleData(scratch, length);
+        sampleSize += length;
+        sampleBytesWritten += length;
+        isAc4HeaderRequired = false;
+      }
       while (sampleBytesWritten < sampleSize) {
         int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten, false);
         sampleBytesWritten += writtenBytes;
@@ -617,6 +646,32 @@ private void updateSampleIndices(long timeUs) {
     }
   }
 
+  /**
+   * Possibly skips the version and flags fields (1+3 byte) of a full meta atom of the {@code
+   * input}.
+   *
+   * <p>Atoms of type {@link Atom#TYPE_meta} are defined to be full atoms which have four additional
+   * bytes for a version and a flags field (see 4.2 'Object Structure' in ISO/IEC 14496-12:2005).
+   * QuickTime do not have such a full box structure. Since some of these files are encoded wrongly,
+   * we can't rely on the file type though. Instead we must check the 8 bytes after the common
+   * header bytes ourselves.
+   */
+  private void maybeSkipRemainingMetaAtomHeaderBytes(ExtractorInput input)
+      throws IOException, InterruptedException {
+    scratch.reset(8);
+    // Peek the next 8 bytes which can be either
+    // (iso) [1 byte version + 3 bytes flags][4 byte size of next atom]
+    // (qt)  [4 byte size of next atom      ][4 byte hdlr atom type   ]
+    // In case of (iso) we need to skip the next 4 bytes.
+    input.peekFully(scratch.data, 0, 8);
+    scratch.skipBytes(4);
+    if (scratch.readInt() == Atom.TYPE_hdlr) {
+      input.resetPeekPosition();
+    } else {
+      input.skipFully(4);
+    }
+  }
+
   /**
    * For each sample of each track, calculates accumulated size of all samples which need to be read
    * before this sample can be used.
@@ -716,24 +771,37 @@ private static boolean processFtypAtom(ParsableByteArray atomData) {
     return false;
   }
 
-  /**
-   * Returns whether the extractor should decode a leaf atom with type {@code atom}.
-   */
+  /** Returns whether the extractor should decode a leaf atom with type {@code atom}. */
   private static boolean shouldParseLeafAtom(int atom) {
-    return atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_hdlr
-        || atom == Atom.TYPE_stsd || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
-        || atom == Atom.TYPE_ctts || atom == Atom.TYPE_elst || atom == Atom.TYPE_stsc
-        || atom == Atom.TYPE_stsz || atom == Atom.TYPE_stz2 || atom == Atom.TYPE_stco
-        || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp
-        || atom == Atom.TYPE_udta;
+    return atom == Atom.TYPE_mdhd
+        || atom == Atom.TYPE_mvhd
+        || atom == Atom.TYPE_hdlr
+        || atom == Atom.TYPE_stsd
+        || atom == Atom.TYPE_stts
+        || atom == Atom.TYPE_stss
+        || atom == Atom.TYPE_ctts
+        || atom == Atom.TYPE_elst
+        || atom == Atom.TYPE_stsc
+        || atom == Atom.TYPE_stsz
+        || atom == Atom.TYPE_stz2
+        || atom == Atom.TYPE_stco
+        || atom == Atom.TYPE_co64
+        || atom == Atom.TYPE_tkhd
+        || atom == Atom.TYPE_ftyp
+        || atom == Atom.TYPE_udta
+        || atom == Atom.TYPE_keys
+        || atom == Atom.TYPE_ilst;
   }
 
-  /**
-   * Returns whether the extractor should decode a container atom with type {@code atom}.
-   */
+  /** Returns whether the extractor should decode a container atom with type {@code atom}. */
   private static boolean shouldParseContainerAtom(int atom) {
-    return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts;
+    return atom == Atom.TYPE_moov
+        || atom == Atom.TYPE_trak
+        || atom == Atom.TYPE_mdia
+        || atom == Atom.TYPE_minf
+        || atom == Atom.TYPE_stbl
+        || atom == Atom.TYPE_edts
+        || atom == Atom.TYPE_meta;
   }
 
   private static final class Mp4Track {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
index 40cfa13325..957c3ba209 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
index 021c9de654..5c5afe39a8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
@@ -27,37 +27,38 @@
  */
 /* package */ final class Sniffer {
 
-  /**
-   * The maximum number of bytes to peek when sniffing.
-   */
+  /** The maximum number of bytes to peek when sniffing. */
   private static final int SEARCH_LENGTH = 4 * 1024;
 
-  private static final int[] COMPATIBLE_BRANDS = new int[] {
-      Util.getIntegerCodeForString("isom"),
-      Util.getIntegerCodeForString("iso2"),
-      Util.getIntegerCodeForString("iso3"),
-      Util.getIntegerCodeForString("iso4"),
-      Util.getIntegerCodeForString("iso5"),
-      Util.getIntegerCodeForString("iso6"),
-      Util.getIntegerCodeForString("avc1"),
-      Util.getIntegerCodeForString("hvc1"),
-      Util.getIntegerCodeForString("hev1"),
-      Util.getIntegerCodeForString("mp41"),
-      Util.getIntegerCodeForString("mp42"),
-      Util.getIntegerCodeForString("3g2a"),
-      Util.getIntegerCodeForString("3g2b"),
-      Util.getIntegerCodeForString("3gr6"),
-      Util.getIntegerCodeForString("3gs6"),
-      Util.getIntegerCodeForString("3ge6"),
-      Util.getIntegerCodeForString("3gg6"),
-      Util.getIntegerCodeForString("M4V "),
-      Util.getIntegerCodeForString("M4A "),
-      Util.getIntegerCodeForString("f4v "),
-      Util.getIntegerCodeForString("kddi"),
-      Util.getIntegerCodeForString("M4VP"),
-      Util.getIntegerCodeForString("qt  "), // Apple QuickTime
-      Util.getIntegerCodeForString("MSNV"), // Sony PSP
-  };
+  private static final int[] COMPATIBLE_BRANDS =
+      new int[] {
+        Util.getIntegerCodeForString("isom"),
+        Util.getIntegerCodeForString("iso2"),
+        Util.getIntegerCodeForString("iso3"),
+        Util.getIntegerCodeForString("iso4"),
+        Util.getIntegerCodeForString("iso5"),
+        Util.getIntegerCodeForString("iso6"),
+        Util.getIntegerCodeForString("avc1"),
+        Util.getIntegerCodeForString("hvc1"),
+        Util.getIntegerCodeForString("hev1"),
+        Util.getIntegerCodeForString("av01"),
+        Util.getIntegerCodeForString("mp41"),
+        Util.getIntegerCodeForString("mp42"),
+        Util.getIntegerCodeForString("3g2a"),
+        Util.getIntegerCodeForString("3g2b"),
+        Util.getIntegerCodeForString("3gr6"),
+        Util.getIntegerCodeForString("3gs6"),
+        Util.getIntegerCodeForString("3ge6"),
+        Util.getIntegerCodeForString("3gg6"),
+        Util.getIntegerCodeForString("M4V "),
+        Util.getIntegerCodeForString("M4A "),
+        Util.getIntegerCodeForString("f4v "),
+        Util.getIntegerCodeForString("kddi"),
+        Util.getIntegerCodeForString("M4VP"),
+        Util.getIntegerCodeForString("qt  "), // Apple QuickTime
+        Util.getIntegerCodeForString("MSNV"), // Sony PSP
+        Util.getIntegerCodeForString("dby1"), // Dolby Vision
+      };
 
   /**
    * Returns whether data peeked from the current position in {@code input} is consistent with the
@@ -109,15 +110,19 @@ private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
         headerSize = Atom.LONG_HEADER_SIZE;
         input.peekFully(buffer.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
         buffer.setLimit(Atom.LONG_HEADER_SIZE);
-        atomSize = buffer.readUnsignedLongToLong();
+        atomSize = buffer.readLong();
       } else if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
         // The atom extends to the end of the file.
-        long endPosition = input.getLength();
-        if (endPosition != C.LENGTH_UNSET) {
-          atomSize = endPosition - input.getPosition() + headerSize;
+        long fileEndPosition = input.getLength();
+        if (fileEndPosition != C.LENGTH_UNSET) {
+          atomSize = fileEndPosition - input.getPeekPosition() + headerSize;
         }
       }
 
+      if (inputLength != C.LENGTH_UNSET && bytesSearched + atomSize > inputLength) {
+        // The file is invalid because the atom extends past the end of the file.
+        return false;
+      }
       if (atomSize < headerSize) {
         // The file is invalid because the atom size is too small for its header.
         return false;
@@ -125,6 +130,13 @@ private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
       bytesSearched += headerSize;
 
       if (atomType == Atom.TYPE_moov) {
+        // We have seen the moov atom. We increase the search size to make sure we don't miss an
+        // mvex atom because the moov's size exceeds the search length.
+        bytesToSearch += (int) atomSize;
+        if (inputLength != C.LENGTH_UNSET && bytesToSearch > inputLength) {
+          // Make sure we don't exceed the file size.
+          bytesToSearch = (int) inputLength;
+        }
         // Check for an mvex atom inside the moov atom to identify whether the file is fragmented.
         continue;
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 59cd602209..9d3635e8b3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import java.lang.annotation.Documented;
@@ -128,4 +128,18 @@ public TrackEncryptionBox getSampleDescriptionEncryptionBox(int sampleDescriptio
         : sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
   }
 
+  public Track copyWithFormat(Format format) {
+    return new Track(
+        id,
+        type,
+        timescale,
+        movieTimescale,
+        durationUs,
+        format,
+        sampleTransformation,
+        sampleDescriptionEncryptionBoxes,
+        nalUnitLengthFieldLength,
+        editListDurations,
+        editListMediaTimes);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
index f09e6ae421..5bd29c6e75 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.Assertions;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
index 56851fc1e0..59ea386335 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
@@ -64,6 +64,9 @@ public TrackSampleTable(
     this.flags = flags;
     this.durationUs = durationUs;
     sampleCount = offsets.length;
+    if (flags.length > 0) {
+      flags[flags.length - 1] |= C.BUFFER_FLAG_LAST_SAMPLE;
+    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
index 93ed00a05b..c83662ee83 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
@@ -26,10 +27,8 @@
 /** Seeks in an Ogg stream. */
 /* package */ final class DefaultOggSeeker implements OggSeeker {
 
-  //@VisibleForTesting
-  public static final int MATCH_RANGE = 72000;
-  //@VisibleForTesting
-  public static final int MATCH_BYTE_RANGE = 100000;
+  @VisibleForTesting public static final int MATCH_RANGE = 72000;
+  @VisibleForTesting public static final int MATCH_BYTE_RANGE = 100000;
   private static final int DEFAULT_OFFSET = 30000;
 
   private static final int STATE_SEEK_TO_END = 0;
@@ -133,7 +132,7 @@ public OggSeekMap createSeekMap() {
     return totalGranules != 0 ? new OggSeekMap() : null;
   }
 
-  //@VisibleForTesting
+  @VisibleForTesting
   public void resetSeeking() {
     start = startPosition;
     end = endPosition;
@@ -150,12 +149,12 @@ public void resetSeeking() {
    *
    * @param targetGranule the target granule position to seek to.
    * @param input the {@link ExtractorInput} to read from.
-   * @return the position to seek the {@link ExtractorInput} to for a next call or
-   *     -(currentGranule + 2) if it's close enough to skip to the target page.
+   * @return the position to seek the {@link ExtractorInput} to for a next call or -(currentGranule
+   *     + 2) if it's close enough to skip to the target page.
    * @throws IOException thrown if reading from the input fails.
    * @throws InterruptedException thrown if interrupted while reading from the input.
    */
-  //@VisibleForTesting
+  @VisibleForTesting
   public long getNextSeekPosition(long targetGranule, ExtractorInput input)
       throws IOException, InterruptedException {
     if (start == end) {
@@ -250,7 +249,7 @@ public long getDurationUs() {
    * @throws InterruptedException If the thread is interrupted.
    * @throws EOFException If the next page can't be found before the end of the input.
    */
-  // @VisibleForTesting
+  @VisibleForTesting
   void skipToNextPage(ExtractorInput input) throws IOException, InterruptedException {
     if (!skipToNextPage(input, endPosition)) {
       // Not found until eof.
@@ -267,7 +266,7 @@ void skipToNextPage(ExtractorInput input) throws IOException, InterruptedExcepti
    * @throws IOException thrown if peeking/reading from the input fails.
    * @throws InterruptedException thrown if interrupted while peeking/reading from the input.
    */
-  // @VisibleForTesting
+  @VisibleForTesting
   boolean skipToNextPage(ExtractorInput input, long limit)
       throws IOException, InterruptedException {
     limit = Math.min(limit + 3, endPosition);
@@ -307,7 +306,7 @@ boolean skipToNextPage(ExtractorInput input, long limit)
    * @throws IOException If reading from the input fails.
    * @throws InterruptedException If the thread is interrupted.
    */
-  // @VisibleForTesting
+  @VisibleForTesting
   long readGranuleOfLastPage(ExtractorInput input) throws IOException, InterruptedException {
     skipToNextPage(input);
     pageHeader.reset();
@@ -319,8 +318,8 @@ long readGranuleOfLastPage(ExtractorInput input) throws IOException, Interrupted
   }
 
   /**
-   * Skips to the position of the start of the page containing the {@code targetGranule} and
-   * returns the granule of the page previous to the target page.
+   * Skips to the position of the start of the page containing the {@code targetGranule} and returns
+   * the granule of the page previous to the target page.
    *
    * @param input the {@link ExtractorInput} to read from.
    * @param targetGranule the target granule.
@@ -331,7 +330,7 @@ long readGranuleOfLastPage(ExtractorInput input) throws IOException, Interrupted
    * @throws IOException thrown if reading from the input fails.
    * @throws InterruptedException thrown if interrupted while reading from the input.
    */
-  //@VisibleForTesting
+  @VisibleForTesting
   long skipToPageOfGranule(ExtractorInput input, long targetGranule, long currentGranule)
       throws IOException, InterruptedException {
     pageHeader.populate(input, false);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java
index 482f0c5021..9c594ffde5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java
@@ -103,14 +103,13 @@ public boolean populate(ExtractorInput input) throws IOException, InterruptedExc
   /**
    * An OGG Packet may span multiple pages. Returns the {@link OggPageHeader} of the last page read,
    * or an empty header if the packet has yet to be populated.
-   * <p>
-   * Note that the returned {@link OggPageHeader} is mutable and may be updated during subsequent
+   *
+   * <p>Note that the returned {@link OggPageHeader} is mutable and may be updated during subsequent
    * calls to {@link #populate(ExtractorInput)}.
    *
    * @return the {@code PageHeader} of the last page read or an empty header if the packet has yet
    *     to be populated.
    */
-  //@VisibleForTesting
   public OggPageHeader getPageHeader() {
     return pageHeader;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java
index 147ad5a20b..2675edd5b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisReader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ogg.VorbisUtil.Mode;
@@ -107,7 +108,7 @@ protected boolean readHeaders(ParsableByteArray packet, long position, SetupData
     return true;
   }
 
-  //@VisibleForTesting
+  @VisibleForTesting
   /* package */ VorbisSetup readSetupHeaders(ParsableByteArray scratch) throws IOException {
 
     if (vorbisIdHeader == null) {
@@ -133,22 +134,22 @@ protected boolean readHeaders(ParsableByteArray packet, long position, SetupData
   }
 
   /**
-   * Reads an int of {@code length} bits from {@code src} starting at
-   * {@code leastSignificantBitIndex}.
+   * Reads an int of {@code length} bits from {@code src} starting at {@code
+   * leastSignificantBitIndex}.
    *
    * @param src the {@code byte} to read from.
    * @param length the length in bits of the int to read.
    * @param leastSignificantBitIndex the index of the least significant bit of the int to read.
    * @return the int value read.
    */
-  //@VisibleForTesting
+  @VisibleForTesting
   /* package */ static int readBits(byte src, int length, int leastSignificantBitIndex) {
     return (src >> leastSignificantBitIndex) & (255 >>> (8 - length));
   }
 
-  //@VisibleForTesting
-  /* package */ static void appendNumberOfSamples(ParsableByteArray buffer,
-      long packetSampleCount) {
+  @VisibleForTesting
+  /* package */ static void appendNumberOfSamples(
+      ParsableByteArray buffer, long packetSampleCount) {
 
     buffer.setLimit(buffer.limit() + 4);
     // The vorbis decoder expects the number of samples in the packet
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 3741d52294..889a49755a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -76,7 +76,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
       if (scratch.readUnsignedInt24() != ID3_TAG) {
         break;
       }
-      scratch.skipBytes(3);
+      scratch.skipBytes(3); // version, flags
       int length = scratch.readSynchSafeInt();
       startPosition += 10 + length;
       input.advancePeekPosition(length);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 93724be92d..cd07a40c6d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.Ac3Util;
@@ -201,7 +201,7 @@ private void parseHeader() {
       output.format(format);
     }
     sampleSize = frameInfo.frameSize;
-    // In this class a sample is an access unit (syncframe in AC-3), but the MediaFormat sample rate
+    // In this class a sample is an access unit (syncframe in AC-3), but Format#sampleRate
     // specifies the number of PCM audio samples per second.
     sampleDurationUs = C.MICROS_PER_SECOND * frameInfo.sampleCount / format.sampleRate;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java
new file mode 100644
index 0000000000..133c0f368b
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import static com.google.android.exoplayer2.audio.Ac4Util.AC40_SYNCWORD;
+import static com.google.android.exoplayer2.audio.Ac4Util.AC41_SYNCWORD;
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.audio.Ac4Util;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/** Extracts data from AC-4 bitstreams. */
+public final class Ac4Extractor implements Extractor {
+
+  /** Factory for {@link Ac4Extractor} instances. */
+  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new Ac4Extractor()};
+
+  /**
+   * The maximum number of bytes to search when sniffing, excluding ID3 information, before giving
+   * up.
+   */
+  private static final int MAX_SNIFF_BYTES = 8 * 1024;
+
+  /**
+   * The size of the reading buffer, in bytes. This value is determined based on the maximum frame
+   * size used in broadcast applications.
+   */
+  private static final int READ_BUFFER_SIZE = 16384;
+
+  /** The size of the frame header, in bytes. */
+  private static final int FRAME_HEADER_SIZE = 7;
+
+  private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
+
+  private final long firstSampleTimestampUs;
+  private final Ac4Reader reader;
+  private final ParsableByteArray sampleData;
+
+  private boolean startedPacket;
+
+  /** Creates a new extractor for AC-4 bitstreams. */
+  public Ac4Extractor() {
+    this(/* firstSampleTimestampUs= */ 0);
+  }
+
+  /** Creates a new extractor for AC-4 bitstreams, using the specified first sample timestamp. */
+  public Ac4Extractor(long firstSampleTimestampUs) {
+    this.firstSampleTimestampUs = firstSampleTimestampUs;
+    reader = new Ac4Reader();
+    sampleData = new ParsableByteArray(READ_BUFFER_SIZE);
+  }
+
+  // Extractor implementation.
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    // Skip any ID3 headers.
+    ParsableByteArray scratch = new ParsableByteArray(10);
+    int startPosition = 0;
+    while (true) {
+      input.peekFully(scratch.data, /* offset= */ 0, /* length= */ 10);
+      scratch.setPosition(0);
+      if (scratch.readUnsignedInt24() != ID3_TAG) {
+        break;
+      }
+      scratch.skipBytes(3); // version, flags
+      int length = scratch.readSynchSafeInt();
+      startPosition += 10 + length;
+      input.advancePeekPosition(length);
+    }
+    input.resetPeekPosition();
+    input.advancePeekPosition(startPosition);
+
+    int headerPosition = startPosition;
+    int validFramesCount = 0;
+    while (true) {
+      input.peekFully(scratch.data, /* offset= */ 0, /* length= */ FRAME_HEADER_SIZE);
+      scratch.setPosition(0);
+      int syncBytes = scratch.readUnsignedShort();
+      if (syncBytes != AC40_SYNCWORD && syncBytes != AC41_SYNCWORD) {
+        validFramesCount = 0;
+        input.resetPeekPosition();
+        if (++headerPosition - startPosition >= MAX_SNIFF_BYTES) {
+          return false;
+        }
+        input.advancePeekPosition(headerPosition);
+      } else {
+        if (++validFramesCount >= 4) {
+          return true;
+        }
+        int frameSize = Ac4Util.parseAc4SyncframeSize(scratch.data, syncBytes);
+        if (frameSize == C.LENGTH_UNSET) {
+          return false;
+        }
+        input.advancePeekPosition(frameSize - FRAME_HEADER_SIZE);
+      }
+    }
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    reader.createTracks(
+        output, new TrackIdGenerator(/* firstTrackId= */ 0, /* trackIdIncrement= */ 1));
+    output.endTracks();
+    output.seekMap(new SeekMap.Unseekable(/* durationUs= */ C.TIME_UNSET));
+  }
+
+  @Override
+  public void seek(long position, long timeUs) {
+    startedPacket = false;
+    reader.seek();
+  }
+
+  @Override
+  public void release() {
+    // Do nothing.
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    int bytesRead = input.read(sampleData.data, /* offset= */ 0, /* length= */ READ_BUFFER_SIZE);
+    if (bytesRead == C.RESULT_END_OF_INPUT) {
+      return RESULT_END_OF_INPUT;
+    }
+
+    // Feed whatever data we have to the reader, regardless of whether the read finished or not.
+    sampleData.setPosition(0);
+    sampleData.setLimit(bytesRead);
+
+    if (!startedPacket) {
+      // Pass data to the reader as though it's contained within a single infinitely long packet.
+      reader.packetStarted(firstSampleTimestampUs, FLAG_DATA_ALIGNMENT_INDICATOR);
+      startedPacket = true;
+    }
+    // TODO: Make it possible for the reader to consume the dataSource directly, so that it becomes
+    // unnecessary to copy the data through packetBuffer.
+    reader.consume(sampleData);
+    return RESULT_CONTINUE;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java
new file mode 100644
index 0000000000..48bd07fce4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import androidx.annotation.IntDef;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.audio.Ac4Util;
+import com.google.android.exoplayer2.audio.Ac4Util.SyncFrameInfo;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** Parses a continuous AC-4 byte stream and extracts individual samples. */
+public final class Ac4Reader implements ElementaryStreamReader {
+
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({STATE_FINDING_SYNC, STATE_READING_HEADER, STATE_READING_SAMPLE})
+  private @interface State {}
+
+  private static final int STATE_FINDING_SYNC = 0;
+  private static final int STATE_READING_HEADER = 1;
+  private static final int STATE_READING_SAMPLE = 2;
+
+  private final ParsableBitArray headerScratchBits;
+  private final ParsableByteArray headerScratchBytes;
+  private final String language;
+
+  private String trackFormatId;
+  private TrackOutput output;
+
+  @State private int state;
+  private int bytesRead;
+
+  // Used to find the header.
+  private boolean lastByteWasAC;
+  private boolean hasCRC;
+
+  // Used when parsing the header.
+  private long sampleDurationUs;
+  private Format format;
+  private int sampleSize;
+
+  // Used when reading the samples.
+  private long timeUs;
+
+  /** Constructs a new reader for AC-4 elementary streams. */
+  public Ac4Reader() {
+    this(null);
+  }
+
+  /**
+   * Constructs a new reader for AC-4 elementary streams.
+   *
+   * @param language Track language.
+   */
+  public Ac4Reader(String language) {
+    headerScratchBits = new ParsableBitArray(new byte[Ac4Util.HEADER_SIZE_FOR_PARSER]);
+    headerScratchBytes = new ParsableByteArray(headerScratchBits.data);
+    state = STATE_FINDING_SYNC;
+    bytesRead = 0;
+    lastByteWasAC = false;
+    hasCRC = false;
+    this.language = language;
+  }
+
+  @Override
+  public void seek() {
+    state = STATE_FINDING_SYNC;
+    bytesRead = 0;
+    lastByteWasAC = false;
+    hasCRC = false;
+  }
+
+  @Override
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator generator) {
+    generator.generateNewId();
+    trackFormatId = generator.getFormatId();
+    output = extractorOutput.track(generator.getTrackId(), C.TRACK_TYPE_AUDIO);
+  }
+
+  @Override
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_SYNC:
+          if (skipToNextSync(data)) {
+            state = STATE_READING_HEADER;
+            headerScratchBytes.data[0] = (byte) 0xAC;
+            headerScratchBytes.data[1] = (byte) (hasCRC ? 0x41 : 0x40);
+            bytesRead = 2;
+          }
+          break;
+        case STATE_READING_HEADER:
+          if (continueRead(data, headerScratchBytes.data, Ac4Util.HEADER_SIZE_FOR_PARSER)) {
+            parseHeader();
+            headerScratchBytes.setPosition(0);
+            output.sampleData(headerScratchBytes, Ac4Util.HEADER_SIZE_FOR_PARSER);
+            state = STATE_READING_SAMPLE;
+          }
+          break;
+        case STATE_READING_SAMPLE:
+          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+          output.sampleData(data, bytesToRead);
+          bytesRead += bytesToRead;
+          if (bytesRead == sampleSize) {
+            output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+            timeUs += sampleDurationUs;
+            state = STATE_FINDING_SYNC;
+          }
+          break;
+        default:
+          break;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+   * that the data should be written into {@code target} starting from an offset of zero.
+   *
+   * @param source The source from which to read.
+   * @param target The target into which data is to be read.
+   * @param targetLength The target length of the read.
+   * @return Whether the target length was reached.
+   */
+  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+    source.readBytes(target, bytesRead, bytesToRead);
+    bytesRead += bytesToRead;
+    return bytesRead == targetLength;
+  }
+
+  /**
+   * Locates the next syncword, advancing the position to the byte that immediately follows it. If a
+   * syncword was not located, the position is advanced to the limit.
+   *
+   * @param pesBuffer The buffer whose position should be advanced.
+   * @return Whether a syncword position was found.
+   */
+  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
+    while (pesBuffer.bytesLeft() > 0) {
+      if (!lastByteWasAC) {
+        lastByteWasAC = (pesBuffer.readUnsignedByte() == 0xAC);
+        continue;
+      }
+      int secondByte = pesBuffer.readUnsignedByte();
+      lastByteWasAC = secondByte == 0xAC;
+      if (secondByte == 0x40 || secondByte == 0x41) {
+        hasCRC = secondByte == 0x41;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Parses the sample header. */
+  @SuppressWarnings("ReferenceEquality")
+  private void parseHeader() {
+    headerScratchBits.setPosition(0);
+    SyncFrameInfo frameInfo = Ac4Util.parseAc4SyncframeInfo(headerScratchBits);
+    if (format == null
+        || frameInfo.channelCount != format.channelCount
+        || frameInfo.sampleRate != format.sampleRate
+        || !MimeTypes.AUDIO_AC4.equals(format.sampleMimeType)) {
+      format =
+          Format.createAudioSampleFormat(
+              trackFormatId,
+              MimeTypes.AUDIO_AC4,
+              /* codecs= */ null,
+              /* bitrate= */ Format.NO_VALUE,
+              /* maxInputSize= */ Format.NO_VALUE,
+              frameInfo.channelCount,
+              frameInfo.sampleRate,
+              /* initializationData= */ null,
+              /* drmInitData= */ null,
+              /* selectionFlags= */ 0,
+              language);
+      output.format(format);
+    }
+    sampleSize = frameInfo.frameSize;
+    // In this class a sample is an AC-4 sync frame, but Format#sampleRate specifies the number of
+    // PCM audio samples per second.
+    sampleDurationUs = C.MICROS_PER_SECOND * frameInfo.sampleCount / format.sampleRate;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 77b79fa19f..9526a65766 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -17,8 +17,8 @@
 
 import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ConstantBitrateSeekMap;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index a5506e2cfb..15c37430bc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
@@ -38,7 +38,8 @@
    * Flags controlling elementary stream readers' behavior. Possible flag values are {@link
    * #FLAG_ALLOW_NON_IDR_KEYFRAMES}, {@link #FLAG_IGNORE_AAC_STREAM}, {@link
    * #FLAG_IGNORE_H264_STREAM}, {@link #FLAG_DETECT_ACCESS_UNITS}, {@link
-   * #FLAG_IGNORE_SPLICE_INFO_STREAM} and {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS}.
+   * #FLAG_IGNORE_SPLICE_INFO_STREAM}, {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} and {@link
+   * #FLAG_ENABLE_HDMV_DTS_AUDIO_STREAMS}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -50,7 +51,8 @@
         FLAG_IGNORE_H264_STREAM,
         FLAG_DETECT_ACCESS_UNITS,
         FLAG_IGNORE_SPLICE_INFO_STREAM,
-        FLAG_OVERRIDE_CAPTION_DESCRIPTORS
+        FLAG_OVERRIDE_CAPTION_DESCRIPTORS,
+        FLAG_ENABLE_HDMV_DTS_AUDIO_STREAMS
       })
   public @interface Flags {}
 
@@ -86,6 +88,11 @@
    * closedCaptionFormats} will be ignored if the PMT contains closed captions service descriptors.
    */
   public static final int FLAG_OVERRIDE_CAPTION_DESCRIPTORS = 1 << 5;
+  /**
+   * Sets whether HDMV DTS audio streams will be handled. If this flag is set, SCTE subtitles will
+   * not be detected, as they share the same elementary stream type as HDMV DTS.
+   */
+  public static final int FLAG_ENABLE_HDMV_DTS_AUDIO_STREAMS = 1 << 6;
 
   private static final int DESCRIPTOR_TAG_CAPTION_SERVICE = 0x86;
 
@@ -142,8 +149,14 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
       case TsExtractor.TS_STREAM_TYPE_AC3:
       case TsExtractor.TS_STREAM_TYPE_E_AC3:
         return new PesReader(new Ac3Reader(esInfo.language));
-      case TsExtractor.TS_STREAM_TYPE_DTS:
+      case TsExtractor.TS_STREAM_TYPE_AC4:
+        return new PesReader(new Ac4Reader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_HDMV_DTS:
+        if (!isSet(FLAG_ENABLE_HDMV_DTS_AUDIO_STREAMS)) {
+          return null;
+        }
+        // Fall through.
+      case TsExtractor.TS_STREAM_TYPE_DTS:
         return new PesReader(new DtsReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader(buildUserDataReader(esInfo)));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
index 2a633c191d..39e74ae6a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index d91842423d..a2f8568cbb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -17,7 +17,7 @@
 
 import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_PAYLOAD_UNIT_START_INDICATOR;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
@@ -87,6 +87,7 @@
   public static final int TS_STREAM_TYPE_DTS = 0x8A;
   public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
   public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
+  public static final int TS_STREAM_TYPE_AC4 = 0xAC; // DVB/ATSC AC-4 Descriptor
   public static final int TS_STREAM_TYPE_H262 = 0x02;
   public static final int TS_STREAM_TYPE_H264 = 0x1B;
   public static final int TS_STREAM_TYPE_H265 = 0x24;
@@ -102,6 +103,7 @@
 
   private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
   private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
+  private static final long AC4_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-4");
   private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
 
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * 50;
@@ -494,8 +496,11 @@ public void consume(ParsableByteArray sectionData) {
     private static final int TS_PMT_DESC_AC3 = 0x6A;
     private static final int TS_PMT_DESC_EAC3 = 0x7A;
     private static final int TS_PMT_DESC_DTS = 0x7B;
+    private static final int TS_PMT_DESC_DVB_EXT = 0x7F;
     private static final int TS_PMT_DESC_DVBSUBS = 0x59;
 
+    private static final int TS_PMT_DESC_DVB_EXT_AC4 = 0x15;
+
     private final ParsableBitArray pmtScratch;
     private final SparseArray<TsPayloadReader> trackIdToReaderScratch;
     private final SparseIntArray trackIdToPidScratch;
@@ -648,6 +653,8 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {
             streamType = TS_STREAM_TYPE_AC3;
           } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
             streamType = TS_STREAM_TYPE_E_AC3;
+          } else if (formatIdentifier == AC4_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_AC4;
           } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
             streamType = TS_STREAM_TYPE_H265;
           }
@@ -655,6 +662,13 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {
           streamType = TS_STREAM_TYPE_AC3;
         } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
           streamType = TS_STREAM_TYPE_E_AC3;
+        } else if (descriptorTag == TS_PMT_DESC_DVB_EXT) {
+          // Extension descriptor in DVB (ETSI EN 300 468).
+          int descriptorTagExt = data.readUnsignedByte();
+          if (descriptorTagExt == TS_PMT_DESC_DVB_EXT_AC4) {
+            // AC-4_descriptor in DVB (ETSI EN 300 468).
+            streamType = TS_STREAM_TYPE_AC4;
+          }
         } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
           streamType = TS_STREAM_TYPE_DTS;
         } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index a034b05696..536a31c9fc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -100,7 +100,7 @@ public EsInfo(int streamType, String language, List<DvbSubtitleInfo> dvbSubtitle
     public final byte[] initializationData;
 
     /**
-     * @param language The ISO 639-2 three character language.
+     * @param language The ISO 639-2 three-letter language code.
      * @param type The subtitling type.
      * @param initializationData The composition and ancillary page ids.
      */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 8cec75a66d..08ba94f257 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -22,7 +22,7 @@
 import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCodecInfo.VideoCapabilities;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
@@ -31,7 +31,6 @@
 import com.google.android.exoplayer2.util.Util;
 
 /** Information about a {@link MediaCodec} for a given mime type. */
-@TargetApi(16)
 @SuppressWarnings("InlinedApi")
 public final class MediaCodecInfo {
 
@@ -251,8 +250,8 @@ public boolean isCodecSupported(String codec) {
     int profile = codecProfileAndLevel.first;
     int level = codecProfileAndLevel.second;
     if (!isVideo && profile != CodecProfileLevel.AACObjectXHE) {
-      // Some devices/builds under-report audio capabilities, so assume support except for xHE-AAC
-      // which is not widely supported. See https://github.com/google/ExoPlayer/issues/5145.
+      // Some devices/builds underreport audio capabilities, so assume support except for xHE-AAC
+      // which may not be widely supported. See https://github.com/google/ExoPlayer/issues/5145.
       return true;
     }
     for (CodecProfileLevel capabilities : getProfileLevels()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 6a813332e3..f7855810d4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -20,13 +20,14 @@
 import android.media.MediaCodec.CodecException;
 import android.media.MediaCodec.CryptoException;
 import android.media.MediaCrypto;
+import android.media.MediaCryptoException;
 import android.media.MediaFormat;
 import android.os.Bundle;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.support.annotation.CheckResult;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -52,12 +53,12 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
  * An abstract renderer that uses {@link MediaCodec} to decode samples for rendering.
  */
-@TargetApi(16)
 public abstract class MediaCodecRenderer extends BaseRenderer {
 
   /**
@@ -187,19 +188,22 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     KEEP_CODEC_RESULT_NO,
-    KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION,
-    KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION
+    KEEP_CODEC_RESULT_YES_WITH_FLUSH,
+    KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION,
+    KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION
   })
   protected @interface KeepCodecResult {}
   /** The codec cannot be kept. */
   protected static final int KEEP_CODEC_RESULT_NO = 0;
-  /** The codec can be kept. No reconfiguration is required. */
-  protected static final int KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION = 1;
+  /** The codec can be kept, but must be flushed. */
+  protected static final int KEEP_CODEC_RESULT_YES_WITH_FLUSH = 1;
   /**
-   * The codec can be kept, but must be reconfigured by prefixing the next input buffer with the new
-   * format's configuration data.
+   * The codec can be kept. It does not need to be flushed, but must be reconfigured by prefixing
+   * the next input buffer with the new format's configuration data.
    */
-  protected static final int KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION = 3;
+  protected static final int KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION = 2;
+  /** The codec can be kept. It does not need to be flushed and no reconfiguration is required. */
+  protected static final int KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION = 3;
 
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -223,30 +227,34 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int RECONFIGURATION_STATE_QUEUE_PENDING = 2;
 
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({DRAIN_STATE_NONE, DRAIN_STATE_SIGNAL_END_OF_STREAM, DRAIN_STATE_WAIT_END_OF_STREAM})
+  private @interface DrainState {}
+  /** The codec is not being drained. */
+  private static final int DRAIN_STATE_NONE = 0;
+  /** The codec needs to be drained, but we haven't signaled an end of stream to it yet. */
+  private static final int DRAIN_STATE_SIGNAL_END_OF_STREAM = 1;
+  /** The codec needs to be drained, and we're waiting for it to output an end of stream. */
+  private static final int DRAIN_STATE_WAIT_END_OF_STREAM = 2;
+
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-    REINITIALIZATION_STATE_NONE,
-    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+    DRAIN_ACTION_NONE,
+    DRAIN_ACTION_FLUSH,
+    DRAIN_ACTION_UPDATE_DRM_SESSION,
+    DRAIN_ACTION_REINITIALIZE
   })
-  private @interface ReinitializationState {}
-  /**
-   * The codec does not need to be re-initialized.
-   */
-  private static final int REINITIALIZATION_STATE_NONE = 0;
-  /**
-   * The input format has changed in a way that requires the codec to be re-initialized, but we
-   * haven't yet signaled an end of stream to the existing codec. We need to do so in order to
-   * ensure that it outputs any remaining buffers before we release it.
-   */
-  private static final int REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM = 1;
-  /**
-   * The input format has changed in a way that requires the codec to be re-initialized, and we've
-   * signaled an end of stream to the existing codec. We're waiting for the codec to output an end
-   * of stream signal to indicate that it has output any remaining buffers before we release it.
-   */
-  private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
+  private @interface DrainAction {}
+  /** No special action should be taken. */
+  private static final int DRAIN_ACTION_NONE = 0;
+  /** The codec should be flushed. */
+  private static final int DRAIN_ACTION_FLUSH = 1;
+  /** The codec should be flushed and updated to use the pending DRM session. */
+  private static final int DRAIN_ACTION_UPDATE_DRM_SESSION = 2;
+  /** The codec should be reinitialized. */
+  private static final int DRAIN_ACTION_REINITIALIZE = 3;
 
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -280,30 +288,32 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private static final int ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT = 32;
 
   private final MediaCodecSelector mediaCodecSelector;
-  @Nullable
-  private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
+  @Nullable private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
+  private final boolean enableDecoderFallback;
   private final float assumedMinimumCodecOperatingRate;
   private final DecoderInputBuffer buffer;
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final FormatHolder formatHolder;
   private final TimedValueQueue<Format> formatQueue;
-  private final List<Long> decodeOnlyPresentationTimestamps;
+  private final ArrayList<Long> decodeOnlyPresentationTimestamps;
   private final MediaCodec.BufferInfo outputBufferInfo;
 
-  private Format format;
-  private Format pendingFormat;
+  @Nullable private Format inputFormat;
   private Format outputFormat;
-  private DrmSession<FrameworkMediaCrypto> drmSession;
-  private DrmSession<FrameworkMediaCrypto> pendingDrmSession;
-  private MediaCodec codec;
+  @Nullable private DrmSession<FrameworkMediaCrypto> codecDrmSession;
+  @Nullable private DrmSession<FrameworkMediaCrypto> sourceDrmSession;
+  @Nullable private MediaCrypto mediaCrypto;
+  private boolean mediaCryptoRequiresSecureDecoder;
+  private long renderTimeLimitMs;
   private float rendererOperatingRate;
+  @Nullable private MediaCodec codec;
+  @Nullable private Format codecFormat;
   private float codecOperatingRate;
-  private boolean codecConfiguredWithOperatingRate;
-  private @Nullable ArrayDeque<MediaCodecInfo> availableCodecInfos;
-  private @Nullable DecoderInitializationException preferredDecoderInitializationException;
-  private @Nullable MediaCodecInfo codecInfo;
-  private @AdaptationWorkaroundMode int codecAdaptationWorkaroundMode;
+  @Nullable private ArrayDeque<MediaCodecInfo> availableCodecInfos;
+  @Nullable private DecoderInitializationException preferredDecoderInitializationException;
+  @Nullable private MediaCodecInfo codecInfo;
+  @AdaptationWorkaroundMode private int codecAdaptationWorkaroundMode;
   private boolean codecNeedsReconfigureWorkaround;
   private boolean codecNeedsDiscardToSpsWorkaround;
   private boolean codecNeedsFlushWorkaround;
@@ -321,15 +331,17 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private ByteBuffer outputBuffer;
   private boolean shouldSkipOutputBuffer;
   private boolean codecReconfigured;
-  private @ReconfigurationState int codecReconfigurationState;
-  private @ReinitializationState int codecReinitializationState;
+  @ReconfigurationState private int codecReconfigurationState;
+  @DrainState private int codecDrainState;
+  @DrainAction private int codecDrainAction;
   private boolean codecReceivedBuffers;
   private boolean codecReceivedEos;
 
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
-  private boolean waitingForFirstSyncFrame;
+  private boolean waitingForFirstSyncSample;
+  private boolean waitingForFirstSampleInFormat;
 
   protected DecoderCounters decoderCounters;
 
@@ -344,6 +356,9 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is less efficient or slower
+   *     than the primary decoder.
    * @param assumedMinimumCodecOperatingRate A codec operating rate that all codecs instantiated by
    *     this renderer are assumed to meet implicitly (i.e. without the operating rate being set
    *     explicitly using {@link MediaFormat#KEY_OPERATING_RATE}).
@@ -353,12 +368,13 @@ public MediaCodecRenderer(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       float assumedMinimumCodecOperatingRate) {
     super(trackType);
-    Assertions.checkState(Util.SDK_INT >= 16);
     this.mediaCodecSelector = Assertions.checkNotNull(mediaCodecSelector);
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    this.enableDecoderFallback = enableDecoderFallback;
     this.assumedMinimumCodecOperatingRate = assumedMinimumCodecOperatingRate;
     buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
@@ -367,9 +383,25 @@ public MediaCodecRenderer(
     decodeOnlyPresentationTimestamps = new ArrayList<>();
     outputBufferInfo = new MediaCodec.BufferInfo();
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
-    codecReinitializationState = REINITIALIZATION_STATE_NONE;
+    codecDrainState = DRAIN_STATE_NONE;
+    codecDrainAction = DRAIN_ACTION_NONE;
     codecOperatingRate = CODEC_OPERATING_RATE_UNSET;
     rendererOperatingRate = 1f;
+    renderTimeLimitMs = C.TIME_UNSET;
+  }
+
+  /**
+   * Set a limit on the time a single {@link #render(long, long)} call can spend draining and
+   * filling the decoder.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release. It should
+   * only be called before the renderer is used.
+   *
+   * @param renderTimeLimitMs The render time limit in milliseconds, or {@link C#TIME_UNSET} for no
+   *     limit.
+   */
+  public void experimental_setRenderTimeLimitMs(long renderTimeLimitMs) {
+    this.renderTimeLimitMs = renderTimeLimitMs;
   }
 
   @Override
@@ -409,11 +441,9 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  protected List<MediaCodecInfo> getDecoderInfos(
+  protected abstract List<MediaCodecInfo> getDecoderInfos(
       MediaCodecSelector mediaCodecSelector, Format format, boolean requiresSecureDecoder)
-      throws DecoderQueryException {
-    return mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecoder);
-  }
+      throws DecoderQueryException;
 
   /**
    * Configures a newly created {@link MediaCodec}.
@@ -435,34 +465,41 @@ protected abstract void configureCodec(
       throws DecoderQueryException;
 
   protected final void maybeInitCodec() throws ExoPlaybackException {
-    if (codec != null || format == null) {
+    if (codec != null || inputFormat == null) {
       // We have a codec already, or we don't have a format with which to instantiate one.
       return;
     }
 
-    drmSession = pendingDrmSession;
-    String mimeType = format.sampleMimeType;
-    MediaCrypto wrappedMediaCrypto = null;
-    boolean drmSessionRequiresSecureDecoder = false;
-    if (drmSession != null) {
-      FrameworkMediaCrypto mediaCrypto = drmSession.getMediaCrypto();
+    setCodecDrmSession(sourceDrmSession);
+
+    String mimeType = inputFormat.sampleMimeType;
+    if (codecDrmSession != null) {
       if (mediaCrypto == null) {
-        DrmSessionException drmError = drmSession.getError();
-        if (drmError != null) {
-          // Continue for now. We may be able to avoid failure if the session recovers, or if a new
-          // input format causes the session to be replaced before it's used.
+        FrameworkMediaCrypto sessionMediaCrypto = codecDrmSession.getMediaCrypto();
+        if (sessionMediaCrypto == null) {
+          DrmSessionException drmError = codecDrmSession.getError();
+          if (drmError != null) {
+            // Continue for now. We may be able to avoid failure if the session recovers, or if a
+            // new input format causes the session to be replaced before it's used.
+          } else {
+            // The drm session isn't open yet.
+            return;
+          }
         } else {
-          // The drm session isn't open yet.
-          return;
+          try {
+            mediaCrypto = new MediaCrypto(sessionMediaCrypto.uuid, sessionMediaCrypto.sessionId);
+          } catch (MediaCryptoException e) {
+            throw ExoPlaybackException.createForRenderer(e, getIndex());
+          }
+          mediaCryptoRequiresSecureDecoder =
+              !sessionMediaCrypto.forceAllowInsecureDecoderComponents
+                  && mediaCrypto.requiresSecureDecoderComponent(mimeType);
         }
-      } else {
-        wrappedMediaCrypto = mediaCrypto.getWrappedMediaCrypto();
-        drmSessionRequiresSecureDecoder = mediaCrypto.requiresSecureDecoderComponent(mimeType);
       }
       if (deviceNeedsDrmKeysToConfigureCodecWorkaround()) {
-        @DrmSession.State int drmSessionState = drmSession.getState();
+        @DrmSession.State int drmSessionState = codecDrmSession.getState();
         if (drmSessionState == DrmSession.STATE_ERROR) {
-          throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+          throw ExoPlaybackException.createForRenderer(codecDrmSession.getError(), getIndex());
         } else if (drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS) {
           // Wait for keys.
           return;
@@ -471,32 +508,10 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     }
 
     try {
-      if (!initCodecWithFallback(wrappedMediaCrypto, drmSessionRequiresSecureDecoder)) {
-        // We can't initialize a codec yet.
-        return;
-      }
+      maybeInitCodecWithFallback(mediaCrypto, mediaCryptoRequiresSecureDecoder);
     } catch (DecoderInitializationException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
-
-    String codecName = codecInfo.name;
-    codecAdaptationWorkaroundMode = codecAdaptationWorkaroundMode(codecName);
-    codecNeedsReconfigureWorkaround = codecNeedsReconfigureWorkaround(codecName);
-    codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, format);
-    codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
-    codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
-    codecNeedsEosOutputExceptionWorkaround = codecNeedsEosOutputExceptionWorkaround(codecName);
-    codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
-    codecNeedsEosPropagation =
-        codecNeedsEosPropagationWorkaround(codecInfo) || getCodecNeedsEosPropagation();
-    codecHotswapDeadlineMs =
-        getState() == STATE_STARTED
-            ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS)
-            : C.TIME_UNSET;
-    resetInputBuffer();
-    resetOutputBuffer();
-    waitingForFirstSyncFrame = true;
-    decoderCounters.decoderInitCount++;
   }
 
   protected boolean shouldInitCodec(MediaCodecInfo codecInfo) {
@@ -542,83 +557,69 @@ protected void onEnabled(boolean joining) throws ExoPlaybackException {
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     inputStreamEnded = false;
     outputStreamEnded = false;
-    if (codec != null) {
-      flushCodec();
-    }
+    flushOrReinitializeCodec();
     formatQueue.clear();
   }
 
   @Override
   public final void setOperatingRate(float operatingRate) throws ExoPlaybackException {
     rendererOperatingRate = operatingRate;
-    updateCodecOperatingRate();
+    if (codec != null
+        && codecDrainAction != DRAIN_ACTION_REINITIALIZE
+        && getState() != STATE_DISABLED) {
+      updateCodecOperatingRate();
+    }
   }
 
   @Override
   protected void onDisabled() {
-    format = null;
-    availableCodecInfos = null;
+    inputFormat = null;
+    if (sourceDrmSession != null || codecDrmSession != null) {
+      // TODO: Do something better with this case.
+      onReset();
+    } else {
+      flushOrReleaseCodec();
+    }
+  }
+
+  @Override
+  protected void onReset() {
     try {
       releaseCodec();
     } finally {
-      try {
-        if (drmSession != null) {
-          drmSessionManager.releaseSession(drmSession);
-        }
-      } finally {
-        try {
-          if (pendingDrmSession != null && pendingDrmSession != drmSession) {
-            drmSessionManager.releaseSession(pendingDrmSession);
-          }
-        } finally {
-          drmSession = null;
-          pendingDrmSession = null;
-        }
-      }
+      setSourceDrmSession(null);
     }
   }
 
   protected void releaseCodec() {
-    codecHotswapDeadlineMs = C.TIME_UNSET;
+    availableCodecInfos = null;
+    codecInfo = null;
+    codecFormat = null;
     resetInputBuffer();
     resetOutputBuffer();
+    resetCodecBuffers();
     waitingForKeys = false;
-    shouldSkipOutputBuffer = false;
+    codecHotswapDeadlineMs = C.TIME_UNSET;
     decodeOnlyPresentationTimestamps.clear();
-    resetCodecBuffers();
-    codecInfo = null;
-    codecReconfigured = false;
-    codecReceivedBuffers = false;
-    codecNeedsDiscardToSpsWorkaround = false;
-    codecNeedsFlushWorkaround = false;
-    codecAdaptationWorkaroundMode = ADAPTATION_WORKAROUND_MODE_NEVER;
-    codecNeedsReconfigureWorkaround = false;
-    codecNeedsEosFlushWorkaround = false;
-    codecNeedsMonoChannelCountWorkaround = false;
-    codecNeedsAdaptationWorkaroundBuffer = false;
-    shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    codecNeedsEosPropagation = false;
-    codecReceivedEos = false;
-    codecReconfigurationState = RECONFIGURATION_STATE_NONE;
-    codecReinitializationState = REINITIALIZATION_STATE_NONE;
-    codecConfiguredWithOperatingRate = false;
-    if (codec != null) {
-      decoderCounters.decoderReleaseCount++;
-      try {
-        codec.stop();
-      } finally {
+    try {
+      if (codec != null) {
+        decoderCounters.decoderReleaseCount++;
         try {
-          codec.release();
+          codec.stop();
         } finally {
-          codec = null;
-          if (drmSession != null && pendingDrmSession != drmSession) {
-            try {
-              drmSessionManager.releaseSession(drmSession);
-            } finally {
-              drmSession = null;
-            }
-          }
+          codec.release();
+        }
+      }
+    } finally {
+      codec = null;
+      try {
+        if (mediaCrypto != null) {
+          mediaCrypto.release();
         }
+      } finally {
+        mediaCrypto = null;
+        mediaCryptoRequiresSecureDecoder = false;
+        setCodecDrmSession(null);
       }
     }
   }
@@ -639,29 +640,17 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       renderToEndOfStream();
       return;
     }
-    if (format == null) {
-      // We don't have a format yet, so try and read one.
-      flagsOnlyBuffer.clear();
-      int result = readSource(formatHolder, flagsOnlyBuffer, true);
-      if (result == C.RESULT_FORMAT_READ) {
-        onInputFormatChanged(formatHolder.format);
-      } else if (result == C.RESULT_BUFFER_READ) {
-        // End of stream read having not read a format.
-        Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
-        inputStreamEnded = true;
-        processEndOfStream();
-        return;
-      } else {
+    if (inputFormat == null && !readToFlagsOnlyBuffer(/* requireFormat= */ true)) {
         // We still don't have a format and can't make progress without one.
         return;
-      }
     }
     // We have a format.
     maybeInitCodec();
     if (codec != null) {
+      long drainStartTimeMs = SystemClock.elapsedRealtime();
       TraceUtil.beginSection("drainAndFeed");
       while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-      while (feedInputBuffer()) {}
+      while (feedInputBuffer() && shouldContinueFeeding(drainStartTimeMs)) {}
       TraceUtil.endSection();
     } else {
       decoderCounters.skippedInputBufferCount += skipSource(positionUs);
@@ -669,81 +658,121 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       // updated, and so that we have the most recent format should the codec be initialized. We may
       // also reach the end of the stream. Note that readSource will not read a sample into a
       // flags-only buffer.
-      flagsOnlyBuffer.clear();
-      int result = readSource(formatHolder, flagsOnlyBuffer, false);
-      if (result == C.RESULT_FORMAT_READ) {
-        onInputFormatChanged(formatHolder.format);
-      } else if (result == C.RESULT_BUFFER_READ) {
-        Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
-        inputStreamEnded = true;
-        processEndOfStream();
-      }
+      readToFlagsOnlyBuffer(/* requireFormat= */ false);
     }
     decoderCounters.ensureUpdated();
   }
 
-  protected void flushCodec() throws ExoPlaybackException {
-    codecHotswapDeadlineMs = C.TIME_UNSET;
+  /**
+   * Flushes the codec. If flushing is not possible, the codec will be released and re-instantiated.
+   * This method is a no-op if the codec is {@code null}.
+   *
+   * <p>The implementation of this method calls {@link #flushOrReleaseCodec()}, and {@link
+   * #maybeInitCodec()} if the codec needs to be re-instantiated.
+   *
+   * @return Whether the codec was released and reinitialized, rather than being flushed.
+   * @throws ExoPlaybackException If an error occurs re-instantiating the codec.
+   */
+  protected final boolean flushOrReinitializeCodec() throws ExoPlaybackException {
+    boolean released = flushOrReleaseCodec();
+    if (released) {
+      maybeInitCodec();
+    }
+    return released;
+  }
+
+  /**
+   * Flushes the codec. If flushing is not possible, the codec will be released. This method is a
+   * no-op if the codec is {@code null}.
+   *
+   * @return Whether the codec was released.
+   */
+  protected boolean flushOrReleaseCodec() {
+    if (codec == null) {
+      return false;
+    }
+    if (codecDrainAction == DRAIN_ACTION_REINITIALIZE
+        || codecNeedsFlushWorkaround
+        || (codecNeedsEosFlushWorkaround && codecReceivedEos)) {
+      releaseCodec();
+      return true;
+    }
+
+    codec.flush();
     resetInputBuffer();
     resetOutputBuffer();
-    waitingForFirstSyncFrame = true;
-    waitingForKeys = false;
-    shouldSkipOutputBuffer = false;
-    decodeOnlyPresentationTimestamps.clear();
+    codecHotswapDeadlineMs = C.TIME_UNSET;
+    codecReceivedEos = false;
+    codecReceivedBuffers = false;
+    waitingForFirstSyncSample = true;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    if (codecNeedsFlushWorkaround || (codecNeedsEosFlushWorkaround && codecReceivedEos)) {
-      releaseCodec();
-      maybeInitCodec();
-    } else if (codecReinitializationState != REINITIALIZATION_STATE_NONE) {
-      // We're already waiting to release and re-initialize the codec. Since we're now flushing,
-      // there's no need to wait any longer.
-      releaseCodec();
-      maybeInitCodec();
-    } else {
-      // We can flush and re-use the existing decoder.
-      codec.flush();
-      codecReceivedBuffers = false;
-    }
-    if (codecReconfigured && format != null) {
-      // Any reconfiguration data that we send shortly before the flush may be discarded. We
-      // avoid this issue by sending reconfiguration data following every flush.
-      codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+    shouldSkipOutputBuffer = false;
+
+    waitingForKeys = false;
+    decodeOnlyPresentationTimestamps.clear();
+    codecDrainState = DRAIN_STATE_NONE;
+    codecDrainAction = DRAIN_ACTION_NONE;
+    // Reconfiguration data sent shortly before the flush may not have been processed by the
+    // decoder. If the codec has been reconfigured we always send reconfiguration data again to
+    // guarantee that it's processed.
+    codecReconfigurationState =
+        codecReconfigured ? RECONFIGURATION_STATE_WRITE_PENDING : RECONFIGURATION_STATE_NONE;
+    return false;
+  }
+
+  /** Reads into {@link #flagsOnlyBuffer} and returns whether a format was read. */
+  private boolean readToFlagsOnlyBuffer(boolean requireFormat) throws ExoPlaybackException {
+    flagsOnlyBuffer.clear();
+    int result = readSource(formatHolder, flagsOnlyBuffer, requireFormat);
+    if (result == C.RESULT_FORMAT_READ) {
+      onInputFormatChanged(formatHolder.format);
+      return true;
+    } else if (result == C.RESULT_BUFFER_READ && flagsOnlyBuffer.isEndOfStream()) {
+      inputStreamEnded = true;
+      processEndOfStream();
     }
+    return false;
   }
 
-  private boolean initCodecWithFallback(MediaCrypto crypto, boolean drmSessionRequiresSecureDecoder)
+  private void maybeInitCodecWithFallback(
+      MediaCrypto crypto, boolean mediaCryptoRequiresSecureDecoder)
       throws DecoderInitializationException {
     if (availableCodecInfos == null) {
       try {
-        availableCodecInfos =
-            new ArrayDeque<>(getAvailableCodecInfos(drmSessionRequiresSecureDecoder));
+        List<MediaCodecInfo> allAvailableCodecInfos =
+            getAvailableCodecInfos(mediaCryptoRequiresSecureDecoder);
+        if (enableDecoderFallback) {
+          availableCodecInfos = new ArrayDeque<>(allAvailableCodecInfos);
+        } else {
+          availableCodecInfos =
+              new ArrayDeque<>(Collections.singletonList(allAvailableCodecInfos.get(0)));
+        }
         preferredDecoderInitializationException = null;
       } catch (DecoderQueryException e) {
         throw new DecoderInitializationException(
-            format,
+            inputFormat,
             e,
-            drmSessionRequiresSecureDecoder,
+            mediaCryptoRequiresSecureDecoder,
             DecoderInitializationException.DECODER_QUERY_ERROR);
       }
     }
 
     if (availableCodecInfos.isEmpty()) {
       throw new DecoderInitializationException(
-          format,
+          inputFormat,
           /* cause= */ null,
-          drmSessionRequiresSecureDecoder,
+          mediaCryptoRequiresSecureDecoder,
           DecoderInitializationException.NO_SUITABLE_DECODER_ERROR);
     }
 
-    while (true) {
+    while (codec == null) {
       MediaCodecInfo codecInfo = availableCodecInfos.peekFirst();
       if (!shouldInitCodec(codecInfo)) {
-        return false;
+        return;
       }
       try {
         initCodec(codecInfo, crypto);
-        return true;
       } catch (Exception e) {
         Log.w(TAG, "Failed to initialize decoder: " + codecInfo, e);
         // This codec failed to initialize, so fall back to the next codec in the list (if any). We
@@ -752,7 +781,7 @@ private boolean initCodecWithFallback(MediaCrypto crypto, boolean drmSessionRequ
         availableCodecInfos.removeFirst();
         DecoderInitializationException exception =
             new DecoderInitializationException(
-                format, e, drmSessionRequiresSecureDecoder, codecInfo.name);
+                inputFormat, e, mediaCryptoRequiresSecureDecoder, codecInfo.name);
         if (preferredDecoderInitializationException == null) {
           preferredDecoderInitializationException = exception;
         } else {
@@ -764,23 +793,26 @@ private boolean initCodecWithFallback(MediaCrypto crypto, boolean drmSessionRequ
         }
       }
     }
+
+    availableCodecInfos = null;
   }
 
-  private List<MediaCodecInfo> getAvailableCodecInfos(boolean drmSessionRequiresSecureDecoder)
+  private List<MediaCodecInfo> getAvailableCodecInfos(boolean mediaCryptoRequiresSecureDecoder)
       throws DecoderQueryException {
     List<MediaCodecInfo> codecInfos =
-        getDecoderInfos(mediaCodecSelector, format, drmSessionRequiresSecureDecoder);
-    if (codecInfos.isEmpty() && drmSessionRequiresSecureDecoder) {
+        getDecoderInfos(mediaCodecSelector, inputFormat, mediaCryptoRequiresSecureDecoder);
+    if (codecInfos.isEmpty() && mediaCryptoRequiresSecureDecoder) {
       // The drm session indicates that a secure decoder is required, but the device does not
       // have one. Assuming that supportsFormat indicated support for the media being played, we
       // know that it does not require a secure output path. Most CDM implementations allow
       // playback to proceed with a non-secure decoder in this case, so we try our luck.
-      codecInfos = getDecoderInfos(mediaCodecSelector, format, /* requiresSecureDecoder= */ false);
+      codecInfos =
+          getDecoderInfos(mediaCodecSelector, inputFormat, /* requiresSecureDecoder= */ false);
       if (!codecInfos.isEmpty()) {
         Log.w(
             TAG,
             "Drm session requires secure decoder for "
-                + format.sampleMimeType
+                + inputFormat.sampleMimeType
                 + ", but no secure decoder available. Trying to proceed with "
                 + codecInfos
                 + ".");
@@ -793,22 +825,22 @@ private void initCodec(MediaCodecInfo codecInfo, MediaCrypto crypto) throws Exce
     long codecInitializingTimestamp;
     long codecInitializedTimestamp;
     MediaCodec codec = null;
-    String name = codecInfo.name;
-    updateCodecOperatingRate();
-    boolean configureWithOperatingRate = codecOperatingRate > assumedMinimumCodecOperatingRate;
+    String codecName = codecInfo.name;
+
+    float codecOperatingRate =
+        Util.SDK_INT < 23
+            ? CODEC_OPERATING_RATE_UNSET
+            : getCodecOperatingRateV23(rendererOperatingRate, inputFormat, getStreamFormats());
+    if (codecOperatingRate <= assumedMinimumCodecOperatingRate) {
+      codecOperatingRate = CODEC_OPERATING_RATE_UNSET;
+    }
     try {
       codecInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("createCodec:" + name);
-      codec = MediaCodec.createByCodecName(name);
+      TraceUtil.beginSection("createCodec:" + codecName);
+      codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
-      configureCodec(
-          codecInfo,
-          codec,
-          format,
-          crypto,
-          configureWithOperatingRate ? codecOperatingRate : CODEC_OPERATING_RATE_UNSET);
-      codecConfiguredWithOperatingRate = configureWithOperatingRate;
+      configureCodec(codecInfo, codec, inputFormat, crypto, codecOperatingRate);
       TraceUtil.endSection();
       TraceUtil.beginSection("startCodec");
       codec.start();
@@ -822,10 +854,47 @@ private void initCodec(MediaCodecInfo codecInfo, MediaCrypto crypto) throws Exce
       }
       throw e;
     }
+
     this.codec = codec;
     this.codecInfo = codecInfo;
+    this.codecOperatingRate = codecOperatingRate;
+    codecFormat = inputFormat;
+    codecAdaptationWorkaroundMode = codecAdaptationWorkaroundMode(codecName);
+    codecNeedsReconfigureWorkaround = codecNeedsReconfigureWorkaround(codecName);
+    codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, codecFormat);
+    codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
+    codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
+    codecNeedsEosOutputExceptionWorkaround = codecNeedsEosOutputExceptionWorkaround(codecName);
+    codecNeedsMonoChannelCountWorkaround =
+        codecNeedsMonoChannelCountWorkaround(codecName, codecFormat);
+    codecNeedsEosPropagation =
+        codecNeedsEosPropagationWorkaround(codecInfo) || getCodecNeedsEosPropagation();
+
+    resetInputBuffer();
+    resetOutputBuffer();
+    codecHotswapDeadlineMs =
+        getState() == STATE_STARTED
+            ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS)
+            : C.TIME_UNSET;
+    codecReconfigured = false;
+    codecReconfigurationState = RECONFIGURATION_STATE_NONE;
+    codecReceivedEos = false;
+    codecReceivedBuffers = false;
+    codecDrainState = DRAIN_STATE_NONE;
+    codecDrainAction = DRAIN_ACTION_NONE;
+    codecNeedsAdaptationWorkaroundBuffer = false;
+    shouldSkipAdaptationWorkaroundOutputBuffer = false;
+    shouldSkipOutputBuffer = false;
+    waitingForFirstSyncSample = true;
+
+    decoderCounters.decoderInitCount++;
     long elapsed = codecInitializedTimestamp - codecInitializingTimestamp;
-    onCodecInitialized(name, codecInitializedTimestamp, elapsed);
+    onCodecInitialized(codecName, codecInitializedTimestamp, elapsed);
+  }
+
+  private boolean shouldContinueFeeding(long drainStartTimeMs) {
+    return renderTimeLimitMs == C.TIME_UNSET
+        || SystemClock.elapsedRealtime() - drainStartTimeMs < renderTimeLimitMs;
   }
 
   private void getCodecBuffers(MediaCodec codec) {
@@ -872,14 +941,30 @@ private void resetOutputBuffer() {
     outputBuffer = null;
   }
 
+  private void setSourceDrmSession(@Nullable DrmSession<FrameworkMediaCrypto> session) {
+    DrmSession<FrameworkMediaCrypto> previous = sourceDrmSession;
+    sourceDrmSession = session;
+    releaseDrmSessionIfUnused(previous);
+  }
+
+  private void setCodecDrmSession(@Nullable DrmSession<FrameworkMediaCrypto> session) {
+    DrmSession<FrameworkMediaCrypto> previous = codecDrmSession;
+    codecDrmSession = session;
+    releaseDrmSessionIfUnused(previous);
+  }
+
+  private void releaseDrmSessionIfUnused(@Nullable DrmSession<FrameworkMediaCrypto> session) {
+    if (session != null && session != sourceDrmSession && session != codecDrmSession) {
+      drmSessionManager.releaseSession(session);
+    }
+  }
+
   /**
    * @return Whether it may be possible to feed more input data.
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
   private boolean feedInputBuffer() throws ExoPlaybackException {
-    if (codec == null || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
-        || inputStreamEnded) {
-      // We need to reinitialize the codec or the input stream has ended.
+    if (codec == null || codecDrainState == DRAIN_STATE_WAIT_END_OF_STREAM || inputStreamEnded) {
       return false;
     }
 
@@ -892,7 +977,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       buffer.clear();
     }
 
-    if (codecReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
+    if (codecDrainState == DRAIN_STATE_SIGNAL_END_OF_STREAM) {
       // We need to re-initialize the codec. Send an end of stream signal to the existing codec so
       // that it outputs any remaining buffers before we release it.
       if (codecNeedsEosPropagation) {
@@ -902,7 +987,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
         resetInputBuffer();
       }
-      codecReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
+      codecDrainState = DRAIN_STATE_WAIT_END_OF_STREAM;
       return false;
     }
 
@@ -924,8 +1009,8 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       // For adaptive reconfiguration OMX decoders expect all reconfiguration data to be supplied
       // at the start of the buffer that also contains the first frame in the new format.
       if (codecReconfigurationState == RECONFIGURATION_STATE_WRITE_PENDING) {
-        for (int i = 0; i < format.initializationData.size(); i++) {
-          byte[] data = format.initializationData.get(i);
+        for (int i = 0; i < codecFormat.initializationData.size(); i++) {
+          byte[] data = codecFormat.initializationData.get(i);
           buffer.data.put(data);
         }
         codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;
@@ -975,7 +1060,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       }
       return false;
     }
-    if (waitingForFirstSyncFrame && !buffer.isKeyFrame()) {
+    if (waitingForFirstSyncSample && !buffer.isKeyFrame()) {
       buffer.clear();
       if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
         // The buffer we just cleared contained reconfiguration data. We need to re-write this
@@ -984,7 +1069,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       }
       return true;
     }
-    waitingForFirstSyncFrame = false;
+    waitingForFirstSyncSample = false;
     boolean bufferEncrypted = buffer.isEncrypted();
     waitingForKeys = shouldWaitForKeys(bufferEncrypted);
     if (waitingForKeys) {
@@ -1002,9 +1087,9 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       if (buffer.isDecodeOnly()) {
         decodeOnlyPresentationTimestamps.add(presentationTimeUs);
       }
-      if (pendingFormat != null) {
-        formatQueue.add(presentationTimeUs, pendingFormat);
-        pendingFormat = null;
+      if (waitingForFirstSampleInFormat) {
+        formatQueue.add(presentationTimeUs, inputFormat);
+        waitingForFirstSampleInFormat = false;
       }
 
       buffer.flip();
@@ -1028,12 +1113,12 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
   }
 
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (drmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+    if (codecDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
       return false;
     }
-    @DrmSession.State int drmSessionState = drmSession.getState();
+    @DrmSession.State int drmSessionState = codecDrmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+      throw ExoPlaybackException.createForRenderer(codecDrmSession.getError(), getIndex());
     }
     return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
   }
@@ -1057,60 +1142,93 @@ protected void onCodecInitialized(String name, long initializedTimestampMs,
    * Called when a new format is read from the upstream {@link MediaPeriod}.
    *
    * @param newFormat The new format.
-   * @throws ExoPlaybackException If an error occurs reinitializing the {@link MediaCodec}.
+   * @throws ExoPlaybackException If an error occurs re-initializing the {@link MediaCodec}.
    */
   protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
-    Format oldFormat = format;
-    format = newFormat;
-    pendingFormat = newFormat;
+    Format oldFormat = inputFormat;
+    inputFormat = newFormat;
+    waitingForFirstSampleInFormat = true;
 
     boolean drmInitDataChanged =
-        !Util.areEqual(format.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
+        !Util.areEqual(newFormat.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
     if (drmInitDataChanged) {
-      if (format.drmInitData != null) {
+      if (newFormat.drmInitData != null) {
         if (drmSessionManager == null) {
           throw ExoPlaybackException.createForRenderer(
               new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
         }
-        pendingDrmSession = drmSessionManager.acquireSession(Looper.myLooper(), format.drmInitData);
-        if (pendingDrmSession == drmSession) {
-          drmSessionManager.releaseSession(pendingDrmSession);
+        DrmSession<FrameworkMediaCrypto> session =
+            drmSessionManager.acquireSession(Looper.myLooper(), newFormat.drmInitData);
+        if (session == sourceDrmSession || session == codecDrmSession) {
+          // We already had this session. The manager must be reference counting, so release it once
+          // to get the count attributed to this renderer back down to 1.
+          drmSessionManager.releaseSession(session);
         }
+        setSourceDrmSession(session);
       } else {
-        pendingDrmSession = null;
+        setSourceDrmSession(null);
       }
     }
 
-    boolean keepingCodec = false;
-    if (pendingDrmSession == drmSession && codec != null) {
-      switch (canKeepCodec(codec, codecInfo, oldFormat, format)) {
-        case KEEP_CODEC_RESULT_NO:
-          // Do nothing.
-          break;
-        case KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION:
-          keepingCodec = true;
-          break;
-        case KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION:
-          if (!codecNeedsReconfigureWorkaround) {
-            keepingCodec = true;
-            codecReconfigured = true;
-            codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
-            codecNeedsAdaptationWorkaroundBuffer =
-                codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_ALWAYS
-                    || (codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
-                        && format.width == oldFormat.width
-                        && format.height == oldFormat.height);
-          }
-          break;
-        default:
-          throw new IllegalStateException(); // Never happens.
-      }
+    if (codec == null) {
+      maybeInitCodec();
+      return;
     }
 
-    if (!keepingCodec) {
-      reinitializeCodec();
-    } else {
-      updateCodecOperatingRate();
+    // We have an existing codec that we may need to reconfigure or re-initialize. If the existing
+    // codec instance is being kept then its operating rate may need to be updated.
+
+    if ((sourceDrmSession == null && codecDrmSession != null)
+        || (sourceDrmSession != null && codecDrmSession == null)
+        || (sourceDrmSession != null && !codecInfo.secure)
+        || (Util.SDK_INT < 23 && sourceDrmSession != codecDrmSession)) {
+      // We might need to switch between the clear and protected output paths, or we're using DRM
+      // prior to API level 23 where the codec needs to be re-initialized to switch to the new DRM
+      // session.
+      drainAndReinitializeCodec();
+      return;
+    }
+
+    switch (canKeepCodec(codec, codecInfo, codecFormat, newFormat)) {
+      case KEEP_CODEC_RESULT_NO:
+        drainAndReinitializeCodec();
+        break;
+      case KEEP_CODEC_RESULT_YES_WITH_FLUSH:
+        codecFormat = newFormat;
+        updateCodecOperatingRate();
+        if (sourceDrmSession != codecDrmSession) {
+          drainAndUpdateCodecDrmSession();
+        } else {
+          drainAndFlushCodec();
+        }
+        break;
+      case KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION:
+        if (codecNeedsReconfigureWorkaround) {
+          drainAndReinitializeCodec();
+        } else {
+          codecReconfigured = true;
+          codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+          codecNeedsAdaptationWorkaroundBuffer =
+              codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_ALWAYS
+                  || (codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
+                      && newFormat.width == codecFormat.width
+                      && newFormat.height == codecFormat.height);
+          codecFormat = newFormat;
+          updateCodecOperatingRate();
+          if (sourceDrmSession != codecDrmSession) {
+            drainAndUpdateCodecDrmSession();
+          }
+        }
+        break;
+      case KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION:
+        codecFormat = newFormat;
+        updateCodecOperatingRate();
+        if (sourceDrmSession != codecDrmSession) {
+          drainAndUpdateCodecDrmSession();
+        }
+        break;
+      default:
+        throw new IllegalStateException(); // Never happens.
     }
   }
 
@@ -1174,7 +1292,7 @@ public boolean isEnded() {
 
   @Override
   public boolean isReady() {
-    return format != null
+    return inputFormat != null
         && !waitingForKeys
         && (isSourceReady()
             || hasOutputBuffer()
@@ -1203,62 +1321,82 @@ protected long getDequeueOutputBufferTimeoutUs() {
    * @return The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if no codec operating
    *     rate should be set.
    */
-  protected float getCodecOperatingRate(
+  protected float getCodecOperatingRateV23(
       float operatingRate, Format format, Format[] streamFormats) {
     return CODEC_OPERATING_RATE_UNSET;
   }
 
   /**
-   * Updates the codec operating rate, and the codec itself if necessary.
+   * Updates the codec operating rate.
    *
    * @throws ExoPlaybackException If an error occurs releasing or initializing a codec.
    */
   private void updateCodecOperatingRate() throws ExoPlaybackException {
-    if (format == null || Util.SDK_INT < 23) {
-      return;
-    }
-
-    float codecOperatingRate =
-        getCodecOperatingRate(rendererOperatingRate, format, getStreamFormats());
-    if (this.codecOperatingRate == codecOperatingRate) {
+    if (Util.SDK_INT < 23) {
       return;
     }
 
-    this.codecOperatingRate = codecOperatingRate;
-    if (codec == null || codecReinitializationState != REINITIALIZATION_STATE_NONE) {
-      // Either no codec, or it's about to be reinitialized anyway.
-    } else if (codecOperatingRate == CODEC_OPERATING_RATE_UNSET
-        && codecConfiguredWithOperatingRate) {
-      // We need to clear the operating rate. The only way to do so is to instantiate a new codec
-      // instance. See [Internal ref: b/71987865].
-      reinitializeCodec();
+    float newCodecOperatingRate =
+        getCodecOperatingRateV23(rendererOperatingRate, codecFormat, getStreamFormats());
+    if (codecOperatingRate == newCodecOperatingRate) {
+      // No change.
+    } else if (newCodecOperatingRate == CODEC_OPERATING_RATE_UNSET) {
+      // The only way to clear the operating rate is to instantiate a new codec instance. See
+      // [Internal ref: b/71987865].
+      drainAndReinitializeCodec();
     } else if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET
-        && (codecConfiguredWithOperatingRate
-            || codecOperatingRate > assumedMinimumCodecOperatingRate)) {
+        || newCodecOperatingRate > assumedMinimumCodecOperatingRate) {
       // We need to set the operating rate, either because we've set it previously or because it's
       // above the assumed minimum rate.
       Bundle codecParameters = new Bundle();
-      codecParameters.putFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
+      codecParameters.putFloat(MediaFormat.KEY_OPERATING_RATE, newCodecOperatingRate);
       codec.setParameters(codecParameters);
-      codecConfiguredWithOperatingRate = true;
+      codecOperatingRate = newCodecOperatingRate;
+    }
+  }
+
+  /** Starts draining the codec for flush. */
+  private void drainAndFlushCodec() {
+    if (codecReceivedBuffers) {
+      codecDrainState = DRAIN_STATE_SIGNAL_END_OF_STREAM;
+      codecDrainAction = DRAIN_ACTION_FLUSH;
     }
   }
 
   /**
-   * Starts the process of releasing the existing codec and initializing a new one. This may occur
-   * immediately, or be deferred until any final output buffers have been dequeued.
+   * Starts draining the codec to update its DRM session. The update may occur immediately if no
+   * buffers have been queued to the codec.
    *
-   * @throws ExoPlaybackException If an error occurs releasing or initializing a codec.
+   * @throws ExoPlaybackException If an error occurs updating the codec's DRM session.
    */
-  private void reinitializeCodec() throws ExoPlaybackException {
-    availableCodecInfos = null;
+  private void drainAndUpdateCodecDrmSession() throws ExoPlaybackException {
+    if (Util.SDK_INT < 23) {
+      // The codec needs to be re-initialized to switch to the source DRM session.
+      drainAndReinitializeCodec();
+      return;
+    }
     if (codecReceivedBuffers) {
-      // Signal end of stream and wait for any final output buffers before re-initialization.
-      codecReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
+      codecDrainState = DRAIN_STATE_SIGNAL_END_OF_STREAM;
+      codecDrainAction = DRAIN_ACTION_UPDATE_DRM_SESSION;
     } else {
-      // There aren't any final output buffers, so perform re-initialization immediately.
-      releaseCodec();
-      maybeInitCodec();
+      // Nothing has been queued to the decoder, so we can do the update immediately.
+      updateDrmSessionOrReinitializeCodecV23();
+    }
+  }
+
+  /**
+   * Starts draining the codec for re-initialization. Re-initialization may occur immediately if no
+   * buffers have been queued to the codec.
+   *
+   * @throws ExoPlaybackException If an error occurs re-initializing a codec.
+   */
+  private void drainAndReinitializeCodec() throws ExoPlaybackException {
+    if (codecReceivedBuffers) {
+      codecDrainState = DRAIN_STATE_SIGNAL_END_OF_STREAM;
+      codecDrainAction = DRAIN_ACTION_REINITIALIZE;
+    } else {
+      // Nothing has been queued to the decoder, so we can re-initialize immediately.
+      reinitializeCodec();
     }
   }
 
@@ -1297,8 +1435,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         }
         /* MediaCodec.INFO_TRY_AGAIN_LATER (-1) or unknown negative return value */
         if (codecNeedsEosPropagation
-            && (inputStreamEnded
-                || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM)) {
+            && (inputStreamEnded || codecDrainState == DRAIN_STATE_WAIT_END_OF_STREAM)) {
           processEndOfStream();
         }
         return false;
@@ -1461,14 +1598,63 @@ protected void renderToEndOfStream() throws ExoPlaybackException {
    * @throws ExoPlaybackException If an error occurs processing the signal.
    */
   private void processEndOfStream() throws ExoPlaybackException {
-    if (codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
-      // We're waiting to re-initialize the codec, and have now processed all final buffers.
-      releaseCodec();
-      maybeInitCodec();
-    } else {
-      outputStreamEnded = true;
-      renderToEndOfStream();
+    switch (codecDrainAction) {
+      case DRAIN_ACTION_REINITIALIZE:
+        reinitializeCodec();
+        break;
+      case DRAIN_ACTION_UPDATE_DRM_SESSION:
+        updateDrmSessionOrReinitializeCodecV23();
+        break;
+      case DRAIN_ACTION_FLUSH:
+        flushOrReinitializeCodec();
+        break;
+      case DRAIN_ACTION_NONE:
+      default:
+        outputStreamEnded = true;
+        renderToEndOfStream();
+        break;
+    }
+  }
+
+  private void reinitializeCodec() throws ExoPlaybackException {
+    releaseCodec();
+    maybeInitCodec();
+  }
+
+  @TargetApi(23)
+  private void updateDrmSessionOrReinitializeCodecV23() throws ExoPlaybackException {
+    FrameworkMediaCrypto sessionMediaCrypto = sourceDrmSession.getMediaCrypto();
+    if (sessionMediaCrypto == null) {
+      // We'd only expect this to happen if the CDM from which the pending session is obtained needs
+      // provisioning. This is unlikely to happen (it probably requires a switch from one DRM scheme
+      // to another, where the new CDM hasn't been used before and needs provisioning). It would be
+      // possible to handle this case more efficiently (i.e. with a new renderer state that waits
+      // for provisioning to finish and then calls mediaCrypto.setMediaDrmSession), but the extra
+      // complexity is not warranted given how unlikely the case is to occur.
+      reinitializeCodec();
+      return;
+    }
+    if (C.PLAYREADY_UUID.equals(sessionMediaCrypto.uuid)) {
+      // The PlayReady CDM does not implement setMediaDrmSession.
+      // TODO: Add API check once [Internal ref: b/128835874] is fixed.
+      reinitializeCodec();
+      return;
+    }
+
+    if (flushOrReinitializeCodec()) {
+      // The codec was reinitialized. The new codec will be using the new DRM session, so there's
+      // nothing more to do.
+      return;
+    }
+
+    try {
+      mediaCrypto.setMediaDrmSession(sessionMediaCrypto.sessionId);
+    } catch (MediaCryptoException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
+    setCodecDrmSession(sourceDrmSession);
+    codecDrainState = DRAIN_STATE_NONE;
+    codecDrainAction = DRAIN_ACTION_NONE;
   }
 
   private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
@@ -1486,7 +1672,7 @@ private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
 
   private static MediaCodec.CryptoInfo getFrameworkCryptoInfo(
       DecoderInputBuffer buffer, int adaptiveReconfigurationBytes) {
-    MediaCodec.CryptoInfo cryptoInfo = buffer.cryptoInfo.getFrameworkCryptoInfoV16();
+    MediaCodec.CryptoInfo cryptoInfo = buffer.cryptoInfo.getFrameworkCryptoInfo();
     if (adaptiveReconfigurationBytes == 0) {
       return cryptoInfo;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
index d92e93d45b..41cb4ee04a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
@@ -16,9 +16,8 @@
 package com.google.android.exoplayer2.mediacodec;
 
 import android.media.MediaCodec;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -33,35 +32,11 @@
   MediaCodecSelector DEFAULT =
       new MediaCodecSelector() {
         @Override
-        public List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean requiresSecureDecoder)
+        public List<MediaCodecInfo> getDecoderInfos(
+            String mimeType, boolean requiresSecureDecoder, boolean requiresTunnelingDecoder)
             throws DecoderQueryException {
-          List<MediaCodecInfo> decoderInfos =
-              MediaCodecUtil.getDecoderInfos(mimeType, requiresSecureDecoder);
-          return decoderInfos.isEmpty()
-              ? Collections.emptyList()
-              : Collections.singletonList(decoderInfos.get(0));
-        }
-
-        @Override
-        public @Nullable MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
-          return MediaCodecUtil.getPassthroughDecoderInfo();
-        }
-      };
-
-  /**
-   * A {@link MediaCodecSelector} that returns a list of decoders in priority order, allowing
-   * fallback to less preferred decoders if initialization fails.
-   *
-   * <p>Note: if a hardware-accelerated video decoder fails to initialize, this selector may provide
-   * a software video decoder to use as a fallback. Using software decoding can be inefficient, and
-   * the decoder may be too slow to keep up with the playback position.
-   */
-  MediaCodecSelector DEFAULT_WITH_FALLBACK =
-      new MediaCodecSelector() {
-        @Override
-        public List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean requiresSecureDecoder)
-            throws DecoderQueryException {
-          return MediaCodecUtil.getDecoderInfos(mimeType, requiresSecureDecoder);
+          return MediaCodecUtil.getDecoderInfos(
+              mimeType, requiresSecureDecoder, requiresTunnelingDecoder);
         }
 
         @Override
@@ -75,10 +50,12 @@
    *
    * @param mimeType The MIME type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
+   * @param requiresTunnelingDecoder Whether a tunneling decoder is required.
    * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean requiresSecureDecoder)
+  List<MediaCodecInfo> getDecoderInfos(
+      String mimeType, boolean requiresSecureDecoder, boolean requiresTunnelingDecoder)
       throws DecoderQueryException;
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 4d971d461e..3211f7ea8e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -20,7 +20,7 @@
 import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCodecList;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Pair;
 import android.util.SparseIntArray;
@@ -39,7 +39,6 @@
 /**
  * A utility class for querying the available codecs.
  */
-@TargetApi(16)
 @SuppressLint("InlinedApi")
 public final class MediaCodecUtil {
 
@@ -59,8 +58,6 @@ private DecoderQueryException(Throwable cause) {
 
   private static final String TAG = "MediaCodecUtil";
   private static final Pattern PROFILE_PATTERN = Pattern.compile("^\\D?(\\d+)$");
-  private static final RawAudioCodecComparator RAW_AUDIO_CODEC_COMPARATOR =
-      new RawAudioCodecComparator();
 
   private static final HashMap<CodecKey, List<MediaCodecInfo>> decoderInfosCache = new HashMap<>();
 
@@ -74,6 +71,11 @@ private DecoderQueryException(Throwable cause) {
   private static final Map<String, Integer> HEVC_CODEC_STRING_TO_PROFILE_LEVEL;
   private static final String CODEC_ID_HEV1 = "hev1";
   private static final String CODEC_ID_HVC1 = "hvc1";
+  // Dolby Vision.
+  private static final Map<String, Integer> DOLBY_VISION_STRING_TO_PROFILE;
+  private static final Map<String, Integer> DOLBY_VISION_STRING_TO_LEVEL;
+  private static final String CODEC_ID_DVHE = "dvhe";
+  private static final String CODEC_ID_DVH1 = "dvh1";
   // MP4A AAC.
   private static final SparseIntArray MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE;
   private static final String CODEC_ID_MP4A = "mp4a";
@@ -85,17 +87,19 @@ private MediaCodecUtil() {}
 
   /**
    * Optional call to warm the codec cache for a given mime type.
-   * <p>
-   * Calling this method may speed up subsequent calls to {@link #getDecoderInfo(String, boolean)}
-   * and {@link #getDecoderInfos(String, boolean)}.
+   *
+   * <p>Calling this method may speed up subsequent calls to {@link #getDecoderInfo(String, boolean,
+   * boolean)} and {@link #getDecoderInfos(String, boolean, boolean)}.
    *
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
+   * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
+   *     tunneling really is required.
    */
-  public static void warmDecoderInfoCache(String mimeType, boolean secure) {
+  public static void warmDecoderInfoCache(String mimeType, boolean secure, boolean tunneling) {
     try {
-      getDecoderInfos(mimeType, secure);
+      getDecoderInfos(mimeType, secure, tunneling);
     } catch (DecoderQueryException e) {
       // Codec warming is best effort, so we can swallow the exception.
       Log.e(TAG, "Codec warming failed", e);
@@ -108,8 +112,10 @@ public static void warmDecoderInfoCache(String mimeType, boolean secure) {
    * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static @Nullable MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
-    MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.AUDIO_RAW, /* secure= */ false);
+  @Nullable
+  public static MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
+    MediaCodecInfo decoderInfo =
+        getDecoderInfo(MimeTypes.AUDIO_RAW, /* secure= */ false, /* tunneling= */ false);
     return decoderInfo == null ? null : MediaCodecInfo.newPassthroughInstance(decoderInfo.name);
   }
 
@@ -119,12 +125,15 @@ public static void warmDecoderInfoCache(String mimeType, boolean secure) {
    * @param mimeType The MIME type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
+   * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
+   *     tunneling really is required.
    * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static @Nullable MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
+  @Nullable
+  public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boolean tunneling)
       throws DecoderQueryException {
-    List<MediaCodecInfo> decoderInfos = getDecoderInfos(mimeType, secure);
+    List<MediaCodecInfo> decoderInfos = getDecoderInfos(mimeType, secure, tunneling);
     return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
   }
 
@@ -135,19 +144,23 @@ public static void warmDecoderInfoCache(String mimeType, boolean secure) {
    * @param mimeType The MIME type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
+   * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
+   *     tunneling really is required.
    * @return A list of all {@link MediaCodecInfo}s for the given mime type, in the order given by
    *     {@link MediaCodecList}.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static synchronized List<MediaCodecInfo> getDecoderInfos(String mimeType, boolean secure)
-      throws DecoderQueryException {
-    CodecKey key = new CodecKey(mimeType, secure);
+  public static synchronized List<MediaCodecInfo> getDecoderInfos(
+      String mimeType, boolean secure, boolean tunneling) throws DecoderQueryException {
+    CodecKey key = new CodecKey(mimeType, secure, tunneling);
     List<MediaCodecInfo> cachedDecoderInfos = decoderInfosCache.get(key);
     if (cachedDecoderInfos != null) {
       return cachedDecoderInfos;
     }
-    MediaCodecListCompat mediaCodecList = Util.SDK_INT >= 21
-        ? new MediaCodecListCompatV21(secure) : new MediaCodecListCompatV16();
+    MediaCodecListCompat mediaCodecList =
+        Util.SDK_INT >= 21
+            ? new MediaCodecListCompatV21(secure, tunneling)
+            : new MediaCodecListCompatV16();
     ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
@@ -161,7 +174,7 @@ public static void warmDecoderInfoCache(String mimeType, boolean secure) {
     }
     if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
       // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
-      CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure);
+      CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure, key.tunneling);
       ArrayList<MediaCodecInfo> eac3DecoderInfos =
           getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);
       decoderInfos.addAll(eac3DecoderInfos);
@@ -180,7 +193,8 @@ public static void warmDecoderInfoCache(String mimeType, boolean secure) {
   public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     if (maxH264DecodableFrameSize == -1) {
       int result = 0;
-      MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
+      MediaCodecInfo decoderInfo =
+          getDecoderInfo(MimeTypes.VIDEO_H264, /* secure= */ false, /* tunneling= */ false);
       if (decoderInfo != null) {
         for (CodecProfileLevel profileLevel : decoderInfo.getProfileLevels()) {
           result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
@@ -198,22 +212,28 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
    * Returns profile and level (as defined by {@link CodecProfileLevel}) corresponding to the given
    * codec description string (as defined by RFC 6381).
    *
-   * @param codec A codec description string, as defined by RFC 6381.
+   * @param codec A codec description string, as defined by RFC 6381, or {@code null} if not known.
    * @return A pair (profile constant, level constant) if {@code codec} is well-formed and
    *     recognized, or null otherwise
    */
-  public static @Nullable Pair<Integer, Integer> getCodecProfileAndLevel(String codec) {
+  @Nullable
+  public static Pair<Integer, Integer> getCodecProfileAndLevel(@Nullable String codec) {
     if (codec == null) {
       return null;
     }
+    // TODO: Check codec profile/level for AV1 once targeting Android Q and [Internal: b/128552878]
+    // has been fixed.
     String[] parts = codec.split("\\.");
     switch (parts[0]) {
-      case CODEC_ID_HEV1:
-      case CODEC_ID_HVC1:
-        return getHevcProfileAndLevel(codec, parts);
       case CODEC_ID_AVC1:
       case CODEC_ID_AVC2:
         return getAvcProfileAndLevel(codec, parts);
+      case CODEC_ID_HEV1:
+      case CODEC_ID_HVC1:
+        return getHevcProfileAndLevel(codec, parts);
+      case CODEC_ID_DVHE:
+      case CODEC_ID_DVH1:
+        return getDolbyVisionProfileAndLevel(codec, parts);
       case CODEC_ID_MP4A:
         return getAacCodecProfileAndLevel(codec, parts);
       default:
@@ -244,36 +264,58 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       // Note: MediaCodecList is sorted by the framework such that the best decoders come first.
       for (int i = 0; i < numberOfCodecs; i++) {
         android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
-        String codecName = codecInfo.getName();
-        if (isCodecUsableDecoder(codecInfo, codecName, secureDecodersExplicit, requestedMimeType)) {
-          for (String supportedType : codecInfo.getSupportedTypes()) {
-            if (supportedType.equalsIgnoreCase(mimeType)) {
-              try {
-                CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
-                boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
-                boolean forceDisableAdaptive = codecNeedsDisableAdaptationWorkaround(codecName);
-                if ((secureDecodersExplicit && key.secure == secure)
-                    || (!secureDecodersExplicit && !key.secure)) {
-                  decoderInfos.add(MediaCodecInfo.newInstance(codecName, mimeType, capabilities,
-                      forceDisableAdaptive, false));
-                } else if (!secureDecodersExplicit && secure) {
-                  decoderInfos.add(MediaCodecInfo.newInstance(codecName + ".secure", mimeType,
-                      capabilities, forceDisableAdaptive, true));
-                  // It only makes sense to have one synthesized secure decoder, return immediately.
-                  return decoderInfos;
-                }
-              } catch (Exception e) {
-                if (Util.SDK_INT <= 23 && !decoderInfos.isEmpty()) {
-                  // Suppress error querying secondary codec capabilities up to API level 23.
-                  Log.e(TAG, "Skipping codec " + codecName + " (failed to query capabilities)");
-                } else {
-                  // Rethrow error querying primary codec capabilities, or secondary codec
-                  // capabilities if API level is greater than 23.
-                  Log.e(TAG, "Failed to query codec " + codecName + " (" + supportedType + ")");
-                  throw e;
-                }
-              }
-            }
+        String name = codecInfo.getName();
+        String supportedType =
+            getCodecSupportedType(codecInfo, name, secureDecodersExplicit, requestedMimeType);
+        if (supportedType == null) {
+          continue;
+        }
+        try {
+          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+          boolean tunnelingSupported =
+              mediaCodecList.isFeatureSupported(
+                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+          boolean tunnelingRequired =
+              mediaCodecList.isFeatureRequired(
+                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+          if ((!key.tunneling && tunnelingRequired) || (key.tunneling && !tunnelingSupported)) {
+            continue;
+          }
+          boolean secureSupported =
+              mediaCodecList.isFeatureSupported(
+                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+          boolean secureRequired =
+              mediaCodecList.isFeatureRequired(
+                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+          if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {
+            continue;
+          }
+          boolean forceDisableAdaptive = codecNeedsDisableAdaptationWorkaround(name);
+          if ((secureDecodersExplicit && key.secure == secureSupported)
+              || (!secureDecodersExplicit && !key.secure)) {
+            decoderInfos.add(
+                MediaCodecInfo.newInstance(
+                    name, mimeType, capabilities, forceDisableAdaptive, /* forceSecure= */ false));
+          } else if (!secureDecodersExplicit && secureSupported) {
+            decoderInfos.add(
+                MediaCodecInfo.newInstance(
+                    name + ".secure",
+                    mimeType,
+                    capabilities,
+                    forceDisableAdaptive,
+                    /* forceSecure= */ true));
+            // It only makes sense to have one synthesized secure decoder, return immediately.
+            return decoderInfos;
+          }
+        } catch (Exception e) {
+          if (Util.SDK_INT <= 23 && !decoderInfos.isEmpty()) {
+            // Suppress error querying secondary codec capabilities up to API level 23.
+            Log.e(TAG, "Skipping codec " + name + " (failed to query capabilities)");
+          } else {
+            // Rethrow error querying primary codec capabilities, or secondary codec
+            // capabilities if API level is greater than 23.
+            Log.e(TAG, "Failed to query codec " + name + " (" + supportedType + ")");
+            throw e;
           }
         }
       }
@@ -285,6 +327,46 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     }
   }
 
+  /**
+   * Returns the codec's supported type for decoding {@code requestedMimeType} on the current
+   * device, or {@code null} if the codec can't be used.
+   *
+   * @param info The codec information.
+   * @param name The name of the codec
+   * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
+   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
+   *     key MIME type if the codec key is being considered as a fallback.
+   * @return The codec's supported type for decoding {@code requestedMimeType}, or {@code null} if
+   *     the codec can't be used.
+   */
+  @Nullable
+  private static String getCodecSupportedType(
+      android.media.MediaCodecInfo info,
+      String name,
+      boolean secureDecodersExplicit,
+      String requestedMimeType) {
+    if (isCodecUsableDecoder(info, name, secureDecodersExplicit, requestedMimeType)) {
+      if (requestedMimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
+        // Handle decoders that declare support for DV via MIME types that aren't
+        // video/dolby-vision.
+        if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
+          return "video/hevcdv";
+        } else if ("OMX.RTK.video.decoder".equals(name)
+            || "OMX.realtek.video.decoder.tunneled".equals(name)) {
+          return "video/dv_hevc";
+        }
+      }
+
+      String[] supportedTypes = info.getSupportedTypes();
+      for (String supportedType : supportedTypes) {
+        if (supportedType.equalsIgnoreCase(requestedMimeType)) {
+          return supportedType;
+        }
+      }
+    }
+    return null;
+  }
+
   /**
    * Returns whether the specified codec is usable for decoding on the current device.
    *
@@ -312,33 +394,10 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
       return false;
     }
 
-    // Work around https://github.com/google/ExoPlayer/issues/398.
-    if (Util.SDK_INT < 18 && "OMX.SEC.MP3.Decoder".equals(name)) {
-      return false;
-    }
-
-    // Work around https://github.com/google/ExoPlayer/issues/4519.
-    if ("OMX.SEC.mp3.dec".equals(name)
-        && (Util.MODEL.startsWith("GT-I9152")
-            || Util.MODEL.startsWith("GT-I9515")
-            || Util.MODEL.startsWith("GT-P5220")
-            || Util.MODEL.startsWith("GT-S7580")
-            || Util.MODEL.startsWith("SM-G350")
-            || Util.MODEL.startsWith("SM-G386")
-            || Util.MODEL.startsWith("SM-T231")
-            || Util.MODEL.startsWith("SM-T530"))) {
-      return false;
-    }
-    if ("OMX.brcm.audio.mp3.decoder".equals(name)
-        && (Util.MODEL.startsWith("GT-I9152")
-            || Util.MODEL.startsWith("GT-S7580")
-            || Util.MODEL.startsWith("SM-G350"))) {
-      return false;
-    }
-
     // Work around https://github.com/google/ExoPlayer/issues/1528 and
     // https://github.com/google/ExoPlayer/issues/3171.
-    if (Util.SDK_INT < 18 && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
+    if (Util.SDK_INT < 18
+        && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
         && ("a70".equals(Util.DEVICE)
             || ("Xiaomi".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith("HM")))) {
       return false;
@@ -391,9 +450,12 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     // Work around https://github.com/google/ExoPlayer/issues/548.
     // VP8 decoder on Samsung Galaxy S3/S4/S4 Mini/Tab 3/Note 2 does not render video.
     if (Util.SDK_INT <= 19
-        && "OMX.SEC.vp8.dec".equals(name) && "samsung".equals(Util.MANUFACTURER)
-        && (Util.DEVICE.startsWith("d2") || Util.DEVICE.startsWith("serrano")
-            || Util.DEVICE.startsWith("jflte") || Util.DEVICE.startsWith("santos")
+        && "OMX.SEC.vp8.dec".equals(name)
+        && "samsung".equals(Util.MANUFACTURER)
+        && (Util.DEVICE.startsWith("d2")
+            || Util.DEVICE.startsWith("serrano")
+            || Util.DEVICE.startsWith("jflte")
+            || Util.DEVICE.startsWith("santos")
             || Util.DEVICE.startsWith("t0"))) {
       return false;
     }
@@ -422,7 +484,18 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
    */
   private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decoderInfos) {
     if (MimeTypes.AUDIO_RAW.equals(mimeType)) {
-      Collections.sort(decoderInfos, RAW_AUDIO_CODEC_COMPARATOR);
+      Collections.sort(decoderInfos, new RawAudioCodecComparator());
+    } else if (Util.SDK_INT < 21 && decoderInfos.size() > 1) {
+      String firstCodecName = decoderInfos.get(0).name;
+      if ("OMX.SEC.mp3.dec".equals(firstCodecName)
+          || "OMX.SEC.MP3.Decoder".equals(firstCodecName)
+          || "OMX.brcm.audio.mp3.decoder".equals(firstCodecName)) {
+        // Prefer OMX.google codecs over OMX.SEC.mp3.dec, OMX.SEC.MP3.Decoder and
+        // OMX.brcm.audio.mp3.decoder on older devices. See:
+        // https://github.com/google/ExoPlayer/issues/398 and
+        // https://github.com/google/ExoPlayer/issues/4519.
+        Collections.sort(decoderInfos, new PreferOmxGoogleCodecComparator());
+      }
     }
   }
 
@@ -439,6 +512,34 @@ private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
         && ("OMX.Exynos.AVC.Decoder".equals(name) || "OMX.Exynos.AVC.Decoder.secure".equals(name));
   }
 
+  private static Pair<Integer, Integer> getDolbyVisionProfileAndLevel(
+      String codec, String[] parts) {
+    if (parts.length < 3) {
+      // The codec has fewer parts than required by the Dolby Vision codec string format.
+      Log.w(TAG, "Ignoring malformed Dolby Vision codec string: " + codec);
+      return null;
+    }
+    // The profile_space gets ignored.
+    Matcher matcher = PROFILE_PATTERN.matcher(parts[1]);
+    if (!matcher.matches()) {
+      Log.w(TAG, "Ignoring malformed Dolby Vision codec string: " + codec);
+      return null;
+    }
+    String profileString = matcher.group(1);
+    Integer profile = DOLBY_VISION_STRING_TO_PROFILE.get(profileString);
+    if (profile == null) {
+      Log.w(TAG, "Unknown Dolby Vision profile string: " + profileString);
+      return null;
+    }
+    String levelString = parts[2];
+    Integer level = DOLBY_VISION_STRING_TO_LEVEL.get(levelString);
+    if (level == null) {
+      Log.w(TAG, "Unknown Dolby Vision level string: " + levelString);
+      return null;
+    }
+    return new Pair<>(profile, level);
+  }
+
   private static Pair<Integer, Integer> getHevcProfileAndLevel(String codec, String[] parts) {
     if (parts.length < 4) {
       // The codec has fewer parts than required by the HEVC codec string format.
@@ -461,9 +562,10 @@ private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
       Log.w(TAG, "Unknown HEVC profile string: " + profileString);
       return null;
     }
-    Integer level = HEVC_CODEC_STRING_TO_PROFILE_LEVEL.get(parts[3]);
+    String levelString = parts[3];
+    Integer level = HEVC_CODEC_STRING_TO_PROFILE_LEVEL.get(levelString);
     if (level == null) {
-      Log.w(TAG, "Unknown HEVC level string: " + matcher.group(1));
+      Log.w(TAG, "Unknown HEVC level string: " + levelString);
       return null;
     }
     return new Pair<>(profile, level);
@@ -475,8 +577,8 @@ private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
       Log.w(TAG, "Ignoring malformed AVC codec string: " + codec);
       return null;
     }
-    Integer profileInteger;
-    Integer levelInteger;
+    int profileInteger;
+    int levelInteger;
     try {
       if (parts[1].length() == 6) {
         // Format: avc1.xxccyy, where xx is profile and yy level, both hexadecimal.
@@ -549,8 +651,8 @@ private static int avcLevelToMaxFrameSize(int avcLevel) {
     }
   }
 
-  private static @Nullable Pair<Integer, Integer> getAacCodecProfileAndLevel(
-      String codec, String[] parts) {
+  @Nullable
+  private static Pair<Integer, Integer> getAacCodecProfileAndLevel(String codec, String[] parts) {
     if (parts.length != 3) {
       Log.w(TAG, "Ignoring malformed MP4A codec string: " + codec);
       return null;
@@ -593,12 +695,11 @@ private static int avcLevelToMaxFrameSize(int avcLevel) {
      */
     boolean secureDecodersExplicit();
 
-    /**
-     * Whether secure playback is supported for the given {@link CodecCapabilities}, which should
-     * have been obtained from a {@link android.media.MediaCodecInfo} obtained from this list.
-     */
-    boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capabilities);
+    /** Whether the specified {@link CodecCapabilities} {@code feature} is supported. */
+    boolean isFeatureSupported(String feature, String mimeType, CodecCapabilities capabilities);
 
+    /** Whether the specified {@link CodecCapabilities} {@code feature} is required. */
+    boolean isFeatureRequired(String feature, String mimeType, CodecCapabilities capabilities);
   }
 
   @TargetApi(21)
@@ -608,8 +709,11 @@ private static int avcLevelToMaxFrameSize(int avcLevel) {
 
     private android.media.MediaCodecInfo[] mediaCodecInfos;
 
-    public MediaCodecListCompatV21(boolean includeSecure) {
-      codecKind = includeSecure ? MediaCodecList.ALL_CODECS : MediaCodecList.REGULAR_CODECS;
+    public MediaCodecListCompatV21(boolean includeSecure, boolean includeTunneling) {
+      codecKind =
+          includeSecure || includeTunneling
+              ? MediaCodecList.ALL_CODECS
+              : MediaCodecList.REGULAR_CODECS;
     }
 
     @Override
@@ -630,8 +734,15 @@ public boolean secureDecodersExplicit() {
     }
 
     @Override
-    public boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capabilities) {
-      return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_SecurePlayback);
+    public boolean isFeatureSupported(
+        String feature, String mimeType, CodecCapabilities capabilities) {
+      return capabilities.isFeatureSupported(feature);
+    }
+
+    @Override
+    public boolean isFeatureRequired(
+        String feature, String mimeType, CodecCapabilities capabilities) {
+      return capabilities.isFeatureRequired(feature);
     }
 
     private void ensureMediaCodecInfosInitialized() {
@@ -661,10 +772,18 @@ public boolean secureDecodersExplicit() {
     }
 
     @Override
-    public boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capabilities) {
+    public boolean isFeatureSupported(
+        String feature, String mimeType, CodecCapabilities capabilities) {
       // Secure decoders weren't explicitly listed prior to API level 21. We assume that a secure
       // H264 decoder exists.
-      return MimeTypes.VIDEO_H264.equals(mimeType);
+      return CodecCapabilities.FEATURE_SecurePlayback.equals(feature)
+          && MimeTypes.VIDEO_H264.equals(mimeType);
+    }
+
+    @Override
+    public boolean isFeatureRequired(
+        String feature, String mimeType, CodecCapabilities capabilities) {
+      return false;
     }
 
   }
@@ -673,10 +792,12 @@ public boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capa
 
     public final String mimeType;
     public final boolean secure;
+    public final boolean tunneling;
 
-    public CodecKey(String mimeType, boolean secure) {
+    public CodecKey(String mimeType, boolean secure, boolean tunneling) {
       this.mimeType = mimeType;
       this.secure = secure;
+      this.tunneling = tunneling;
     }
 
     @Override
@@ -685,6 +806,7 @@ public int hashCode() {
       int result = 1;
       result = prime * result + ((mimeType == null) ? 0 : mimeType.hashCode());
       result = prime * result + (secure ? 1231 : 1237);
+      result = prime * result + (tunneling ? 1231 : 1237);
       return result;
     }
 
@@ -697,7 +819,9 @@ public boolean equals(@Nullable Object obj) {
         return false;
       }
       CodecKey other = (CodecKey) obj;
-      return TextUtils.equals(mimeType, other.mimeType) && secure == other.secure;
+      return TextUtils.equals(mimeType, other.mimeType)
+          && secure == other.secure
+          && tunneling == other.tunneling;
     }
 
   }
@@ -728,6 +852,18 @@ private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
     }
   }
 
+  /** Comparator for preferring OMX.google media codecs. */
+  private static final class PreferOmxGoogleCodecComparator implements Comparator<MediaCodecInfo> {
+    @Override
+    public int compare(MediaCodecInfo a, MediaCodecInfo b) {
+      return scoreMediaCodecInfo(a) - scoreMediaCodecInfo(b);
+    }
+
+    private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
+      return mediaCodecInfo.name.startsWith("OMX.google") ? -1 : 0;
+    }
+  }
+
   static {
     AVC_PROFILE_NUMBER_TO_CONST = new SparseIntArray();
     AVC_PROFILE_NUMBER_TO_CONST.put(66, CodecProfileLevel.AVCProfileBaseline);
@@ -786,6 +922,29 @@ private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
     HEVC_CODEC_STRING_TO_PROFILE_LEVEL.put("H183", CodecProfileLevel.HEVCHighTierLevel61);
     HEVC_CODEC_STRING_TO_PROFILE_LEVEL.put("H186", CodecProfileLevel.HEVCHighTierLevel62);
 
+    DOLBY_VISION_STRING_TO_PROFILE = new HashMap<>();
+    DOLBY_VISION_STRING_TO_PROFILE.put("00", CodecProfileLevel.DolbyVisionProfileDvavPer);
+    DOLBY_VISION_STRING_TO_PROFILE.put("01", CodecProfileLevel.DolbyVisionProfileDvavPen);
+    DOLBY_VISION_STRING_TO_PROFILE.put("02", CodecProfileLevel.DolbyVisionProfileDvheDer);
+    DOLBY_VISION_STRING_TO_PROFILE.put("03", CodecProfileLevel.DolbyVisionProfileDvheDen);
+    DOLBY_VISION_STRING_TO_PROFILE.put("04", CodecProfileLevel.DolbyVisionProfileDvheDtr);
+    DOLBY_VISION_STRING_TO_PROFILE.put("05", CodecProfileLevel.DolbyVisionProfileDvheStn);
+    DOLBY_VISION_STRING_TO_PROFILE.put("06", CodecProfileLevel.DolbyVisionProfileDvheDth);
+    DOLBY_VISION_STRING_TO_PROFILE.put("07", CodecProfileLevel.DolbyVisionProfileDvheDtb);
+    DOLBY_VISION_STRING_TO_PROFILE.put("08", CodecProfileLevel.DolbyVisionProfileDvheSt);
+    DOLBY_VISION_STRING_TO_PROFILE.put("09", CodecProfileLevel.DolbyVisionProfileDvavSe);
+
+    DOLBY_VISION_STRING_TO_LEVEL = new HashMap<>();
+    DOLBY_VISION_STRING_TO_LEVEL.put("01", CodecProfileLevel.DolbyVisionLevelHd24);
+    DOLBY_VISION_STRING_TO_LEVEL.put("02", CodecProfileLevel.DolbyVisionLevelHd30);
+    DOLBY_VISION_STRING_TO_LEVEL.put("03", CodecProfileLevel.DolbyVisionLevelFhd24);
+    DOLBY_VISION_STRING_TO_LEVEL.put("04", CodecProfileLevel.DolbyVisionLevelFhd30);
+    DOLBY_VISION_STRING_TO_LEVEL.put("05", CodecProfileLevel.DolbyVisionLevelFhd60);
+    DOLBY_VISION_STRING_TO_LEVEL.put("06", CodecProfileLevel.DolbyVisionLevelUhd24);
+    DOLBY_VISION_STRING_TO_LEVEL.put("07", CodecProfileLevel.DolbyVisionLevelUhd30);
+    DOLBY_VISION_STRING_TO_LEVEL.put("08", CodecProfileLevel.DolbyVisionLevelUhd48);
+    DOLBY_VISION_STRING_TO_LEVEL.put("09", CodecProfileLevel.DolbyVisionLevelUhd60);
+
     MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE = new SparseIntArray();
     MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(1, CodecProfileLevel.AACObjectMain);
     MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(2, CodecProfileLevel.AACObjectLC);
@@ -800,5 +959,4 @@ private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
     MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(39, CodecProfileLevel.AACObjectELD);
     MP4A_AUDIO_OBJECT_TYPE_TO_PROFILE.put(42, CodecProfileLevel.AACObjectXHE);
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaFormatUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaFormatUtil.java
index 3cfefc0736..118445835b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaFormatUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaFormatUtil.java
@@ -15,16 +15,14 @@
  */
 package com.google.android.exoplayer2.mediacodec;
 
-import android.annotation.TargetApi;
 import android.media.MediaFormat;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.video.ColorInfo;
 import java.nio.ByteBuffer;
 import java.util.List;
 
 /** Helper class for configuring {@link MediaFormat} instances. */
-@TargetApi(16)
 public final class MediaFormatUtil {
 
   private MediaFormatUtil() {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
index a2ad7fe2ce..7b4f4c0836 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
@@ -17,9 +17,11 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A collection of metadata entries.
@@ -76,6 +78,33 @@ public int length() {
     return entries[index];
   }
 
+  /**
+   * Returns a copy of this metadata with the entries of the specified metadata appended. Returns
+   * this instance if {@code other} is null.
+   *
+   * @param other The metadata that holds the entries to append. If null, this methods returns this
+   *     instance.
+   * @return The metadata instance with the appended entries.
+   */
+  public Metadata copyWithAppendedEntriesFrom(@Nullable Metadata other) {
+    if (other == null) {
+      return this;
+    }
+    return copyWithAppendedEntries(other.entries);
+  }
+
+  /**
+   * Returns a copy of this metadata with the specified entries appended.
+   *
+   * @param entriesToAppend The entries to append.
+   * @return The metadata instance with the appended entries.
+   */
+  public Metadata copyWithAppendedEntries(Entry... entriesToAppend) {
+    @NullableType Entry[] merged = Arrays.copyOf(entries, entries.length + entriesToAppend.length);
+    System.arraycopy(entriesToAppend, 0, merged, entries.length, entriesToAppend.length);
+    return new Metadata(Util.castNonNullTypeArray(merged));
+  }
+
   @Override
   public boolean equals(@Nullable Object obj) {
     if (this == obj) {
@@ -108,16 +137,16 @@ public void writeToParcel(Parcel dest, int flags) {
     }
   }
 
-  public static final Parcelable.Creator<Metadata> CREATOR = new Parcelable.Creator<Metadata>() {
-    @Override
-    public Metadata createFromParcel(Parcel in) {
-      return new Metadata(in);
-    }
-
-    @Override
-    public Metadata[] newArray(int size) {
-      return new Metadata[0];
-    }
-  };
-
+  public static final Parcelable.Creator<Metadata> CREATOR =
+      new Parcelable.Creator<Metadata>() {
+        @Override
+        public Metadata createFromParcel(Parcel in) {
+          return new Metadata(in);
+        }
+
+        @Override
+        public Metadata[] newArray(int size) {
+          return new Metadata[size];
+        }
+      };
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
index 7e4861a8cb..1d95d32290 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.metadata;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * Decodes metadata from binary data.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
index 028a8eb893..ae4b7db5c9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
+import com.google.android.exoplayer2.metadata.icy.IcyDecoder;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -46,38 +47,43 @@
 
   /**
    * Default {@link MetadataDecoder} implementation.
-   * <p>
-   * The formats supported by this factory are:
+   *
+   * <p>The formats supported by this factory are:
+   *
    * <ul>
-   * <li>ID3 ({@link Id3Decoder})</li>
-   * <li>EMSG ({@link EventMessageDecoder})</li>
-   * <li>SCTE-35 ({@link SpliceInfoDecoder})</li>
+   *   <li>ID3 ({@link Id3Decoder})
+   *   <li>EMSG ({@link EventMessageDecoder})
+   *   <li>SCTE-35 ({@link SpliceInfoDecoder})
+   *   <li>ICY ({@link IcyDecoder})
    * </ul>
    */
-  MetadataDecoderFactory DEFAULT = new MetadataDecoderFactory() {
-
-    @Override
-    public boolean supportsFormat(Format format) {
-      String mimeType = format.sampleMimeType;
-      return MimeTypes.APPLICATION_ID3.equals(mimeType)
-          || MimeTypes.APPLICATION_EMSG.equals(mimeType)
-          || MimeTypes.APPLICATION_SCTE35.equals(mimeType);
-    }
-
-    @Override
-    public MetadataDecoder createDecoder(Format format) {
-      switch (format.sampleMimeType) {
-        case MimeTypes.APPLICATION_ID3:
-          return new Id3Decoder();
-        case MimeTypes.APPLICATION_EMSG:
-          return new EventMessageDecoder();
-        case MimeTypes.APPLICATION_SCTE35:
-          return new SpliceInfoDecoder();
-        default:
-          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
-      }
-    }
+  MetadataDecoderFactory DEFAULT =
+      new MetadataDecoderFactory() {
 
-  };
+        @Override
+        public boolean supportsFormat(Format format) {
+          String mimeType = format.sampleMimeType;
+          return MimeTypes.APPLICATION_ID3.equals(mimeType)
+              || MimeTypes.APPLICATION_EMSG.equals(mimeType)
+              || MimeTypes.APPLICATION_SCTE35.equals(mimeType)
+              || MimeTypes.APPLICATION_ICY.equals(mimeType);
+        }
 
+        @Override
+        public MetadataDecoder createDecoder(Format format) {
+          switch (format.sampleMimeType) {
+            case MimeTypes.APPLICATION_ID3:
+              return new Id3Decoder();
+            case MimeTypes.APPLICATION_EMSG:
+              return new EventMessageDecoder();
+            case MimeTypes.APPLICATION_SCTE35:
+              return new SpliceInfoDecoder();
+            case MimeTypes.APPLICATION_ICY:
+              return new IcyDecoder();
+            default:
+              throw new IllegalArgumentException(
+                  "Attempted to create decoder for unsupported format");
+          }
+        }
+      };
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index 864616e810..d360224872 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -19,7 +19,7 @@
 import android.os.Handler.Callback;
 import android.os.Looper;
 import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
index 7d70d9de1c..ca1e390181 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
@@ -44,13 +44,6 @@
    */
   public final long durationMs;
 
-  /**
-   * The presentation time value of this event message in microseconds.
-   * <p>
-   * Except in special cases, application code should <em>not</em> use this field.
-   */
-  public final long presentationTimeUs;
-
   /**
    * The instance identifier.
    */
@@ -70,22 +63,19 @@
    * @param durationMs The duration of the event in milliseconds.
    * @param id The instance identifier.
    * @param messageData The body of the message.
-   * @param presentationTimeUs The presentation time value of this event message in microseconds.
    */
-  public EventMessage(String schemeIdUri, String value, long durationMs, long id,
-      byte[] messageData, long presentationTimeUs) {
+  public EventMessage(
+      String schemeIdUri, String value, long durationMs, long id, byte[] messageData) {
     this.schemeIdUri = schemeIdUri;
     this.value = value;
     this.durationMs = durationMs;
     this.id = id;
     this.messageData = messageData;
-    this.presentationTimeUs = presentationTimeUs;
   }
 
   /* package */ EventMessage(Parcel in) {
     schemeIdUri = castNonNull(in.readString());
     value = castNonNull(in.readString());
-    presentationTimeUs = in.readLong();
     durationMs = in.readLong();
     id = in.readLong();
     messageData = castNonNull(in.createByteArray());
@@ -97,7 +87,6 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (schemeIdUri != null ? schemeIdUri.hashCode() : 0);
       result = 31 * result + (value != null ? value.hashCode() : 0);
-      result = 31 * result + (int) (presentationTimeUs ^ (presentationTimeUs >>> 32));
       result = 31 * result + (int) (durationMs ^ (durationMs >>> 32));
       result = 31 * result + (int) (id ^ (id >>> 32));
       result = 31 * result + Arrays.hashCode(messageData);
@@ -115,9 +104,11 @@ public boolean equals(@Nullable Object obj) {
       return false;
     }
     EventMessage other = (EventMessage) obj;
-    return presentationTimeUs == other.presentationTimeUs && durationMs == other.durationMs
-        && id == other.id && Util.areEqual(schemeIdUri, other.schemeIdUri)
-        && Util.areEqual(value, other.value) && Arrays.equals(messageData, other.messageData);
+    return durationMs == other.durationMs
+        && id == other.id
+        && Util.areEqual(schemeIdUri, other.schemeIdUri)
+        && Util.areEqual(value, other.value)
+        && Arrays.equals(messageData, other.messageData);
   }
 
   @Override
@@ -136,7 +127,6 @@ public int describeContents() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(schemeIdUri);
     dest.writeString(value);
-    dest.writeLong(presentationTimeUs);
     dest.writeLong(durationMs);
     dest.writeLong(id);
     dest.writeByteArray(messageData);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index 14f678374c..33d79917eb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -15,11 +15,11 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
-import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
@@ -27,12 +27,15 @@
 
 /**
  * Decodes Event Message (emsg) atoms, as defined in ISO/IEC 23009-1:2014, Section 5.10.3.3.
- * <p>
- * Atom data should be provided to the decoder without the full atom header (i.e. starting from the
- * first byte of the scheme_id_uri field).
+ *
+ * <p>Atom data should be provided to the decoder without the full atom header (i.e. starting from
+ * the first byte of the scheme_id_uri field). It is expected that the presentation_time_delta field
+ * should be 0, having already been accounted for by adjusting the sample timestamp.
  */
 public final class EventMessageDecoder implements MetadataDecoder {
 
+  private static final String TAG = "EventMessageDecoder";
+
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
   public Metadata decode(MetadataInputBuffer inputBuffer) {
@@ -43,13 +46,16 @@ public Metadata decode(MetadataInputBuffer inputBuffer) {
     String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
     String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
     long timescale = emsgData.readUnsignedInt();
-    long presentationTimeUs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(),
-        C.MICROS_PER_SECOND, timescale);
+    long presentationTimeDelta = emsgData.readUnsignedInt();
+    if (presentationTimeDelta != 0) {
+      // We expect the source to have accounted for presentation_time_delta by adjusting the sample
+      // timestamp and zeroing the field in the sample data. Log a warning if the field is non-zero.
+      Log.w(TAG, "Ignoring non-zero presentation_time_delta: " + presentationTimeDelta);
+    }
     long durationMs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(), 1000, timescale);
     long id = emsgData.readUnsignedInt();
     byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
-    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData,
-        presentationTimeUs));
+    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
index eca498a6df..dd33d591a7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
@@ -15,10 +15,7 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
+import androidx.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -37,27 +34,22 @@ public EventMessageEncoder() {
   }
 
   /**
-   * Encodes an {@link EventMessage} to a byte array that can be decoded by
-   * {@link EventMessageDecoder}.
+   * Encodes an {@link EventMessage} to a byte array that can be decoded by {@link
+   * EventMessageDecoder}.
    *
    * @param eventMessage The event message to be encoded.
-   * @param timescale Timescale of the event message, in units per second.
    * @return The serialized byte array.
    */
   @Nullable
-  public byte[] encode(EventMessage eventMessage, long timescale) {
-    Assertions.checkArgument(timescale >= 0);
+  public byte[] encode(EventMessage eventMessage) {
     byteArrayOutputStream.reset();
     try {
       writeNullTerminatedString(dataOutputStream, eventMessage.schemeIdUri);
       String nonNullValue = eventMessage.value != null ? eventMessage.value : "";
       writeNullTerminatedString(dataOutputStream, nonNullValue);
-      writeUnsignedInt(dataOutputStream, timescale);
-      long presentationTime = Util.scaleLargeTimestamp(eventMessage.presentationTimeUs,
-          timescale, C.MICROS_PER_SECOND);
-      writeUnsignedInt(dataOutputStream, presentationTime);
-      long duration = Util.scaleLargeTimestamp(eventMessage.durationMs, timescale, 1000);
-      writeUnsignedInt(dataOutputStream, duration);
+      writeUnsignedInt(dataOutputStream, 1000); // timescale
+      writeUnsignedInt(dataOutputStream, 0); // presentation_time_delta
+      writeUnsignedInt(dataOutputStream, eventMessage.durationMs);
       writeUnsignedInt(dataOutputStream, eventMessage.id);
       dataOutputStream.write(eventMessage.messageData);
       dataOutputStream.flush();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
new file mode 100644
index 0000000000..d04cd3a999
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.icy;
+
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoder;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Decodes ICY stream information. */
+public final class IcyDecoder implements MetadataDecoder {
+
+  private static final String TAG = "IcyDecoder";
+
+  private static final Pattern METADATA_ELEMENT = Pattern.compile("(.+?)='(.+?)';");
+  private static final String STREAM_KEY_NAME = "streamtitle";
+  private static final String STREAM_KEY_URL = "streamurl";
+
+  @Override
+  @Nullable
+  @SuppressWarnings("ByteBufferBackingArray")
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int length = buffer.limit();
+    return decode(Util.fromUtf8Bytes(data, 0, length));
+  }
+
+  @Nullable
+  @VisibleForTesting
+  /* package */ Metadata decode(String metadata) {
+    String name = null;
+    String url = null;
+    int index = 0;
+    Matcher matcher = METADATA_ELEMENT.matcher(metadata);
+    while (matcher.find(index)) {
+      String key = Util.toLowerInvariant(matcher.group(1));
+      String value = matcher.group(2);
+      switch (key) {
+        case STREAM_KEY_NAME:
+          name = value;
+          break;
+        case STREAM_KEY_URL:
+          url = value;
+          break;
+        default:
+          Log.w(TAG, "Unrecognized ICY tag: " + name);
+          break;
+      }
+      index = matcher.end();
+    }
+    return (name != null || url != null) ? new Metadata(new IcyInfo(name, url)) : null;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyHeaders.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyHeaders.java
new file mode 100644
index 0000000000..35c5be86d6
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyHeaders.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.icy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.util.List;
+import java.util.Map;
+
+/** ICY headers. */
+public final class IcyHeaders implements Metadata.Entry {
+
+  public static final String REQUEST_HEADER_ENABLE_METADATA_NAME = "Icy-MetaData";
+  public static final String REQUEST_HEADER_ENABLE_METADATA_VALUE = "1";
+
+  private static final String TAG = "IcyHeaders";
+
+  private static final String RESPONSE_HEADER_BITRATE = "icy-br";
+  private static final String RESPONSE_HEADER_GENRE = "icy-genre";
+  private static final String RESPONSE_HEADER_NAME = "icy-name";
+  private static final String RESPONSE_HEADER_URL = "icy-url";
+  private static final String RESPONSE_HEADER_PUB = "icy-pub";
+  private static final String RESPONSE_HEADER_METADATA_INTERVAL = "icy-metaint";
+
+  /**
+   * Parses {@link IcyHeaders} from response headers.
+   *
+   * @param responseHeaders The response headers.
+   * @return The parsed {@link IcyHeaders}, or {@code null} if no ICY headers were present.
+   */
+  @Nullable
+  public static IcyHeaders parse(Map<String, List<String>> responseHeaders) {
+    boolean icyHeadersPresent = false;
+    int bitrate = Format.NO_VALUE;
+    String genre = null;
+    String name = null;
+    String url = null;
+    boolean isPublic = false;
+    int metadataInterval = C.LENGTH_UNSET;
+
+    List<String> headers = responseHeaders.get(RESPONSE_HEADER_BITRATE);
+    if (headers != null) {
+      String bitrateHeader = headers.get(0);
+      try {
+        bitrate = Integer.parseInt(bitrateHeader) * 1000;
+        if (bitrate > 0) {
+          icyHeadersPresent = true;
+        } else {
+          Log.w(TAG, "Invalid bitrate: " + bitrateHeader);
+          bitrate = Format.NO_VALUE;
+        }
+      } catch (NumberFormatException e) {
+        Log.w(TAG, "Invalid bitrate header: " + bitrateHeader);
+      }
+    }
+    headers = responseHeaders.get(RESPONSE_HEADER_GENRE);
+    if (headers != null) {
+      genre = headers.get(0);
+      icyHeadersPresent = true;
+    }
+    headers = responseHeaders.get(RESPONSE_HEADER_NAME);
+    if (headers != null) {
+      name = headers.get(0);
+      icyHeadersPresent = true;
+    }
+    headers = responseHeaders.get(RESPONSE_HEADER_URL);
+    if (headers != null) {
+      url = headers.get(0);
+      icyHeadersPresent = true;
+    }
+    headers = responseHeaders.get(RESPONSE_HEADER_PUB);
+    if (headers != null) {
+      isPublic = headers.get(0).equals("1");
+      icyHeadersPresent = true;
+    }
+    headers = responseHeaders.get(RESPONSE_HEADER_METADATA_INTERVAL);
+    if (headers != null) {
+      String metadataIntervalHeader = headers.get(0);
+      try {
+        metadataInterval = Integer.parseInt(metadataIntervalHeader);
+        if (metadataInterval > 0) {
+          icyHeadersPresent = true;
+        } else {
+          Log.w(TAG, "Invalid metadata interval: " + metadataIntervalHeader);
+          metadataInterval = C.LENGTH_UNSET;
+        }
+      } catch (NumberFormatException e) {
+        Log.w(TAG, "Invalid metadata interval: " + metadataIntervalHeader);
+      }
+    }
+    return icyHeadersPresent
+        ? new IcyHeaders(bitrate, genre, name, url, isPublic, metadataInterval)
+        : null;
+  }
+
+  /**
+   * Bitrate in bits per second ({@code (icy-br * 1000)}), or {@link Format#NO_VALUE} if the header
+   * was not present.
+   */
+  public final int bitrate;
+  /** The genre ({@code icy-genre}). */
+  @Nullable public final String genre;
+  /** The stream name ({@code icy-name}). */
+  @Nullable public final String name;
+  /** The URL of the radio station ({@code icy-url}). */
+  @Nullable public final String url;
+  /**
+   * Whether the radio station is listed ({@code icy-pub}), or {@code false} if the header was not
+   * present.
+   */
+  public final boolean isPublic;
+
+  /**
+   * The interval in bytes between metadata chunks ({@code icy-metaint}), or {@link C#LENGTH_UNSET}
+   * if the header was not present.
+   */
+  public final int metadataInterval;
+
+  /**
+   * @param bitrate See {@link #bitrate}.
+   * @param genre See {@link #genre}.
+   * @param name See {@link #name See}.
+   * @param url See {@link #url}.
+   * @param isPublic See {@link #isPublic}.
+   * @param metadataInterval See {@link #metadataInterval}.
+   */
+  public IcyHeaders(
+      int bitrate,
+      @Nullable String genre,
+      @Nullable String name,
+      @Nullable String url,
+      boolean isPublic,
+      int metadataInterval) {
+    Assertions.checkArgument(metadataInterval == C.LENGTH_UNSET || metadataInterval > 0);
+    this.bitrate = bitrate;
+    this.genre = genre;
+    this.name = name;
+    this.url = url;
+    this.isPublic = isPublic;
+    this.metadataInterval = metadataInterval;
+  }
+
+  /* package */ IcyHeaders(Parcel in) {
+    bitrate = in.readInt();
+    genre = in.readString();
+    name = in.readString();
+    url = in.readString();
+    isPublic = Util.readBoolean(in);
+    metadataInterval = in.readInt();
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    IcyHeaders other = (IcyHeaders) obj;
+    return bitrate == other.bitrate
+        && Util.areEqual(genre, other.genre)
+        && Util.areEqual(name, other.name)
+        && Util.areEqual(url, other.url)
+        && isPublic == other.isPublic
+        && metadataInterval == other.metadataInterval;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + bitrate;
+    result = 31 * result + (genre != null ? genre.hashCode() : 0);
+    result = 31 * result + (name != null ? name.hashCode() : 0);
+    result = 31 * result + (url != null ? url.hashCode() : 0);
+    result = 31 * result + (isPublic ? 1 : 0);
+    result = 31 * result + metadataInterval;
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "IcyHeaders: name=\""
+        + name
+        + "\", genre=\""
+        + genre
+        + "\", bitrate="
+        + bitrate
+        + ", metadataInterval="
+        + metadataInterval;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(bitrate);
+    dest.writeString(genre);
+    dest.writeString(name);
+    dest.writeString(url);
+    Util.writeBoolean(dest, isPublic);
+    dest.writeInt(metadataInterval);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<IcyHeaders> CREATOR =
+      new Parcelable.Creator<IcyHeaders>() {
+
+        @Override
+        public IcyHeaders createFromParcel(Parcel in) {
+          return new IcyHeaders(in);
+        }
+
+        @Override
+        public IcyHeaders[] newArray(int size) {
+          return new IcyHeaders[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
new file mode 100644
index 0000000000..e6b915a6c8
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.icy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Util;
+
+/** ICY in-stream information. */
+public final class IcyInfo implements Metadata.Entry {
+
+  /** The stream title if present, or {@code null}. */
+  @Nullable public final String title;
+  /** The stream title if present, or {@code null}. */
+  @Nullable public final String url;
+
+  /**
+   * @param title See {@link #title}.
+   * @param url See {@link #url}.
+   */
+  public IcyInfo(@Nullable String title, @Nullable String url) {
+    this.title = title;
+    this.url = url;
+  }
+
+  /* package */ IcyInfo(Parcel in) {
+    title = in.readString();
+    url = in.readString();
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    IcyInfo other = (IcyInfo) obj;
+    return Util.areEqual(title, other.title) && Util.areEqual(url, other.url);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (title != null ? title.hashCode() : 0);
+    result = 31 * result + (url != null ? url.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "ICY: title=\"" + title + "\", url=\"" + url + "\"";
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(title);
+    dest.writeString(url);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<IcyInfo> CREATOR =
+      new Parcelable.Creator<IcyInfo>() {
+
+        @Override
+        public IcyInfo createFromParcel(Parcel in) {
+          return new IcyInfo(in);
+        }
+
+        @Override
+        public IcyInfo[] newArray(int size) {
+          return new IcyInfo[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
index 53976da0d1..c233ad61b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
index c48829ae54..6c6057bb7a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.util.Arrays;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
index 7ffb6d028c..bf5d2de6ea 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
@@ -18,7 +18,7 @@
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
 import android.os.Parcel;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
index c4a7c06e49..5d454e84ac 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
@@ -18,7 +18,7 @@
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
 import android.os.Parcel;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
@@ -45,12 +45,13 @@ public ChapterTocFrame(String elementId, boolean isRoot, boolean isOrdered, Stri
     this.subFrames = subFrames;
   }
 
-  /* package */ ChapterTocFrame(Parcel in) {
+  /* package */
+  ChapterTocFrame(Parcel in) {
     super(ID);
     this.elementId = castNonNull(in.readString());
     this.isRoot = in.readByte() != 0;
     this.isOrdered = in.readByte() != 0;
-    this.children = in.createStringArray();
+    this.children = castNonNull(in.createStringArray());
     int subFrameCount = in.readInt();
     subFrames = new Id3Frame[subFrameCount];
     for (int i = 0; i < subFrameCount; i++) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
index 5666e48939..363057f17a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
index 990d8f2e48..6023f76aa1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index 63bf30dd11..fff0828b3a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
@@ -713,9 +713,11 @@ private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int fram
    */
   private static int removeUnsynchronization(ParsableByteArray data, int length) {
     byte[] bytes = data.data;
-    for (int i = data.getPosition(); i + 1 < length; i++) {
+    int startPosition = data.getPosition();
+    for (int i = startPosition; i + 1 < startPosition + length; i++) {
       if ((bytes[i] & 0xFF) == 0xFF && bytes[i + 1] == 0x00) {
-        System.arraycopy(bytes, i + 2, bytes, i + 1, length - i - 2);
+        int relativePosition = i - startPosition;
+        System.arraycopy(bytes, i + 2, bytes, i + 1, length - relativePosition - 2);
         length--;
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java
index c191676ce2..762ca0da00 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/InternalFrame.java
@@ -18,7 +18,7 @@
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
 import android.os.Parcel;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /** Internal ID3 frame that is intended for use by the player. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
index 06a4dd9d2d..0cdd2e038e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
@@ -16,7 +16,8 @@
 package com.google.android.exoplayer2.metadata.id3;
 
 import android.os.Parcel;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
 /** MPEG location lookup table frame. */
@@ -44,13 +45,14 @@ public MlltFrame(
     this.millisecondsDeviations = millisecondsDeviations;
   }
 
-  /* package */ MlltFrame(Parcel in) {
+  /* package */
+  MlltFrame(Parcel in) {
     super(ID);
     this.mpegFramesBetweenReference = in.readInt();
     this.bytesBetweenReference = in.readInt();
     this.millisecondsBetweenReference = in.readInt();
-    this.bytesDeviations = in.createIntArray();
-    this.millisecondsDeviations = in.createIntArray();
+    this.bytesDeviations = Util.castNonNull(in.createIntArray());
+    this.millisecondsDeviations = Util.castNonNull(in.createIntArray());
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
index a10ce229d9..6e53485453 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
index 62175ee90c..8a36276b91 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
index 4b35131bea..8be9ed1881 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
@@ -19,7 +19,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFile.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFile.java
index e37e09a090..a053185435 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFile.java
@@ -15,43 +15,58 @@
  */
 package com.google.android.exoplayer2.offline;
 
-import com.google.android.exoplayer2.offline.DownloadAction.Deserializer;
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.offline.DownloadRequest.UnsupportedRequestException;
 import com.google.android.exoplayer2.util.AtomicFile;
 import com.google.android.exoplayer2.util.Util;
 import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- * Stores and loads {@link DownloadAction}s to/from a file.
+ * Loads {@link DownloadRequest DownloadRequests} from legacy action files.
+ *
+ * @deprecated Legacy action files should be merged into download indices using {@link
+ *     ActionFileUpgradeUtil}.
  */
-public final class ActionFile {
+@Deprecated
+/* package */ final class ActionFile {
 
-  /* package */ static final int VERSION = 0;
+  private static final int VERSION = 0;
 
   private final AtomicFile atomicFile;
-  private final File actionFile;
 
   /**
-   * @param actionFile File to be used to store and load {@link DownloadAction}s.
+   * @param actionFile The file from which {@link DownloadRequest DownloadRequests} will be loaded.
    */
   public ActionFile(File actionFile) {
-    this.actionFile = actionFile;
     atomicFile = new AtomicFile(actionFile);
   }
 
+  /** Returns whether the file or its backup exists. */
+  public boolean exists() {
+    return atomicFile.exists();
+  }
+
+  /** Deletes the action file and its backup. */
+  public void delete() {
+    atomicFile.delete();
+  }
+
   /**
-   * Loads {@link DownloadAction}s from file.
+   * Loads {@link DownloadRequest DownloadRequests} from the file.
    *
-   * @param deserializers {@link Deserializer}s to deserialize DownloadActions.
-   * @return Loaded DownloadActions. If the action file doesn't exists returns an empty array.
-   * @throws IOException If there is an error during loading.
+   * @return The loaded {@link DownloadRequest DownloadRequests}, or an empty array if the file does
+   *     not exist.
+   * @throws IOException If there is an error reading the file.
    */
-  public DownloadAction[] load(Deserializer... deserializers) throws IOException {
-    if (!actionFile.exists()) {
-      return new DownloadAction[0];
+  public DownloadRequest[] load() throws IOException {
+    if (!exists()) {
+      return new DownloadRequest[0];
     }
     InputStream inputStream = null;
     try {
@@ -62,37 +77,88 @@ public ActionFile(File actionFile) {
         throw new IOException("Unsupported action file version: " + version);
       }
       int actionCount = dataInputStream.readInt();
-      DownloadAction[] actions = new DownloadAction[actionCount];
+      ArrayList<DownloadRequest> actions = new ArrayList<>();
       for (int i = 0; i < actionCount; i++) {
-        actions[i] = DownloadAction.deserializeFromStream(deserializers, dataInputStream);
+        try {
+          actions.add(readDownloadRequest(dataInputStream));
+        } catch (UnsupportedRequestException e) {
+          // remove DownloadRequest is not supported. Ignore and continue loading rest.
+        }
       }
-      return actions;
+      return actions.toArray(new DownloadRequest[0]);
     } finally {
       Util.closeQuietly(inputStream);
     }
   }
 
-  /**
-   * Stores {@link DownloadAction}s to file.
-   *
-   * @param downloadActions DownloadActions to store to file.
-   * @throws IOException If there is an error during storing.
-   */
-  public void store(DownloadAction... downloadActions) throws IOException {
-    DataOutputStream output = null;
-    try {
-      output = new DataOutputStream(atomicFile.startWrite());
-      output.writeInt(VERSION);
-      output.writeInt(downloadActions.length);
-      for (DownloadAction action : downloadActions) {
-        DownloadAction.serializeToStream(action, output);
+  private static DownloadRequest readDownloadRequest(DataInputStream input) throws IOException {
+    String type = input.readUTF();
+    int version = input.readInt();
+
+    Uri uri = Uri.parse(input.readUTF());
+    boolean isRemoveAction = input.readBoolean();
+
+    int dataLength = input.readInt();
+    byte[] data;
+    if (dataLength != 0) {
+      data = new byte[dataLength];
+      input.readFully(data);
+    } else {
+      data = null;
+    }
+
+    // Serialized version 0 progressive actions did not contain keys.
+    boolean isLegacyProgressive = version == 0 && DownloadRequest.TYPE_PROGRESSIVE.equals(type);
+    List<StreamKey> keys = new ArrayList<>();
+    if (!isLegacyProgressive) {
+      int keyCount = input.readInt();
+      for (int i = 0; i < keyCount; i++) {
+        keys.add(readKey(type, version, input));
       }
-      atomicFile.endWrite(output);
-      // Avoid calling close twice.
-      output = null;
-    } finally {
-      Util.closeQuietly(output);
     }
+
+    // Serialized version 0 and 1 DASH/HLS/SS actions did not contain a custom cache key.
+    boolean isLegacySegmented =
+        version < 2
+            && (DownloadRequest.TYPE_DASH.equals(type)
+                || DownloadRequest.TYPE_HLS.equals(type)
+                || DownloadRequest.TYPE_SS.equals(type));
+    String customCacheKey = null;
+    if (!isLegacySegmented) {
+      customCacheKey = input.readBoolean() ? input.readUTF() : null;
+    }
+
+    // Serialized version 0, 1 and 2 did not contain an id. We need to generate one.
+    String id = version < 3 ? generateDownloadId(uri, customCacheKey) : input.readUTF();
+
+    if (isRemoveAction) {
+      // Remove actions are not supported anymore.
+      throw new UnsupportedRequestException();
+    }
+    return new DownloadRequest(id, type, uri, keys, customCacheKey, data);
+  }
+
+  private static StreamKey readKey(String type, int version, DataInputStream input)
+      throws IOException {
+    int periodIndex;
+    int groupIndex;
+    int trackIndex;
+
+    // Serialized version 0 HLS/SS actions did not contain a period index.
+    if ((DownloadRequest.TYPE_HLS.equals(type) || DownloadRequest.TYPE_SS.equals(type))
+        && version == 0) {
+      periodIndex = 0;
+      groupIndex = input.readInt();
+      trackIndex = input.readInt();
+    } else {
+      periodIndex = input.readInt();
+      groupIndex = input.readInt();
+      trackIndex = input.readInt();
+    }
+    return new StreamKey(periodIndex, groupIndex, trackIndex);
   }
 
+  private static String generateDownloadId(Uri uri, @Nullable String customCacheKey) {
+    return customCacheKey != null ? customCacheKey : uri.toString();
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java
new file mode 100644
index 0000000000..baf47772ab
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.android.exoplayer2.offline.Download.STATE_QUEUED;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import java.io.File;
+import java.io.IOException;
+
+/** Utility class for upgrading legacy action files into {@link DefaultDownloadIndex}. */
+public final class ActionFileUpgradeUtil {
+
+  /** Provides download IDs during action file upgrade. */
+  public interface DownloadIdProvider {
+
+    /**
+     * Returns a download id for given request.
+     *
+     * @param downloadRequest The request for which an ID is required.
+     * @return A corresponding download ID.
+     */
+    String getId(DownloadRequest downloadRequest);
+  }
+
+  private ActionFileUpgradeUtil() {}
+
+  /**
+   * Merges {@link DownloadRequest DownloadRequests} contained in a legacy action file into a {@link
+   * DefaultDownloadIndex}, deleting the action file if the merge is successful or if {@code
+   * deleteOnFailure} is {@code true}.
+   *
+   * <p>This method must not be called while the {@link DefaultDownloadIndex} is being used by a
+   * {@link DownloadManager}.
+   *
+   * @param actionFilePath The action file path.
+   * @param downloadIdProvider A download ID provider, or {@code null}. If {@code null} then ID of
+   *     each download will be its custom cache key if one is specified, or else its URL.
+   * @param downloadIndex The index into which the requests will be merged.
+   * @param deleteOnFailure Whether to delete the action file if the merge fails.
+   * @param addNewDownloadsAsCompleted Whether to add new downloads as completed.
+   * @throws IOException If an error occurs loading or merging the requests.
+   */
+  @SuppressWarnings("deprecation")
+  public static void upgradeAndDelete(
+      File actionFilePath,
+      @Nullable DownloadIdProvider downloadIdProvider,
+      DefaultDownloadIndex downloadIndex,
+      boolean deleteOnFailure,
+      boolean addNewDownloadsAsCompleted)
+      throws IOException {
+    ActionFile actionFile = new ActionFile(actionFilePath);
+    if (actionFile.exists()) {
+      boolean success = false;
+      try {
+        long nowMs = System.currentTimeMillis();
+        for (DownloadRequest request : actionFile.load()) {
+          if (downloadIdProvider != null) {
+            request = request.copyWithId(downloadIdProvider.getId(request));
+          }
+          mergeRequest(request, downloadIndex, addNewDownloadsAsCompleted, nowMs);
+        }
+        success = true;
+      } finally {
+        if (success || deleteOnFailure) {
+          actionFile.delete();
+        }
+      }
+    }
+  }
+
+  /**
+   * Merges a {@link DownloadRequest} into a {@link DefaultDownloadIndex}.
+   *
+   * @param request The request to be merged.
+   * @param downloadIndex The index into which the request will be merged.
+   * @param addNewDownloadAsCompleted Whether to add new downloads as completed.
+   * @throws IOException If an error occurs merging the request.
+   */
+  /* package */ static void mergeRequest(
+      DownloadRequest request,
+      DefaultDownloadIndex downloadIndex,
+      boolean addNewDownloadAsCompleted,
+      long nowMs)
+      throws IOException {
+    Download download = downloadIndex.getDownload(request.id);
+    if (download != null) {
+      download = DownloadManager.mergeRequest(download, request, download.stopReason, nowMs);
+    } else {
+      download =
+          new Download(
+              request,
+              addNewDownloadAsCompleted ? Download.STATE_COMPLETED : STATE_QUEUED,
+              /* startTimeMs= */ nowMs,
+              /* updateTimeMs= */ nowMs,
+              /* contentLength= */ C.LENGTH_UNSET,
+              Download.STOP_REASON_NONE,
+              Download.FAILURE_REASON_NONE);
+    }
+    downloadIndex.putDownload(download);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
new file mode 100644
index 0000000000..06f308d1e9
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
@@ -0,0 +1,424 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.database.DatabaseIOException;
+import com.google.android.exoplayer2.database.DatabaseProvider;
+import com.google.android.exoplayer2.database.VersionTable;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.List;
+
+/** A {@link DownloadIndex} that uses SQLite to persist {@link Download Downloads}. */
+public final class DefaultDownloadIndex implements WritableDownloadIndex {
+
+  private static final String TABLE_PREFIX = DatabaseProvider.TABLE_PREFIX + "Downloads";
+
+  @VisibleForTesting /* package */ static final int TABLE_VERSION = 2;
+
+  private static final String COLUMN_ID = "id";
+  private static final String COLUMN_TYPE = "title";
+  private static final String COLUMN_URI = "uri";
+  private static final String COLUMN_STREAM_KEYS = "stream_keys";
+  private static final String COLUMN_CUSTOM_CACHE_KEY = "custom_cache_key";
+  private static final String COLUMN_DATA = "data";
+  private static final String COLUMN_STATE = "state";
+  private static final String COLUMN_START_TIME_MS = "start_time_ms";
+  private static final String COLUMN_UPDATE_TIME_MS = "update_time_ms";
+  private static final String COLUMN_CONTENT_LENGTH = "content_length";
+  private static final String COLUMN_STOP_REASON = "stop_reason";
+  private static final String COLUMN_FAILURE_REASON = "failure_reason";
+  private static final String COLUMN_PERCENT_DOWNLOADED = "percent_downloaded";
+  private static final String COLUMN_BYTES_DOWNLOADED = "bytes_downloaded";
+
+  private static final int COLUMN_INDEX_ID = 0;
+  private static final int COLUMN_INDEX_TYPE = 1;
+  private static final int COLUMN_INDEX_URI = 2;
+  private static final int COLUMN_INDEX_STREAM_KEYS = 3;
+  private static final int COLUMN_INDEX_CUSTOM_CACHE_KEY = 4;
+  private static final int COLUMN_INDEX_DATA = 5;
+  private static final int COLUMN_INDEX_STATE = 6;
+  private static final int COLUMN_INDEX_START_TIME_MS = 7;
+  private static final int COLUMN_INDEX_UPDATE_TIME_MS = 8;
+  private static final int COLUMN_INDEX_CONTENT_LENGTH = 9;
+  private static final int COLUMN_INDEX_STOP_REASON = 10;
+  private static final int COLUMN_INDEX_FAILURE_REASON = 11;
+  private static final int COLUMN_INDEX_PERCENT_DOWNLOADED = 12;
+  private static final int COLUMN_INDEX_BYTES_DOWNLOADED = 13;
+
+  private static final String WHERE_ID_EQUALS = COLUMN_ID + " = ?";
+  private static final String WHERE_STATE_IS_DOWNLOADING =
+      COLUMN_STATE + " = " + Download.STATE_DOWNLOADING;
+  private static final String WHERE_STATE_IS_TERMINAL =
+      getStateQuery(Download.STATE_COMPLETED, Download.STATE_FAILED);
+
+  private static final String[] COLUMNS =
+      new String[] {
+        COLUMN_ID,
+        COLUMN_TYPE,
+        COLUMN_URI,
+        COLUMN_STREAM_KEYS,
+        COLUMN_CUSTOM_CACHE_KEY,
+        COLUMN_DATA,
+        COLUMN_STATE,
+        COLUMN_START_TIME_MS,
+        COLUMN_UPDATE_TIME_MS,
+        COLUMN_CONTENT_LENGTH,
+        COLUMN_STOP_REASON,
+        COLUMN_FAILURE_REASON,
+        COLUMN_PERCENT_DOWNLOADED,
+        COLUMN_BYTES_DOWNLOADED,
+      };
+
+  private static final String TABLE_SCHEMA =
+      "("
+          + COLUMN_ID
+          + " TEXT PRIMARY KEY NOT NULL,"
+          + COLUMN_TYPE
+          + " TEXT NOT NULL,"
+          + COLUMN_URI
+          + " TEXT NOT NULL,"
+          + COLUMN_STREAM_KEYS
+          + " TEXT NOT NULL,"
+          + COLUMN_CUSTOM_CACHE_KEY
+          + " TEXT,"
+          + COLUMN_DATA
+          + " BLOB NOT NULL,"
+          + COLUMN_STATE
+          + " INTEGER NOT NULL,"
+          + COLUMN_START_TIME_MS
+          + " INTEGER NOT NULL,"
+          + COLUMN_UPDATE_TIME_MS
+          + " INTEGER NOT NULL,"
+          + COLUMN_CONTENT_LENGTH
+          + " INTEGER NOT NULL,"
+          + COLUMN_STOP_REASON
+          + " INTEGER NOT NULL,"
+          + COLUMN_FAILURE_REASON
+          + " INTEGER NOT NULL,"
+          + COLUMN_PERCENT_DOWNLOADED
+          + " REAL NOT NULL,"
+          + COLUMN_BYTES_DOWNLOADED
+          + " INTEGER NOT NULL)";
+
+  private static final String TRUE = "1";
+
+  private final String name;
+  private final String tableName;
+  private final DatabaseProvider databaseProvider;
+
+  private boolean initialized;
+
+  /**
+   * Creates an instance that stores the {@link Download Downloads} in an SQLite database provided
+   * by a {@link DatabaseProvider}.
+   *
+   * <p>Equivalent to calling {@link #DefaultDownloadIndex(DatabaseProvider, String)} with {@code
+   * name=""}.
+   *
+   * <p>Applications that only have one download index may use this constructor. Applications that
+   * have multiple download indices should call {@link #DefaultDownloadIndex(DatabaseProvider,
+   * String)} to specify a unique name for each index.
+   *
+   * @param databaseProvider Provides the SQLite database in which downloads are persisted.
+   */
+  public DefaultDownloadIndex(DatabaseProvider databaseProvider) {
+    this(databaseProvider, "");
+  }
+
+  /**
+   * Creates an instance that stores the {@link Download Downloads} in an SQLite database provided
+   * by a {@link DatabaseProvider}.
+   *
+   * @param databaseProvider Provides the SQLite database in which downloads are persisted.
+   * @param name The name of the index. This name is incorporated into the names of the SQLite
+   *     tables in which downloads are persisted.
+   */
+  public DefaultDownloadIndex(DatabaseProvider databaseProvider, String name) {
+    this.name = name;
+    this.databaseProvider = databaseProvider;
+    tableName = TABLE_PREFIX + name;
+  }
+
+  @Override
+  @Nullable
+  public Download getDownload(String id) throws DatabaseIOException {
+    ensureInitialized();
+    try (Cursor cursor = getCursor(WHERE_ID_EQUALS, new String[] {id})) {
+      if (cursor.getCount() == 0) {
+        return null;
+      }
+      cursor.moveToNext();
+      return getDownloadForCurrentRow(cursor);
+    } catch (SQLiteException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  @Override
+  public DownloadCursor getDownloads(@Download.State int... states) throws DatabaseIOException {
+    ensureInitialized();
+    Cursor cursor = getCursor(getStateQuery(states), /* selectionArgs= */ null);
+    return new DownloadCursorImpl(cursor);
+  }
+
+  @Override
+  public void putDownload(Download download) throws DatabaseIOException {
+    ensureInitialized();
+    ContentValues values = new ContentValues();
+    values.put(COLUMN_ID, download.request.id);
+    values.put(COLUMN_TYPE, download.request.type);
+    values.put(COLUMN_URI, download.request.uri.toString());
+    values.put(COLUMN_STREAM_KEYS, encodeStreamKeys(download.request.streamKeys));
+    values.put(COLUMN_CUSTOM_CACHE_KEY, download.request.customCacheKey);
+    values.put(COLUMN_DATA, download.request.data);
+    values.put(COLUMN_STATE, download.state);
+    values.put(COLUMN_START_TIME_MS, download.startTimeMs);
+    values.put(COLUMN_UPDATE_TIME_MS, download.updateTimeMs);
+    values.put(COLUMN_CONTENT_LENGTH, download.contentLength);
+    values.put(COLUMN_STOP_REASON, download.stopReason);
+    values.put(COLUMN_FAILURE_REASON, download.failureReason);
+    values.put(COLUMN_PERCENT_DOWNLOADED, download.getPercentDownloaded());
+    values.put(COLUMN_BYTES_DOWNLOADED, download.getBytesDownloaded());
+    try {
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.replaceOrThrow(tableName, /* nullColumnHack= */ null, values);
+    } catch (SQLiteException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  @Override
+  public void removeDownload(String id) throws DatabaseIOException {
+    ensureInitialized();
+    try {
+      databaseProvider.getWritableDatabase().delete(tableName, WHERE_ID_EQUALS, new String[] {id});
+    } catch (SQLiteException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  @Override
+  public void setDownloadingStatesToQueued() throws DatabaseIOException {
+    ensureInitialized();
+    try {
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_STATE, Download.STATE_QUEUED);
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.update(tableName, values, WHERE_STATE_IS_DOWNLOADING, /* whereArgs= */ null);
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  @Override
+  public void setStopReason(int stopReason) throws DatabaseIOException {
+    ensureInitialized();
+    try {
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_STOP_REASON, stopReason);
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.update(tableName, values, WHERE_STATE_IS_TERMINAL, /* whereArgs= */ null);
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  @Override
+  public void setStopReason(String id, int stopReason) throws DatabaseIOException {
+    ensureInitialized();
+    try {
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_STOP_REASON, stopReason);
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.update(
+          tableName,
+          values,
+          WHERE_STATE_IS_TERMINAL + " AND " + WHERE_ID_EQUALS,
+          new String[] {id});
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  private void ensureInitialized() throws DatabaseIOException {
+    if (initialized) {
+      return;
+    }
+    try {
+      SQLiteDatabase readableDatabase = databaseProvider.getReadableDatabase();
+      int version = VersionTable.getVersion(readableDatabase, VersionTable.FEATURE_OFFLINE, name);
+      if (version != TABLE_VERSION) {
+        SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+        writableDatabase.beginTransaction();
+        try {
+          VersionTable.setVersion(
+              writableDatabase, VersionTable.FEATURE_OFFLINE, name, TABLE_VERSION);
+          writableDatabase.execSQL("DROP TABLE IF EXISTS " + tableName);
+          writableDatabase.execSQL("CREATE TABLE " + tableName + " " + TABLE_SCHEMA);
+          writableDatabase.setTransactionSuccessful();
+        } finally {
+          writableDatabase.endTransaction();
+        }
+      }
+      initialized = true;
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  private Cursor getCursor(String selection, @Nullable String[] selectionArgs)
+      throws DatabaseIOException {
+    try {
+      String sortOrder = COLUMN_START_TIME_MS + " ASC";
+      return databaseProvider
+          .getReadableDatabase()
+          .query(
+              tableName,
+              COLUMNS,
+              selection,
+              selectionArgs,
+              /* groupBy= */ null,
+              /* having= */ null,
+              sortOrder);
+    } catch (SQLiteException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  private static String getStateQuery(@Download.State int... states) {
+    if (states.length == 0) {
+      return TRUE;
+    }
+    StringBuilder selectionBuilder = new StringBuilder();
+    selectionBuilder.append(COLUMN_STATE).append(" IN (");
+    for (int i = 0; i < states.length; i++) {
+      if (i > 0) {
+        selectionBuilder.append(',');
+      }
+      selectionBuilder.append(states[i]);
+    }
+    selectionBuilder.append(')');
+    return selectionBuilder.toString();
+  }
+
+  private static Download getDownloadForCurrentRow(Cursor cursor) {
+    DownloadRequest request =
+        new DownloadRequest(
+            /* id= */ cursor.getString(COLUMN_INDEX_ID),
+            /* type= */ cursor.getString(COLUMN_INDEX_TYPE),
+            /* uri= */ Uri.parse(cursor.getString(COLUMN_INDEX_URI)),
+            /* streamKeys= */ decodeStreamKeys(cursor.getString(COLUMN_INDEX_STREAM_KEYS)),
+            /* customCacheKey= */ cursor.getString(COLUMN_INDEX_CUSTOM_CACHE_KEY),
+            /* data= */ cursor.getBlob(COLUMN_INDEX_DATA));
+    DownloadProgress downloadProgress = new DownloadProgress();
+    downloadProgress.bytesDownloaded = cursor.getLong(COLUMN_INDEX_BYTES_DOWNLOADED);
+    downloadProgress.percentDownloaded = cursor.getFloat(COLUMN_INDEX_PERCENT_DOWNLOADED);
+    return new Download(
+        request,
+        /* state= */ cursor.getInt(COLUMN_INDEX_STATE),
+        /* startTimeMs= */ cursor.getLong(COLUMN_INDEX_START_TIME_MS),
+        /* updateTimeMs= */ cursor.getLong(COLUMN_INDEX_UPDATE_TIME_MS),
+        /* contentLength= */ cursor.getLong(COLUMN_INDEX_CONTENT_LENGTH),
+        /* stopReason= */ cursor.getInt(COLUMN_INDEX_STOP_REASON),
+        /* failureReason= */ cursor.getInt(COLUMN_INDEX_FAILURE_REASON),
+        downloadProgress);
+  }
+
+  private static String encodeStreamKeys(List<StreamKey> streamKeys) {
+    StringBuilder stringBuilder = new StringBuilder();
+    for (int i = 0; i < streamKeys.size(); i++) {
+      StreamKey streamKey = streamKeys.get(i);
+      stringBuilder
+          .append(streamKey.periodIndex)
+          .append('.')
+          .append(streamKey.groupIndex)
+          .append('.')
+          .append(streamKey.trackIndex)
+          .append(',');
+    }
+    if (stringBuilder.length() > 0) {
+      stringBuilder.setLength(stringBuilder.length() - 1);
+    }
+    return stringBuilder.toString();
+  }
+
+  private static List<StreamKey> decodeStreamKeys(String encodedStreamKeys) {
+    ArrayList<StreamKey> streamKeys = new ArrayList<>();
+    if (encodedStreamKeys.isEmpty()) {
+      return streamKeys;
+    }
+    String[] streamKeysStrings = Util.split(encodedStreamKeys, ",");
+    for (String streamKeysString : streamKeysStrings) {
+      String[] indices = Util.split(streamKeysString, "\\.");
+      Assertions.checkState(indices.length == 3);
+      streamKeys.add(
+          new StreamKey(
+              Integer.parseInt(indices[0]),
+              Integer.parseInt(indices[1]),
+              Integer.parseInt(indices[2])));
+    }
+    return streamKeys;
+  }
+
+  private static final class DownloadCursorImpl implements DownloadCursor {
+
+    private final Cursor cursor;
+
+    private DownloadCursorImpl(Cursor cursor) {
+      this.cursor = cursor;
+    }
+
+    @Override
+    public Download getDownload() {
+      return getDownloadForCurrentRow(cursor);
+    }
+
+    @Override
+    public int getCount() {
+      return cursor.getCount();
+    }
+
+    @Override
+    public int getPosition() {
+      return cursor.getPosition();
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+      return cursor.moveToPosition(position);
+    }
+
+    @Override
+    public void close() {
+      cursor.close();
+    }
+
+    @Override
+    public boolean isClosed() {
+      return cursor.isClosed();
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloaderFactory.java
new file mode 100644
index 0000000000..d8126d4736
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloaderFactory.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import java.lang.reflect.Constructor;
+import java.util.List;
+
+/**
+ * Default {@link DownloaderFactory}, supporting creation of progressive, DASH, HLS and
+ * SmoothStreaming downloaders. Note that for the latter three, the corresponding library module
+ * must be built into the application.
+ */
+public class DefaultDownloaderFactory implements DownloaderFactory {
+
+  @Nullable private static final Constructor<? extends Downloader> DASH_DOWNLOADER_CONSTRUCTOR;
+  @Nullable private static final Constructor<? extends Downloader> HLS_DOWNLOADER_CONSTRUCTOR;
+  @Nullable private static final Constructor<? extends Downloader> SS_DOWNLOADER_CONSTRUCTOR;
+
+  static {
+    Constructor<? extends Downloader> dashDownloaderConstructor = null;
+    try {
+      // LINT.IfChange
+      dashDownloaderConstructor =
+          getDownloaderConstructor(
+              Class.forName("com.google.android.exoplayer2.source.dash.offline.DashDownloader"));
+      // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+    } catch (ClassNotFoundException e) {
+      // Expected if the app was built without the DASH module.
+    }
+    DASH_DOWNLOADER_CONSTRUCTOR = dashDownloaderConstructor;
+    Constructor<? extends Downloader> hlsDownloaderConstructor = null;
+    try {
+      // LINT.IfChange
+      hlsDownloaderConstructor =
+          getDownloaderConstructor(
+              Class.forName("com.google.android.exoplayer2.source.hls.offline.HlsDownloader"));
+      // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+    } catch (ClassNotFoundException e) {
+      // Expected if the app was built without the HLS module.
+    }
+    HLS_DOWNLOADER_CONSTRUCTOR = hlsDownloaderConstructor;
+    Constructor<? extends Downloader> ssDownloaderConstructor = null;
+    try {
+      // LINT.IfChange
+      ssDownloaderConstructor =
+          getDownloaderConstructor(
+              Class.forName(
+                  "com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloader"));
+      // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+    } catch (ClassNotFoundException e) {
+      // Expected if the app was built without the SmoothStreaming module.
+    }
+    SS_DOWNLOADER_CONSTRUCTOR = ssDownloaderConstructor;
+  }
+
+  private final DownloaderConstructorHelper downloaderConstructorHelper;
+
+  /** @param downloaderConstructorHelper A helper for instantiating downloaders. */
+  public DefaultDownloaderFactory(DownloaderConstructorHelper downloaderConstructorHelper) {
+    this.downloaderConstructorHelper = downloaderConstructorHelper;
+  }
+
+  @Override
+  public Downloader createDownloader(DownloadRequest request) {
+    switch (request.type) {
+      case DownloadRequest.TYPE_PROGRESSIVE:
+        return new ProgressiveDownloader(
+            request.uri, request.customCacheKey, downloaderConstructorHelper);
+      case DownloadRequest.TYPE_DASH:
+        return createDownloader(request, DASH_DOWNLOADER_CONSTRUCTOR);
+      case DownloadRequest.TYPE_HLS:
+        return createDownloader(request, HLS_DOWNLOADER_CONSTRUCTOR);
+      case DownloadRequest.TYPE_SS:
+        return createDownloader(request, SS_DOWNLOADER_CONSTRUCTOR);
+      default:
+        throw new IllegalArgumentException("Unsupported type: " + request.type);
+    }
+  }
+
+  private Downloader createDownloader(
+      DownloadRequest request, @Nullable Constructor<? extends Downloader> constructor) {
+    if (constructor == null) {
+      throw new IllegalStateException("Module missing for: " + request.type);
+    }
+    try {
+      return constructor.newInstance(request.uri, request.streamKeys, downloaderConstructorHelper);
+    } catch (Exception e) {
+      throw new RuntimeException("Failed to instantiate downloader for: " + request.type, e);
+    }
+  }
+
+  // LINT.IfChange
+  private static Constructor<? extends Downloader> getDownloaderConstructor(Class<?> clazz) {
+    try {
+      return clazz
+          .asSubclass(Downloader.class)
+          .getConstructor(Uri.class, List.class, DownloaderConstructorHelper.class);
+    } catch (NoSuchMethodException e) {
+      // The downloader is present, but the expected constructor is missing.
+      throw new RuntimeException("Downloader constructor missing", e);
+    }
+  }
+  // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/Download.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/Download.java
new file mode 100644
index 0000000000..97dff8394e
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/Download.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import androidx.annotation.IntDef;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** Represents state of a download. */
+public final class Download {
+
+  /**
+   * Download states. One of {@link #STATE_QUEUED}, {@link #STATE_STOPPED}, {@link
+   * #STATE_DOWNLOADING}, {@link #STATE_COMPLETED}, {@link #STATE_FAILED}, {@link #STATE_REMOVING}
+   * or {@link #STATE_RESTARTING}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    STATE_QUEUED,
+    STATE_STOPPED,
+    STATE_DOWNLOADING,
+    STATE_COMPLETED,
+    STATE_FAILED,
+    STATE_REMOVING,
+    STATE_RESTARTING
+  })
+  public @interface State {}
+  // Important: These constants are persisted into DownloadIndex. Do not change them.
+  /**
+   * The download is waiting to be started. A download may be queued because the {@link
+   * DownloadManager}
+   *
+   * <ul>
+   *   <li>Is {@link DownloadManager#getDownloadsPaused() paused}
+   *   <li>Has {@link DownloadManager#getRequirements() Requirements} that are not met
+   *   <li>Has already started {@link DownloadManager#getMaxParallelDownloads()
+   *       maxParallelDownloads}
+   * </ul>
+   */
+  public static final int STATE_QUEUED = 0;
+  /** The download is stopped for a specified {@link #stopReason}. */
+  public static final int STATE_STOPPED = 1;
+  /** The download is currently started. */
+  public static final int STATE_DOWNLOADING = 2;
+  /** The download completed. */
+  public static final int STATE_COMPLETED = 3;
+  /** The download failed. */
+  public static final int STATE_FAILED = 4;
+  /** The download is being removed. */
+  public static final int STATE_REMOVING = 5;
+  /** The download will restart after all downloaded data is removed. */
+  public static final int STATE_RESTARTING = 7;
+
+  /** Failure reasons. Either {@link #FAILURE_REASON_NONE} or {@link #FAILURE_REASON_UNKNOWN}. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({FAILURE_REASON_NONE, FAILURE_REASON_UNKNOWN})
+  public @interface FailureReason {}
+  /** The download isn't failed. */
+  public static final int FAILURE_REASON_NONE = 0;
+  /** The download is failed because of unknown reason. */
+  public static final int FAILURE_REASON_UNKNOWN = 1;
+
+  /** The download isn't stopped. */
+  public static final int STOP_REASON_NONE = 0;
+
+  /** The download request. */
+  public final DownloadRequest request;
+  /** The state of the download. */
+  @State public final int state;
+  /** The first time when download entry is created. */
+  public final long startTimeMs;
+  /** The last update time. */
+  public final long updateTimeMs;
+  /** The total size of the content in bytes, or {@link C#LENGTH_UNSET} if unknown. */
+  public final long contentLength;
+  /** The reason the download is stopped, or {@link #STOP_REASON_NONE}. */
+  public final int stopReason;
+  /**
+   * If {@link #state} is {@link #STATE_FAILED} then this is the cause, otherwise {@link
+   * #FAILURE_REASON_NONE}.
+   */
+  @FailureReason public final int failureReason;
+
+  /* package */ final DownloadProgress progress;
+
+  public Download(
+      DownloadRequest request,
+      @State int state,
+      long startTimeMs,
+      long updateTimeMs,
+      long contentLength,
+      int stopReason,
+      @FailureReason int failureReason) {
+    this(
+        request,
+        state,
+        startTimeMs,
+        updateTimeMs,
+        contentLength,
+        stopReason,
+        failureReason,
+        new DownloadProgress());
+  }
+
+  public Download(
+      DownloadRequest request,
+      @State int state,
+      long startTimeMs,
+      long updateTimeMs,
+      long contentLength,
+      int stopReason,
+      @FailureReason int failureReason,
+      DownloadProgress progress) {
+    Assertions.checkNotNull(progress);
+    Assertions.checkState((failureReason == FAILURE_REASON_NONE) == (state != STATE_FAILED));
+    if (stopReason != 0) {
+      Assertions.checkState(state != STATE_DOWNLOADING && state != STATE_QUEUED);
+    }
+    this.request = request;
+    this.state = state;
+    this.startTimeMs = startTimeMs;
+    this.updateTimeMs = updateTimeMs;
+    this.contentLength = contentLength;
+    this.stopReason = stopReason;
+    this.failureReason = failureReason;
+    this.progress = progress;
+  }
+
+  /** Returns whether the download is completed or failed. These are terminal states. */
+  public boolean isTerminalState() {
+    return state == STATE_COMPLETED || state == STATE_FAILED;
+  }
+
+  /** Returns the total number of downloaded bytes. */
+  public long getBytesDownloaded() {
+    return progress.bytesDownloaded;
+  }
+
+  /**
+   * Returns the estimated download percentage, or {@link C#PERCENTAGE_UNSET} if no estimate is
+   * available.
+   */
+  public float getPercentDownloaded() {
+    return progress.percentDownloaded;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java
deleted file mode 100644
index e9868ceea0..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadAction.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/** Contains the necessary parameters for a download or remove action. */
-public abstract class DownloadAction {
-
-  /** Used to deserialize {@link DownloadAction}s. */
-  public abstract static class Deserializer {
-
-    public final String type;
-    public final int version;
-
-    public Deserializer(String type, int version) {
-      this.type = type;
-      this.version = version;
-    }
-
-    /**
-     * Deserializes an action from the {@code input}.
-     *
-     * @param version The version of the serialized action.
-     * @param input The stream from which to read the action.
-     * @see DownloadAction#writeToStream(DataOutputStream)
-     */
-    public abstract DownloadAction readFromStream(int version, DataInputStream input)
-        throws IOException;
-  }
-
-  private static @Nullable Deserializer[] defaultDeserializers;
-
-  /** Returns available default {@link Deserializer}s. */
-  public static synchronized Deserializer[] getDefaultDeserializers() {
-    if (defaultDeserializers != null) {
-      return defaultDeserializers;
-    }
-    Deserializer[] deserializers = new Deserializer[4];
-    int count = 0;
-    deserializers[count++] = ProgressiveDownloadAction.DESERIALIZER;
-    Class<?> clazz;
-    // Full class names used for constructor args so the LINT rule triggers if any of them move.
-    try {
-      // LINT.IfChange
-      clazz = Class.forName("com.google.android.exoplayer2.source.dash.offline.DashDownloadAction");
-      // LINT.ThenChange(../../../../../../../../../dash/proguard-rules.txt)
-      deserializers[count++] = getDeserializer(clazz);
-    } catch (Exception e) {
-      // Do nothing.
-    }
-    try {
-      // LINT.IfChange
-      clazz = Class.forName("com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction");
-      // LINT.ThenChange(../../../../../../../../../hls/proguard-rules.txt)
-      deserializers[count++] = getDeserializer(clazz);
-    } catch (Exception e) {
-      // Do nothing.
-    }
-    try {
-      // LINT.IfChange
-      clazz =
-          Class.forName(
-              "com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction");
-      // LINT.ThenChange(../../../../../../../../../smoothstreaming/proguard-rules.txt)
-      deserializers[count++] = getDeserializer(clazz);
-    } catch (Exception e) {
-      // Do nothing.
-    }
-    defaultDeserializers = Arrays.copyOf(Assertions.checkNotNull(deserializers), count);
-    return defaultDeserializers;
-  }
-
-  /**
-   * Deserializes one action that was serialized with {@link #serializeToStream(DownloadAction,
-   * OutputStream)} from the {@code input}, using the {@link Deserializer}s that supports the
-   * action's type.
-   *
-   * <p>The caller is responsible for closing the given {@link InputStream}.
-   *
-   * @param deserializers {@link Deserializer}s for supported actions.
-   * @param input The stream from which to read the action.
-   * @return The deserialized action.
-   * @throws IOException If there is an IO error reading from {@code input}, or if the action type
-   *     isn't supported by any of the {@code deserializers}.
-   */
-  public static DownloadAction deserializeFromStream(
-      Deserializer[] deserializers, InputStream input) throws IOException {
-    // Don't close the stream as it closes the underlying stream too.
-    DataInputStream dataInputStream = new DataInputStream(input);
-    String type = dataInputStream.readUTF();
-    int version = dataInputStream.readInt();
-    for (Deserializer deserializer : deserializers) {
-      if (type.equals(deserializer.type) && deserializer.version >= version) {
-        return deserializer.readFromStream(version, dataInputStream);
-      }
-    }
-    throw new DownloadException("No deserializer found for:" + type + ", " + version);
-  }
-
-  /** Serializes {@code action} type and data into the {@code output}. */
-  public static void serializeToStream(DownloadAction action, OutputStream output)
-      throws IOException {
-    // Don't close the stream as it closes the underlying stream too.
-    DataOutputStream dataOutputStream = new DataOutputStream(output);
-    dataOutputStream.writeUTF(action.type);
-    dataOutputStream.writeInt(action.version);
-    action.writeToStream(dataOutputStream);
-    dataOutputStream.flush();
-  }
-
-  /** The type of the action. */
-  public final String type;
-  /** The action version. */
-  public final int version;
-  /** The uri being downloaded or removed. */
-  public final Uri uri;
-  /** Whether this is a remove action. If false, this is a download action. */
-  public final boolean isRemoveAction;
-  /** Custom data for this action. May be empty. */
-  public final byte[] data;
-
-  /**
-   * @param type The type of the action.
-   * @param version The action version.
-   * @param uri The uri being downloaded or removed.
-   * @param isRemoveAction Whether this is a remove action. If false, this is a download action.
-   * @param data Optional custom data for this action.
-   */
-  protected DownloadAction(
-      String type, int version, Uri uri, boolean isRemoveAction, @Nullable byte[] data) {
-    this.type = type;
-    this.version = version;
-    this.uri = uri;
-    this.isRemoveAction = isRemoveAction;
-    this.data = data != null ? data : Util.EMPTY_BYTE_ARRAY;
-  }
-
-  /** Serializes itself into a byte array. */
-  public final byte[] toByteArray() {
-    ByteArrayOutputStream output = new ByteArrayOutputStream();
-    try {
-      serializeToStream(this, output);
-    } catch (IOException e) {
-      // ByteArrayOutputStream shouldn't throw IOException.
-      throw new IllegalStateException();
-    }
-    return output.toByteArray();
-  }
-
-  /** Returns whether this is an action for the same media as the {@code other}. */
-  public boolean isSameMedia(DownloadAction other) {
-    return uri.equals(other.uri);
-  }
-
-  /** Returns keys of tracks to be downloaded. */
-  public List<StreamKey> getKeys() {
-    return Collections.emptyList();
-  }
-
-  /** Serializes itself into the {@code output}. */
-  protected abstract void writeToStream(DataOutputStream output) throws IOException;
-
-  /** Creates a {@link Downloader} with the given parameters. */
-  public abstract Downloader createDownloader(
-      DownloaderConstructorHelper downloaderConstructorHelper);
-
-  @SuppressWarnings("EqualsGetClass")
-  @Override
-  public boolean equals(@Nullable Object o) {
-    if (o == null || getClass() != o.getClass()) {
-      return false;
-    }
-    DownloadAction that = (DownloadAction) o;
-    return type.equals(that.type)
-        && version == that.version
-        && uri.equals(that.uri)
-        && isRemoveAction == that.isRemoveAction
-        && Arrays.equals(data, that.data);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = uri.hashCode();
-    result = 31 * result + (isRemoveAction ? 1 : 0);
-    result = 31 * result + Arrays.hashCode(data);
-    return result;
-  }
-
-  private static Deserializer getDeserializer(Class<?> clazz)
-      throws NoSuchFieldException, IllegalAccessException {
-    Object value = clazz.getDeclaredField("DESERIALIZER").get(null);
-    return (Deserializer) Assertions.checkNotNull(value);
-  }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadCursor.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadCursor.java
new file mode 100644
index 0000000000..a1822fca97
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadCursor.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import java.io.Closeable;
+
+/** Provides random read-write access to the result set returned by a database query. */
+public interface DownloadCursor extends Closeable {
+
+  /** Returns the download at the current position. */
+  Download getDownload();
+
+  /** Returns the numbers of downloads in the cursor. */
+  int getCount();
+
+  /**
+   * Returns the current position of the cursor in the download set. The value is zero-based. When
+   * the download set is first returned the cursor will be at positon -1, which is before the first
+   * download. After the last download is returned another call to next() will leave the cursor past
+   * the last entry, at a position of count().
+   *
+   * @return the current cursor position.
+   */
+  int getPosition();
+
+  /**
+   * Move the cursor to an absolute position. The valid range of values is -1 &lt;= position &lt;=
+   * count.
+   *
+   * <p>This method will return true if the request destination was reachable, otherwise, it returns
+   * false.
+   *
+   * @param position the zero-based position to move to.
+   * @return whether the requested move fully succeeded.
+   */
+  boolean moveToPosition(int position);
+
+  /**
+   * Move the cursor to the first download.
+   *
+   * <p>This method will return false if the cursor is empty.
+   *
+   * @return whether the move succeeded.
+   */
+  default boolean moveToFirst() {
+    return moveToPosition(0);
+  }
+
+  /**
+   * Move the cursor to the last download.
+   *
+   * <p>This method will return false if the cursor is empty.
+   *
+   * @return whether the move succeeded.
+   */
+  default boolean moveToLast() {
+    return moveToPosition(getCount() - 1);
+  }
+
+  /**
+   * Move the cursor to the next download.
+   *
+   * <p>This method will return false if the cursor is already past the last entry in the result
+   * set.
+   *
+   * @return whether the move succeeded.
+   */
+  default boolean moveToNext() {
+    return moveToPosition(getPosition() + 1);
+  }
+
+  /**
+   * Move the cursor to the previous download.
+   *
+   * <p>This method will return false if the cursor is already before the first entry in the result
+   * set.
+   *
+   * @return whether the move succeeded.
+   */
+  default boolean moveToPrevious() {
+    return moveToPosition(getPosition() - 1);
+  }
+
+  /** Returns whether the cursor is pointing to the first download. */
+  default boolean isFirst() {
+    return getPosition() == 0 && getCount() != 0;
+  }
+
+  /** Returns whether the cursor is pointing to the last download. */
+  default boolean isLast() {
+    int count = getCount();
+    return getPosition() == (count - 1) && count != 0;
+  }
+
+  /** Returns whether the cursor is pointing to the position before the first download. */
+  default boolean isBeforeFirst() {
+    if (getCount() == 0) {
+      return true;
+    }
+    return getPosition() == -1;
+  }
+
+  /** Returns whether the cursor is pointing to the position after the last download. */
+  default boolean isAfterLast() {
+    if (getCount() == 0) {
+      return true;
+    }
+    return getPosition() == getCount();
+  }
+
+  /** Returns whether the cursor is closed */
+  boolean isClosed();
+
+  @Override
+  void close();
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
index bb82df7a48..8a15c82c89 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
@@ -15,15 +15,77 @@
  */
 package com.google.android.exoplayer2.offline;
 
+import android.net.Uri;
 import android.os.Handler;
-import android.os.Looper;
-import android.support.annotation.Nullable;
+import android.os.HandlerThread;
+import android.os.Message;
+import androidx.annotation.Nullable;
+import android.util.Pair;
+import android.util.SparseIntArray;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.Parameters;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultAllocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
-/** A helper for initializing and removing downloads. */
-public abstract class DownloadHelper {
+/**
+ * A helper for initializing and removing downloads.
+ *
+ * <p>The helper extracts track information from the media, selects tracks for downloading, and
+ * creates {@link DownloadRequest download requests} based on the selected tracks.
+ *
+ * <p>A typical usage of DownloadHelper follows these steps:
+ *
+ * <ol>
+ *   <li>Build the helper using one of the {@code forXXX} methods.
+ *   <li>Prepare the helper using {@link #prepare(Callback)} and wait for the callback.
+ *   <li>Optional: Inspect the selected tracks using {@link #getMappedTrackInfo(int)} and {@link
+ *       #getTrackSelections(int, int)}, and make adjustments using {@link
+ *       #clearTrackSelections(int)}, {@link #replaceTrackSelections(int, Parameters)} and {@link
+ *       #addTrackSelection(int, Parameters)}.
+ *   <li>Create a download request for the selected track using {@link #getDownloadRequest(byte[])}.
+ *   <li>Release the helper using {@link #release()}.
+ * </ol>
+ */
+public final class DownloadHelper {
+
+  /**
+   * The default parameters used for track selection for downloading. This default selects the
+   * highest bitrate audio and video tracks which are supported by the renderers.
+   */
+  public static final DefaultTrackSelector.Parameters DEFAULT_TRACK_SELECTOR_PARAMETERS =
+      new DefaultTrackSelector.ParametersBuilder().setForceHighestSupportedBitrate(true).build();
 
   /** A callback to be notified when the {@link DownloadHelper} is prepared. */
   public interface Callback {
@@ -44,67 +106,887 @@
     void onPrepareError(DownloadHelper helper, IOException e);
   }
 
+  @Nullable private static final Constructor<?> DASH_FACTORY_CONSTRUCTOR;
+  @Nullable private static final Constructor<?> HLS_FACTORY_CONSTRUCTOR;
+  @Nullable private static final Constructor<?> SS_FACTORY_CONSTRUCTOR;
+  @Nullable private static final Method DASH_FACTORY_CREATE_METHOD;
+  @Nullable private static final Method HLS_FACTORY_CREATE_METHOD;
+  @Nullable private static final Method SS_FACTORY_CREATE_METHOD;
+
+  static {
+    Pair<@NullableType Constructor<?>, @NullableType Method> dashFactoryMethods =
+        getMediaSourceFactoryMethods(
+            "com.google.android.exoplayer2.source.dash.DashMediaSource$Factory");
+    DASH_FACTORY_CONSTRUCTOR = dashFactoryMethods.first;
+    DASH_FACTORY_CREATE_METHOD = dashFactoryMethods.second;
+    Pair<@NullableType Constructor<?>, @NullableType Method> hlsFactoryMethods =
+        getMediaSourceFactoryMethods(
+            "com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory");
+    HLS_FACTORY_CONSTRUCTOR = hlsFactoryMethods.first;
+    HLS_FACTORY_CREATE_METHOD = hlsFactoryMethods.second;
+    Pair<@NullableType Constructor<?>, @NullableType Method> ssFactoryMethods =
+        getMediaSourceFactoryMethods(
+            "com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory");
+    SS_FACTORY_CONSTRUCTOR = ssFactoryMethods.first;
+    SS_FACTORY_CREATE_METHOD = ssFactoryMethods.second;
+  }
+
   /**
-   * Initializes the helper for starting a download.
+   * Creates a {@link DownloadHelper} for progressive streams.
    *
-   * @param callback A callback to be notified when preparation completes or fails. The callback
-   *     will be invoked on the calling thread unless that thread does not have an associated {@link
-   *     Looper}, in which case it will be called on the application's main thread.
+   * @param uri A stream {@link Uri}.
+   * @return A {@link DownloadHelper} for progressive streams.
    */
-  public void prepare(final Callback callback) {
-    final Handler handler =
-        new Handler(Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper());
-    new Thread() {
-      @Override
-      public void run() {
-        try {
-          prepareInternal();
-          handler.post(() -> callback.onPrepared(DownloadHelper.this));
-        } catch (final IOException e) {
-          handler.post(() -> callback.onPrepareError(DownloadHelper.this, e));
-        }
-      }
-    }.start();
+  public static DownloadHelper forProgressive(Uri uri) {
+    return forProgressive(uri, /* cacheKey= */ null);
+  }
+
+  /**
+   * Creates a {@link DownloadHelper} for progressive streams.
+   *
+   * @param uri A stream {@link Uri}.
+   * @param cacheKey An optional cache key.
+   * @return A {@link DownloadHelper} for progressive streams.
+   */
+  public static DownloadHelper forProgressive(Uri uri, @Nullable String cacheKey) {
+    return new DownloadHelper(
+        DownloadRequest.TYPE_PROGRESSIVE,
+        uri,
+        cacheKey,
+        /* mediaSource= */ null,
+        DEFAULT_TRACK_SELECTOR_PARAMETERS,
+        /* rendererCapabilities= */ new RendererCapabilities[0]);
+  }
+
+  /**
+   * Creates a {@link DownloadHelper} for DASH streams.
+   *
+   * @param uri A manifest {@link Uri}.
+   * @param dataSourceFactory A {@link DataSource.Factory} used to load the manifest.
+   * @param renderersFactory A {@link RenderersFactory} creating the renderers for which tracks are
+   *     selected.
+   * @return A {@link DownloadHelper} for DASH streams.
+   * @throws IllegalStateException If the DASH module is missing.
+   */
+  public static DownloadHelper forDash(
+      Uri uri, DataSource.Factory dataSourceFactory, RenderersFactory renderersFactory) {
+    return forDash(
+        uri,
+        dataSourceFactory,
+        renderersFactory,
+        /* drmSessionManager= */ null,
+        DEFAULT_TRACK_SELECTOR_PARAMETERS);
   }
 
   /**
-   * Called on a background thread during preparation.
+   * Creates a {@link DownloadHelper} for DASH streams.
    *
-   * @throws IOException If preparation fails.
+   * @param uri A manifest {@link Uri}.
+   * @param dataSourceFactory A {@link DataSource.Factory} used to load the manifest.
+   * @param renderersFactory A {@link RenderersFactory} creating the renderers for which tracks are
+   *     selected.
+   * @param drmSessionManager An optional {@link DrmSessionManager} used by the renderers created by
+   *     {@code renderersFactory}.
+   * @param trackSelectorParameters {@link DefaultTrackSelector.Parameters} for selecting tracks for
+   *     downloading.
+   * @return A {@link DownloadHelper} for DASH streams.
+   * @throws IllegalStateException If the DASH module is missing.
    */
-  protected abstract void prepareInternal() throws IOException;
+  public static DownloadHelper forDash(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      RenderersFactory renderersFactory,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      DefaultTrackSelector.Parameters trackSelectorParameters) {
+    return new DownloadHelper(
+        DownloadRequest.TYPE_DASH,
+        uri,
+        /* cacheKey= */ null,
+        createMediaSource(
+            uri, dataSourceFactory, DASH_FACTORY_CONSTRUCTOR, DASH_FACTORY_CREATE_METHOD),
+        trackSelectorParameters,
+        Util.getRendererCapabilities(renderersFactory, drmSessionManager));
+  }
+
+  /**
+   * Creates a {@link DownloadHelper} for HLS streams.
+   *
+   * @param uri A playlist {@link Uri}.
+   * @param dataSourceFactory A {@link DataSource.Factory} used to load the playlist.
+   * @param renderersFactory A {@link RenderersFactory} creating the renderers for which tracks are
+   *     selected.
+   * @return A {@link DownloadHelper} for HLS streams.
+   * @throws IllegalStateException If the HLS module is missing.
+   */
+  public static DownloadHelper forHls(
+      Uri uri, DataSource.Factory dataSourceFactory, RenderersFactory renderersFactory) {
+    return forHls(
+        uri,
+        dataSourceFactory,
+        renderersFactory,
+        /* drmSessionManager= */ null,
+        DEFAULT_TRACK_SELECTOR_PARAMETERS);
+  }
+
+  /**
+   * Creates a {@link DownloadHelper} for HLS streams.
+   *
+   * @param uri A playlist {@link Uri}.
+   * @param dataSourceFactory A {@link DataSource.Factory} used to load the playlist.
+   * @param renderersFactory A {@link RenderersFactory} creating the renderers for which tracks are
+   *     selected.
+   * @param drmSessionManager An optional {@link DrmSessionManager} used by the renderers created by
+   *     {@code renderersFactory}.
+   * @param trackSelectorParameters {@link DefaultTrackSelector.Parameters} for selecting tracks for
+   *     downloading.
+   * @return A {@link DownloadHelper} for HLS streams.
+   * @throws IllegalStateException If the HLS module is missing.
+   */
+  public static DownloadHelper forHls(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      RenderersFactory renderersFactory,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      DefaultTrackSelector.Parameters trackSelectorParameters) {
+    return new DownloadHelper(
+        DownloadRequest.TYPE_HLS,
+        uri,
+        /* cacheKey= */ null,
+        createMediaSource(
+            uri, dataSourceFactory, HLS_FACTORY_CONSTRUCTOR, HLS_FACTORY_CREATE_METHOD),
+        trackSelectorParameters,
+        Util.getRendererCapabilities(renderersFactory, drmSessionManager));
+  }
+
+  /**
+   * Creates a {@link DownloadHelper} for SmoothStreaming streams.
+   *
+   * @param uri A manifest {@link Uri}.
+   * @param dataSourceFactory A {@link DataSource.Factory} used to load the manifest.
+   * @param renderersFactory A {@link RenderersFactory} creating the renderers for which tracks are
+   *     selected.
+   * @return A {@link DownloadHelper} for SmoothStreaming streams.
+   * @throws IllegalStateException If the SmoothStreaming module is missing.
+   */
+  public static DownloadHelper forSmoothStreaming(
+      Uri uri, DataSource.Factory dataSourceFactory, RenderersFactory renderersFactory) {
+    return forSmoothStreaming(
+        uri,
+        dataSourceFactory,
+        renderersFactory,
+        /* drmSessionManager= */ null,
+        DEFAULT_TRACK_SELECTOR_PARAMETERS);
+  }
+
+  /**
+   * Creates a {@link DownloadHelper} for SmoothStreaming streams.
+   *
+   * @param uri A manifest {@link Uri}.
+   * @param dataSourceFactory A {@link DataSource.Factory} used to load the manifest.
+   * @param renderersFactory A {@link RenderersFactory} creating the renderers for which tracks are
+   *     selected.
+   * @param drmSessionManager An optional {@link DrmSessionManager} used by the renderers created by
+   *     {@code renderersFactory}.
+   * @param trackSelectorParameters {@link DefaultTrackSelector.Parameters} for selecting tracks for
+   *     downloading.
+   * @return A {@link DownloadHelper} for SmoothStreaming streams.
+   * @throws IllegalStateException If the SmoothStreaming module is missing.
+   */
+  public static DownloadHelper forSmoothStreaming(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      RenderersFactory renderersFactory,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      DefaultTrackSelector.Parameters trackSelectorParameters) {
+    return new DownloadHelper(
+        DownloadRequest.TYPE_SS,
+        uri,
+        /* cacheKey= */ null,
+        createMediaSource(uri, dataSourceFactory, SS_FACTORY_CONSTRUCTOR, SS_FACTORY_CREATE_METHOD),
+        trackSelectorParameters,
+        Util.getRendererCapabilities(renderersFactory, drmSessionManager));
+  }
+
+  private final String downloadType;
+  private final Uri uri;
+  @Nullable private final String cacheKey;
+  @Nullable private final MediaSource mediaSource;
+  private final DefaultTrackSelector trackSelector;
+  private final RendererCapabilities[] rendererCapabilities;
+  private final SparseIntArray scratchSet;
+  private final Handler callbackHandler;
+
+  private boolean isPreparedWithMedia;
+  private @MonotonicNonNull Callback callback;
+  private @MonotonicNonNull MediaPreparer mediaPreparer;
+  private TrackGroupArray @MonotonicNonNull [] trackGroupArrays;
+  private MappedTrackInfo @MonotonicNonNull [] mappedTrackInfos;
+  private List<TrackSelection> @MonotonicNonNull [][] trackSelectionsByPeriodAndRenderer;
+  private List<TrackSelection> @MonotonicNonNull [][] immutableTrackSelectionsByPeriodAndRenderer;
+
+  /**
+   * Creates download helper.
+   *
+   * @param downloadType A download type. This value will be used as {@link DownloadRequest#type}.
+   * @param uri A {@link Uri}.
+   * @param cacheKey An optional cache key.
+   * @param mediaSource A {@link MediaSource} for which tracks are selected, or null if no track
+   *     selection needs to be made.
+   * @param trackSelectorParameters {@link DefaultTrackSelector.Parameters} for selecting tracks for
+   *     downloading.
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which tracks
+   *     are selected.
+   */
+  public DownloadHelper(
+      String downloadType,
+      Uri uri,
+      @Nullable String cacheKey,
+      @Nullable MediaSource mediaSource,
+      DefaultTrackSelector.Parameters trackSelectorParameters,
+      RendererCapabilities[] rendererCapabilities) {
+    this.downloadType = downloadType;
+    this.uri = uri;
+    this.cacheKey = cacheKey;
+    this.mediaSource = mediaSource;
+    this.trackSelector = new DefaultTrackSelector(new DownloadTrackSelection.Factory());
+    this.rendererCapabilities = rendererCapabilities;
+    this.scratchSet = new SparseIntArray();
+    trackSelector.setParameters(trackSelectorParameters);
+    trackSelector.init(/* listener= */ () -> {}, new DummyBandwidthMeter());
+    callbackHandler = new Handler(Util.getLooper());
+  }
+
+  /**
+   * Initializes the helper for starting a download.
+   *
+   * @param callback A callback to be notified when preparation completes or fails.
+   * @throws IllegalStateException If the download helper has already been prepared.
+   */
+  public void prepare(Callback callback) {
+    Assertions.checkState(this.callback == null);
+    this.callback = callback;
+    if (mediaSource != null) {
+      mediaPreparer = new MediaPreparer(mediaSource, /* downloadHelper= */ this);
+    } else {
+      callbackHandler.post(() -> callback.onPrepared(this));
+    }
+  }
+
+  /** Releases the helper and all resources it is holding. */
+  public void release() {
+    if (mediaPreparer != null) {
+      mediaPreparer.release();
+    }
+  }
+
+  /**
+   * Returns the manifest, or null if no manifest is loaded. Must not be called until after
+   * preparation completes.
+   */
+  @Nullable
+  public Object getManifest() {
+    if (mediaSource == null) {
+      return null;
+    }
+    assertPreparedWithMedia();
+    return mediaPreparer.manifest;
+  }
 
   /**
    * Returns the number of periods for which media is available. Must not be called until after
    * preparation completes.
    */
-  public abstract int getPeriodCount();
+  public int getPeriodCount() {
+    if (mediaSource == null) {
+      return 0;
+    }
+    assertPreparedWithMedia();
+    return trackGroupArrays.length;
+  }
 
   /**
    * Returns the track groups for the given period. Must not be called until after preparation
    * completes.
    *
+   * <p>Use {@link #getMappedTrackInfo(int)} to get the track groups mapped to renderers.
+   *
    * @param periodIndex The period index.
    * @return The track groups for the period. May be {@link TrackGroupArray#EMPTY} for single stream
    *     content.
    */
-  public abstract TrackGroupArray getTrackGroups(int periodIndex);
+  public TrackGroupArray getTrackGroups(int periodIndex) {
+    assertPreparedWithMedia();
+    return trackGroupArrays[periodIndex];
+  }
 
   /**
-   * Builds a {@link DownloadAction} for downloading the specified tracks. Must not be called until
-   * after preparation completes.
+   * Returns the mapped track info for the given period. Must not be called until after preparation
+   * completes.
+   *
+   * @param periodIndex The period index.
+   * @return The {@link MappedTrackInfo} for the period.
+   */
+  public MappedTrackInfo getMappedTrackInfo(int periodIndex) {
+    assertPreparedWithMedia();
+    return mappedTrackInfos[periodIndex];
+  }
+
+  /**
+   * Returns all {@link TrackSelection track selections} for a period and renderer. Must not be
+   * called until after preparation completes.
+   *
+   * @param periodIndex The period index.
+   * @param rendererIndex The renderer index.
+   * @return A list of selected {@link TrackSelection track selections}.
+   */
+  public List<TrackSelection> getTrackSelections(int periodIndex, int rendererIndex) {
+    assertPreparedWithMedia();
+    return immutableTrackSelectionsByPeriodAndRenderer[periodIndex][rendererIndex];
+  }
+
+  /**
+   * Clears the selection of tracks for a period. Must not be called until after preparation
+   * completes.
+   *
+   * @param periodIndex The period index for which track selections are cleared.
+   */
+  public void clearTrackSelections(int periodIndex) {
+    assertPreparedWithMedia();
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      trackSelectionsByPeriodAndRenderer[periodIndex][i].clear();
+    }
+  }
+
+  /**
+   * Replaces a selection of tracks to be downloaded. Must not be called until after preparation
+   * completes.
+   *
+   * @param periodIndex The period index for which the track selection is replaced.
+   * @param trackSelectorParameters The {@link DefaultTrackSelector.Parameters} to obtain the new
+   *     selection of tracks.
+   */
+  public void replaceTrackSelections(
+      int periodIndex, DefaultTrackSelector.Parameters trackSelectorParameters) {
+    clearTrackSelections(periodIndex);
+    addTrackSelection(periodIndex, trackSelectorParameters);
+  }
+
+  /**
+   * Adds a selection of tracks to be downloaded. Must not be called until after preparation
+   * completes.
    *
-   * @param data Application provided data to store in {@link DownloadAction#data}.
-   * @param trackKeys The selected tracks. If empty, all streams will be downloaded.
-   * @return The built {@link DownloadAction}.
+   * @param periodIndex The period index this track selection is added for.
+   * @param trackSelectorParameters The {@link DefaultTrackSelector.Parameters} to obtain the new
+   *     selection of tracks.
    */
-  public abstract DownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys);
+  public void addTrackSelection(
+      int periodIndex, DefaultTrackSelector.Parameters trackSelectorParameters) {
+    assertPreparedWithMedia();
+    trackSelector.setParameters(trackSelectorParameters);
+    runTrackSelection(periodIndex);
+  }
+
+  /**
+   * Convenience method to add selections of tracks for all specified audio languages. If an audio
+   * track in one of the specified languages is not available, the default fallback audio track is
+   * used instead. Must not be called until after preparation completes.
+   *
+   * @param languages A list of audio languages for which tracks should be added to the download
+   *     selection, as IETF BCP 47 conformant tags.
+   */
+  public void addAudioLanguagesToSelection(String... languages) {
+    assertPreparedWithMedia();
+    for (int periodIndex = 0; periodIndex < mappedTrackInfos.length; periodIndex++) {
+      DefaultTrackSelector.ParametersBuilder parametersBuilder =
+          DEFAULT_TRACK_SELECTOR_PARAMETERS.buildUpon();
+      MappedTrackInfo mappedTrackInfo = mappedTrackInfos[periodIndex];
+      int rendererCount = mappedTrackInfo.getRendererCount();
+      for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
+        if (mappedTrackInfo.getRendererType(rendererIndex) != C.TRACK_TYPE_AUDIO) {
+          parametersBuilder.setRendererDisabled(rendererIndex, /* disabled= */ true);
+        }
+      }
+      for (String language : languages) {
+        parametersBuilder.setPreferredAudioLanguage(language);
+        addTrackSelection(periodIndex, parametersBuilder.build());
+      }
+    }
+  }
+
+  /**
+   * Convenience method to add selections of tracks for all specified text languages. Must not be
+   * called until after preparation completes.
+   *
+   * @param selectUndeterminedTextLanguage Whether a text track with undetermined language should be
+   *     selected for downloading if no track with one of the specified {@code languages} is
+   *     available.
+   * @param languages A list of text languages for which tracks should be added to the download
+   *     selection, as IETF BCP 47 conformant tags.
+   */
+  public void addTextLanguagesToSelection(
+      boolean selectUndeterminedTextLanguage, String... languages) {
+    assertPreparedWithMedia();
+    for (int periodIndex = 0; periodIndex < mappedTrackInfos.length; periodIndex++) {
+      DefaultTrackSelector.ParametersBuilder parametersBuilder =
+          DEFAULT_TRACK_SELECTOR_PARAMETERS.buildUpon();
+      MappedTrackInfo mappedTrackInfo = mappedTrackInfos[periodIndex];
+      int rendererCount = mappedTrackInfo.getRendererCount();
+      for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
+        if (mappedTrackInfo.getRendererType(rendererIndex) != C.TRACK_TYPE_TEXT) {
+          parametersBuilder.setRendererDisabled(rendererIndex, /* disabled= */ true);
+        }
+      }
+      parametersBuilder.setSelectUndeterminedTextLanguage(selectUndeterminedTextLanguage);
+      for (String language : languages) {
+        parametersBuilder.setPreferredTextLanguage(language);
+        addTrackSelection(periodIndex, parametersBuilder.build());
+      }
+    }
+  }
+
+  /**
+   * Convenience method to add a selection of tracks to be downloaded for a single renderer. Must
+   * not be called until after preparation completes.
+   *
+   * @param periodIndex The period index the track selection is added for.
+   * @param rendererIndex The renderer index the track selection is added for.
+   * @param trackSelectorParameters The {@link DefaultTrackSelector.Parameters} to obtain the new
+   *     selection of tracks.
+   * @param overrides A list of {@link SelectionOverride SelectionOverrides} to apply to the {@code
+   *     trackSelectorParameters}. If empty, {@code trackSelectorParameters} are used as they are.
+   */
+  public void addTrackSelectionForSingleRenderer(
+      int periodIndex,
+      int rendererIndex,
+      DefaultTrackSelector.Parameters trackSelectorParameters,
+      List<SelectionOverride> overrides) {
+    assertPreparedWithMedia();
+    DefaultTrackSelector.ParametersBuilder builder = trackSelectorParameters.buildUpon();
+    for (int i = 0; i < mappedTrackInfos[periodIndex].getRendererCount(); i++) {
+      builder.setRendererDisabled(/* rendererIndex= */ i, /* disabled= */ i != rendererIndex);
+    }
+    if (overrides.isEmpty()) {
+      addTrackSelection(periodIndex, builder.build());
+    } else {
+      TrackGroupArray trackGroupArray = mappedTrackInfos[periodIndex].getTrackGroups(rendererIndex);
+      for (int i = 0; i < overrides.size(); i++) {
+        builder.setSelectionOverride(rendererIndex, trackGroupArray, overrides.get(i));
+        addTrackSelection(periodIndex, builder.build());
+      }
+    }
+  }
+
+  /**
+   * Builds a {@link DownloadRequest} for downloading the selected tracks. Must not be called until
+   * after preparation completes. The uri of the {@link DownloadRequest} will be used as content id.
+   *
+   * @param data Application provided data to store in {@link DownloadRequest#data}.
+   * @return The built {@link DownloadRequest}.
+   */
+  public DownloadRequest getDownloadRequest(@Nullable byte[] data) {
+    return getDownloadRequest(uri.toString(), data);
+  }
 
   /**
-   * Builds a {@link DownloadAction} for removing the media. May be called in any state.
+   * Builds a {@link DownloadRequest} for downloading the selected tracks. Must not be called until
+   * after preparation completes.
    *
-   * @param data Application provided data to store in {@link DownloadAction#data}.
-   * @return The built {@link DownloadAction}.
+   * @param id The unique content id.
+   * @param data Application provided data to store in {@link DownloadRequest#data}.
+   * @return The built {@link DownloadRequest}.
+   */
+  public DownloadRequest getDownloadRequest(String id, @Nullable byte[] data) {
+    if (mediaSource == null) {
+      return new DownloadRequest(
+          id, downloadType, uri, /* streamKeys= */ Collections.emptyList(), cacheKey, data);
+    }
+    assertPreparedWithMedia();
+    List<StreamKey> streamKeys = new ArrayList<>();
+    List<TrackSelection> allSelections = new ArrayList<>();
+    int periodCount = trackSelectionsByPeriodAndRenderer.length;
+    for (int periodIndex = 0; periodIndex < periodCount; periodIndex++) {
+      allSelections.clear();
+      int rendererCount = trackSelectionsByPeriodAndRenderer[periodIndex].length;
+      for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
+        allSelections.addAll(trackSelectionsByPeriodAndRenderer[periodIndex][rendererIndex]);
+      }
+      streamKeys.addAll(mediaPreparer.mediaPeriods[periodIndex].getStreamKeys(allSelections));
+    }
+    return new DownloadRequest(id, downloadType, uri, streamKeys, cacheKey, data);
+  }
+
+  // Initialization of array of Lists.
+  @SuppressWarnings("unchecked")
+  private void onMediaPrepared() {
+    Assertions.checkNotNull(mediaPreparer);
+    Assertions.checkNotNull(mediaPreparer.mediaPeriods);
+    Assertions.checkNotNull(mediaPreparer.timeline);
+    int periodCount = mediaPreparer.mediaPeriods.length;
+    int rendererCount = rendererCapabilities.length;
+    trackSelectionsByPeriodAndRenderer =
+        (List<TrackSelection>[][]) new List<?>[periodCount][rendererCount];
+    immutableTrackSelectionsByPeriodAndRenderer =
+        (List<TrackSelection>[][]) new List<?>[periodCount][rendererCount];
+    for (int i = 0; i < periodCount; i++) {
+      for (int j = 0; j < rendererCount; j++) {
+        trackSelectionsByPeriodAndRenderer[i][j] = new ArrayList<>();
+        immutableTrackSelectionsByPeriodAndRenderer[i][j] =
+            Collections.unmodifiableList(trackSelectionsByPeriodAndRenderer[i][j]);
+      }
+    }
+    trackGroupArrays = new TrackGroupArray[periodCount];
+    mappedTrackInfos = new MappedTrackInfo[periodCount];
+    for (int i = 0; i < periodCount; i++) {
+      trackGroupArrays[i] = mediaPreparer.mediaPeriods[i].getTrackGroups();
+      TrackSelectorResult trackSelectorResult = runTrackSelection(/* periodIndex= */ i);
+      trackSelector.onSelectionActivated(trackSelectorResult.info);
+      mappedTrackInfos[i] = Assertions.checkNotNull(trackSelector.getCurrentMappedTrackInfo());
+    }
+    setPreparedWithMedia();
+    Assertions.checkNotNull(callbackHandler)
+        .post(() -> Assertions.checkNotNull(callback).onPrepared(this));
+  }
+
+  private void onMediaPreparationFailed(IOException error) {
+    Assertions.checkNotNull(callbackHandler)
+        .post(() -> Assertions.checkNotNull(callback).onPrepareError(this, error));
+  }
+
+  @RequiresNonNull({
+    "trackGroupArrays",
+    "mappedTrackInfos",
+    "trackSelectionsByPeriodAndRenderer",
+    "immutableTrackSelectionsByPeriodAndRenderer",
+    "mediaPreparer",
+    "mediaPreparer.timeline",
+    "mediaPreparer.mediaPeriods"
+  })
+  private void setPreparedWithMedia() {
+    isPreparedWithMedia = true;
+  }
+
+  @EnsuresNonNull({
+    "trackGroupArrays",
+    "mappedTrackInfos",
+    "trackSelectionsByPeriodAndRenderer",
+    "immutableTrackSelectionsByPeriodAndRenderer",
+    "mediaPreparer",
+    "mediaPreparer.timeline",
+    "mediaPreparer.mediaPeriods"
+  })
+  @SuppressWarnings("nullness:contracts.postcondition.not.satisfied")
+  private void assertPreparedWithMedia() {
+    Assertions.checkState(isPreparedWithMedia);
+  }
+
+  /**
+   * Runs the track selection for a given period index with the current parameters. The selected
+   * tracks will be added to {@link #trackSelectionsByPeriodAndRenderer}.
    */
-  public abstract DownloadAction getRemoveAction(@Nullable byte[] data);
+  // Intentional reference comparison of track group instances.
+  @SuppressWarnings("ReferenceEquality")
+  @RequiresNonNull({
+    "trackGroupArrays",
+    "trackSelectionsByPeriodAndRenderer",
+    "mediaPreparer",
+    "mediaPreparer.timeline"
+  })
+  private TrackSelectorResult runTrackSelection(int periodIndex) {
+    try {
+      TrackSelectorResult trackSelectorResult =
+          trackSelector.selectTracks(
+              rendererCapabilities,
+              trackGroupArrays[periodIndex],
+              new MediaPeriodId(mediaPreparer.timeline.getUidOfPeriod(periodIndex)),
+              mediaPreparer.timeline);
+      for (int i = 0; i < trackSelectorResult.length; i++) {
+        TrackSelection newSelection = trackSelectorResult.selections.get(i);
+        if (newSelection == null) {
+          continue;
+        }
+        List<TrackSelection> existingSelectionList =
+            trackSelectionsByPeriodAndRenderer[periodIndex][i];
+        boolean mergedWithExistingSelection = false;
+        for (int j = 0; j < existingSelectionList.size(); j++) {
+          TrackSelection existingSelection = existingSelectionList.get(j);
+          if (existingSelection.getTrackGroup() == newSelection.getTrackGroup()) {
+            // Merge with existing selection.
+            scratchSet.clear();
+            for (int k = 0; k < existingSelection.length(); k++) {
+              scratchSet.put(existingSelection.getIndexInTrackGroup(k), 0);
+            }
+            for (int k = 0; k < newSelection.length(); k++) {
+              scratchSet.put(newSelection.getIndexInTrackGroup(k), 0);
+            }
+            int[] mergedTracks = new int[scratchSet.size()];
+            for (int k = 0; k < scratchSet.size(); k++) {
+              mergedTracks[k] = scratchSet.keyAt(k);
+            }
+            existingSelectionList.set(
+                j, new DownloadTrackSelection(existingSelection.getTrackGroup(), mergedTracks));
+            mergedWithExistingSelection = true;
+            break;
+          }
+        }
+        if (!mergedWithExistingSelection) {
+          existingSelectionList.add(newSelection);
+        }
+      }
+      return trackSelectorResult;
+    } catch (ExoPlaybackException e) {
+      // DefaultTrackSelector does not throw exceptions during track selection.
+      throw new UnsupportedOperationException(e);
+    }
+  }
+
+  private static Pair<@NullableType Constructor<?>, @NullableType Method>
+      getMediaSourceFactoryMethods(String className) {
+    Constructor<?> constructor = null;
+    Method createMethod = null;
+    try {
+      // LINT.IfChange
+      Class<?> factoryClazz = Class.forName(className);
+      constructor = factoryClazz.getConstructor(DataSource.Factory.class);
+      createMethod = factoryClazz.getMethod("createMediaSource", Uri.class);
+      // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+    } catch (Exception e) {
+      // Expected if the app was built without the respective module.
+    }
+    return Pair.create(constructor, createMethod);
+  }
+
+  private static MediaSource createMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      @Nullable Constructor<?> factoryConstructor,
+      @Nullable Method createMediaSourceMethod) {
+    if (factoryConstructor == null || createMediaSourceMethod == null) {
+      throw new IllegalStateException("Module missing to create media source.");
+    }
+    try {
+      Object factory = factoryConstructor.newInstance(dataSourceFactory);
+      return (MediaSource) Assertions.checkNotNull(createMediaSourceMethod.invoke(factory, uri));
+    } catch (Exception e) {
+      throw new IllegalStateException("Failed to instantiate media source.", e);
+    }
+  }
+
+  private static final class MediaPreparer
+      implements MediaSource.SourceInfoRefreshListener, MediaPeriod.Callback, Handler.Callback {
+
+    private static final int MESSAGE_PREPARE_SOURCE = 0;
+    private static final int MESSAGE_CHECK_FOR_FAILURE = 1;
+    private static final int MESSAGE_CONTINUE_LOADING = 2;
+    private static final int MESSAGE_RELEASE = 3;
+
+    private static final int DOWNLOAD_HELPER_CALLBACK_MESSAGE_PREPARED = 0;
+    private static final int DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED = 1;
+
+    private final MediaSource mediaSource;
+    private final DownloadHelper downloadHelper;
+    private final Allocator allocator;
+    private final HandlerThread mediaSourceThread;
+    private final Handler mediaSourceHandler;
+    private final Handler downloadHelperHandler;
+    private final ArrayList<MediaPeriod> pendingMediaPeriods;
+
+    @Nullable public Object manifest;
+    public @MonotonicNonNull Timeline timeline;
+    public MediaPeriod @MonotonicNonNull [] mediaPeriods;
+
+    private boolean released;
+
+    public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
+      this.mediaSource = mediaSource;
+      this.downloadHelper = downloadHelper;
+      allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
+      @SuppressWarnings("methodref.receiver.bound.invalid")
+      Handler downloadThreadHandler = Util.createHandler(this::handleDownloadHelperCallbackMessage);
+      this.downloadHelperHandler = downloadThreadHandler;
+      mediaSourceThread = new HandlerThread("DownloadHelper");
+      mediaSourceThread.start();
+      mediaSourceHandler = Util.createHandler(mediaSourceThread.getLooper(), /* callback= */ this);
+      mediaSourceHandler.sendEmptyMessage(MESSAGE_PREPARE_SOURCE);
+      pendingMediaPeriods = new ArrayList<>();
+    }
+
+    public void release() {
+      if (released) {
+        return;
+      }
+      released = true;
+      mediaSourceHandler.sendEmptyMessage(MESSAGE_RELEASE);
+    }
+
+    // Handler.Callback
+
+    @Override
+    public boolean handleMessage(Message msg) {
+      switch (msg.what) {
+        case MESSAGE_PREPARE_SOURCE:
+          mediaSource.prepareSource(/* listener= */ this, /* mediaTransferListener= */ null);
+          mediaSourceHandler.sendEmptyMessage(MESSAGE_CHECK_FOR_FAILURE);
+          return true;
+        case MESSAGE_CHECK_FOR_FAILURE:
+          try {
+            if (mediaPeriods == null) {
+              mediaSource.maybeThrowSourceInfoRefreshError();
+            } else {
+              for (int i = 0; i < pendingMediaPeriods.size(); i++) {
+                pendingMediaPeriods.get(i).maybeThrowPrepareError();
+              }
+            }
+            mediaSourceHandler.sendEmptyMessageDelayed(
+                MESSAGE_CHECK_FOR_FAILURE, /* delayMillis= */ 100);
+          } catch (IOException e) {
+            downloadHelperHandler
+                .obtainMessage(DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED, /* obj= */ e)
+                .sendToTarget();
+          }
+          return true;
+        case MESSAGE_CONTINUE_LOADING:
+          MediaPeriod mediaPeriod = (MediaPeriod) msg.obj;
+          if (pendingMediaPeriods.contains(mediaPeriod)) {
+            mediaPeriod.continueLoading(/* positionUs= */ 0);
+          }
+          return true;
+        case MESSAGE_RELEASE:
+          if (mediaPeriods != null) {
+            for (MediaPeriod period : mediaPeriods) {
+              mediaSource.releasePeriod(period);
+            }
+          }
+          mediaSource.releaseSource(this);
+          mediaSourceHandler.removeCallbacksAndMessages(null);
+          mediaSourceThread.quit();
+          return true;
+        default:
+          return false;
+      }
+    }
+
+    // MediaSource.SourceInfoRefreshListener implementation.
+
+    @Override
+    public void onSourceInfoRefreshed(
+        MediaSource source, Timeline timeline, @Nullable Object manifest) {
+      if (this.timeline != null) {
+        // Ignore dynamic updates.
+        return;
+      }
+      this.timeline = timeline;
+      this.manifest = manifest;
+      mediaPeriods = new MediaPeriod[timeline.getPeriodCount()];
+      for (int i = 0; i < mediaPeriods.length; i++) {
+        MediaPeriod mediaPeriod =
+            mediaSource.createPeriod(
+                new MediaPeriodId(timeline.getUidOfPeriod(/* periodIndex= */ i)),
+                allocator,
+                /* startPositionUs= */ 0);
+        mediaPeriods[i] = mediaPeriod;
+        pendingMediaPeriods.add(mediaPeriod);
+      }
+      for (MediaPeriod mediaPeriod : mediaPeriods) {
+        mediaPeriod.prepare(/* callback= */ this, /* positionUs= */ 0);
+      }
+    }
+
+    // MediaPeriod.Callback implementation.
+
+    @Override
+    public void onPrepared(MediaPeriod mediaPeriod) {
+      pendingMediaPeriods.remove(mediaPeriod);
+      if (pendingMediaPeriods.isEmpty()) {
+        mediaSourceHandler.removeMessages(MESSAGE_CHECK_FOR_FAILURE);
+        downloadHelperHandler.sendEmptyMessage(DOWNLOAD_HELPER_CALLBACK_MESSAGE_PREPARED);
+      }
+    }
+
+    @Override
+    public void onContinueLoadingRequested(MediaPeriod mediaPeriod) {
+      if (pendingMediaPeriods.contains(mediaPeriod)) {
+        mediaSourceHandler.obtainMessage(MESSAGE_CONTINUE_LOADING, mediaPeriod).sendToTarget();
+      }
+    }
+
+    private boolean handleDownloadHelperCallbackMessage(Message msg) {
+      if (released) {
+        // Stale message.
+        return false;
+      }
+      switch (msg.what) {
+        case DOWNLOAD_HELPER_CALLBACK_MESSAGE_PREPARED:
+          downloadHelper.onMediaPrepared();
+          return true;
+        case DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED:
+          downloadHelper.onMediaPreparationFailed((IOException) Util.castNonNull(msg.obj));
+          return true;
+        default:
+          return false;
+      }
+    }
+  }
+
+  private static final class DownloadTrackSelection extends BaseTrackSelection {
+
+    private static final class Factory implements TrackSelection.Factory {
+
+      @Override
+      public @NullableType TrackSelection[] createTrackSelections(
+          @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
+        @NullableType TrackSelection[] selections = new TrackSelection[definitions.length];
+        for (int i = 0; i < definitions.length; i++) {
+          selections[i] =
+              definitions[i] == null
+                  ? null
+                  : new DownloadTrackSelection(definitions[i].group, definitions[i].tracks);
+        }
+        return selections;
+      }
+    }
+
+    public DownloadTrackSelection(TrackGroup trackGroup, int[] tracks) {
+      super(trackGroup, tracks);
+    }
+
+    @Override
+    public int getSelectedIndex() {
+      return 0;
+    }
+
+    @Override
+    public int getSelectionReason() {
+      return C.SELECTION_REASON_UNKNOWN;
+    }
+
+    @Nullable
+    @Override
+    public Object getSelectionData() {
+      return null;
+    }
+  }
+
+  private static final class DummyBandwidthMeter implements BandwidthMeter {
+
+    @Override
+    public long getBitrateEstimate() {
+      return 0;
+    }
+
+    @Nullable
+    @Override
+    public TransferListener getTransferListener() {
+      return null;
+    }
+
+    @Override
+    public void addEventListener(Handler eventHandler, EventListener eventListener) {
+      // Do nothing.
+    }
+
+    @Override
+    public void removeEventListener(EventListener eventListener) {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java
new file mode 100644
index 0000000000..3de1b7b212
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import androidx.annotation.Nullable;
+import java.io.IOException;
+
+/** An index of {@link Download Downloads}. */
+public interface DownloadIndex {
+
+  /**
+   * Returns the {@link Download} with the given {@code id}, or null.
+   *
+   * @param id ID of a {@link Download}.
+   * @return The {@link Download} with the given {@code id}, or null if a download state with this
+   *     id doesn't exist.
+   * @throws IOException If an error occurs reading the state.
+   */
+  @Nullable
+  Download getDownload(String id) throws IOException;
+
+  /**
+   * Returns a {@link DownloadCursor} to {@link Download}s with the given {@code states}.
+   *
+   * @param states Returns only the {@link Download}s with this states. If empty, returns all.
+   * @return A cursor to {@link Download}s with the given {@code states}.
+   * @throws IOException If an error occurs reading the state.
+   */
+  DownloadCursor getDownloads(@Download.State int... states) throws IOException;
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
index 409f79f30b..3bf03dd3e8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
@@ -15,37 +15,49 @@
  */
 package com.google.android.exoplayer2.offline;
 
-import static com.google.android.exoplayer2.offline.DownloadManager.TaskState.STATE_CANCELED;
-import static com.google.android.exoplayer2.offline.DownloadManager.TaskState.STATE_COMPLETED;
-import static com.google.android.exoplayer2.offline.DownloadManager.TaskState.STATE_FAILED;
-import static com.google.android.exoplayer2.offline.DownloadManager.TaskState.STATE_QUEUED;
-import static com.google.android.exoplayer2.offline.DownloadManager.TaskState.STATE_STARTED;
-
-import android.os.ConditionVariable;
+import static com.google.android.exoplayer2.offline.Download.FAILURE_REASON_NONE;
+import static com.google.android.exoplayer2.offline.Download.FAILURE_REASON_UNKNOWN;
+import static com.google.android.exoplayer2.offline.Download.STATE_COMPLETED;
+import static com.google.android.exoplayer2.offline.Download.STATE_DOWNLOADING;
+import static com.google.android.exoplayer2.offline.Download.STATE_FAILED;
+import static com.google.android.exoplayer2.offline.Download.STATE_QUEUED;
+import static com.google.android.exoplayer2.offline.Download.STATE_REMOVING;
+import static com.google.android.exoplayer2.offline.Download.STATE_RESTARTING;
+import static com.google.android.exoplayer2.offline.Download.STATE_STOPPED;
+import static com.google.android.exoplayer2.offline.Download.STOP_REASON_NONE;
+
+import android.content.Context;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import android.os.Message;
+import androidx.annotation.CheckResult;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.offline.DownloadAction.Deserializer;
+import com.google.android.exoplayer2.database.DatabaseProvider;
+import com.google.android.exoplayer2.scheduler.Requirements;
+import com.google.android.exoplayer2.scheduler.RequirementsWatcher;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSource.Factory;
 import com.google.android.exoplayer2.upstream.cache.Cache;
+import com.google.android.exoplayer2.upstream.cache.CacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
-import java.io.ByteArrayInputStream;
-import java.io.File;
 import java.io.IOException;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
- * Manages multiple stream download and remove requests.
+ * Manages downloads.
+ *
+ * <p>Normally a download manager should be accessed via a {@link DownloadService}. When a download
+ * manager is used directly instead, downloads will be initially paused and so must be resumed by
+ * calling {@link #resumeDownloads()}.
  *
  * <p>A download manager instance must be accessed only from the thread that created it, unless that
  * thread does not have a {@link Looper}. In that case, it must be accessed only from the
@@ -55,137 +67,187 @@
 
   /** Listener for {@link DownloadManager} events. */
   public interface Listener {
+
     /**
-     * Called when all actions have been restored.
+     * Called when all downloads have been restored.
      *
      * @param downloadManager The reporting instance.
      */
-    void onInitialized(DownloadManager downloadManager);
+    default void onInitialized(DownloadManager downloadManager) {}
+
+    /**
+     * Called when the state of a download changes.
+     *
+     * @param downloadManager The reporting instance.
+     * @param download The state of the download.
+     */
+    default void onDownloadChanged(DownloadManager downloadManager, Download download) {}
+
     /**
-     * Called when the state of a task changes.
+     * Called when a download is removed.
      *
      * @param downloadManager The reporting instance.
-     * @param taskState The state of the task.
+     * @param download The last state of the download before it was removed.
      */
-    void onTaskStateChanged(DownloadManager downloadManager, TaskState taskState);
+    default void onDownloadRemoved(DownloadManager downloadManager, Download download) {}
 
     /**
-     * Called when there is no active task left.
+     * Called when there is no active download left.
      *
      * @param downloadManager The reporting instance.
      */
-    void onIdle(DownloadManager downloadManager);
+    default void onIdle(DownloadManager downloadManager) {}
+
+    /**
+     * Called when the download requirements state changed.
+     *
+     * @param downloadManager The reporting instance.
+     * @param requirements Requirements needed to be met to start downloads.
+     * @param notMetRequirements {@link Requirements.RequirementFlags RequirementFlags} that are not
+     *     met, or 0.
+     */
+    default void onRequirementsStateChanged(
+        DownloadManager downloadManager,
+        Requirements requirements,
+        @Requirements.RequirementFlags int notMetRequirements) {}
   }
 
-  /** The default maximum number of simultaneous download tasks. */
-  public static final int DEFAULT_MAX_SIMULTANEOUS_DOWNLOADS = 1;
-  /** The default minimum number of times a task must be retried before failing. */
+  /** The default maximum number of parallel downloads. */
+  public static final int DEFAULT_MAX_PARALLEL_DOWNLOADS = 3;
+  /** The default minimum number of times a download must be retried before failing. */
   public static final int DEFAULT_MIN_RETRY_COUNT = 5;
+  /** The default requirement is that the device has network connectivity. */
+  public static final Requirements DEFAULT_REQUIREMENTS = new Requirements(Requirements.NETWORK);
+
+  // Messages posted to the main handler.
+  private static final int MSG_INITIALIZED = 0;
+  private static final int MSG_PROCESSED = 1;
+  private static final int MSG_DOWNLOAD_UPDATE = 2;
+
+  // Messages posted to the background handler.
+  private static final int MSG_INITIALIZE = 0;
+  private static final int MSG_SET_DOWNLOADS_PAUSED = 1;
+  private static final int MSG_SET_NOT_MET_REQUIREMENTS = 2;
+  private static final int MSG_SET_STOP_REASON = 3;
+  private static final int MSG_SET_MAX_PARALLEL_DOWNLOADS = 4;
+  private static final int MSG_SET_MIN_RETRY_COUNT = 5;
+  private static final int MSG_ADD_DOWNLOAD = 6;
+  private static final int MSG_REMOVE_DOWNLOAD = 7;
+  private static final int MSG_TASK_STOPPED = 8;
+  private static final int MSG_CONTENT_LENGTH_CHANGED = 9;
+  private static final int MSG_UPDATE_PROGRESS = 10;
+  private static final int MSG_RELEASE = 11;
 
   private static final String TAG = "DownloadManager";
-  private static final boolean DEBUG = false;
-
-  private final DownloaderConstructorHelper downloaderConstructorHelper;
-  private final int maxActiveDownloadTasks;
-  private final int minRetryCount;
-  private final ActionFile actionFile;
-  private final DownloadAction.Deserializer[] deserializers;
-  private final ArrayList<Task> tasks;
-  private final ArrayList<Task> activeDownloadTasks;
-  private final Handler handler;
-  private final HandlerThread fileIOThread;
-  private final Handler fileIOHandler;
+
+  private final Context context;
+  private final WritableDownloadIndex downloadIndex;
+  private final Handler mainHandler;
+  private final InternalHandler internalHandler;
+  private final RequirementsWatcher.Listener requirementsListener;
   private final CopyOnWriteArraySet<Listener> listeners;
 
-  private int nextTaskId;
+  private int pendingMessages;
+  private int activeTaskCount;
   private boolean initialized;
-  private boolean released;
-  private boolean downloadsStopped;
+  private boolean downloadsPaused;
+  private int maxParallelDownloads;
+  private int minRetryCount;
+  private int notMetRequirements;
+  private List<Download> downloads;
+  private RequirementsWatcher requirementsWatcher;
 
   /**
-   * Creates a {@link DownloadManager}.
+   * Constructs a {@link DownloadManager}.
    *
-   * @param cache Cache instance to be used to store downloaded data.
-   * @param upstreamDataSourceFactory A {@link DataSource.Factory} for creating data sources for
-   *     downloading upstream data.
-   * @param actionSaveFile File to save active actions.
-   * @param deserializers Used to deserialize {@link DownloadAction}s. If empty, {@link
-   *     DownloadAction#getDefaultDeserializers()} is used instead.
+   * @param context Any context.
+   * @param databaseProvider Provides the SQLite database in which downloads are persisted.
+   * @param cache A cache to be used to store downloaded data. The cache should be configured with
+   *     an {@link CacheEvictor} that will not evict downloaded content, for example {@link
+   *     NoOpCacheEvictor}.
+   * @param upstreamFactory A {@link Factory} for creating {@link DataSource}s for downloading data.
    */
   public DownloadManager(
-      Cache cache,
-      DataSource.Factory upstreamDataSourceFactory,
-      File actionSaveFile,
-      Deserializer... deserializers) {
+      Context context, DatabaseProvider databaseProvider, Cache cache, Factory upstreamFactory) {
     this(
-        new DownloaderConstructorHelper(cache, upstreamDataSourceFactory),
-        actionSaveFile,
-        deserializers);
+        context,
+        new DefaultDownloadIndex(databaseProvider),
+        new DefaultDownloaderFactory(new DownloaderConstructorHelper(cache, upstreamFactory)));
   }
 
   /**
    * Constructs a {@link DownloadManager}.
    *
-   * @param constructorHelper A {@link DownloaderConstructorHelper} to create {@link Downloader}s
-   *     for downloading data.
-   * @param actionFile The file in which active actions are saved.
-   * @param deserializers Used to deserialize {@link DownloadAction}s. If empty, {@link
-   *     DownloadAction#getDefaultDeserializers()} is used instead.
+   * @param context Any context.
+   * @param downloadIndex The download index used to hold the download information.
+   * @param downloaderFactory A factory for creating {@link Downloader}s.
    */
   public DownloadManager(
-      DownloaderConstructorHelper constructorHelper,
-      File actionFile,
-      Deserializer... deserializers) {
-    this(
-        constructorHelper,
-        DEFAULT_MAX_SIMULTANEOUS_DOWNLOADS,
-        DEFAULT_MIN_RETRY_COUNT,
-        actionFile,
-        deserializers);
+      Context context, WritableDownloadIndex downloadIndex, DownloaderFactory downloaderFactory) {
+    this.context = context.getApplicationContext();
+    this.downloadIndex = downloadIndex;
+
+    maxParallelDownloads = DEFAULT_MAX_PARALLEL_DOWNLOADS;
+    minRetryCount = DEFAULT_MIN_RETRY_COUNT;
+    downloadsPaused = true;
+    downloads = Collections.emptyList();
+    listeners = new CopyOnWriteArraySet<>();
+
+    @SuppressWarnings("methodref.receiver.bound.invalid")
+    Handler mainHandler = Util.createHandler(this::handleMainMessage);
+    this.mainHandler = mainHandler;
+    HandlerThread internalThread = new HandlerThread("DownloadManager file i/o");
+    internalThread.start();
+    internalHandler =
+        new InternalHandler(
+            internalThread,
+            downloadIndex,
+            downloaderFactory,
+            mainHandler,
+            maxParallelDownloads,
+            minRetryCount,
+            downloadsPaused);
+
+    @SuppressWarnings("methodref.receiver.bound.invalid")
+    RequirementsWatcher.Listener requirementsListener = this::onRequirementsStateChanged;
+    this.requirementsListener = requirementsListener;
+    requirementsWatcher =
+        new RequirementsWatcher(context, requirementsListener, DEFAULT_REQUIREMENTS);
+    notMetRequirements = requirementsWatcher.start();
+
+    pendingMessages = 1;
+    internalHandler
+        .obtainMessage(MSG_INITIALIZE, notMetRequirements, /* unused */ 0)
+        .sendToTarget();
+  }
+
+  /** Returns whether the manager has completed initialization. */
+  public boolean isInitialized() {
+    return initialized;
   }
 
   /**
-   * Constructs a {@link DownloadManager}.
-   *
-   * @param constructorHelper A {@link DownloaderConstructorHelper} to create {@link Downloader}s
-   *     for downloading data.
-   * @param maxSimultaneousDownloads The maximum number of simultaneous download tasks.
-   * @param minRetryCount The minimum number of times a task must be retried before failing.
-   * @param actionFile The file in which active actions are saved.
-   * @param deserializers Used to deserialize {@link DownloadAction}s. If empty, {@link
-   *     DownloadAction#getDefaultDeserializers()} is used instead.
+   * Returns whether the manager is currently idle. The manager is idle if all downloads are in a
+   * terminal state (i.e. completed or failed), or if no progress can be made (e.g. because the
+   * download requirements are not met).
    */
-  public DownloadManager(
-      DownloaderConstructorHelper constructorHelper,
-      int maxSimultaneousDownloads,
-      int minRetryCount,
-      File actionFile,
-      Deserializer... deserializers) {
-    this.downloaderConstructorHelper = constructorHelper;
-    this.maxActiveDownloadTasks = maxSimultaneousDownloads;
-    this.minRetryCount = minRetryCount;
-    this.actionFile = new ActionFile(actionFile);
-    this.deserializers =
-        deserializers.length > 0 ? deserializers : DownloadAction.getDefaultDeserializers();
-    this.downloadsStopped = true;
-
-    tasks = new ArrayList<>();
-    activeDownloadTasks = new ArrayList<>();
+  public boolean isIdle() {
+    return activeTaskCount == 0 && pendingMessages == 0;
+  }
 
-    Looper looper = Looper.myLooper();
-    if (looper == null) {
-      looper = Looper.getMainLooper();
+  /**
+   * Returns whether this manager has one or more downloads that are not progressing for the sole
+   * reason that the {@link #getRequirements() Requirements} are not met.
+   */
+  public boolean isWaitingForRequirements() {
+    if (!downloadsPaused && notMetRequirements != 0) {
+      for (int i = 0; i < downloads.size(); i++) {
+        if (downloads.get(i).state == STATE_QUEUED) {
+          return true;
+        }
+      }
     }
-    handler = new Handler(looper);
-
-    fileIOThread = new HandlerThread("DownloadManager file i/o");
-    fileIOThread.start();
-    fileIOHandler = new Handler(fileIOThread.getLooper());
-
-    listeners = new CopyOnWriteArraySet<>();
-
-    loadActions();
-    logd("Created");
+    return false;
   }
 
   /**
@@ -206,654 +268,975 @@ public void removeListener(Listener listener) {
     listeners.remove(listener);
   }
 
-  /** Starts the download tasks. */
-  public void startDownloads() {
-    Assertions.checkState(!released);
-    if (downloadsStopped) {
-      downloadsStopped = false;
-      maybeStartTasks();
-      logd("Downloads are started");
-    }
+  /** Returns the requirements needed to be met to progress. */
+  public Requirements getRequirements() {
+    return requirementsWatcher.getRequirements();
   }
 
-  /** Stops all of the download tasks. Call {@link #startDownloads()} to restart tasks. */
-  public void stopDownloads() {
-    Assertions.checkState(!released);
-    if (!downloadsStopped) {
-      downloadsStopped = true;
-      for (int i = 0; i < activeDownloadTasks.size(); i++) {
-        activeDownloadTasks.get(i).stop();
-      }
-      logd("Downloads are stopping");
-    }
+  /**
+   * Returns the requirements needed for downloads to progress that are not currently met.
+   *
+   * @return The not met {@link Requirements.RequirementFlags}, or 0 if all requirements are met.
+   */
+  @Requirements.RequirementFlags
+  public int getNotMetRequirements() {
+    return getRequirements().getNotMetRequirements(context);
   }
 
   /**
-   * Deserializes an action from {@code actionData}, and calls {@link
-   * #handleAction(DownloadAction)}.
+   * Sets the requirements that need to be met for downloads to progress.
    *
-   * @param actionData Serialized version of the action to be executed.
-   * @return The id of the newly created task.
-   * @throws IOException If an error occurs deserializing the action.
+   * @param requirements A {@link Requirements}.
    */
-  public int handleAction(byte[] actionData) throws IOException {
-    Assertions.checkState(!released);
-    ByteArrayInputStream input = new ByteArrayInputStream(actionData);
-    DownloadAction action = DownloadAction.deserializeFromStream(deserializers, input);
-    return handleAction(action);
+  public void setRequirements(Requirements requirements) {
+    if (requirements.equals(requirementsWatcher.getRequirements())) {
+      return;
+    }
+    requirementsWatcher.stop();
+    requirementsWatcher = new RequirementsWatcher(context, requirementsListener, requirements);
+    int notMetRequirements = requirementsWatcher.start();
+    onRequirementsStateChanged(requirementsWatcher, notMetRequirements);
+  }
+
+  /** Returns the maximum number of parallel downloads. */
+  public int getMaxParallelDownloads() {
+    return maxParallelDownloads;
   }
 
   /**
-   * Handles the given action. A task is created and added to the task queue. If it's a remove
-   * action then any download tasks for the same media are immediately canceled.
+   * Sets the maximum number of parallel downloads.
    *
-   * @param action The action to be executed.
-   * @return The id of the newly created task.
+   * @param maxParallelDownloads The maximum number of parallel downloads. Must be greater than 0.
    */
-  public int handleAction(DownloadAction action) {
-    Assertions.checkState(!released);
-    Task task = addTaskForAction(action);
-    if (initialized) {
-      saveActions();
-      maybeStartTasks();
-      if (task.currentState == STATE_QUEUED) {
-        // Task did not change out of its initial state, and so its initial state won't have been
-        // reported to listeners. Do so now.
-        notifyListenersTaskStateChange(task);
-      }
+  public void setMaxParallelDownloads(int maxParallelDownloads) {
+    Assertions.checkArgument(maxParallelDownloads > 0);
+    if (this.maxParallelDownloads == maxParallelDownloads) {
+      return;
     }
-    return task.id;
+    this.maxParallelDownloads = maxParallelDownloads;
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_SET_MAX_PARALLEL_DOWNLOADS, maxParallelDownloads, /* unused */ 0)
+        .sendToTarget();
   }
 
-  /** Returns the number of tasks. */
-  public int getTaskCount() {
-    Assertions.checkState(!released);
-    return tasks.size();
+  /**
+   * Returns the minimum number of times that a download will be retried. A download will fail if
+   * the specified number of retries is exceeded without any progress being made.
+   */
+  public int getMinRetryCount() {
+    return minRetryCount;
   }
 
-  /** Returns the number of download tasks. */
-  public int getDownloadCount() {
-    int count = 0;
-    for (int i = 0; i < tasks.size(); i++) {
-      if (!tasks.get(i).action.isRemoveAction) {
-        count++;
-      }
+  /**
+   * Sets the minimum number of times that a download will be retried. A download will fail if the
+   * specified number of retries is exceeded without any progress being made.
+   *
+   * @param minRetryCount The minimum number of times that a download will be retried.
+   */
+  public void setMinRetryCount(int minRetryCount) {
+    Assertions.checkArgument(minRetryCount >= 0);
+    if (this.minRetryCount == minRetryCount) {
+      return;
     }
-    return count;
+    this.minRetryCount = minRetryCount;
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_SET_MIN_RETRY_COUNT, minRetryCount, /* unused */ 0)
+        .sendToTarget();
   }
 
-  /** Returns the state of a task, or null if no such task exists */
-  public @Nullable TaskState getTaskState(int taskId) {
-    Assertions.checkState(!released);
-    for (int i = 0; i < tasks.size(); i++) {
-      Task task = tasks.get(i);
-      if (task.id == taskId) {
-        return task.getDownloadState();
-      }
-    }
-    return null;
+  /** Returns the used {@link DownloadIndex}. */
+  public DownloadIndex getDownloadIndex() {
+    return downloadIndex;
   }
 
-  /** Returns the states of all current tasks. */
-  public TaskState[] getAllTaskStates() {
-    Assertions.checkState(!released);
-    TaskState[] states = new TaskState[tasks.size()];
-    for (int i = 0; i < states.length; i++) {
-      states[i] = tasks.get(i).getDownloadState();
-    }
-    return states;
+  /**
+   * Returns current downloads. Downloads that are in terminal states (i.e. completed or failed) are
+   * not included. To query all downloads including those in terminal states, use {@link
+   * #getDownloadIndex()} instead.
+   */
+  public List<Download> getCurrentDownloads() {
+    return downloads;
   }
 
-  /** Returns whether the manager has completed initialization. */
-  public boolean isInitialized() {
-    Assertions.checkState(!released);
-    return initialized;
+  /** Returns whether downloads are currently paused. */
+  public boolean getDownloadsPaused() {
+    return downloadsPaused;
   }
 
-  /** Returns whether there are no active tasks. */
-  public boolean isIdle() {
-    Assertions.checkState(!released);
-    if (!initialized) {
-      return false;
-    }
-    for (int i = 0; i < tasks.size(); i++) {
-      if (tasks.get(i).isActive()) {
-        return false;
-      }
+  /**
+   * Resumes downloads.
+   *
+   * <p>If the {@link #setRequirements(Requirements) Requirements} are met up to {@link
+   * #getMaxParallelDownloads() maxParallelDownloads} will be started, excluding those with non-zero
+   * {@link Download#stopReason stopReasons}.
+   */
+  public void resumeDownloads() {
+    if (!downloadsPaused) {
+      return;
     }
-    return true;
+    downloadsPaused = false;
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_SET_DOWNLOADS_PAUSED, /* downloadsPaused */ 0, /* unused */ 0)
+        .sendToTarget();
   }
 
   /**
-   * Stops all of the tasks and releases resources. If the action file isn't up to date, waits for
-   * the changes to be written. The manager must not be accessed after this method has been called.
+   * Pauses downloads. Downloads that would otherwise be making progress transition to {@link
+   * Download#STATE_QUEUED}.
    */
-  public void release() {
-    if (released) {
+  public void pauseDownloads() {
+    if (downloadsPaused) {
       return;
     }
-    released = true;
-    for (int i = 0; i < tasks.size(); i++) {
-      tasks.get(i).stop();
-    }
-    final ConditionVariable fileIOFinishedCondition = new ConditionVariable();
-    fileIOHandler.post(fileIOFinishedCondition::open);
-    fileIOFinishedCondition.block();
-    fileIOThread.quit();
-    logd("Released");
+    downloadsPaused = true;
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_SET_DOWNLOADS_PAUSED, /* downloadsPaused */ 1, /* unused */ 0)
+        .sendToTarget();
   }
 
-  private Task addTaskForAction(DownloadAction action) {
-    Task task = new Task(nextTaskId++, this, action, minRetryCount);
-    tasks.add(task);
-    logd("Task is added", task);
-    return task;
+  /**
+   * Sets the stop reason for one or all downloads. To clear the stop reason, pass {@link
+   * Download#STOP_REASON_NONE}.
+   *
+   * @param id The content id of the download to update, or {@code null} to set the stop reason for
+   *     all downloads.
+   * @param stopReason The stop reason, or {@link Download#STOP_REASON_NONE}.
+   */
+  public void setStopReason(@Nullable String id, int stopReason) {
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_SET_STOP_REASON, stopReason, /* unused */ 0, id)
+        .sendToTarget();
   }
 
   /**
-   * Iterates through the task queue and starts any task if all of the following are true:
+   * Adds a download defined by the given request.
    *
-   * <ul>
-   *   <li>It hasn't started yet.
-   *   <li>There are no preceding conflicting tasks.
-   *   <li>If it's a download task then there are no preceding download tasks on hold and the
-   *       maximum number of active downloads hasn't been reached.
-   * </ul>
+   * @param request The download request.
+   */
+  public void addDownload(DownloadRequest request) {
+    addDownload(request, STOP_REASON_NONE);
+  }
+
+  /**
+   * Adds a download defined by the given request and with the specified stop reason.
    *
-   * If the task is a remove action then preceding conflicting tasks are canceled.
+   * @param request The download request.
+   * @param stopReason An initial stop reason for the download, or {@link Download#STOP_REASON_NONE}
+   *     if the download should be started.
    */
-  private void maybeStartTasks() {
-    if (!initialized || released) {
-      return;
-    }
+  public void addDownload(DownloadRequest request, int stopReason) {
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_ADD_DOWNLOAD, stopReason, /* unused */ 0, request)
+        .sendToTarget();
+  }
 
-    boolean skipDownloadActions = downloadsStopped
-        || activeDownloadTasks.size() == maxActiveDownloadTasks;
-    for (int i = 0; i < tasks.size(); i++) {
-      Task task = tasks.get(i);
-      if (!task.canStart()) {
-        continue;
-      }
-
-      DownloadAction action = task.action;
-      boolean isRemoveAction = action.isRemoveAction;
-      if (!isRemoveAction && skipDownloadActions) {
-        continue;
-      }
-
-      boolean canStartTask = true;
-      for (int j = 0; j < i; j++) {
-        Task otherTask = tasks.get(j);
-        if (otherTask.action.isSameMedia(action)) {
-          if (isRemoveAction) {
-            canStartTask = false;
-            logd(task + " clashes with " + otherTask);
-            otherTask.cancel();
-            // Continue loop to cancel any other preceding clashing tasks.
-          } else if (otherTask.action.isRemoveAction) {
-            canStartTask = false;
-            skipDownloadActions = true;
-            break;
-          }
-        }
-      }
+  /**
+   * Cancels the download with the {@code id} and removes all downloaded data.
+   *
+   * @param id The unique content id of the download to be started.
+   */
+  public void removeDownload(String id) {
+    pendingMessages++;
+    internalHandler.obtainMessage(MSG_REMOVE_DOWNLOAD, id).sendToTarget();
+  }
 
-      if (canStartTask) {
-        task.start();
-        if (!isRemoveAction) {
-          activeDownloadTasks.add(task);
-          skipDownloadActions = activeDownloadTasks.size() == maxActiveDownloadTasks;
+  /**
+   * Stops the downloads and releases resources. Waits until the downloads are persisted to the
+   * download index. The manager must not be accessed after this method has been called.
+   */
+  public void release() {
+    synchronized (internalHandler) {
+      if (internalHandler.released) {
+        return;
+      }
+      internalHandler.sendEmptyMessage(MSG_RELEASE);
+      boolean wasInterrupted = false;
+      while (!internalHandler.released) {
+        try {
+          internalHandler.wait();
+        } catch (InterruptedException e) {
+          wasInterrupted = true;
         }
       }
+      if (wasInterrupted) {
+        // Restore the interrupted status.
+        Thread.currentThread().interrupt();
+      }
+      mainHandler.removeCallbacksAndMessages(/* token= */ null);
+      // Reset state.
+      downloads = Collections.emptyList();
+      pendingMessages = 0;
+      activeTaskCount = 0;
+      initialized = false;
     }
   }
 
-  private void maybeNotifyListenersIdle() {
-    if (!isIdle()) {
-      return;
-    }
-    logd("Notify idle state");
+  private void onRequirementsStateChanged(
+      RequirementsWatcher requirementsWatcher,
+      @Requirements.RequirementFlags int notMetRequirements) {
+    Requirements requirements = requirementsWatcher.getRequirements();
     for (Listener listener : listeners) {
-      listener.onIdle(this);
+      listener.onRequirementsStateChanged(this, requirements, notMetRequirements);
     }
-  }
-
-  private void onTaskStateChange(Task task) {
-    if (released) {
+    if (this.notMetRequirements == notMetRequirements) {
       return;
     }
-    boolean stopped = !task.isActive();
-    if (stopped) {
-      activeDownloadTasks.remove(task);
-    }
-    notifyListenersTaskStateChange(task);
-    if (task.isFinished()) {
-      tasks.remove(task);
-      saveActions();
-    }
-    if (stopped) {
-      maybeStartTasks();
-      maybeNotifyListenersIdle();
-    }
+    this.notMetRequirements = notMetRequirements;
+    pendingMessages++;
+    internalHandler
+        .obtainMessage(MSG_SET_NOT_MET_REQUIREMENTS, notMetRequirements, /* unused */ 0)
+        .sendToTarget();
   }
 
-  private void notifyListenersTaskStateChange(Task task) {
-    logd("Task state is changed", task);
-    TaskState taskState = task.getDownloadState();
-    for (Listener listener : listeners) {
-      listener.onTaskStateChanged(this, taskState);
+  // Main thread message handling.
+
+  @SuppressWarnings("unchecked")
+  private boolean handleMainMessage(Message message) {
+    switch (message.what) {
+      case MSG_INITIALIZED:
+        List<Download> downloads = (List<Download>) message.obj;
+        onInitialized(downloads);
+        break;
+      case MSG_DOWNLOAD_UPDATE:
+        DownloadUpdate update = (DownloadUpdate) message.obj;
+        onDownloadUpdate(update);
+        break;
+      case MSG_PROCESSED:
+        int processedMessageCount = message.arg1;
+        int activeTaskCount = message.arg2;
+        onMessageProcessed(processedMessageCount, activeTaskCount);
+        break;
+      default:
+        throw new IllegalStateException();
     }
+    return true;
   }
 
-  private void loadActions() {
-    fileIOHandler.post(
-        () -> {
-          DownloadAction[] loadedActions;
-          try {
-            loadedActions = actionFile.load(DownloadManager.this.deserializers);
-            logd("Action file is loaded.");
-          } catch (Throwable e) {
-            Log.e(TAG, "Action file loading failed.", e);
-            loadedActions = new DownloadAction[0];
-          }
-          final DownloadAction[] actions = loadedActions;
-          handler.post(
-              () -> {
-                if (released) {
-                  return;
-                }
-                List<Task> pendingTasks = new ArrayList<>(tasks);
-                tasks.clear();
-                for (DownloadAction action : actions) {
-                  addTaskForAction(action);
-                }
-                logd("Tasks are created.");
-                initialized = true;
-                for (Listener listener : listeners) {
-                  listener.onInitialized(DownloadManager.this);
-                }
-                if (!pendingTasks.isEmpty()) {
-                  tasks.addAll(pendingTasks);
-                  saveActions();
-                }
-                maybeStartTasks();
-                for (int i = 0; i < tasks.size(); i++) {
-                  Task task = tasks.get(i);
-                  if (task.currentState == STATE_QUEUED) {
-                    // Task did not change out of its initial state, and so its initial state
-                    // won't have been reported to listeners. Do so now.
-                    notifyListenersTaskStateChange(task);
-                  }
-                }
-              });
-        });
+  private void onInitialized(List<Download> downloads) {
+    initialized = true;
+    this.downloads = Collections.unmodifiableList(downloads);
+    for (Listener listener : listeners) {
+      listener.onInitialized(DownloadManager.this);
+    }
   }
 
-  private void saveActions() {
-    if (released) {
-      return;
-    }
-    final DownloadAction[] actions = new DownloadAction[tasks.size()];
-    for (int i = 0; i < tasks.size(); i++) {
-      actions[i] = tasks.get(i).action;
+  private void onDownloadUpdate(DownloadUpdate update) {
+    downloads = Collections.unmodifiableList(update.downloads);
+    Download updatedDownload = update.download;
+    if (update.isRemove) {
+      for (Listener listener : listeners) {
+        listener.onDownloadRemoved(this, updatedDownload);
+      }
+    } else {
+      for (Listener listener : listeners) {
+        listener.onDownloadChanged(this, updatedDownload);
+      }
     }
-    fileIOHandler.post(
-        () -> {
-          try {
-            actionFile.store(actions);
-            logd("Actions persisted.");
-          } catch (IOException e) {
-            Log.e(TAG, "Persisting actions failed.", e);
-          }
-        });
   }
 
-  private static void logd(String message) {
-    if (DEBUG) {
-      Log.d(TAG, message);
+  private void onMessageProcessed(int processedMessageCount, int activeTaskCount) {
+    this.pendingMessages -= processedMessageCount;
+    this.activeTaskCount = activeTaskCount;
+    if (isIdle()) {
+      for (Listener listener : listeners) {
+        listener.onIdle(this);
+      }
     }
   }
 
-  private static void logd(String message, Task task) {
-    logd(message + ": " + task);
+  /* package */ static Download mergeRequest(
+      Download download, DownloadRequest request, int stopReason, long nowMs) {
+    @Download.State int state = download.state;
+    // Treat the merge as creating a new download if we're currently removing the existing one, or
+    // if the existing download is in a terminal state. Else treat the merge as updating the
+    // existing download.
+    long startTimeMs =
+        state == STATE_REMOVING || download.isTerminalState() ? nowMs : download.startTimeMs;
+    if (state == STATE_REMOVING || state == STATE_RESTARTING) {
+      state = STATE_RESTARTING;
+    } else if (stopReason != STOP_REASON_NONE) {
+      state = STATE_STOPPED;
+    } else {
+      state = STATE_QUEUED;
+    }
+    return new Download(
+        download.request.copyWithMergedRequest(request),
+        state,
+        startTimeMs,
+        /* updateTimeMs= */ nowMs,
+        /* contentLength= */ C.LENGTH_UNSET,
+        stopReason,
+        FAILURE_REASON_NONE);
   }
 
-  /** Represents state of a task. */
-  public static final class TaskState {
+  private static final class InternalHandler extends Handler {
+
+    private static final int UPDATE_PROGRESS_INTERVAL_MS = 5000;
+
+    public boolean released;
+
+    private final HandlerThread thread;
+    private final WritableDownloadIndex downloadIndex;
+    private final DownloaderFactory downloaderFactory;
+    private final Handler mainHandler;
+    private final ArrayList<Download> downloads;
+    private final HashMap<String, Task> activeTasks;
+
+    @Requirements.RequirementFlags private int notMetRequirements;
+    private boolean downloadsPaused;
+    private int maxParallelDownloads;
+    private int minRetryCount;
+    private int activeDownloadTaskCount;
+
+    public InternalHandler(
+        HandlerThread thread,
+        WritableDownloadIndex downloadIndex,
+        DownloaderFactory downloaderFactory,
+        Handler mainHandler,
+        int maxParallelDownloads,
+        int minRetryCount,
+        boolean downloadsPaused) {
+      super(thread.getLooper());
+      this.thread = thread;
+      this.downloadIndex = downloadIndex;
+      this.downloaderFactory = downloaderFactory;
+      this.mainHandler = mainHandler;
+      this.maxParallelDownloads = maxParallelDownloads;
+      this.minRetryCount = minRetryCount;
+      this.downloadsPaused = downloadsPaused;
+      downloads = new ArrayList<>();
+      activeTasks = new HashMap<>();
+    }
 
-    /**
-     * Task states. One of {@link #STATE_QUEUED}, {@link #STATE_STARTED}, {@link #STATE_COMPLETED},
-     * {@link #STATE_CANCELED} or {@link #STATE_FAILED}.
-     *
-     * <p>Transition diagram:
-     *
-     * <pre>
-     *                    -&gt; canceled
-     * queued &lt;-&gt; started -&gt; completed
-     *                    -&gt; failed
-     * </pre>
-     */
-    @Documented
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({STATE_QUEUED, STATE_STARTED, STATE_COMPLETED, STATE_CANCELED, STATE_FAILED})
-    public @interface State {}
-    /** The task is waiting to be started. */
-    public static final int STATE_QUEUED = 0;
-    /** The task is currently started. */
-    public static final int STATE_STARTED = 1;
-    /** The task completed. */
-    public static final int STATE_COMPLETED = 2;
-    /** The task was canceled. */
-    public static final int STATE_CANCELED = 3;
-    /** The task failed. */
-    public static final int STATE_FAILED = 4;
-
-    /** Returns the state string for the given state value. */
-    public static String getStateString(@State int state) {
-      switch (state) {
-        case STATE_QUEUED:
-          return "QUEUED";
-        case STATE_STARTED:
-          return "STARTED";
-        case STATE_COMPLETED:
-          return "COMPLETED";
-        case STATE_CANCELED:
-          return "CANCELED";
-        case STATE_FAILED:
-          return "FAILED";
+    @Override
+    public void handleMessage(Message message) {
+      boolean processedExternalMessage = true;
+      switch (message.what) {
+        case MSG_INITIALIZE:
+          int notMetRequirements = message.arg1;
+          initialize(notMetRequirements);
+          break;
+        case MSG_SET_DOWNLOADS_PAUSED:
+          boolean downloadsPaused = message.arg1 != 0;
+          setDownloadsPaused(downloadsPaused);
+          break;
+        case MSG_SET_NOT_MET_REQUIREMENTS:
+          notMetRequirements = message.arg1;
+          setNotMetRequirements(notMetRequirements);
+          break;
+        case MSG_SET_STOP_REASON:
+          String id = (String) message.obj;
+          int stopReason = message.arg1;
+          setStopReason(id, stopReason);
+          break;
+        case MSG_SET_MAX_PARALLEL_DOWNLOADS:
+          int maxParallelDownloads = message.arg1;
+          setMaxParallelDownloads(maxParallelDownloads);
+          break;
+        case MSG_SET_MIN_RETRY_COUNT:
+          int minRetryCount = message.arg1;
+          setMinRetryCount(minRetryCount);
+          break;
+        case MSG_ADD_DOWNLOAD:
+          DownloadRequest request = (DownloadRequest) message.obj;
+          stopReason = message.arg1;
+          addDownload(request, stopReason);
+          break;
+        case MSG_REMOVE_DOWNLOAD:
+          id = (String) message.obj;
+          removeDownload(id);
+          break;
+        case MSG_TASK_STOPPED:
+          Task task = (Task) message.obj;
+          onTaskStopped(task);
+          processedExternalMessage = false; // This message is posted internally.
+          break;
+        case MSG_CONTENT_LENGTH_CHANGED:
+          task = (Task) message.obj;
+          onContentLengthChanged(task);
+          return; // No need to post back to mainHandler.
+        case MSG_UPDATE_PROGRESS:
+          updateProgress();
+          return; // No need to post back to mainHandler.
+        case MSG_RELEASE:
+          release();
+          return; // No need to post back to mainHandler.
         default:
           throw new IllegalStateException();
       }
+      mainHandler
+          .obtainMessage(MSG_PROCESSED, processedExternalMessage ? 1 : 0, activeTasks.size())
+          .sendToTarget();
     }
 
-    /** The unique task id. */
-    public final int taskId;
-    /** The action being executed. */
-    public final DownloadAction action;
-    /** The state of the task. */
-    public final @State int state;
-
-    /**
-     * The estimated download percentage, or {@link C#PERCENTAGE_UNSET} if no estimate is available
-     * or if this is a removal task.
-     */
-    public final float downloadPercentage;
-    /** The total number of downloaded bytes. */
-    public final long downloadedBytes;
+    private void initialize(int notMetRequirements) {
+      this.notMetRequirements = notMetRequirements;
+      DownloadCursor cursor = null;
+      try {
+        downloadIndex.setDownloadingStatesToQueued();
+        cursor =
+            downloadIndex.getDownloads(
+                STATE_QUEUED, STATE_STOPPED, STATE_DOWNLOADING, STATE_REMOVING, STATE_RESTARTING);
+        while (cursor.moveToNext()) {
+          downloads.add(cursor.getDownload());
+        }
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to load index.", e);
+        downloads.clear();
+      } finally {
+        Util.closeQuietly(cursor);
+      }
+      // A copy must be used for the message to ensure that subsequent changes to the downloads list
+      // are not visible to the main thread when it processes the message.
+      ArrayList<Download> downloadsForMessage = new ArrayList<>(downloads);
+      mainHandler.obtainMessage(MSG_INITIALIZED, downloadsForMessage).sendToTarget();
+      syncTasks();
+    }
 
-    /** If {@link #state} is {@link #STATE_FAILED} then this is the cause, otherwise null. */
-    public final Throwable error;
+    private void setDownloadsPaused(boolean downloadsPaused) {
+      this.downloadsPaused = downloadsPaused;
+      syncTasks();
+    }
 
-    private TaskState(
-        int taskId,
-        DownloadAction action,
-        @State int state,
-        float downloadPercentage,
-        long downloadedBytes,
-        Throwable error) {
-      this.taskId = taskId;
-      this.action = action;
-      this.state = state;
-      this.downloadPercentage = downloadPercentage;
-      this.downloadedBytes = downloadedBytes;
-      this.error = error;
+    private void setNotMetRequirements(@Requirements.RequirementFlags int notMetRequirements) {
+      this.notMetRequirements = notMetRequirements;
+      syncTasks();
     }
 
-  }
+    private void setStopReason(@Nullable String id, int stopReason) {
+      if (id == null) {
+        for (int i = 0; i < downloads.size(); i++) {
+          setStopReason(downloads.get(i), stopReason);
+        }
+        try {
+          // Set the stop reason for downloads in terminal states as well.
+          downloadIndex.setStopReason(stopReason);
+        } catch (IOException e) {
+          Log.e(TAG, "Failed to set manual stop reason", e);
+        }
+      } else {
+        Download download = getDownload(id, /* loadFromIndex= */ false);
+        if (download != null) {
+          setStopReason(download, stopReason);
+        } else {
+          try {
+            // Set the stop reason if the download is in a terminal state.
+            downloadIndex.setStopReason(id, stopReason);
+          } catch (IOException e) {
+            Log.e(TAG, "Failed to set manual stop reason: " + id, e);
+          }
+        }
+      }
+      syncTasks();
+    }
 
-  private static final class Task implements Runnable {
+    private void setStopReason(Download download, int stopReason) {
+      if (stopReason == STOP_REASON_NONE) {
+        if (download.state == STATE_STOPPED) {
+          putDownloadWithState(download, STATE_QUEUED);
+        }
+      } else if (stopReason != download.stopReason) {
+        @Download.State int state = download.state;
+        if (state == STATE_QUEUED || state == STATE_DOWNLOADING) {
+          state = STATE_STOPPED;
+        }
+        putDownload(
+            new Download(
+                download.request,
+                state,
+                download.startTimeMs,
+                /* updateTimeMs= */ System.currentTimeMillis(),
+                download.contentLength,
+                stopReason,
+                FAILURE_REASON_NONE,
+                download.progress));
+      }
+    }
 
-    /**
-     * Task states. One of {@link TaskState#STATE_QUEUED}, {@link TaskState#STATE_STARTED}, {@link
-     * TaskState#STATE_COMPLETED}, {@link TaskState#STATE_CANCELED}, {@link TaskState#STATE_FAILED},
-     * {@link #STATE_QUEUED_CANCELING}, {@link #STATE_STARTED_CANCELING} or {@link
-     * #STATE_STARTED_STOPPING}.
-     *
-     * <p>Transition map (vertical states are source states):
-     *
-     * <pre>
-     *             +------+-------+---------+-----------+-----------+--------+--------+------+
-     *             |queued|started|completed|q_canceling|s_canceling|canceled|stopping|failed|
-     * +-----------+------+-------+---------+-----------+-----------+--------+--------+------+
-     * |queued     |      |   X   |         |     X     |           |        |        |      |
-     * |started    |      |       |    X    |           |     X     |        |   X    |   X  |
-     * |q_canceling|      |       |         |           |           |   X    |        |      |
-     * |s_canceling|      |       |         |           |           |   X    |        |      |
-     * |stopping   |   X  |       |         |           |           |        |        |      |
-     * +-----------+------+-------+---------+-----------+-----------+--------+--------+------+
-     * </pre>
-     */
-    @Documented
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({
-      STATE_QUEUED,
-      STATE_STARTED,
-      STATE_COMPLETED,
-      STATE_CANCELED,
-      STATE_FAILED,
-      STATE_QUEUED_CANCELING,
-      STATE_STARTED_CANCELING,
-      STATE_STARTED_STOPPING
-    })
-    public @interface InternalState {}
-    /** The task is about to be canceled. */
-    public static final int STATE_QUEUED_CANCELING = 5;
-    /** The task is about to be canceled. */
-    public static final int STATE_STARTED_CANCELING = 6;
-    /** The task is about to be stopped. */
-    public static final int STATE_STARTED_STOPPING = 7;
-
-    private final int id;
-    private final DownloadManager downloadManager;
-    private final DownloadAction action;
-    private final int minRetryCount;
-    private volatile @InternalState int currentState;
-    private volatile Downloader downloader;
-    private Thread thread;
-    private Throwable error;
+    private void setMaxParallelDownloads(int maxParallelDownloads) {
+      this.maxParallelDownloads = maxParallelDownloads;
+      syncTasks();
+    }
 
-    private Task(
-        int id, DownloadManager downloadManager, DownloadAction action, int minRetryCount) {
-      this.id = id;
-      this.downloadManager = downloadManager;
-      this.action = action;
-      this.currentState = STATE_QUEUED;
+    private void setMinRetryCount(int minRetryCount) {
       this.minRetryCount = minRetryCount;
     }
 
-    public TaskState getDownloadState() {
-      int externalState = getExternalState();
-      return new TaskState(
-          id, action, externalState, getDownloadPercentage(), getDownloadedBytes(), error);
+    private void addDownload(DownloadRequest request, int stopReason) {
+      Download download = getDownload(request.id, /* loadFromIndex= */ true);
+      long nowMs = System.currentTimeMillis();
+      if (download != null) {
+        putDownload(mergeRequest(download, request, stopReason, nowMs));
+      } else {
+        putDownload(
+            new Download(
+                request,
+                stopReason != STOP_REASON_NONE ? STATE_STOPPED : STATE_QUEUED,
+                /* startTimeMs= */ nowMs,
+                /* updateTimeMs= */ nowMs,
+                /* contentLength= */ C.LENGTH_UNSET,
+                stopReason,
+                FAILURE_REASON_NONE));
+      }
+      syncTasks();
     }
 
-    /** Returns whether the task is finished. */
-    public boolean isFinished() {
-      return currentState == STATE_FAILED
-          || currentState == STATE_COMPLETED
-          || currentState == STATE_CANCELED;
+    private void removeDownload(String id) {
+      Download download = getDownload(id, /* loadFromIndex= */ true);
+      if (download == null) {
+        Log.e(TAG, "Failed to remove nonexistent download: " + id);
+        return;
+      }
+      putDownloadWithState(download, STATE_REMOVING);
+      syncTasks();
     }
 
-    /** Returns whether the task is started. */
-    public boolean isActive() {
-      return currentState == STATE_QUEUED_CANCELING
-          || currentState == STATE_STARTED
-          || currentState == STATE_STARTED_STOPPING
-          || currentState == STATE_STARTED_CANCELING;
+    private void release() {
+      for (Task task : activeTasks.values()) {
+        task.cancel(/* released= */ true);
+      }
+      try {
+        downloadIndex.setDownloadingStatesToQueued();
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to update index.", e);
+      }
+      downloads.clear();
+      thread.quit();
+      synchronized (this) {
+        released = true;
+        notifyAll();
+      }
     }
 
-    /**
-     * Returns the estimated download percentage, or {@link C#PERCENTAGE_UNSET} if no estimate is
-     * available.
-     */
-    public float getDownloadPercentage() {
-      return downloader != null ? downloader.getDownloadPercentage() : C.PERCENTAGE_UNSET;
+    // Start and cancel tasks based on the current download and manager states.
+
+    private void syncTasks() {
+      int accumulatingDownloadTaskCount = 0;
+      for (int i = 0; i < downloads.size(); i++) {
+        Download download = downloads.get(i);
+        Task activeTask = activeTasks.get(download.request.id);
+        switch (download.state) {
+          case STATE_STOPPED:
+            syncStoppedDownload(activeTask);
+            break;
+          case STATE_QUEUED:
+            activeTask = syncQueuedDownload(activeTask, download);
+            break;
+          case STATE_DOWNLOADING:
+            Assertions.checkNotNull(activeTask);
+            syncDownloadingDownload(activeTask, download, accumulatingDownloadTaskCount);
+            break;
+          case STATE_REMOVING:
+          case STATE_RESTARTING:
+            syncRemovingDownload(activeTask, download);
+            break;
+          case STATE_COMPLETED:
+          case STATE_FAILED:
+          default:
+            throw new IllegalStateException();
+        }
+        if (activeTask != null && !activeTask.isRemove) {
+          accumulatingDownloadTaskCount++;
+        }
+      }
     }
 
-    /** Returns the total number of downloaded bytes. */
-    public long getDownloadedBytes() {
-      return downloader != null ? downloader.getDownloadedBytes() : 0;
+    private void syncStoppedDownload(@Nullable Task activeTask) {
+      if (activeTask != null) {
+        // We have a task, which must be a download task. Cancel it.
+        Assertions.checkState(!activeTask.isRemove);
+        activeTask.cancel(/* released= */ false);
+      }
     }
 
-    @Override
-    public String toString() {
-      if (!DEBUG) {
-        return super.toString();
-      }
-      return action.type
-          + ' '
-          + (action.isRemoveAction ? "remove" : "download")
-          + ' '
-          + toString(action.data)
-          + ' '
-          + getStateString();
-    }
-
-    private static String toString(byte[] data) {
-      if (data.length > 100) {
-        return "<data is too long>";
-      } else {
-        return '\'' + Util.fromUtf8Bytes(data) + '\'';
+    @Nullable
+    @CheckResult
+    private Task syncQueuedDownload(@Nullable Task activeTask, Download download) {
+      if (activeTask != null) {
+        // We have a task, which must be a download task. If the download state is queued we need to
+        // cancel it and start a new one, since a new request has been merged into the download.
+        Assertions.checkState(!activeTask.isRemove);
+        activeTask.cancel(/* released= */ false);
+        return activeTask;
+      }
+
+      if (!canDownloadsRun() || activeDownloadTaskCount >= maxParallelDownloads) {
+        return null;
+      }
+
+      // We can start a download task.
+      download = putDownloadWithState(download, STATE_DOWNLOADING);
+      Downloader downloader = downloaderFactory.createDownloader(download.request);
+      activeTask =
+          new Task(
+              download.request,
+              downloader,
+              download.progress,
+              /* isRemove= */ false,
+              minRetryCount,
+              /* internalHandler= */ this);
+      activeTasks.put(download.request.id, activeTask);
+      if (activeDownloadTaskCount++ == 0) {
+        sendEmptyMessageDelayed(MSG_UPDATE_PROGRESS, UPDATE_PROGRESS_INTERVAL_MS);
       }
+      activeTask.start();
+      return activeTask;
     }
 
-    private String getStateString() {
-      switch (currentState) {
-        case STATE_QUEUED_CANCELING:
-        case STATE_STARTED_CANCELING:
-          return "CANCELING";
-        case STATE_STARTED_STOPPING:
-          return "STOPPING";
-        case STATE_QUEUED:
-        case STATE_STARTED:
-        case STATE_COMPLETED:
-        case STATE_CANCELED:
-        case STATE_FAILED:
-        default:
-          return TaskState.getStateString(currentState);
+    private void syncDownloadingDownload(
+        Task activeTask, Download download, int accumulatingDownloadTaskCount) {
+      Assertions.checkState(!activeTask.isRemove);
+      if (!canDownloadsRun() || accumulatingDownloadTaskCount >= maxParallelDownloads) {
+        putDownloadWithState(download, STATE_QUEUED);
+        activeTask.cancel(/* released= */ false);
       }
     }
 
-    private int getExternalState() {
-      switch (currentState) {
-        case STATE_QUEUED_CANCELING:
-          return STATE_QUEUED;
-        case STATE_STARTED_CANCELING:
-        case STATE_STARTED_STOPPING:
-          return STATE_STARTED;
+    private void syncRemovingDownload(@Nullable Task activeTask, Download download) {
+      if (activeTask != null) {
+        if (!activeTask.isRemove) {
+          // Cancel the downloading task.
+          activeTask.cancel(/* released= */ false);
+        }
+        // The activeTask is either a remove task, or a downloading task that we just cancelled. In
+        // the latter case we need to wait for the task to stop before we start a remove task.
+        return;
+      }
+
+      // We can start a remove task.
+      Downloader downloader = downloaderFactory.createDownloader(download.request);
+      activeTask =
+          new Task(
+              download.request,
+              downloader,
+              download.progress,
+              /* isRemove= */ true,
+              minRetryCount,
+              /* internalHandler= */ this);
+      activeTasks.put(download.request.id, activeTask);
+      activeTask.start();
+    }
+
+    // Task event processing.
+
+    private void onContentLengthChanged(Task task) {
+      String downloadId = task.request.id;
+      long contentLength = task.contentLength;
+      Download download =
+          Assertions.checkNotNull(getDownload(downloadId, /* loadFromIndex= */ false));
+      if (contentLength == download.contentLength || contentLength == C.LENGTH_UNSET) {
+        return;
+      }
+      putDownload(
+          new Download(
+              download.request,
+              download.state,
+              download.startTimeMs,
+              /* updateTimeMs= */ System.currentTimeMillis(),
+              contentLength,
+              download.stopReason,
+              download.failureReason,
+              download.progress));
+    }
+
+    private void onTaskStopped(Task task) {
+      String downloadId = task.request.id;
+      activeTasks.remove(downloadId);
+
+      boolean isRemove = task.isRemove;
+      if (!isRemove && --activeDownloadTaskCount == 0) {
+        removeMessages(MSG_UPDATE_PROGRESS);
+      }
+
+      if (task.isCanceled) {
+        syncTasks();
+        return;
+      }
+
+      Throwable finalError = task.finalError;
+      if (finalError != null) {
+        Log.e(TAG, "Task failed: " + task.request + ", " + isRemove, finalError);
+      }
+
+      Download download =
+          Assertions.checkNotNull(getDownload(downloadId, /* loadFromIndex= */ false));
+      switch (download.state) {
+        case STATE_DOWNLOADING:
+          Assertions.checkState(!isRemove);
+          onDownloadTaskStopped(download, finalError);
+          break;
+        case STATE_REMOVING:
+        case STATE_RESTARTING:
+          Assertions.checkState(isRemove);
+          onRemoveTaskStopped(download);
+          break;
         case STATE_QUEUED:
-        case STATE_STARTED:
+        case STATE_STOPPED:
         case STATE_COMPLETED:
-        case STATE_CANCELED:
         case STATE_FAILED:
         default:
-          return currentState;
+          throw new IllegalStateException();
       }
+
+      syncTasks();
     }
 
-    private void start() {
-      if (changeStateAndNotify(STATE_QUEUED, STATE_STARTED)) {
-        thread = new Thread(this);
-        thread.start();
+    private void onDownloadTaskStopped(Download download, @Nullable Throwable finalError) {
+      download =
+          new Download(
+              download.request,
+              finalError == null ? STATE_COMPLETED : STATE_FAILED,
+              download.startTimeMs,
+              /* updateTimeMs= */ System.currentTimeMillis(),
+              download.contentLength,
+              download.stopReason,
+              finalError == null ? FAILURE_REASON_NONE : FAILURE_REASON_UNKNOWN,
+              download.progress);
+      // The download is now in a terminal state, so should not be in the downloads list.
+      downloads.remove(getDownloadIndex(download.request.id));
+      // We still need to update the download index and main thread.
+      try {
+        downloadIndex.putDownload(download);
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to update index.", e);
       }
+      DownloadUpdate update =
+          new DownloadUpdate(download, /* isRemove= */ false, new ArrayList<>(downloads));
+      mainHandler.obtainMessage(MSG_DOWNLOAD_UPDATE, update).sendToTarget();
     }
 
-    private boolean canStart() {
-      return currentState == STATE_QUEUED;
+    private void onRemoveTaskStopped(Download download) {
+      if (download.state == STATE_RESTARTING) {
+        putDownloadWithState(
+            download, download.stopReason == STOP_REASON_NONE ? STATE_QUEUED : STATE_STOPPED);
+        syncTasks();
+      } else {
+        int removeIndex = getDownloadIndex(download.request.id);
+        downloads.remove(removeIndex);
+        try {
+          downloadIndex.removeDownload(download.request.id);
+        } catch (IOException e) {
+          Log.e(TAG, "Failed to remove from database");
+        }
+        DownloadUpdate update =
+            new DownloadUpdate(download, /* isRemove= */ true, new ArrayList<>(downloads));
+        mainHandler.obtainMessage(MSG_DOWNLOAD_UPDATE, update).sendToTarget();
+      }
     }
 
-    private void cancel() {
-      if (changeStateAndNotify(STATE_QUEUED, STATE_QUEUED_CANCELING)) {
-        downloadManager.handler.post(
-            () -> changeStateAndNotify(STATE_QUEUED_CANCELING, STATE_CANCELED));
-      } else if (changeStateAndNotify(STATE_STARTED, STATE_STARTED_CANCELING)) {
-        cancelDownload();
+    // Progress updates.
+
+    private void updateProgress() {
+      for (int i = 0; i < downloads.size(); i++) {
+        Download download = downloads.get(i);
+        if (download.state == STATE_DOWNLOADING) {
+          try {
+            downloadIndex.putDownload(download);
+          } catch (IOException e) {
+            Log.e(TAG, "Failed to update index.", e);
+          }
+        }
       }
+      sendEmptyMessageDelayed(MSG_UPDATE_PROGRESS, UPDATE_PROGRESS_INTERVAL_MS);
     }
 
-    private void stop() {
-      if (changeStateAndNotify(STATE_STARTED, STATE_STARTED_STOPPING)) {
-        logd("Stopping", this);
-        cancelDownload();
-      }
+    // Helper methods.
+
+    private boolean canDownloadsRun() {
+      return !downloadsPaused && notMetRequirements == 0;
     }
 
-    private boolean changeStateAndNotify(@InternalState int oldState, @InternalState int newState) {
-      return changeStateAndNotify(oldState, newState, null);
+    private Download putDownloadWithState(Download download, @Download.State int state) {
+      // Downloads in terminal states shouldn't be in the downloads list. This method cannot be used
+      // to set STATE_STOPPED either, because it doesn't have a stopReason argument.
+      Assertions.checkState(
+          state != STATE_COMPLETED && state != STATE_FAILED && state != STATE_STOPPED);
+      return putDownload(
+          new Download(
+              download.request,
+              state,
+              download.startTimeMs,
+              /* updateTimeMs= */ System.currentTimeMillis(),
+              download.contentLength,
+              /* stopReason= */ 0,
+              FAILURE_REASON_NONE,
+              download.progress));
     }
 
-    private boolean changeStateAndNotify(
-        @InternalState int oldState, @InternalState int newState, Throwable error) {
-      if (currentState != oldState) {
-        return false;
+    private Download putDownload(Download download) {
+      // Downloads in terminal states shouldn't be in the downloads list.
+      Assertions.checkState(download.state != STATE_COMPLETED && download.state != STATE_FAILED);
+      int changedIndex = getDownloadIndex(download.request.id);
+      if (changedIndex == C.INDEX_UNSET) {
+        downloads.add(download);
+        Collections.sort(downloads, InternalHandler::compareStartTimes);
+      } else {
+        boolean needsSort = download.startTimeMs != downloads.get(changedIndex).startTimeMs;
+        downloads.set(changedIndex, download);
+        if (needsSort) {
+          Collections.sort(downloads, InternalHandler::compareStartTimes);
+        }
+      }
+      try {
+        downloadIndex.putDownload(download);
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to update index.", e);
+      }
+      DownloadUpdate update =
+          new DownloadUpdate(download, /* isRemove= */ false, new ArrayList<>(downloads));
+      mainHandler.obtainMessage(MSG_DOWNLOAD_UPDATE, update).sendToTarget();
+      return download;
+    }
+
+    @Nullable
+    private Download getDownload(String id, boolean loadFromIndex) {
+      int index = getDownloadIndex(id);
+      if (index != C.INDEX_UNSET) {
+        return downloads.get(index);
+      }
+      if (loadFromIndex) {
+        try {
+          return downloadIndex.getDownload(id);
+        } catch (IOException e) {
+          Log.e(TAG, "Failed to load download: " + id, e);
+        }
       }
-      currentState = newState;
-      this.error = error;
-      boolean isInternalState = currentState != getExternalState();
-      if (!isInternalState) {
-        downloadManager.onTaskStateChange(this);
+      return null;
+    }
+
+    private int getDownloadIndex(String id) {
+      for (int i = 0; i < downloads.size(); i++) {
+        Download download = downloads.get(i);
+        if (download.request.id.equals(id)) {
+          return i;
+        }
       }
-      return true;
+      return C.INDEX_UNSET;
     }
 
-    private void cancelDownload() {
-      if (downloader != null) {
+    private static int compareStartTimes(Download first, Download second) {
+      return Util.compareLong(first.startTimeMs, second.startTimeMs);
+    }
+  }
+
+  private static class Task extends Thread implements Downloader.ProgressListener {
+
+    private final DownloadRequest request;
+    private final Downloader downloader;
+    private final DownloadProgress downloadProgress;
+    private final boolean isRemove;
+    private final int minRetryCount;
+
+    private volatile InternalHandler internalHandler;
+    private volatile boolean isCanceled;
+    @Nullable private Throwable finalError;
+
+    private long contentLength;
+
+    private Task(
+        DownloadRequest request,
+        Downloader downloader,
+        DownloadProgress downloadProgress,
+        boolean isRemove,
+        int minRetryCount,
+        InternalHandler internalHandler) {
+      this.request = request;
+      this.downloader = downloader;
+      this.downloadProgress = downloadProgress;
+      this.isRemove = isRemove;
+      this.minRetryCount = minRetryCount;
+      this.internalHandler = internalHandler;
+      contentLength = C.LENGTH_UNSET;
+    }
+
+    @SuppressWarnings("nullness:assignment.type.incompatible")
+    public void cancel(boolean released) {
+      if (released) {
+        // Download threads are GC roots for as long as they're running. The time taken for
+        // cancellation to complete depends on the implementation of the downloader being used. We
+        // null the handler reference here so that it doesn't prevent garbage collection of the
+        // download manager whilst cancellation is ongoing.
+        internalHandler = null;
+      }
+      if (!isCanceled) {
+        isCanceled = true;
         downloader.cancel();
+        interrupt();
       }
-      thread.interrupt();
     }
 
     // Methods running on download thread.
 
     @Override
     public void run() {
-      logd("Task is started", this);
-      Throwable error = null;
       try {
-        downloader = action.createDownloader(downloadManager.downloaderConstructorHelper);
-        if (action.isRemoveAction) {
+        if (isRemove) {
           downloader.remove();
         } else {
           int errorCount = 0;
           long errorPosition = C.LENGTH_UNSET;
-          while (!Thread.interrupted()) {
+          while (!isCanceled) {
             try {
-              downloader.download();
+              downloader.download(/* progressListener= */ this);
               break;
             } catch (IOException e) {
-              long downloadedBytes = downloader.getDownloadedBytes();
-              if (downloadedBytes != errorPosition) {
-                logd("Reset error count. downloadedBytes = " + downloadedBytes, this);
-                errorPosition = downloadedBytes;
-                errorCount = 0;
-              }
-              if (currentState != STATE_STARTED || ++errorCount > minRetryCount) {
-                throw e;
+              if (!isCanceled) {
+                long bytesDownloaded = downloadProgress.bytesDownloaded;
+                if (bytesDownloaded != errorPosition) {
+                  errorPosition = bytesDownloaded;
+                  errorCount = 0;
+                }
+                if (++errorCount > minRetryCount) {
+                  throw e;
+                }
+                Thread.sleep(getRetryDelayMillis(errorCount));
               }
-              logd("Download error. Retry " + errorCount, this);
-              Thread.sleep(getRetryDelayMillis(errorCount));
             }
           }
         }
-      } catch (Throwable e){
-        error = e;
-      }
-      final Throwable finalError = error;
-      downloadManager.handler.post(
-          () -> {
-            if (changeStateAndNotify(
-                    STATE_STARTED, finalError != null ? STATE_FAILED : STATE_COMPLETED, finalError)
-                || changeStateAndNotify(STATE_STARTED_CANCELING, STATE_CANCELED)
-                || changeStateAndNotify(STATE_STARTED_STOPPING, STATE_QUEUED)) {
-              return;
-            }
-            throw new IllegalStateException();
-          });
+      } catch (Throwable e) {
+        finalError = e;
+      }
+      Handler internalHandler = this.internalHandler;
+      if (internalHandler != null) {
+        internalHandler.obtainMessage(MSG_TASK_STOPPED, this).sendToTarget();
+      }
+    }
+
+    @Override
+    public void onProgress(long contentLength, long bytesDownloaded, float percentDownloaded) {
+      downloadProgress.bytesDownloaded = bytesDownloaded;
+      downloadProgress.percentDownloaded = percentDownloaded;
+      if (contentLength != this.contentLength) {
+        this.contentLength = contentLength;
+        Handler internalHandler = this.internalHandler;
+        if (internalHandler != null) {
+          internalHandler.obtainMessage(MSG_CONTENT_LENGTH_CHANGED, this).sendToTarget();
+        }
+      }
     }
 
-    private int getRetryDelayMillis(int errorCount) {
+    private static int getRetryDelayMillis(int errorCount) {
       return Math.min((errorCount - 1) * 1000, 5000);
     }
   }
 
+  private static final class DownloadUpdate {
+
+    public final Download download;
+    public final boolean isRemove;
+    public final List<Download> downloads;
+
+    public DownloadUpdate(Download download, boolean isRemove, List<Download> downloads) {
+      this.download = download;
+      this.isRemove = isRemove;
+      this.downloads = downloads;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadProgress.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadProgress.java
new file mode 100644
index 0000000000..9d946daa28
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadProgress.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import com.google.android.exoplayer2.C;
+
+/** Mutable {@link Download} progress. */
+public class DownloadProgress {
+
+  /** The number of bytes that have been downloaded. */
+  public long bytesDownloaded;
+
+  /** The percentage that has been downloaded, or {@link C#PERCENTAGE_UNSET} if unknown. */
+  public float percentDownloaded;
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadRequest.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadRequest.java
new file mode 100644
index 0000000000..7ff43ceacd
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadRequest.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
+import android.net.Uri;
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/** Defines content to be downloaded. */
+public final class DownloadRequest implements Parcelable {
+
+  /** Thrown when the encoded request data belongs to an unsupported request type. */
+  public static class UnsupportedRequestException extends IOException {}
+
+  /** Type for progressive downloads. */
+  public static final String TYPE_PROGRESSIVE = "progressive";
+  /** Type for DASH downloads. */
+  public static final String TYPE_DASH = "dash";
+  /** Type for HLS downloads. */
+  public static final String TYPE_HLS = "hls";
+  /** Type for SmoothStreaming downloads. */
+  public static final String TYPE_SS = "ss";
+
+  /** The unique content id. */
+  public final String id;
+  /** The type of the request. */
+  public final String type;
+  /** The uri being downloaded. */
+  public final Uri uri;
+  /** Stream keys to be downloaded. If empty, all streams will be downloaded. */
+  public final List<StreamKey> streamKeys;
+  /**
+   * Custom key for cache indexing, or null. Must be null for DASH, HLS and SmoothStreaming
+   * downloads.
+   */
+  @Nullable public final String customCacheKey;
+  /** Application defined data associated with the download. May be empty. */
+  public final byte[] data;
+
+  /**
+   * @param id See {@link #id}.
+   * @param type See {@link #type}.
+   * @param uri See {@link #uri}.
+   * @param streamKeys See {@link #streamKeys}.
+   * @param customCacheKey See {@link #customCacheKey}.
+   * @param data See {@link #data}.
+   */
+  public DownloadRequest(
+      String id,
+      String type,
+      Uri uri,
+      List<StreamKey> streamKeys,
+      @Nullable String customCacheKey,
+      @Nullable byte[] data) {
+    if (TYPE_DASH.equals(type) || TYPE_HLS.equals(type) || TYPE_SS.equals(type)) {
+      Assertions.checkArgument(
+          customCacheKey == null, "customCacheKey must be null for type: " + type);
+    }
+    this.id = id;
+    this.type = type;
+    this.uri = uri;
+    ArrayList<StreamKey> mutableKeys = new ArrayList<>(streamKeys);
+    Collections.sort(mutableKeys);
+    this.streamKeys = Collections.unmodifiableList(mutableKeys);
+    this.customCacheKey = customCacheKey;
+    this.data = data != null ? Arrays.copyOf(data, data.length) : Util.EMPTY_BYTE_ARRAY;
+  }
+
+  /* package */ DownloadRequest(Parcel in) {
+    id = castNonNull(in.readString());
+    type = castNonNull(in.readString());
+    uri = Uri.parse(castNonNull(in.readString()));
+    int streamKeyCount = in.readInt();
+    ArrayList<StreamKey> mutableStreamKeys = new ArrayList<>(streamKeyCount);
+    for (int i = 0; i < streamKeyCount; i++) {
+      mutableStreamKeys.add(in.readParcelable(StreamKey.class.getClassLoader()));
+    }
+    streamKeys = Collections.unmodifiableList(mutableStreamKeys);
+    customCacheKey = in.readString();
+    data = new byte[in.readInt()];
+    in.readByteArray(data);
+  }
+
+  /**
+   * Returns a copy with the specified ID.
+   *
+   * @param id The ID of the copy.
+   * @return The copy with the specified ID.
+   */
+  public DownloadRequest copyWithId(String id) {
+    return new DownloadRequest(id, type, uri, streamKeys, customCacheKey, data);
+  }
+
+  /**
+   * Returns the result of merging {@code newRequest} into this request. The requests must have the
+   * same {@link #id} and {@link #type}.
+   *
+   * <p>If the requests have different {@link #uri}, {@link #customCacheKey} and {@link #data}
+   * values, then those from the request being merged are included in the result.
+   *
+   * @param newRequest The request being merged.
+   * @return The merged result.
+   * @throws IllegalArgumentException If the requests do not have the same {@link #id} and {@link
+   *     #type}.
+   */
+  public DownloadRequest copyWithMergedRequest(DownloadRequest newRequest) {
+    Assertions.checkArgument(id.equals(newRequest.id));
+    Assertions.checkArgument(type.equals(newRequest.type));
+    List<StreamKey> mergedKeys;
+    if (streamKeys.isEmpty() || newRequest.streamKeys.isEmpty()) {
+      // If either streamKeys is empty then all streams should be downloaded.
+      mergedKeys = Collections.emptyList();
+    } else {
+      mergedKeys = new ArrayList<>(streamKeys);
+      for (int i = 0; i < newRequest.streamKeys.size(); i++) {
+        StreamKey newKey = newRequest.streamKeys.get(i);
+        if (!mergedKeys.contains(newKey)) {
+          mergedKeys.add(newKey);
+        }
+      }
+    }
+    return new DownloadRequest(
+        id, type, newRequest.uri, mergedKeys, newRequest.customCacheKey, newRequest.data);
+  }
+
+  @Override
+  public String toString() {
+    return type + ":" + id;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object o) {
+    if (!(o instanceof DownloadRequest)) {
+      return false;
+    }
+    DownloadRequest that = (DownloadRequest) o;
+    return id.equals(that.id)
+        && type.equals(that.type)
+        && uri.equals(that.uri)
+        && streamKeys.equals(that.streamKeys)
+        && Util.areEqual(customCacheKey, that.customCacheKey)
+        && Arrays.equals(data, that.data);
+  }
+
+  @Override
+  public final int hashCode() {
+    int result = type.hashCode();
+    result = 31 * result + id.hashCode();
+    result = 31 * result + type.hashCode();
+    result = 31 * result + uri.hashCode();
+    result = 31 * result + streamKeys.hashCode();
+    result = 31 * result + (customCacheKey != null ? customCacheKey.hashCode() : 0);
+    result = 31 * result + Arrays.hashCode(data);
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeString(type);
+    dest.writeString(uri.toString());
+    dest.writeInt(streamKeys.size());
+    for (int i = 0; i < streamKeys.size(); i++) {
+      dest.writeParcelable(streamKeys.get(i), /* parcelableFlags= */ 0);
+    }
+    dest.writeString(customCacheKey);
+    dest.writeInt(data.length);
+    dest.writeByteArray(data);
+  }
+
+  public static final Parcelable.Creator<DownloadRequest> CREATOR =
+      new Parcelable.Creator<DownloadRequest>() {
+
+        @Override
+        public DownloadRequest createFromParcel(Parcel in) {
+          return new DownloadRequest(in);
+        }
+
+        @Override
+        public DownloadRequest[] newArray(int size) {
+          return new DownloadRequest[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
index 5c6cf88b48..fdd7163a2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.offline;
 
+import static com.google.android.exoplayer2.offline.Download.STOP_REASON_NONE;
+
 import android.app.Notification;
 import android.app.Service;
 import android.content.Context;
@@ -22,100 +24,179 @@
 import android.os.Handler;
 import android.os.IBinder;
 import android.os.Looper;
-import android.support.annotation.Nullable;
-import android.support.annotation.StringRes;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringRes;
 import com.google.android.exoplayer2.scheduler.Requirements;
-import com.google.android.exoplayer2.scheduler.RequirementsWatcher;
 import com.google.android.exoplayer2.scheduler.Scheduler;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.NotificationUtil;
 import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
 import java.util.HashMap;
+import java.util.List;
 
 /** A {@link Service} for downloading media. */
 public abstract class DownloadService extends Service {
 
-  /** Starts a download service without adding a new {@link DownloadAction}. */
+  /**
+   * Starts a download service to resume any ongoing downloads. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
   public static final String ACTION_INIT =
       "com.google.android.exoplayer.downloadService.action.INIT";
 
-  /** Starts a download service, adding a new {@link DownloadAction} to be executed. */
-  public static final String ACTION_ADD = "com.google.android.exoplayer.downloadService.action.ADD";
-
-  /** Reloads the download requirements. */
-  public static final String ACTION_RELOAD_REQUIREMENTS =
-      "com.google.android.exoplayer.downloadService.action.RELOAD_REQUIREMENTS";
-
   /** Like {@link #ACTION_INIT}, but with {@link #KEY_FOREGROUND} implicitly set to true. */
   private static final String ACTION_RESTART =
       "com.google.android.exoplayer.downloadService.action.RESTART";
 
-  /** Key for the {@link DownloadAction} in an {@link #ACTION_ADD} intent. */
-  public static final String KEY_DOWNLOAD_ACTION = "download_action";
+  /**
+   * Adds a new download. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_DOWNLOAD_REQUEST} - A {@link DownloadRequest} defining the download to be
+   *       added.
+   *   <li>{@link #KEY_STOP_REASON} - An initial stop reason for the download. If omitted {@link
+   *       Download#STOP_REASON_NONE} is used.
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_ADD_DOWNLOAD =
+      "com.google.android.exoplayer.downloadService.action.ADD_DOWNLOAD";
+
+  /**
+   * Removes a download. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_CONTENT_ID} - The content id of a download to remove.
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_REMOVE_DOWNLOAD =
+      "com.google.android.exoplayer.downloadService.action.REMOVE_DOWNLOAD";
 
-  /** Invalid foreground notification id which can be used to run the service in the background. */
-  public static final int FOREGROUND_NOTIFICATION_ID_NONE = 0;
+  /**
+   * Resumes all downloads except those that have a non-zero {@link Download#stopReason}. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_RESUME_DOWNLOADS =
+      "com.google.android.exoplayer.downloadService.action.RESUME_DOWNLOADS";
+
+  /**
+   * Pauses all downloads. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_PAUSE_DOWNLOADS =
+      "com.google.android.exoplayer.downloadService.action.PAUSE_DOWNLOADS";
+
+  /**
+   * Sets the stop reason for one or all downloads. To clear the stop reason, pass {@link
+   * Download#STOP_REASON_NONE}. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_CONTENT_ID} - The content id of a single download to update with the stop
+   *       reason. If omitted, all downloads will be updated.
+   *   <li>{@link #KEY_STOP_REASON} - An application provided reason for stopping the download or
+   *       downloads, or {@link Download#STOP_REASON_NONE} to clear the stop reason.
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_SET_STOP_REASON =
+      "com.google.android.exoplayer.downloadService.action.SET_STOP_REASON";
+
+  /**
+   * Sets the requirements that need to be met for downloads to progress. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_REQUIREMENTS} - A {@link Requirements}.
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_SET_REQUIREMENTS =
+      "com.google.android.exoplayer.downloadService.action.SET_REQUIREMENTS";
+
+  /** Key for the {@link DownloadRequest} in {@link #ACTION_ADD_DOWNLOAD} intents. */
+  public static final String KEY_DOWNLOAD_REQUEST = "download_request";
+
+  /**
+   * Key for the {@link String} content id in {@link #ACTION_SET_STOP_REASON} and {@link
+   * #ACTION_REMOVE_DOWNLOAD} intents.
+   */
+  public static final String KEY_CONTENT_ID = "content_id";
+
+  /**
+   * Key for the integer stop reason in {@link #ACTION_SET_STOP_REASON} and {@link
+   * #ACTION_ADD_DOWNLOAD} intents.
+   */
+  public static final String KEY_STOP_REASON = "stop_reason";
+
+  /** Key for the {@link Requirements} in {@link #ACTION_SET_REQUIREMENTS} intents. */
+  public static final String KEY_REQUIREMENTS = "requirements";
 
   /**
-   * Key for a boolean flag in any intent to indicate whether the service was started in the
-   * foreground. If set, the service is guaranteed to call {@link #startForeground(int,
-   * Notification)}.
+   * Key for a boolean extra that can be set on any intent to indicate whether the service was
+   * started in the foreground. If set, the service is guaranteed to call {@link
+   * #startForeground(int, Notification)}.
    */
   public static final String KEY_FOREGROUND = "foreground";
 
+  /** Invalid foreground notification id that can be used to run the service in the background. */
+  public static final int FOREGROUND_NOTIFICATION_ID_NONE = 0;
+
   /** Default foreground notification update interval in milliseconds. */
   public static final long DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL = 1000;
 
   private static final String TAG = "DownloadService";
-  private static final boolean DEBUG = false;
 
-  // Keep the requirements helper for each DownloadService as long as there are tasks (and the
-  // process is running). This allows tasks to resume when there's no scheduler. It may also allow
-  // tasks the resume more quickly than when relying on the scheduler alone.
-  private static final HashMap<Class<? extends DownloadService>, RequirementsHelper>
-      requirementsHelpers = new HashMap<>();
-  private static final Requirements DEFAULT_REQUIREMENTS =
-      new Requirements(Requirements.NETWORK_TYPE_ANY, false, false);
+  // Keep DownloadManagerListeners for each DownloadService as long as there are downloads (and the
+  // process is running). This allows DownloadService to restart when there's no scheduler.
+  private static final HashMap<Class<? extends DownloadService>, DownloadManagerHelper>
+      downloadManagerListeners = new HashMap<>();
 
-  private final @Nullable ForegroundNotificationUpdater foregroundNotificationUpdater;
-  private final @Nullable String channelId;
-  private final @StringRes int channelName;
+  @Nullable private final ForegroundNotificationUpdater foregroundNotificationUpdater;
+  @Nullable private final String channelId;
+  @StringRes private final int channelNameResourceId;
 
   private DownloadManager downloadManager;
-  private DownloadManagerListener downloadManagerListener;
   private int lastStartId;
   private boolean startedInForeground;
   private boolean taskRemoved;
+  private boolean isDestroyed;
 
   /**
    * Creates a DownloadService.
    *
-   * <p>If {@code foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE} (value
-   * {@value #FOREGROUND_NOTIFICATION_ID_NONE}) then the service runs in the background. No
-   * foreground notification is displayed and {@link #getScheduler()} isn't called.
+   * <p>If {@code foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE} then the
+   * service will only ever run in the background. No foreground notification will be displayed and
+   * {@link #getScheduler()} will not be called.
    *
-   * <p>If {@code foregroundNotificationId} isn't {@link #FOREGROUND_NOTIFICATION_ID_NONE} (value
-   * {@value #FOREGROUND_NOTIFICATION_ID_NONE}) the service runs in the foreground with {@link
-   * #DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL}. In that case {@link
-   * #getForegroundNotification(TaskState[])} should be overridden in the subclass.
+   * <p>If {@code foregroundNotificationId} is not {@link #FOREGROUND_NOTIFICATION_ID_NONE} then the
+   * service will run in the foreground. The foreground notification will be updated at least as
+   * often as the interval specified by {@link #DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL}.
    *
    * @param foregroundNotificationId The notification id for the foreground notification, or {@link
-   *     #FOREGROUND_NOTIFICATION_ID_NONE} (value {@value #FOREGROUND_NOTIFICATION_ID_NONE})
+   *     #FOREGROUND_NOTIFICATION_ID_NONE} if the service should only ever run in the background.
    */
   protected DownloadService(int foregroundNotificationId) {
     this(foregroundNotificationId, DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL);
   }
 
   /**
-   * Creates a DownloadService which will run in the foreground. {@link
-   * #getForegroundNotification(TaskState[])} should be overridden in the subclass.
+   * Creates a DownloadService.
    *
-   * @param foregroundNotificationId The notification id for the foreground notification, must not
-   *     be 0.
-   * @param foregroundNotificationUpdateInterval The maximum interval to update foreground
-   *     notification, in milliseconds.
+   * @param foregroundNotificationId The notification id for the foreground notification, or {@link
+   *     #FOREGROUND_NOTIFICATION_ID_NONE} if the service should only ever run in the background.
+   * @param foregroundNotificationUpdateInterval The maximum interval between updates to the
+   *     foreground notification, in milliseconds. Ignored if {@code foregroundNotificationId} is
+   *     {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
    */
   protected DownloadService(
       int foregroundNotificationId, long foregroundNotificationUpdateInterval) {
@@ -123,81 +204,282 @@ protected DownloadService(
         foregroundNotificationId,
         foregroundNotificationUpdateInterval,
         /* channelId= */ null,
-        /* channelName= */ 0);
+        /* channelNameResourceId= */ 0);
   }
 
   /**
-   * Creates a DownloadService which will run in the foreground. {@link
-   * #getForegroundNotification(TaskState[])} should be overridden in the subclass.
+   * Creates a DownloadService.
    *
-   * @param foregroundNotificationId The notification id for the foreground notification. Must not
-   *     be 0.
+   * @param foregroundNotificationId The notification id for the foreground notification, or {@link
+   *     #FOREGROUND_NOTIFICATION_ID_NONE} if the service should only ever run in the background.
    * @param foregroundNotificationUpdateInterval The maximum interval between updates to the
-   *     foreground notification, in milliseconds.
+   *     foreground notification, in milliseconds. Ignored if {@code foregroundNotificationId} is
+   *     {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
    * @param channelId An id for a low priority notification channel to create, or {@code null} if
    *     the app will take care of creating a notification channel if needed. If specified, must be
-   *     unique per package and the value may be truncated if it is too long.
-   * @param channelName A string resource identifier for the user visible name of the channel, if
-   *     {@code channelId} is specified. The recommended maximum length is 40 characters; the value
-   *     may be truncated if it is too long.
+   *     unique per package. The value may be truncated if it's too long. Ignored if {@code
+   *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
+   * @param channelNameResourceId A string resource identifier for the user visible name of the
+   *     channel, if {@code channelId} is specified. The recommended maximum length is 40
+   *     characters. The value may be truncated if it is too long. Ignored if {@code
+   *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
    */
   protected DownloadService(
       int foregroundNotificationId,
       long foregroundNotificationUpdateInterval,
       @Nullable String channelId,
-      @StringRes int channelName) {
-    foregroundNotificationUpdater =
-        foregroundNotificationId == 0
-            ? null
-            : new ForegroundNotificationUpdater(
-                foregroundNotificationId, foregroundNotificationUpdateInterval);
-    this.channelId = channelId;
-    this.channelName = channelName;
+      @StringRes int channelNameResourceId) {
+    if (foregroundNotificationId == FOREGROUND_NOTIFICATION_ID_NONE) {
+      this.foregroundNotificationUpdater = null;
+      this.channelId = null;
+      this.channelNameResourceId = 0;
+    } else {
+      this.foregroundNotificationUpdater =
+          new ForegroundNotificationUpdater(
+              foregroundNotificationId, foregroundNotificationUpdateInterval);
+      this.channelId = channelId;
+      this.channelNameResourceId = channelNameResourceId;
+    }
+  }
+
+  /**
+   * Builds an {@link Intent} for adding a new download.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param downloadRequest The request to be executed.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildAddDownloadIntent(
+      Context context,
+      Class<? extends DownloadService> clazz,
+      DownloadRequest downloadRequest,
+      boolean foreground) {
+    return buildAddDownloadIntent(context, clazz, downloadRequest, STOP_REASON_NONE, foreground);
+  }
+
+  /**
+   * Builds an {@link Intent} for adding a new download.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param downloadRequest The request to be executed.
+   * @param stopReason An initial stop reason for the download, or {@link Download#STOP_REASON_NONE}
+   *     if the download should be started.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildAddDownloadIntent(
+      Context context,
+      Class<? extends DownloadService> clazz,
+      DownloadRequest downloadRequest,
+      int stopReason,
+      boolean foreground) {
+    return getIntent(context, clazz, ACTION_ADD_DOWNLOAD, foreground)
+        .putExtra(KEY_DOWNLOAD_REQUEST, downloadRequest)
+        .putExtra(KEY_STOP_REASON, stopReason);
+  }
+
+  /**
+   * Builds an {@link Intent} for removing the download with the {@code id}.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param id The content id.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildRemoveDownloadIntent(
+      Context context, Class<? extends DownloadService> clazz, String id, boolean foreground) {
+    return getIntent(context, clazz, ACTION_REMOVE_DOWNLOAD, foreground)
+        .putExtra(KEY_CONTENT_ID, id);
+  }
+
+  /**
+   * Builds an {@link Intent} for resuming all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildResumeDownloadsIntent(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    return getIntent(context, clazz, ACTION_RESUME_DOWNLOADS, foreground);
+  }
+
+  /**
+   * Builds an {@link Intent} to pause all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildPauseDownloadsIntent(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    return getIntent(context, clazz, ACTION_PAUSE_DOWNLOADS, foreground);
+  }
+
+  /**
+   * Builds an {@link Intent} for setting the stop reason for one or all downloads. To clear the
+   * stop reason, pass {@link Download#STOP_REASON_NONE}.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param id The content id, or {@code null} to set the stop reason for all downloads.
+   * @param stopReason An application defined stop reason.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildSetStopReasonIntent(
+      Context context,
+      Class<? extends DownloadService> clazz,
+      @Nullable String id,
+      int stopReason,
+      boolean foreground) {
+    return getIntent(context, clazz, ACTION_SET_STOP_REASON, foreground)
+        .putExtra(KEY_CONTENT_ID, id)
+        .putExtra(KEY_STOP_REASON, stopReason);
   }
 
   /**
-   * Builds an {@link Intent} for adding an action to be executed by the service.
+   * Builds an {@link Intent} for setting the requirements that need to be met for downloads to
+   * progress.
    *
    * @param context A {@link Context}.
    * @param clazz The concrete download service being targeted by the intent.
-   * @param downloadAction The action to be executed.
+   * @param requirements A {@link Requirements}.
    * @param foreground Whether this intent will be used to start the service in the foreground.
-   * @return Created Intent.
+   * @return The created intent.
    */
-  public static Intent buildAddActionIntent(
+  public static Intent buildSetRequirementsIntent(
       Context context,
       Class<? extends DownloadService> clazz,
-      DownloadAction downloadAction,
+      Requirements requirements,
       boolean foreground) {
-    return getIntent(context, clazz, ACTION_ADD)
-        .putExtra(KEY_DOWNLOAD_ACTION, downloadAction.toByteArray())
-        .putExtra(KEY_FOREGROUND, foreground);
+    return getIntent(context, clazz, ACTION_SET_REQUIREMENTS, foreground)
+        .putExtra(KEY_REQUIREMENTS, requirements);
   }
 
   /**
-   * Starts the service, adding an action to be executed.
+   * Starts the service if not started already and adds a new download.
    *
    * @param context A {@link Context}.
    * @param clazz The concrete download service to be started.
-   * @param downloadAction The action to be executed.
+   * @param downloadRequest The request to be executed.
    * @param foreground Whether the service is started in the foreground.
    */
-  public static void startWithAction(
+  public static void sendAddDownload(
       Context context,
       Class<? extends DownloadService> clazz,
-      DownloadAction downloadAction,
+      DownloadRequest downloadRequest,
       boolean foreground) {
-    Intent intent = buildAddActionIntent(context, clazz, downloadAction, foreground);
-    if (foreground) {
-      Util.startForegroundService(context, intent);
-    } else {
-      context.startService(intent);
-    }
+    Intent intent = buildAddDownloadIntent(context, clazz, downloadRequest, foreground);
+    startService(context, intent, foreground);
+  }
+
+  /**
+   * Starts the service if not started already and adds a new download.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param downloadRequest The request to be executed.
+   * @param stopReason An initial stop reason for the download, or {@link Download#STOP_REASON_NONE}
+   *     if the download should be started.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendAddDownload(
+      Context context,
+      Class<? extends DownloadService> clazz,
+      DownloadRequest downloadRequest,
+      int stopReason,
+      boolean foreground) {
+    Intent intent = buildAddDownloadIntent(context, clazz, downloadRequest, stopReason, foreground);
+    startService(context, intent, foreground);
+  }
+
+  /**
+   * Starts the service if not started already and removes a download.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param id The content id.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendRemoveDownload(
+      Context context, Class<? extends DownloadService> clazz, String id, boolean foreground) {
+    Intent intent = buildRemoveDownloadIntent(context, clazz, id, foreground);
+    startService(context, intent, foreground);
+  }
+
+  /**
+   * Starts the service if not started already and resumes all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendResumeDownloads(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    Intent intent = buildResumeDownloadsIntent(context, clazz, foreground);
+    startService(context, intent, foreground);
+  }
+
+  /**
+   * Starts the service if not started already and pauses all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendPauseDownloads(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    Intent intent = buildPauseDownloadsIntent(context, clazz, foreground);
+    startService(context, intent, foreground);
+  }
+
+  /**
+   * Starts the service if not started already and sets the stop reason for one or all downloads. To
+   * clear stop reason, pass {@link Download#STOP_REASON_NONE}.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param id The content id, or {@code null} to set the stop reason for all downloads.
+   * @param stopReason An application defined stop reason.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendSetStopReason(
+      Context context,
+      Class<? extends DownloadService> clazz,
+      @Nullable String id,
+      int stopReason,
+      boolean foreground) {
+    Intent intent = buildSetStopReasonIntent(context, clazz, id, stopReason, foreground);
+    startService(context, intent, foreground);
+  }
+
+  /**
+   * Starts the service if not started already and sets the requirements that need to be met for
+   * downloads to progress.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param requirements A {@link Requirements}.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendSetRequirements(
+      Context context,
+      Class<? extends DownloadService> clazz,
+      Requirements requirements,
+      boolean foreground) {
+    Intent intent = buildSetRequirementsIntent(context, clazz, requirements, foreground);
+    startService(context, intent, foreground);
   }
 
   /**
-   * Starts the service without adding a new action. If there are any not finished actions and the
-   * requirements are met, the service resumes executing actions. Otherwise it stops immediately.
+   * Starts a download service to resume any ongoing downloads.
    *
    * @param context A {@link Context}.
    * @param clazz The concrete download service to be started.
@@ -208,29 +490,37 @@ public static void start(Context context, Class<? extends DownloadService> clazz
   }
 
   /**
-   * Starts the service in the foreground without adding a new action. If there are any not finished
-   * actions and the requirements are met, the service resumes executing actions. Otherwise it stops
-   * immediately.
+   * Starts the service in the foreground without adding a new download request. If there are any
+   * not finished downloads and the requirements are met, the service resumes downloading. Otherwise
+   * it stops immediately.
    *
    * @param context A {@link Context}.
    * @param clazz The concrete download service to be started.
    * @see #start(Context, Class)
    */
   public static void startForeground(Context context, Class<? extends DownloadService> clazz) {
-    Intent intent = getIntent(context, clazz, ACTION_INIT).putExtra(KEY_FOREGROUND, true);
+    Intent intent = getIntent(context, clazz, ACTION_INIT, true);
     Util.startForegroundService(context, intent);
   }
 
   @Override
   public void onCreate() {
-    logd("onCreate");
     if (channelId != null) {
       NotificationUtil.createNotificationChannel(
-          this, channelId, channelName, NotificationUtil.IMPORTANCE_LOW);
+          this, channelId, channelNameResourceId, NotificationUtil.IMPORTANCE_LOW);
+    }
+    Class<? extends DownloadService> clazz = getClass();
+    DownloadManagerHelper downloadManagerHelper = downloadManagerListeners.get(clazz);
+    if (downloadManagerHelper == null) {
+      DownloadManager downloadManager = getDownloadManager();
+      downloadManager.resumeDownloads();
+      downloadManagerHelper =
+          new DownloadManagerHelper(
+              getApplicationContext(), downloadManager, getScheduler(), clazz);
+      downloadManagerListeners.put(clazz, downloadManagerHelper);
     }
-    downloadManager = getDownloadManager();
-    downloadManagerListener = new DownloadManagerListener();
-    downloadManager.addListener(downloadManagerListener);
+    downloadManager = downloadManagerHelper.downloadManager;
+    downloadManagerHelper.attachService(this);
   }
 
   @Override
@@ -238,49 +528,65 @@ public int onStartCommand(Intent intent, int flags, int startId) {
     lastStartId = startId;
     taskRemoved = false;
     String intentAction = null;
+    String contentId = null;
     if (intent != null) {
       intentAction = intent.getAction();
       startedInForeground |=
           intent.getBooleanExtra(KEY_FOREGROUND, false) || ACTION_RESTART.equals(intentAction);
+      contentId = intent.getStringExtra(KEY_CONTENT_ID);
     }
     // intentAction is null if the service is restarted or no action is specified.
     if (intentAction == null) {
       intentAction = ACTION_INIT;
     }
-    logd("onStartCommand action: " + intentAction + " startId: " + startId);
     switch (intentAction) {
       case ACTION_INIT:
       case ACTION_RESTART:
         // Do nothing.
         break;
-      case ACTION_ADD:
-        byte[] actionData = intent.getByteArrayExtra(KEY_DOWNLOAD_ACTION);
-        if (actionData == null) {
-          Log.e(TAG, "Ignoring ADD action with no action data");
+      case ACTION_ADD_DOWNLOAD:
+        DownloadRequest downloadRequest = intent.getParcelableExtra(KEY_DOWNLOAD_REQUEST);
+        if (downloadRequest == null) {
+          Log.e(TAG, "Ignored ADD_DOWNLOAD: Missing " + KEY_DOWNLOAD_REQUEST + " extra");
+        } else {
+          int stopReason = intent.getIntExtra(KEY_STOP_REASON, Download.STOP_REASON_NONE);
+          downloadManager.addDownload(downloadRequest, stopReason);
+        }
+        break;
+      case ACTION_REMOVE_DOWNLOAD:
+        if (contentId == null) {
+          Log.e(TAG, "Ignored REMOVE_DOWNLOAD: Missing " + KEY_CONTENT_ID + " extra");
+        } else {
+          downloadManager.removeDownload(contentId);
+        }
+        break;
+      case ACTION_RESUME_DOWNLOADS:
+        downloadManager.resumeDownloads();
+        break;
+      case ACTION_PAUSE_DOWNLOADS:
+        downloadManager.pauseDownloads();
+        break;
+      case ACTION_SET_STOP_REASON:
+        if (!intent.hasExtra(KEY_STOP_REASON)) {
+          Log.e(TAG, "Ignored SET_STOP_REASON: Missing " + KEY_STOP_REASON + " extra");
         } else {
-          try {
-            downloadManager.handleAction(actionData);
-          } catch (IOException e) {
-            Log.e(TAG, "Failed to handle ADD action", e);
-          }
+          int stopReason = intent.getIntExtra(KEY_STOP_REASON, /* defaultValue= */ 0);
+          downloadManager.setStopReason(contentId, stopReason);
         }
         break;
-      case ACTION_RELOAD_REQUIREMENTS:
-        stopWatchingRequirements();
+      case ACTION_SET_REQUIREMENTS:
+        Requirements requirements = intent.getParcelableExtra(KEY_REQUIREMENTS);
+        if (requirements == null) {
+          Log.e(TAG, "Ignored SET_REQUIREMENTS: Missing " + KEY_REQUIREMENTS + " extra");
+        } else {
+          downloadManager.setRequirements(requirements);
+        }
         break;
       default:
-        Log.e(TAG, "Ignoring unrecognized action: " + intentAction);
+        Log.e(TAG, "Ignored unrecognized action: " + intentAction);
         break;
     }
 
-    Requirements requirements = getRequirements();
-    if (requirements.checkRequirements(this)) {
-      downloadManager.startDownloads();
-    } else {
-      downloadManager.stopDownloads();
-    }
-    maybeStartWatchingRequirements(requirements);
-
     if (downloadManager.isIdle()) {
       stop();
     }
@@ -289,31 +595,32 @@ public int onStartCommand(Intent intent, int flags, int startId) {
 
   @Override
   public void onTaskRemoved(Intent rootIntent) {
-    logd("onTaskRemoved rootIntent: " + rootIntent);
     taskRemoved = true;
   }
 
   @Override
   public void onDestroy() {
-    logd("onDestroy");
+    isDestroyed = true;
+    DownloadManagerHelper downloadManagerHelper = downloadManagerListeners.get(getClass());
+    boolean unschedule = !downloadManager.isWaitingForRequirements();
+    downloadManagerHelper.detachService(this, unschedule);
     if (foregroundNotificationUpdater != null) {
       foregroundNotificationUpdater.stopPeriodicUpdates();
     }
-    downloadManager.removeListener(downloadManagerListener);
-    maybeStopWatchingRequirements();
   }
 
+  /**
+   * Throws {@link UnsupportedOperationException} because this service is not designed to be bound.
+   */
   @Nullable
   @Override
-  public IBinder onBind(Intent intent) {
-    return null;
+  public final IBinder onBind(Intent intent) {
+    throw new UnsupportedOperationException();
   }
 
   /**
    * Returns a {@link DownloadManager} to be used to downloaded content. Called only once in the
-   * life cycle of the service. The service will call {@link DownloadManager#startDownloads()} and
-   * {@link DownloadManager#stopDownloads} as necessary when requirements returned by {@link
-   * #getRequirements()} are met or stop being met.
+   * life cycle of the process.
    */
   protected abstract DownloadManager getDownloadManager();
 
@@ -325,70 +632,69 @@ public IBinder onBind(Intent intent) {
   protected abstract @Nullable Scheduler getScheduler();
 
   /**
-   * Returns requirements for downloads to take place. By default the only requirement is that the
-   * device has network connectivity.
-   */
-  protected Requirements getRequirements() {
-    return DEFAULT_REQUIREMENTS;
-  }
-
-  /**
-   * Should be overridden in the subclass if the service will be run in the foreground.
-   *
-   * <p>Returns a notification to be displayed when this service running in the foreground.
-   *
-   * <p>This method is called when there is a task state change and periodically while there are
-   * active tasks. The periodic update interval can be set using {@link #DownloadService(int,
-   * long)}.
+   * Returns a notification to be displayed when this service running in the foreground. This method
+   * is called when there is a download state change and periodically while there are active
+   * downloads. The periodic update interval can be set using {@link #DownloadService(int, long)}.
    *
    * <p>On API level 26 and above, this method may also be called just before the service stops,
-   * with an empty {@code taskStates} array. The returned notification is used to satisfy system
+   * with an empty {@code downloads} array. The returned notification is used to satisfy system
    * requirements for foreground services.
    *
-   * @param taskStates The states of all current tasks.
+   * <p>Download services that do not wish to run in the foreground should be created by setting the
+   * {@code foregroundNotificationId} constructor argument to {@link
+   * #FOREGROUND_NOTIFICATION_ID_NONE}. This method will not be called in this case, meaning it can
+   * be implemented to throw {@link UnsupportedOperationException}.
+   *
+   * @param downloads The current downloads.
    * @return The foreground notification to display.
    */
-  protected Notification getForegroundNotification(TaskState[] taskStates) {
-    throw new IllegalStateException(
-        getClass().getName()
-            + " is started in the foreground but getForegroundNotification() is not implemented.");
+  protected abstract Notification getForegroundNotification(List<Download> downloads);
+
+  /**
+   * Invalidates the current foreground notification and causes {@link
+   * #getForegroundNotification(List)} to be invoked again if the service isn't stopped.
+   */
+  protected final void invalidateForegroundNotification() {
+    if (foregroundNotificationUpdater != null && !isDestroyed) {
+      foregroundNotificationUpdater.invalidate();
+    }
   }
 
   /**
-   * Called when the state of a task changes.
+   * Called when the state of a download changes. The default implementation is a no-op.
    *
-   * @param taskState The state of the task.
+   * @param download The new state of the download.
    */
-  protected void onTaskStateChanged(TaskState taskState) {
+  protected void onDownloadChanged(Download download) {
     // Do nothing.
   }
 
-  private void maybeStartWatchingRequirements(Requirements requirements) {
-    if (downloadManager.getDownloadCount() == 0) {
-      return;
-    }
-    Class<? extends DownloadService> clazz = getClass();
-    RequirementsHelper requirementsHelper = requirementsHelpers.get(clazz);
-    if (requirementsHelper == null) {
-      requirementsHelper = new RequirementsHelper(this, requirements, getScheduler(), clazz);
-      requirementsHelpers.put(clazz, requirementsHelper);
-      requirementsHelper.start();
-      logd("started watching requirements");
-    }
+  /**
+   * Called when a download is removed. The default implementation is a no-op.
+   *
+   * @param download The last state of the download before it was removed.
+   */
+  protected void onDownloadRemoved(Download download) {
+    // Do nothing.
   }
 
-  private void maybeStopWatchingRequirements() {
-    if (downloadManager.getDownloadCount() > 0) {
-      return;
+  private void notifyDownloadChanged(Download download) {
+    onDownloadChanged(download);
+    if (foregroundNotificationUpdater != null) {
+      if (download.state == Download.STATE_DOWNLOADING
+          || download.state == Download.STATE_REMOVING
+          || download.state == Download.STATE_RESTARTING) {
+        foregroundNotificationUpdater.startPeriodicUpdates();
+      } else {
+        foregroundNotificationUpdater.invalidate();
+      }
     }
-    stopWatchingRequirements();
   }
 
-  private void stopWatchingRequirements() {
-    RequirementsHelper requirementsHelper = requirementsHelpers.remove(getClass());
-    if (requirementsHelper != null) {
-      requirementsHelper.stop();
-      logd("stopped watching requirements");
+  private void notifyDownloadRemoved(Download download) {
+    onDownloadRemoved(download);
+    if (foregroundNotificationUpdater != null) {
+      foregroundNotificationUpdater.invalidate();
     }
   }
 
@@ -402,17 +708,14 @@ private void stop() {
     }
     if (Util.SDK_INT < 28 && taskRemoved) { // See [Internal: b/74248644].
       stopSelf();
-      logd("stopSelf()");
     } else {
-      boolean stopSelfResult = stopSelfResult(lastStartId);
-      logd("stopSelf(" + lastStartId + ") result: " + stopSelfResult);
+      stopSelfResult(lastStartId);
     }
   }
 
-  private void logd(String message) {
-    if (DEBUG) {
-      Log.d(TAG, message);
-    }
+  private static Intent getIntent(
+      Context context, Class<? extends DownloadService> clazz, String action, boolean foreground) {
+    return getIntent(context, clazz, action).putExtra(KEY_FOREGROUND, foreground);
   }
 
   private static Intent getIntent(
@@ -420,35 +723,20 @@ private static Intent getIntent(
     return new Intent(context, clazz).setAction(action);
   }
 
-  private final class DownloadManagerListener implements DownloadManager.Listener {
-    @Override
-    public void onInitialized(DownloadManager downloadManager) {
-      maybeStartWatchingRequirements(getRequirements());
-    }
-
-    @Override
-    public void onTaskStateChanged(DownloadManager downloadManager, TaskState taskState) {
-      DownloadService.this.onTaskStateChanged(taskState);
-      if (foregroundNotificationUpdater != null) {
-        if (taskState.state == TaskState.STATE_STARTED) {
-          foregroundNotificationUpdater.startPeriodicUpdates();
-        } else {
-          foregroundNotificationUpdater.update();
-        }
-      }
-    }
-
-    @Override
-    public final void onIdle(DownloadManager downloadManager) {
-      stop();
+  private static void startService(Context context, Intent intent, boolean foreground) {
+    if (foreground) {
+      Util.startForegroundService(context, intent);
+    } else {
+      context.startService(intent);
     }
   }
 
-  private final class ForegroundNotificationUpdater implements Runnable {
+  private final class ForegroundNotificationUpdater {
 
     private final int notificationId;
     private final long updateInterval;
     private final Handler handler;
+    private final Runnable updateRunnable;
 
     private boolean periodicUpdatesStarted;
     private boolean notificationDisplayed;
@@ -457,6 +745,7 @@ public ForegroundNotificationUpdater(int notificationId, long updateInterval) {
       this.notificationId = notificationId;
       this.updateInterval = updateInterval;
       this.handler = new Handler(Looper.getMainLooper());
+      this.updateRunnable = this::update;
     }
 
     public void startPeriodicUpdates() {
@@ -466,83 +755,114 @@ public void startPeriodicUpdates() {
 
     public void stopPeriodicUpdates() {
       periodicUpdatesStarted = false;
-      handler.removeCallbacks(this);
+      handler.removeCallbacks(updateRunnable);
     }
 
-    public void update() {
-      TaskState[] taskStates = downloadManager.getAllTaskStates();
-      startForeground(notificationId, getForegroundNotification(taskStates));
-      notificationDisplayed = true;
-      if (periodicUpdatesStarted) {
-        handler.removeCallbacks(this);
-        handler.postDelayed(this, updateInterval);
+    public void showNotificationIfNotAlready() {
+      if (!notificationDisplayed) {
+        update();
       }
     }
 
-    public void showNotificationIfNotAlready() {
-      if (!notificationDisplayed) {
+    public void invalidate() {
+      if (notificationDisplayed) {
         update();
       }
     }
 
-    @Override
-    public void run() {
-      update();
+    private void update() {
+      List<Download> downloads = downloadManager.getCurrentDownloads();
+      startForeground(notificationId, getForegroundNotification(downloads));
+      notificationDisplayed = true;
+      if (periodicUpdatesStarted) {
+        handler.removeCallbacks(updateRunnable);
+        handler.postDelayed(updateRunnable, updateInterval);
+      }
     }
   }
 
-  private static final class RequirementsHelper implements RequirementsWatcher.Listener {
+  private static final class DownloadManagerHelper implements DownloadManager.Listener {
 
     private final Context context;
-    private final Requirements requirements;
-    private final @Nullable Scheduler scheduler;
+    private final DownloadManager downloadManager;
+    @Nullable private final Scheduler scheduler;
     private final Class<? extends DownloadService> serviceClass;
-    private final RequirementsWatcher requirementsWatcher;
+    @Nullable private DownloadService downloadService;
 
-    private RequirementsHelper(
+    private DownloadManagerHelper(
         Context context,
-        Requirements requirements,
+        DownloadManager downloadManager,
         @Nullable Scheduler scheduler,
         Class<? extends DownloadService> serviceClass) {
       this.context = context;
-      this.requirements = requirements;
+      this.downloadManager = downloadManager;
       this.scheduler = scheduler;
       this.serviceClass = serviceClass;
-      requirementsWatcher = new RequirementsWatcher(context, this, requirements);
+      downloadManager.addListener(this);
+      if (scheduler != null) {
+        Requirements requirements = downloadManager.getRequirements();
+        setSchedulerEnabled(/* enabled= */ !requirements.checkRequirements(context), requirements);
+      }
     }
 
-    public void start() {
-      requirementsWatcher.start();
+    public void attachService(DownloadService downloadService) {
+      Assertions.checkState(this.downloadService == null);
+      this.downloadService = downloadService;
     }
 
-    public void stop() {
-      requirementsWatcher.stop();
-      if (scheduler != null) {
+    public void detachService(DownloadService downloadService, boolean unschedule) {
+      Assertions.checkState(this.downloadService == downloadService);
+      this.downloadService = null;
+      if (scheduler != null && unschedule) {
         scheduler.cancel();
       }
     }
 
     @Override
-    public void requirementsMet(RequirementsWatcher requirementsWatcher) {
-      try {
-        notifyService();
-      } catch (Exception e) {
-        /* If we can't notify the service, don't stop the scheduler. */
-        return;
+    public void onDownloadChanged(DownloadManager downloadManager, Download download) {
+      if (downloadService != null) {
+        downloadService.notifyDownloadChanged(download);
       }
-      if (scheduler != null) {
-        scheduler.cancel();
+    }
+
+    @Override
+    public void onDownloadRemoved(DownloadManager downloadManager, Download download) {
+      if (downloadService != null) {
+        downloadService.notifyDownloadRemoved(download);
+      }
+    }
+
+    @Override
+    public final void onIdle(DownloadManager downloadManager) {
+      if (downloadService != null) {
+        downloadService.stop();
       }
     }
 
     @Override
-    public void requirementsNotMet(RequirementsWatcher requirementsWatcher) {
-      try {
-        notifyService();
-      } catch (Exception e) {
-        /* Do nothing. The service isn't running anyway. */
+    public void onRequirementsStateChanged(
+        DownloadManager downloadManager,
+        Requirements requirements,
+        @Requirements.RequirementFlags int notMetRequirements) {
+      boolean requirementsMet = notMetRequirements == 0;
+      if (downloadService == null && requirementsMet) {
+        try {
+          Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_INIT);
+          context.startService(intent);
+        } catch (IllegalStateException e) {
+          /* startService fails if the app is in the background then don't stop the scheduler. */
+          return;
+        }
       }
       if (scheduler != null) {
+        setSchedulerEnabled(/* enabled= */ !requirementsMet, requirements);
+      }
+    }
+
+    private void setSchedulerEnabled(boolean enabled, Requirements requirements) {
+      if (!enabled) {
+        scheduler.cancel();
+      } else {
         String servicePackage = context.getPackageName();
         boolean success = scheduler.schedule(requirements, servicePackage, ACTION_RESTART);
         if (!success) {
@@ -550,15 +870,5 @@ public void requirementsNotMet(RequirementsWatcher requirementsWatcher) {
         }
       }
     }
-
-    private void notifyService() throws Exception {
-      Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_INIT);
-      try {
-        context.startService(intent);
-      } catch (IllegalStateException e) {
-        /* startService will fail if the app is in the background and the service isn't running. */
-        throw new Exception(e);
-      }
-    }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java
index 10523d6bc6..fa10d5842b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java
@@ -15,37 +15,44 @@
  */
 package com.google.android.exoplayer2.offline;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 
-/**
- * An interface for stream downloaders.
- */
+/** Downloads and removes a piece of content. */
 public interface Downloader {
 
+  /** Receives progress updates during download operations. */
+  interface ProgressListener {
+
+    /**
+     * Called when progress is made during a download operation.
+     *
+     * @param contentLength The length of the content in bytes, or {@link C#LENGTH_UNSET} if
+     *     unknown.
+     * @param bytesDownloaded The number of bytes that have been downloaded.
+     * @param percentDownloaded The percentage of the content that has been downloaded, or {@link
+     *     C#PERCENTAGE_UNSET}.
+     */
+    void onProgress(long contentLength, long bytesDownloaded, float percentDownloaded);
+  }
+
   /**
-   * Downloads the media.
+   * Downloads the content.
    *
-   * @throws DownloadException Thrown if the media cannot be downloaded.
+   * @param progressListener A listener to receive progress updates, or {@code null}.
+   * @throws DownloadException Thrown if the content cannot be downloaded.
    * @throws InterruptedException If the thread has been interrupted.
    * @throws IOException Thrown when there is an io error while downloading.
    */
-  void download() throws InterruptedException, IOException;
+  void download(@Nullable ProgressListener progressListener)
+      throws InterruptedException, IOException;
 
-  /** Interrupts any current download operation and prevents future operations from running. */
+  /** Cancels the download operation and prevents future download operations from running. */
   void cancel();
 
-  /** Returns the total number of downloaded bytes. */
-  long getDownloadedBytes();
-
-  /**
-   * Returns the estimated download percentage, or {@link C#PERCENTAGE_UNSET} if no estimate is
-   * available.
-   */
-  float getDownloadPercentage();
-
   /**
-   * Removes the media.
+   * Removes the content.
    *
    * @throws InterruptedException Thrown if the thread was interrupted.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
index 18387b9d92..65dcd187a9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
@@ -15,60 +15,125 @@
  */
 package com.google.android.exoplayer2.offline;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSource.Factory;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.FileDataSource;
-import com.google.android.exoplayer2.upstream.PriorityDataSource;
+import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
+import com.google.android.exoplayer2.upstream.PriorityDataSourceFactory;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSink;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSinkFactory;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
-import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSourceFactory;
+import com.google.android.exoplayer2.upstream.cache.CacheKeyFactory;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 
 /** A helper class that holds necessary parameters for {@link Downloader} construction. */
 public final class DownloaderConstructorHelper {
 
   private final Cache cache;
-  private final Factory upstreamDataSourceFactory;
-  private final Factory cacheReadDataSourceFactory;
-  private final DataSink.Factory cacheWriteDataSinkFactory;
-  private final PriorityTaskManager priorityTaskManager;
+  @Nullable private final CacheKeyFactory cacheKeyFactory;
+  @Nullable private final PriorityTaskManager priorityTaskManager;
+  private final CacheDataSourceFactory onlineCacheDataSourceFactory;
+  private final CacheDataSourceFactory offlineCacheDataSourceFactory;
 
   /**
    * @param cache Cache instance to be used to store downloaded data.
-   * @param upstreamDataSourceFactory A {@link Factory} for downloading data.
+   * @param upstreamFactory A {@link DataSource.Factory} for creating {@link DataSource}s for
+   *     downloading data.
    */
-  public DownloaderConstructorHelper(Cache cache, Factory upstreamDataSourceFactory) {
-    this(cache, upstreamDataSourceFactory, null, null, null);
+  public DownloaderConstructorHelper(Cache cache, DataSource.Factory upstreamFactory) {
+    this(
+        cache,
+        upstreamFactory,
+        /* cacheReadDataSourceFactory= */ null,
+        /* cacheWriteDataSinkFactory= */ null,
+        /* priorityTaskManager= */ null);
   }
 
   /**
    * @param cache Cache instance to be used to store downloaded data.
-   * @param upstreamDataSourceFactory A {@link Factory} for downloading data.
-   * @param cacheReadDataSourceFactory A {@link Factory} for reading data from the cache. If null
-   *     then standard {@link FileDataSource} instances will be used.
-   * @param cacheWriteDataSinkFactory A {@link DataSink.Factory} for writing data to the cache. If
-   *     null then standard {@link CacheDataSink} instances will be used.
+   * @param upstreamFactory A {@link DataSource.Factory} for creating {@link DataSource}s for
+   *     downloading data.
+   * @param cacheReadDataSourceFactory A {@link DataSource.Factory} for creating {@link DataSource}s
+   *     for reading data from the cache. If null then a {@link FileDataSourceFactory} will be used.
+   * @param cacheWriteDataSinkFactory A {@link DataSink.Factory} for creating {@link DataSource}s
+   *     for writing data to the cache. If null then a {@link CacheDataSinkFactory} will be used.
    * @param priorityTaskManager A {@link PriorityTaskManager} to use when downloading. If non-null,
    *     downloaders will register as tasks with priority {@link C#PRIORITY_DOWNLOAD} whilst
    *     downloading.
    */
   public DownloaderConstructorHelper(
       Cache cache,
-      Factory upstreamDataSourceFactory,
-      @Nullable Factory cacheReadDataSourceFactory,
+      DataSource.Factory upstreamFactory,
+      @Nullable DataSource.Factory cacheReadDataSourceFactory,
       @Nullable DataSink.Factory cacheWriteDataSinkFactory,
       @Nullable PriorityTaskManager priorityTaskManager) {
-    Assertions.checkNotNull(upstreamDataSourceFactory);
+    this(
+        cache,
+        upstreamFactory,
+        cacheReadDataSourceFactory,
+        cacheWriteDataSinkFactory,
+        priorityTaskManager,
+        /* cacheKeyFactory= */ null);
+  }
+
+  /**
+   * @param cache Cache instance to be used to store downloaded data.
+   * @param upstreamFactory A {@link DataSource.Factory} for creating {@link DataSource}s for
+   *     downloading data.
+   * @param cacheReadDataSourceFactory A {@link DataSource.Factory} for creating {@link DataSource}s
+   *     for reading data from the cache. If null then a {@link FileDataSourceFactory} will be used.
+   * @param cacheWriteDataSinkFactory A {@link DataSink.Factory} for creating {@link DataSource}s
+   *     for writing data to the cache. If null then a {@link CacheDataSinkFactory} will be used.
+   * @param priorityTaskManager A {@link PriorityTaskManager} to use when downloading. If non-null,
+   *     downloaders will register as tasks with priority {@link C#PRIORITY_DOWNLOAD} whilst
+   *     downloading.
+   * @param cacheKeyFactory An optional factory for cache keys.
+   */
+  public DownloaderConstructorHelper(
+      Cache cache,
+      DataSource.Factory upstreamFactory,
+      @Nullable DataSource.Factory cacheReadDataSourceFactory,
+      @Nullable DataSink.Factory cacheWriteDataSinkFactory,
+      @Nullable PriorityTaskManager priorityTaskManager,
+      @Nullable CacheKeyFactory cacheKeyFactory) {
+    if (priorityTaskManager != null) {
+      upstreamFactory =
+          new PriorityDataSourceFactory(upstreamFactory, priorityTaskManager, C.PRIORITY_DOWNLOAD);
+    }
+    DataSource.Factory readDataSourceFactory =
+        cacheReadDataSourceFactory != null
+            ? cacheReadDataSourceFactory
+            : new FileDataSourceFactory();
+    if (cacheWriteDataSinkFactory == null) {
+      cacheWriteDataSinkFactory =
+          new CacheDataSinkFactory(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE);
+    }
+    onlineCacheDataSourceFactory =
+        new CacheDataSourceFactory(
+            cache,
+            upstreamFactory,
+            readDataSourceFactory,
+            cacheWriteDataSinkFactory,
+            CacheDataSource.FLAG_BLOCK_ON_CACHE,
+            /* eventListener= */ null,
+            cacheKeyFactory);
+    offlineCacheDataSourceFactory =
+        new CacheDataSourceFactory(
+            cache,
+            DummyDataSource.FACTORY,
+            readDataSourceFactory,
+            null,
+            CacheDataSource.FLAG_BLOCK_ON_CACHE,
+            /* eventListener= */ null,
+            cacheKeyFactory);
     this.cache = cache;
-    this.upstreamDataSourceFactory = upstreamDataSourceFactory;
-    this.cacheReadDataSourceFactory = cacheReadDataSourceFactory;
-    this.cacheWriteDataSinkFactory = cacheWriteDataSinkFactory;
     this.priorityTaskManager = priorityTaskManager;
+    this.cacheKeyFactory = cacheKeyFactory;
   }
 
   /** Returns the {@link Cache} instance. */
@@ -76,6 +141,11 @@ public Cache getCache() {
     return cache;
   }
 
+  /** Returns the {@link CacheKeyFactory}. */
+  public CacheKeyFactory getCacheKeyFactory() {
+    return cacheKeyFactory != null ? cacheKeyFactory : CacheUtil.DEFAULT_CACHE_KEY_FACTORY;
+  }
+
   /** Returns a {@link PriorityTaskManager} instance. */
   public PriorityTaskManager getPriorityTaskManager() {
     // Return a dummy PriorityTaskManager if none is provided. Create a new PriorityTaskManager
@@ -83,26 +153,16 @@ public PriorityTaskManager getPriorityTaskManager() {
     return priorityTaskManager != null ? priorityTaskManager : new PriorityTaskManager();
   }
 
+  /** Returns a new {@link CacheDataSource} instance. */
+  public CacheDataSource createCacheDataSource() {
+    return onlineCacheDataSourceFactory.createDataSource();
+  }
+
   /**
-   * Returns a new {@link CacheDataSource} instance. If {@code offline} is true, it can only read
-   * data from the cache.
+   * Returns a new {@link CacheDataSource} instance which accesses cache read-only and throws an
+   * exception on cache miss.
    */
-  public CacheDataSource buildCacheDataSource(boolean offline) {
-    DataSource cacheReadDataSource = cacheReadDataSourceFactory != null
-        ? cacheReadDataSourceFactory.createDataSource() : new FileDataSource();
-    if (offline) {
-      return new CacheDataSource(cache, DummyDataSource.INSTANCE,
-          cacheReadDataSource, null, CacheDataSource.FLAG_BLOCK_ON_CACHE, null);
-    } else {
-      DataSink cacheWriteDataSink = cacheWriteDataSinkFactory != null
-          ? cacheWriteDataSinkFactory.createDataSink()
-          : new CacheDataSink(cache, CacheDataSource.DEFAULT_MAX_CACHE_FILE_SIZE);
-      DataSource upstream = upstreamDataSourceFactory.createDataSource();
-      upstream = priorityTaskManager == null ? upstream
-          : new PriorityDataSource(upstream, priorityTaskManager, C.PRIORITY_DOWNLOAD);
-      return new CacheDataSource(cache, upstream, cacheReadDataSource,
-          cacheWriteDataSink, CacheDataSource.FLAG_BLOCK_ON_CACHE, null);
-    }
+  public CacheDataSource createOfflineCacheDataSource() {
+    return offlineCacheDataSourceFactory.createDataSource();
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderFactory.java
new file mode 100644
index 0000000000..f98ca3eac3
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderFactory.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+/** Creates {@link Downloader Downloaders} for given {@link DownloadRequest DownloadRequests}. */
+public interface DownloaderFactory {
+
+  /**
+   * Creates a {@link Downloader} to perform the given {@link DownloadRequest}.
+   *
+   * @param action The action.
+   * @return The downloader.
+   */
+  Downloader createDownloader(DownloadRequest action);
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java
index c32cdf7126..7e15987c40 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/FilteringManifestParser.java
@@ -16,22 +16,27 @@
 package com.google.android.exoplayer2.offline;
 
 import android.net.Uri;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.ParsingLoadable.Parser;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.List;
 
-/** A manifest parser that includes only the streams identified by the given stream keys. */
+/**
+ * A manifest parser that includes only the streams identified by the given stream keys.
+ *
+ * @param <T> The {@link FilterableManifest} type.
+ */
 public final class FilteringManifestParser<T extends FilterableManifest<T>> implements Parser<T> {
 
-  private final Parser<T> parser;
-  private final List<StreamKey> streamKeys;
+  private final Parser<? extends T> parser;
+  @Nullable private final List<StreamKey> streamKeys;
 
   /**
    * @param parser A parser for the manifest that will be filtered.
    * @param streamKeys The stream keys. If null or empty then filtering will not occur.
    */
-  public FilteringManifestParser(Parser<T> parser, List<StreamKey> streamKeys) {
+  public FilteringManifestParser(Parser<? extends T> parser, @Nullable List<StreamKey> streamKeys) {
     this.parser = parser;
     this.streamKeys = streamKeys;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java
deleted file mode 100644
index 7ced2fa41b..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadAction.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil;
-import com.google.android.exoplayer2.util.Util;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-/** An action to download or remove downloaded progressive streams. */
-public final class ProgressiveDownloadAction extends DownloadAction {
-
-  private static final String TYPE = "progressive";
-  private static final int VERSION = 0;
-
-  public static final Deserializer DESERIALIZER =
-      new Deserializer(TYPE, VERSION) {
-        @Override
-        public ProgressiveDownloadAction readFromStream(int version, DataInputStream input)
-            throws IOException {
-          Uri uri = Uri.parse(input.readUTF());
-          boolean isRemoveAction = input.readBoolean();
-          int dataLength = input.readInt();
-          byte[] data = new byte[dataLength];
-          input.readFully(data);
-          String customCacheKey = input.readBoolean() ? input.readUTF() : null;
-          return new ProgressiveDownloadAction(uri, isRemoveAction, data, customCacheKey);
-        }
-      };
-
-  private final @Nullable String customCacheKey;
-
-  /**
-   * Creates a progressive stream download action.
-   *
-   * @param uri Uri of the data to be downloaded.
-   * @param data Optional custom data for this action.
-   * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
-   *     is used for cache indexing.
-   */
-  public static ProgressiveDownloadAction createDownloadAction(
-      Uri uri, @Nullable byte[] data, @Nullable String customCacheKey) {
-    return new ProgressiveDownloadAction(uri, /* isRemoveAction= */ false, data, customCacheKey);
-  }
-
-  /**
-   * Creates a progressive stream remove action.
-   *
-   * @param uri Uri of the data to be removed.
-   * @param data Optional custom data for this action.
-   * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
-   *     is used for cache indexing.
-   */
-  public static ProgressiveDownloadAction createRemoveAction(
-      Uri uri, @Nullable byte[] data, @Nullable String customCacheKey) {
-    return new ProgressiveDownloadAction(uri, /* isRemoveAction= */ true, data, customCacheKey);
-  }
-
-  /**
-   * @param uri Uri of the data to be downloaded.
-   * @param isRemoveAction Whether this is a remove action. If false, this is a download action.
-   * @param data Optional custom data for this action.
-   * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
-   *     is used for cache indexing.
-   * @deprecated Use {@link #createDownloadAction(Uri, byte[], String)} or {@link
-   *     #createRemoveAction(Uri, byte[], String)}.
-   */
-  @Deprecated
-  public ProgressiveDownloadAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, @Nullable String customCacheKey) {
-    super(TYPE, VERSION, uri, isRemoveAction, data);
-    this.customCacheKey = customCacheKey;
-  }
-
-  @Override
-  public ProgressiveDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
-    return new ProgressiveDownloader(uri, customCacheKey, constructorHelper);
-  }
-
-  @Override
-  protected void writeToStream(DataOutputStream output) throws IOException {
-    output.writeUTF(uri.toString());
-    output.writeBoolean(isRemoveAction);
-    output.writeInt(data.length);
-    output.write(data);
-    boolean customCacheKeySet = customCacheKey != null;
-    output.writeBoolean(customCacheKeySet);
-    if (customCacheKeySet) {
-      output.writeUTF(customCacheKey);
-    }
-  }
-
-  @Override
-  public boolean isSameMedia(DownloadAction other) {
-    return ((other instanceof ProgressiveDownloadAction)
-        && getCacheKey().equals(((ProgressiveDownloadAction) other).getCacheKey()));
-  }
-
-  @Override
-  public boolean equals(@Nullable Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (!super.equals(o)) {
-      return false;
-    }
-    ProgressiveDownloadAction that = (ProgressiveDownloadAction) o;
-    return Util.areEqual(customCacheKey, that.customCacheKey);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result = 31 * result + (customCacheKey != null ? customCacheKey.hashCode() : 0);
-    return result;
-  }
-
-  private String getCacheKey() {
-    return customCacheKey != null ? customCacheKey : CacheUtil.generateKey(uri);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java
deleted file mode 100644
index 473209803a..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloadHelper.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import java.util.List;
-
-/** A {@link DownloadHelper} for progressive streams. */
-public final class ProgressiveDownloadHelper extends DownloadHelper {
-
-  private final Uri uri;
-  private final @Nullable String customCacheKey;
-
-  public ProgressiveDownloadHelper(Uri uri) {
-    this(uri, null);
-  }
-
-  public ProgressiveDownloadHelper(Uri uri, @Nullable String customCacheKey) {
-    this.uri = uri;
-    this.customCacheKey = customCacheKey;
-  }
-
-  @Override
-  protected void prepareInternal() {
-    // Do nothing.
-  }
-
-  @Override
-  public int getPeriodCount() {
-    return 1;
-  }
-
-  @Override
-  public TrackGroupArray getTrackGroups(int periodIndex) {
-    return TrackGroupArray.EMPTY;
-  }
-
-  @Override
-  public ProgressiveDownloadAction getDownloadAction(
-      @Nullable byte[] data, List<TrackKey> trackKeys) {
-    return ProgressiveDownloadAction.createDownloadAction(uri, data, customCacheKey);
-  }
-
-  @Override
-  public ProgressiveDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return ProgressiveDownloadAction.createRemoveAction(uri, data, customCacheKey);
-  }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
index 8c80a23d67..17f4047bc0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
@@ -16,12 +16,13 @@
 package com.google.android.exoplayer2.offline;
 
 import android.net.Uri;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheKeyFactory;
 import com.google.android.exoplayer2.upstream.cache.CacheUtil;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -36,8 +37,8 @@
   private final DataSpec dataSpec;
   private final Cache cache;
   private final CacheDataSource dataSource;
+  private final CacheKeyFactory cacheKeyFactory;
   private final PriorityTaskManager priorityTaskManager;
-  private final CacheUtil.CachingCounters cachingCounters;
   private final AtomicBoolean isCanceled;
 
   /**
@@ -47,27 +48,35 @@
    * @param constructorHelper A {@link DownloaderConstructorHelper} instance.
    */
   public ProgressiveDownloader(
-      Uri uri, String customCacheKey, DownloaderConstructorHelper constructorHelper) {
-    this.dataSpec = new DataSpec(uri, 0, C.LENGTH_UNSET, customCacheKey, 0);
+      Uri uri, @Nullable String customCacheKey, DownloaderConstructorHelper constructorHelper) {
+    this.dataSpec =
+        new DataSpec(
+            uri,
+            /* absoluteStreamPosition= */ 0,
+            C.LENGTH_UNSET,
+            customCacheKey,
+            /* flags= */ DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION);
     this.cache = constructorHelper.getCache();
-    this.dataSource = constructorHelper.buildCacheDataSource(false);
+    this.dataSource = constructorHelper.createCacheDataSource();
+    this.cacheKeyFactory = constructorHelper.getCacheKeyFactory();
     this.priorityTaskManager = constructorHelper.getPriorityTaskManager();
-    cachingCounters = new CachingCounters();
     isCanceled = new AtomicBoolean();
   }
 
   @Override
-  public void download() throws InterruptedException, IOException {
+  public void download(@Nullable ProgressListener progressListener)
+      throws InterruptedException, IOException {
     priorityTaskManager.add(C.PRIORITY_DOWNLOAD);
     try {
       CacheUtil.cache(
           dataSpec,
           cache,
+          cacheKeyFactory,
           dataSource,
           new byte[BUFFER_SIZE_BYTES],
           priorityTaskManager,
           C.PRIORITY_DOWNLOAD,
-          cachingCounters,
+          progressListener == null ? null : new ProgressForwarder(progressListener),
           isCanceled,
           /* enableEOFException= */ true);
     } finally {
@@ -81,20 +90,25 @@ public void cancel() {
   }
 
   @Override
-  public long getDownloadedBytes() {
-    return cachingCounters.totalCachedBytes();
+  public void remove() {
+    CacheUtil.remove(dataSpec, cache, cacheKeyFactory);
   }
 
-  @Override
-  public float getDownloadPercentage() {
-    long contentLength = cachingCounters.contentLength;
-    return contentLength == C.LENGTH_UNSET
-        ? C.PERCENTAGE_UNSET
-        : ((cachingCounters.totalCachedBytes() * 100f) / contentLength);
-  }
+  private static final class ProgressForwarder implements CacheUtil.ProgressListener {
 
-  @Override
-  public void remove() {
-    CacheUtil.remove(cache, CacheUtil.getKey(dataSpec));
+    private final ProgressListener progessListener;
+
+    public ProgressForwarder(ProgressListener progressListener) {
+      this.progessListener = progressListener;
+    }
+
+    @Override
+    public void onProgress(long contentLength, long bytesCached, long newBytesCached) {
+      float percentDownloaded =
+          contentLength == C.LENGTH_UNSET || contentLength == 0
+              ? C.PERCENTAGE_UNSET
+              : ((bytesCached * 100f) / contentLength);
+      progessListener.onProgress(contentLength, bytesCached, percentDownloaded);
+    }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java
deleted file mode 100644
index 403b4e797b..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloadAction.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/** {@link DownloadAction} for {@link SegmentDownloader}s. */
-public abstract class SegmentDownloadAction extends DownloadAction {
-
-  /** Base class for {@link SegmentDownloadAction} {@link Deserializer}s. */
-  protected abstract static class SegmentDownloadActionDeserializer extends Deserializer {
-
-    public SegmentDownloadActionDeserializer(String type, int version) {
-      super(type, version);
-    }
-
-    @Override
-    public final DownloadAction readFromStream(int version, DataInputStream input)
-        throws IOException {
-      Uri uri = Uri.parse(input.readUTF());
-      boolean isRemoveAction = input.readBoolean();
-      int dataLength = input.readInt();
-      byte[] data = new byte[dataLength];
-      input.readFully(data);
-      int keyCount = input.readInt();
-      List<StreamKey> keys = new ArrayList<>();
-      for (int i = 0; i < keyCount; i++) {
-        keys.add(readKey(version, input));
-      }
-      return createDownloadAction(uri, isRemoveAction, data, keys);
-    }
-
-    /** Deserializes a key from the {@code input}. */
-    protected StreamKey readKey(int version, DataInputStream input) throws IOException {
-      int periodIndex = input.readInt();
-      int groupIndex = input.readInt();
-      int trackIndex = input.readInt();
-      return new StreamKey(periodIndex, groupIndex, trackIndex);
-    }
-
-    /** Returns a {@link DownloadAction}. */
-    protected abstract DownloadAction createDownloadAction(
-        Uri manifestUri, boolean isRemoveAction, byte[] data, List<StreamKey> keys);
-  }
-
-  public final List<StreamKey> keys;
-
-  /**
-   * @param type The type of the action.
-   * @param version The action version.
-   * @param uri The URI of the media being downloaded.
-   * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded. If {@code
-   *     removeAction} is true, {@code keys} must be empty.
-   */
-  protected SegmentDownloadAction(
-      String type,
-      int version,
-      Uri uri,
-      boolean isRemoveAction,
-      @Nullable byte[] data,
-      List<StreamKey> keys) {
-    super(type, version, uri, isRemoveAction, data);
-    if (isRemoveAction) {
-      Assertions.checkArgument(keys.isEmpty());
-      this.keys = Collections.emptyList();
-    } else {
-      ArrayList<StreamKey> mutableKeys = new ArrayList<>(keys);
-      Collections.sort(mutableKeys);
-      this.keys = Collections.unmodifiableList(mutableKeys);
-    }
-  }
-
-  @Override
-  public List<StreamKey> getKeys() {
-    return keys;
-  }
-
-  @Override
-  public final void writeToStream(DataOutputStream output) throws IOException {
-    output.writeUTF(uri.toString());
-    output.writeBoolean(isRemoveAction);
-    output.writeInt(data.length);
-    output.write(data);
-    output.writeInt(keys.size());
-    for (int i = 0; i < keys.size(); i++) {
-      writeKey(output, keys.get(i));
-    }
-  }
-
-  @Override
-  public boolean equals(@Nullable Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (!super.equals(o)) {
-      return false;
-    }
-    SegmentDownloadAction that = (SegmentDownloadAction) o;
-    return keys.equals(that.keys);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result = 31 * result + keys.hashCode();
-    return result;
-  }
-
-  /** Serializes the {@code key} into the {@code output}. */
-  private void writeKey(DataOutputStream output, StreamKey key) throws IOException {
-    output.writeInt(key.periodIndex);
-    output.writeInt(key.groupIndex);
-    output.writeInt(key.trackIndex);
-  }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
index 625ec4f5e7..1643812ece 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -16,14 +16,16 @@
 package com.google.android.exoplayer2.offline;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheKeyFactory;
 import com.google.android.exoplayer2.upstream.cache.CacheUtil;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -41,6 +43,7 @@
 
   /** Smallest unit of content to be downloaded. */
   protected static class Segment implements Comparable<Segment> {
+
     /** The start time of the segment in microseconds. */
     public final long startTimeUs;
 
@@ -61,18 +64,15 @@ public int compareTo(@NonNull Segment other) {
 
   private static final int BUFFER_SIZE_BYTES = 128 * 1024;
 
-  private final Uri manifestUri;
-  private final PriorityTaskManager priorityTaskManager;
+  private final DataSpec manifestDataSpec;
   private final Cache cache;
   private final CacheDataSource dataSource;
   private final CacheDataSource offlineDataSource;
+  private final CacheKeyFactory cacheKeyFactory;
+  private final PriorityTaskManager priorityTaskManager;
   private final ArrayList<StreamKey> streamKeys;
   private final AtomicBoolean isCanceled;
 
-  private volatile int totalSegments;
-  private volatile int downloadedSegments;
-  private volatile long downloadedBytes;
-
   /**
    * @param manifestUri The {@link Uri} of the manifest to be downloaded.
    * @param streamKeys Keys defining which streams in the manifest should be selected for download.
@@ -81,13 +81,13 @@ public int compareTo(@NonNull Segment other) {
    */
   public SegmentDownloader(
       Uri manifestUri, List<StreamKey> streamKeys, DownloaderConstructorHelper constructorHelper) {
-    this.manifestUri = manifestUri;
+    this.manifestDataSpec = getCompressibleDataSpec(manifestUri);
     this.streamKeys = new ArrayList<>(streamKeys);
     this.cache = constructorHelper.getCache();
-    this.dataSource = constructorHelper.buildCacheDataSource(false);
-    this.offlineDataSource = constructorHelper.buildCacheDataSource(true);
+    this.dataSource = constructorHelper.createCacheDataSource();
+    this.offlineDataSource = constructorHelper.createOfflineCacheDataSource();
+    this.cacheKeyFactory = constructorHelper.getCacheKeyFactory();
     this.priorityTaskManager = constructorHelper.getPriorityTaskManager();
-    totalSegments = C.LENGTH_UNSET;
     isCanceled = new AtomicBoolean();
   }
 
@@ -98,33 +98,71 @@ public SegmentDownloader(
    * @throws IOException Thrown when there is an error downloading.
    * @throws InterruptedException If the thread has been interrupted.
    */
-  // downloadedSegments and downloadedBytes are only written from this method, and this method
-  // should not be called from more than one thread. Hence non-atomic updates are valid.
-  @SuppressWarnings("NonAtomicVolatileUpdate")
   @Override
-  public final void download() throws IOException, InterruptedException {
+  public final void download(@Nullable ProgressListener progressListener)
+      throws IOException, InterruptedException {
     priorityTaskManager.add(C.PRIORITY_DOWNLOAD);
-
     try {
-      List<Segment> segments = initDownload();
+      // Get the manifest and all of the segments.
+      M manifest = getManifest(dataSource, manifestDataSpec);
+      if (!streamKeys.isEmpty()) {
+        manifest = manifest.copy(streamKeys);
+      }
+      List<Segment> segments = getSegments(dataSource, manifest, /* allowIncompleteList= */ false);
+
+      // Scan the segments, removing any that are fully downloaded.
+      int totalSegments = segments.size();
+      int segmentsDownloaded = 0;
+      long contentLength = 0;
+      long bytesDownloaded = 0;
+      for (int i = segments.size() - 1; i >= 0; i--) {
+        Segment segment = segments.get(i);
+        Pair<Long, Long> segmentLengthAndBytesDownloaded =
+            CacheUtil.getCached(segment.dataSpec, cache, cacheKeyFactory);
+        long segmentLength = segmentLengthAndBytesDownloaded.first;
+        long segmentBytesDownloaded = segmentLengthAndBytesDownloaded.second;
+        bytesDownloaded += segmentBytesDownloaded;
+        if (segmentLength != C.LENGTH_UNSET) {
+          if (segmentLength == segmentBytesDownloaded) {
+            // The segment is fully downloaded.
+            segmentsDownloaded++;
+            segments.remove(i);
+          }
+          if (contentLength != C.LENGTH_UNSET) {
+            contentLength += segmentLength;
+          }
+        } else {
+          contentLength = C.LENGTH_UNSET;
+        }
+      }
       Collections.sort(segments);
+
+      // Download the segments.
+      ProgressNotifier progressNotifier = null;
+      if (progressListener != null) {
+        progressNotifier =
+            new ProgressNotifier(
+                progressListener,
+                contentLength,
+                totalSegments,
+                bytesDownloaded,
+                segmentsDownloaded);
+      }
       byte[] buffer = new byte[BUFFER_SIZE_BYTES];
-      CachingCounters cachingCounters = new CachingCounters();
       for (int i = 0; i < segments.size(); i++) {
-        try {
-          CacheUtil.cache(
-              segments.get(i).dataSpec,
-              cache,
-              dataSource,
-              buffer,
-              priorityTaskManager,
-              C.PRIORITY_DOWNLOAD,
-              cachingCounters,
-              isCanceled,
-              true);
-          downloadedSegments++;
-        } finally {
-          downloadedBytes += cachingCounters.newlyCachedBytes;
+        CacheUtil.cache(
+            segments.get(i).dataSpec,
+            cache,
+            cacheKeyFactory,
+            dataSource,
+            buffer,
+            priorityTaskManager,
+            C.PRIORITY_DOWNLOAD,
+            progressNotifier,
+            isCanceled,
+            true);
+        if (progressNotifier != null) {
+          progressNotifier.onSegmentDownloaded();
         }
       }
     } finally {
@@ -137,35 +175,19 @@ public void cancel() {
     isCanceled.set(true);
   }
 
-  @Override
-  public final long getDownloadedBytes() {
-    return downloadedBytes;
-  }
-
-  @Override
-  public final float getDownloadPercentage() {
-    // Take local snapshot of the volatile fields
-    int totalSegments = this.totalSegments;
-    int downloadedSegments = this.downloadedSegments;
-    if (totalSegments == C.LENGTH_UNSET || downloadedSegments == C.LENGTH_UNSET) {
-      return C.PERCENTAGE_UNSET;
-    }
-    return totalSegments == 0 ? 100f : (downloadedSegments * 100f) / totalSegments;
-  }
-
   @Override
   public final void remove() throws InterruptedException {
     try {
-      M manifest = getManifest(offlineDataSource, manifestUri);
+      M manifest = getManifest(offlineDataSource, manifestDataSpec);
       List<Segment> segments = getSegments(offlineDataSource, manifest, true);
       for (int i = 0; i < segments.size(); i++) {
-        removeUri(segments.get(i).dataSpec.uri);
+        removeDataSpec(segments.get(i).dataSpec);
       }
     } catch (IOException e) {
       // Ignore exceptions when removing.
     } finally {
       // Always attempt to remove the manifest.
-      removeUri(manifestUri);
+      removeDataSpec(manifestDataSpec);
     }
   }
 
@@ -175,11 +197,11 @@ public final void remove() throws InterruptedException {
    * Loads and parses the manifest.
    *
    * @param dataSource The {@link DataSource} through which to load.
-   * @param uri The manifest uri.
+   * @param dataSpec The manifest {@link DataSpec}.
    * @return The manifest.
    * @throws IOException If an error occurs reading data.
    */
-  protected abstract M getManifest(DataSource dataSource, Uri uri) throws IOException;
+  protected abstract M getManifest(DataSource dataSource, DataSpec dataSpec) throws IOException;
 
   /**
    * Returns a list of all downloadable {@link Segment}s for a given manifest.
@@ -189,43 +211,70 @@ public final void remove() throws InterruptedException {
    * @param allowIncompleteList Whether to continue in the case that a load error prevents all
    *     segments from being listed. If true then a partial segment list will be returned. If false
    *     an {@link IOException} will be thrown.
+   * @return The list of downloadable {@link Segment}s.
    * @throws InterruptedException Thrown if the thread was interrupted.
    * @throws IOException Thrown if {@code allowPartialIndex} is false and a load error occurs, or if
    *     the media is not in a form that allows for its segments to be listed.
-   * @return The list of downloadable {@link Segment}s.
    */
   protected abstract List<Segment> getSegments(
       DataSource dataSource, M manifest, boolean allowIncompleteList)
       throws InterruptedException, IOException;
 
-  /** Initializes the download, returning a list of {@link Segment}s that need to be downloaded. */
-  // Writes to downloadedSegments and downloadedBytes are safe. See the comment on download().
-  @SuppressWarnings("NonAtomicVolatileUpdate")
-  private List<Segment> initDownload() throws IOException, InterruptedException {
-    M manifest = getManifest(dataSource, manifestUri);
-    if (!streamKeys.isEmpty()) {
-      manifest = manifest.copy(streamKeys);
-    }
-    List<Segment> segments = getSegments(dataSource, manifest, /* allowIncompleteList= */ false);
-    CachingCounters cachingCounters = new CachingCounters();
-    totalSegments = segments.size();
-    downloadedSegments = 0;
-    downloadedBytes = 0;
-    for (int i = segments.size() - 1; i >= 0; i--) {
-      Segment segment = segments.get(i);
-      CacheUtil.getCached(segment.dataSpec, cache, cachingCounters);
-      downloadedBytes += cachingCounters.alreadyCachedBytes;
-      if (cachingCounters.alreadyCachedBytes == cachingCounters.contentLength) {
-        // The segment is fully downloaded.
-        downloadedSegments++;
-        segments.remove(i);
-      }
-    }
-    return segments;
+  private void removeDataSpec(DataSpec dataSpec) {
+    CacheUtil.remove(dataSpec, cache, cacheKeyFactory);
   }
 
-  private void removeUri(Uri uri) {
-    CacheUtil.remove(cache, CacheUtil.generateKey(uri));
+  protected static DataSpec getCompressibleDataSpec(Uri uri) {
+    return new DataSpec(
+        uri,
+        /* absoluteStreamPosition= */ 0,
+        /* length= */ C.LENGTH_UNSET,
+        /* key= */ null,
+        /* flags= */ DataSpec.FLAG_ALLOW_GZIP);
   }
 
+  private static final class ProgressNotifier implements CacheUtil.ProgressListener {
+
+    private final ProgressListener progressListener;
+
+    private final long contentLength;
+    private final int totalSegments;
+
+    private long bytesDownloaded;
+    private int segmentsDownloaded;
+
+    public ProgressNotifier(
+        ProgressListener progressListener,
+        long contentLength,
+        int totalSegments,
+        long bytesDownloaded,
+        int segmentsDownloaded) {
+      this.progressListener = progressListener;
+      this.contentLength = contentLength;
+      this.totalSegments = totalSegments;
+      this.bytesDownloaded = bytesDownloaded;
+      this.segmentsDownloaded = segmentsDownloaded;
+    }
+
+    @Override
+    public void onProgress(long requestLength, long bytesCached, long newBytesCached) {
+      bytesDownloaded += newBytesCached;
+      progressListener.onProgress(contentLength, bytesDownloaded, getPercentDownloaded());
+    }
+
+    public void onSegmentDownloaded() {
+      segmentsDownloaded++;
+      progressListener.onProgress(contentLength, bytesDownloaded, getPercentDownloaded());
+    }
+
+    private float getPercentDownloaded() {
+      if (contentLength != C.LENGTH_UNSET && contentLength != 0) {
+        return (bytesDownloaded * 100f) / contentLength;
+      } else if (totalSegments != 0) {
+        return (segmentsDownloaded * 100f) / totalSegments;
+      } else {
+        return C.PERCENTAGE_UNSET;
+      }
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
index 838073cd99..977be9a198 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
@@ -15,14 +15,19 @@
  */
 package com.google.android.exoplayer2.offline;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 /**
- * Identifies a given track by the index of the containing period, the index of the containing group
- * within the period, and the index of the track within the group.
+ * A key for a subset of media which can be separately loaded (a "stream").
+ *
+ * <p>The stream key consists of a period index, a group index within the period and a track index
+ * within the group. The interpretation of these indices depends on the type of media for which the
+ * stream key is used.
  */
-public final class StreamKey implements Comparable<StreamKey> {
+public final class StreamKey implements Comparable<StreamKey>, Parcelable {
 
   /** The period index. */
   public final int periodIndex;
@@ -50,6 +55,12 @@ public StreamKey(int periodIndex, int groupIndex, int trackIndex) {
     this.trackIndex = trackIndex;
   }
 
+  /* package */ StreamKey(Parcel in) {
+    periodIndex = in.readInt();
+    groupIndex = in.readInt();
+    trackIndex = in.readInt();
+  }
+
   @Override
   public String toString() {
     return periodIndex + "." + groupIndex + "." + trackIndex;
@@ -91,4 +102,32 @@ public int compareTo(@NonNull StreamKey o) {
     }
     return result;
   }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(periodIndex);
+    dest.writeInt(groupIndex);
+    dest.writeInt(trackIndex);
+  }
+
+  public static final Parcelable.Creator<StreamKey> CREATOR =
+      new Parcelable.Creator<StreamKey>() {
+
+        @Override
+        public StreamKey createFromParcel(Parcel in) {
+          return new StreamKey(in);
+        }
+
+        @Override
+        public StreamKey[] newArray(int size) {
+          return new StreamKey[size];
+        }
+      };
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/TrackKey.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/TrackKey.java
deleted file mode 100644
index f6a411c3a1..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/TrackKey.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.offline;
-
-/**
- * Identifies a given track by the index of the containing period, the index of the containing group
- * within the period, and the index of the track within the group.
- */
-public final class TrackKey {
-
-  /** The period index. */
-  public final int periodIndex;
-  /** The group index. */
-  public final int groupIndex;
-  /** The track index. */
-  public final int trackIndex;
-
-  /**
-   * @param periodIndex The period index.
-   * @param groupIndex The group index.
-   * @param trackIndex The track index.
-   */
-  public TrackKey(int periodIndex, int groupIndex, int trackIndex) {
-    this.periodIndex = periodIndex;
-    this.groupIndex = groupIndex;
-    this.trackIndex = trackIndex;
-  }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
new file mode 100644
index 0000000000..ae634f8544
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import java.io.IOException;
+
+/** A writable index of {@link Download Downloads}. */
+public interface WritableDownloadIndex extends DownloadIndex {
+
+  /**
+   * Adds or replaces a {@link Download}.
+   *
+   * @param download The {@link Download} to be added.
+   * @throws IOException If an error occurs setting the state.
+   */
+  void putDownload(Download download) throws IOException;
+
+  /**
+   * Removes the download with the given ID. Does nothing if a download with the given ID does not
+   * exist.
+   *
+   * @param id The ID of the download to remove.
+   * @throws IOException If an error occurs removing the state.
+   */
+  void removeDownload(String id) throws IOException;
+
+  /**
+   * Sets all {@link Download#STATE_DOWNLOADING} states to {@link Download#STATE_QUEUED}.
+   *
+   * @throws IOException If an error occurs updating the state.
+   */
+  void setDownloadingStatesToQueued() throws IOException;
+
+  /**
+   * Sets the stop reason of the downloads in a terminal state ({@link Download#STATE_COMPLETED},
+   * {@link Download#STATE_FAILED}).
+   *
+   * @param stopReason The stop reason.
+   * @throws IOException If an error occurs updating the state.
+   */
+  void setStopReason(int stopReason) throws IOException;
+
+  /**
+   * Sets the stop reason of the download with the given ID in a terminal state ({@link
+   * Download#STATE_COMPLETED}, {@link Download#STATE_FAILED}). Does nothing if a download with the
+   * given ID does not exist, or if it's not in a terminal state.
+   *
+   * @param id The ID of the download to update.
+   * @param stopReason The stop reason.
+   * @throws IOException If an error occurs updating the state.
+   */
+  void setStopReason(String id, int stopReason) throws IOException;
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
index ed06d3745a..8572c9c7ca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
@@ -24,7 +24,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.PersistableBundle;
-import android.support.annotation.RequiresPermission;
+import androidx.annotation.RequiresPermission;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
@@ -44,6 +44,7 @@
 @TargetApi(21)
 public final class PlatformScheduler implements Scheduler {
 
+  private static final boolean DEBUG = false;
   private static final String TAG = "PlatformScheduler";
   private static final String KEY_SERVICE_ACTION = "service_action";
   private static final String KEY_SERVICE_PACKAGE = "service_package";
@@ -93,36 +94,11 @@ private static JobInfo buildJobInfo(
       String servicePackage) {
     JobInfo.Builder builder = new JobInfo.Builder(jobId, jobServiceComponentName);
 
-    int networkType;
-    switch (requirements.getRequiredNetworkType()) {
-      case Requirements.NETWORK_TYPE_NONE:
-        networkType = JobInfo.NETWORK_TYPE_NONE;
-        break;
-      case Requirements.NETWORK_TYPE_ANY:
-        networkType = JobInfo.NETWORK_TYPE_ANY;
-        break;
-      case Requirements.NETWORK_TYPE_UNMETERED:
-        networkType = JobInfo.NETWORK_TYPE_UNMETERED;
-        break;
-      case Requirements.NETWORK_TYPE_NOT_ROAMING:
-        if (Util.SDK_INT >= 24) {
-          networkType = JobInfo.NETWORK_TYPE_NOT_ROAMING;
-        } else {
-          throw new UnsupportedOperationException();
-        }
-        break;
-      case Requirements.NETWORK_TYPE_METERED:
-        if (Util.SDK_INT >= 26) {
-          networkType = JobInfo.NETWORK_TYPE_METERED;
-        } else {
-          throw new UnsupportedOperationException();
-        }
-        break;
-      default:
-        throw new UnsupportedOperationException();
+    if (requirements.isUnmeteredNetworkRequired()) {
+      builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);
+    } else if (requirements.isNetworkRequired()) {
+      builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);
     }
-
-    builder.setRequiredNetworkType(networkType);
     builder.setRequiresDeviceIdle(requirements.isIdleRequired());
     builder.setRequiresCharging(requirements.isChargingRequired());
     builder.setPersisted(true);
@@ -130,7 +106,7 @@ private static JobInfo buildJobInfo(
     PersistableBundle extras = new PersistableBundle();
     extras.putString(KEY_SERVICE_ACTION, serviceAction);
     extras.putString(KEY_SERVICE_PACKAGE, servicePackage);
-    extras.putInt(KEY_REQUIREMENTS, requirements.getRequirementsData());
+    extras.putInt(KEY_REQUIREMENTS, requirements.getRequirements());
     builder.setExtras(extras);
 
     return builder.build();
@@ -153,6 +129,8 @@ public boolean onStartJob(JobParameters params) {
         logd("Requirements are met");
         String serviceAction = extras.getString(KEY_SERVICE_ACTION);
         String servicePackage = extras.getString(KEY_SERVICE_PACKAGE);
+        // FIXME: incompatible types in argument.
+        @SuppressWarnings("nullness:argument.type.incompatible")
         Intent intent = new Intent(serviceAction).setPackage(servicePackage);
         logd("Starting service action: " + serviceAction + " package: " + servicePackage);
         Util.startForegroundService(this, intent);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
index 5acd31ee0d..30cf452572 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
@@ -23,96 +23,71 @@
 import android.net.NetworkCapabilities;
 import android.net.NetworkInfo;
 import android.os.BatteryManager;
+import android.os.Parcel;
+import android.os.Parcelable;
 import android.os.PowerManager;
-import android.support.annotation.IntDef;
-import com.google.android.exoplayer2.util.Log;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
-/**
- * Defines a set of device state requirements.
- */
-public final class Requirements {
+/** Defines a set of device state requirements. */
+public final class Requirements implements Parcelable {
 
   /**
-   * Network types. One of {@link #NETWORK_TYPE_NONE}, {@link #NETWORK_TYPE_ANY}, {@link
-   * #NETWORK_TYPE_UNMETERED}, {@link #NETWORK_TYPE_NOT_ROAMING} or {@link #NETWORK_TYPE_METERED}.
+   * Requirement flags. Possible flag values are {@link #NETWORK}, {@link #NETWORK_UNMETERED},
+   * {@link #DEVICE_IDLE} and {@link #DEVICE_CHARGING}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({
-    NETWORK_TYPE_NONE,
-    NETWORK_TYPE_ANY,
-    NETWORK_TYPE_UNMETERED,
-    NETWORK_TYPE_NOT_ROAMING,
-    NETWORK_TYPE_METERED,
-  })
-  public @interface NetworkType {}
-  /** This job doesn't require network connectivity. */
-  public static final int NETWORK_TYPE_NONE = 0;
-  /** This job requires network connectivity. */
-  public static final int NETWORK_TYPE_ANY = 1;
-  /** This job requires network connectivity that is unmetered. */
-  public static final int NETWORK_TYPE_UNMETERED = 2;
-  /** This job requires network connectivity that is not roaming. */
-  public static final int NETWORK_TYPE_NOT_ROAMING = 3;
-  /** This job requires metered connectivity such as most cellular data networks. */
-  public static final int NETWORK_TYPE_METERED = 4;
-  /** This job requires the device to be idle. */
-  private static final int DEVICE_IDLE = 8;
-  /** This job requires the device to be charging. */
-  private static final int DEVICE_CHARGING = 16;
-
-  private static final int NETWORK_TYPE_MASK = 7;
-
-  private static final String TAG = "Requirements";
-
-  private static final String[] NETWORK_TYPE_STRINGS;
-
-  static {
-    if (Scheduler.DEBUG) {
-      NETWORK_TYPE_STRINGS =
-          new String[] {
-            "NETWORK_TYPE_NONE",
-            "NETWORK_TYPE_ANY",
-            "NETWORK_TYPE_UNMETERED",
-            "NETWORK_TYPE_NOT_ROAMING",
-            "NETWORK_TYPE_METERED"
-          };
-    } else {
-      NETWORK_TYPE_STRINGS = null;
-    }
+  @IntDef(
+      flag = true,
+      value = {NETWORK, NETWORK_UNMETERED, DEVICE_IDLE, DEVICE_CHARGING})
+  public @interface RequirementFlags {}
+
+  /** Requirement that the device has network connectivity. */
+  public static final int NETWORK = 1;
+  /** Requirement that the device has a network connection that is unmetered. */
+  public static final int NETWORK_UNMETERED = 1 << 1;
+  /** Requirement that the device is idle. */
+  public static final int DEVICE_IDLE = 1 << 2;
+  /** Requirement that the device is charging. */
+  public static final int DEVICE_CHARGING = 1 << 3;
+
+  @RequirementFlags private final int requirements;
+
+  /** @param requirements A combination of requirement flags. */
+  public Requirements(@RequirementFlags int requirements) {
+    if ((requirements & NETWORK_UNMETERED) != 0) {
+      // Make sure network requirement flags are consistent.
+      requirements |= NETWORK;
+    }
+    this.requirements = requirements;
   }
 
-  private final int requirements;
-
-  /**
-   * @param networkType Required network type.
-   * @param charging Whether the device should be charging.
-   * @param idle Whether the device should be idle.
-   */
-  public Requirements(@NetworkType int networkType, boolean charging, boolean idle) {
-    this(networkType | (charging ? DEVICE_CHARGING : 0) | (idle ? DEVICE_IDLE : 0));
+  /** Returns the requirements. */
+  @RequirementFlags
+  public int getRequirements() {
+    return requirements;
   }
 
-  /** @param requirementsData The value returned by {@link #getRequirementsData()}. */
-  public Requirements(int requirementsData) {
-    this.requirements = requirementsData;
+  /** Returns whether network connectivity is required. */
+  public boolean isNetworkRequired() {
+    return (requirements & NETWORK) != 0;
   }
 
-  /** Returns required network type. */
-  public int getRequiredNetworkType() {
-    return requirements & NETWORK_TYPE_MASK;
+  /** Returns whether un-metered network connectivity is required. */
+  public boolean isUnmeteredNetworkRequired() {
+    return (requirements & NETWORK_UNMETERED) != 0;
   }
 
-  /** Returns whether the device should be charging. */
+  /** Returns whether the device is required to be charging. */
   public boolean isChargingRequired() {
     return (requirements & DEVICE_CHARGING) != 0;
   }
 
-  /** Returns whether the device should be idle. */
+  /** Returns whether the device is required to be idle. */
   public boolean isIdleRequired() {
     return (requirements & DEVICE_IDLE) != 0;
   }
@@ -121,56 +96,53 @@ public boolean isIdleRequired() {
    * Returns whether the requirements are met.
    *
    * @param context Any context.
+   * @return Whether the requirements are met.
    */
   public boolean checkRequirements(Context context) {
-    return checkNetworkRequirements(context)
-        && checkChargingRequirement(context)
-        && checkIdleRequirement(context);
+    return getNotMetRequirements(context) == 0;
   }
 
-  /** Returns the encoded requirements data which can be used with {@link #Requirements(int)}. */
-  public int getRequirementsData() {
-    return requirements;
+  /**
+   * Returns requirements that are not met, or 0.
+   *
+   * @param context Any context.
+   * @return The requirements that are not met, or 0.
+   */
+  @RequirementFlags
+  public int getNotMetRequirements(Context context) {
+    @RequirementFlags int notMetRequirements = getNotMetNetworkRequirements(context);
+    if (isChargingRequired() && !isDeviceCharging(context)) {
+      notMetRequirements |= DEVICE_CHARGING;
+    }
+    if (isIdleRequired() && !isDeviceIdle(context)) {
+      notMetRequirements |= DEVICE_IDLE;
+    }
+    return notMetRequirements;
   }
 
-  private boolean checkNetworkRequirements(Context context) {
-    int networkRequirement = getRequiredNetworkType();
-    if (networkRequirement == NETWORK_TYPE_NONE) {
-      return true;
+  @RequirementFlags
+  private int getNotMetNetworkRequirements(Context context) {
+    if (!isNetworkRequired()) {
+      return 0;
     }
+
     ConnectivityManager connectivityManager =
         (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
     NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
-    if (networkInfo == null || !networkInfo.isConnected()) {
-      logd("No network info or no connection.");
-      return false;
-    }
-    if (!checkInternetConnectivity(connectivityManager)) {
-      return false;
-    }
-    if (networkRequirement == NETWORK_TYPE_ANY) {
-      return true;
-    }
-    if (networkRequirement == NETWORK_TYPE_NOT_ROAMING) {
-      boolean roaming = networkInfo.isRoaming();
-      logd("Roaming: " + roaming);
-      return !roaming;
-    }
-    boolean activeNetworkMetered = isActiveNetworkMetered(connectivityManager, networkInfo);
-    logd("Metered network: " + activeNetworkMetered);
-    if (networkRequirement == NETWORK_TYPE_UNMETERED) {
-      return !activeNetworkMetered;
+    if (networkInfo == null
+        || !networkInfo.isConnected()
+        || !isInternetConnectivityValidated(connectivityManager)) {
+      return requirements & (NETWORK | NETWORK_UNMETERED);
     }
-    if (networkRequirement == NETWORK_TYPE_METERED) {
-      return activeNetworkMetered;
+
+    if (isUnmeteredNetworkRequired() && connectivityManager.isActiveNetworkMetered()) {
+      return NETWORK_UNMETERED;
     }
-    throw new IllegalStateException();
+
+    return 0;
   }
 
-  private boolean checkChargingRequirement(Context context) {
-    if (!isChargingRequired()) {
-      return true;
-    }
+  private boolean isDeviceCharging(Context context) {
     Intent batteryStatus =
         context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
     if (batteryStatus == null) {
@@ -181,17 +153,14 @@ private boolean checkChargingRequirement(Context context) {
         || status == BatteryManager.BATTERY_STATUS_FULL;
   }
 
-  private boolean checkIdleRequirement(Context context) {
-    if (!isIdleRequired()) {
-      return true;
-    }
+  private boolean isDeviceIdle(Context context) {
     PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
     return Util.SDK_INT >= 23
         ? powerManager.isDeviceIdleMode()
         : Util.SDK_INT >= 20 ? !powerManager.isInteractive() : !powerManager.isScreenOn();
   }
 
-  private static boolean checkInternetConnectivity(ConnectivityManager connectivityManager) {
+  private static boolean isInternetConnectivityValidated(ConnectivityManager connectivityManager) {
     if (Util.SDK_INT < 23) {
       // TODO Check internet connectivity using http://clients3.google.com/generate_204 on API
       // levels prior to 23.
@@ -199,7 +168,6 @@ private static boolean checkInternetConnectivity(ConnectivityManager connectivit
     }
     Network activeNetwork = connectivityManager.getActiveNetwork();
     if (activeNetwork == null) {
-      logd("No active network.");
       return false;
     }
     NetworkCapabilities networkCapabilities =
@@ -207,36 +175,48 @@ private static boolean checkInternetConnectivity(ConnectivityManager connectivit
     boolean validated =
         networkCapabilities == null
             || !networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
-    logd("Network capability validated: " + validated);
     return !validated;
   }
 
-  private static boolean isActiveNetworkMetered(
-      ConnectivityManager connectivityManager, NetworkInfo networkInfo) {
-    if (Util.SDK_INT >= 16) {
-      return connectivityManager.isActiveNetworkMetered();
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
     }
-    int type = networkInfo.getType();
-    return type != ConnectivityManager.TYPE_WIFI
-        && type != ConnectivityManager.TYPE_BLUETOOTH
-        && type != ConnectivityManager.TYPE_ETHERNET;
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    return requirements == ((Requirements) o).requirements;
   }
 
-  private static void logd(String message) {
-    if (Scheduler.DEBUG) {
-      Log.d(TAG, message);
-    }
+  @Override
+  public int hashCode() {
+    return requirements;
   }
 
+  // Parcelable implementation.
+
   @Override
-  public String toString() {
-    if (!Scheduler.DEBUG) {
-      return super.toString();
-    }
-    return "requirements{"
-        + NETWORK_TYPE_STRINGS[getRequiredNetworkType()]
-        + (isChargingRequired() ? ",charging" : "")
-        + (isIdleRequired() ? ",idle" : "")
-        + '}';
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(requirements);
   }
+
+  public static final Parcelable.Creator<Requirements> CREATOR =
+      new Creator<Requirements>() {
+
+        @Override
+        public Requirements createFromParcel(Parcel in) {
+          return new Requirements(in.readInt());
+        }
+
+        @Override
+        public Requirements[] newArray(int size) {
+          return new Requirements[size];
+        }
+      };
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
index d1eb28cc2a..f0d0f37cdf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
@@ -27,9 +27,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.PowerManager;
-import android.support.annotation.RequiresApi;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Log;
+import androidx.annotation.RequiresApi;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -42,30 +40,26 @@
    * Requirements} are met.
    */
   public interface Listener {
-
-    /**
-     * Called when the requirements are met.
-     *
-     * @param requirementsWatcher Calling instance.
-     */
-    void requirementsMet(RequirementsWatcher requirementsWatcher);
-
     /**
-     * Called when the requirements are not met.
+     * Called when there is a change on the met requirements.
      *
      * @param requirementsWatcher Calling instance.
+     * @param notMetRequirements {@link Requirements.RequirementFlags RequirementFlags} that are not
+     *     met, or 0.
      */
-    void requirementsNotMet(RequirementsWatcher requirementsWatcher);
+    void onRequirementsStateChanged(
+        RequirementsWatcher requirementsWatcher,
+        @Requirements.RequirementFlags int notMetRequirements);
   }
 
-  private static final String TAG = "RequirementsWatcher";
-
   private final Context context;
   private final Listener listener;
   private final Requirements requirements;
+  private final Handler handler;
+
   private DeviceStatusChangeReceiver receiver;
 
-  private boolean requirementsWereMet;
+  @Requirements.RequirementFlags private int notMetRequirements;
   private CapabilityValidatedCallback networkCallback;
 
   /**
@@ -74,23 +68,24 @@
    * @param requirements The requirements to watch.
    */
   public RequirementsWatcher(Context context, Listener listener, Requirements requirements) {
-    this.requirements = requirements;
-    this.listener = listener;
     this.context = context.getApplicationContext();
-    logd(this + " created");
+    this.listener = listener;
+    this.requirements = requirements;
+    handler = new Handler(Util.getLooper());
   }
 
   /**
    * Starts watching for changes. Must be called from a thread that has an associated {@link
    * Looper}. Listener methods are called on the caller thread.
+   *
+   * @return Initial {@link Requirements.RequirementFlags RequirementFlags} that are not met, or 0.
    */
-  public void start() {
-    Assertions.checkNotNull(Looper.myLooper());
-
-    requirementsWereMet = requirements.checkRequirements(context);
+  @Requirements.RequirementFlags
+  public int start() {
+    notMetRequirements = requirements.getNotMetRequirements(context);
 
     IntentFilter filter = new IntentFilter();
-    if (requirements.getRequiredNetworkType() != Requirements.NETWORK_TYPE_NONE) {
+    if (requirements.isNetworkRequired()) {
       if (Util.SDK_INT >= 23) {
         registerNetworkCallbackV23();
       } else {
@@ -110,8 +105,8 @@ public void start() {
       }
     }
     receiver = new DeviceStatusChangeReceiver();
-    context.registerReceiver(receiver, filter, null, new Handler());
-    logd(this + " started");
+    context.registerReceiver(receiver, filter, null, handler);
+    return notMetRequirements;
   }
 
   /** Stops watching for changes. */
@@ -121,7 +116,6 @@ public void stop() {
     if (networkCallback != null) {
       unregisterNetworkCallback();
     }
-    logd(this + " stopped");
   }
 
   /** Returns watched {@link Requirements}. */
@@ -129,14 +123,6 @@ public Requirements getRequirements() {
     return requirements;
   }
 
-  @Override
-  public String toString() {
-    if (!Scheduler.DEBUG) {
-      return super.toString();
-    }
-    return "RequirementsWatcher{" + requirements + '}';
-  }
-
   @TargetApi(23)
   private void registerNetworkCallbackV23() {
     ConnectivityManager connectivityManager =
@@ -159,24 +145,11 @@ private void unregisterNetworkCallback() {
   }
 
   private void checkRequirements() {
-    boolean requirementsAreMet = requirements.checkRequirements(context);
-    if (requirementsAreMet == requirementsWereMet) {
-      logd("requirementsAreMet is still " + requirementsAreMet);
-      return;
-    }
-    requirementsWereMet = requirementsAreMet;
-    if (requirementsAreMet) {
-      logd("start job");
-      listener.requirementsMet(this);
-    } else {
-      logd("stop job");
-      listener.requirementsNotMet(this);
-    }
-  }
-
-  private static void logd(String message) {
-    if (Scheduler.DEBUG) {
-      Log.d(TAG, message);
+    @Requirements.RequirementFlags
+    int notMetRequirements = requirements.getNotMetRequirements(context);
+    if (this.notMetRequirements != notMetRequirements) {
+      this.notMetRequirements = notMetRequirements;
+      listener.onRequirementsStateChanged(this, notMetRequirements);
     }
   }
 
@@ -184,7 +157,6 @@ private static void logd(String message) {
     @Override
     public void onReceive(Context context, Intent intent) {
       if (!isInitialStickyBroadcast()) {
-        logd(RequirementsWatcher.this + " received " + intent.getAction());
         checkRequirements();
       }
     }
@@ -194,16 +166,21 @@ public void onReceive(Context context, Intent intent) {
   private final class CapabilityValidatedCallback extends ConnectivityManager.NetworkCallback {
     @Override
     public void onAvailable(Network network) {
-      super.onAvailable(network);
-      logd(RequirementsWatcher.this + " NetworkCallback.onAvailable");
-      checkRequirements();
+      onNetworkCallback();
     }
 
     @Override
     public void onLost(Network network) {
-      super.onLost(network);
-      logd(RequirementsWatcher.this + " NetworkCallback.onLost");
-      checkRequirements();
+      onNetworkCallback();
+    }
+
+    private void onNetworkCallback() {
+      handler.post(
+          () -> {
+            if (networkCallback != null) {
+              checkRequirements();
+            }
+          });
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Scheduler.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Scheduler.java
index 1b225d9a4d..b5a6f40424 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Scheduler.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Scheduler.java
@@ -22,8 +22,6 @@
 /** Schedules a service to be started in the foreground when some {@link Requirements} are met. */
 public interface Scheduler {
 
-  /* package */ boolean DEBUG = false;
-
   /**
    * Schedules a service to be started in the foreground when some {@link Requirements} are met.
    * Anything that was previously scheduled will be canceled.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
index 2feac2978e..f6ea3da089 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
+import android.os.Looper;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -35,9 +35,9 @@
   private final ArrayList<SourceInfoRefreshListener> sourceInfoListeners;
   private final MediaSourceEventListener.EventDispatcher eventDispatcher;
 
-  private @Nullable ExoPlayer player;
-  private @Nullable Timeline timeline;
-  private @Nullable Object manifest;
+  @Nullable private Looper looper;
+  @Nullable private Timeline timeline;
+  @Nullable private Object manifest;
 
   public BaseMediaSource() {
     sourceInfoListeners = new ArrayList<>(/* initialCapacity= */ 1);
@@ -48,21 +48,16 @@ public BaseMediaSource() {
    * Starts source preparation. This method is called at most once until the next call to {@link
    * #releaseSourceInternal()}.
    *
-   * @param player The player for which this source is being prepared.
-   * @param isTopLevelSource Whether this source has been passed directly to {@link
-   *     ExoPlayer#prepare(MediaSource)} or {@link ExoPlayer#prepare(MediaSource, boolean,
-   *     boolean)}.
    * @param mediaTransferListener The transfer listener which should be informed of any media data
    *     transfers. May be null if no listener is available. Note that this listener should usually
    *     be only informed of transfers related to the media loads and not of auxiliary loads for
    *     manifests and other data.
    */
-  protected abstract void prepareSourceInternal(
-      ExoPlayer player, boolean isTopLevelSource, @Nullable TransferListener mediaTransferListener);
+  protected abstract void prepareSourceInternal(@Nullable TransferListener mediaTransferListener);
 
   /**
    * Releases the source. This method is called exactly once after each call to {@link
-   * #prepareSourceInternal(ExoPlayer, boolean, TransferListener)}.
+   * #prepareSourceInternal(TransferListener)}.
    */
   protected abstract void releaseSourceInternal();
 
@@ -135,21 +130,14 @@ public final void removeEventListener(MediaSourceEventListener eventListener) {
 
   @Override
   public final void prepareSource(
-      ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener) {
-    prepareSource(player, isTopLevelSource, listener, /* mediaTransferListener= */ null);
-  }
-
-  @Override
-  public final void prepareSource(
-      ExoPlayer player,
-      boolean isTopLevelSource,
       SourceInfoRefreshListener listener,
       @Nullable TransferListener mediaTransferListener) {
-    Assertions.checkArgument(this.player == null || this.player == player);
+    Looper looper = Looper.myLooper();
+    Assertions.checkArgument(this.looper == null || this.looper == looper);
     sourceInfoListeners.add(listener);
-    if (this.player == null) {
-      this.player = player;
-      prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+    if (this.looper == null) {
+      this.looper = looper;
+      prepareSourceInternal(mediaTransferListener);
     } else if (timeline != null) {
       listener.onSourceInfoRefreshed(/* source= */ this, timeline, manifest);
     }
@@ -159,7 +147,7 @@ public final void prepareSource(
   public final void releaseSource(SourceInfoRefreshListener listener) {
     sourceInfoListeners.remove(listener);
     if (sourceInfoListeners.isEmpty()) {
-      player = null;
+      looper = null;
       timeline = null;
       manifest = null;
       releaseSourceInternal();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index 3ed18049bf..ce6254e975 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -15,10 +15,9 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -116,36 +115,6 @@ public ClippingMediaSource(MediaSource mediaSource, long startPositionUs, long e
         /* relativeToDefaultPosition= */ false);
   }
 
-  /**
-   * Creates a new clipping source that wraps the specified source and provides samples between the
-   * specified start and end position.
-   *
-   * @param mediaSource The single-period source to wrap.
-   * @param startPositionUs The start position within {@code mediaSource}'s window at which to start
-   *     providing samples, in microseconds.
-   * @param endPositionUs The end position within {@code mediaSource}'s window at which to stop
-   *     providing samples, in microseconds. Specify {@link C#TIME_END_OF_SOURCE} to provide samples
-   *     from the specified start point up to the end of the source. Specifying a position that
-   *     exceeds the {@code mediaSource}'s duration will also result in the end of the source not
-   *     being clipped.
-   * @param enableInitialDiscontinuity Whether the initial discontinuity should be enabled.
-   */
-  // TODO: remove this when the new API is public.
-  @Deprecated
-  public ClippingMediaSource(
-      MediaSource mediaSource,
-      long startPositionUs,
-      long endPositionUs,
-      boolean enableInitialDiscontinuity) {
-    this(
-        mediaSource,
-        startPositionUs,
-        endPositionUs,
-        enableInitialDiscontinuity,
-        /* allowDynamicClippingUpdates= */ false,
-        /* relativeToDefaultPosition= */ false);
-  }
-
   /**
    * Creates a new clipping source that wraps the specified source and provides samples from the
    * default position for the specified duration.
@@ -223,11 +192,8 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
     prepareChildSource(/* id= */ null, mediaSource);
   }
 
@@ -240,10 +206,10 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     ClippingMediaPeriod mediaPeriod =
         new ClippingMediaPeriod(
-            mediaSource.createPeriod(id, allocator),
+            mediaSource.createPeriod(id, allocator, startPositionUs),
             enableInitialDiscontinuity,
             periodStartUs,
             periodEndUs);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
index 69fa4b094b..9323f7505c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
@@ -16,9 +16,8 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
-import android.support.annotation.CallSuper;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
+import androidx.annotation.CallSuper;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -35,7 +34,6 @@
 
   private final HashMap<T, MediaSourceAndListener> childSources;
 
-  private @Nullable ExoPlayer player;
   private @Nullable Handler eventHandler;
   private @Nullable TransferListener mediaTransferListener;
 
@@ -46,11 +44,7 @@ protected CompositeMediaSource() {
 
   @Override
   @CallSuper
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    this.player = player;
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     eventHandler = new Handler();
   }
@@ -71,7 +65,6 @@ public void releaseSourceInternal() {
       childSource.mediaSource.removeEventListener(childSource.eventListener);
     }
     childSources.clear();
-    player = null;
   }
 
   /**
@@ -105,11 +98,7 @@ protected final void prepareChildSource(final T id, MediaSource mediaSource) {
     MediaSourceEventListener eventListener = new ForwardingEventListener(id);
     childSources.put(id, new MediaSourceAndListener(mediaSource, sourceListener, eventListener));
     mediaSource.addEventListener(Assertions.checkNotNull(eventHandler), eventListener);
-    mediaSource.prepareSource(
-        Assertions.checkNotNull(player),
-        /* isTopLevelSource= */ false,
-        sourceListener,
-        mediaTransferListener);
+    mediaSource.prepareSource(sourceListener, mediaTransferListener);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 03ccd56645..e73fdd58a3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -16,13 +16,12 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import android.os.Message;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.PlayerMessage;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource.MediaSourceHolder;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
@@ -36,41 +35,48 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * Concatenates multiple {@link MediaSource}s. The list of {@link MediaSource}s can be modified
  * during playback. It is valid for the same {@link MediaSource} instance to be present more than
  * once in the concatenation. Access to this class is thread-safe.
  */
-public class ConcatenatingMediaSource extends CompositeMediaSource<MediaSourceHolder>
-    implements PlayerMessage.Target {
+public class ConcatenatingMediaSource extends CompositeMediaSource<MediaSourceHolder> {
 
   private static final int MSG_ADD = 0;
   private static final int MSG_REMOVE = 1;
   private static final int MSG_MOVE = 2;
   private static final int MSG_SET_SHUFFLE_ORDER = 3;
-  private static final int MSG_NOTIFY_LISTENER = 4;
+  private static final int MSG_UPDATE_TIMELINE = 4;
   private static final int MSG_ON_COMPLETION = 5;
 
-  // Accessed on the app thread.
+  // Accessed on any thread.
+  @GuardedBy("this")
   private final List<MediaSourceHolder> mediaSourcesPublic;
 
-  // Accessed on the playback thread.
+  @GuardedBy("this")
+  private final Set<HandlerAndRunnable> pendingOnCompletionActions;
+
+  @GuardedBy("this")
+  @Nullable
+  private Handler playbackThreadHandler;
+
+  // Accessed on the playback thread only.
   private final List<MediaSourceHolder> mediaSourceHolders;
   private final Map<MediaPeriod, MediaSourceHolder> mediaSourceByMediaPeriod;
   private final Map<Object, MediaSourceHolder> mediaSourceByUid;
-  private final List<Runnable> pendingOnCompletionActions;
   private final boolean isAtomic;
   private final boolean useLazyPreparation;
   private final Timeline.Window window;
   private final Timeline.Period period;
 
-  private @Nullable ExoPlayer player;
-  private @Nullable Handler playerApplicationHandler;
-  private boolean listenerNotificationScheduled;
+  private boolean timelineUpdateScheduled;
+  private Set<HandlerAndRunnable> nextTimelineUpdateOnCompletionActions;
   private ShuffleOrder shuffleOrder;
   private int windowCount;
   private int periodCount;
@@ -129,7 +135,8 @@ public ConcatenatingMediaSource(
     this.mediaSourceByUid = new HashMap<>();
     this.mediaSourcesPublic = new ArrayList<>();
     this.mediaSourceHolders = new ArrayList<>();
-    this.pendingOnCompletionActions = new ArrayList<>();
+    this.nextTimelineUpdateOnCompletionActions = new HashSet<>();
+    this.pendingOnCompletionActions = new HashSet<>();
     this.isAtomic = isAtomic;
     this.useLazyPreparation = useLazyPreparation;
     window = new Timeline.Window();
@@ -143,19 +150,20 @@ public ConcatenatingMediaSource(
    * @param mediaSource The {@link MediaSource} to be added to the list.
    */
   public final synchronized void addMediaSource(MediaSource mediaSource) {
-    addMediaSource(mediaSourcesPublic.size(), mediaSource, null);
+    addMediaSource(mediaSourcesPublic.size(), mediaSource);
   }
 
   /**
    * Appends a {@link MediaSource} to the playlist and executes a custom action on completion.
    *
    * @param mediaSource The {@link MediaSource} to be added to the list.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been added to the playlist.
    */
   public final synchronized void addMediaSource(
-      MediaSource mediaSource, @Nullable Runnable actionOnCompletion) {
-    addMediaSource(mediaSourcesPublic.size(), mediaSource, actionOnCompletion);
+      MediaSource mediaSource, Handler handler, Runnable onCompletionAction) {
+    addMediaSource(mediaSourcesPublic.size(), mediaSource, handler, onCompletionAction);
   }
 
   /**
@@ -166,7 +174,11 @@ public final synchronized void addMediaSource(
    * @param mediaSource The {@link MediaSource} to be added to the list.
    */
   public final synchronized void addMediaSource(int index, MediaSource mediaSource) {
-    addMediaSource(index, mediaSource, null);
+    addPublicMediaSources(
+        index,
+        Collections.singletonList(mediaSource),
+        /* handler= */ null,
+        /* onCompletionAction= */ null);
   }
 
   /**
@@ -175,12 +187,14 @@ public final synchronized void addMediaSource(int index, MediaSource mediaSource
    * @param index The index at which the new {@link MediaSource} will be inserted. This index must
    *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param mediaSource The {@link MediaSource} to be added to the list.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been added to the playlist.
    */
   public final synchronized void addMediaSource(
-      int index, MediaSource mediaSource, @Nullable Runnable actionOnCompletion) {
-    addMediaSources(index, Collections.singletonList(mediaSource), actionOnCompletion);
+      int index, MediaSource mediaSource, Handler handler, Runnable onCompletionAction) {
+    addPublicMediaSources(
+        index, Collections.singletonList(mediaSource), handler, onCompletionAction);
   }
 
   /**
@@ -190,7 +204,11 @@ public final synchronized void addMediaSource(
    *     sources are added in the order in which they appear in this collection.
    */
   public final synchronized void addMediaSources(Collection<MediaSource> mediaSources) {
-    addMediaSources(mediaSourcesPublic.size(), mediaSources, null);
+    addPublicMediaSources(
+        mediaSourcesPublic.size(),
+        mediaSources,
+        /* handler= */ null,
+        /* onCompletionAction= */ null);
   }
 
   /**
@@ -199,12 +217,13 @@ public final synchronized void addMediaSources(Collection<MediaSource> mediaSour
    *
    * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
    *     sources are added in the order in which they appear in this collection.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     sources have been added to the playlist.
    */
   public final synchronized void addMediaSources(
-      Collection<MediaSource> mediaSources, @Nullable Runnable actionOnCompletion) {
-    addMediaSources(mediaSourcesPublic.size(), mediaSources, actionOnCompletion);
+      Collection<MediaSource> mediaSources, Handler handler, Runnable onCompletionAction) {
+    addPublicMediaSources(mediaSourcesPublic.size(), mediaSources, handler, onCompletionAction);
   }
 
   /**
@@ -216,7 +235,7 @@ public final synchronized void addMediaSources(
    *     sources are added in the order in which they appear in this collection.
    */
   public final synchronized void addMediaSources(int index, Collection<MediaSource> mediaSources) {
-    addMediaSources(index, mediaSources, null);
+    addPublicMediaSources(index, mediaSources, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
@@ -226,28 +245,16 @@ public final synchronized void addMediaSources(int index, Collection<MediaSource
    *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
    *     sources are added in the order in which they appear in this collection.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     sources have been added to the playlist.
    */
   public final synchronized void addMediaSources(
-      int index, Collection<MediaSource> mediaSources, @Nullable Runnable actionOnCompletion) {
-    for (MediaSource mediaSource : mediaSources) {
-      Assertions.checkNotNull(mediaSource);
-    }
-    List<MediaSourceHolder> mediaSourceHolders = new ArrayList<>(mediaSources.size());
-    for (MediaSource mediaSource : mediaSources) {
-      mediaSourceHolders.add(new MediaSourceHolder(mediaSource));
-    }
-    mediaSourcesPublic.addAll(index, mediaSourceHolders);
-    if (player != null && !mediaSources.isEmpty()) {
-      player
-          .createMessage(this)
-          .setType(MSG_ADD)
-          .setPayload(new MessageData<>(index, mediaSourceHolders, actionOnCompletion))
-          .send();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+      int index,
+      Collection<MediaSource> mediaSources,
+      Handler handler,
+      Runnable onCompletionAction) {
+    addPublicMediaSources(index, mediaSources, handler, onCompletionAction);
   }
 
   /**
@@ -263,26 +270,27 @@ public final synchronized void addMediaSources(
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
   public final synchronized void removeMediaSource(int index) {
-    removeMediaSource(index, null);
+    removePublicMediaSources(index, index + 1, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
    * Removes a {@link MediaSource} from the playlist and executes a custom action on completion.
    *
    * <p>Note: If you want to move the instance, it's preferable to use {@link #moveMediaSource(int,
-   * int, Runnable)} instead.
+   * int, Handler, Runnable)} instead.
    *
    * <p>Note: If you want to remove a set of contiguous sources, it's preferable to use {@link
-   * #removeMediaSourceRange(int, int, Runnable)} instead.
+   * #removeMediaSourceRange(int, int, Handler, Runnable)} instead.
    *
    * @param index The index at which the media source will be removed. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been removed from the playlist.
    */
   public final synchronized void removeMediaSource(
-      int index, @Nullable Runnable actionOnCompletion) {
-    removeMediaSourceRange(index, index + 1, actionOnCompletion);
+      int index, Handler handler, Runnable onCompletionAction) {
+    removePublicMediaSources(index, index + 1, handler, onCompletionAction);
   }
 
   /**
@@ -300,7 +308,8 @@ public final synchronized void removeMediaSource(
    *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
    */
   public final synchronized void removeMediaSourceRange(int fromIndex, int toIndex) {
-    removeMediaSourceRange(fromIndex, toIndex, null);
+    removePublicMediaSources(
+        fromIndex, toIndex, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
@@ -314,29 +323,15 @@ public final synchronized void removeMediaSourceRange(int fromIndex, int toIndex
    *     removed. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param toIndex The final range index, pointing to the first media source that will be left
    *     untouched. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source range has been removed from the playlist.
    * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
    *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
    */
   public final synchronized void removeMediaSourceRange(
-      int fromIndex, int toIndex, @Nullable Runnable actionOnCompletion) {
-    Util.removeRange(mediaSourcesPublic, fromIndex, toIndex);
-    if (fromIndex == toIndex) {
-      if (actionOnCompletion != null) {
-        actionOnCompletion.run();
-      }
-      return;
-    }
-    if (player != null) {
-      player
-          .createMessage(this)
-          .setType(MSG_REMOVE)
-          .setPayload(new MessageData<>(fromIndex, toIndex, actionOnCompletion))
-          .send();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+      int fromIndex, int toIndex, Handler handler, Runnable onCompletionAction) {
+    removePublicMediaSources(fromIndex, toIndex, handler, onCompletionAction);
   }
 
   /**
@@ -348,7 +343,8 @@ public final synchronized void removeMediaSourceRange(
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
   public final synchronized void moveMediaSource(int currentIndex, int newIndex) {
-    moveMediaSource(currentIndex, newIndex, null);
+    movePublicMediaSource(
+        currentIndex, newIndex, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
@@ -359,42 +355,29 @@ public final synchronized void moveMediaSource(int currentIndex, int newIndex) {
    *     in the range of 0 &lt;= index &lt; {@link #getSize()}.
    * @param newIndex The target index of the media source in the playlist. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been moved.
    */
   public final synchronized void moveMediaSource(
-      int currentIndex, int newIndex, @Nullable Runnable actionOnCompletion) {
-    if (currentIndex == newIndex) {
-      if (actionOnCompletion != null) {
-        actionOnCompletion.run();
-      }
-      return;
-    }
-    mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
-    if (player != null) {
-      player
-          .createMessage(this)
-          .setType(MSG_MOVE)
-          .setPayload(new MessageData<>(currentIndex, newIndex, actionOnCompletion))
-          .send();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+      int currentIndex, int newIndex, Handler handler, Runnable onCompletionAction) {
+    movePublicMediaSource(currentIndex, newIndex, handler, onCompletionAction);
   }
 
   /** Clears the playlist. */
   public final synchronized void clear() {
-    clear(/* actionOnCompletion= */ null);
+    removeMediaSourceRange(0, getSize());
   }
 
   /**
    * Clears the playlist and executes a custom action on completion.
    *
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the playlist
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the playlist
    *     has been cleared.
    */
-  public final synchronized void clear(@Nullable Runnable actionOnCompletion) {
-    removeMediaSourceRange(0, getSize(), actionOnCompletion);
+  public final synchronized void clear(Handler handler, Runnable onCompletionAction) {
+    removeMediaSourceRange(0, getSize(), handler, onCompletionAction);
   }
 
   /** Returns the number of media sources in the playlist. */
@@ -418,41 +401,24 @@ public final synchronized MediaSource getMediaSource(int index) {
    * @param shuffleOrder A {@link ShuffleOrder}.
    */
   public final synchronized void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    setShuffleOrder(shuffleOrder, /* actionOnCompletion= */ null);
+    setPublicShuffleOrder(shuffleOrder, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
    * Sets a new shuffle order to use when shuffling the child media sources.
    *
    * @param shuffleOrder A {@link ShuffleOrder}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the shuffle
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the shuffle
    *     order has been changed.
    */
   public final synchronized void setShuffleOrder(
-      ShuffleOrder shuffleOrder, @Nullable Runnable actionOnCompletion) {
-    ExoPlayer player = this.player;
-    if (player != null) {
-      int size = getSize();
-      if (shuffleOrder.getLength() != size) {
-        shuffleOrder =
-            shuffleOrder
-                .cloneAndClear()
-                .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
-      }
-      player
-          .createMessage(this)
-          .setType(MSG_SET_SHUFFLE_ORDER)
-          .setPayload(new MessageData<>(/* index= */ 0, shuffleOrder, actionOnCompletion))
-          .send();
-    } else {
-      this.shuffleOrder =
-          shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
-      if (actionOnCompletion != null) {
-        actionOnCompletion.run();
-      }
-    }
+      ShuffleOrder shuffleOrder, Handler handler, Runnable onCompletionAction) {
+    setPublicShuffleOrder(shuffleOrder, handler, onCompletionAction);
   }
 
+  // CompositeMediaSource implementation.
+
   @Override
   @Nullable
   public Object getTag() {
@@ -461,18 +427,15 @@ public Object getTag() {
 
   @Override
   public final synchronized void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
       @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
-    this.player = player;
-    playerApplicationHandler = new Handler(player.getApplicationLooper());
+    super.prepareSourceInternal(mediaTransferListener);
+    playbackThreadHandler = new Handler(/* callback= */ this::handleMessage);
     if (mediaSourcesPublic.isEmpty()) {
-      notifyListener();
+      updateTimelineAndScheduleOnCompletionActions();
     } else {
       shuffleOrder = shuffleOrder.cloneAndInsert(0, mediaSourcesPublic.size());
       addMediaSourcesInternal(0, mediaSourcesPublic);
-      scheduleListenerNotification(/* actionOnCompletion= */ null);
+      scheduleTimelineUpdate();
     }
   }
 
@@ -484,7 +447,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public final MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public final MediaPeriod createPeriod(
+      MediaPeriodId id, Allocator allocator, long startPositionUs) {
     Object mediaSourceHolderUid = getMediaSourceHolderUid(id.periodUid);
     MediaSourceHolder holder = mediaSourceByUid.get(mediaSourceHolderUid);
     if (holder == null) {
@@ -492,7 +456,8 @@ public final MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
       holder = new MediaSourceHolder(new DummyMediaSource());
       holder.hasStartedPreparing = true;
     }
-    DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(holder.mediaSource, id, allocator);
+    DeferredMediaPeriod mediaPeriod =
+        new DeferredMediaPeriod(holder.mediaSource, id, allocator, startPositionUs);
     mediaSourceByMediaPeriod.put(mediaPeriod, holder);
     holder.activeMediaPeriods.add(mediaPeriod);
     if (!holder.hasStartedPreparing) {
@@ -515,15 +480,20 @@ public final void releasePeriod(MediaPeriod mediaPeriod) {
   }
 
   @Override
-  public final void releaseSourceInternal() {
+  public final synchronized void releaseSourceInternal() {
     super.releaseSourceInternal();
     mediaSourceHolders.clear();
     mediaSourceByUid.clear();
-    player = null;
-    playerApplicationHandler = null;
     shuffleOrder = shuffleOrder.cloneAndClear();
     windowCount = 0;
     periodCount = 0;
+    if (playbackThreadHandler != null) {
+      playbackThreadHandler.removeCallbacksAndMessages(null);
+      playbackThreadHandler = null;
+    }
+    timelineUpdateScheduled = false;
+    nextTimelineUpdateOnCompletionActions.clear();
+    dispatchOnCompletionActions(pendingOnCompletionActions);
   }
 
   @Override
@@ -556,24 +526,126 @@ protected int getWindowIndexForChildWindowIndex(
     return windowIndex + mediaSourceHolder.firstWindowIndexInChild;
   }
 
-  @Override
-  @SuppressWarnings("unchecked")
-  public final void handleMessage(int messageType, @Nullable Object message)
-      throws ExoPlaybackException {
-    if (player == null) {
-      // Stale event.
-      return;
+  // Internal methods. Called from any thread.
+
+  @GuardedBy("this")
+  private void addPublicMediaSources(
+      int index,
+      Collection<MediaSource> mediaSources,
+      @Nullable Handler handler,
+      @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    for (MediaSource mediaSource : mediaSources) {
+      Assertions.checkNotNull(mediaSource);
+    }
+    List<MediaSourceHolder> mediaSourceHolders = new ArrayList<>(mediaSources.size());
+    for (MediaSource mediaSource : mediaSources) {
+      mediaSourceHolders.add(new MediaSourceHolder(mediaSource));
     }
-    switch (messageType) {
+    mediaSourcesPublic.addAll(index, mediaSourceHolders);
+    if (playbackThreadHandler != null && !mediaSources.isEmpty()) {
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(MSG_ADD, new MessageData<>(index, mediaSourceHolders, callbackAction))
+          .sendToTarget();
+    } else if (onCompletionAction != null && handler != null) {
+      handler.post(onCompletionAction);
+    }
+  }
+
+  @GuardedBy("this")
+  private void removePublicMediaSources(
+      int fromIndex,
+      int toIndex,
+      @Nullable Handler handler,
+      @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    Util.removeRange(mediaSourcesPublic, fromIndex, toIndex);
+    if (playbackThreadHandler != null) {
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(MSG_REMOVE, new MessageData<>(fromIndex, toIndex, callbackAction))
+          .sendToTarget();
+    } else if (onCompletionAction != null && handler != null) {
+      handler.post(onCompletionAction);
+    }
+  }
+
+  @GuardedBy("this")
+  private void movePublicMediaSource(
+      int currentIndex,
+      int newIndex,
+      @Nullable Handler handler,
+      @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
+    if (playbackThreadHandler != null) {
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(MSG_MOVE, new MessageData<>(currentIndex, newIndex, callbackAction))
+          .sendToTarget();
+    } else if (onCompletionAction != null && handler != null) {
+      handler.post(onCompletionAction);
+    }
+  }
+
+  @GuardedBy("this")
+  private void setPublicShuffleOrder(
+      ShuffleOrder shuffleOrder, @Nullable Handler handler, @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    if (playbackThreadHandler != null) {
+      int size = getSize();
+      if (shuffleOrder.getLength() != size) {
+        shuffleOrder =
+            shuffleOrder
+                .cloneAndClear()
+                .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
+      }
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(
+              MSG_SET_SHUFFLE_ORDER,
+              new MessageData<>(/* index= */ 0, shuffleOrder, callbackAction))
+          .sendToTarget();
+    } else {
+      this.shuffleOrder =
+          shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
+      if (onCompletionAction != null && handler != null) {
+        handler.post(onCompletionAction);
+      }
+    }
+  }
+
+  @GuardedBy("this")
+  @Nullable
+  private HandlerAndRunnable createOnCompletionAction(
+      @Nullable Handler handler, @Nullable Runnable runnable) {
+    if (handler == null || runnable == null) {
+      return null;
+    }
+    HandlerAndRunnable handlerAndRunnable = new HandlerAndRunnable(handler, runnable);
+    pendingOnCompletionActions.add(handlerAndRunnable);
+    return handlerAndRunnable;
+  }
+
+  // Internal methods. Called on the playback thread.
+
+  @SuppressWarnings("unchecked")
+  private boolean handleMessage(Message msg) {
+    switch (msg.what) {
       case MSG_ADD:
         MessageData<Collection<MediaSourceHolder>> addMessage =
-            (MessageData<Collection<MediaSourceHolder>>) Util.castNonNull(message);
+            (MessageData<Collection<MediaSourceHolder>>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrder.cloneAndInsert(addMessage.index, addMessage.customData.size());
         addMediaSourcesInternal(addMessage.index, addMessage.customData);
-        scheduleListenerNotification(addMessage.actionOnCompletion);
+        scheduleTimelineUpdate(addMessage.onCompletionAction);
         break;
       case MSG_REMOVE:
-        MessageData<Integer> removeMessage = (MessageData<Integer>) Util.castNonNull(message);
+        MessageData<Integer> removeMessage = (MessageData<Integer>) Util.castNonNull(msg.obj);
         int fromIndex = removeMessage.index;
         int toIndex = removeMessage.customData;
         if (fromIndex == 0 && toIndex == shuffleOrder.getLength()) {
@@ -584,64 +656,74 @@ public final void handleMessage(int messageType, @Nullable Object message)
         for (int index = toIndex - 1; index >= fromIndex; index--) {
           removeMediaSourceInternal(index);
         }
-        scheduleListenerNotification(removeMessage.actionOnCompletion);
+        scheduleTimelineUpdate(removeMessage.onCompletionAction);
         break;
       case MSG_MOVE:
-        MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(message);
+        MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index, moveMessage.index + 1);
         shuffleOrder = shuffleOrder.cloneAndInsert(moveMessage.customData, 1);
         moveMediaSourceInternal(moveMessage.index, moveMessage.customData);
-        scheduleListenerNotification(moveMessage.actionOnCompletion);
+        scheduleTimelineUpdate(moveMessage.onCompletionAction);
         break;
       case MSG_SET_SHUFFLE_ORDER:
         MessageData<ShuffleOrder> shuffleOrderMessage =
-            (MessageData<ShuffleOrder>) Util.castNonNull(message);
+            (MessageData<ShuffleOrder>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrderMessage.customData;
-        scheduleListenerNotification(shuffleOrderMessage.actionOnCompletion);
+        scheduleTimelineUpdate(shuffleOrderMessage.onCompletionAction);
         break;
-      case MSG_NOTIFY_LISTENER:
-        notifyListener();
+      case MSG_UPDATE_TIMELINE:
+        updateTimelineAndScheduleOnCompletionActions();
         break;
       case MSG_ON_COMPLETION:
-        List<Runnable> actionsOnCompletion = (List<Runnable>) Util.castNonNull(message);
-        Handler handler = Assertions.checkNotNull(playerApplicationHandler);
-        for (int i = 0; i < actionsOnCompletion.size(); i++) {
-          handler.post(actionsOnCompletion.get(i));
-        }
+        Set<HandlerAndRunnable> actions = (Set<HandlerAndRunnable>) Util.castNonNull(msg.obj);
+        dispatchOnCompletionActions(actions);
         break;
       default:
         throw new IllegalStateException();
     }
+    return true;
+  }
+
+  private void scheduleTimelineUpdate() {
+    scheduleTimelineUpdate(/* onCompletionAction= */ null);
   }
 
-  private void scheduleListenerNotification(@Nullable Runnable actionOnCompletion) {
-    if (!listenerNotificationScheduled) {
-      Assertions.checkNotNull(player).createMessage(this).setType(MSG_NOTIFY_LISTENER).send();
-      listenerNotificationScheduled = true;
+  private void scheduleTimelineUpdate(@Nullable HandlerAndRunnable onCompletionAction) {
+    if (!timelineUpdateScheduled) {
+      getPlaybackThreadHandlerOnPlaybackThread().obtainMessage(MSG_UPDATE_TIMELINE).sendToTarget();
+      timelineUpdateScheduled = true;
     }
-    if (actionOnCompletion != null) {
-      pendingOnCompletionActions.add(actionOnCompletion);
+    if (onCompletionAction != null) {
+      nextTimelineUpdateOnCompletionActions.add(onCompletionAction);
     }
   }
 
-  private void notifyListener() {
-    listenerNotificationScheduled = false;
-    List<Runnable> actionsOnCompletion =
-        pendingOnCompletionActions.isEmpty()
-            ? Collections.emptyList()
-            : new ArrayList<>(pendingOnCompletionActions);
-    pendingOnCompletionActions.clear();
+  private void updateTimelineAndScheduleOnCompletionActions() {
+    timelineUpdateScheduled = false;
+    Set<HandlerAndRunnable> onCompletionActions = nextTimelineUpdateOnCompletionActions;
+    nextTimelineUpdateOnCompletionActions = new HashSet<>();
     refreshSourceInfo(
         new ConcatenatedTimeline(
             mediaSourceHolders, windowCount, periodCount, shuffleOrder, isAtomic),
         /* manifest= */ null);
-    if (!actionsOnCompletion.isEmpty()) {
-      Assertions.checkNotNull(player)
-          .createMessage(this)
-          .setType(MSG_ON_COMPLETION)
-          .setPayload(actionsOnCompletion)
-          .send();
+    getPlaybackThreadHandlerOnPlaybackThread()
+        .obtainMessage(MSG_ON_COMPLETION, onCompletionActions)
+        .sendToTarget();
+  }
+
+  @SuppressWarnings("GuardedBy")
+  private Handler getPlaybackThreadHandlerOnPlaybackThread() {
+    // Write access to this value happens on the playback thread only, so playback thread reads
+    // don't need to be synchronized.
+    return Assertions.checkNotNull(playbackThreadHandler);
+  }
+
+  private synchronized void dispatchOnCompletionActions(
+      Set<HandlerAndRunnable> onCompletionActions) {
+    for (HandlerAndRunnable pendingAction : onCompletionActions) {
+      pendingAction.dispatch();
     }
+    pendingOnCompletionActions.removeAll(onCompletionActions);
   }
 
   private void addMediaSourcesInternal(
@@ -718,6 +800,7 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
       //     unlikely to be a problem as a non-zero default position usually only occurs for live
       //     playbacks and seeking to zero in a live window would cause BehindLiveWindowExceptions
       //     anyway.
+      timeline.getWindow(/* windowIndex= */ 0, window);
       long windowStartPositionUs = window.getDefaultPositionUs();
       if (deferredMediaPeriod != null) {
         long periodPreparePositionUs = deferredMediaPeriod.getPreparePositionUs();
@@ -739,7 +822,7 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
       }
     }
     mediaSourceHolder.isPrepared = true;
-    scheduleListenerNotification(/* actionOnCompletion= */ null);
+    scheduleTimelineUpdate();
   }
 
   private void removeMediaSourceInternal(int index) {
@@ -814,6 +897,7 @@ private static Object getPeriodUid(MediaSourceHolder holder, Object childPeriodU
 
     public final MediaSource mediaSource;
     public final Object uid;
+    public final List<DeferredMediaPeriod> activeMediaPeriods;
 
     public DeferredTimeline timeline;
     public int childIndex;
@@ -822,7 +906,6 @@ private static Object getPeriodUid(MediaSourceHolder holder, Object childPeriodU
     public boolean hasStartedPreparing;
     public boolean isPrepared;
     public boolean isRemoved;
-    public List<DeferredMediaPeriod> activeMediaPeriods;
 
     public MediaSourceHolder(MediaSource mediaSource) {
       this.mediaSource = mediaSource;
@@ -852,12 +935,12 @@ public int compareTo(@NonNull MediaSourceHolder other) {
 
     public final int index;
     public final T customData;
-    public final @Nullable Runnable actionOnCompletion;
+    @Nullable public final HandlerAndRunnable onCompletionAction;
 
-    public MessageData(int index, T customData, @Nullable Runnable actionOnCompletion) {
+    public MessageData(int index, T customData, @Nullable HandlerAndRunnable onCompletionAction) {
       this.index = index;
-      this.actionOnCompletion = actionOnCompletion;
       this.customData = customData;
+      this.onCompletionAction = onCompletionAction;
     }
   }
 
@@ -1077,10 +1160,7 @@ public Object getUidOfPeriod(int periodIndex) {
   private static final class DummyMediaSource extends BaseMediaSource {
 
     @Override
-    protected void prepareSourceInternal(
-        ExoPlayer player,
-        boolean isTopLevelSource,
-        @Nullable TransferListener mediaTransferListener) {
+    protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
       // Do nothing.
     }
 
@@ -1101,7 +1181,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
     }
 
     @Override
-    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
       throw new UnsupportedOperationException();
     }
 
@@ -1110,5 +1190,20 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
       // Do nothing.
     }
   }
+
+  private static final class HandlerAndRunnable {
+
+    private final Handler handler;
+    private final Runnable runnable;
+
+    public HandlerAndRunnable(Handler handler, Runnable runnable) {
+      this.handler = handler;
+      this.runnable = runnable;
+    }
+
+    public void dispatch() {
+      handler.post(runnable);
+    }
+  }
 }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java
index fd7c037fb9..14bafdaf4b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import java.io.IOException;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
index 26c25a749e..abf02541c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
@@ -25,7 +25,7 @@
 
 /**
  * Media period that wraps a media source and defers calling its {@link
- * MediaSource#createPeriod(MediaPeriodId, Allocator)} method until {@link
+ * MediaSource#createPeriod(MediaPeriodId, Allocator, long)} method until {@link
  * #createPeriod(MediaPeriodId)} has been called. This is useful if you need to return a media
  * period immediately but the media source that should create it is not yet prepared.
  */
@@ -60,11 +60,14 @@
    * @param mediaSource The media source to wrap.
    * @param id The identifier used to create the deferred media period.
    * @param allocator The allocator used to create the media period.
+   * @param preparePositionUs The expected start position, in microseconds.
    */
-  public DeferredMediaPeriod(MediaSource mediaSource, MediaPeriodId id, Allocator allocator) {
+  public DeferredMediaPeriod(
+      MediaSource mediaSource, MediaPeriodId id, Allocator allocator, long preparePositionUs) {
     this.id = id;
     this.allocator = allocator;
     this.mediaSource = mediaSource;
+    this.preparePositionUs = preparePositionUs;
     preparePositionOverrideUs = C.TIME_UNSET;
   }
 
@@ -86,28 +89,25 @@ public long getPreparePositionUs() {
 
   /**
    * Overrides the default prepare position at which to prepare the media period. This value is only
-   * used if the call to {@link MediaPeriod#prepare(Callback, long)} is being deferred.
+   * used if called before {@link #createPeriod(MediaPeriodId)}.
    *
-   * @param defaultPreparePositionUs The default prepare position to use, in microseconds.
+   * @param preparePositionUs The default prepare position to use, in microseconds.
    */
-  public void overridePreparePositionUs(long defaultPreparePositionUs) {
-    preparePositionOverrideUs = defaultPreparePositionUs;
+  public void overridePreparePositionUs(long preparePositionUs) {
+    preparePositionOverrideUs = preparePositionUs;
   }
 
   /**
-   * Calls {@link MediaSource#createPeriod(MediaPeriodId, Allocator)} on the wrapped source then
-   * prepares it if {@link #prepare(Callback, long)} has been called. Call {@link #releasePeriod()}
-   * to release the period.
+   * Calls {@link MediaSource#createPeriod(MediaPeriodId, Allocator, long)} on the wrapped source
+   * then prepares it if {@link #prepare(Callback, long)} has been called. Call {@link
+   * #releasePeriod()} to release the period.
    *
    * @param id The identifier that should be used to create the media period from the media source.
    */
   public void createPeriod(MediaPeriodId id) {
-    mediaPeriod = mediaSource.createPeriod(id, allocator);
+    long preparePositionUs = getPreparePositionWithOverride(this.preparePositionUs);
+    mediaPeriod = mediaSource.createPeriod(id, allocator, preparePositionUs);
     if (callback != null) {
-      long preparePositionUs =
-          preparePositionOverrideUs != C.TIME_UNSET
-              ? preparePositionOverrideUs
-              : this.preparePositionUs;
       mediaPeriod.prepare(this, preparePositionUs);
     }
   }
@@ -124,9 +124,8 @@ public void releasePeriod() {
   @Override
   public void prepare(Callback callback, long preparePositionUs) {
     this.callback = callback;
-    this.preparePositionUs = preparePositionUs;
     if (mediaPeriod != null) {
-      mediaPeriod.prepare(this, preparePositionUs);
+      mediaPeriod.prepare(this, getPreparePositionWithOverride(this.preparePositionUs));
     }
   }
 
@@ -217,4 +216,9 @@ public void onPrepared(MediaPeriod mediaPeriod) {
     callback.onPrepared(this);
   }
 
+  private long getPreparePositionWithOverride(long preparePositionUs) {
+    return preparePositionOverrideUs != C.TIME_UNSET
+        ? preparePositionOverrideUs
+        : preparePositionUs;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 085b5dba71..f3ed19db3d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -17,10 +17,10 @@
 
 import android.net.Uri;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
@@ -33,25 +33,13 @@
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 
-/**
- * Provides one period that loads data from a {@link Uri} and extracted using an {@link Extractor}.
- *
- * <p>If the possible input stream container formats are known, pass a factory that instantiates
- * extractors for them to the constructor. Otherwise, pass a {@link DefaultExtractorsFactory} to use
- * the default extractors. When reading a new stream, the first {@link Extractor} in the array of
- * extractors created by the factory that returns {@code true} from {@link Extractor#sniff} will be
- * used to extract samples from the input stream.
- *
- * <p>Note that the built-in extractors for AAC, MPEG PS/TS and FLV streams do not support seeking.
- */
+/** @deprecated Use {@link ProgressiveMediaSource} instead. */
+@Deprecated
+@SuppressWarnings("deprecation")
 public final class ExtractorMediaSource extends BaseMediaSource
-    implements ExtractorMediaPeriod.Listener {
+    implements MediaSource.SourceInfoRefreshListener {
 
-  /**
-   * Listener of {@link ExtractorMediaSource} events.
-   *
-   * @deprecated Use {@link MediaSourceEventListener}.
-   */
+  /** @deprecated Use {@link MediaSourceEventListener} instead. */
   @Deprecated
   public interface EventListener {
 
@@ -71,7 +59,8 @@
 
   }
 
-  /** Factory for {@link ExtractorMediaSource}s. */
+  /** Use {@link ProgressiveMediaSource.Factory} instead. */
+  @Deprecated
   public static final class Factory implements AdsMediaSource.MediaSourceFactory {
 
     private final DataSource.Factory dataSourceFactory;
@@ -233,23 +222,11 @@ public ExtractorMediaSource createMediaSource(
     }
   }
 
-  /**
-   * The default number of bytes that should be loaded between each each invocation of {@link
-   * MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
-   */
-  public static final int DEFAULT_LOADING_CHECK_INTERVAL_BYTES = 1024 * 1024;
-
-  private final Uri uri;
-  private final DataSource.Factory dataSourceFactory;
-  private final ExtractorsFactory extractorsFactory;
-  private final LoadErrorHandlingPolicy loadableLoadErrorHandlingPolicy;
-  private final String customCacheKey;
-  private final int continueLoadingCheckIntervalBytes;
-  private final @Nullable Object tag;
+  @Deprecated
+  public static final int DEFAULT_LOADING_CHECK_INTERVAL_BYTES =
+      ProgressiveMediaSource.DEFAULT_LOADING_CHECK_INTERVAL_BYTES;
 
-  private long timelineDurationUs;
-  private boolean timelineIsSeekable;
-  private @Nullable TransferListener transferListener;
+  private final ProgressiveMediaSource progressiveMediaSource;
 
   /**
    * @param uri The {@link Uri} of the media stream.
@@ -262,7 +239,6 @@ public ExtractorMediaSource createMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
-  @SuppressWarnings("deprecation")
   public ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
@@ -285,7 +261,6 @@ public ExtractorMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
-  @SuppressWarnings("deprecation")
   public ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
@@ -318,7 +293,6 @@ public ExtractorMediaSource(
    * @deprecated Use {@link Factory} instead.
    */
   @Deprecated
-  @SuppressWarnings("deprecation")
   public ExtractorMediaSource(
       Uri uri,
       DataSource.Factory dataSourceFactory,
@@ -348,96 +322,57 @@ private ExtractorMediaSource(
       @Nullable String customCacheKey,
       int continueLoadingCheckIntervalBytes,
       @Nullable Object tag) {
-    this.uri = uri;
-    this.dataSourceFactory = dataSourceFactory;
-    this.extractorsFactory = extractorsFactory;
-    this.loadableLoadErrorHandlingPolicy = loadableLoadErrorHandlingPolicy;
-    this.customCacheKey = customCacheKey;
-    this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
-    this.timelineDurationUs = C.TIME_UNSET;
-    this.tag = tag;
+    progressiveMediaSource =
+        new ProgressiveMediaSource(
+            uri,
+            dataSourceFactory,
+            extractorsFactory,
+            loadableLoadErrorHandlingPolicy,
+            customCacheKey,
+            continueLoadingCheckIntervalBytes,
+            tag);
   }
 
   @Override
   @Nullable
   public Object getTag() {
-    return tag;
+    return progressiveMediaSource.getTag();
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    transferListener = mediaTransferListener;
-    notifySourceInfoRefreshed(timelineDurationUs, /* isSeekable= */ false);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    progressiveMediaSource.prepareSource(/* listener= */ this, mediaTransferListener);
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    // Do nothing.
+    progressiveMediaSource.maybeThrowSourceInfoRefreshError();
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    DataSource dataSource = dataSourceFactory.createDataSource();
-    if (transferListener != null) {
-      dataSource.addTransferListener(transferListener);
-    }
-    return new ExtractorMediaPeriod(
-        uri,
-        dataSource,
-        extractorsFactory.createExtractors(),
-        loadableLoadErrorHandlingPolicy,
-        createEventDispatcher(id),
-        this,
-        allocator,
-        customCacheKey,
-        continueLoadingCheckIntervalBytes);
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+    return progressiveMediaSource.createPeriod(id, allocator, startPositionUs);
   }
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
-    ((ExtractorMediaPeriod) mediaPeriod).release();
+    progressiveMediaSource.releasePeriod(mediaPeriod);
   }
 
   @Override
   public void releaseSourceInternal() {
-    // Do nothing.
+    progressiveMediaSource.releaseSource(/* listener= */ this);
   }
 
-  // ExtractorMediaPeriod.Listener implementation.
-
   @Override
-  public void onSourceInfoRefreshed(long durationUs, boolean isSeekable) {
-    // If we already have the duration from a previous source info refresh, use it.
-    durationUs = durationUs == C.TIME_UNSET ? timelineDurationUs : durationUs;
-    if (timelineDurationUs == durationUs && timelineIsSeekable == isSeekable) {
-      // Suppress no-op source info changes.
-      return;
-    }
-    notifySourceInfoRefreshed(durationUs, isSeekable);
-  }
-
-  // Internal methods.
-
-  private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
-    timelineDurationUs = durationUs;
-    timelineIsSeekable = isSeekable;
-    // TODO: Make timeline dynamic until its duration is known. This is non-trivial. See b/69703223.
-    refreshSourceInfo(
-        new SinglePeriodTimeline(
-            timelineDurationUs, timelineIsSeekable, /* isDynamic= */ false, tag),
-        /* manifest= */ null);
+  public void onSourceInfoRefreshed(
+      MediaSource source, Timeline timeline, @Nullable Object manifest) {
+    refreshSourceInfo(timeline, manifest);
   }
 
-  /**
-   * Wraps a deprecated {@link EventListener}, invoking its callback from the equivalent callback in
-   * {@link MediaSourceEventListener}.
-   */
   @Deprecated
-  @SuppressWarnings("deprecation")
   private static final class EventListenerWrapper extends DefaultMediaSourceEventListener {
+
     private final EventListener eventListener;
 
     public EventListenerWrapper(EventListener eventListener) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java
new file mode 100644
index 0000000000..3d31e2a771
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Splits ICY stream metadata out from a stream.
+ *
+ * <p>Note: {@link #open(DataSpec)} and {@link #close()} are not supported. This implementation is
+ * intended to wrap upstream {@link DataSource} instances that are opened and closed directly.
+ */
+/* package */ final class IcyDataSource implements DataSource {
+
+  public interface Listener {
+
+    /**
+     * Called when ICY stream metadata has been split from the stream.
+     *
+     * @param metadata The stream metadata in binary form.
+     */
+    void onIcyMetadata(ParsableByteArray metadata);
+  }
+
+  private final DataSource upstream;
+  private final int metadataIntervalBytes;
+  private final Listener listener;
+  private final byte[] metadataLengthByteHolder;
+  private int bytesUntilMetadata;
+
+  /**
+   * @param upstream The upstream {@link DataSource}.
+   * @param metadataIntervalBytes The interval between ICY stream metadata, in bytes.
+   * @param listener A listener to which stream metadata is delivered.
+   */
+  public IcyDataSource(DataSource upstream, int metadataIntervalBytes, Listener listener) {
+    Assertions.checkArgument(metadataIntervalBytes > 0);
+    this.upstream = upstream;
+    this.metadataIntervalBytes = metadataIntervalBytes;
+    this.listener = listener;
+    metadataLengthByteHolder = new byte[1];
+    bytesUntilMetadata = metadataIntervalBytes;
+  }
+
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstream.addTransferListener(transferListener);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    if (bytesUntilMetadata == 0) {
+      if (readMetadata()) {
+        bytesUntilMetadata = metadataIntervalBytes;
+      } else {
+        return C.RESULT_END_OF_INPUT;
+      }
+    }
+    int bytesRead = upstream.read(buffer, offset, Math.min(bytesUntilMetadata, readLength));
+    if (bytesRead != C.RESULT_END_OF_INPUT) {
+      bytesUntilMetadata -= bytesRead;
+    }
+    return bytesRead;
+  }
+
+  @Nullable
+  @Override
+  public Uri getUri() {
+    return upstream.getUri();
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstream.getResponseHeaders();
+  }
+
+  @Override
+  public void close() throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * Reads an ICY stream metadata block, passing it to {@link #listener} unless the block is empty.
+   *
+   * @return True if the block was extracted, including if it's length byte indicated a length of
+   *     zero. False if the end of the stream was reached.
+   * @throws IOException If an error occurs reading from the wrapped {@link DataSource}.
+   */
+  private boolean readMetadata() throws IOException {
+    int bytesRead = upstream.read(metadataLengthByteHolder, 0, 1);
+    if (bytesRead == C.RESULT_END_OF_INPUT) {
+      return false;
+    }
+    int metadataLength = (metadataLengthByteHolder[0] & 0xFF) << 4;
+    if (metadataLength == 0) {
+      return true;
+    }
+
+    int offset = 0;
+    int lengthRemaining = metadataLength;
+    byte[] metadata = new byte[metadataLength];
+    while (lengthRemaining > 0) {
+      bytesRead = upstream.read(metadata, offset, lengthRemaining);
+      if (bytesRead == C.RESULT_END_OF_INPUT) {
+        return false;
+      }
+      offset += bytesRead;
+      lengthRemaining -= bytesRead;
+    }
+
+    // Discard trailing zero bytes.
+    while (metadataLength > 0 && metadata[metadataLength - 1] == 0) {
+      metadataLength--;
+    }
+
+    if (metadataLength > 0) {
+      listener.onIcyMetadata(new ParsableByteArray(metadata, metadataLength));
+    }
+    return true;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index cac15d5ed9..769f545aaa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
@@ -31,7 +31,7 @@
  * Loops a {@link MediaSource} a specified number of times.
  *
  * <p>Note: To loop a {@link MediaSource} indefinitely, it is usually better to use {@link
- * ExoPlayer#setRepeatMode(int)}.
+ * ExoPlayer#setRepeatMode(int)} instead of this class.
  */
 public final class LoopingMediaSource extends CompositeMediaSource<Void> {
 
@@ -71,23 +71,21 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
     prepareChildSource(/* id= */ null, childSource);
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     if (loopCount == Integer.MAX_VALUE) {
-      return childSource.createPeriod(id, allocator);
+      return childSource.createPeriod(id, allocator, startPositionUs);
     }
     Object childPeriodUid = LoopingTimeline.getChildPeriodUidFromConcatenatedUid(id.periodUid);
     MediaPeriodId childMediaPeriodId = id.copyWithPeriodUid(childPeriodUid);
     childMediaPeriodIdToMediaPeriodId.put(childMediaPeriodId, id);
-    MediaPeriod mediaPeriod = childSource.createPeriod(childMediaPeriodId, allocator);
+    MediaPeriod mediaPeriod =
+        childSource.createPeriod(childMediaPeriodId, allocator, startPositionUs);
     mediaPeriodToChildMediaPeriodId.put(mediaPeriod, childMediaPeriodId);
     return mediaPeriod;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index 997f94bbfe..b40bbb35d1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -19,8 +19,12 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * Loads media corresponding to a {@link Timeline.Period}, and allows that media to be read. All
@@ -82,6 +86,22 @@
    */
   TrackGroupArray getTrackGroups();
 
+  /**
+   * Returns a list of {@link StreamKey StreamKeys} which allow to filter the media in this period
+   * to load only the parts needed to play the provided {@link TrackSelection TrackSelections}.
+   *
+   * <p>This method is only called after the period has been prepared.
+   *
+   * @param trackSelections The {@link TrackSelection TrackSelections} describing the tracks for
+   *     which stream keys are requested.
+   * @return The corresponding {@link StreamKey StreamKeys} for the selected tracks, or an empty
+   *     list if filtering is not possible and the entire media needs to be loaded to play the
+   *     selected tracks.
+   */
+  default List<StreamKey> getStreamKeys(List<TrackSelection> trackSelections) {
+    return Collections.emptyList();
+  }
+
   /**
    * Performs a track selection.
    *
@@ -108,9 +128,9 @@
    * @return The actual position at which the tracks were enabled, in microseconds.
    */
   long selectTracks(
-      TrackSelection[] selections,
+      @NullableType TrackSelection[] selections,
       boolean[] mayRetainStreamFlags,
-      SampleStream[] streams,
+      @NullableType SampleStream[] streams,
       boolean[] streamResetFlags,
       long positionUs);
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 74449ba16b..d7b7c75210 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
@@ -25,23 +25,24 @@
 import java.io.IOException;
 
 /**
- * Defines and provides media to be played by an {@link ExoPlayer}. A MediaSource has two main
- * responsibilities:
+ * Defines and provides media to be played by an {@link com.google.android.exoplayer2.ExoPlayer}. A
+ * MediaSource has two main responsibilities:
  *
  * <ul>
  *   <li>To provide the player with a {@link Timeline} defining the structure of its media, and to
  *       provide a new timeline whenever the structure of the media changes. The MediaSource
  *       provides these timelines by calling {@link SourceInfoRefreshListener#onSourceInfoRefreshed}
- *       on the {@link SourceInfoRefreshListener}s passed to {@link #prepareSource(ExoPlayer,
- *       boolean, SourceInfoRefreshListener, TransferListener)}.
+ *       on the {@link SourceInfoRefreshListener}s passed to {@link
+ *       #prepareSource(SourceInfoRefreshListener, TransferListener)}.
  *   <li>To provide {@link MediaPeriod} instances for the periods in its timeline. MediaPeriods are
- *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator)}, and provide a way for
- *       the player to load and read the media.
+ *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator, long)}, and provide a
+ *       way for the player to load and read the media.
  * </ul>
  *
  * All methods are called on the player's internal playback thread, as described in the {@link
- * ExoPlayer} Javadoc. They should not be called directly from application code. Instances can be
- * re-used, but only for one {@link ExoPlayer} instance simultaneously.
+ * com.google.android.exoplayer2.ExoPlayer} Javadoc. They should not be called directly from
+ * application code. Instances can be re-used, but only for one {@link
+ * com.google.android.exoplayer2.ExoPlayer} instance simultaneously.
  */
 public interface MediaSource {
 
@@ -89,13 +90,10 @@
     public final long windowSequenceNumber;
 
     /**
-     * The end position of the media to play within the media period, in microseconds, or {@link
-     * C#TIME_END_OF_SOURCE} if the end position is the end of the media period.
-     *
-     * <p>Note that this only applies if the media period is for content (i.e., not for an ad) and
-     * is clipped to the position of the next ad group.
+     * The index of the next ad group to which the media period's content is clipped, or {@link
+     * C#INDEX_UNSET} if there is no following ad group or if this media period is an ad.
      */
-    public final long endPositionUs;
+    public final int nextAdGroupIndex;
 
     /**
      * Creates a media period identifier for a dummy period which is not part of a buffered sequence
@@ -104,7 +102,7 @@
      * @param periodUid The unique id of the timeline period.
      */
     public MediaPeriodId(Object periodUid) {
-      this(periodUid, C.INDEX_UNSET);
+      this(periodUid, /* windowSequenceNumber= */ C.INDEX_UNSET);
     }
 
     /**
@@ -115,7 +113,12 @@ public MediaPeriodId(Object periodUid) {
      *     windows this media period is part of.
      */
     public MediaPeriodId(Object periodUid, long windowSequenceNumber) {
-      this(periodUid, C.INDEX_UNSET, C.INDEX_UNSET, windowSequenceNumber, C.TIME_END_OF_SOURCE);
+      this(
+          periodUid,
+          /* adGroupIndex= */ C.INDEX_UNSET,
+          /* adIndexInAdGroup= */ C.INDEX_UNSET,
+          windowSequenceNumber,
+          /* nextAdGroupIndex= */ C.INDEX_UNSET);
     }
 
     /**
@@ -124,11 +127,16 @@ public MediaPeriodId(Object periodUid, long windowSequenceNumber) {
      * @param periodUid The unique id of the timeline period.
      * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
      *     windows this media period is part of.
-     * @param endPositionUs The end position of the media period within the timeline period, in
-     *     microseconds.
+     * @param nextAdGroupIndex The index of the next ad group to which the media period's content is
+     *     clipped.
      */
-    public MediaPeriodId(Object periodUid, long windowSequenceNumber, long endPositionUs) {
-      this(periodUid, C.INDEX_UNSET, C.INDEX_UNSET, windowSequenceNumber, endPositionUs);
+    public MediaPeriodId(Object periodUid, long windowSequenceNumber, int nextAdGroupIndex) {
+      this(
+          periodUid,
+          /* adGroupIndex= */ C.INDEX_UNSET,
+          /* adIndexInAdGroup= */ C.INDEX_UNSET,
+          windowSequenceNumber,
+          nextAdGroupIndex);
     }
 
     /**
@@ -143,7 +151,12 @@ public MediaPeriodId(Object periodUid, long windowSequenceNumber, long endPositi
      */
     public MediaPeriodId(
         Object periodUid, int adGroupIndex, int adIndexInAdGroup, long windowSequenceNumber) {
-      this(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, C.TIME_END_OF_SOURCE);
+      this(
+          periodUid,
+          adGroupIndex,
+          adIndexInAdGroup,
+          windowSequenceNumber,
+          /* nextAdGroupIndex= */ C.INDEX_UNSET);
     }
 
     private MediaPeriodId(
@@ -151,12 +164,12 @@ private MediaPeriodId(
         int adGroupIndex,
         int adIndexInAdGroup,
         long windowSequenceNumber,
-        long endPositionUs) {
+        int nextAdGroupIndex) {
       this.periodUid = periodUid;
       this.adGroupIndex = adGroupIndex;
       this.adIndexInAdGroup = adIndexInAdGroup;
       this.windowSequenceNumber = windowSequenceNumber;
-      this.endPositionUs = endPositionUs;
+      this.nextAdGroupIndex = nextAdGroupIndex;
     }
 
     /** Returns a copy of this period identifier but with {@code newPeriodUid} as its period uid. */
@@ -164,7 +177,7 @@ public MediaPeriodId copyWithPeriodUid(Object newPeriodUid) {
       return periodUid.equals(newPeriodUid)
           ? this
           : new MediaPeriodId(
-              newPeriodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, endPositionUs);
+              newPeriodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, nextAdGroupIndex);
     }
 
     /**
@@ -188,7 +201,7 @@ public boolean equals(@Nullable Object obj) {
           && adGroupIndex == periodId.adGroupIndex
           && adIndexInAdGroup == periodId.adIndexInAdGroup
           && windowSequenceNumber == periodId.windowSequenceNumber
-          && endPositionUs == periodId.endPositionUs;
+          && nextAdGroupIndex == periodId.nextAdGroupIndex;
     }
 
     @Override
@@ -198,7 +211,7 @@ public int hashCode() {
       result = 31 * result + adGroupIndex;
       result = 31 * result + adIndexInAdGroup;
       result = 31 * result + (int) windowSequenceNumber;
-      result = 31 * result + (int) endPositionUs;
+      result = 31 * result + nextAdGroupIndex;
       return result;
     }
   }
@@ -226,11 +239,6 @@ default Object getTag() {
     return null;
   }
 
-  /** @deprecated Will be removed in the next release. */
-  @Deprecated
-  void prepareSource(
-      ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener);
-
   /**
    * Starts source preparation if not yet started, and adds a listener for timeline and/or manifest
    * updates.
@@ -242,11 +250,6 @@ void prepareSource(
    * <p>For each call to this method, a call to {@link #releaseSource(SourceInfoRefreshListener)} is
    * needed to remove the listener and to release the source if no longer required.
    *
-   * @param player The player for which this source is being prepared.
-   * @param isTopLevelSource Whether this source has been passed directly to {@link
-   *     ExoPlayer#prepare(MediaSource)} or {@link ExoPlayer#prepare(MediaSource, boolean,
-   *     boolean)}. If {@code false}, this source is being prepared by another source (e.g. {@link
-   *     ConcatenatingMediaSource}) for composition.
    * @param listener The listener to be added.
    * @param mediaTransferListener The transfer listener which should be informed of any media data
    *     transfers. May be null if no listener is available. Note that this listener should be only
@@ -254,10 +257,7 @@ void prepareSource(
    *     and other data.
    */
   void prepareSource(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      SourceInfoRefreshListener listener,
-      @Nullable TransferListener mediaTransferListener);
+      SourceInfoRefreshListener listener, @Nullable TransferListener mediaTransferListener);
 
   /**
    * Throws any pending error encountered while loading or refreshing source information.
@@ -274,9 +274,10 @@ void prepareSource(
    *
    * @param id The identifier of the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
+   * @param startPositionUs The expected start position, in microseconds.
    * @return A new {@link MediaPeriod}.
    */
-  MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator);
+  MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs);
 
   /**
    * Releases the period.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
index 98d1d0a2ab..233e19b29c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
@@ -19,8 +19,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.support.annotation.CheckResult;
-import android.support.annotation.Nullable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index 573e97cb13..6b1a362b59 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -15,9 +15,8 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -105,11 +104,8 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
     for (int i = 0; i < mediaSources.length; i++) {
       prepareChildSource(i, mediaSources[i]);
     }
@@ -124,13 +120,13 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     MediaPeriod[] periods = new MediaPeriod[mediaSources.length];
     int periodIndex = timelines[0].getIndexOfPeriod(id.periodUid);
     for (int i = 0; i < periods.length; i++) {
       MediaPeriodId childMediaPeriodId =
           id.copyWithPeriodUid(timelines[i].getUidOfPeriod(periodIndex));
-      periods[i] = mediaSources[i].createPeriod(childMediaPeriodId, allocator);
+      periods[i] = mediaSources[i].createPeriod(childMediaPeriodId, allocator, startPositionUs);
     }
     return new MergingMediaPeriod(compositeSequenceableLoaderFactory, periods);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
similarity index 84%
rename from library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
rename to library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
index 31daf65d38..d9f0008a7f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
@@ -17,10 +17,11 @@
 
 import android.net.Uri;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
@@ -30,7 +31,10 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.SeekMap.SeekPoints;
+import com.google.android.exoplayer2.extractor.SeekMap.Unseekable;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue.UpstreamFormatChangedListener;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -45,18 +49,20 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Arrays;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
-/**
- * A {@link MediaPeriod} that extracts data using an {@link Extractor}.
- */
-/* package */ final class ExtractorMediaPeriod implements MediaPeriod, ExtractorOutput,
-    Loader.Callback<ExtractorMediaPeriod.ExtractingLoadable>, Loader.ReleaseCallback,
-    UpstreamFormatChangedListener {
+/** A {@link MediaPeriod} that extracts data using an {@link Extractor}. */
+/* package */ final class ProgressiveMediaPeriod
+    implements MediaPeriod,
+        ExtractorOutput,
+        Loader.Callback<ProgressiveMediaPeriod.ExtractingLoadable>,
+        Loader.ReleaseCallback,
+        UpstreamFormatChangedListener {
 
   /**
    * Listener for information about the period.
@@ -79,13 +85,16 @@
    */
   private static final long DEFAULT_LAST_SAMPLE_DURATION_US = 10000;
 
+  private static final Format ICY_FORMAT =
+      Format.createSampleFormat("icy", MimeTypes.APPLICATION_ICY, Format.OFFSET_SAMPLE_RELATIVE);
+
   private final Uri uri;
   private final DataSource dataSource;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final EventDispatcher eventDispatcher;
   private final Listener listener;
   private final Allocator allocator;
-  private final @Nullable String customCacheKey;
+  @Nullable private final String customCacheKey;
   private final long continueLoadingCheckIntervalBytes;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
@@ -94,14 +103,15 @@
   private final Runnable onContinueLoadingRequestedRunnable;
   private final Handler handler;
 
-  private @Nullable Callback callback;
-  private @Nullable SeekMap seekMap;
+  @Nullable private Callback callback;
+  @Nullable private SeekMap seekMap;
+  @Nullable private IcyHeaders icyHeaders;
   private SampleQueue[] sampleQueues;
-  private int[] sampleQueueTrackIds;
+  private TrackId[] sampleQueueTrackIds;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
 
-  private @Nullable PreparedState preparedState;
+  @Nullable private PreparedState preparedState;
   private boolean haveAudioVideoTracks;
   private int dataType;
 
@@ -134,8 +144,11 @@
    *     invocation of {@link Callback#onContinueLoadingRequested(SequenceableLoader)}.
    */
   // maybeFinishPrepare is not posted to the handler until initialization completes.
-  @SuppressWarnings("nullness:methodref.receiver.bound.invalid")
-  public ExtractorMediaPeriod(
+  @SuppressWarnings({
+    "nullness:argument.type.incompatible",
+    "nullness:methodref.receiver.bound.invalid"
+  })
+  public ProgressiveMediaPeriod(
       Uri uri,
       DataSource dataSource,
       Extractor[] extractors,
@@ -153,18 +166,19 @@ public ExtractorMediaPeriod(
     this.allocator = allocator;
     this.customCacheKey = customCacheKey;
     this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
-    loader = new Loader("Loader:ExtractorMediaPeriod");
+    loader = new Loader("Loader:ProgressiveMediaPeriod");
     extractorHolder = new ExtractorHolder(extractors);
     loadCondition = new ConditionVariable();
     maybeFinishPrepareRunnable = this::maybeFinishPrepare;
     onContinueLoadingRequestedRunnable =
         () -> {
           if (!released) {
-            Assertions.checkNotNull(callback).onContinueLoadingRequested(ExtractorMediaPeriod.this);
+            Assertions.checkNotNull(callback)
+                .onContinueLoadingRequested(ProgressiveMediaPeriod.this);
           }
         };
     handler = new Handler();
-    sampleQueueTrackIds = new int[0];
+    sampleQueueTrackIds = new TrackId[0];
     sampleQueues = new SampleQueue[0];
     pendingResetPositionUs = C.TIME_UNSET;
     length = C.LENGTH_UNSET;
@@ -206,6 +220,9 @@ public void prepare(Callback callback, long positionUs) {
   @Override
   public void maybeThrowPrepareError() throws IOException {
     maybeThrowError();
+    if (loadingFinished && !prepared) {
+      throw new ParserException("Loading finished before preparation is complete.");
+    }
   }
 
   @Override
@@ -215,7 +232,7 @@ public TrackGroupArray getTrackGroups() {
 
   @Override
   public long selectTracks(
-      TrackSelection[] selections,
+      @NullableType TrackSelection[] selections,
       boolean[] mayRetainStreamFlags,
       @NullableType SampleStream[] streams,
       boolean[] streamResetFlags,
@@ -346,18 +363,18 @@ public long getBufferedPositionUs() {
     } else if (isPendingReset()) {
       return pendingResetPositionUs;
     }
-    long largestQueuedTimestampUs;
+    long largestQueuedTimestampUs = Long.MAX_VALUE;
     if (haveAudioVideoTracks) {
       // Ignore non-AV tracks, which may be sparse or poorly interleaved.
-      largestQueuedTimestampUs = Long.MAX_VALUE;
       int trackCount = sampleQueues.length;
       for (int i = 0; i < trackCount; i++) {
-        if (trackIsAudioVideoFlags[i]) {
+        if (trackIsAudioVideoFlags[i] && !sampleQueues[i].isLastSampleQueued()) {
           largestQueuedTimestampUs = Math.min(largestQueuedTimestampUs,
               sampleQueues[i].getLargestQueuedTimestampUs());
         }
       }
-    } else {
+    }
+    if (largestQueuedTimestampUs == Long.MAX_VALUE) {
       largestQueuedTimestampUs = getLargestQueuedTimestampUs();
     }
     return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs
@@ -500,12 +517,12 @@ private boolean suppressRead() {
   @Override
   public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs) {
-    if (durationUs == C.TIME_UNSET) {
-      SeekMap seekMap = Assertions.checkNotNull(this.seekMap);
+    if (durationUs == C.TIME_UNSET && seekMap != null) {
+      boolean isSeekable = seekMap.isSeekable();
       long largestQueuedTimestampUs = getLargestQueuedTimestampUs();
       durationUs = largestQueuedTimestampUs == Long.MIN_VALUE ? 0
           : largestQueuedTimestampUs + DEFAULT_LAST_SAMPLE_DURATION_US;
-      listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
+      listener.onSourceInfoRefreshed(durationUs, isSeekable);
     }
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
@@ -564,7 +581,7 @@ public LoadErrorAction onLoadError(
     copyLengthFromLoader(loadable);
     LoadErrorAction loadErrorAction;
     long retryDelayMs =
-        loadErrorHandlingPolicy.getRetryDelayMsFor(dataType, durationUs, error, errorCount);
+        loadErrorHandlingPolicy.getRetryDelayMsFor(dataType, loadDurationMs, error, errorCount);
     if (retryDelayMs == C.TIME_UNSET) {
       loadErrorAction = Loader.DONT_RETRY_FATAL;
     } else /* the load should be retried */ {
@@ -599,20 +616,7 @@ public LoadErrorAction onLoadError(
 
   @Override
   public TrackOutput track(int id, int type) {
-    int trackCount = sampleQueues.length;
-    for (int i = 0; i < trackCount; i++) {
-      if (sampleQueueTrackIds[i] == id) {
-        return sampleQueues[i];
-      }
-    }
-    SampleQueue trackOutput = new SampleQueue(allocator);
-    trackOutput.setUpstreamFormatChangeListener(this);
-    sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
-    sampleQueueTrackIds[trackCount] = id;
-    @NullableType SampleQueue[] sampleQueues = Arrays.copyOf(this.sampleQueues, trackCount + 1);
-    sampleQueues[trackCount] = trackOutput;
-    this.sampleQueues = Util.castNonNullTypeArray(sampleQueues);
-    return trackOutput;
+    return prepareTrackOutput(new TrackId(id, /* isIcyTrack= */ false));
   }
 
   @Override
@@ -623,10 +627,16 @@ public void endTracks() {
 
   @Override
   public void seekMap(SeekMap seekMap) {
-    this.seekMap = seekMap;
+    this.seekMap = icyHeaders == null ? seekMap : new Unseekable(/* durationUs */ C.TIME_UNSET);
     handler.post(maybeFinishPrepareRunnable);
   }
 
+  // Icy metadata. Called by the loading thread.
+
+  /* package */ TrackOutput icyTrack() {
+    return prepareTrackOutput(new TrackId(0, /* isIcyTrack= */ true));
+  }
+
   // UpstreamFormatChangedListener implementation. Called by the loading thread.
 
   @Override
@@ -636,6 +646,25 @@ public void onUpstreamFormatChanged(Format format) {
 
   // Internal methods.
 
+  private TrackOutput prepareTrackOutput(TrackId id) {
+    int trackCount = sampleQueues.length;
+    for (int i = 0; i < trackCount; i++) {
+      if (id.equals(sampleQueueTrackIds[i])) {
+        return sampleQueues[i];
+      }
+    }
+    SampleQueue trackOutput = new SampleQueue(allocator);
+    trackOutput.setUpstreamFormatChangeListener(this);
+    @NullableType
+    TrackId[] sampleQueueTrackIds = Arrays.copyOf(this.sampleQueueTrackIds, trackCount + 1);
+    sampleQueueTrackIds[trackCount] = id;
+    this.sampleQueueTrackIds = Util.castNonNullTypeArray(sampleQueueTrackIds);
+    @NullableType SampleQueue[] sampleQueues = Arrays.copyOf(this.sampleQueues, trackCount + 1);
+    sampleQueues[trackCount] = trackOutput;
+    this.sampleQueues = Util.castNonNullTypeArray(sampleQueues);
+    return trackOutput;
+  }
+
   private void maybeFinishPrepare() {
     SeekMap seekMap = this.seekMap;
     if (released || prepared || !sampleQueuesBuilt || seekMap == null) {
@@ -653,11 +682,28 @@ private void maybeFinishPrepare() {
     durationUs = seekMap.getDurationUs();
     for (int i = 0; i < trackCount; i++) {
       Format trackFormat = sampleQueues[i].getUpstreamFormat();
-      trackArray[i] = new TrackGroup(trackFormat);
       String mimeType = trackFormat.sampleMimeType;
-      boolean isAudioVideo = MimeTypes.isVideo(mimeType) || MimeTypes.isAudio(mimeType);
+      boolean isAudio = MimeTypes.isAudio(mimeType);
+      boolean isAudioVideo = isAudio || MimeTypes.isVideo(mimeType);
       trackIsAudioVideoFlags[i] = isAudioVideo;
       haveAudioVideoTracks |= isAudioVideo;
+      IcyHeaders icyHeaders = this.icyHeaders;
+      if (icyHeaders != null) {
+        if (isAudio || sampleQueueTrackIds[i].isIcyTrack) {
+          Metadata metadata = trackFormat.metadata;
+          trackFormat =
+              trackFormat.copyWithMetadata(
+                  metadata == null
+                      ? new Metadata(icyHeaders)
+                      : metadata.copyWithAppendedEntries(icyHeaders));
+        }
+        if (isAudio
+            && trackFormat.bitrate == Format.NO_VALUE
+            && icyHeaders.bitrate != Format.NO_VALUE) {
+          trackFormat = trackFormat.copyWithBitrate(icyHeaders.bitrate);
+        }
+      }
+      trackArray[i] = new TrackGroup(trackFormat);
     }
     dataType =
         length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET
@@ -812,29 +858,29 @@ public SampleStreamImpl(int track) {
 
     @Override
     public boolean isReady() {
-      return ExtractorMediaPeriod.this.isReady(track);
+      return ProgressiveMediaPeriod.this.isReady(track);
     }
 
     @Override
     public void maybeThrowError() throws IOException {
-      ExtractorMediaPeriod.this.maybeThrowError();
+      ProgressiveMediaPeriod.this.maybeThrowError();
     }
 
     @Override
     public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         boolean formatRequired) {
-      return ExtractorMediaPeriod.this.readData(track, formatHolder, buffer, formatRequired);
+      return ProgressiveMediaPeriod.this.readData(track, formatHolder, buffer, formatRequired);
     }
 
     @Override
     public int skipData(long positionUs) {
-      return ExtractorMediaPeriod.this.skipData(track, positionUs);
+      return ProgressiveMediaPeriod.this.skipData(track, positionUs);
     }
 
   }
 
   /** Loads the media stream and extracts sample data from it. */
-  /* package */ final class ExtractingLoadable implements Loadable {
+  /* package */ final class ExtractingLoadable implements Loadable, IcyDataSource.Listener {
 
     private final Uri uri;
     private final StatsDataSource dataSource;
@@ -849,7 +895,10 @@ public int skipData(long positionUs) {
     private long seekTimeUs;
     private DataSpec dataSpec;
     private long length;
+    @Nullable private TrackOutput icyTrackOutput;
+    private boolean seenIcyMetadata;
 
+    @SuppressWarnings("method.invocation.invalid")
     public ExtractingLoadable(
         Uri uri,
         DataSource dataSource,
@@ -864,7 +913,7 @@ public ExtractingLoadable(
       this.positionHolder = new PositionHolder();
       this.pendingExtractorSeek = true;
       this.length = C.LENGTH_UNSET;
-      dataSpec = new DataSpec(uri, positionHolder.position, C.LENGTH_UNSET, customCacheKey);
+      dataSpec = buildDataSpec(/* position= */ 0);
     }
 
     // Loadable implementation.
@@ -881,13 +930,20 @@ public void load() throws IOException, InterruptedException {
         ExtractorInput input = null;
         try {
           long position = positionHolder.position;
-          dataSpec = new DataSpec(uri, position, C.LENGTH_UNSET, customCacheKey);
+          dataSpec = buildDataSpec(position);
           length = dataSource.open(dataSpec);
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
           Uri uri = Assertions.checkNotNull(dataSource.getUri());
-          input = new DefaultExtractorInput(dataSource, position, length);
+          icyHeaders = IcyHeaders.parse(dataSource.getResponseHeaders());
+          DataSource extractorDataSource = dataSource;
+          if (icyHeaders != null && icyHeaders.metadataInterval != C.LENGTH_UNSET) {
+            extractorDataSource = new IcyDataSource(dataSource, icyHeaders.metadataInterval, this);
+            icyTrackOutput = icyTrack();
+            icyTrackOutput.format(ICY_FORMAT);
+          }
+          input = new DefaultExtractorInput(extractorDataSource, position, length);
           Extractor extractor = extractorHolder.selectExtractor(input, extractorOutput, uri);
           if (pendingExtractorSeek) {
             extractor.seek(position, seekTimeUs);
@@ -913,12 +969,42 @@ public void load() throws IOException, InterruptedException {
       }
     }
 
+    // IcyDataSource.Listener
+
+    @Override
+    public void onIcyMetadata(ParsableByteArray metadata) {
+      // Always output the first ICY metadata at the start time. This helps minimize any delay
+      // between the start of playback and the first ICY metadata event.
+      long timeUs =
+          !seenIcyMetadata ? seekTimeUs : Math.max(getLargestQueuedTimestampUs(), seekTimeUs);
+      int length = metadata.bytesLeft();
+      TrackOutput icyTrackOutput = Assertions.checkNotNull(this.icyTrackOutput);
+      icyTrackOutput.sampleData(metadata, length);
+      icyTrackOutput.sampleMetadata(
+          timeUs, C.BUFFER_FLAG_KEY_FRAME, length, /* offset= */ 0, /* encryptionData= */ null);
+      seenIcyMetadata = true;
+    }
+
     // Internal methods.
 
+    private DataSpec buildDataSpec(long position) {
+      // Disable caching if the content length cannot be resolved, since this is indicative of a
+      // progressive live stream.
+      return new DataSpec(
+          uri,
+          position,
+          C.LENGTH_UNSET,
+          customCacheKey,
+          DataSpec.FLAG_ALLOW_ICY_METADATA
+              | DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN
+              | DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION);
+    }
+
     private void setLoadPosition(long position, long timeUs) {
       positionHolder.position = position;
       seekTimeUs = timeUs;
       pendingExtractorSeek = true;
+      seenIcyMetadata = false;
     }
   }
 
@@ -1002,4 +1088,33 @@ public PreparedState(
       this.trackNotifiedDownstreamFormats = new boolean[tracks.length];
     }
   }
+
+  /** Identifies a track. */
+  private static final class TrackId {
+
+    public final int id;
+    public final boolean isIcyTrack;
+
+    public TrackId(int id, boolean isIcyTrack) {
+      this.id = id;
+      this.isIcyTrack = isIcyTrack;
+    }
+
+    @Override
+    public boolean equals(@Nullable Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null || getClass() != obj.getClass()) {
+        return false;
+      }
+      TrackId other = (TrackId) obj;
+      return id == other.id && isIcyTrack == other.isIcyTrack;
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * id + (isIcyTrack ? 1 : 0);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
new file mode 100644
index 0000000000..f448b0b6c8
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+
+/**
+ * Provides one period that loads data from a {@link Uri} and extracted using an {@link Extractor}.
+ *
+ * <p>If the possible input stream container formats are known, pass a factory that instantiates
+ * extractors for them to the constructor. Otherwise, pass a {@link DefaultExtractorsFactory} to use
+ * the default extractors. When reading a new stream, the first {@link Extractor} in the array of
+ * extractors created by the factory that returns {@code true} from {@link Extractor#sniff} will be
+ * used to extract samples from the input stream.
+ *
+ * <p>Note that the built-in extractor for FLV streams does not support seeking.
+ */
+public final class ProgressiveMediaSource extends BaseMediaSource
+    implements ProgressiveMediaPeriod.Listener {
+
+  /** Factory for {@link ProgressiveMediaSource}s. */
+  public static final class Factory implements AdsMediaSource.MediaSourceFactory {
+
+    private final DataSource.Factory dataSourceFactory;
+
+    private ExtractorsFactory extractorsFactory;
+    @Nullable private String customCacheKey;
+    @Nullable private Object tag;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
+    private int continueLoadingCheckIntervalBytes;
+    private boolean isCreateCalled;
+
+    /**
+     * Creates a new factory for {@link ProgressiveMediaSource}s, using the extractors provided by
+     * {@link DefaultExtractorsFactory}.
+     *
+     * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+     */
+    public Factory(DataSource.Factory dataSourceFactory) {
+      this(dataSourceFactory, new DefaultExtractorsFactory());
+    }
+
+    /**
+     * Creates a new factory for {@link ProgressiveMediaSource}s.
+     *
+     * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+     * @param extractorsFactory A factory for extractors used to extract media from its container.
+     */
+    public Factory(DataSource.Factory dataSourceFactory, ExtractorsFactory extractorsFactory) {
+      this.dataSourceFactory = dataSourceFactory;
+      this.extractorsFactory = extractorsFactory;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
+      continueLoadingCheckIntervalBytes = DEFAULT_LOADING_CHECK_INTERVAL_BYTES;
+    }
+
+    /**
+     * Sets the factory for {@link Extractor}s to process the media stream. The default value is an
+     * instance of {@link DefaultExtractorsFactory}.
+     *
+     * @param extractorsFactory A factory for {@link Extractor}s to process the media stream. If the
+     *     possible formats are known, pass a factory that instantiates extractors for those
+     *     formats.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     * @deprecated Pass the {@link ExtractorsFactory} via {@link #Factory(DataSource.Factory,
+     *     ExtractorsFactory)}. This is necessary so that proguard can treat the default extractors
+     *     factory as unused.
+     */
+    @Deprecated
+    public Factory setExtractorsFactory(ExtractorsFactory extractorsFactory) {
+      Assertions.checkState(!isCreateCalled);
+      this.extractorsFactory = extractorsFactory;
+      return this;
+    }
+
+    /**
+     * Sets the custom key that uniquely identifies the original stream. Used for cache indexing.
+     * The default value is {@code null}.
+     *
+     * @param customCacheKey A custom key that uniquely identifies the original stream. Used for
+     *     cache indexing.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setCustomCacheKey(String customCacheKey) {
+      Assertions.checkState(!isCreateCalled);
+      this.customCacheKey = customCacheKey;
+      return this;
+    }
+
+    /**
+     * Sets a tag for the media source which will be published in the {@link
+     * com.google.android.exoplayer2.Timeline} of the source as {@link
+     * com.google.android.exoplayer2.Timeline.Window#tag}.
+     *
+     * @param tag A tag for the media source.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setTag(Object tag) {
+      Assertions.checkState(!isCreateCalled);
+      this.tag = tag;
+      return this;
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy}. The default value is created by calling {@link
+     * DefaultLoadErrorHandlingPolicy#DefaultLoadErrorHandlingPolicy()}.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
+      Assertions.checkState(!isCreateCalled);
+      this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
+      return this;
+    }
+
+    /**
+     * Sets the number of bytes that should be loaded between each invocation of {@link
+     * MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}. The default value is
+     * {@link #DEFAULT_LOADING_CHECK_INTERVAL_BYTES}.
+     *
+     * @param continueLoadingCheckIntervalBytes The number of bytes that should be loaded between
+     *     each invocation of {@link
+     *     MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setContinueLoadingCheckIntervalBytes(int continueLoadingCheckIntervalBytes) {
+      Assertions.checkState(!isCreateCalled);
+      this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
+      return this;
+    }
+
+    /**
+     * Returns a new {@link ProgressiveMediaSource} using the current parameters.
+     *
+     * @param uri The {@link Uri}.
+     * @return The new {@link ProgressiveMediaSource}.
+     */
+    @Override
+    public ProgressiveMediaSource createMediaSource(Uri uri) {
+      isCreateCalled = true;
+      return new ProgressiveMediaSource(
+          uri,
+          dataSourceFactory,
+          extractorsFactory,
+          loadErrorHandlingPolicy,
+          customCacheKey,
+          continueLoadingCheckIntervalBytes,
+          tag);
+    }
+
+    @Override
+    public int[] getSupportedTypes() {
+      return new int[] {C.TYPE_OTHER};
+    }
+  }
+
+  /**
+   * The default number of bytes that should be loaded between each each invocation of {@link
+   * MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
+   */
+  public static final int DEFAULT_LOADING_CHECK_INTERVAL_BYTES = 1024 * 1024;
+
+  private final Uri uri;
+  private final DataSource.Factory dataSourceFactory;
+  private final ExtractorsFactory extractorsFactory;
+  private final LoadErrorHandlingPolicy loadableLoadErrorHandlingPolicy;
+  @Nullable private final String customCacheKey;
+  private final int continueLoadingCheckIntervalBytes;
+  @Nullable private final Object tag;
+
+  private long timelineDurationUs;
+  private boolean timelineIsSeekable;
+  @Nullable private TransferListener transferListener;
+
+  // TODO: Make private when ExtractorMediaSource is deleted.
+  /* package */ ProgressiveMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory,
+      LoadErrorHandlingPolicy loadableLoadErrorHandlingPolicy,
+      @Nullable String customCacheKey,
+      int continueLoadingCheckIntervalBytes,
+      @Nullable Object tag) {
+    this.uri = uri;
+    this.dataSourceFactory = dataSourceFactory;
+    this.extractorsFactory = extractorsFactory;
+    this.loadableLoadErrorHandlingPolicy = loadableLoadErrorHandlingPolicy;
+    this.customCacheKey = customCacheKey;
+    this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
+    this.timelineDurationUs = C.TIME_UNSET;
+    this.tag = tag;
+  }
+
+  @Override
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
+  @Override
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    transferListener = mediaTransferListener;
+    notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    // Do nothing.
+  }
+
+  @Override
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+    DataSource dataSource = dataSourceFactory.createDataSource();
+    if (transferListener != null) {
+      dataSource.addTransferListener(transferListener);
+    }
+    return new ProgressiveMediaPeriod(
+        uri,
+        dataSource,
+        extractorsFactory.createExtractors(),
+        loadableLoadErrorHandlingPolicy,
+        createEventDispatcher(id),
+        this,
+        allocator,
+        customCacheKey,
+        continueLoadingCheckIntervalBytes);
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {
+    ((ProgressiveMediaPeriod) mediaPeriod).release();
+  }
+
+  @Override
+  public void releaseSourceInternal() {
+    // Do nothing.
+  }
+
+  // ProgressiveMediaPeriod.Listener implementation.
+
+  @Override
+  public void onSourceInfoRefreshed(long durationUs, boolean isSeekable) {
+    // If we already have the duration from a previous source info refresh, use it.
+    durationUs = durationUs == C.TIME_UNSET ? timelineDurationUs : durationUs;
+    if (timelineDurationUs == durationUs && timelineIsSeekable == isSeekable) {
+      // Suppress no-op source info changes.
+      return;
+    }
+    notifySourceInfoRefreshed(durationUs, isSeekable);
+  }
+
+  // Internal methods.
+
+  private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
+    timelineDurationUs = durationUs;
+    timelineIsSeekable = isSeekable;
+    // TODO: Make timeline dynamic until its duration is known. This is non-trivial. See b/69703223.
+    refreshSourceInfo(
+        new SinglePeriodTimeline(
+            timelineDurationUs, timelineIsSeekable, /* isDynamic= */ false, tag),
+        /* manifest= */ null);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
index e5b950cf2e..25cc73d4ae 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
@@ -57,6 +57,7 @@
 
   private long largestDiscardedTimestampUs;
   private long largestQueuedTimestampUs;
+  private boolean isLastSampleQueued;
   private boolean upstreamKeyframeRequired;
   private boolean upstreamFormatRequired;
   private Format upstreamFormat;
@@ -93,6 +94,7 @@ public void reset(boolean resetUpstreamFormat) {
     upstreamKeyframeRequired = true;
     largestDiscardedTimestampUs = Long.MIN_VALUE;
     largestQueuedTimestampUs = Long.MIN_VALUE;
+    isLastSampleQueued = false;
     if (resetUpstreamFormat) {
       upstreamFormat = null;
       upstreamFormatRequired = true;
@@ -118,6 +120,7 @@ public long discardUpstreamSamples(int discardFromIndex) {
     Assertions.checkArgument(0 <= discardCount && discardCount <= (length - readPosition));
     length -= discardCount;
     largestQueuedTimestampUs = Math.max(largestDiscardedTimestampUs, getLargestTimestamp(length));
+    isLastSampleQueued = discardCount == 0 && isLastSampleQueued;
     if (length == 0) {
       return 0;
     } else {
@@ -186,6 +189,19 @@ public synchronized long getLargestQueuedTimestampUs() {
     return largestQueuedTimestampUs;
   }
 
+  /**
+   * Returns whether the last sample of the stream has knowingly been queued. A return value of
+   * {@code false} means that the last sample had not been queued or that it's unknown whether the
+   * last sample has been queued.
+   *
+   * <p>Samples that were discarded by calling {@link #discardUpstreamSamples(int)} are not
+   * considered as having been queued. Samples that were dequeued from the front of the queue are
+   * considered as having been queued.
+   */
+  public synchronized boolean isLastSampleQueued() {
+    return isLastSampleQueued;
+  }
+
   /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */
   public synchronized long getFirstTimestampUs() {
     return length == 0 ? Long.MIN_VALUE : timesUs[relativeFirstIndex];
@@ -203,28 +219,34 @@ public synchronized void rewind() {
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If a sample is read then the buffer is populated with information
-   *     about the sample, but not its data. The size and absolute position of the data in the
-   *     rolling buffer is stored in {@code extrasHolder}, along with an encryption id if present
-   *     and the absolute position of the first byte that may still be required after the current
-   *     sample has been read. May be null if the caller requires that the format of the stream be
-   *     read even if it's not changing.
-   * @param formatRequired Whether the caller requires that the format of the stream be read even
-   *     if it's not changing. A sample will never be read if set to true, however it is still
-   *     possible for the end of stream or nothing to be read.
+   *     end of the stream. If a sample is read then the buffer is populated with information about
+   *     the sample, but not its data. The size and absolute position of the data in the rolling
+   *     buffer is stored in {@code extrasHolder}, along with an encryption id if present and the
+   *     absolute position of the first byte that may still be required after the current sample has
+   *     been read. If a {@link DecoderInputBuffer#isFlagsOnly() flags-only} buffer is passed, only
+   *     the buffer flags may be populated by this method and the read position of the queue will
+   *     not change. May be null if the caller requires that the format of the stream be read even
+   *     if it's not changing.
+   * @param formatRequired Whether the caller requires that the format of the stream be read even if
+   *     it's not changing. A sample will never be read if set to true, however it is still possible
+   *     for the end of stream or nothing to be read.
    * @param loadingFinished True if an empty queue should be considered the end of the stream.
-   * @param downstreamFormat The current downstream {@link Format}. If the format of the next
-   *     sample is different to the current downstream format then a format will be read.
+   * @param downstreamFormat The current downstream {@link Format}. If the format of the next sample
+   *     is different to the current downstream format then a format will be read.
    * @param extrasHolder The holder into which extra sample information should be written.
-   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ}
-   *     or {@link C#RESULT_BUFFER_READ}.
+   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
+   *     {@link C#RESULT_BUFFER_READ}.
    */
   @SuppressWarnings("ReferenceEquality")
-  public synchronized int read(FormatHolder formatHolder, DecoderInputBuffer buffer,
-      boolean formatRequired, boolean loadingFinished, Format downstreamFormat,
+  public synchronized int read(
+      FormatHolder formatHolder,
+      DecoderInputBuffer buffer,
+      boolean formatRequired,
+      boolean loadingFinished,
+      Format downstreamFormat,
       SampleExtrasHolder extrasHolder) {
     if (!hasNextSample()) {
-      if (loadingFinished) {
+      if (loadingFinished || isLastSampleQueued) {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
       } else if (upstreamFormat != null
@@ -242,12 +264,12 @@ public synchronized int read(FormatHolder formatHolder, DecoderInputBuffer buffe
       return C.RESULT_FORMAT_READ;
     }
 
+    buffer.setFlags(flags[relativeReadIndex]);
+    buffer.timeUs = timesUs[relativeReadIndex];
     if (buffer.isFlagsOnly()) {
-      return C.RESULT_NOTHING_READ;
+      return C.RESULT_BUFFER_READ;
     }
 
-    buffer.timeUs = timesUs[relativeReadIndex];
-    buffer.setFlags(flags[relativeReadIndex]);
     extrasHolder.size = sizes[relativeReadIndex];
     extrasHolder.offset = offsets[relativeReadIndex];
     extrasHolder.cryptoData = cryptoDatas[relativeReadIndex];
@@ -388,7 +410,9 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       upstreamKeyframeRequired = false;
     }
     Assertions.checkState(!upstreamFormatRequired);
-    commitSampleTimestamp(timeUs);
+
+    isLastSampleQueued = (sampleFlags & C.BUFFER_FLAG_LAST_SAMPLE) != 0;
+    largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timeUs);
 
     int relativeEndIndex = getRelativeIndex(length);
     timesUs[relativeEndIndex] = timeUs;
@@ -439,10 +463,6 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
     }
   }
 
-  public synchronized void commitSampleTimestamp(long timeUs) {
-    largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timeUs);
-  }
-
   /**
    * Attempts to discard samples from the end of the queue to allow samples starting from the
    * specified timestamp to be spliced in. Samples will not be discarded prior to the read position.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index ecc720c656..e8f4953436 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -224,6 +224,15 @@ public long getLargestQueuedTimestampUs() {
     return metadataQueue.getLargestQueuedTimestampUs();
   }
 
+  /**
+   * Returns whether the last sample of the stream has knowingly been queued. A return value of
+   * {@code false} means that the last sample had not been queued or that it's unknown whether the
+   * last sample has been queued.
+   */
+  public boolean isLastSampleQueued() {
+    return metadataQueue.isLastSampleQueued();
+  }
+
   /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */
   public long getFirstTimestampUs() {
     return metadataQueue.getFirstTimestampUs();
@@ -308,8 +317,10 @@ public boolean setReadPosition(int sampleIndex) {
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     end of the stream. If the end of the stream has been reached, the {@link
+   *     C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. If a {@link
+   *     DecoderInputBuffer#isFlagsOnly() flags-only} buffer is passed, only the buffer flags may be
+   *     populated by this method and the read position of the queue will not change.
    * @param formatRequired Whether the caller requires that the format of the stream be read even if
    *     it's not changing. A sample will never be read if set to true, however it is still possible
    *     for the end of stream or nothing to be read.
@@ -319,8 +330,12 @@ public boolean setReadPosition(int sampleIndex) {
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
-  public int read(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired,
-      boolean loadingFinished, long decodeOnlyUntilUs) {
+  public int read(
+      FormatHolder formatHolder,
+      DecoderInputBuffer buffer,
+      boolean formatRequired,
+      boolean loadingFinished,
+      long decodeOnlyUntilUs) {
     int result = metadataQueue.read(formatHolder, buffer, formatRequired, loadingFinished,
         downstreamFormat, extrasHolder);
     switch (result) {
@@ -332,13 +347,15 @@ public int read(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean fo
           if (buffer.timeUs < decodeOnlyUntilUs) {
             buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
           }
-          // Read encryption data if the sample is encrypted.
-          if (buffer.isEncrypted()) {
-            readEncryptionData(buffer, extrasHolder);
+          if (!buffer.isFlagsOnly()) {
+            // Read encryption data if the sample is encrypted.
+            if (buffer.isEncrypted()) {
+              readEncryptionData(buffer, extrasHolder);
+            }
+            // Write the sample data into the holder.
+            buffer.ensureSpaceForWrite(extrasHolder.size);
+            readData(extrasHolder.offset, buffer.data, extrasHolder.size);
           }
-          // Write the sample data into the holder.
-          buffer.ensureSpaceForWrite(extrasHolder.size);
-          readData(extrasHolder.offset, buffer.data, extrasHolder.size);
         }
         return C.RESULT_BUFFER_READ;
       case C.RESULT_NOTHING_READ:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
index 06efc980e2..54293aa4c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
@@ -45,18 +45,20 @@
 
   /**
    * Attempts to read from the stream.
-   * <p>
-   * If the stream has ended then {@link C#BUFFER_FLAG_END_OF_STREAM} flag is set on {@code buffer}
-   * and {@link C#RESULT_BUFFER_READ} is returned. Else if no data is available then
-   * {@link C#RESULT_NOTHING_READ} is returned. Else if the format of the media is changing or if
-   * {@code formatRequired} is set then {@code formatHolder} is populated and
-   * {@link C#RESULT_FORMAT_READ} is returned. Else {@code buffer} is populated and
-   * {@link C#RESULT_BUFFER_READ} is returned.
+   *
+   * <p>If the stream has ended then {@link C#BUFFER_FLAG_END_OF_STREAM} flag is set on {@code
+   * buffer} and {@link C#RESULT_BUFFER_READ} is returned. Else if no data is available then {@link
+   * C#RESULT_NOTHING_READ} is returned. Else if the format of the media is changing or if {@code
+   * formatRequired} is set then {@code formatHolder} is populated and {@link C#RESULT_FORMAT_READ}
+   * is returned. Else {@code buffer} is populated and {@link C#RESULT_BUFFER_READ} is returned.
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     end of the stream. If the end of the stream has been reached, the {@link
+   *     C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. If a {@link
+   *     DecoderInputBuffer#isFlagsOnly() flags-only} buffer is passed, then no {@link
+   *     DecoderInputBuffer#data} will be read and the read position of the stream will not change,
+   *     but the flags of the buffer will be populated.
    * @param formatRequired Whether the caller requires that the format of the stream be read even if
    *     it's not changing. A sample will never be read if set to true, however it is still possible
    *     for the end of stream or nothing to be read.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 9e33a2d898..acdfbcc8c0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.util.Assertions;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 73d590951d..e0c2a00df3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -251,7 +251,7 @@ public LoadErrorAction onLoadError(
       int errorCount) {
     long retryDelay =
         loadErrorHandlingPolicy.getRetryDelayMsFor(
-            C.DATA_TYPE_MEDIA, durationUs, error, errorCount);
+            C.DATA_TYPE_MEDIA, loadDurationMs, error, errorCount);
     boolean errorCanBePropagated =
         retryDelay == C.TIME_UNSET
             || errorCount
@@ -326,8 +326,11 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         return C.RESULT_FORMAT_READ;
       } else if (loadingFinished) {
         if (loadingSucceeded) {
-          buffer.timeUs = 0;
           buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
+          buffer.timeUs = 0;
+          if (buffer.isFlagsOnly()) {
+            return C.RESULT_BUFFER_READ;
+          }
           buffer.ensureSpaceForWrite(sampleSize);
           buffer.data.put(sampleData, 0, sampleSize);
         } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 66097970c7..6f85a2b0f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -17,8 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -139,12 +138,12 @@ public Factory setTreatLoadErrorsAsEndOfStream(boolean treatLoadErrorsAsEndOfStr
     }
 
     /**
-     * Returns a new {@link ExtractorMediaSource} using the current parameters.
+     * Returns a new {@link SingleSampleMediaSource} using the current parameters.
      *
      * @param uri The {@link Uri}.
      * @param format The {@link Format} of the media stream.
      * @param durationUs The duration of the media stream in microseconds.
-     * @return The new {@link ExtractorMediaSource}.
+     * @return The new {@link SingleSampleMediaSource}.
      */
     public SingleSampleMediaSource createMediaSource(Uri uri, Format format, long durationUs) {
       isCreateCalled = true;
@@ -289,8 +288,7 @@ private SingleSampleMediaSource(
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
     this.tag = tag;
-    dataSpec =
-        new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+    dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP);
     timeline =
         new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false, tag);
   }
@@ -304,10 +302,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     transferListener = mediaTransferListener;
     refreshSourceInfo(timeline, /* manifest= */ null);
   }
@@ -318,7 +313,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     return new SingleSampleMediaPeriod(
         dataSpec,
         dataSourceFactory,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java b/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
index 56c9989f34..9e837bf05d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
@@ -17,7 +17,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java b/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
index a155032a9f..e737a5fafa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
@@ -17,7 +17,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.util.Arrays;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
index 41adb78906..be9dea91f1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.source.ads;
 
 import android.net.Uri;
-import android.support.annotation.CheckResult;
-import android.support.annotation.IntDef;
+import androidx.annotation.CheckResult;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.lang.annotation.Documented;
@@ -310,7 +310,9 @@ private AdPlaybackState(
    * unplayed. Returns {@link C#INDEX_UNSET} if the ad group at or before {@code positionUs} has no
    * ads remaining to be played, or if there is no such ad group.
    *
-   * @param positionUs The position at or before which to find an ad group, in microseconds.
+   * @param positionUs The position at or before which to find an ad group, in microseconds, or
+   *     {@link C#TIME_END_OF_SOURCE} for the end of the stream (in which case the index of any
+   *     unplayed postroll ad group will be returned).
    * @return The index of the ad group, or {@link C#INDEX_UNSET}.
    */
   public int getAdGroupIndexForPositionUs(long positionUs) {
@@ -327,10 +329,18 @@ public int getAdGroupIndexForPositionUs(long positionUs) {
    * Returns the index of the next ad group after {@code positionUs} that has ads remaining to be
    * played. Returns {@link C#INDEX_UNSET} if there is no such ad group.
    *
-   * @param positionUs The position after which to find an ad group, in microseconds.
+   * @param positionUs The position after which to find an ad group, in microseconds, or {@link
+   *     C#TIME_END_OF_SOURCE} for the end of the stream (in which case there can be no ad group
+   *     after the position).
+   * @param periodDurationUs The duration of the containing period in microseconds, or {@link
+   *     C#TIME_UNSET} if not known.
    * @return The index of the ad group, or {@link C#INDEX_UNSET}.
    */
-  public int getAdGroupIndexAfterPositionUs(long positionUs) {
+  public int getAdGroupIndexAfterPositionUs(long positionUs, long periodDurationUs) {
+    if (positionUs == C.TIME_END_OF_SOURCE
+        || (periodDurationUs != C.TIME_UNSET && positionUs >= periodDurationUs)) {
+      return C.INDEX_UNSET;
+    }
     // Use a linear search as the array elements may not be increasing due to TIME_END_OF_SOURCE.
     // In practice we expect there to be few ad groups so the search shouldn't be expensive.
     int index = 0;
@@ -457,6 +467,10 @@ public int hashCode() {
   }
 
   private boolean isPositionBeforeAdGroup(long positionUs, int adGroupIndex) {
+    if (positionUs == C.TIME_END_OF_SOURCE) {
+      // The end of the content is at (but not before) any postroll ad, and after any other ads.
+      return false;
+    }
     long adGroupPositionUs = adGroupTimesUs[adGroupIndex];
     if (adGroupPositionUs == C.TIME_END_OF_SOURCE) {
       return contentDurationUs == C.TIME_UNSET || positionUs < contentDurationUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
index f041542356..2b90fac6ab 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer2.source.ads;
 
+import androidx.annotation.Nullable;
+import android.view.View;
 import android.view.ViewGroup;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource.AdLoadException;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.IOException;
@@ -25,27 +27,25 @@
 /**
  * Interface for loaders of ads, which can be used with {@link AdsMediaSource}.
  *
- * <p>Ad loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
+ * <p>Ads loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
  * particular, implementations must call {@link EventListener#onAdPlaybackState(AdPlaybackState)}
  * with a new copy of the current {@link AdPlaybackState} whenever further information about ads
  * becomes known (for example, when an ad media URI is available, or an ad has played to the end).
  *
- * <p>{@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} will be called when the ads media
- * source first initializes, at which point the loader can request ads. If the player enters the
- * background, {@link #detachPlayer()} will be called. Loaders should maintain any ad playback state
- * in preparation for a later call to {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. If
- * an ad is playing when the player is detached, update the ad playback state with the current
- * playback position using {@link AdPlaybackState#withAdResumePositionUs(long)}.
+ * <p>{@link #start(EventListener, AdViewProvider)} will be called when the ads media source first
+ * initializes, at which point the loader can request ads. If the player enters the background,
+ * {@link #stop()} will be called. Loaders should maintain any ad playback state in preparation for
+ * a later call to {@link #start(EventListener, AdViewProvider)}. If an ad is playing when the
+ * player is detached, update the ad playback state with the current playback position using {@link
+ * AdPlaybackState#withAdResumePositionUs(long)}.
  *
  * <p>If {@link EventListener#onAdPlaybackState(AdPlaybackState)} has been called, the
- * implementation of {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} should invoke the
- * same listener to provide the existing playback state to the new player.
+ * implementation of {@link #start(EventListener, AdViewProvider)} should invoke the same listener
+ * to provide the existing playback state to the new player.
  */
 public interface AdsLoader {
 
-  /**
-   * Listener for ad loader events. All methods are called on the main thread.
-   */
+  /** Listener for ads loader events. All methods are called on the main thread. */
   interface EventListener {
 
     /**
@@ -53,7 +53,7 @@
      *
      * @param adPlaybackState The new ad playback state.
      */
-    void onAdPlaybackState(AdPlaybackState adPlaybackState);
+    default void onAdPlaybackState(AdPlaybackState adPlaybackState) {}
 
     /**
      * Called when there was an error loading ads.
@@ -61,23 +61,62 @@
      * @param error The error.
      * @param dataSpec The data spec associated with the load error.
      */
-    void onAdLoadError(AdLoadException error, DataSpec dataSpec);
+    default void onAdLoadError(AdLoadException error, DataSpec dataSpec) {}
 
-    /**
-     * Called when the user clicks through an ad (for example, following a 'learn more' link).
-     */
-    void onAdClicked();
+    /** Called when the user clicks through an ad (for example, following a 'learn more' link). */
+    default void onAdClicked() {}
+
+    /** Called when the user taps a non-clickthrough part of an ad. */
+    default void onAdTapped() {}
+  }
+
+  /** Provides views for the ad UI. */
+  interface AdViewProvider {
+
+    /** Returns the {@link ViewGroup} on top of the player that will show any ad UI. */
+    ViewGroup getAdViewGroup();
 
     /**
-     * Called when the user taps a non-clickthrough part of an ad.
+     * Returns an array of views that are shown on top of the ad view group, but that are essential
+     * for controlling playback and should be excluded from ad viewability measurements by the
+     * {@link AdsLoader} (if it supports this).
+     *
+     * <p>Each view must be either a fully transparent overlay (for capturing touch events), or a
+     * small piece of transient UI that is essential to the user experience of playback (such as a
+     * button to pause/resume playback or a transient full-screen or cast button). For more
+     * information see the documentation for your ads loader.
      */
-    void onAdTapped();
-
+    View[] getAdOverlayViews();
   }
 
+  // Methods called by the application.
+
+  /**
+   * Sets the player that will play the loaded ads.
+   *
+   * <p>This method must be called before the player is prepared with media using this ads loader.
+   *
+   * <p>This method must also be called on the main thread and only players which are accessed on
+   * the main thread are supported ({@code player.getApplicationLooper() ==
+   * Looper.getMainLooper()}).
+   *
+   * @param player The player instance that will play the loaded ads. May be null to delete the
+   *     reference to a previously set player.
+   */
+  void setPlayer(@Nullable Player player);
+
   /**
-   * Sets the supported content types for ad media. Must be called before the first call to
-   * {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. Subsequent calls may be ignored.
+   * Releases the loader. Must be called by the application on the main thread when the instance is
+   * no longer needed.
+   */
+  void release();
+
+  // Methods called by AdsMediaSource.
+
+  /**
+   * Sets the supported content types for ad media. Must be called before the first call to {@link
+   * #start(EventListener, AdViewProvider)}. Subsequent calls may be ignored. Called on the main
+   * thread by {@link AdsMediaSource}.
    *
    * @param contentTypes The supported content types for ad media. Each element must be one of
    *     {@link C#TYPE_DASH}, {@link C#TYPE_HLS}, {@link C#TYPE_SS} and {@link C#TYPE_OTHER}.
@@ -85,32 +124,23 @@
   void setSupportedContentTypes(@C.ContentType int... contentTypes);
 
   /**
-   * Attaches a player that will play ads loaded using this instance. Called on the main thread by
-   * {@link AdsMediaSource}.
+   * Starts using the ads loader for playback. Called on the main thread by {@link AdsMediaSource}.
    *
-   * @param player The player instance that will play the loaded ads. Only players which are
-   *     accessed on the main thread are supported ({@code player.getApplicationLooper() ==
-   *     Looper.getMainLooper()}).
    * @param eventListener Listener for ads loader events.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   */
-  void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup);
-
-  /**
-   * Detaches the attached player and event listener. Called on the main thread by
-   * {@link AdsMediaSource}.
+   * @param adViewProvider Provider of views for the ad UI.
    */
-  void detachPlayer();
+  void start(EventListener eventListener, AdViewProvider adViewProvider);
 
   /**
-   * Releases the loader. Called by the application on the main thread when the instance is no
-   * longer needed.
+   * Stops using the ads loader for playback and deregisters the event listener. Called on the main
+   * thread by {@link AdsMediaSource}.
    */
-  void release();
+  void stop();
 
   /**
    * Notifies the ads loader that the player was not able to prepare media for a given ad.
    * Implementations should update the ad playback state as the specified ad has failed to load.
+   * Called on the main thread by {@link AdsMediaSource}.
    *
    * @param adGroupIndex The index of the ad group.
    * @param adIndexInAdGroup The index of the ad in the ad group.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
index 19ddbd2c54..1998977961 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -18,21 +18,19 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import android.view.ViewGroup;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.CompositeMediaSource;
 import com.google.android.exoplayer2.source.DeferredMediaPeriod;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.MediaSourceEventListener;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.LoadEventInfo;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.MediaLoadData;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -140,46 +138,6 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
     }
   }
 
-  /**
-   * Listener for ads media source events.
-   *
-   * @deprecated To listen for ad load error events, add a listener via {@link
-   *     #addEventListener(Handler, MediaSourceEventListener)} and check for {@link
-   *     AdLoadException}s in {@link MediaSourceEventListener#onLoadError(int, MediaPeriodId,
-   *     LoadEventInfo, MediaLoadData, IOException, boolean)}. Individual ads loader implementations
-   *     should expose ad interaction events, if applicable.
-   */
-  @Deprecated
-  public interface EventListener {
-
-    /**
-     * Called if there was an error loading one or more ads. The loader will skip the problematic
-     * ad(s).
-     *
-     * @param error The error.
-     */
-    void onAdLoadError(IOException error);
-
-    /**
-     * Called when an unexpected internal error is encountered while loading ads. The loader will
-     * skip all remaining ads, as the error is not recoverable.
-     *
-     * @param error The error.
-     */
-    void onInternalAdLoadError(RuntimeException error);
-
-    /**
-     * Called when the user clicks through an ad (for example, following a 'learn more' link).
-     */
-    void onAdClicked();
-
-    /**
-     * Called when the user taps a non-clickthrough part of an ad.
-     */
-    void onAdTapped();
-
-  }
-
   // Used to identify the content "child" source for CompositeMediaSource.
   private static final MediaPeriodId DUMMY_CONTENT_MEDIA_PERIOD_ID =
       new MediaPeriodId(/* periodUid= */ new Object());
@@ -187,9 +145,7 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
   private final MediaSource contentMediaSource;
   private final MediaSourceFactory adMediaSourceFactory;
   private final AdsLoader adsLoader;
-  private final ViewGroup adUiViewGroup;
-  @Nullable private final Handler eventHandler;
-  @Nullable private final EventListener eventListener;
+  private final AdsLoader.AdViewProvider adViewProvider;
   private final Handler mainHandler;
   private final Map<MediaSource, List<DeferredMediaPeriod>> deferredMediaPeriodByAdMediaSource;
   private final Timeline.Period period;
@@ -204,25 +160,23 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
 
   /**
    * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}. Ad media is loaded using {@link ExtractorMediaSource}.
+   * contentMediaSource}. Ad media is loaded using {@link ProgressiveMediaSource}.
    *
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param dataSourceFactory Factory for data sources used to load ad media.
    * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param adViewProvider Provider of views for the ad UI.
    */
   public AdsMediaSource(
       MediaSource contentMediaSource,
       DataSource.Factory dataSourceFactory,
       AdsLoader adsLoader,
-      ViewGroup adUiViewGroup) {
+      AdsLoader.AdViewProvider adViewProvider) {
     this(
         contentMediaSource,
-        new ExtractorMediaSource.Factory(dataSourceFactory),
+        new ProgressiveMediaSource.Factory(dataSourceFactory),
         adsLoader,
-        adUiViewGroup,
-        /* eventHandler= */ null,
-        /* eventListener= */ null);
+        adViewProvider);
   }
 
   /**
@@ -232,85 +186,17 @@ public AdsMediaSource(
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param adMediaSourceFactory Factory for media sources used to load ad media.
    * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param adViewProvider Provider of views for the ad UI.
    */
   public AdsMediaSource(
       MediaSource contentMediaSource,
       MediaSourceFactory adMediaSourceFactory,
       AdsLoader adsLoader,
-      ViewGroup adUiViewGroup) {
-    this(
-        contentMediaSource,
-        adMediaSourceFactory,
-        adsLoader,
-        adUiViewGroup,
-        /* eventHandler= */ null,
-        /* eventListener= */ null);
-  }
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}. Ad media is loaded using {@link ExtractorMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param dataSourceFactory Factory for data sources used to load ad media.
-   * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @deprecated To listen for ad load error events, add a listener via {@link
-   *     #addEventListener(Handler, MediaSourceEventListener)} and check for {@link
-   *     AdLoadException}s in {@link MediaSourceEventListener#onLoadError(int, MediaPeriodId,
-   *     LoadEventInfo, MediaLoadData, IOException, boolean)}. Individual ads loader implementations
-   *     should expose ad interaction events, if applicable.
-   */
-  @Deprecated
-  public AdsMediaSource(
-      MediaSource contentMediaSource,
-      DataSource.Factory dataSourceFactory,
-      AdsLoader adsLoader,
-      ViewGroup adUiViewGroup,
-      @Nullable Handler eventHandler,
-      @Nullable EventListener eventListener) {
-    this(
-        contentMediaSource,
-        new ExtractorMediaSource.Factory(dataSourceFactory),
-        adsLoader,
-        adUiViewGroup,
-        eventHandler,
-        eventListener);
-  }
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param adMediaSourceFactory Factory for media sources used to load ad media.
-   * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @deprecated To listen for ad load error events, add a listener via {@link
-   *     #addEventListener(Handler, MediaSourceEventListener)} and check for {@link
-   *     AdLoadException}s in {@link MediaSourceEventListener#onLoadError(int, MediaPeriodId,
-   *     LoadEventInfo, MediaLoadData, IOException, boolean)}. Individual ads loader implementations
-   *     should expose ad interaction events, if applicable.
-   */
-  @Deprecated
-  public AdsMediaSource(
-      MediaSource contentMediaSource,
-      MediaSourceFactory adMediaSourceFactory,
-      AdsLoader adsLoader,
-      ViewGroup adUiViewGroup,
-      @Nullable Handler eventHandler,
-      @Nullable EventListener eventListener) {
+      AdsLoader.AdViewProvider adViewProvider) {
     this.contentMediaSource = contentMediaSource;
     this.adMediaSourceFactory = adMediaSourceFactory;
     this.adsLoader = adsLoader;
-    this.adUiViewGroup = adUiViewGroup;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
+    this.adViewProvider = adViewProvider;
     mainHandler = new Handler(Looper.getMainLooper());
     deferredMediaPeriodByAdMediaSource = new HashMap<>();
     period = new Timeline.Period();
@@ -326,22 +212,16 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      final ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
-    Assertions.checkArgument(
-        isTopLevelSource,
-        "AdsMediaSource must be the top-level source used to prepare the player.");
-    final ComponentListener componentListener = new ComponentListener();
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
+    ComponentListener componentListener = new ComponentListener();
     this.componentListener = componentListener;
     prepareChildSource(DUMMY_CONTENT_MEDIA_PERIOD_ID, contentMediaSource);
-    mainHandler.post(() -> adsLoader.attachPlayer(player, componentListener, adUiViewGroup));
+    mainHandler.post(() -> adsLoader.start(componentListener, adViewProvider));
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     if (adPlaybackState.adGroupCount > 0 && id.isAd()) {
       int adGroupIndex = id.adGroupIndex;
       int adIndexInAdGroup = id.adIndexInAdGroup;
@@ -360,7 +240,8 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
         prepareChildSource(id, adMediaSource);
       }
       MediaSource mediaSource = adGroupMediaSources[adGroupIndex][adIndexInAdGroup];
-      DeferredMediaPeriod deferredMediaPeriod = new DeferredMediaPeriod(mediaSource, id, allocator);
+      DeferredMediaPeriod deferredMediaPeriod =
+          new DeferredMediaPeriod(mediaSource, id, allocator, startPositionUs);
       deferredMediaPeriod.setPrepareErrorListener(
           new AdPrepareErrorListener(adUri, adGroupIndex, adIndexInAdGroup));
       List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.get(mediaSource);
@@ -376,7 +257,8 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
       }
       return deferredMediaPeriod;
     } else {
-      DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(contentMediaSource, id, allocator);
+      DeferredMediaPeriod mediaPeriod =
+          new DeferredMediaPeriod(contentMediaSource, id, allocator, startPositionUs);
       mediaPeriod.createPeriod(id);
       return mediaPeriod;
     }
@@ -404,7 +286,7 @@ public void releaseSourceInternal() {
     adPlaybackState = null;
     adGroupMediaSources = new MediaSource[0][];
     adGroupTimelines = new Timeline[0][];
-    mainHandler.post(adsLoader::detachPlayer);
+    mainHandler.post(adsLoader::stop);
   }
 
   @Override
@@ -444,6 +326,7 @@ private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
   }
 
   private void onContentSourceInfoRefreshed(Timeline timeline, Object manifest) {
+    Assertions.checkArgument(timeline.getPeriodCount() == 1);
     contentTimeline = timeline;
     contentManifest = manifest;
     maybeUpdateSourceInfo();
@@ -526,36 +409,6 @@ public void onAdPlaybackState(final AdPlaybackState adPlaybackState) {
           });
     }
 
-    @Override
-    public void onAdClicked() {
-      if (released) {
-        return;
-      }
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(
-            () -> {
-              if (!released) {
-                eventListener.onAdClicked();
-              }
-            });
-      }
-    }
-
-    @Override
-    public void onAdTapped() {
-      if (released) {
-        return;
-      }
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(
-            () -> {
-              if (!released) {
-                eventListener.onAdTapped();
-              }
-            });
-      }
-    }
-
     @Override
     public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
       if (released) {
@@ -572,18 +425,6 @@ public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
               /* bytesLoaded= */ 0,
               error,
               /* wasCanceled= */ true);
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(
-            () -> {
-              if (!released) {
-                if (error.type == AdLoadException.TYPE_UNEXPECTED) {
-                  eventListener.onInternalAdLoadError(error.getRuntimeExceptionForUnexpected());
-                } else {
-                  eventListener.onAdLoadError(error);
-                }
-              }
-            });
-      }
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
index 0594a635a5..25a1440c80 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.ads;
 
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ForwardingTimeline;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java
index 68dd322449..274be54889 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkIterator.java
@@ -31,13 +31,14 @@
   /**
    * Creates base iterator.
    *
-   * @param fromIndex The index at which the iterator will start.
+   * @param fromIndex The first available index.
    * @param toIndex The last available index.
    */
+  @SuppressWarnings("method.invocation.invalid")
   public BaseMediaChunkIterator(long fromIndex, long toIndex) {
     this.fromIndex = fromIndex;
     this.toIndex = toIndex;
-    currentIndex = fromIndex - 1;
+    reset();
   }
 
   @Override
@@ -51,19 +52,24 @@ public boolean next() {
     return !isEnded();
   }
 
+  @Override
+  public void reset() {
+    currentIndex = fromIndex - 1;
+  }
+
   /**
    * Verifies that the iterator points to a valid element.
    *
    * @throws NoSuchElementException If the iterator does not point to a valid element.
    */
-  protected void checkInBounds() {
+  protected final void checkInBounds() {
     if (currentIndex < fromIndex || currentIndex > toIndex) {
       throw new NoSuchElementException();
     }
   }
 
   /** Returns the current index this iterator is pointing to. */
-  protected long getCurrentIndex() {
+  protected final long getCurrentIndex() {
     return currentIndex;
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java
index 91c3afec80..2e7581eba5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/Chunk.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.chunk;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.upstream.DataSource;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index a8676b5a05..fc07a318b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 9fac69b281..18eada4708 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
index 10b823d444..ba7c0d0d5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
@@ -121,7 +121,7 @@ public final void load() throws IOException, InterruptedException {
         BaseMediaChunkOutput output = getOutput();
         output.setSampleOffsetUs(sampleOffsetUs);
         extractorWrapper.init(
-            output,
+            getTrackOutputProvider(output),
             clippedStartTimeUs == C.TIME_UNSET
                 ? C.TIME_UNSET
                 : (clippedStartTimeUs - sampleOffsetUs),
@@ -144,4 +144,17 @@ public final void load() throws IOException, InterruptedException {
     loadCompleted = true;
   }
 
+  /**
+   * Returns the {@link ChunkExtractorWrapper.TrackOutputProvider} to be used by the wrapped
+   * extractor.
+   *
+   * @param baseMediaChunkOutput The {@link BaseMediaChunkOutput} most recently passed to {@link
+   *     #init(BaseMediaChunkOutput)}.
+   * @return A {@link ChunkExtractorWrapper.TrackOutputProvider} to be used by the wrapped
+   *     extractor.
+   */
+  protected ChunkExtractorWrapper.TrackOutputProvider getTrackOutputProvider(
+      BaseMediaChunkOutput baseMediaChunkOutput) {
+    return baseMediaChunkOutput;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
index eecf471b24..37c70d5498 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java
index 71d8940e26..59ecc03d7a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkIterator.java
@@ -55,6 +55,11 @@ public long getChunkStartTimeUs() {
         public long getChunkEndTimeUs() {
           throw new NoSuchElementException();
         }
+
+        @Override
+        public void reset() {
+          // Do nothing.
+        }
       };
 
   /** Returns whether the iteration has reached the end of the available data. */
@@ -93,4 +98,7 @@ public long getChunkEndTimeUs() {
    *     {@link #next()} or when {@link #isEnded()} is true.
    */
   long getChunkEndTimeUs();
+
+  /** Resets the iterator to the initial position. */
+  void reset();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkListIterator.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkListIterator.java
new file mode 100644
index 0000000000..ca64e1affd
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunkListIterator.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.chunk;
+
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.util.List;
+
+/** A {@link MediaChunkIterator} which iterates over a {@link List} of {@link MediaChunk}s. */
+public final class MediaChunkListIterator extends BaseMediaChunkIterator {
+
+  private final List<? extends MediaChunk> chunks;
+  private final boolean reverseOrder;
+
+  /**
+   * Creates iterator.
+   *
+   * @param chunks The list of chunks to iterate over.
+   * @param reverseOrder Whether to iterate in reverse order.
+   */
+  public MediaChunkListIterator(List<? extends MediaChunk> chunks, boolean reverseOrder) {
+    super(0, chunks.size() - 1);
+    this.chunks = chunks;
+    this.reverseOrder = reverseOrder;
+  }
+
+  @Override
+  public DataSpec getDataSpec() {
+    return getCurrentChunk().dataSpec;
+  }
+
+  @Override
+  public long getChunkStartTimeUs() {
+    return getCurrentChunk().startTimeUs;
+  }
+
+  @Override
+  public long getChunkEndTimeUs() {
+    return getCurrentChunk().endTimeUs;
+  }
+
+  private MediaChunk getCurrentChunk() {
+    int index = (int) super.getCurrentIndex();
+    if (reverseOrder) {
+      index = chunks.size() - 1 - index;
+    }
+    return chunks.get(index);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java b/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
index e7bb0e16bf..b863d80c9a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
@@ -18,7 +18,7 @@
 import android.annotation.TargetApi;
 import android.graphics.Color;
 import android.graphics.Typeface;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.view.accessibility.CaptioningManager;
 import android.view.accessibility.CaptioningManager.CaptionStyle;
 import com.google.android.exoplayer2.util.Util;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
index a5c666c44a..4b54b3ea9a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -17,7 +17,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Color;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java
index 5a08db94cb..aa3b4e5557 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java
@@ -25,8 +25,7 @@
   /**
    * Called when there is a change in the {@link Cue}s.
    *
-   * @param cues The {@link Cue}s.
+   * @param cues The {@link Cue}s. May be empty.
    */
   void onCues(List<Cue> cues);
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index 16f82a7293..55bee5bd6a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -19,8 +19,8 @@
 import android.os.Handler.Callback;
 import android.os.Looper;
 import android.os.Message;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 3c39fdc6c1..9316e4fb86 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -25,11 +25,11 @@
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleInputBuffer;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
@@ -41,13 +41,16 @@
  */
 public final class Cea608Decoder extends CeaDecoder {
 
+  private static final String TAG = "Cea608Decoder";
+
   private static final int CC_VALID_FLAG = 0x04;
   private static final int CC_TYPE_FLAG = 0x02;
   private static final int CC_FIELD_FLAG = 0x01;
 
   private static final int NTSC_CC_FIELD_1 = 0x00;
   private static final int NTSC_CC_FIELD_2 = 0x01;
-  private static final int CC_VALID_608_ID = 0x04;
+  private static final int NTSC_CC_CHANNEL_1 = 0x00;
+  private static final int NTSC_CC_CHANNEL_2 = 0x01;
 
   private static final int CC_MODE_UNKNOWN = 0;
   private static final int CC_MODE_ROLL_UP = 1;
@@ -180,9 +183,45 @@
     0xC5, 0xE5, 0xD8, 0xF8, 0x250C, 0x2510, 0x2514, 0x2518
   };
 
+  private static final boolean[] ODD_PARITY_BYTE_TABLE = {
+    false, true, true, false, true, false, false, true, // 0
+    true, false, false, true, false, true, true, false, // 8
+    true, false, false, true, false, true, true, false, // 16
+    false, true, true, false, true, false, false, true, // 24
+    true, false, false, true, false, true, true, false, // 32
+    false, true, true, false, true, false, false, true, // 40
+    false, true, true, false, true, false, false, true, // 48
+    true, false, false, true, false, true, true, false, // 56
+    true, false, false, true, false, true, true, false, // 64
+    false, true, true, false, true, false, false, true, // 72
+    false, true, true, false, true, false, false, true, // 80
+    true, false, false, true, false, true, true, false, // 88
+    false, true, true, false, true, false, false, true, // 96
+    true, false, false, true, false, true, true, false, // 104
+    true, false, false, true, false, true, true, false, // 112
+    false, true, true, false, true, false, false, true, // 120
+    true, false, false, true, false, true, true, false, // 128
+    false, true, true, false, true, false, false, true, // 136
+    false, true, true, false, true, false, false, true, // 144
+    true, false, false, true, false, true, true, false, // 152
+    false, true, true, false, true, false, false, true, // 160
+    true, false, false, true, false, true, true, false, // 168
+    true, false, false, true, false, true, true, false, // 176
+    false, true, true, false, true, false, false, true, // 184
+    false, true, true, false, true, false, false, true, // 192
+    true, false, false, true, false, true, true, false, // 200
+    true, false, false, true, false, true, true, false, // 208
+    false, true, true, false, true, false, false, true, // 216
+    true, false, false, true, false, true, true, false, // 224
+    false, true, true, false, true, false, false, true, // 232
+    false, true, true, false, true, false, false, true, // 240
+    true, false, false, true, false, true, true, false, // 248
+  };
+
   private final ParsableByteArray ccData;
   private final int packetLength;
   private final int selectedField;
+  private final int selectedChannel;
   private final ArrayList<CueBuilder> cueBuilders;
 
   private CueBuilder currentCueBuilder;
@@ -192,25 +231,39 @@
   private int captionMode;
   private int captionRowCount;
 
+  private boolean captionValid;
   private boolean repeatableControlSet;
   private byte repeatableControlCc1;
   private byte repeatableControlCc2;
+  private int currentChannel;
 
   public Cea608Decoder(String mimeType, int accessibilityChannel) {
     ccData = new ParsableByteArray();
     cueBuilders = new ArrayList<>();
     currentCueBuilder = new CueBuilder(CC_MODE_UNKNOWN, DEFAULT_CAPTIONS_ROW_COUNT);
+    currentChannel = NTSC_CC_CHANNEL_1;
     packetLength = MimeTypes.APPLICATION_MP4CEA608.equals(mimeType) ? 2 : 3;
     switch (accessibilityChannel) {
+      case 1:
+        selectedChannel = NTSC_CC_CHANNEL_1;
+        selectedField = NTSC_CC_FIELD_1;
+        break;
+      case 2:
+        selectedChannel = NTSC_CC_CHANNEL_2;
+        selectedField = NTSC_CC_FIELD_1;
+        break;
       case 3:
+        selectedChannel = NTSC_CC_CHANNEL_1;
+        selectedField = NTSC_CC_FIELD_2;
+        break;
       case 4:
-        selectedField = 2;
+        selectedChannel = NTSC_CC_CHANNEL_2;
+        selectedField = NTSC_CC_FIELD_2;
         break;
-      case 1:
-      case 2:
-      case Format.NO_VALUE:
       default:
-        selectedField = 1;
+        Log.w(TAG, "Invalid channel. Defaulting to CC1.");
+        selectedChannel = NTSC_CC_CHANNEL_1;
+        selectedField = NTSC_CC_FIELD_1;
     }
 
     setCaptionMode(CC_MODE_UNKNOWN);
@@ -230,9 +283,11 @@ public void flush() {
     setCaptionMode(CC_MODE_UNKNOWN);
     setCaptionRowCount(DEFAULT_CAPTIONS_ROW_COUNT);
     resetCueBuilders();
+    captionValid = false;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
+    currentChannel = NTSC_CC_CHANNEL_1;
   }
 
   @Override
@@ -256,41 +311,65 @@ protected Subtitle createSubtitle() {
   protected void decode(SubtitleInputBuffer inputBuffer) {
     ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
     boolean captionDataProcessed = false;
-    boolean isRepeatableControl = false;
     while (ccData.bytesLeft() >= packetLength) {
-      byte ccDataHeader = packetLength == 2 ? CC_IMPLICIT_DATA_HEADER
+      byte ccHeader = packetLength == 2 ? CC_IMPLICIT_DATA_HEADER
           : (byte) ccData.readUnsignedByte();
-      byte ccData1 = (byte) (ccData.readUnsignedByte() & 0x7F); // strip the parity bit
-      byte ccData2 = (byte) (ccData.readUnsignedByte() & 0x7F); // strip the parity bit
+      int ccByte1 = ccData.readUnsignedByte();
+      int ccByte2 = ccData.readUnsignedByte();
 
-      // Only examine valid CEA-608 packets
       // TODO: We're currently ignoring the top 5 marker bits, which should all be 1s according
       // to the CEA-608 specification. We need to determine if the data should be handled
       // differently when that is not the case.
-      if ((ccDataHeader & (CC_VALID_FLAG | CC_TYPE_FLAG)) != CC_VALID_608_ID) {
+
+      if ((ccHeader & CC_TYPE_FLAG) != 0) {
+        // Do not process anything that is not part of the 608 byte stream.
         continue;
       }
 
-      // Only examine packets within the selected field
-      if ((selectedField == 1 && (ccDataHeader & CC_FIELD_FLAG) != NTSC_CC_FIELD_1)
-          || (selectedField == 2 && (ccDataHeader & CC_FIELD_FLAG) != NTSC_CC_FIELD_2)) {
+      if ((ccHeader & CC_FIELD_FLAG) != selectedField) {
+        // Do not process packets not within the selected field.
         continue;
       }
 
-      // Ignore empty captions.
+      // Strip the parity bit from each byte to get CC data.
+      byte ccData1 = (byte) (ccByte1 & 0x7F);
+      byte ccData2 = (byte) (ccByte2 & 0x7F);
+
       if (ccData1 == 0 && ccData2 == 0) {
+        // Ignore empty captions.
+        continue;
+      }
+
+      boolean repeatedControlPossible = repeatableControlSet;
+      repeatableControlSet = false;
+
+      boolean previousCaptionValid = captionValid;
+      captionValid = (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG;
+      if (!captionValid) {
+        if (previousCaptionValid) {
+          // The encoder has flipped the validity bit to indicate captions are being turned off.
+          resetCueBuilders();
+          captionDataProcessed = true;
+        }
         continue;
       }
 
       // If we've reached this point then there is data to process; flag that work has been done.
       captionDataProcessed = true;
 
+      if (!ODD_PARITY_BYTE_TABLE[ccByte1] || !ODD_PARITY_BYTE_TABLE[ccByte2]) {
+        // The data is invalid.
+        resetCueBuilders();
+        continue;
+      }
+
       // Special North American character set.
       // ccData1 - 0|0|0|1|C|0|0|1
       // ccData2 - 0|0|1|1|X|X|X|X
       if (((ccData1 & 0xF7) == 0x11) && ((ccData2 & 0xF0) == 0x30)) {
-        // TODO: Make use of the channel toggle
-        currentCueBuilder.append(getSpecialChar(ccData2));
+        if (getChannel(ccData1) == selectedChannel) {
+          currentCueBuilder.append(getSpecialChar(ccData2));
+        }
         continue;
       }
 
@@ -298,15 +377,16 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
       // ccData1 - 0|0|0|1|C|0|1|S
       // ccData2 - 0|0|1|X|X|X|X|X
       if (((ccData1 & 0xF6) == 0x12) && (ccData2 & 0xE0) == 0x20) {
-        // TODO: Make use of the channel toggle
-        // Remove standard equivalent of the special extended char before appending new one
-        currentCueBuilder.backspace();
-        if ((ccData1 & 0x01) == 0x00) {
-          // Extended Spanish/Miscellaneous and French character set (S = 0).
-          currentCueBuilder.append(getExtendedEsFrChar(ccData2));
-        } else {
-          // Extended Portuguese and German/Danish character set (S = 1).
-          currentCueBuilder.append(getExtendedPtDeChar(ccData2));
+        if (getChannel(ccData1) == selectedChannel) {
+          // Remove standard equivalent of the special extended char before appending new one
+          currentCueBuilder.backspace();
+          if ((ccData1 & 0x01) == 0x00) {
+            // Extended Spanish/Miscellaneous and French character set (S = 0).
+            currentCueBuilder.append(getExtendedEsFrChar(ccData2));
+          } else {
+            // Extended Portuguese and German/Danish character set (S = 1).
+            currentCueBuilder.append(getExtendedPtDeChar(ccData2));
+          }
         }
         continue;
       }
@@ -314,7 +394,11 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
       // Control character.
       // ccData1 - 0|0|0|X|X|X|X|X
       if ((ccData1 & 0xE0) == 0x00) {
-        isRepeatableControl = handleCtrl(ccData1, ccData2);
+        handleCtrl(ccData1, ccData2, repeatedControlPossible);
+        continue;
+      }
+
+      if (currentChannel != selectedChannel) {
         continue;
       }
 
@@ -326,49 +410,44 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
     }
 
     if (captionDataProcessed) {
-      if (!isRepeatableControl) {
-        repeatableControlSet = false;
-      }
       if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
         cues = getDisplayCues();
       }
     }
   }
 
-  private boolean handleCtrl(byte cc1, byte cc2) {
-    boolean isRepeatableControl = isRepeatable(cc1);
-
-    // Most control commands are sent twice in succession to ensure they are received properly.
-    // We don't want to process duplicate commands, so if we see the same repeatable command twice
-    // in a row, ignore the second one.
-    if (isRepeatableControl) {
-      if (repeatableControlSet
-          && repeatableControlCc1 == cc1
-          && repeatableControlCc2 == cc2) {
-        // This is a duplicate. Clear the repeatable control flag and return.
-        repeatableControlSet = false;
-        return true;
+  private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
+    currentChannel = getChannel(cc1);
+    // Most control commands are sent twice in succession to ensure they are received properly. We
+    // don't want to process duplicate commands, so if we see the same repeatable command twice in a
+    // row then we ignore the second one.
+    if (isRepeatable(cc1)) {
+      if (repeatedControlPossible && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
+        // This is a repeated command, so we ignore it.
+        return;
       } else {
-        // This is a repeatable command, but we haven't see it yet, so set the repeatable control
-        // flag (to ensure we ignore the next one should it be a duplicate) and continue processing
-        // the command.
+        // This is the first occurrence of a repeatable command. Set the repeatable control
+        // variables so that we can recognize and ignore a duplicate (if there is one), and then
+        // continue to process the command below.
         repeatableControlSet = true;
         repeatableControlCc1 = cc1;
         repeatableControlCc2 = cc2;
       }
     }
 
+    if (currentChannel != selectedChannel) {
+      return;
+    }
+
     if (isMidrowCtrlCode(cc1, cc2)) {
       handleMidrowCtrl(cc2);
     } else if (isPreambleAddressCode(cc1, cc2)) {
       handlePreambleAddressCode(cc1, cc2);
     } else if (isTabCtrlCode(cc1, cc2)) {
-      currentCueBuilder.setTab(cc2 - 0x20);
+      currentCueBuilder.tabOffset = cc2 - 0x20;
     } else if (isMiscCode(cc1, cc2)) {
       handleMiscCode(cc2);
     }
-
-    return isRepeatableControl;
   }
 
   private void handleMidrowCtrl(byte cc2) {
@@ -387,7 +466,6 @@ private void handlePreambleAddressCode(byte cc1, byte cc2) {
     // cc1 - 0|0|0|1|C|E|ROW
     // C is the channel toggle, E is the extended flag, and ROW is the encoded row
     int row = ROW_INDICES[cc1 & 0x07];
-    // TODO: Make use of the channel toggle
     // TODO: support the extended address and style
 
     // cc2 - 0|1|N|ATTRBTE|U
@@ -398,12 +476,12 @@ private void handlePreambleAddressCode(byte cc1, byte cc2) {
       row++;
     }
 
-    if (row != currentCueBuilder.getRow()) {
+    if (row != currentCueBuilder.row) {
       if (captionMode != CC_MODE_ROLL_UP && !currentCueBuilder.isEmpty()) {
         currentCueBuilder = new CueBuilder(captionMode, captionRowCount);
         cueBuilders.add(currentCueBuilder);
       }
-      currentCueBuilder.setRow(row);
+      currentCueBuilder.row = row;
     }
 
     // cc2 - 0|1|N|0|STYLE|U
@@ -417,7 +495,7 @@ private void handlePreambleAddressCode(byte cc1, byte cc2) {
     currentCueBuilder.setStyle(isCursor ? STYLE_UNCHANGED : cursorOrStyle, underline);
 
     if (isCursor) {
-      currentCueBuilder.setIndent(COLUMN_INDICES[cursorOrStyle]);
+      currentCueBuilder.indent = COLUMN_INDICES[cursorOrStyle];
     }
   }
 
@@ -484,13 +562,34 @@ private void handleMiscCode(byte cc2) {
   }
 
   private List<Cue> getDisplayCues() {
-    List<Cue> displayCues = new ArrayList<>();
-    for (int i = 0; i < cueBuilders.size(); i++) {
-      Cue cue = cueBuilders.get(i).build();
+    // CEA-608 does not define middle and end alignment, however content providers artificially
+    // introduce them using whitespace. When each cue is built, we try and infer the alignment based
+    // on the amount of whitespace either side of the text. To avoid consecutive cues being aligned
+    // differently, we force all cues to have the same alignment, with start alignment given
+    // preference, then middle alignment, then end alignment.
+    @Cue.AnchorType int positionAnchor = Cue.ANCHOR_TYPE_END;
+    int cueBuilderCount = cueBuilders.size();
+    List<Cue> cueBuilderCues = new ArrayList<>(cueBuilderCount);
+    for (int i = 0; i < cueBuilderCount; i++) {
+      Cue cue = cueBuilders.get(i).build(/* forcedPositionAnchor= */ Cue.TYPE_UNSET);
+      cueBuilderCues.add(cue);
+      if (cue != null) {
+        positionAnchor = Math.min(positionAnchor, cue.positionAnchor);
+      }
+    }
+
+    // Skip null cues and rebuild any that don't have the preferred alignment.
+    List<Cue> displayCues = new ArrayList<>(cueBuilderCount);
+    for (int i = 0; i < cueBuilderCount; i++) {
+      Cue cue = cueBuilderCues.get(i);
       if (cue != null) {
+        if (cue.positionAnchor != positionAnchor) {
+          cue = cueBuilders.get(i).build(positionAnchor);
+        }
         displayCues.add(cue);
       }
     }
+
     return displayCues;
   }
 
@@ -502,6 +601,14 @@ private void setCaptionMode(int captionMode) {
     int oldCaptionMode = this.captionMode;
     this.captionMode = captionMode;
 
+    if (captionMode == CC_MODE_PAINT_ON) {
+      // Switching to paint-on mode should have no effect except to select the mode.
+      for (int i = 0; i < cueBuilders.size(); i++) {
+        cueBuilders.get(i).setCaptionMode(captionMode);
+      }
+      return;
+    }
+
     // Clear the working memory.
     resetCueBuilders();
     if (oldCaptionMode == CC_MODE_PAINT_ON || captionMode == CC_MODE_ROLL_UP
@@ -542,6 +649,11 @@ private static char getExtendedPtDeChar(byte ccData) {
     return (char) SPECIAL_PT_DE_CHARACTER_SET[index];
   }
 
+  private static int getChannel(byte cc1) {
+    // cc1 - X|X|X|X|C|X|X|X
+    return (cc1 >> 3) & 0x1;
+  }
+
   private static boolean isMidrowCtrlCode(byte cc1, byte cc2) {
     // cc1 - 0|0|0|1|C|0|0|1
     // cc2 - 0|0|1|0|X|X|X|X
@@ -561,9 +673,9 @@ private static boolean isTabCtrlCode(byte cc1, byte cc2) {
   }
 
   private static boolean isMiscCode(byte cc1, byte cc2) {
-    // cc1 - 0|0|0|1|C|1|0|0
+    // cc1 - 0|0|0|1|C|1|0|F
     // cc2 - 0|0|1|0|X|X|X|X
-    return ((cc1 & 0xF7) == 0x14) && ((cc2 & 0xF0) == 0x20);
+    return ((cc1 & 0xF6) == 0x14) && ((cc2 & 0xF0) == 0x20);
   }
 
   private static boolean isRepeatable(byte cc1) {
@@ -606,16 +718,24 @@ public void reset(int captionMode) {
       tabOffset = 0;
     }
 
-    public void setCaptionRowCount(int captionRowCount) {
-      this.captionRowCount = captionRowCount;
-    }
-
     public boolean isEmpty() {
       return cueStyles.isEmpty()
           && rolledUpCaptions.isEmpty()
           && captionStringBuilder.length() == 0;
     }
 
+    public void setCaptionMode(int captionMode) {
+      this.captionMode = captionMode;
+    }
+
+    public void setCaptionRowCount(int captionRowCount) {
+      this.captionRowCount = captionRowCount;
+    }
+
+    public void setStyle(int style, boolean underline) {
+      cueStyles.add(new CueStyle(style, underline, captionStringBuilder.length()));
+    }
+
     public void backspace() {
       int length = captionStringBuilder.length();
       if (length > 0) {
@@ -633,16 +753,12 @@ public void backspace() {
       }
     }
 
-    public int getRow() {
-      return row;
-    }
-
-    public void setRow(int row) {
-      this.row = row;
+    public void append(char text) {
+      captionStringBuilder.append(text);
     }
 
     public void rollUp() {
-      rolledUpCaptions.add(buildSpannableString());
+      rolledUpCaptions.add(buildCurrentLine());
       captionStringBuilder.setLength(0);
       cueStyles.clear();
       int numRows = Math.min(captionRowCount, row);
@@ -651,23 +767,89 @@ public void rollUp() {
       }
     }
 
-    public void setIndent(int indent) {
-      this.indent = indent;
-    }
+    public Cue build(@Cue.AnchorType int forcedPositionAnchor) {
+      SpannableStringBuilder cueString = new SpannableStringBuilder();
+      // Add any rolled up captions, separated by new lines.
+      for (int i = 0; i < rolledUpCaptions.size(); i++) {
+        cueString.append(rolledUpCaptions.get(i));
+        cueString.append('\n');
+      }
+      // Add the current line.
+      cueString.append(buildCurrentLine());
 
-    public void setTab(int tabs) {
-      tabOffset = tabs;
-    }
+      if (cueString.length() == 0) {
+        // The cue is empty.
+        return null;
+      }
 
-    public void setStyle(int style, boolean underline) {
-      cueStyles.add(new CueStyle(style, underline, captionStringBuilder.length()));
-    }
+      int positionAnchor;
+      // The number of empty columns before the start of the text, in the range [0-31].
+      int startPadding = indent + tabOffset;
+      // The number of empty columns after the end of the text, in the same range.
+      int endPadding = SCREEN_CHARWIDTH - startPadding - cueString.length();
+      int startEndPaddingDelta = startPadding - endPadding;
+      if (forcedPositionAnchor != Cue.TYPE_UNSET) {
+        positionAnchor = forcedPositionAnchor;
+      } else if (captionMode == CC_MODE_POP_ON
+          && (Math.abs(startEndPaddingDelta) < 3 || endPadding < 0)) {
+        // Treat approximately centered pop-on captions as middle aligned. We also treat captions
+        // that are wider than they should be in this way. See
+        // https://github.com/google/ExoPlayer/issues/3534.
+        positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+      } else if (captionMode == CC_MODE_POP_ON && startEndPaddingDelta > 0) {
+        // Treat pop-on captions with less padding at the end than the start as end aligned.
+        positionAnchor = Cue.ANCHOR_TYPE_END;
+      } else {
+        // For all other cases assume start aligned.
+        positionAnchor = Cue.ANCHOR_TYPE_START;
+      }
 
-    public void append(char text) {
-      captionStringBuilder.append(text);
+      float position;
+      switch (positionAnchor) {
+        case Cue.ANCHOR_TYPE_MIDDLE:
+          position = 0.5f;
+          break;
+        case Cue.ANCHOR_TYPE_END:
+          position = (float) (SCREEN_CHARWIDTH - endPadding) / SCREEN_CHARWIDTH;
+          // Adjust the position to fit within the safe area.
+          position = position * 0.8f + 0.1f;
+          break;
+        case Cue.ANCHOR_TYPE_START:
+        default:
+          position = (float) startPadding / SCREEN_CHARWIDTH;
+          // Adjust the position to fit within the safe area.
+          position = position * 0.8f + 0.1f;
+          break;
+      }
+
+      int lineAnchor;
+      int line;
+      // Note: Row indices are in the range [1-15].
+      if (captionMode == CC_MODE_ROLL_UP || row > (BASE_ROW / 2)) {
+        lineAnchor = Cue.ANCHOR_TYPE_END;
+        line = row - BASE_ROW;
+        // Two line adjustments. The first is because line indices from the bottom of the window
+        // start from -1 rather than 0. The second is a blank row to act as the safe area.
+        line -= 2;
+      } else {
+        lineAnchor = Cue.ANCHOR_TYPE_START;
+        // Line indices from the top of the window start from 0, but we want a blank row to act as
+        // the safe area. As a result no adjustment is necessary.
+        line = row;
+      }
+
+      return new Cue(
+          cueString,
+          Alignment.ALIGN_NORMAL,
+          line,
+          Cue.LINE_TYPE_NUMBER,
+          lineAnchor,
+          position,
+          positionAnchor,
+          Cue.DIMEN_UNSET);
     }
 
-    public SpannableString buildSpannableString() {
+    private SpannableString buildCurrentLine() {
       SpannableStringBuilder builder = new SpannableStringBuilder(captionStringBuilder);
       int length = builder.length();
 
@@ -733,73 +915,6 @@ public SpannableString buildSpannableString() {
       return new SpannableString(builder);
     }
 
-    public Cue build() {
-      SpannableStringBuilder cueString = new SpannableStringBuilder();
-      // Add any rolled up captions, separated by new lines.
-      for (int i = 0; i < rolledUpCaptions.size(); i++) {
-        cueString.append(rolledUpCaptions.get(i));
-        cueString.append('\n');
-      }
-      // Add the current line.
-      cueString.append(buildSpannableString());
-
-      if (cueString.length() == 0) {
-        // The cue is empty.
-        return null;
-      }
-
-      float position;
-      int positionAnchor;
-      // The number of empty columns before the start of the text, in the range [0-31].
-      int startPadding = indent + tabOffset;
-      // The number of empty columns after the end of the text, in the same range.
-      int endPadding = SCREEN_CHARWIDTH - startPadding - cueString.length();
-      int startEndPaddingDelta = startPadding - endPadding;
-      if (captionMode == CC_MODE_POP_ON && (Math.abs(startEndPaddingDelta) < 3 || endPadding < 0)) {
-        // Treat approximately centered pop-on captions as middle aligned. We also treat captions
-        // that are wider than they should be in this way. See
-        // https://github.com/google/ExoPlayer/issues/3534.
-        position = 0.5f;
-        positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
-      } else if (captionMode == CC_MODE_POP_ON && startEndPaddingDelta > 0) {
-        // Treat pop-on captions with less padding at the end than the start as end aligned.
-        position = (float) (SCREEN_CHARWIDTH - endPadding) / SCREEN_CHARWIDTH;
-        // Adjust the position to fit within the safe area.
-        position = position * 0.8f + 0.1f;
-        positionAnchor = Cue.ANCHOR_TYPE_END;
-      } else {
-        // For all other cases assume start aligned.
-        position = (float) startPadding / SCREEN_CHARWIDTH;
-        // Adjust the position to fit within the safe area.
-        position = position * 0.8f + 0.1f;
-        positionAnchor = Cue.ANCHOR_TYPE_START;
-      }
-
-      int lineAnchor;
-      int line;
-      // Note: Row indices are in the range [1-15].
-      if (captionMode == CC_MODE_ROLL_UP || row > (BASE_ROW / 2)) {
-        lineAnchor = Cue.ANCHOR_TYPE_END;
-        line = row - BASE_ROW;
-        // Two line adjustments. The first is because line indices from the bottom of the window
-        // start from -1 rather than 0. The second is a blank row to act as the safe area.
-        line -= 2;
-      } else {
-        lineAnchor = Cue.ANCHOR_TYPE_START;
-        // Line indices from the top of the window start from 0, but we want a blank row to act as
-        // the safe area. As a result no adjustment is necessary.
-        line = row;
-      }
-
-      return new Cue(cueString, Alignment.ALIGN_NORMAL, line, Cue.LINE_TYPE_NUMBER, lineAnchor,
-          position, positionAnchor, Cue.DIMEN_UNSET);
-    }
-
-    @Override
-    public String toString() {
-      return captionStringBuilder.toString();
-    }
-
     private static void setUnderlineSpan(SpannableStringBuilder builder, int start, int end) {
       builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
index 0a3f36fa87..a0201e19e6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import android.text.Layout.Alignment;
 import com.google.android.exoplayer2.text.Cue;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
index 3efc16bdd0..ce9da9f5d5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Subtitle;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
index 3b039061b0..6f9fd366ec 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.text.subrip;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.Html;
 import android.text.Spanned;
 import android.text.TextUtils;
@@ -247,8 +247,11 @@ private static long parseTimecode(Matcher matcher, int groupOffset) {
       case Cue.ANCHOR_TYPE_MIDDLE:
         return SubripDecoder.MID_FRACTION;
       case Cue.ANCHOR_TYPE_END:
-      default:
         return SubripDecoder.END_FRACTION;
+      case Cue.TYPE_UNSET:
+      default:
+        // Should never happen.
+        throw new IllegalArgumentException();
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
index 020bbe201b..ecf5c8b0a0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
@@ -17,7 +17,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.SpannableStringBuilder;
 import android.util.Base64;
 import android.util.Pair;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
index a4f0cca955..9fdcc48c12 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.text.ttml;
 
 import android.graphics.Typeface;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Assertions;
 import java.lang.annotation.Documented;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
index 7b30461750..6a52338a94 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text.ttml;
 
+import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
@@ -63,7 +64,7 @@ public long getEventTime(int index) {
     return eventTimesUs[index];
   }
 
-  /* @VisibleForTesting */
+  @VisibleForTesting
   /* package */ TtmlNode getRoot() {
     return root;
   }
@@ -73,7 +74,7 @@ public long getEventTime(int index) {
     return root.getCues(timeUs, globalStyles, regionMap, imageMap);
   }
 
-  /* @VisibleForTesting */
+  @VisibleForTesting
   /* package */ Map<String, TtmlStyle> getGlobalStyles() {
     return globalStyles;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index fe274a6241..ded7ef73ff 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.text.webvtt;
 
 import android.graphics.Typeface;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
index 9900ca0e72..2361c9729f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.text.webvtt;
 
 import android.graphics.Typeface;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import android.text.Layout.Alignment;
 import android.text.Spannable;
 import android.text.SpannableStringBuilder;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index 696f2bdefe..bbf57c5602 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
@@ -23,9 +23,12 @@
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A bandwidth based adaptive {@link TrackSelection}, whose selected track is updated to be the one
@@ -33,10 +36,8 @@
  */
 public class AdaptiveTrackSelection extends BaseTrackSelection {
 
-  /**
-   * Factory for {@link AdaptiveTrackSelection} instances.
-   */
-  public static final class Factory implements TrackSelection.Factory {
+  /** Factory for {@link AdaptiveTrackSelection} instances. */
+  public static class Factory implements TrackSelection.Factory {
 
     private final @Nullable BandwidthMeter bandwidthMeter;
     private final int minDurationForQualityIncreaseMs;
@@ -47,6 +48,9 @@
     private final long minTimeBetweenBufferReevaluationMs;
     private final Clock clock;
 
+    private TrackBitrateEstimator trackBitrateEstimator;
+    private boolean blockFixedTrackSelectionBandwidth;
+
     /** Creates an adaptive track selection factory with default parameters. */
     public Factory() {
       this(
@@ -199,22 +203,102 @@ public Factory(
           bufferedFractionToLiveEdgeForQualityIncrease;
       this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;
       this.clock = clock;
+      trackBitrateEstimator = TrackBitrateEstimator.DEFAULT;
+    }
+
+    /**
+     * Sets a TrackBitrateEstimator.
+     *
+     * <p>This method is experimental, and will be renamed or removed in a future release.
+     *
+     * @param trackBitrateEstimator A {@link TrackBitrateEstimator}.
+     */
+    public final void experimental_setTrackBitrateEstimator(
+        TrackBitrateEstimator trackBitrateEstimator) {
+      this.trackBitrateEstimator = trackBitrateEstimator;
+    }
+
+    /**
+     * Enables blocking of the total fixed track selection bandwidth.
+     *
+     * <p>This method is experimental, and will be renamed or removed in a future release.
+     */
+    public final void experimental_enableBlockFixedTrackSelectionBandwidth() {
+      this.blockFixedTrackSelectionBandwidth = true;
     }
 
     @Override
-    public AdaptiveTrackSelection createTrackSelection(
-        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
+    public final @NullableType TrackSelection[] createTrackSelections(
+        @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
       if (this.bandwidthMeter != null) {
         bandwidthMeter = this.bandwidthMeter;
       }
+      TrackSelection[] selections = new TrackSelection[definitions.length];
+      List<AdaptiveTrackSelection> adaptiveSelections = new ArrayList<>();
+      int totalFixedBandwidth = 0;
+      for (int i = 0; i < definitions.length; i++) {
+        Definition definition = definitions[i];
+        if (definition == null) {
+          continue;
+        }
+        if (definition.tracks.length > 1) {
+          AdaptiveTrackSelection adaptiveSelection =
+              createAdaptiveTrackSelection(definition.group, bandwidthMeter, definition.tracks);
+          adaptiveSelection.experimental_setTrackBitrateEstimator(trackBitrateEstimator);
+          adaptiveSelections.add(adaptiveSelection);
+          selections[i] = adaptiveSelection;
+        } else {
+          selections[i] =
+              new FixedTrackSelection(
+                  definition.group, definition.tracks[0], definition.reason, definition.data);
+          int trackBitrate = definition.group.getFormat(definition.tracks[0]).bitrate;
+          if (trackBitrate != Format.NO_VALUE) {
+            totalFixedBandwidth += trackBitrate;
+          }
+        }
+      }
+      if (blockFixedTrackSelectionBandwidth) {
+        for (int i = 0; i < adaptiveSelections.size(); i++) {
+          adaptiveSelections.get(i).experimental_setNonAllocatableBandwidth(totalFixedBandwidth);
+        }
+      }
+      if (adaptiveSelections.size() > 1) {
+        long[][] adaptiveTrackBitrates = new long[adaptiveSelections.size()][];
+        for (int i = 0; i < adaptiveSelections.size(); i++) {
+          AdaptiveTrackSelection adaptiveSelection = adaptiveSelections.get(i);
+          adaptiveTrackBitrates[i] = new long[adaptiveSelection.length()];
+          for (int j = 0; j < adaptiveSelection.length(); j++) {
+            adaptiveTrackBitrates[i][j] =
+                adaptiveSelection.getFormat(adaptiveSelection.length() - j - 1).bitrate;
+          }
+        }
+        long[][][] bandwidthCheckpoints = getAllocationCheckpoints(adaptiveTrackBitrates);
+        for (int i = 0; i < adaptiveSelections.size(); i++) {
+          adaptiveSelections
+              .get(i)
+              .experimental_setBandwidthAllocationCheckpoints(bandwidthCheckpoints[i]);
+        }
+      }
+      return selections;
+    }
+
+    /**
+     * Creates a single adaptive selection for the given group, bandwidth meter and tracks.
+     *
+     * @param group The {@link TrackGroup}.
+     * @param bandwidthMeter A {@link BandwidthMeter} which can be used to select tracks.
+     * @param tracks The indices of the selected tracks in the track group.
+     * @return An {@link AdaptiveTrackSelection} for the specified tracks.
+     */
+    protected AdaptiveTrackSelection createAdaptiveTrackSelection(
+        TrackGroup group, BandwidthMeter bandwidthMeter, int[] tracks) {
       return new AdaptiveTrackSelection(
           group,
           tracks,
-          bandwidthMeter,
+          new DefaultBandwidthProvider(bandwidthMeter, bandwidthFraction),
           minDurationForQualityIncreaseMs,
           maxDurationForQualityDecreaseMs,
           minDurationToRetainAfterDiscardMs,
-          bandwidthFraction,
           bufferedFractionToLiveEdgeForQualityIncrease,
           minTimeBetweenBufferReevaluationMs,
           clock);
@@ -228,15 +312,18 @@ public AdaptiveTrackSelection createTrackSelection(
   public static final float DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE = 0.75f;
   public static final long DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS = 2000;
 
-  private final BandwidthMeter bandwidthMeter;
+  private final BandwidthProvider bandwidthProvider;
   private final long minDurationForQualityIncreaseUs;
   private final long maxDurationForQualityDecreaseUs;
   private final long minDurationToRetainAfterDiscardUs;
-  private final float bandwidthFraction;
   private final float bufferedFractionToLiveEdgeForQualityIncrease;
   private final long minTimeBetweenBufferReevaluationMs;
   private final Clock clock;
+  private final Format[] formats;
+  private final int[] formatBitrates;
+  private final int[] trackBitrates;
 
+  private TrackBitrateEstimator trackBitrateEstimator;
   private float playbackSpeed;
   private int selectedIndex;
   private int reason;
@@ -301,22 +388,84 @@ public AdaptiveTrackSelection(
       float bufferedFractionToLiveEdgeForQualityIncrease,
       long minTimeBetweenBufferReevaluationMs,
       Clock clock) {
+    this(
+        group,
+        tracks,
+        new DefaultBandwidthProvider(bandwidthMeter, bandwidthFraction),
+        minDurationForQualityIncreaseMs,
+        maxDurationForQualityDecreaseMs,
+        minDurationToRetainAfterDiscardMs,
+        bufferedFractionToLiveEdgeForQualityIncrease,
+        minTimeBetweenBufferReevaluationMs,
+        clock);
+  }
+
+  private AdaptiveTrackSelection(
+      TrackGroup group,
+      int[] tracks,
+      BandwidthProvider bandwidthProvider,
+      long minDurationForQualityIncreaseMs,
+      long maxDurationForQualityDecreaseMs,
+      long minDurationToRetainAfterDiscardMs,
+      float bufferedFractionToLiveEdgeForQualityIncrease,
+      long minTimeBetweenBufferReevaluationMs,
+      Clock clock) {
     super(group, tracks);
-    this.bandwidthMeter = bandwidthMeter;
+    this.bandwidthProvider = bandwidthProvider;
     this.minDurationForQualityIncreaseUs = minDurationForQualityIncreaseMs * 1000L;
     this.maxDurationForQualityDecreaseUs = maxDurationForQualityDecreaseMs * 1000L;
     this.minDurationToRetainAfterDiscardUs = minDurationToRetainAfterDiscardMs * 1000L;
-    this.bandwidthFraction = bandwidthFraction;
     this.bufferedFractionToLiveEdgeForQualityIncrease =
         bufferedFractionToLiveEdgeForQualityIncrease;
     this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;
     this.clock = clock;
     playbackSpeed = 1f;
-    reason = C.SELECTION_REASON_INITIAL;
+    reason = C.SELECTION_REASON_UNKNOWN;
     lastBufferEvaluationMs = C.TIME_UNSET;
-    @SuppressWarnings("nullness:method.invocation.invalid")
-    int selectedIndex = determineIdealSelectedIndex(Long.MIN_VALUE);
-    this.selectedIndex = selectedIndex;
+    trackBitrateEstimator = TrackBitrateEstimator.DEFAULT;
+    formats = new Format[length];
+    formatBitrates = new int[length];
+    trackBitrates = new int[length];
+    for (int i = 0; i < length; i++) {
+      @SuppressWarnings("nullness:method.invocation.invalid")
+      Format format = getFormat(i);
+      formats[i] = format;
+      formatBitrates[i] = formats[i].bitrate;
+    }
+  }
+
+  /**
+   * Sets a TrackBitrateEstimator.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release.
+   *
+   * @param trackBitrateEstimator A {@link TrackBitrateEstimator}.
+   */
+  public void experimental_setTrackBitrateEstimator(TrackBitrateEstimator trackBitrateEstimator) {
+    this.trackBitrateEstimator = trackBitrateEstimator;
+  }
+
+  /**
+   * Sets the non-allocatable bandwidth, which shouldn't be considered available.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release.
+   *
+   * @param nonAllocatableBandwidth The non-allocatable bandwidth in bits per second.
+   */
+  public void experimental_setNonAllocatableBandwidth(long nonAllocatableBandwidth) {
+    ((DefaultBandwidthProvider) bandwidthProvider)
+        .experimental_setNonAllocatableBandwidth(nonAllocatableBandwidth);
+  }
+
+  /**
+   * Sets checkpoints to determine the allocation bandwidth based on the total bandwidth.
+   *
+   * @param allocationCheckpoints List of checkpoints. Each element must be a long[2], with [0]
+   *     being the total bandwidth and [1] being the allocated bandwidth.
+   */
+  public void experimental_setBandwidthAllocationCheckpoints(long[][] allocationCheckpoints) {
+    ((DefaultBandwidthProvider) bandwidthProvider)
+        .experimental_setBandwidthAllocationCheckpoints(allocationCheckpoints);
   }
 
   @Override
@@ -338,9 +487,19 @@ public void updateSelectedTrack(
       MediaChunkIterator[] mediaChunkIterators) {
     long nowMs = clock.elapsedRealtime();
 
+    // Update the estimated track bitrates.
+    trackBitrateEstimator.getBitrates(formats, queue, mediaChunkIterators, trackBitrates);
+
+    // Make initial selection
+    if (reason == C.SELECTION_REASON_UNKNOWN) {
+      reason = C.SELECTION_REASON_INITIAL;
+      selectedIndex = determineIdealSelectedIndex(nowMs, trackBitrates);
+      return;
+    }
+
     // Stash the current selection, then make a new one.
     int currentSelectedIndex = selectedIndex;
-    selectedIndex = determineIdealSelectedIndex(nowMs);
+    selectedIndex = determineIdealSelectedIndex(nowMs, trackBitrates);
     if (selectedIndex == currentSelectedIndex) {
       return;
     }
@@ -385,10 +544,10 @@ public int getSelectionReason() {
   @Override
   public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
     long nowMs = clock.elapsedRealtime();
-    if (lastBufferEvaluationMs != C.TIME_UNSET
-        && nowMs - lastBufferEvaluationMs < minTimeBetweenBufferReevaluationMs) {
+    if (!shouldEvaluateQueueSize(nowMs)) {
       return queue.size();
     }
+
     lastBufferEvaluationMs = nowMs;
     if (queue.isEmpty()) {
       return 0;
@@ -399,10 +558,11 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     long playoutBufferedDurationBeforeLastChunkUs =
         Util.getPlayoutDurationForMediaDuration(
             lastChunk.startTimeUs - playbackPositionUs, playbackSpeed);
+    long minDurationToRetainAfterDiscardUs = getMinDurationToRetainAfterDiscardUs();
     if (playoutBufferedDurationBeforeLastChunkUs < minDurationToRetainAfterDiscardUs) {
       return queueSize;
     }
-    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
+    int idealSelectedIndex = determineIdealSelectedIndex(nowMs, formatBitrates);
     Format idealFormat = getFormat(idealSelectedIndex);
     // If the chunks contain video, discard from the first SD chunk beyond
     // minDurationToRetainAfterDiscardUs whose resolution and bitrate are both lower than the ideal
@@ -424,19 +584,59 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     return queueSize;
   }
 
+  /**
+   * Called when updating the selected track to determine whether a candidate track can be selected.
+   *
+   * @param format The {@link Format} of the candidate track.
+   * @param trackBitrate The estimated bitrate of the track. May differ from {@link Format#bitrate}
+   *     if a more accurate estimate of the current track bitrate is available.
+   * @param playbackSpeed The current playback speed.
+   * @param effectiveBitrate The bitrate available to this selection.
+   * @return Whether this {@link Format} can be selected.
+   */
+  @SuppressWarnings("unused")
+  protected boolean canSelectFormat(
+      Format format, int trackBitrate, float playbackSpeed, long effectiveBitrate) {
+    return Math.round(trackBitrate * playbackSpeed) <= effectiveBitrate;
+  }
+
+  /**
+   * Called from {@link #evaluateQueueSize(long, List)} to determine whether an evaluation should be
+   * performed.
+   *
+   * @param nowMs The current value of {@link Clock#elapsedRealtime()}.
+   * @return Whether an evaluation should be performed.
+   */
+  protected boolean shouldEvaluateQueueSize(long nowMs) {
+    return lastBufferEvaluationMs == C.TIME_UNSET
+        || nowMs - lastBufferEvaluationMs >= minTimeBetweenBufferReevaluationMs;
+  }
+
+  /**
+   * Called from {@link #evaluateQueueSize(long, List)} to determine the minimum duration of buffer
+   * to retain after discarding chunks.
+   *
+   * @return The minimum duration of buffer to retain after discarding chunks, in microseconds.
+   */
+  protected long getMinDurationToRetainAfterDiscardUs() {
+    return minDurationToRetainAfterDiscardUs;
+  }
+
   /**
    * Computes the ideal selected index ignoring buffer health.
    *
    * @param nowMs The current time in the timebase of {@link Clock#elapsedRealtime()}, or {@link
    *     Long#MIN_VALUE} to ignore blacklisting.
+   * @param trackBitrates The estimated track bitrates. May differ from format bitrates if more
+   *     accurate estimates of the current track bitrates are available.
    */
-  private int determineIdealSelectedIndex(long nowMs) {
-    long effectiveBitrate = (long) (bandwidthMeter.getBitrateEstimate() * bandwidthFraction);
+  private int determineIdealSelectedIndex(long nowMs, int[] trackBitrates) {
+    long effectiveBitrate = bandwidthProvider.getAllocatedBandwidth();
     int lowestBitrateNonBlacklistedIndex = 0;
     for (int i = 0; i < length; i++) {
       if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
         Format format = getFormat(i);
-        if (Math.round(format.bitrate * playbackSpeed) <= effectiveBitrate) {
+        if (canSelectFormat(format, trackBitrates[i], playbackSpeed, effectiveBitrate)) {
           return i;
         } else {
           lowestBitrateNonBlacklistedIndex = i;
@@ -453,4 +653,165 @@ private long minDurationForQualityIncreaseUs(long availableDurationUs) {
         ? (long) (availableDurationUs * bufferedFractionToLiveEdgeForQualityIncrease)
         : minDurationForQualityIncreaseUs;
   }
+
+  /** Provides the allocated bandwidth. */
+  private interface BandwidthProvider {
+
+    /** Returns the allocated bitrate. */
+    long getAllocatedBandwidth();
+  }
+
+  private static final class DefaultBandwidthProvider implements BandwidthProvider {
+
+    private final BandwidthMeter bandwidthMeter;
+    private final float bandwidthFraction;
+
+    private long nonAllocatableBandwidth;
+
+    @Nullable private long[][] allocationCheckpoints;
+
+    /* package */ DefaultBandwidthProvider(BandwidthMeter bandwidthMeter, float bandwidthFraction) {
+      this.bandwidthMeter = bandwidthMeter;
+      this.bandwidthFraction = bandwidthFraction;
+    }
+
+    @Override
+    public long getAllocatedBandwidth() {
+      long totalBandwidth = (long) (bandwidthMeter.getBitrateEstimate() * bandwidthFraction);
+      long allocatableBandwidth = Math.max(0L, totalBandwidth - nonAllocatableBandwidth);
+      if (allocationCheckpoints == null) {
+        return allocatableBandwidth;
+      }
+      int nextIndex = 1;
+      while (nextIndex < allocationCheckpoints.length - 1
+          && allocationCheckpoints[nextIndex][0] < allocatableBandwidth) {
+        nextIndex++;
+      }
+      long[] previous = allocationCheckpoints[nextIndex - 1];
+      long[] next = allocationCheckpoints[nextIndex];
+      float fractionBetweenCheckpoints =
+          (float) (allocatableBandwidth - previous[0]) / (next[0] - previous[0]);
+      return previous[1] + (long) (fractionBetweenCheckpoints * (next[1] - previous[1]));
+    }
+
+    /* package */ void experimental_setNonAllocatableBandwidth(long nonAllocatableBandwidth) {
+      this.nonAllocatableBandwidth = nonAllocatableBandwidth;
+    }
+
+    /* package */ void experimental_setBandwidthAllocationCheckpoints(
+        long[][] allocationCheckpoints) {
+      Assertions.checkArgument(allocationCheckpoints.length >= 2);
+      this.allocationCheckpoints = allocationCheckpoints;
+    }
+  }
+
+  /**
+   * Returns allocation checkpoints for allocating bandwidth between multiple adaptive track
+   * selections.
+   *
+   * @param trackBitrates Array of [selectionIndex][trackIndex] -> trackBitrate.
+   * @return Array of allocation checkpoints [selectionIndex][checkpointIndex][2] with [0]=total
+   *     bandwidth at checkpoint and [1]=allocated bandwidth at checkpoint.
+   */
+  private static long[][][] getAllocationCheckpoints(long[][] trackBitrates) {
+    // Algorithm:
+    //  1. Use log bitrates to treat all resolution update steps equally.
+    //  2. Distribute switch points for each selection equally in the same [0.0-1.0] range.
+    //  3. Switch up one format at a time in the order of the switch points.
+    double[][] logBitrates = getLogArrayValues(trackBitrates);
+    double[][] switchPoints = getSwitchPoints(logBitrates);
+
+    // There will be (count(switch point) + 3) checkpoints:
+    // [0] = all zero, [1] = minimum bitrates, [2-(end-1)] = up-switch points,
+    // [end] = extra point to set slope for additional bitrate.
+    int checkpointCount = countArrayElements(switchPoints) + 3;
+    long[][][] checkpoints = new long[logBitrates.length][checkpointCount][2];
+    int[] currentSelection = new int[logBitrates.length];
+    setCheckpointValues(checkpoints, /* checkpointIndex= */ 1, trackBitrates, currentSelection);
+    for (int checkpointIndex = 2; checkpointIndex < checkpointCount - 1; checkpointIndex++) {
+      int nextUpdateIndex = 0;
+      double nextUpdateSwitchPoint = Double.MAX_VALUE;
+      for (int i = 0; i < logBitrates.length; i++) {
+        if (currentSelection[i] + 1 == logBitrates[i].length) {
+          continue;
+        }
+        double switchPoint = switchPoints[i][currentSelection[i]];
+        if (switchPoint < nextUpdateSwitchPoint) {
+          nextUpdateSwitchPoint = switchPoint;
+          nextUpdateIndex = i;
+        }
+      }
+      currentSelection[nextUpdateIndex]++;
+      setCheckpointValues(checkpoints, checkpointIndex, trackBitrates, currentSelection);
+    }
+    for (long[][] points : checkpoints) {
+      points[checkpointCount - 1][0] = 2 * points[checkpointCount - 2][0];
+      points[checkpointCount - 1][1] = 2 * points[checkpointCount - 2][1];
+    }
+    return checkpoints;
+  }
+
+  /** Converts all input values to Math.log(value). */
+  private static double[][] getLogArrayValues(long[][] values) {
+    double[][] logValues = new double[values.length][];
+    for (int i = 0; i < values.length; i++) {
+      logValues[i] = new double[values[i].length];
+      for (int j = 0; j < values[i].length; j++) {
+        logValues[i][j] = Math.log(values[i][j]);
+      }
+    }
+    return logValues;
+  }
+
+  /**
+   * Returns idealized switch points for each switch between consecutive track selection bitrates.
+   *
+   * @param logBitrates Log bitrates with [selectionCount][formatCount].
+   * @return Linearly distributed switch points in the range of [0.0-1.0].
+   */
+  private static double[][] getSwitchPoints(double[][] logBitrates) {
+    double[][] switchPoints = new double[logBitrates.length][];
+    for (int i = 0; i < logBitrates.length; i++) {
+      switchPoints[i] = new double[logBitrates[i].length - 1];
+      if (switchPoints[i].length == 0) {
+        continue;
+      }
+      double totalBitrateDiff = logBitrates[i][logBitrates[i].length - 1] - logBitrates[i][0];
+      for (int j = 0; j < logBitrates[i].length - 1; j++) {
+        double switchBitrate = 0.5 * (logBitrates[i][j] + logBitrates[i][j + 1]);
+        switchPoints[i][j] = (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
+      }
+    }
+    return switchPoints;
+  }
+
+  /** Returns total number of elements in a 2D array. */
+  private static int countArrayElements(double[][] array) {
+    int count = 0;
+    for (double[] subArray : array) {
+      count += subArray.length;
+    }
+    return count;
+  }
+
+  /**
+   * Sets checkpoint bitrates.
+   *
+   * @param checkpoints Output checkpoints with [selectionIndex][checkpointIndex][2] where [0]=Total
+   *     bitrate and [1]=Allocated bitrate.
+   * @param checkpointIndex The checkpoint index.
+   * @param trackBitrates The track bitrates with [selectionIndex][trackIndex].
+   * @param selectedTracks The indices of selected tracks for each selection for this checkpoint.
+   */
+  private static void setCheckpointValues(
+      long[][][] checkpoints, int checkpointIndex, long[][] trackBitrates, int[] selectedTracks) {
+    long totalBitrate = 0;
+    for (int i = 0; i < checkpoints.length; i++) {
+      checkpoints[i][checkpointIndex][1] = trackBitrates[i][selectedTracks[i]];
+      totalBitrate += checkpoints[i][checkpointIndex][1];
+    }
+    for (long[][] points : checkpoints) {
+      points[checkpointIndex][0] = totalBitrate;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index 798b6ce810..dc0b3f6747 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BufferSizeAdaptationBuilder.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BufferSizeAdaptationBuilder.java
new file mode 100644
index 0000000000..9826c5b137
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BufferSizeAdaptationBuilder.java
@@ -0,0 +1,494 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import androidx.annotation.Nullable;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.trackselection.TrackSelection.Definition;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultAllocator;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Clock;
+import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+
+/**
+ * Builder for a {@link TrackSelection.Factory} and {@link LoadControl} that implement buffer size
+ * based track adaptation.
+ */
+public final class BufferSizeAdaptationBuilder {
+
+  /** Dynamic filter for formats, which is applied when selecting a new track. */
+  public interface DynamicFormatFilter {
+
+    /** Filter which allows all formats. */
+    DynamicFormatFilter NO_FILTER = (format, trackBitrate, isInitialSelection) -> true;
+
+    /**
+     * Called when updating the selected track to determine whether a candidate track is allowed. If
+     * no format is allowed or eligible, the lowest quality format will be used.
+     *
+     * @param format The {@link Format} of the candidate track.
+     * @param trackBitrate The estimated bitrate of the track. May differ from {@link
+     *     Format#bitrate} if a more accurate estimate of the current track bitrate is available.
+     * @param isInitialSelection Whether this is for the initial track selection.
+     */
+    boolean isFormatAllowed(Format format, int trackBitrate, boolean isInitialSelection);
+  }
+
+  /**
+   * The default minimum duration of media that the player will attempt to ensure is buffered at all
+   * times, in milliseconds.
+   */
+  public static final int DEFAULT_MIN_BUFFER_MS = 15000;
+
+  /**
+   * The default maximum duration of media that the player will attempt to buffer, in milliseconds.
+   */
+  public static final int DEFAULT_MAX_BUFFER_MS = 50000;
+
+  /**
+   * The default duration of media that must be buffered for playback to start or resume following a
+   * user action such as a seek, in milliseconds.
+   */
+  public static final int DEFAULT_BUFFER_FOR_PLAYBACK_MS =
+      DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_MS;
+
+  /**
+   * The default duration of media that must be buffered for playback to resume after a rebuffer, in
+   * milliseconds. A rebuffer is defined to be caused by buffer depletion rather than a user action.
+   */
+  public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS =
+      DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS;
+
+  /**
+   * The default offset the current duration of buffered media must deviate from the ideal duration
+   * of buffered media for the currently selected format, before the selected format is changed.
+   */
+  public static final int DEFAULT_HYSTERESIS_BUFFER_MS = 5000;
+
+  /**
+   * During start-up phase, the default fraction of the available bandwidth that the selection
+   * should consider available for use. Setting to a value less than 1 is recommended to account for
+   * inaccuracies in the bandwidth estimator.
+   */
+  public static final float DEFAULT_START_UP_BANDWIDTH_FRACTION =
+      AdaptiveTrackSelection.DEFAULT_BANDWIDTH_FRACTION;
+
+  /**
+   * During start-up phase, the default minimum duration of buffered media required for the selected
+   * track to switch to one of higher quality based on measured bandwidth.
+   */
+  public static final int DEFAULT_START_UP_MIN_BUFFER_FOR_QUALITY_INCREASE_MS =
+      AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS;
+
+  @Nullable private DefaultAllocator allocator;
+  private Clock clock;
+  private int minBufferMs;
+  private int maxBufferMs;
+  private int bufferForPlaybackMs;
+  private int bufferForPlaybackAfterRebufferMs;
+  private int hysteresisBufferMs;
+  private float startUpBandwidthFraction;
+  private int startUpMinBufferForQualityIncreaseMs;
+  private DynamicFormatFilter dynamicFormatFilter;
+  private boolean buildCalled;
+
+  /** Creates builder with default values. */
+  public BufferSizeAdaptationBuilder() {
+    clock = Clock.DEFAULT;
+    minBufferMs = DEFAULT_MIN_BUFFER_MS;
+    maxBufferMs = DEFAULT_MAX_BUFFER_MS;
+    bufferForPlaybackMs = DEFAULT_BUFFER_FOR_PLAYBACK_MS;
+    bufferForPlaybackAfterRebufferMs = DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS;
+    hysteresisBufferMs = DEFAULT_HYSTERESIS_BUFFER_MS;
+    startUpBandwidthFraction = DEFAULT_START_UP_BANDWIDTH_FRACTION;
+    startUpMinBufferForQualityIncreaseMs = DEFAULT_START_UP_MIN_BUFFER_FOR_QUALITY_INCREASE_MS;
+    dynamicFormatFilter = DynamicFormatFilter.NO_FILTER;
+  }
+
+  /**
+   * Set the clock to use. Should only be set for testing purposes.
+   *
+   * @param clock The {@link Clock}.
+   * @return This builder, for convenience.
+   * @throws IllegalStateException If {@link #buildPlayerComponents()} has already been called.
+   */
+  public BufferSizeAdaptationBuilder setClock(Clock clock) {
+    Assertions.checkState(!buildCalled);
+    this.clock = clock;
+    return this;
+  }
+
+  /**
+   * Sets the {@link DefaultAllocator} used by the loader.
+   *
+   * @param allocator The {@link DefaultAllocator}.
+   * @return This builder, for convenience.
+   * @throws IllegalStateException If {@link #buildPlayerComponents()} has already been called.
+   */
+  public BufferSizeAdaptationBuilder setAllocator(DefaultAllocator allocator) {
+    Assertions.checkState(!buildCalled);
+    this.allocator = allocator;
+    return this;
+  }
+
+  /**
+   * Sets the buffer duration parameters.
+   *
+   * @param minBufferMs The minimum duration of media that the player will attempt to ensure is
+   *     buffered at all times, in milliseconds.
+   * @param maxBufferMs The maximum duration of media that the player will attempt to buffer, in
+   *     milliseconds.
+   * @param bufferForPlaybackMs The duration of media that must be buffered for playback to start or
+   *     resume following a user action such as a seek, in milliseconds.
+   * @param bufferForPlaybackAfterRebufferMs The default duration of media that must be buffered for
+   *     playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by
+   *     buffer depletion rather than a user action.
+   * @return This builder, for convenience.
+   * @throws IllegalStateException If {@link #buildPlayerComponents()} has already been called.
+   */
+  public BufferSizeAdaptationBuilder setBufferDurationsMs(
+      int minBufferMs,
+      int maxBufferMs,
+      int bufferForPlaybackMs,
+      int bufferForPlaybackAfterRebufferMs) {
+    Assertions.checkState(!buildCalled);
+    this.minBufferMs = minBufferMs;
+    this.maxBufferMs = maxBufferMs;
+    this.bufferForPlaybackMs = bufferForPlaybackMs;
+    this.bufferForPlaybackAfterRebufferMs = bufferForPlaybackAfterRebufferMs;
+    return this;
+  }
+
+  /**
+   * Sets the hysteresis buffer used to prevent repeated format switching.
+   *
+   * @param hysteresisBufferMs The offset the current duration of buffered media must deviate from
+   *     the ideal duration of buffered media for the currently selected format, before the selected
+   *     format is changed. This value must be smaller than {@code maxBufferMs - minBufferMs}.
+   * @return This builder, for convenience.
+   * @throws IllegalStateException If {@link #buildPlayerComponents()} has already been called.
+   */
+  public BufferSizeAdaptationBuilder setHysteresisBufferMs(int hysteresisBufferMs) {
+    Assertions.checkState(!buildCalled);
+    this.hysteresisBufferMs = hysteresisBufferMs;
+    return this;
+  }
+
+  /**
+   * Sets track selection parameters used during the start-up phase before the selection can be made
+   * purely on based on buffer size. During the start-up phase the selection is based on the current
+   * bandwidth estimate.
+   *
+   * @param bandwidthFraction The fraction of the available bandwidth that the selection should
+   *     consider available for use. Setting to a value less than 1 is recommended to account for
+   *     inaccuracies in the bandwidth estimator.
+   * @param minBufferForQualityIncreaseMs The minimum duration of buffered media required for the
+   *     selected track to switch to one of higher quality.
+   * @return This builder, for convenience.
+   * @throws IllegalStateException If {@link #buildPlayerComponents()} has already been called.
+   */
+  public BufferSizeAdaptationBuilder setStartUpTrackSelectionParameters(
+      float bandwidthFraction, int minBufferForQualityIncreaseMs) {
+    Assertions.checkState(!buildCalled);
+    this.startUpBandwidthFraction = bandwidthFraction;
+    this.startUpMinBufferForQualityIncreaseMs = minBufferForQualityIncreaseMs;
+    return this;
+  }
+
+  /**
+   * Sets the {@link DynamicFormatFilter} to use when updating the selected track.
+   *
+   * @param dynamicFormatFilter The {@link DynamicFormatFilter}.
+   * @return This builder, for convenience.
+   * @throws IllegalStateException If {@link #buildPlayerComponents()} has already been called.
+   */
+  public BufferSizeAdaptationBuilder setDynamicFormatFilter(
+      DynamicFormatFilter dynamicFormatFilter) {
+    Assertions.checkState(!buildCalled);
+    this.dynamicFormatFilter = dynamicFormatFilter;
+    return this;
+  }
+
+  /**
+   * Builds player components for buffer size based track adaptation.
+   *
+   * @return A pair of a {@link TrackSelection.Factory} and a {@link LoadControl}, which should be
+   *     used to construct the player.
+   */
+  public Pair<TrackSelection.Factory, LoadControl> buildPlayerComponents() {
+    Assertions.checkArgument(hysteresisBufferMs < maxBufferMs - minBufferMs);
+    Assertions.checkState(!buildCalled);
+    buildCalled = true;
+
+    DefaultLoadControl.Builder loadControlBuilder =
+        new DefaultLoadControl.Builder()
+            .setTargetBufferBytes(/* targetBufferBytes = */ Integer.MAX_VALUE)
+            .setBufferDurationsMs(
+                /* minBufferMs= */ maxBufferMs,
+                maxBufferMs,
+                bufferForPlaybackMs,
+                bufferForPlaybackAfterRebufferMs);
+    if (allocator != null) {
+      loadControlBuilder.setAllocator(allocator);
+    }
+
+    TrackSelection.Factory trackSelectionFactory =
+        new TrackSelection.Factory() {
+          @Override
+          public @NullableType TrackSelection[] createTrackSelections(
+              @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
+            return TrackSelectionUtil.createTrackSelectionsForDefinitions(
+                definitions,
+                definition ->
+                    new BufferSizeAdaptiveTrackSelection(
+                        definition.group,
+                        definition.tracks,
+                        bandwidthMeter,
+                        minBufferMs,
+                        maxBufferMs,
+                        hysteresisBufferMs,
+                        startUpBandwidthFraction,
+                        startUpMinBufferForQualityIncreaseMs,
+                        dynamicFormatFilter,
+                        clock));
+          }
+        };
+
+    return Pair.create(trackSelectionFactory, loadControlBuilder.createDefaultLoadControl());
+  }
+
+  private static final class BufferSizeAdaptiveTrackSelection extends BaseTrackSelection {
+
+    private static final int BITRATE_BLACKLISTED = Format.NO_VALUE;
+
+    private final BandwidthMeter bandwidthMeter;
+    private final Clock clock;
+    private final DynamicFormatFilter dynamicFormatFilter;
+    private final int[] formatBitrates;
+    private final long minBufferUs;
+    private final long maxBufferUs;
+    private final long hysteresisBufferUs;
+    private final float startUpBandwidthFraction;
+    private final long startUpMinBufferForQualityIncreaseUs;
+    private final int minBitrate;
+    private final int maxBitrate;
+    private final double bitrateToBufferFunctionSlope;
+    private final double bitrateToBufferFunctionIntercept;
+
+    private boolean isInSteadyState;
+    private int selectedIndex;
+    private int selectionReason;
+    private float playbackSpeed;
+
+    private BufferSizeAdaptiveTrackSelection(
+        TrackGroup trackGroup,
+        int[] tracks,
+        BandwidthMeter bandwidthMeter,
+        int minBufferMs,
+        int maxBufferMs,
+        int hysteresisBufferMs,
+        float startUpBandwidthFraction,
+        int startUpMinBufferForQualityIncreaseMs,
+        DynamicFormatFilter dynamicFormatFilter,
+        Clock clock) {
+      super(trackGroup, tracks);
+      this.bandwidthMeter = bandwidthMeter;
+      this.minBufferUs = C.msToUs(minBufferMs);
+      this.maxBufferUs = C.msToUs(maxBufferMs);
+      this.hysteresisBufferUs = C.msToUs(hysteresisBufferMs);
+      this.startUpBandwidthFraction = startUpBandwidthFraction;
+      this.startUpMinBufferForQualityIncreaseUs = C.msToUs(startUpMinBufferForQualityIncreaseMs);
+      this.dynamicFormatFilter = dynamicFormatFilter;
+      this.clock = clock;
+
+      formatBitrates = new int[length];
+      maxBitrate = getFormat(/* index= */ 0).bitrate;
+      minBitrate = getFormat(/* index= */ length - 1).bitrate;
+      selectionReason = C.SELECTION_REASON_UNKNOWN;
+      playbackSpeed = 1.0f;
+
+      // We use a log-linear function to map from bitrate to buffer size:
+      // buffer = slope * ln(bitrate) + intercept,
+      // with buffer(minBitrate) = minBuffer and buffer(maxBitrate) = maxBuffer - hysteresisBuffer.
+      bitrateToBufferFunctionSlope =
+          (maxBufferUs - hysteresisBufferUs - minBufferUs)
+              / Math.log((double) maxBitrate / minBitrate);
+      bitrateToBufferFunctionIntercept =
+          minBufferUs - bitrateToBufferFunctionSlope * Math.log(minBitrate);
+    }
+
+    @Override
+    public void onPlaybackSpeed(float playbackSpeed) {
+      this.playbackSpeed = playbackSpeed;
+    }
+
+    @Override
+    public void onDiscontinuity() {
+      isInSteadyState = false;
+    }
+
+    @Override
+    public int getSelectedIndex() {
+      return selectedIndex;
+    }
+
+    @Override
+    public int getSelectionReason() {
+      return selectionReason;
+    }
+
+    @Override
+    @Nullable
+    public Object getSelectionData() {
+      return null;
+    }
+
+    @Override
+    public void updateSelectedTrack(
+        long playbackPositionUs,
+        long bufferedDurationUs,
+        long availableDurationUs,
+        List<? extends MediaChunk> queue,
+        MediaChunkIterator[] mediaChunkIterators) {
+      updateFormatBitrates(/* nowMs= */ clock.elapsedRealtime());
+
+      // Make initial selection
+      if (selectionReason == C.SELECTION_REASON_UNKNOWN) {
+        selectionReason = C.SELECTION_REASON_INITIAL;
+        selectedIndex = selectIdealIndexUsingBandwidth(/* isInitialSelection= */ true);
+        return;
+      }
+
+      long bufferUs = getCurrentPeriodBufferedDurationUs(playbackPositionUs, bufferedDurationUs);
+      int oldSelectedIndex = selectedIndex;
+      if (isInSteadyState) {
+        selectIndexSteadyState(bufferUs);
+      } else {
+        selectIndexStartUpPhase(bufferUs);
+      }
+      if (selectedIndex != oldSelectedIndex) {
+        selectionReason = C.SELECTION_REASON_ADAPTIVE;
+      }
+    }
+
+    // Steady state.
+
+    private void selectIndexSteadyState(long bufferUs) {
+      if (isOutsideHysteresis(bufferUs)) {
+        selectedIndex = selectIdealIndexUsingBufferSize(bufferUs);
+      }
+    }
+
+    private boolean isOutsideHysteresis(long bufferUs) {
+      if (formatBitrates[selectedIndex] == BITRATE_BLACKLISTED) {
+        return true;
+      }
+      long targetBufferForCurrentBitrateUs =
+          getTargetBufferForBitrateUs(formatBitrates[selectedIndex]);
+      long bufferDiffUs = bufferUs - targetBufferForCurrentBitrateUs;
+      return Math.abs(bufferDiffUs) > hysteresisBufferUs;
+    }
+
+    private int selectIdealIndexUsingBufferSize(long bufferUs) {
+      int lowestBitrateNonBlacklistedIndex = 0;
+      for (int i = 0; i < formatBitrates.length; i++) {
+        if (formatBitrates[i] != BITRATE_BLACKLISTED) {
+          if (getTargetBufferForBitrateUs(formatBitrates[i]) <= bufferUs
+              && dynamicFormatFilter.isFormatAllowed(
+                  getFormat(i), formatBitrates[i], /* isInitialSelection= */ false)) {
+            return i;
+          }
+          lowestBitrateNonBlacklistedIndex = i;
+        }
+      }
+      return lowestBitrateNonBlacklistedIndex;
+    }
+
+    // Startup.
+
+    private void selectIndexStartUpPhase(long bufferUs) {
+      int startUpSelectedIndex = selectIdealIndexUsingBandwidth(/* isInitialSelection= */ false);
+      int steadyStateSelectedIndex = selectIdealIndexUsingBufferSize(bufferUs);
+      if (steadyStateSelectedIndex <= selectedIndex) {
+        // Switch to steady state if we have enough buffer to maintain current selection.
+        selectedIndex = steadyStateSelectedIndex;
+        isInSteadyState = true;
+      } else {
+        if (bufferUs < startUpMinBufferForQualityIncreaseUs
+            && startUpSelectedIndex < selectedIndex
+            && formatBitrates[selectedIndex] != BITRATE_BLACKLISTED) {
+          // Switching up from a non-blacklisted track is only allowed if we have enough buffer.
+          return;
+        }
+        selectedIndex = startUpSelectedIndex;
+      }
+    }
+
+    private int selectIdealIndexUsingBandwidth(boolean isInitialSelection) {
+      long effectiveBitrate =
+          (long) (bandwidthMeter.getBitrateEstimate() * startUpBandwidthFraction);
+      int lowestBitrateNonBlacklistedIndex = 0;
+      for (int i = 0; i < formatBitrates.length; i++) {
+        if (formatBitrates[i] != BITRATE_BLACKLISTED) {
+          if (Math.round(formatBitrates[i] * playbackSpeed) <= effectiveBitrate
+              && dynamicFormatFilter.isFormatAllowed(
+                  getFormat(i), formatBitrates[i], isInitialSelection)) {
+            return i;
+          }
+          lowestBitrateNonBlacklistedIndex = i;
+        }
+      }
+      return lowestBitrateNonBlacklistedIndex;
+    }
+
+    // Utility methods.
+
+    private void updateFormatBitrates(long nowMs) {
+      for (int i = 0; i < length; i++) {
+        if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
+          formatBitrates[i] = getFormat(i).bitrate;
+        } else {
+          formatBitrates[i] = BITRATE_BLACKLISTED;
+        }
+      }
+    }
+
+    private long getTargetBufferForBitrateUs(int bitrate) {
+      if (bitrate <= minBitrate) {
+        return minBufferUs;
+      }
+      if (bitrate >= maxBitrate) {
+        return maxBufferUs - hysteresisBufferUs;
+      }
+      return (int)
+          (bitrateToBufferFunctionSlope * Math.log(bitrate) + bitrateToBufferFunctionIntercept);
+    }
+
+    private static long getCurrentPeriodBufferedDurationUs(
+        long playbackPositionUs, long bufferedDurationUs) {
+      return playbackPositionUs >= 0 ? bufferedDurationUs : playbackPositionUs + bufferedDurationUs;
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 4a75b6f722..3200e40495 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -19,8 +19,8 @@
 import android.graphics.Point;
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Pair;
 import android.util.SparseArray;
@@ -159,30 +159,34 @@
    * A builder for {@link Parameters}. See the {@link Parameters} documentation for explanations of
    * the parameters that can be configured using this builder.
    */
-  public static final class ParametersBuilder {
+  public static final class ParametersBuilder extends TrackSelectionParameters.Builder {
 
-    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
-    private final SparseBooleanArray rendererDisabledFlags;
-
-    private @Nullable String preferredAudioLanguage;
-    private @Nullable String preferredTextLanguage;
-    private boolean selectUndeterminedTextLanguage;
-    private int disabledTextTrackSelectionFlags;
-    private boolean forceLowestBitrate;
-    private boolean forceHighestSupportedBitrate;
-    private boolean allowMixedMimeAdaptiveness;
-    private boolean allowNonSeamlessAdaptiveness;
+    // Video
     private int maxVideoWidth;
     private int maxVideoHeight;
     private int maxVideoFrameRate;
     private int maxVideoBitrate;
     private boolean exceedVideoConstraintsIfNecessary;
-    private boolean exceedRendererCapabilitiesIfNecessary;
+    private boolean allowVideoMixedMimeTypeAdaptiveness;
+    private boolean allowVideoNonSeamlessAdaptiveness;
     private int viewportWidth;
     private int viewportHeight;
     private boolean viewportOrientationMayChange;
+    // Audio
+    private int maxAudioChannelCount;
+    private int maxAudioBitrate;
+    private boolean exceedAudioConstraintsIfNecessary;
+    private boolean allowAudioMixedMimeTypeAdaptiveness;
+    private boolean allowAudioMixedSampleRateAdaptiveness;
+    // General
+    private boolean forceLowestBitrate;
+    private boolean forceHighestSupportedBitrate;
+    private boolean exceedRendererCapabilitiesIfNecessary;
     private int tunnelingAudioSessionId;
 
+    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
+    private final SparseBooleanArray rendererDisabledFlags;
+
     /** Creates a builder with default initial values. */
     public ParametersBuilder() {
       this(Parameters.DEFAULT);
@@ -193,223 +197,311 @@ public ParametersBuilder() {
      *     obtained.
      */
     private ParametersBuilder(Parameters initialValues) {
-      selectionOverrides = cloneSelectionOverrides(initialValues.selectionOverrides);
-      rendererDisabledFlags = initialValues.rendererDisabledFlags.clone();
-      preferredAudioLanguage = initialValues.preferredAudioLanguage;
-      preferredTextLanguage = initialValues.preferredTextLanguage;
-      selectUndeterminedTextLanguage = initialValues.selectUndeterminedTextLanguage;
-      disabledTextTrackSelectionFlags = initialValues.disabledTextTrackSelectionFlags;
-      forceLowestBitrate = initialValues.forceLowestBitrate;
-      forceHighestSupportedBitrate = initialValues.forceHighestSupportedBitrate;
-      allowMixedMimeAdaptiveness = initialValues.allowMixedMimeAdaptiveness;
-      allowNonSeamlessAdaptiveness = initialValues.allowNonSeamlessAdaptiveness;
+      super(initialValues);
+      // Video
       maxVideoWidth = initialValues.maxVideoWidth;
       maxVideoHeight = initialValues.maxVideoHeight;
       maxVideoFrameRate = initialValues.maxVideoFrameRate;
       maxVideoBitrate = initialValues.maxVideoBitrate;
       exceedVideoConstraintsIfNecessary = initialValues.exceedVideoConstraintsIfNecessary;
-      exceedRendererCapabilitiesIfNecessary = initialValues.exceedRendererCapabilitiesIfNecessary;
+      allowVideoMixedMimeTypeAdaptiveness = initialValues.allowVideoMixedMimeTypeAdaptiveness;
+      allowVideoNonSeamlessAdaptiveness = initialValues.allowVideoNonSeamlessAdaptiveness;
       viewportWidth = initialValues.viewportWidth;
       viewportHeight = initialValues.viewportHeight;
       viewportOrientationMayChange = initialValues.viewportOrientationMayChange;
+      // Audio
+      maxAudioChannelCount = initialValues.maxAudioChannelCount;
+      maxAudioBitrate = initialValues.maxAudioBitrate;
+      exceedAudioConstraintsIfNecessary = initialValues.exceedAudioConstraintsIfNecessary;
+      allowAudioMixedMimeTypeAdaptiveness = initialValues.allowAudioMixedMimeTypeAdaptiveness;
+      allowAudioMixedSampleRateAdaptiveness = initialValues.allowAudioMixedSampleRateAdaptiveness;
+      // General
+      forceLowestBitrate = initialValues.forceLowestBitrate;
+      forceHighestSupportedBitrate = initialValues.forceHighestSupportedBitrate;
+      exceedRendererCapabilitiesIfNecessary = initialValues.exceedRendererCapabilitiesIfNecessary;
       tunnelingAudioSessionId = initialValues.tunnelingAudioSessionId;
+      // Overrides
+      selectionOverrides = cloneSelectionOverrides(initialValues.selectionOverrides);
+      rendererDisabledFlags = initialValues.rendererDisabledFlags.clone();
     }
 
+    // Video
+
     /**
-     * See {@link Parameters#preferredAudioLanguage}.
+     * Equivalent to {@link #setMaxVideoSize setMaxVideoSize(1279, 719)}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setPreferredAudioLanguage(String preferredAudioLanguage) {
-      this.preferredAudioLanguage = preferredAudioLanguage;
-      return this;
+    public ParametersBuilder setMaxVideoSizeSd() {
+      return setMaxVideoSize(1279, 719);
     }
 
     /**
-     * See {@link Parameters#preferredTextLanguage}.
+     * Equivalent to {@link #setMaxVideoSize setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setPreferredTextLanguage(String preferredTextLanguage) {
-      this.preferredTextLanguage = preferredTextLanguage;
-      return this;
+    public ParametersBuilder clearVideoSizeConstraints() {
+      return setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
     }
 
     /**
-     * See {@link Parameters#selectUndeterminedTextLanguage}.
+     * See {@link Parameters#maxVideoWidth} and {@link Parameters#maxVideoHeight}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setSelectUndeterminedTextLanguage(
-        boolean selectUndeterminedTextLanguage) {
-      this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
+    public ParametersBuilder setMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
+      this.maxVideoWidth = maxVideoWidth;
+      this.maxVideoHeight = maxVideoHeight;
       return this;
     }
 
     /**
-     * See {@link Parameters#disabledTextTrackSelectionFlags}.
+     * See {@link Parameters#maxVideoFrameRate}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setDisabledTextTrackSelectionFlags(
-        int disabledTextTrackSelectionFlags) {
-      this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
+    public ParametersBuilder setMaxVideoFrameRate(int maxVideoFrameRate) {
+      this.maxVideoFrameRate = maxVideoFrameRate;
       return this;
     }
 
     /**
-     * See {@link Parameters#forceLowestBitrate}.
+     * See {@link Parameters#maxVideoBitrate}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setForceLowestBitrate(boolean forceLowestBitrate) {
-      this.forceLowestBitrate = forceLowestBitrate;
+    public ParametersBuilder setMaxVideoBitrate(int maxVideoBitrate) {
+      this.maxVideoBitrate = maxVideoBitrate;
       return this;
     }
 
     /**
-     * See {@link Parameters#forceHighestSupportedBitrate}.
+     * See {@link Parameters#exceedVideoConstraintsIfNecessary}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setForceHighestSupportedBitrate(boolean forceHighestSupportedBitrate) {
-      this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
+    public ParametersBuilder setExceedVideoConstraintsIfNecessary(
+        boolean exceedVideoConstraintsIfNecessary) {
+      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
       return this;
     }
 
     /**
-     * See {@link Parameters#allowMixedMimeAdaptiveness}.
+     * See {@link Parameters#allowVideoMixedMimeTypeAdaptiveness}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
-      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
+    public ParametersBuilder setAllowVideoMixedMimeTypeAdaptiveness(
+        boolean allowVideoMixedMimeTypeAdaptiveness) {
+      this.allowVideoMixedMimeTypeAdaptiveness = allowVideoMixedMimeTypeAdaptiveness;
       return this;
     }
 
     /**
-     * See {@link Parameters#allowNonSeamlessAdaptiveness}.
+     * See {@link Parameters#allowVideoNonSeamlessAdaptiveness}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
-      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+    public ParametersBuilder setAllowVideoNonSeamlessAdaptiveness(
+        boolean allowVideoNonSeamlessAdaptiveness) {
+      this.allowVideoNonSeamlessAdaptiveness = allowVideoNonSeamlessAdaptiveness;
       return this;
     }
 
     /**
-     * Equivalent to {@link #setMaxVideoSize setMaxVideoSize(1279, 719)}.
+     * Equivalent to calling {@link #setViewportSize(int, int, boolean)} with the viewport size
+     * obtained from {@link Util#getPhysicalDisplaySize(Context)}.
      *
+     * @param context Any context.
+     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
      * @return This builder.
      */
-    public ParametersBuilder setMaxVideoSizeSd() {
-      return setMaxVideoSize(1279, 719);
+    public ParametersBuilder setViewportSizeToPhysicalDisplaySize(
+        Context context, boolean viewportOrientationMayChange) {
+      // Assume the viewport is fullscreen.
+      Point viewportSize = Util.getPhysicalDisplaySize(context);
+      return setViewportSize(viewportSize.x, viewportSize.y, viewportOrientationMayChange);
     }
 
     /**
-     * Equivalent to {@link #setMaxVideoSize setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
+     * Equivalent to {@link #setViewportSize setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE,
+     * true)}.
      *
      * @return This builder.
      */
-    public ParametersBuilder clearVideoSizeConstraints() {
-      return setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
+    public ParametersBuilder clearViewportSizeConstraints() {
+      return setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
     }
 
     /**
-     * See {@link Parameters#maxVideoWidth} and {@link Parameters#maxVideoHeight}.
+     * See {@link Parameters#viewportWidth}, {@link Parameters#maxVideoHeight} and {@link
+     * Parameters#viewportOrientationMayChange}.
      *
+     * @param viewportWidth See {@link Parameters#viewportWidth}.
+     * @param viewportHeight See {@link Parameters#viewportHeight}.
+     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
      * @return This builder.
      */
-    public ParametersBuilder setMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
-      this.maxVideoWidth = maxVideoWidth;
-      this.maxVideoHeight = maxVideoHeight;
+    public ParametersBuilder setViewportSize(
+        int viewportWidth, int viewportHeight, boolean viewportOrientationMayChange) {
+      this.viewportWidth = viewportWidth;
+      this.viewportHeight = viewportHeight;
+      this.viewportOrientationMayChange = viewportOrientationMayChange;
+      return this;
+    }
+
+    // Audio
+
+    @Override
+    public ParametersBuilder setPreferredAudioLanguage(@Nullable String preferredAudioLanguage) {
+      super.setPreferredAudioLanguage(preferredAudioLanguage);
       return this;
     }
 
     /**
-     * See {@link Parameters#maxVideoFrameRate}.
+     * See {@link Parameters#maxAudioChannelCount}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setMaxVideoFrameRate(int maxVideoFrameRate) {
-      this.maxVideoFrameRate = maxVideoFrameRate;
+    public ParametersBuilder setMaxAudioChannelCount(int maxAudioChannelCount) {
+      this.maxAudioChannelCount = maxAudioChannelCount;
       return this;
     }
 
     /**
-     * See {@link Parameters#maxVideoBitrate}.
+     * See {@link Parameters#maxAudioBitrate}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setMaxVideoBitrate(int maxVideoBitrate) {
-      this.maxVideoBitrate = maxVideoBitrate;
+    public ParametersBuilder setMaxAudioBitrate(int maxAudioBitrate) {
+      this.maxAudioBitrate = maxAudioBitrate;
       return this;
     }
 
     /**
-     * See {@link Parameters#exceedVideoConstraintsIfNecessary}.
+     * See {@link Parameters#exceedAudioConstraintsIfNecessary}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setExceedVideoConstraintsIfNecessary(
-        boolean exceedVideoConstraintsIfNecessary) {
-      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+    public ParametersBuilder setExceedAudioConstraintsIfNecessary(
+        boolean exceedAudioConstraintsIfNecessary) {
+      this.exceedAudioConstraintsIfNecessary = exceedAudioConstraintsIfNecessary;
       return this;
     }
 
     /**
-     * See {@link Parameters#exceedRendererCapabilitiesIfNecessary}.
+     * See {@link Parameters#allowAudioMixedMimeTypeAdaptiveness}.
      *
      * @return This builder.
      */
-    public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
-        boolean exceedRendererCapabilitiesIfNecessary) {
-      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
+    public ParametersBuilder setAllowAudioMixedMimeTypeAdaptiveness(
+        boolean allowAudioMixedMimeTypeAdaptiveness) {
+      this.allowAudioMixedMimeTypeAdaptiveness = allowAudioMixedMimeTypeAdaptiveness;
       return this;
     }
 
     /**
-     * Equivalent to calling {@link #setViewportSize(int, int, boolean)} with the viewport size
-     * obtained from {@link Util#getPhysicalDisplaySize(Context)}.
+     * See {@link Parameters#allowAudioMixedSampleRateAdaptiveness}.
      *
-     * @param context Any context.
-     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
      * @return This builder.
      */
-    public ParametersBuilder setViewportSizeToPhysicalDisplaySize(
-        Context context, boolean viewportOrientationMayChange) {
-      // Assume the viewport is fullscreen.
-      Point viewportSize = Util.getPhysicalDisplaySize(context);
-      return setViewportSize(viewportSize.x, viewportSize.y, viewportOrientationMayChange);
+    public ParametersBuilder setAllowAudioMixedSampleRateAdaptiveness(
+        boolean allowAudioMixedSampleRateAdaptiveness) {
+      this.allowAudioMixedSampleRateAdaptiveness = allowAudioMixedSampleRateAdaptiveness;
+      return this;
+    }
+
+    // Text
+
+    @Override
+    public ParametersBuilder setPreferredTextLanguage(@Nullable String preferredTextLanguage) {
+      super.setPreferredTextLanguage(preferredTextLanguage);
+      return this;
+    }
+
+    @Override
+    public ParametersBuilder setSelectUndeterminedTextLanguage(
+        boolean selectUndeterminedTextLanguage) {
+      super.setSelectUndeterminedTextLanguage(selectUndeterminedTextLanguage);
+      return this;
+    }
+
+    @Override
+    public ParametersBuilder setDisabledTextTrackSelectionFlags(
+        @C.SelectionFlags int disabledTextTrackSelectionFlags) {
+      super.setDisabledTextTrackSelectionFlags(disabledTextTrackSelectionFlags);
+      return this;
     }
+    // General
 
     /**
-     * Equivalent to
-     * {@link #setViewportSize setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+     * See {@link Parameters#forceLowestBitrate}.
      *
      * @return This builder.
      */
-    public ParametersBuilder clearViewportSizeConstraints() {
-      return setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+    public ParametersBuilder setForceLowestBitrate(boolean forceLowestBitrate) {
+      this.forceLowestBitrate = forceLowestBitrate;
+      return this;
     }
 
     /**
-     * See {@link Parameters#viewportWidth}, {@link Parameters#maxVideoHeight} and {@link
-     * Parameters#viewportOrientationMayChange}.
+     * See {@link Parameters#forceHighestSupportedBitrate}.
      *
-     * @param viewportWidth See {@link Parameters#viewportWidth}.
-     * @param viewportHeight See {@link Parameters#viewportHeight}.
-     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
      * @return This builder.
      */
-    public ParametersBuilder setViewportSize(
-        int viewportWidth, int viewportHeight, boolean viewportOrientationMayChange) {
-      this.viewportWidth = viewportWidth;
-      this.viewportHeight = viewportHeight;
-      this.viewportOrientationMayChange = viewportOrientationMayChange;
+    public ParametersBuilder setForceHighestSupportedBitrate(boolean forceHighestSupportedBitrate) {
+      this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
       return this;
     }
 
+    /**
+     * @deprecated Use {@link #setAllowVideoMixedMimeTypeAdaptiveness(boolean)} and {@link
+     *     #setAllowAudioMixedMimeTypeAdaptiveness(boolean)}.
+     */
+    @Deprecated
+    public ParametersBuilder setAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
+      setAllowAudioMixedMimeTypeAdaptiveness(allowMixedMimeAdaptiveness);
+      setAllowVideoMixedMimeTypeAdaptiveness(allowMixedMimeAdaptiveness);
+      return this;
+    }
+
+    /** @deprecated Use {@link #setAllowVideoNonSeamlessAdaptiveness(boolean)} */
+    @Deprecated
+    public ParametersBuilder setAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
+      return setAllowVideoNonSeamlessAdaptiveness(allowNonSeamlessAdaptiveness);
+    }
+
+    /**
+     * See {@link Parameters#exceedRendererCapabilitiesIfNecessary}.
+     *
+     * @return This builder.
+     */
+    public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
+        boolean exceedRendererCapabilitiesIfNecessary) {
+      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
+      return this;
+    }
+
+    /**
+     * See {@link Parameters#tunnelingAudioSessionId}.
+     *
+     * <p>Enables or disables tunneling. To enable tunneling, pass an audio session id to use when
+     * in tunneling mode. Session ids can be generated using {@link
+     * C#generateAudioSessionIdV21(Context)}. To disable tunneling pass {@link
+     * C#AUDIO_SESSION_ID_UNSET}. Tunneling will only be activated if it's both enabled and
+     * supported by the audio and video renderers for the selected tracks.
+     *
+     * @param tunnelingAudioSessionId The audio session id to use when tunneling, or {@link
+     *     C#AUDIO_SESSION_ID_UNSET} to disable tunneling.
+     */
+    public ParametersBuilder setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
+      this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+      return this;
+    }
+
+    // Overrides
+
     /**
      * Sets whether the renderer at the specified index is disabled. Disabling a renderer prevents
      * the selector from selecting any tracks for it.
@@ -513,51 +605,40 @@ public final ParametersBuilder clearSelectionOverrides() {
       return this;
     }
 
-    /**
-     * See {@link Parameters#tunnelingAudioSessionId}.
-     *
-     * <p>Enables or disables tunneling. To enable tunneling, pass an audio session id to use when
-     * in tunneling mode. Session ids can be generated using {@link
-     * C#generateAudioSessionIdV21(Context)}. To disable tunneling pass {@link
-     * C#AUDIO_SESSION_ID_UNSET}. Tunneling will only be activated if it's both enabled and
-     * supported by the audio and video renderers for the selected tracks.
-     *
-     * @param tunnelingAudioSessionId The audio session id to use when tunneling, or {@link
-     *     C#AUDIO_SESSION_ID_UNSET} to disable tunneling.
-     */
-    public ParametersBuilder setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
-      if (this.tunnelingAudioSessionId != tunnelingAudioSessionId) {
-        this.tunnelingAudioSessionId = tunnelingAudioSessionId;
-        return this;
-      }
-      return this;
-    }
-
     /**
      * Builds a {@link Parameters} instance with the selected values.
      */
     public Parameters build() {
       return new Parameters(
-          selectionOverrides,
-          rendererDisabledFlags,
-          preferredAudioLanguage,
-          preferredTextLanguage,
-          selectUndeterminedTextLanguage,
-          disabledTextTrackSelectionFlags,
-          forceLowestBitrate,
-          forceHighestSupportedBitrate,
-          allowMixedMimeAdaptiveness,
-          allowNonSeamlessAdaptiveness,
+          // Video
           maxVideoWidth,
           maxVideoHeight,
           maxVideoFrameRate,
           maxVideoBitrate,
           exceedVideoConstraintsIfNecessary,
-          exceedRendererCapabilitiesIfNecessary,
+          allowVideoMixedMimeTypeAdaptiveness,
+          allowVideoNonSeamlessAdaptiveness,
           viewportWidth,
           viewportHeight,
           viewportOrientationMayChange,
-          tunnelingAudioSessionId);
+          // Audio
+          preferredAudioLanguage,
+          maxAudioChannelCount,
+          maxAudioBitrate,
+          exceedAudioConstraintsIfNecessary,
+          allowAudioMixedMimeTypeAdaptiveness,
+          allowAudioMixedSampleRateAdaptiveness,
+          // Text
+          preferredTextLanguage,
+          selectUndeterminedTextLanguage,
+          disabledTextTrackSelectionFlags,
+          // General
+          forceLowestBitrate,
+          forceHighestSupportedBitrate,
+          exceedRendererCapabilitiesIfNecessary,
+          tunnelingAudioSessionId,
+          selectionOverrides,
+          rendererDisabledFlags);
     }
 
     private static SparseArray<Map<TrackGroupArray, SelectionOverride>> cloneSelectionOverrides(
@@ -570,43 +651,15 @@ public Parameters build() {
     }
   }
 
-  /** Constraint parameters for {@link DefaultTrackSelector}. */
-  public static final class Parameters implements Parcelable {
+  /**
+   * Extends {@link TrackSelectionParameters} by adding fields that are specific to {@link
+   * DefaultTrackSelector}.
+   */
+  public static final class Parameters extends TrackSelectionParameters {
 
     /** An instance with default values. */
     public static final Parameters DEFAULT = new Parameters();
 
-    // Per renderer overrides.
-
-    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
-    private final SparseBooleanArray rendererDisabledFlags;
-
-    // Audio
-    /**
-     * The preferred language for audio and forced text tracks, as an ISO 639-2/T tag. {@code null}
-     * selects the default track, or the first track if there's no default. The default value is
-     * {@code null}.
-     */
-    public final @Nullable String preferredAudioLanguage;
-
-    // Text
-    /**
-     * The preferred language for text tracks as an ISO 639-2/T tag. {@code null} selects the
-     * default track if there is one, or no track otherwise. The default value is {@code null}.
-     */
-    public final @Nullable String preferredTextLanguage;
-    /**
-     * Whether a text track with undetermined language should be selected if no track with {@link
-     * #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset. The
-     * default value is {@code false}.
-     */
-    public final boolean selectUndeterminedTextLanguage;
-    /**
-     * Bitmask of selection flags that are disabled for text track selections. See {@link
-     * C.SelectionFlags}. The default value is {@code 0} (i.e. no flags).
-     */
-    public final int disabledTextTrackSelectionFlags;
-
     // Video
     /**
      * Maximum allowed video width. The default value is {@link Integer#MAX_VALUE} (i.e. no
@@ -641,6 +694,18 @@ public Parameters build() {
      * {@code true}.
      */
     public final boolean exceedVideoConstraintsIfNecessary;
+    /**
+     * Whether to allow adaptive video selections containing mixed mime types. Adaptations between
+     * different mime types may not be completely seamless, in which case {@link
+     * #allowVideoNonSeamlessAdaptiveness} also needs to be {@code true} for mixed mime type
+     * selections to be made. The default value is {@code false}.
+     */
+    public final boolean allowVideoMixedMimeTypeAdaptiveness;
+    /**
+     * Whether to allow adaptive video selections where adaptation may not be completely seamless.
+     * The default value is {@code true}.
+     */
+    public final boolean allowVideoNonSeamlessAdaptiveness;
     /**
      * Viewport width in pixels. Constrains video track selections for adaptive content so that only
      * tracks suitable for the viewport are selected. The default value is {@link Integer#MAX_VALUE}
@@ -659,6 +724,31 @@ public Parameters build() {
      * The default value is {@code true}.
      */
     public final boolean viewportOrientationMayChange;
+    // Audio
+    /**
+     * Maximum allowed audio channel count. The default value is {@link Integer#MAX_VALUE} (i.e. no
+     * constraint).
+     */
+    public final int maxAudioChannelCount;
+    /**
+     * Maximum audio bitrate. The default value is {@link Integer#MAX_VALUE} (i.e. no constraint).
+     */
+    public final int maxAudioBitrate;
+    /**
+     * Whether to exceed the {@link #maxAudioChannelCount} and {@link #maxAudioBitrate} constraints
+     * when no selection can be made otherwise. The default value is {@code true}.
+     */
+    public final boolean exceedAudioConstraintsIfNecessary;
+    /**
+     * Whether to allow adaptive audio selections containing mixed mime types. Adaptations between
+     * different mime types may not be completely seamless. The default value is {@code false}.
+     */
+    public final boolean allowAudioMixedMimeTypeAdaptiveness;
+    /**
+     * Whether to allow adaptive audio selections containing mixed sample rates. Adaptations between
+     * different sample rates may not be completely seamless. The default value is {@code false}.
+     */
+    public final boolean allowAudioMixedSampleRateAdaptiveness;
 
     // General
     /**
@@ -672,15 +762,12 @@ public Parameters build() {
      */
     public final boolean forceHighestSupportedBitrate;
     /**
-     * Whether to allow adaptive selections containing mixed mime types. The default value is {@code
-     * false}.
+     * @deprecated Use {@link #allowVideoMixedMimeTypeAdaptiveness} and {@link
+     *     #allowAudioMixedMimeTypeAdaptiveness}.
      */
-    public final boolean allowMixedMimeAdaptiveness;
-    /**
-     * Whether to allow adaptive selections where adaptation may not be completely seamless. The
-     * default value is {@code true}.
-     */
-    public final boolean allowNonSeamlessAdaptiveness;
+    @Deprecated public final boolean allowMixedMimeAdaptiveness;
+    /** @deprecated Use {@link #allowVideoNonSeamlessAdaptiveness}. */
+    @Deprecated public final boolean allowNonSeamlessAdaptiveness;
     /**
      * Whether to exceed renderer capabilities when no selection can be made otherwise.
      *
@@ -698,94 +785,140 @@ public Parameters build() {
      */
     public final int tunnelingAudioSessionId;
 
+    // Overrides
+    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
+    private final SparseBooleanArray rendererDisabledFlags;
+
     private Parameters() {
       this(
-          /* selectionOverrides= */ new SparseArray<>(),
-          /* rendererDisabledFlags= */ new SparseBooleanArray(),
-          /* preferredAudioLanguage= */ null,
-          /* preferredTextLanguage= */ null,
-          /* selectUndeterminedTextLanguage= */ false,
-          /* disabledTextTrackSelectionFlags= */ 0,
-          /* forceLowestBitrate= */ false,
-          /* forceHighestSupportedBitrate= */ false,
-          /* allowMixedMimeAdaptiveness= */ false,
-          /* allowNonSeamlessAdaptiveness= */ true,
+          // Video
           /* maxVideoWidth= */ Integer.MAX_VALUE,
           /* maxVideoHeight= */ Integer.MAX_VALUE,
           /* maxVideoFrameRate= */ Integer.MAX_VALUE,
           /* maxVideoBitrate= */ Integer.MAX_VALUE,
           /* exceedVideoConstraintsIfNecessary= */ true,
-          /* exceedRendererCapabilitiesIfNecessary= */ true,
+          /* allowVideoMixedMimeTypeAdaptiveness= */ false,
+          /* allowVideoNonSeamlessAdaptiveness= */ true,
           /* viewportWidth= */ Integer.MAX_VALUE,
           /* viewportHeight= */ Integer.MAX_VALUE,
           /* viewportOrientationMayChange= */ true,
-          /* tunnelingAudioSessionId= */ C.AUDIO_SESSION_ID_UNSET);
+          // Audio
+          TrackSelectionParameters.DEFAULT.preferredAudioLanguage,
+          /* maxAudioChannelCount= */ Integer.MAX_VALUE,
+          /* maxAudioBitrate= */ Integer.MAX_VALUE,
+          /* exceedAudioConstraintsIfNecessary= */ true,
+          /* allowAudioMixedMimeTypeAdaptiveness= */ false,
+          /* allowAudioMixedSampleRateAdaptiveness= */ false,
+          // Text
+          TrackSelectionParameters.DEFAULT.preferredTextLanguage,
+          TrackSelectionParameters.DEFAULT.selectUndeterminedTextLanguage,
+          TrackSelectionParameters.DEFAULT.disabledTextTrackSelectionFlags,
+          // General
+          /* forceLowestBitrate= */ false,
+          /* forceHighestSupportedBitrate= */ false,
+          /* exceedRendererCapabilitiesIfNecessary= */ true,
+          /* tunnelingAudioSessionId= */ C.AUDIO_SESSION_ID_UNSET,
+          new SparseArray<>(),
+          new SparseBooleanArray());
     }
 
     /* package */ Parameters(
-        SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides,
-        SparseBooleanArray rendererDisabledFlags,
-        @Nullable String preferredAudioLanguage,
-        @Nullable String preferredTextLanguage,
-        boolean selectUndeterminedTextLanguage,
-        int disabledTextTrackSelectionFlags,
-        boolean forceLowestBitrate,
-        boolean forceHighestSupportedBitrate,
-        boolean allowMixedMimeAdaptiveness,
-        boolean allowNonSeamlessAdaptiveness,
+        // Video
         int maxVideoWidth,
         int maxVideoHeight,
         int maxVideoFrameRate,
         int maxVideoBitrate,
         boolean exceedVideoConstraintsIfNecessary,
-        boolean exceedRendererCapabilitiesIfNecessary,
+        boolean allowVideoMixedMimeTypeAdaptiveness,
+        boolean allowVideoNonSeamlessAdaptiveness,
         int viewportWidth,
         int viewportHeight,
         boolean viewportOrientationMayChange,
-        int tunnelingAudioSessionId) {
-      this.selectionOverrides = selectionOverrides;
-      this.rendererDisabledFlags = rendererDisabledFlags;
-      this.preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
-      this.preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
-      this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
-      this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
-      this.forceLowestBitrate = forceLowestBitrate;
-      this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
-      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
-      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+        // Audio
+        @Nullable String preferredAudioLanguage,
+        int maxAudioChannelCount,
+        int maxAudioBitrate,
+        boolean exceedAudioConstraintsIfNecessary,
+        boolean allowAudioMixedMimeTypeAdaptiveness,
+        boolean allowAudioMixedSampleRateAdaptiveness,
+        // Text
+        @Nullable String preferredTextLanguage,
+        boolean selectUndeterminedTextLanguage,
+        @C.SelectionFlags int disabledTextTrackSelectionFlags,
+        // General
+        boolean forceLowestBitrate,
+        boolean forceHighestSupportedBitrate,
+        boolean exceedRendererCapabilitiesIfNecessary,
+        int tunnelingAudioSessionId,
+        // Overrides
+        SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides,
+        SparseBooleanArray rendererDisabledFlags) {
+      super(
+          preferredAudioLanguage,
+          preferredTextLanguage,
+          selectUndeterminedTextLanguage,
+          disabledTextTrackSelectionFlags);
+      // Video
       this.maxVideoWidth = maxVideoWidth;
       this.maxVideoHeight = maxVideoHeight;
       this.maxVideoFrameRate = maxVideoFrameRate;
       this.maxVideoBitrate = maxVideoBitrate;
       this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
-      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
+      this.allowVideoMixedMimeTypeAdaptiveness = allowVideoMixedMimeTypeAdaptiveness;
+      this.allowVideoNonSeamlessAdaptiveness = allowVideoNonSeamlessAdaptiveness;
       this.viewportWidth = viewportWidth;
       this.viewportHeight = viewportHeight;
       this.viewportOrientationMayChange = viewportOrientationMayChange;
+      // Audio
+      this.maxAudioChannelCount = maxAudioChannelCount;
+      this.maxAudioBitrate = maxAudioBitrate;
+      this.exceedAudioConstraintsIfNecessary = exceedAudioConstraintsIfNecessary;
+      this.allowAudioMixedMimeTypeAdaptiveness = allowAudioMixedMimeTypeAdaptiveness;
+      this.allowAudioMixedSampleRateAdaptiveness = allowAudioMixedSampleRateAdaptiveness;
+      // General
+      this.forceLowestBitrate = forceLowestBitrate;
+      this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
+      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
       this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+      // Deprecated fields.
+      this.allowMixedMimeAdaptiveness = allowVideoMixedMimeTypeAdaptiveness;
+      this.allowNonSeamlessAdaptiveness = allowVideoNonSeamlessAdaptiveness;
+      // Overrides
+      this.selectionOverrides = selectionOverrides;
+      this.rendererDisabledFlags = rendererDisabledFlags;
     }
 
-    /* package */ Parameters(Parcel in) {
-      this.selectionOverrides = readSelectionOverrides(in);
-      this.rendererDisabledFlags = in.readSparseBooleanArray();
-      this.preferredAudioLanguage = in.readString();
-      this.preferredTextLanguage = in.readString();
-      this.selectUndeterminedTextLanguage = Util.readBoolean(in);
-      this.disabledTextTrackSelectionFlags = in.readInt();
-      this.forceLowestBitrate = Util.readBoolean(in);
-      this.forceHighestSupportedBitrate = Util.readBoolean(in);
-      this.allowMixedMimeAdaptiveness = Util.readBoolean(in);
-      this.allowNonSeamlessAdaptiveness = Util.readBoolean(in);
+    /* package */
+    Parameters(Parcel in) {
+      super(in);
+      // Video
       this.maxVideoWidth = in.readInt();
       this.maxVideoHeight = in.readInt();
       this.maxVideoFrameRate = in.readInt();
       this.maxVideoBitrate = in.readInt();
       this.exceedVideoConstraintsIfNecessary = Util.readBoolean(in);
-      this.exceedRendererCapabilitiesIfNecessary = Util.readBoolean(in);
+      this.allowVideoMixedMimeTypeAdaptiveness = Util.readBoolean(in);
+      this.allowVideoNonSeamlessAdaptiveness = Util.readBoolean(in);
       this.viewportWidth = in.readInt();
       this.viewportHeight = in.readInt();
       this.viewportOrientationMayChange = Util.readBoolean(in);
+      // Audio
+      this.maxAudioChannelCount = in.readInt();
+      this.maxAudioBitrate = in.readInt();
+      this.exceedAudioConstraintsIfNecessary = Util.readBoolean(in);
+      this.allowAudioMixedMimeTypeAdaptiveness = Util.readBoolean(in);
+      this.allowAudioMixedSampleRateAdaptiveness = Util.readBoolean(in);
+      // General
+      this.forceLowestBitrate = Util.readBoolean(in);
+      this.forceHighestSupportedBitrate = Util.readBoolean(in);
+      this.exceedRendererCapabilitiesIfNecessary = Util.readBoolean(in);
       this.tunnelingAudioSessionId = in.readInt();
+      // Overrides
+      this.selectionOverrides = readSelectionOverrides(in);
+      this.rendererDisabledFlags = Util.castNonNull(in.readSparseBooleanArray());
+      // Deprecated fields.
+      this.allowMixedMimeAdaptiveness = allowVideoMixedMimeTypeAdaptiveness;
+      this.allowNonSeamlessAdaptiveness = allowVideoNonSeamlessAdaptiveness;
     }
 
     /**
@@ -817,15 +950,14 @@ public final boolean hasSelectionOverride(int rendererIndex, TrackGroupArray gro
      * @param groups The {@link TrackGroupArray}.
      * @return The override, or null if no override exists.
      */
-    public final @Nullable SelectionOverride getSelectionOverride(
-        int rendererIndex, TrackGroupArray groups) {
+    @Nullable
+    public final SelectionOverride getSelectionOverride(int rendererIndex, TrackGroupArray groups) {
       Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
       return overrides != null ? overrides.get(groups) : null;
     }
 
-    /**
-     * Creates a new {@link ParametersBuilder}, copying the initial values from this instance.
-     */
+    /** Creates a new {@link ParametersBuilder}, copying the initial values from this instance. */
+    @Override
     public ParametersBuilder buildUpon() {
       return new ParametersBuilder(this);
     }
@@ -839,49 +971,60 @@ public boolean equals(@Nullable Object obj) {
         return false;
       }
       Parameters other = (Parameters) obj;
-      return selectUndeterminedTextLanguage == other.selectUndeterminedTextLanguage
-          && disabledTextTrackSelectionFlags == other.disabledTextTrackSelectionFlags
-          && forceLowestBitrate == other.forceLowestBitrate
-          && forceHighestSupportedBitrate == other.forceHighestSupportedBitrate
-          && allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
-          && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
+      return super.equals(obj)
+          // Video
           && maxVideoWidth == other.maxVideoWidth
           && maxVideoHeight == other.maxVideoHeight
           && maxVideoFrameRate == other.maxVideoFrameRate
+          && maxVideoBitrate == other.maxVideoBitrate
           && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
-          && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
+          && allowVideoMixedMimeTypeAdaptiveness == other.allowVideoMixedMimeTypeAdaptiveness
+          && allowVideoNonSeamlessAdaptiveness == other.allowVideoNonSeamlessAdaptiveness
           && viewportOrientationMayChange == other.viewportOrientationMayChange
           && viewportWidth == other.viewportWidth
           && viewportHeight == other.viewportHeight
-          && maxVideoBitrate == other.maxVideoBitrate
+          // Audio
+          && maxAudioChannelCount == other.maxAudioChannelCount
+          && maxAudioBitrate == other.maxAudioBitrate
+          && exceedAudioConstraintsIfNecessary == other.exceedAudioConstraintsIfNecessary
+          && allowAudioMixedMimeTypeAdaptiveness == other.allowAudioMixedMimeTypeAdaptiveness
+          && allowAudioMixedSampleRateAdaptiveness == other.allowAudioMixedSampleRateAdaptiveness
+          // General
+          && forceLowestBitrate == other.forceLowestBitrate
+          && forceHighestSupportedBitrate == other.forceHighestSupportedBitrate
+          && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
           && tunnelingAudioSessionId == other.tunnelingAudioSessionId
-          && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
-          && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage)
+          // Overrides
           && areRendererDisabledFlagsEqual(rendererDisabledFlags, other.rendererDisabledFlags)
           && areSelectionOverridesEqual(selectionOverrides, other.selectionOverrides);
     }
 
     @Override
     public int hashCode() {
-      int result = selectUndeterminedTextLanguage ? 1 : 0;
-      result = 31 * result + disabledTextTrackSelectionFlags;
-      result = 31 * result + (forceLowestBitrate ? 1 : 0);
-      result = 31 * result + (forceHighestSupportedBitrate ? 1 : 0);
-      result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
-      result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
+      int result = super.hashCode();
+      // Video
       result = 31 * result + maxVideoWidth;
       result = 31 * result + maxVideoHeight;
       result = 31 * result + maxVideoFrameRate;
+      result = 31 * result + maxVideoBitrate;
       result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
-      result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
+      result = 31 * result + (allowVideoMixedMimeTypeAdaptiveness ? 1 : 0);
+      result = 31 * result + (allowVideoNonSeamlessAdaptiveness ? 1 : 0);
       result = 31 * result + (viewportOrientationMayChange ? 1 : 0);
       result = 31 * result + viewportWidth;
       result = 31 * result + viewportHeight;
-      result = 31 * result + maxVideoBitrate;
+      // Audio
+      result = 31 * result + maxAudioChannelCount;
+      result = 31 * result + maxAudioBitrate;
+      result = 31 * result + (exceedAudioConstraintsIfNecessary ? 1 : 0);
+      result = 31 * result + (allowAudioMixedMimeTypeAdaptiveness ? 1 : 0);
+      result = 31 * result + (allowAudioMixedSampleRateAdaptiveness ? 1 : 0);
+      // General
+      result = 31 * result + (forceLowestBitrate ? 1 : 0);
+      result = 31 * result + (forceHighestSupportedBitrate ? 1 : 0);
+      result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
       result = 31 * result + tunnelingAudioSessionId;
-      result =
-          31 * result + (preferredAudioLanguage == null ? 0 : preferredAudioLanguage.hashCode());
-      result = 31 * result + (preferredTextLanguage == null ? 0 : preferredTextLanguage.hashCode());
+      // Overrides (omitted from hashCode).
       return result;
     }
 
@@ -894,26 +1037,32 @@ public int describeContents() {
 
     @Override
     public void writeToParcel(Parcel dest, int flags) {
-      writeSelectionOverridesToParcel(dest, selectionOverrides);
-      dest.writeSparseBooleanArray(rendererDisabledFlags);
-      dest.writeString(preferredAudioLanguage);
-      dest.writeString(preferredTextLanguage);
-      Util.writeBoolean(dest, selectUndeterminedTextLanguage);
-      dest.writeInt(disabledTextTrackSelectionFlags);
-      Util.writeBoolean(dest, forceLowestBitrate);
-      Util.writeBoolean(dest, forceHighestSupportedBitrate);
-      Util.writeBoolean(dest, allowMixedMimeAdaptiveness);
-      Util.writeBoolean(dest, allowNonSeamlessAdaptiveness);
+      super.writeToParcel(dest, flags);
+      // Video
       dest.writeInt(maxVideoWidth);
       dest.writeInt(maxVideoHeight);
       dest.writeInt(maxVideoFrameRate);
       dest.writeInt(maxVideoBitrate);
       Util.writeBoolean(dest, exceedVideoConstraintsIfNecessary);
-      Util.writeBoolean(dest, exceedRendererCapabilitiesIfNecessary);
+      Util.writeBoolean(dest, allowVideoMixedMimeTypeAdaptiveness);
+      Util.writeBoolean(dest, allowVideoNonSeamlessAdaptiveness);
       dest.writeInt(viewportWidth);
       dest.writeInt(viewportHeight);
       Util.writeBoolean(dest, viewportOrientationMayChange);
+      // Audio
+      dest.writeInt(maxAudioChannelCount);
+      dest.writeInt(maxAudioBitrate);
+      Util.writeBoolean(dest, exceedAudioConstraintsIfNecessary);
+      Util.writeBoolean(dest, allowAudioMixedMimeTypeAdaptiveness);
+      Util.writeBoolean(dest, allowAudioMixedSampleRateAdaptiveness);
+      // General
+      Util.writeBoolean(dest, forceLowestBitrate);
+      Util.writeBoolean(dest, forceHighestSupportedBitrate);
+      Util.writeBoolean(dest, exceedRendererCapabilitiesIfNecessary);
       dest.writeInt(tunnelingAudioSessionId);
+      // Overrides
+      writeSelectionOverridesToParcel(dest, selectionOverrides);
+      dest.writeSparseBooleanArray(rendererDisabledFlags);
     }
 
     public static final Parcelable.Creator<Parameters> CREATOR =
@@ -1024,15 +1173,29 @@ private static boolean areSelectionOverridesEqual(
     public final int groupIndex;
     public final int[] tracks;
     public final int length;
+    public final int reason;
+    public final int data;
 
     /**
      * @param groupIndex The overriding track group index.
      * @param tracks The overriding track indices within the track group.
      */
     public SelectionOverride(int groupIndex, int... tracks) {
+      this(groupIndex, tracks, C.SELECTION_REASON_MANUAL, /* data= */ 0);
+    }
+
+    /**
+     * @param groupIndex The overriding track group index.
+     * @param tracks The overriding track indices within the track group.
+     * @param reason The reason for the override. One of the {@link C} SELECTION_REASON_ constants.
+     * @param data Optional data associated with this override.
+     */
+    public SelectionOverride(int groupIndex, int[] tracks, int reason, int data) {
       this.groupIndex = groupIndex;
       this.tracks = Arrays.copyOf(tracks, tracks.length);
       this.length = tracks.length;
+      this.reason = reason;
+      this.data = data;
       Arrays.sort(this.tracks);
     }
 
@@ -1041,6 +1204,8 @@ public SelectionOverride(int groupIndex, int... tracks) {
       length = in.readByte();
       tracks = new int[length];
       in.readIntArray(tracks);
+      reason = in.readInt();
+      data = in.readInt();
     }
 
     /** Returns whether this override contains the specified track index. */
@@ -1055,7 +1220,9 @@ public boolean containsTrack(int track) {
 
     @Override
     public int hashCode() {
-      return 31 * groupIndex + Arrays.hashCode(tracks);
+      int hash = 31 * groupIndex + Arrays.hashCode(tracks);
+      hash = 31 * hash + reason;
+      return 31 * hash + data;
     }
 
     @Override
@@ -1067,7 +1234,10 @@ public boolean equals(@Nullable Object obj) {
         return false;
       }
       SelectionOverride other = (SelectionOverride) obj;
-      return groupIndex == other.groupIndex && Arrays.equals(tracks, other.tracks);
+      return groupIndex == other.groupIndex
+          && Arrays.equals(tracks, other.tracks)
+          && reason == other.reason
+          && data == other.data;
     }
 
     // Parcelable implementation.
@@ -1082,6 +1252,8 @@ public void writeToParcel(Parcel dest, int flags) {
       dest.writeInt(groupIndex);
       dest.writeInt(tracks.length);
       dest.writeIntArray(tracks);
+      dest.writeInt(reason);
+      dest.writeInt(data);
     }
 
     public static final Parcelable.Creator<SelectionOverride> CREATOR =
@@ -1108,10 +1280,11 @@ public SelectionOverride createFromParcel(Parcel in) {
   private static final int[] NO_TRACKS = new int[0];
   private static final int WITHIN_RENDERER_CAPABILITIES_BONUS = 1000;
 
-  private final TrackSelection.Factory adaptiveTrackSelectionFactory;
+  private final TrackSelection.Factory trackSelectionFactory;
   private final AtomicReference<Parameters> parametersReference;
 
-  /** Constructs an instance that uses a default factory to create adaptive track selections. */
+  private boolean allowMultipleAdaptiveSelections;
+
   public DefaultTrackSelector() {
     this(new AdaptiveTrackSelection.Factory());
   }
@@ -1126,13 +1299,9 @@ public DefaultTrackSelector(BandwidthMeter bandwidthMeter) {
     this(new AdaptiveTrackSelection.Factory(bandwidthMeter));
   }
 
-  /**
-   * Constructs an instance that uses a factory to create adaptive track selections.
-   *
-   * @param adaptiveTrackSelectionFactory A factory for adaptive {@link TrackSelection}s.
-   */
-  public DefaultTrackSelector(TrackSelection.Factory adaptiveTrackSelectionFactory) {
-    this.adaptiveTrackSelectionFactory = adaptiveTrackSelectionFactory;
+  /** @param trackSelectionFactory A factory for {@link TrackSelection}s. */
+  public DefaultTrackSelector(TrackSelection.Factory trackSelectionFactory) {
+    this.trackSelectionFactory = trackSelectionFactory;
     parametersReference = new AtomicReference<>(Parameters.DEFAULT);
   }
 
@@ -1201,8 +1370,8 @@ public final boolean hasSelectionOverride(int rendererIndex, TrackGroupArray gro
 
   /** @deprecated Use {@link Parameters#getSelectionOverride(int, TrackGroupArray)}. */
   @Deprecated
-  public final @Nullable SelectionOverride getSelectionOverride(
-      int rendererIndex, TrackGroupArray groups) {
+  @Nullable
+  public final SelectionOverride getSelectionOverride(int rendererIndex, TrackGroupArray groups) {
     return getParameters().getSelectionOverride(rendererIndex, groups);
   }
 
@@ -1230,6 +1399,15 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
     setParameters(buildUponParameters().setTunnelingAudioSessionId(tunnelingAudioSessionId));
   }
 
+  /**
+   * Allows the creation of multiple adaptive track selections.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release.
+   */
+  public void experimental_allowMultipleAdaptiveSelections() {
+    this.allowMultipleAdaptiveSelections = true;
+  }
+
   // MappingTrackSelector implementation.
 
   @Override
@@ -1241,7 +1419,7 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
           throws ExoPlaybackException {
     Parameters params = parametersReference.get();
     int rendererCount = mappedTrackInfo.getRendererCount();
-    @NullableType TrackSelection[] rendererTrackSelections =
+    TrackSelection.@NullableType Definition[] definitions =
         selectAllTracks(
             mappedTrackInfo,
             rendererFormatSupports,
@@ -1251,29 +1429,27 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
     // Apply track disabling and overriding.
     for (int i = 0; i < rendererCount; i++) {
       if (params.getRendererDisabled(i)) {
-        rendererTrackSelections[i] = null;
-      } else {
-        TrackGroupArray rendererTrackGroups = mappedTrackInfo.getTrackGroups(i);
-        if (params.hasSelectionOverride(i, rendererTrackGroups)) {
-          SelectionOverride override = params.getSelectionOverride(i, rendererTrackGroups);
-          if (override == null) {
-            rendererTrackSelections[i] = null;
-          } else if (override.length == 1) {
-            rendererTrackSelections[i] =
-                new FixedTrackSelection(
-                    rendererTrackGroups.get(override.groupIndex), override.tracks[0]);
-          } else {
-            rendererTrackSelections[i] =
-                Assertions.checkNotNull(adaptiveTrackSelectionFactory)
-                    .createTrackSelection(
-                        rendererTrackGroups.get(override.groupIndex),
-                        getBandwidthMeter(),
-                        override.tracks);
-          }
-        }
+        definitions[i] = null;
+        continue;
+      }
+      TrackGroupArray rendererTrackGroups = mappedTrackInfo.getTrackGroups(i);
+      if (params.hasSelectionOverride(i, rendererTrackGroups)) {
+        SelectionOverride override = params.getSelectionOverride(i, rendererTrackGroups);
+        definitions[i] =
+            override == null
+                ? null
+                : new TrackSelection.Definition(
+                    rendererTrackGroups.get(override.groupIndex),
+                    override.tracks,
+                    override.reason,
+                    override.data);
       }
     }
 
+    @NullableType
+    TrackSelection[] rendererTrackSelections =
+        trackSelectionFactory.createTrackSelections(definitions, getBandwidthMeter());
+
     // Initialize the renderer configurations to the default configuration for all renderers with
     // selections, and null otherwise.
     @NullableType RendererConfiguration[] rendererConfigurations =
@@ -1312,91 +1488,106 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
    *     each mapped track, indexed by renderer, track group and track (in that order).
    * @param rendererMixedMimeTypeAdaptationSupports The result of {@link
    *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
-   * @return Track selections for each renderer. A null selection indicates the renderer should be
-   *     disabled, unless RendererCapabilities#getTrackType()} is {@link C#TRACK_TYPE_NONE}.
+   * @return The {@link TrackSelection.Definition}s for the renderers. A null entry indicates no
+   *     selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @NullableType TrackSelection[] selectAllTracks(
+  protected TrackSelection.@NullableType Definition[] selectAllTracks(
       MappedTrackInfo mappedTrackInfo,
       int[][][] rendererFormatSupports,
       int[] rendererMixedMimeTypeAdaptationSupports,
       Parameters params)
       throws ExoPlaybackException {
     int rendererCount = mappedTrackInfo.getRendererCount();
-    @NullableType TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCount];
+    TrackSelection.@NullableType Definition[] definitions =
+        new TrackSelection.Definition[rendererCount];
 
     boolean seenVideoRendererWithMappedTracks = false;
     boolean selectedVideoTracks = false;
     for (int i = 0; i < rendererCount; i++) {
       if (C.TRACK_TYPE_VIDEO == mappedTrackInfo.getRendererType(i)) {
         if (!selectedVideoTracks) {
-          rendererTrackSelections[i] =
+          definitions[i] =
               selectVideoTrack(
                   mappedTrackInfo.getTrackGroups(i),
                   rendererFormatSupports[i],
                   rendererMixedMimeTypeAdaptationSupports[i],
                   params,
-                  adaptiveTrackSelectionFactory);
-          selectedVideoTracks = rendererTrackSelections[i] != null;
+                  /* enableAdaptiveTrackSelection= */ true);
+          selectedVideoTracks = definitions[i] != null;
         }
         seenVideoRendererWithMappedTracks |= mappedTrackInfo.getTrackGroups(i).length > 0;
       }
     }
 
     AudioTrackScore selectedAudioTrackScore = null;
+    String selectedAudioLanguage = null;
     int selectedAudioRendererIndex = C.INDEX_UNSET;
+    for (int i = 0; i < rendererCount; i++) {
+      if (C.TRACK_TYPE_AUDIO == mappedTrackInfo.getRendererType(i)) {
+        boolean enableAdaptiveTrackSelection =
+            allowMultipleAdaptiveSelections || !seenVideoRendererWithMappedTracks;
+        Pair<TrackSelection.Definition, AudioTrackScore> audioSelection =
+            selectAudioTrack(
+                mappedTrackInfo.getTrackGroups(i),
+                rendererFormatSupports[i],
+                rendererMixedMimeTypeAdaptationSupports[i],
+                params,
+                enableAdaptiveTrackSelection);
+        if (audioSelection != null
+            && (selectedAudioTrackScore == null
+                || audioSelection.second.compareTo(selectedAudioTrackScore) > 0)) {
+          if (selectedAudioRendererIndex != C.INDEX_UNSET) {
+            // We've already made a selection for another audio renderer, but it had a lower
+            // score. Clear the selection for that renderer.
+            definitions[selectedAudioRendererIndex] = null;
+          }
+          TrackSelection.Definition definition = audioSelection.first;
+          definitions[i] = definition;
+          // We assume that audio tracks in the same group have matching language.
+          selectedAudioLanguage = definition.group.getFormat(definition.tracks[0]).language;
+          selectedAudioTrackScore = audioSelection.second;
+          selectedAudioRendererIndex = i;
+        }
+      }
+    }
+
     int selectedTextTrackScore = Integer.MIN_VALUE;
     int selectedTextRendererIndex = C.INDEX_UNSET;
     for (int i = 0; i < rendererCount; i++) {
       int trackType = mappedTrackInfo.getRendererType(i);
       switch (trackType) {
         case C.TRACK_TYPE_VIDEO:
+        case C.TRACK_TYPE_AUDIO:
           // Already done. Do nothing.
           break;
-        case C.TRACK_TYPE_AUDIO:
-          Pair<TrackSelection, AudioTrackScore> audioSelection =
-              selectAudioTrack(
+        case C.TRACK_TYPE_TEXT:
+          Pair<TrackSelection.Definition, Integer> textSelection =
+              selectTextTrack(
                   mappedTrackInfo.getTrackGroups(i),
                   rendererFormatSupports[i],
-                  rendererMixedMimeTypeAdaptationSupports[i],
                   params,
-                  seenVideoRendererWithMappedTracks ? null : adaptiveTrackSelectionFactory);
-          if (audioSelection != null
-              && (selectedAudioTrackScore == null
-                  || audioSelection.second.compareTo(selectedAudioTrackScore) > 0)) {
-            if (selectedAudioRendererIndex != C.INDEX_UNSET) {
-              // We've already made a selection for another audio renderer, but it had a lower
-              // score. Clear the selection for that renderer.
-              rendererTrackSelections[selectedAudioRendererIndex] = null;
-            }
-            rendererTrackSelections[i] = audioSelection.first;
-            selectedAudioTrackScore = audioSelection.second;
-            selectedAudioRendererIndex = i;
-          }
-          break;
-        case C.TRACK_TYPE_TEXT:
-          Pair<TrackSelection, Integer> textSelection =
-              selectTextTrack(mappedTrackInfo.getTrackGroups(i), rendererFormatSupports[i], params);
+                  selectedAudioLanguage);
           if (textSelection != null && textSelection.second > selectedTextTrackScore) {
             if (selectedTextRendererIndex != C.INDEX_UNSET) {
               // We've already made a selection for another text renderer, but it had a lower score.
               // Clear the selection for that renderer.
-              rendererTrackSelections[selectedTextRendererIndex] = null;
+              definitions[selectedTextRendererIndex] = null;
             }
-            rendererTrackSelections[i] = textSelection.first;
+            definitions[i] = textSelection.first;
             selectedTextTrackScore = textSelection.second;
             selectedTextRendererIndex = i;
           }
           break;
         default:
-          rendererTrackSelections[i] =
+          definitions[i] =
               selectOtherTrack(
                   trackType, mappedTrackInfo.getTrackGroups(i), rendererFormatSupports[i], params);
           break;
       }
     }
 
-    return rendererTrackSelections;
+    return definitions;
   }
 
   // Video track selection implementation.
@@ -1411,50 +1602,44 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
    * @param mixedMimeTypeAdaptationSupports The result of {@link
    *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for the renderer.
    * @param params The selector's current constraint parameters.
-   * @param adaptiveTrackSelectionFactory A factory for generating adaptive track selections, or
-   *     null if a fixed track selection is required.
-   * @return The {@link TrackSelection} for the renderer, or null if no selection was made.
+   * @param enableAdaptiveTrackSelection Whether adaptive track selection is allowed.
+   * @return The {@link TrackSelection.Definition} for the renderer, or null if no selection was
+   *     made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @Nullable TrackSelection selectVideoTrack(
+  @Nullable
+  protected TrackSelection.Definition selectVideoTrack(
       TrackGroupArray groups,
       int[][] formatSupports,
       int mixedMimeTypeAdaptationSupports,
       Parameters params,
-      @Nullable TrackSelection.Factory adaptiveTrackSelectionFactory)
+      boolean enableAdaptiveTrackSelection)
       throws ExoPlaybackException {
-    TrackSelection selection = null;
+    TrackSelection.Definition definition = null;
     if (!params.forceHighestSupportedBitrate
         && !params.forceLowestBitrate
-        && adaptiveTrackSelectionFactory != null) {
-      selection =
-          selectAdaptiveVideoTrack(
-              groups,
-              formatSupports,
-              mixedMimeTypeAdaptationSupports,
-              params,
-              adaptiveTrackSelectionFactory,
-              getBandwidthMeter());
+        && enableAdaptiveTrackSelection) {
+      definition =
+          selectAdaptiveVideoTrack(groups, formatSupports, mixedMimeTypeAdaptationSupports, params);
     }
-    if (selection == null) {
-      selection = selectFixedVideoTrack(groups, formatSupports, params);
+    if (definition == null) {
+      definition = selectFixedVideoTrack(groups, formatSupports, params);
     }
-    return selection;
+    return definition;
   }
 
-  private static @Nullable TrackSelection selectAdaptiveVideoTrack(
+  @Nullable
+  private static TrackSelection.Definition selectAdaptiveVideoTrack(
       TrackGroupArray groups,
       int[][] formatSupport,
       int mixedMimeTypeAdaptationSupports,
-      Parameters params,
-      TrackSelection.Factory adaptiveTrackSelectionFactory,
-      BandwidthMeter bandwidthMeter)
-      throws ExoPlaybackException {
-    int requiredAdaptiveSupport = params.allowNonSeamlessAdaptiveness
-        ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
-        : RendererCapabilities.ADAPTIVE_SEAMLESS;
+      Parameters params) {
+    int requiredAdaptiveSupport =
+        params.allowVideoNonSeamlessAdaptiveness
+            ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
+            : RendererCapabilities.ADAPTIVE_SEAMLESS;
     boolean allowMixedMimeTypes =
-        params.allowMixedMimeAdaptiveness
+        params.allowVideoMixedMimeTypeAdaptiveness
             && (mixedMimeTypeAdaptationSupports & requiredAdaptiveSupport) != 0;
     for (int i = 0; i < groups.length; i++) {
       TrackGroup group = groups.get(i);
@@ -1472,8 +1657,7 @@ public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
               params.viewportHeight,
               params.viewportOrientationMayChange);
       if (adaptiveTracks.length > 0) {
-        return Assertions.checkNotNull(adaptiveTrackSelectionFactory)
-            .createTrackSelection(group, bandwidthMeter, adaptiveTracks);
+        return new TrackSelection.Definition(group, adaptiveTracks);
       }
     }
     return null;
@@ -1616,7 +1800,8 @@ private static boolean isSupportedAdaptiveVideoTrack(
         && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxVideoBitrate);
   }
 
-  private static @Nullable TrackSelection selectFixedVideoTrack(
+  @Nullable
+  private static TrackSelection.Definition selectFixedVideoTrack(
       TrackGroupArray groups, int[][] formatSupports, Parameters params) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
@@ -1651,9 +1836,10 @@ private static boolean isSupportedAdaptiveVideoTrack(
           }
           boolean selectTrack = trackScore > selectedTrackScore;
           if (trackScore == selectedTrackScore) {
-            if (params.forceLowestBitrate) {
+            int bitrateComparison = compareFormatValues(format.bitrate, selectedBitrate);
+            if (params.forceLowestBitrate && bitrateComparison != 0) {
               // Use bitrate as a tie breaker, preferring the lower bitrate.
-              selectTrack = compareFormatValues(format.bitrate, selectedBitrate) < 0;
+              selectTrack = bitrateComparison < 0;
             } else {
               // Use the pixel count as a tie breaker (or bitrate if pixel counts are tied). If
               // we're within constraints prefer a higher pixel count (or bitrate), else prefer a
@@ -1677,8 +1863,9 @@ private static boolean isSupportedAdaptiveVideoTrack(
         }
       }
     }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    return selectedGroup == null
+        ? null
+        : new TrackSelection.Definition(selectedGroup, selectedTrackIndex);
   }
 
   // Audio track selection implementation.
@@ -1693,18 +1880,19 @@ private static boolean isSupportedAdaptiveVideoTrack(
    * @param mixedMimeTypeAdaptationSupports The result of {@link
    *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for the renderer.
    * @param params The selector's current constraint parameters.
-   * @param adaptiveTrackSelectionFactory A factory for generating adaptive track selections, or
-   *     null if a fixed track selection is required.
-   * @return The {@link TrackSelection} and corresponding {@link AudioTrackScore}, or null if no
-   *     selection was made.
+   * @param enableAdaptiveTrackSelection Whether adaptive track selection is allowed.
+   * @return The {@link TrackSelection.Definition} and corresponding {@link AudioTrackScore}, or
+   *     null if no selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @Nullable Pair<TrackSelection, AudioTrackScore> selectAudioTrack(
+  @SuppressWarnings("unused")
+  @Nullable
+  protected Pair<TrackSelection.Definition, AudioTrackScore> selectAudioTrack(
       TrackGroupArray groups,
       int[][] formatSupports,
       int mixedMimeTypeAdaptationSupports,
       Parameters params,
-      @Nullable TrackSelection.Factory adaptiveTrackSelectionFactory)
+      boolean enableAdaptiveTrackSelection)
       throws ExoPlaybackException {
     int selectedTrackIndex = C.INDEX_UNSET;
     int selectedGroupIndex = C.INDEX_UNSET;
@@ -1718,6 +1906,10 @@ private static boolean isSupportedAdaptiveVideoTrack(
           Format format = trackGroup.getFormat(trackIndex);
           AudioTrackScore trackScore =
               new AudioTrackScore(format, params, trackFormatSupport[trackIndex]);
+          if (!trackScore.isWithinConstraints && !params.exceedAudioConstraintsIfNecessary) {
+            // Track should not be selected.
+            continue;
+          }
           if (selectedTrackScore == null || trackScore.compareTo(selectedTrackScore) > 0) {
             selectedGroupIndex = groupIndex;
             selectedTrackIndex = trackIndex;
@@ -1733,40 +1925,50 @@ private static boolean isSupportedAdaptiveVideoTrack(
 
     TrackGroup selectedGroup = groups.get(selectedGroupIndex);
 
-    TrackSelection selection = null;
+    TrackSelection.Definition definition = null;
     if (!params.forceHighestSupportedBitrate
         && !params.forceLowestBitrate
-        && adaptiveTrackSelectionFactory != null) {
+        && enableAdaptiveTrackSelection) {
       // If the group of the track with the highest score allows it, try to enable adaptation.
       int[] adaptiveTracks =
           getAdaptiveAudioTracks(
-              selectedGroup, formatSupports[selectedGroupIndex], params.allowMixedMimeAdaptiveness);
+              selectedGroup,
+              formatSupports[selectedGroupIndex],
+              params.allowAudioMixedMimeTypeAdaptiveness,
+              params.allowAudioMixedSampleRateAdaptiveness);
       if (adaptiveTracks.length > 0) {
-        selection =
-            adaptiveTrackSelectionFactory.createTrackSelection(
-                selectedGroup, getBandwidthMeter(), adaptiveTracks);
+        definition = new TrackSelection.Definition(selectedGroup, adaptiveTracks);
       }
     }
-    if (selection == null) {
+    if (definition == null) {
       // We didn't make an adaptive selection, so make a fixed one instead.
-      selection = new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+      definition = new TrackSelection.Definition(selectedGroup, selectedTrackIndex);
     }
 
-    return Pair.create(selection, Assertions.checkNotNull(selectedTrackScore));
+    return Pair.create(definition, Assertions.checkNotNull(selectedTrackScore));
   }
 
-  private static int[] getAdaptiveAudioTracks(TrackGroup group, int[] formatSupport,
-      boolean allowMixedMimeTypes) {
+  private static int[] getAdaptiveAudioTracks(
+      TrackGroup group,
+      int[] formatSupport,
+      boolean allowMixedMimeTypeAdaptiveness,
+      boolean allowMixedSampleRateAdaptiveness) {
     int selectedConfigurationTrackCount = 0;
     AudioConfigurationTuple selectedConfiguration = null;
     HashSet<AudioConfigurationTuple> seenConfigurationTuples = new HashSet<>();
     for (int i = 0; i < group.length; i++) {
       Format format = group.getFormat(i);
-      AudioConfigurationTuple configuration = new AudioConfigurationTuple(
-          format.channelCount, format.sampleRate,
-          allowMixedMimeTypes ? null : format.sampleMimeType);
+      AudioConfigurationTuple configuration =
+          new AudioConfigurationTuple(
+              format.channelCount, format.sampleRate, format.sampleMimeType);
       if (seenConfigurationTuples.add(configuration)) {
-        int configurationCount = getAdaptiveAudioTrackCount(group, formatSupport, configuration);
+        int configurationCount =
+            getAdaptiveAudioTrackCount(
+                group,
+                formatSupport,
+                configuration,
+                allowMixedMimeTypeAdaptiveness,
+                allowMixedSampleRateAdaptiveness);
         if (configurationCount > selectedConfigurationTrackCount) {
           selectedConfiguration = configuration;
           selectedConfigurationTrackCount = configurationCount;
@@ -1779,7 +1981,11 @@ private static boolean isSupportedAdaptiveVideoTrack(
       int index = 0;
       for (int i = 0; i < group.length; i++) {
         if (isSupportedAdaptiveAudioTrack(
-            group.getFormat(i), formatSupport[i], Assertions.checkNotNull(selectedConfiguration))) {
+            group.getFormat(i),
+            formatSupport[i],
+            Assertions.checkNotNull(selectedConfiguration),
+            allowMixedMimeTypeAdaptiveness,
+            allowMixedSampleRateAdaptiveness)) {
           adaptiveIndices[index++] = i;
         }
       }
@@ -1788,23 +1994,41 @@ private static boolean isSupportedAdaptiveVideoTrack(
     return NO_TRACKS;
   }
 
-  private static int getAdaptiveAudioTrackCount(TrackGroup group, int[] formatSupport,
-      AudioConfigurationTuple configuration) {
+  private static int getAdaptiveAudioTrackCount(
+      TrackGroup group,
+      int[] formatSupport,
+      AudioConfigurationTuple configuration,
+      boolean allowMixedMimeTypeAdaptiveness,
+      boolean allowMixedSampleRateAdaptiveness) {
     int count = 0;
     for (int i = 0; i < group.length; i++) {
-      if (isSupportedAdaptiveAudioTrack(group.getFormat(i), formatSupport[i], configuration)) {
+      if (isSupportedAdaptiveAudioTrack(
+          group.getFormat(i),
+          formatSupport[i],
+          configuration,
+          allowMixedMimeTypeAdaptiveness,
+          allowMixedSampleRateAdaptiveness)) {
         count++;
       }
     }
     return count;
   }
 
-  private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSupport,
-      AudioConfigurationTuple configuration) {
-    return isSupported(formatSupport, false) && format.channelCount == configuration.channelCount
-        && format.sampleRate == configuration.sampleRate
-        && (configuration.mimeType == null
-        || TextUtils.equals(configuration.mimeType, format.sampleMimeType));
+  private static boolean isSupportedAdaptiveAudioTrack(
+      Format format,
+      int formatSupport,
+      AudioConfigurationTuple configuration,
+      boolean allowMixedMimeTypeAdaptiveness,
+      boolean allowMixedSampleRateAdaptiveness) {
+    return isSupported(formatSupport, false)
+        && (format.channelCount != Format.NO_VALUE
+            && format.channelCount == configuration.channelCount)
+        && (allowMixedMimeTypeAdaptiveness
+            || (format.sampleMimeType != null
+                && TextUtils.equals(format.sampleMimeType, configuration.mimeType)))
+        && (allowMixedSampleRateAdaptiveness
+            || (format.sampleRate != Format.NO_VALUE
+                && format.sampleRate == configuration.sampleRate));
   }
 
   // Text track selection implementation.
@@ -1817,12 +2041,18 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
    * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each mapped
    *     track, indexed by track group index and track index (in that order).
    * @param params The selector's current constraint parameters.
-   * @return The {@link TrackSelection} and corresponding track score, or null if no selection was
-   *     made.
+   * @param selectedAudioLanguage The language of the selected audio track. May be null if the
+   *     selected audio track declares no language or no audio track was selected.
+   * @return The {@link TrackSelection.Definition} and corresponding track score, or null if no
+   *     selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @Nullable Pair<TrackSelection, Integer> selectTextTrack(
-      TrackGroupArray groups, int[][] formatSupport, Parameters params)
+  @Nullable
+  protected Pair<TrackSelection.Definition, Integer> selectTextTrack(
+      TrackGroupArray groups,
+      int[][] formatSupport,
+      Parameters params,
+      @Nullable String selectedAudioLanguage)
       throws ExoPlaybackException {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
@@ -1839,28 +2069,26 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
           boolean isDefault = (maskedSelectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
           boolean isForced = (maskedSelectionFlags & C.SELECTION_FLAG_FORCED) != 0;
           int trackScore;
-          boolean preferredLanguageFound = formatHasLanguage(format, params.preferredTextLanguage);
-          if (preferredLanguageFound
-              || (params.selectUndeterminedTextLanguage && formatHasNoLanguage(format))) {
+          int languageScore = getFormatLanguageScore(format, params.preferredTextLanguage);
+          boolean trackHasNoLanguage = formatHasNoLanguage(format);
+          if (languageScore > 0 || (params.selectUndeterminedTextLanguage && trackHasNoLanguage)) {
             if (isDefault) {
-              trackScore = 8;
+              trackScore = 11;
             } else if (!isForced) {
               // Prefer non-forced to forced if a preferred text language has been specified. Where
               // both are provided the non-forced track will usually contain the forced subtitles as
               // a subset.
-              trackScore = 6;
+              trackScore = 7;
             } else {
-              trackScore = 4;
+              trackScore = 3;
             }
-            trackScore += preferredLanguageFound ? 1 : 0;
+            trackScore += languageScore;
           } else if (isDefault) {
-            trackScore = 3;
-          } else if (isForced) {
-            if (formatHasLanguage(format, params.preferredAudioLanguage)) {
-              trackScore = 2;
-            } else {
-              trackScore = 1;
-            }
+            trackScore = 2;
+          } else if (isForced
+              && (getFormatLanguageScore(format, selectedAudioLanguage) > 0
+                  || (trackHasNoLanguage && stringDefinesNoLanguage(selectedAudioLanguage)))) {
+            trackScore = 1;
           } else {
             // Track should not be selected.
             continue;
@@ -1879,7 +2107,7 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
     return selectedGroup == null
         ? null
         : Pair.create(
-            new FixedTrackSelection(selectedGroup, selectedTrackIndex), selectedTrackScore);
+            new TrackSelection.Definition(selectedGroup, selectedTrackIndex), selectedTrackScore);
   }
 
   // General track selection methods.
@@ -1896,7 +2124,8 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
    * @return The {@link TrackSelection} for the renderer, or null if no selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
-  protected @Nullable TrackSelection selectOtherTrack(
+  @Nullable
+  protected TrackSelection.Definition selectOtherTrack(
       int trackType, TrackGroupArray groups, int[][] formatSupport, Parameters params)
       throws ExoPlaybackException {
     TrackGroup selectedGroup = null;
@@ -1922,8 +2151,9 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
         }
       }
     }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    return selectedGroup == null
+        ? null
+        : new TrackSelection.Definition(selectedGroup, selectedTrackIndex);
   }
 
   // Utility methods.
@@ -2047,28 +2277,48 @@ protected static boolean isSupported(int formatSupport, boolean allowExceedsCapa
         && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
   }
 
+  /** Equivalent to {@link #stringDefinesNoLanguage stringDefinesNoLanguage(format.language)}. */
+  protected static boolean formatHasNoLanguage(Format format) {
+    return stringDefinesNoLanguage(format.language);
+  }
+
   /**
-   * Returns whether a {@link Format} does not define a language.
+   * Returns whether the given string does not define a language.
    *
-   * @param format The {@link Format}.
-   * @return Whether the {@link Format} does not define a language.
+   * @param language The string.
+   * @return Whether the given string does not define a language.
    */
-  protected static boolean formatHasNoLanguage(Format format) {
-    return TextUtils.isEmpty(format.language) || formatHasLanguage(format, C.LANGUAGE_UNDETERMINED);
+  protected static boolean stringDefinesNoLanguage(@Nullable String language) {
+    return TextUtils.isEmpty(language) || TextUtils.equals(language, C.LANGUAGE_UNDETERMINED);
   }
 
   /**
-   * Returns whether a {@link Format} specifies a particular language, or {@code false} if {@code
-   * language} is null.
+   * Returns a score for how well a language specified in a {@link Format} matches a given language.
    *
    * @param format The {@link Format}.
-   * @param language The language.
-   * @return Whether the format specifies the language, or {@code false} if {@code language} is
-   *     null.
+   * @param language The language, or null.
+   * @return A score of 3 if the languages match fully, a score of 2 if the languages match partly,
+   *     a score of 1 if the languages don't match but belong to the same main language, and a score
+   *     of 0 if the languages don't match at all.
    */
-  protected static boolean formatHasLanguage(Format format, @Nullable String language) {
-    return language != null
-        && TextUtils.equals(language, Util.normalizeLanguageCode(format.language));
+  protected static int getFormatLanguageScore(Format format, @Nullable String language) {
+    if (format.language == null || language == null) {
+      return 0;
+    }
+    if (TextUtils.equals(format.language, language)) {
+      return 3;
+    }
+    // Partial match where one language is a subset of the other (e.g. "zho-hans" and "zho-hans-hk")
+    if (format.language.startsWith(language) || language.startsWith(format.language)) {
+      return 2;
+    }
+    // Partial match where only the main language tag is the same (e.g. "fra-fr" and "fra-ca")
+    if (format.language.length() >= 3
+        && language.length() >= 3
+        && format.language.substring(0, 3).equals(language.substring(0, 3))) {
+      return 1;
+    }
+    return 0;
   }
 
   private static List<Integer> getViewportFilteredTrackIndices(TrackGroup group, int viewportWidth,
@@ -2143,22 +2393,43 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
   /** Represents how well an audio track matches the selection {@link Parameters}. */
   protected static final class AudioTrackScore implements Comparable<AudioTrackScore> {
 
+    public final boolean isWithinConstraints;
+
     private final Parameters parameters;
-    private final int withinRendererCapabilitiesScore;
-    private final int matchLanguageScore;
-    private final int defaultSelectionFlagScore;
+    private final boolean isWithinRendererCapabilities;
+    private final int preferredLanguageScore;
+    private final int localeLanguageMatchIndex;
+    private final int localeLanguageScore;
+    private final boolean isDefaultSelectionFlag;
     private final int channelCount;
     private final int sampleRate;
     private final int bitrate;
 
     public AudioTrackScore(Format format, Parameters parameters, int formatSupport) {
       this.parameters = parameters;
-      withinRendererCapabilitiesScore = isSupported(formatSupport, false) ? 1 : 0;
-      matchLanguageScore = formatHasLanguage(format, parameters.preferredAudioLanguage) ? 1 : 0;
-      defaultSelectionFlagScore = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0 ? 1 : 0;
+      isWithinRendererCapabilities = isSupported(formatSupport, false);
+      preferredLanguageScore = getFormatLanguageScore(format, parameters.preferredAudioLanguage);
+      isDefaultSelectionFlag = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
       channelCount = format.channelCount;
       sampleRate = format.sampleRate;
       bitrate = format.bitrate;
+      isWithinConstraints =
+          (format.bitrate == Format.NO_VALUE || format.bitrate <= parameters.maxAudioBitrate)
+              && (format.channelCount == Format.NO_VALUE
+                  || format.channelCount <= parameters.maxAudioChannelCount);
+      String[] localeLanguages = Util.getSystemLanguageCodes();
+      int bestMatchIndex = Integer.MAX_VALUE;
+      int bestMatchScore = 0;
+      for (int i = 0; i < localeLanguages.length; i++) {
+        int score = getFormatLanguageScore(format, localeLanguages[i]);
+        if (score > 0) {
+          bestMatchIndex = i;
+          bestMatchScore = score;
+          break;
+        }
+      }
+      localeLanguageMatchIndex = bestMatchIndex;
+      localeLanguageScore = bestMatchScore;
     }
 
     /**
@@ -2170,26 +2441,40 @@ public AudioTrackScore(Format format, Parameters parameters, int formatSupport)
      */
     @Override
     public int compareTo(@NonNull AudioTrackScore other) {
-      if (this.withinRendererCapabilitiesScore != other.withinRendererCapabilitiesScore) {
-        return compareInts(this.withinRendererCapabilitiesScore,
-            other.withinRendererCapabilitiesScore);
-      } else if (this.matchLanguageScore != other.matchLanguageScore) {
-        return compareInts(this.matchLanguageScore, other.matchLanguageScore);
-      } else if (this.defaultSelectionFlagScore != other.defaultSelectionFlagScore) {
-        return compareInts(this.defaultSelectionFlagScore, other.defaultSelectionFlagScore);
-      } else if (parameters.forceLowestBitrate) {
-        return compareInts(other.bitrate, this.bitrate);
-      } else {
-        // If the format are within renderer capabilities, prefer higher values of channel count,
-        // sample rate and bit rate in that order. Otherwise, prefer lower values.
-        int resultSign = withinRendererCapabilitiesScore == 1 ? 1 : -1;
-        if (this.channelCount != other.channelCount) {
-          return resultSign * compareInts(this.channelCount, other.channelCount);
-        } else if (this.sampleRate != other.sampleRate) {
-          return resultSign * compareInts(this.sampleRate, other.sampleRate);
+      if (this.isWithinRendererCapabilities != other.isWithinRendererCapabilities) {
+        return this.isWithinRendererCapabilities ? 1 : -1;
+      }
+      if (this.preferredLanguageScore != other.preferredLanguageScore) {
+        return compareInts(this.preferredLanguageScore, other.preferredLanguageScore);
+      }
+      if (this.isWithinConstraints != other.isWithinConstraints) {
+        return this.isWithinConstraints ? 1 : -1;
+      }
+      if (parameters.forceLowestBitrate) {
+        int bitrateComparison = compareFormatValues(bitrate, other.bitrate);
+        if (bitrateComparison != 0) {
+          return bitrateComparison > 0 ? -1 : 1;
         }
-        return resultSign * compareInts(this.bitrate, other.bitrate);
       }
+      if (this.isDefaultSelectionFlag != other.isDefaultSelectionFlag) {
+        return this.isDefaultSelectionFlag ? 1 : -1;
+      }
+      if (this.localeLanguageMatchIndex != other.localeLanguageMatchIndex) {
+        return -compareInts(this.localeLanguageMatchIndex, other.localeLanguageMatchIndex);
+      }
+      if (this.localeLanguageScore != other.localeLanguageScore) {
+        return compareInts(this.localeLanguageScore, other.localeLanguageScore);
+      }
+      // If the formats are within constraints and renderer capabilities then prefer higher values
+      // of channel count, sample rate and bit rate in that order. Otherwise, prefer lower values.
+      int resultSign = isWithinConstraints && isWithinRendererCapabilities ? 1 : -1;
+      if (this.channelCount != other.channelCount) {
+        return resultSign * compareInts(this.channelCount, other.channelCount);
+      }
+      if (this.sampleRate != other.sampleRate) {
+        return resultSign * compareInts(this.sampleRate, other.sampleRate);
+      }
+      return resultSign * compareInts(this.bitrate, other.bitrate);
     }
   }
 
@@ -2209,7 +2494,7 @@ private static int compareInts(int first, int second) {
 
     public final int channelCount;
     public final int sampleRate;
-    public final @Nullable String mimeType;
+    @Nullable public final String mimeType;
 
     public AudioConfigurationTuple(int channelCount, int sampleRate, @Nullable String mimeType) {
       this.channelCount = channelCount;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
index 7755e437ce..3bdaeeeafb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
@@ -15,14 +15,14 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
-import com.google.android.exoplayer2.util.Assertions;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A {@link TrackSelection} consisting of a single track.
@@ -56,10 +56,12 @@ public Factory(int reason, @Nullable Object data) {
     }
 
     @Override
-    public FixedTrackSelection createTrackSelection(
-        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
-      Assertions.checkArgument(tracks.length == 1);
-      return new FixedTrackSelection(group, tracks[0], reason, data);
+    public @NullableType TrackSelection[] createTrackSelections(
+        @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
+      return TrackSelectionUtil.createTrackSelectionsForDefinitions(
+          definitions,
+          definition ->
+              new FixedTrackSelection(definition.group, definition.tracks[0], reason, data));
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 59a4f96fb0..2738ee5926 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -15,14 +15,16 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Util;
@@ -328,8 +330,12 @@ public final void onSelectionActivated(Object info) {
   }
 
   @Override
-  public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
-      TrackGroupArray trackGroups) throws ExoPlaybackException {
+  public final TrackSelectorResult selectTracks(
+      RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups,
+      MediaPeriodId periodId,
+      Timeline timeline)
+      throws ExoPlaybackException {
     // Structures into which data will be written during the selection. The extra item at the end
     // of each array is to store data associated with track groups that cannot be associated with
     // any renderer.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
index e3c643670b..8053212969 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import java.util.List;
 import java.util.Random;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A {@link TrackSelection} whose selected track is updated randomly.
@@ -49,9 +50,11 @@ public Factory(int seed) {
     }
 
     @Override
-    public RandomTrackSelection createTrackSelection(
-        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
-      return new RandomTrackSelection(group, tracks, random);
+    public @NullableType TrackSelection[] createTrackSelections(
+        @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
+      return TrackSelectionUtil.createTrackSelectionsForDefinitions(
+          definitions,
+          definition -> new RandomTrackSelection(definition.group, definition.tracks, random));
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackBitrateEstimator.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackBitrateEstimator.java
new file mode 100644
index 0000000000..1cd6c09bfe
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackBitrateEstimator.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.trackselection;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import java.util.List;
+
+/** Estimates track bitrate values. */
+public interface TrackBitrateEstimator {
+
+  /**
+   * A {@link TrackBitrateEstimator} that returns the bitrate values defined in the track formats.
+   */
+  TrackBitrateEstimator DEFAULT =
+      (formats, queue, iterators, bitrates) ->
+          TrackSelectionUtil.getFormatBitrates(formats, bitrates);
+
+  /**
+   * Returns bitrate values for a set of tracks whose formats are given.
+   *
+   * @param formats The track formats.
+   * @param queue The queue of already buffered {@link MediaChunk} instances. Must not be modified.
+   * @param iterators An array of {@link MediaChunkIterator}s providing information about the
+   *     sequence of upcoming media chunks for each track.
+   * @param bitrates An array into which the bitrate values will be written. If non-null, this array
+   *     is the one that will be returned.
+   * @return Bitrate values for the tracks. As long as the format of a track has set bitrate, a
+   *     bitrate value is set in the returned array. Otherwise it might be set to {@link
+   *     Format#NO_VALUE}.
+   */
+  int[] getBitrates(
+      Format[] formats,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] iterators,
+      @Nullable int[] bitrates);
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
index 78d052ac3c..bd99403b07 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
@@ -15,54 +15,111 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.trackselection.TrackSelectionUtil.AdaptiveTrackSelectionFactory;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A track selection consisting of a static subset of selected tracks belonging to a {@link
  * TrackGroup}, and a possibly varying individual selected track from the subset.
  *
  * <p>Tracks belonging to the subset are exposed in decreasing bandwidth order. The individual
- * selected track may change as a result of calling {@link #updateSelectedTrack(long, long, long,
- * List, MediaChunkIterator[])}.
+ * selected track may change dynamically as a result of calling {@link #updateSelectedTrack(long,
+ * long, long, List, MediaChunkIterator[])} or {@link #evaluateQueueSize(long, List)}. This only
+ * happens between calls to {@link #enable()} and {@link #disable()}.
  */
 public interface TrackSelection {
 
+  /** Contains of a subset of selected tracks belonging to a {@link TrackGroup}. */
+  final class Definition {
+    /** The {@link TrackGroup} which tracks belong to. */
+    public final TrackGroup group;
+    /** The indices of the selected tracks in {@link #group}. */
+    public final int[] tracks;
+    /** The track selection reason. One of the {@link C} SELECTION_REASON_ constants. */
+    public final int reason;
+    /** Optional data associated with this selection of tracks. */
+    @Nullable public final Object data;
+
+    /**
+     * @param group The {@link TrackGroup}. Must not be null.
+     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *     null or empty. May be in any order.
+     */
+    public Definition(TrackGroup group, int... tracks) {
+      this(group, tracks, C.SELECTION_REASON_UNKNOWN, /* data= */ null);
+    }
+
+    /**
+     * @param group The {@link TrackGroup}. Must not be null.
+     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     * @param reason The track selection reason. One of the {@link C} SELECTION_REASON_ constants.
+     * @param data Optional data associated with this selection of tracks.
+     */
+    public Definition(TrackGroup group, int[] tracks, int reason, @Nullable Object data) {
+      this.group = group;
+      this.tracks = tracks;
+      this.reason = reason;
+      this.data = data;
+    }
+  }
+
   /**
    * Factory for {@link TrackSelection} instances.
    */
   interface Factory {
 
     /**
-     * Creates a new selection.
+     * @deprecated Implement {@link #createTrackSelections(Definition[], BandwidthMeter)} instead.
+     *     Calling {@link TrackSelectionUtil#createTrackSelectionsForDefinitions(Definition[],
+     *     AdaptiveTrackSelectionFactory)} helps to create a single adaptive track selection in the
+     *     same way as using this deprecated method.
+     */
+    @Deprecated
+    default TrackSelection createTrackSelection(
+        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
+      throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Creates a new selection for each {@link Definition}.
      *
-     * @param group The {@link TrackGroup}. Must not be null.
+     * @param definitions A {@link Definition} array. May include null values.
      * @param bandwidthMeter A {@link BandwidthMeter} which can be used to select tracks.
-     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-     *     null or empty. May be in any order.
-     * @return The created selection.
+     * @return The created selections. Must have the same length as {@code definitions} and may
+     *     include null values.
      */
-    TrackSelection createTrackSelection(
-        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks);
+    @SuppressWarnings("deprecation")
+    default @NullableType TrackSelection[] createTrackSelections(
+        @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
+      return TrackSelectionUtil.createTrackSelectionsForDefinitions(
+          definitions,
+          definition -> createTrackSelection(definition.group, bandwidthMeter, definition.tracks));
+    }
   }
 
   /**
-   * Enables the track selection.
-   * <p>
-   * This method may not be called when the track selection is already enabled.
+   * Enables the track selection. Dynamic changes via {@link #updateSelectedTrack(long, long, long,
+   * List, MediaChunkIterator[])} or {@link #evaluateQueueSize(long, List)} will only happen after
+   * this call.
+   *
+   * <p>This method may not be called when the track selection is already enabled.
    */
   void enable();
 
   /**
-   * Disables this track selection.
-   * <p>
-   * This method may only be called when the track selection is already enabled.
+   * Disables this track selection. No further dynamic changes via {@link #updateSelectedTrack(long,
+   * long, long, List, MediaChunkIterator[])} or {@link #evaluateQueueSize(long, List)} will happen
+   * after this call.
+   *
+   * <p>This method may only be called when the track selection is already enabled.
    */
   void disable();
 
@@ -149,6 +206,13 @@ TrackSelection createTrackSelection(
    */
   void onPlaybackSpeed(float speed);
 
+  /**
+   * Called to notify the selection of a position discontinuity.
+   *
+   * <p>This happens when the playback position jumps, e.g., as a result of a seek being performed.
+   */
+  default void onDiscontinuity() {}
+
   /**
    * @deprecated Use and implement {@link #updateSelectedTrack(long, long, long, List,
    *     MediaChunkIterator[])} instead.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
index 48151002be..bc905ace4b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.util.Arrays;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
new file mode 100644
index 0000000000..66a4707496
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import android.text.TextUtils;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+
+/** Constraint parameters for track selection. */
+public class TrackSelectionParameters implements Parcelable {
+
+  /**
+   * A builder for {@link TrackSelectionParameters}. See the {@link TrackSelectionParameters}
+   * documentation for explanations of the parameters that can be configured using this builder.
+   */
+  public static class Builder {
+
+    // Audio
+    @Nullable /* package */ String preferredAudioLanguage;
+    // Text
+    @Nullable /* package */ String preferredTextLanguage;
+    /* package */ boolean selectUndeterminedTextLanguage;
+    @C.SelectionFlags /* package */ int disabledTextTrackSelectionFlags;
+
+    /** Creates a builder with default initial values. */
+    public Builder() {
+      this(DEFAULT);
+    }
+
+    /**
+     * @param initialValues The {@link TrackSelectionParameters} from which the initial values of
+     *     the builder are obtained.
+     */
+    /* package */ Builder(TrackSelectionParameters initialValues) {
+      // Audio
+      preferredAudioLanguage = initialValues.preferredAudioLanguage;
+      // Text
+      preferredTextLanguage = initialValues.preferredTextLanguage;
+      selectUndeterminedTextLanguage = initialValues.selectUndeterminedTextLanguage;
+      disabledTextTrackSelectionFlags = initialValues.disabledTextTrackSelectionFlags;
+    }
+
+    /**
+     * See {@link TrackSelectionParameters#preferredAudioLanguage}.
+     *
+     * @param preferredAudioLanguage Preferred audio language as an IETF BCP 47 conformant tag.
+     * @return This builder.
+     */
+    public Builder setPreferredAudioLanguage(@Nullable String preferredAudioLanguage) {
+      this.preferredAudioLanguage = preferredAudioLanguage;
+      return this;
+    }
+
+    // Text
+
+    /**
+     * See {@link TrackSelectionParameters#preferredTextLanguage}.
+     *
+     * @param preferredTextLanguage Preferred text language as an IETF BCP 47 conformant tag.
+     * @return This builder.
+     */
+    public Builder setPreferredTextLanguage(@Nullable String preferredTextLanguage) {
+      this.preferredTextLanguage = preferredTextLanguage;
+      return this;
+    }
+
+    /**
+     * See {@link TrackSelectionParameters#selectUndeterminedTextLanguage}.
+     *
+     * @return This builder.
+     */
+    public Builder setSelectUndeterminedTextLanguage(boolean selectUndeterminedTextLanguage) {
+      this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
+      return this;
+    }
+
+    /**
+     * See {@link TrackSelectionParameters#disabledTextTrackSelectionFlags}.
+     *
+     * @return This builder.
+     */
+    public Builder setDisabledTextTrackSelectionFlags(
+        @C.SelectionFlags int disabledTextTrackSelectionFlags) {
+      this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
+      return this;
+    }
+
+    /** Builds a {@link TrackSelectionParameters} instance with the selected values. */
+    public TrackSelectionParameters build() {
+      return new TrackSelectionParameters(
+          // Audio
+          preferredAudioLanguage,
+          // Text
+          preferredTextLanguage,
+          selectUndeterminedTextLanguage,
+          disabledTextTrackSelectionFlags);
+    }
+  }
+
+  /** An instance with default values. */
+  public static final TrackSelectionParameters DEFAULT = new TrackSelectionParameters();
+
+  /**
+   * The preferred language for audio and forced text tracks, as an ISO 639-2/T tag. {@code null}
+   * selects the default track, or the first track if there's no default. The default value is
+   * {@code null}.
+   */
+  @Nullable public final String preferredAudioLanguage;
+  // Text
+  /**
+   * The preferred language for text tracks as an ISO 639-2/T tag. {@code null} selects the default
+   * track if there is one, or no track otherwise. The default value is {@code null}.
+   */
+  @Nullable public final String preferredTextLanguage;
+  /**
+   * Whether a text track with undetermined language should be selected if no track with {@link
+   * #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset. The
+   * default value is {@code false}.
+   */
+  public final boolean selectUndeterminedTextLanguage;
+  /**
+   * Bitmask of selection flags that are disabled for text track selections. See {@link
+   * C.SelectionFlags}. The default value is {@code 0} (i.e. no flags).
+   */
+  @C.SelectionFlags public final int disabledTextTrackSelectionFlags;
+
+  /* package */ TrackSelectionParameters() {
+    this(
+        /* preferredAudioLanguage= */ null,
+        // Text
+        /* preferredTextLanguage= */ null,
+        /* selectUndeterminedTextLanguage= */ false,
+        /* disabledTextTrackSelectionFlags= */ 0);
+  }
+
+  /* package */ TrackSelectionParameters(
+      @Nullable String preferredAudioLanguage,
+      @Nullable String preferredTextLanguage,
+      boolean selectUndeterminedTextLanguage,
+      @C.SelectionFlags int disabledTextTrackSelectionFlags) {
+    // Audio
+    this.preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
+    // Text
+    this.preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+    this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
+    this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
+  }
+
+  /* package */ TrackSelectionParameters(Parcel in) {
+    // Audio
+    this.preferredAudioLanguage = in.readString();
+    // Text
+    this.preferredTextLanguage = in.readString();
+    this.selectUndeterminedTextLanguage = Util.readBoolean(in);
+    this.disabledTextTrackSelectionFlags = in.readInt();
+  }
+
+  /** Creates a new {@link Builder}, copying the initial values from this instance. */
+  public Builder buildUpon() {
+    return new Builder(this);
+  }
+
+  @Override
+  @SuppressWarnings("EqualsGetClass")
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    TrackSelectionParameters other = (TrackSelectionParameters) obj;
+    return TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
+        // Text
+        && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage)
+        && selectUndeterminedTextLanguage == other.selectUndeterminedTextLanguage
+        && disabledTextTrackSelectionFlags == other.disabledTextTrackSelectionFlags;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 1;
+    // Audio
+    result = 31 * result + (preferredAudioLanguage == null ? 0 : preferredAudioLanguage.hashCode());
+    // Text
+    result = 31 * result + (preferredTextLanguage == null ? 0 : preferredTextLanguage.hashCode());
+    result = 31 * result + (selectUndeterminedTextLanguage ? 1 : 0);
+    result = 31 * result + disabledTextTrackSelectionFlags;
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    // Audio
+    dest.writeString(preferredAudioLanguage);
+    // Text
+    dest.writeString(preferredTextLanguage);
+    Util.writeBoolean(dest, selectUndeterminedTextLanguage);
+    dest.writeInt(disabledTextTrackSelectionFlags);
+  }
+
+  public static final Creator<TrackSelectionParameters> CREATOR =
+      new Creator<TrackSelectionParameters>() {
+
+        @Override
+        public TrackSelectionParameters createFromParcel(Parcel in) {
+          return new TrackSelectionParameters(in);
+        }
+
+        @Override
+        public TrackSelectionParameters[] newArray(int size) {
+          return new TrackSelectionParameters[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java
new file mode 100644
index 0000000000..71afd87b0f
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.source.chunk.MediaChunkListIterator;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
+import com.google.android.exoplayer2.trackselection.TrackSelection.Definition;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.Arrays;
+import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+
+/** Track selection related utility methods. */
+public final class TrackSelectionUtil {
+
+  private TrackSelectionUtil() {}
+
+  /** Functional interface to create a single adaptive track selection. */
+  public interface AdaptiveTrackSelectionFactory {
+
+    /**
+     * Creates an adaptive track selection for the provided track selection definition.
+     *
+     * @param trackSelectionDefinition A {@link Definition} for the track selection.
+     * @return The created track selection.
+     */
+    TrackSelection createAdaptiveTrackSelection(Definition trackSelectionDefinition);
+  }
+
+  /**
+   * Creates track selections for an array of track selection definitions, with at most one
+   * multi-track adaptive selection.
+   *
+   * @param definitions The list of track selection {@link Definition definitions}. May include null
+   *     values.
+   * @param adaptiveTrackSelectionFactory A factory for the multi-track adaptive track selection.
+   * @return The array of created track selection. For null entries in {@code definitions} returns
+   *     null values.
+   */
+  public static @NullableType TrackSelection[] createTrackSelectionsForDefinitions(
+      @NullableType Definition[] definitions,
+      AdaptiveTrackSelectionFactory adaptiveTrackSelectionFactory) {
+    TrackSelection[] selections = new TrackSelection[definitions.length];
+    boolean createdAdaptiveTrackSelection = false;
+    for (int i = 0; i < definitions.length; i++) {
+      Definition definition = definitions[i];
+      if (definition == null) {
+        continue;
+      }
+      if (definition.tracks.length > 1 && !createdAdaptiveTrackSelection) {
+        createdAdaptiveTrackSelection = true;
+        selections[i] = adaptiveTrackSelectionFactory.createAdaptiveTrackSelection(definition);
+      } else {
+        selections[i] =
+            new FixedTrackSelection(
+                definition.group, definition.tracks[0], definition.reason, definition.data);
+      }
+    }
+    return selections;
+  }
+
+  /**
+   * Updates {@link DefaultTrackSelector.Parameters} with an override.
+   *
+   * @param parameters The current {@link DefaultTrackSelector.Parameters} to build upon.
+   * @param rendererIndex The renderer index to update.
+   * @param trackGroupArray The {@link TrackGroupArray} of the renderer.
+   * @param isDisabled Whether the renderer should be set disabled.
+   * @param override An optional override for the renderer. If null, no override will be set and an
+   *     existing override for this renderer will be cleared.
+   * @return The updated {@link DefaultTrackSelector.Parameters}.
+   */
+  public static DefaultTrackSelector.Parameters updateParametersWithOverride(
+      DefaultTrackSelector.Parameters parameters,
+      int rendererIndex,
+      TrackGroupArray trackGroupArray,
+      boolean isDisabled,
+      @Nullable SelectionOverride override) {
+    DefaultTrackSelector.ParametersBuilder builder =
+        parameters
+            .buildUpon()
+            .clearSelectionOverrides(rendererIndex)
+            .setRendererDisabled(rendererIndex, isDisabled);
+    if (override != null) {
+      builder.setSelectionOverride(rendererIndex, trackGroupArray, override);
+    }
+    return builder.build();
+  }
+
+  /**
+   * Returns average bitrate for chunks in bits per second. Chunks are included in average until
+   * {@code maxDurationMs} or the first unknown length chunk.
+   *
+   * @param iterator Iterator for media chunk sequences.
+   * @param maxDurationUs Maximum duration of chunks to be included in average bitrate, in
+   *     microseconds.
+   * @return Average bitrate for chunks in bits per second, or {@link Format#NO_VALUE} if there are
+   *     no chunks or the first chunk length is unknown.
+   */
+  public static int getAverageBitrate(MediaChunkIterator iterator, long maxDurationUs) {
+    long totalDurationUs = 0;
+    long totalLength = 0;
+    while (iterator.next()) {
+      long chunkLength = iterator.getDataSpec().length;
+      if (chunkLength == C.LENGTH_UNSET) {
+        break;
+      }
+      long chunkDurationUs = iterator.getChunkEndTimeUs() - iterator.getChunkStartTimeUs();
+      if (totalDurationUs + chunkDurationUs >= maxDurationUs) {
+        totalLength += chunkLength * (maxDurationUs - totalDurationUs) / chunkDurationUs;
+        totalDurationUs = maxDurationUs;
+        break;
+      }
+      totalDurationUs += chunkDurationUs;
+      totalLength += chunkLength;
+    }
+    return totalDurationUs == 0
+        ? Format.NO_VALUE
+        : (int) (totalLength * C.BITS_PER_BYTE * C.MICROS_PER_SECOND / totalDurationUs);
+  }
+
+  /**
+   * Returns bitrate values for a set of tracks whose upcoming media chunk iterators and formats are
+   * given.
+   *
+   * <p>If an average bitrate can't be calculated, an estimation is calculated using average bitrate
+   * of another track and the ratio of the bitrate values defined in the formats of the two tracks.
+   *
+   * @param iterators An array of {@link MediaChunkIterator}s providing information about the
+   *     sequence of upcoming media chunks for each track.
+   * @param formats The track formats.
+   * @param maxDurationUs Maximum duration of chunks to be included in average bitrate values, in
+   *     microseconds.
+   * @param bitrates If not null, stores bitrate values in this array.
+   * @return Average bitrate values for the tracks. If for a track, an average bitrate or an
+   *     estimation can't be calculated, {@link Format#NO_VALUE} is set.
+   * @see #getAverageBitrate(MediaChunkIterator, long)
+   */
+  @VisibleForTesting
+  /* package */ static int[] getBitratesUsingFutureInfo(
+      MediaChunkIterator[] iterators,
+      Format[] formats,
+      long maxDurationUs,
+      @Nullable int[] bitrates) {
+    int trackCount = iterators.length;
+    Assertions.checkArgument(trackCount == formats.length);
+    if (trackCount == 0) {
+      return new int[0];
+    }
+    if (bitrates == null) {
+      bitrates = new int[trackCount];
+    }
+    if (maxDurationUs == 0) {
+      Arrays.fill(bitrates, Format.NO_VALUE);
+      return bitrates;
+    }
+
+    int[] formatBitrates = new int[trackCount];
+    float[] bitrateRatios = new float[trackCount];
+    boolean needEstimateBitrate = false;
+    boolean canEstimateBitrate = false;
+    for (int i = 0; i < trackCount; i++) {
+      int bitrate = getAverageBitrate(iterators[i], maxDurationUs);
+      if (bitrate != Format.NO_VALUE) {
+        int formatBitrate = formats[i].bitrate;
+        formatBitrates[i] = formatBitrate;
+        if (formatBitrate != Format.NO_VALUE) {
+          bitrateRatios[i] = ((float) bitrate) / formatBitrate;
+          canEstimateBitrate = true;
+        }
+      } else {
+        needEstimateBitrate = true;
+        formatBitrates[i] = Format.NO_VALUE;
+      }
+      bitrates[i] = bitrate;
+    }
+
+    if (needEstimateBitrate && canEstimateBitrate) {
+      estimateBitrates(bitrates, formats, formatBitrates, bitrateRatios);
+    }
+    return bitrates;
+  }
+
+  /**
+   * Returns bitrate values for a set of tracks whose formats are given, using the given queue of
+   * already buffered {@link MediaChunk} instances.
+   *
+   * @param queue The queue of already buffered {@link MediaChunk} instances. Must not be modified.
+   * @param formats The track formats.
+   * @param maxDurationUs Maximum duration of chunks to be included in average bitrate values, in
+   *     microseconds.
+   * @param bitrates If not null, calculates bitrate values only for indexes set to Format.NO_VALUE
+   *     and stores result in this array.
+   * @return Bitrate values for the tracks. If for a track, a bitrate value can't be calculated,
+   *     {@link Format#NO_VALUE} is set.
+   * @see #getBitratesUsingFutureInfo(MediaChunkIterator[], Format[], long, int[])
+   */
+  @VisibleForTesting
+  /* package */ static int[] getBitratesUsingPastInfo(
+      List<? extends MediaChunk> queue,
+      Format[] formats,
+      long maxDurationUs,
+      @Nullable int[] bitrates) {
+    if (bitrates == null) {
+      bitrates = new int[formats.length];
+      Arrays.fill(bitrates, Format.NO_VALUE);
+    }
+    if (maxDurationUs == 0) {
+      return bitrates;
+    }
+    int queueAverageBitrate = getAverageQueueBitrate(queue, maxDurationUs);
+    if (queueAverageBitrate == Format.NO_VALUE) {
+      return bitrates;
+    }
+    int queueFormatBitrate = queue.get(queue.size() - 1).trackFormat.bitrate;
+    if (queueFormatBitrate != Format.NO_VALUE) {
+      float queueBitrateRatio = ((float) queueAverageBitrate) / queueFormatBitrate;
+      estimateBitrates(
+          bitrates, formats, new int[] {queueFormatBitrate}, new float[] {queueBitrateRatio});
+    }
+    return bitrates;
+  }
+
+  /**
+   * Returns bitrate values for a set of tracks whose formats are given, using the given upcoming
+   * media chunk iterators and the queue of already buffered {@link MediaChunk}s.
+   *
+   * @param formats The track formats.
+   * @param queue The queue of already buffered {@link MediaChunk}s. Must not be modified.
+   * @param maxPastDurationUs Maximum duration of past chunks to be included in average bitrate
+   *     values, in microseconds.
+   * @param iterators An array of {@link MediaChunkIterator}s providing information about the
+   *     sequence of upcoming media chunks for each track.
+   * @param maxFutureDurationUs Maximum duration of future chunks to be included in average bitrate
+   *     values, in microseconds.
+   * @param useFormatBitrateAsLowerBound Whether to return the estimated bitrate only if it's higher
+   *     than the bitrate of the track's format.
+   * @param bitrates An array into which the bitrate values will be written. If non-null, this array
+   *     is the one that will be returned.
+   * @return Bitrate values for the tracks. As long as the format of a track has set bitrate, a
+   *     bitrate value is set in the returned array. Otherwise it might be set to {@link
+   *     Format#NO_VALUE}.
+   */
+  public static int[] getBitratesUsingPastAndFutureInfo(
+      Format[] formats,
+      List<? extends MediaChunk> queue,
+      long maxPastDurationUs,
+      MediaChunkIterator[] iterators,
+      long maxFutureDurationUs,
+      boolean useFormatBitrateAsLowerBound,
+      @Nullable int[] bitrates) {
+    bitrates = getBitratesUsingFutureInfo(iterators, formats, maxFutureDurationUs, bitrates);
+    getBitratesUsingPastInfo(queue, formats, maxPastDurationUs, bitrates);
+    for (int i = 0; i < bitrates.length; i++) {
+      int bitrate = bitrates[i];
+      if (bitrate == Format.NO_VALUE
+          || (useFormatBitrateAsLowerBound
+              && formats[i].bitrate != Format.NO_VALUE
+              && bitrate < formats[i].bitrate)) {
+        bitrates[i] = formats[i].bitrate;
+      }
+    }
+    return bitrates;
+  }
+
+  /**
+   * Returns an array containing {@link Format#bitrate} values for given each format in order.
+   *
+   * @param formats The format array to copy {@link Format#bitrate} values.
+   * @param bitrates If not null, stores bitrate values in this array.
+   * @return An array containing {@link Format#bitrate} values for given each format in order.
+   */
+  public static int[] getFormatBitrates(Format[] formats, @Nullable int[] bitrates) {
+    int trackCount = formats.length;
+    if (bitrates == null) {
+      bitrates = new int[trackCount];
+    }
+    for (int i = 0; i < trackCount; i++) {
+      bitrates[i] = formats[i].bitrate;
+    }
+    return bitrates;
+  }
+
+  /**
+   * Fills missing values in the given {@code bitrates} array by calculates an estimation using the
+   * closest reference bitrate value.
+   *
+   * @param bitrates An array of bitrates to be filled with estimations. Missing values are set to
+   *     {@link Format#NO_VALUE}.
+   * @param formats An array of formats, one for each bitrate.
+   * @param referenceBitrates An array of reference bitrates which are used to calculate
+   *     estimations.
+   * @param referenceBitrateRatios An array containing ratio of reference bitrates to their bitrate
+   *     estimates.
+   */
+  private static void estimateBitrates(
+      int[] bitrates, Format[] formats, int[] referenceBitrates, float[] referenceBitrateRatios) {
+    for (int i = 0; i < bitrates.length; i++) {
+      if (bitrates[i] == Format.NO_VALUE) {
+        int formatBitrate = formats[i].bitrate;
+        if (formatBitrate != Format.NO_VALUE) {
+          int closestReferenceBitrateIndex =
+              getClosestBitrateIndex(formatBitrate, referenceBitrates);
+          bitrates[i] =
+              (int) (referenceBitrateRatios[closestReferenceBitrateIndex] * formatBitrate);
+        }
+      }
+    }
+  }
+
+  private static int getAverageQueueBitrate(List<? extends MediaChunk> queue, long maxDurationUs) {
+    if (queue.isEmpty()) {
+      return Format.NO_VALUE;
+    }
+    MediaChunkListIterator iterator =
+        new MediaChunkListIterator(getSingleFormatSubQueue(queue), /* reverseOrder= */ true);
+    return getAverageBitrate(iterator, maxDurationUs);
+  }
+
+  private static List<? extends MediaChunk> getSingleFormatSubQueue(
+      List<? extends MediaChunk> queue) {
+    Format queueFormat = queue.get(queue.size() - 1).trackFormat;
+    int queueSize = queue.size();
+    for (int i = queueSize - 2; i >= 0; i--) {
+      if (!queue.get(i).trackFormat.equals(queueFormat)) {
+        return queue.subList(i + 1, queueSize);
+      }
+    }
+    return queue;
+  }
+
+  private static int getClosestBitrateIndex(int formatBitrate, int[] formatBitrates) {
+    int closestDistance = Integer.MAX_VALUE;
+    int closestFormat = C.INDEX_UNSET;
+    for (int j = 0; j < formatBitrates.length; j++) {
+      if (formatBitrates[j] != Format.NO_VALUE) {
+        int distance = Math.abs(formatBitrates[j] - formatBitrate);
+        if (distance < closestDistance) {
+          closestDistance = distance;
+          closestFormat = j;
+        }
+      }
+    }
+    return closestFormat;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index 3bb603318f..f2fbd89118 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.Assertions;
@@ -40,9 +42,9 @@
  *   <li>When the player is created it will initialize the track selector by calling {@link
  *       #init(InvalidationListener, BandwidthMeter)}.
  *   <li>When the player needs to make a track selection it will call {@link
- *       #selectTracks(RendererCapabilities[], TrackGroupArray)}. This typically occurs at the start
- *       of playback, when the player starts to buffer a new period of the media being played, and
- *       when the track selector invalidates its previous selections.
+ *       #selectTracks(RendererCapabilities[], TrackGroupArray, MediaPeriodId, Timeline)}. This
+ *       typically occurs at the start of playback, when the player starts to buffer a new period of
+ *       the media being played, and when the track selector invalidates its previous selections.
  *   <li>The player may perform a track selection well in advance of the selected tracks becoming
  *       active, where active is defined to mean that the renderers are actually consuming media
  *       corresponding to the selection that was made. For example when playing media containing
@@ -66,14 +68,14 @@
  * <h3>Renderer configuration</h3>
  *
  * The {@link TrackSelectorResult} returned by {@link #selectTracks(RendererCapabilities[],
- * TrackGroupArray)} contains not only {@link TrackSelection}s for each renderer, but also {@link
- * RendererConfiguration}s defining configuration parameters that the renderers should apply when
- * consuming the corresponding media. Whilst it may seem counter-intuitive for a track selector to
- * also specify renderer configuration information, in practice the two are tightly bound together.
- * It may only be possible to play a certain combination tracks if the renderers are configured in a
- * particular way. Equally, it may only be possible to configure renderers in a particular way if
- * certain tracks are selected. Hence it makes sense to determined the track selection and
- * corresponding renderer configurations in a single step.
+ * TrackGroupArray, MediaPeriodId, Timeline)} contains not only {@link TrackSelection}s for each
+ * renderer, but also {@link RendererConfiguration}s defining configuration parameters that the
+ * renderers should apply when consuming the corresponding media. Whilst it may seem counter-
+ * intuitive for a track selector to also specify renderer configuration information, in practice
+ * the two are tightly bound together. It may only be possible to play a certain combination tracks
+ * if the renderers are configured in a particular way. Equally, it may only be possible to
+ * configure renderers in a particular way if certain tracks are selected. Hence it makes sense to
+ * determined the track selection and corresponding renderer configurations in a single step.
  *
  * <h3>Threading model</h3>
  *
@@ -117,15 +119,21 @@ public final void init(InvalidationListener listener, BandwidthMeter bandwidthMe
    * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which tracks
    *     are to be selected.
    * @param trackGroups The available track groups.
+   * @param periodId The {@link MediaPeriodId} of the period for which tracks are to be selected.
+   * @param timeline The {@link Timeline} holding the period for which tracks are to be selected.
    * @return A {@link TrackSelectorResult} describing the track selections.
    * @throws ExoPlaybackException If an error occurs selecting tracks.
    */
-  public abstract TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
-      TrackGroupArray trackGroups) throws ExoPlaybackException;
+  public abstract TrackSelectorResult selectTracks(
+      RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups,
+      MediaPeriodId periodId,
+      Timeline timeline)
+      throws ExoPlaybackException;
 
   /**
-   * Called by the player when a {@link TrackSelectorResult} previously generated by
-   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} is activated.
+   * Called by the player when a {@link TrackSelectorResult} previously generated by {@link
+   * #selectTracks(RendererCapabilities[], TrackGroupArray, MediaPeriodId, Timeline)} is activated.
    *
    * @param info The value of {@link TrackSelectorResult#info} in the activated selection.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
index f1136f0be5..fc723134f7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.util.Util;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
@@ -70,7 +71,7 @@ public boolean isRendererEnabled(int index) {
    *     will be returned.
    * @return Whether this result is equivalent to {@code other} for all renderers.
    */
-  public boolean isEquivalent(TrackSelectorResult other) {
+  public boolean isEquivalent(@Nullable TrackSelectorResult other) {
     if (other == null || other.selections.length != selections.length) {
       return false;
     }
@@ -93,7 +94,7 @@ public boolean isEquivalent(TrackSelectorResult other) {
    * @return Whether this result is equivalent to {@code other} for the renderer at the specified
    *     index.
    */
-  public boolean isEquivalent(TrackSelectorResult other, int index) {
+  public boolean isEquivalent(@Nullable TrackSelectorResult other, int index) {
     if (other == null) {
       return false;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimator.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimator.java
new file mode 100644
index 0000000000..25f7e4ea73
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimator.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.trackselection;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import java.util.List;
+
+/** A {@link TrackBitrateEstimator} which derives estimates from a window of time. */
+public final class WindowedTrackBitrateEstimator implements TrackBitrateEstimator {
+
+  private final long maxPastDurationUs;
+  private final long maxFutureDurationUs;
+  private final boolean useFormatBitrateAsLowerBound;
+
+  /**
+   * @param maxPastDurationMs Maximum duration of past chunks to be included in average bitrate
+   *     values, in milliseconds.
+   * @param maxFutureDurationMs Maximum duration of future chunks to be included in average bitrate
+   *     values, in milliseconds.
+   * @param useFormatBitrateAsLowerBound Whether to use the bitrate of the track's format as a lower
+   *     bound for the estimated bitrate.
+   */
+  public WindowedTrackBitrateEstimator(
+      long maxPastDurationMs, long maxFutureDurationMs, boolean useFormatBitrateAsLowerBound) {
+    this.maxPastDurationUs = C.msToUs(maxPastDurationMs);
+    this.maxFutureDurationUs = C.msToUs(maxFutureDurationMs);
+    this.useFormatBitrateAsLowerBound = useFormatBitrateAsLowerBound;
+  }
+
+  @Override
+  public int[] getBitrates(
+      Format[] formats,
+      List<? extends MediaChunk> queue,
+      MediaChunkIterator[] iterators,
+      @Nullable int[] bitrates) {
+    if (maxFutureDurationUs > 0 || maxPastDurationUs > 0) {
+      return TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
+          formats,
+          queue,
+          maxPastDurationUs,
+          iterators,
+          maxFutureDurationUs,
+          useFormatBitrateAsLowerBound,
+          bitrates);
+    }
+    return TrackSelectionUtil.getFormatBitrates(formats, bitrates);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
index 16c27ccde8..9224e14d4a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
@@ -18,7 +18,7 @@
 import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
index 470937f02f..853a9af526 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * Provides estimates of the currently available bandwidth.
@@ -29,30 +29,33 @@
   interface EventListener {
 
     /**
-     * Called periodically to indicate that bytes have been transferred.
+     * Called periodically to indicate that bytes have been transferred or the estimated bitrate has
+     * changed.
      *
      * <p>Note: The estimated bitrate is typically derived from more information than just {@code
      * bytes} and {@code elapsedMs}.
      *
-     * @param elapsedMs The time taken to transfer the bytes, in milliseconds.
-     * @param bytes The number of bytes transferred.
-     * @param bitrate The estimated bitrate in bits/sec.
+     * @param elapsedMs The time taken to transfer {@code bytesTransferred}, in milliseconds. This
+     *     is at most the elapsed time since the last callback, but may be less if there were
+     *     periods during which data was not being transferred.
+     * @param bytesTransferred The number of bytes transferred since the last callback.
+     * @param bitrateEstimate The estimated bitrate in bits/sec.
      */
-    void onBandwidthSample(int elapsedMs, long bytes, long bitrate);
+    void onBandwidthSample(int elapsedMs, long bytesTransferred, long bitrateEstimate);
   }
 
-  /** Returns the estimated bandwidth in bits/sec. */
+  /** Returns the estimated bitrate. */
   long getBitrateEstimate();
 
   /**
    * Returns the {@link TransferListener} that this instance uses to gather bandwidth information
-   * from data transfers. May be null, if no transfer listener is used.
+   * from data transfers. May be null if the implementation does not listen to data transfers.
    */
   @Nullable
   TransferListener getTransferListener();
 
   /**
-   * Adds an {@link EventListener} to be informed of bandwidth samples.
+   * Adds an {@link EventListener}.
    *
    * @param eventHandler A handler for events.
    * @param eventListener A listener of events.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java
index 5ed2e33d2b..21f2d5993a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/BaseDataSource.java
@@ -17,7 +17,7 @@
 
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.util.ArrayList;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
index 16637b4052..c450896676 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
index 30051a53e6..c723d3f1ca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
@@ -19,7 +19,7 @@
 import android.content.Context;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
 import java.io.FileInputStream;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
index 2d2a7587f7..de4a75d607 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Base64;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index c759499577..204b9d4d66 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 import java.util.Collections;
@@ -64,11 +64,11 @@
   long open(DataSpec dataSpec) throws IOException;
 
   /**
-   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
+   * Reads up to {@code readLength} bytes of data and stores them into {@code buffer}, starting at
    * index {@code offset}.
-   * <p>
-   * If {@code length} is zero then 0 is returned. Otherwise, if no data is available because the
-   * end of the opened range has been reached, then {@link C#RESULT_END_OF_INPUT} is returned.
+   *
+   * <p>If {@code readLength} is zero then 0 is returned. Otherwise, if no data is available because
+   * the end of the opened range has been reached, then {@link C#RESULT_END_OF_INPUT} is returned.
    * Otherwise, the call will block until at least one byte of data has been read and the number of
    * bytes read is returned.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
index 2f2075f354..6c4e77a90a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index 4a4cc021f4..a98f773c9d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.lang.annotation.Documented;
@@ -31,33 +31,44 @@
 public final class DataSpec {
 
   /**
-   * The flags that apply to any request for data. Possible flag values are {@link #FLAG_ALLOW_GZIP}
-   * and {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH}.
+   * The flags that apply to any request for data. Possible flag values are {@link
+   * #FLAG_ALLOW_GZIP}, {@link #FLAG_ALLOW_ICY_METADATA}, {@link #FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN}
+   * and {@link #FLAG_ALLOW_CACHE_FRAGMENTATION}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
-      value = {FLAG_ALLOW_GZIP, FLAG_ALLOW_CACHING_UNKNOWN_LENGTH})
+      value = {
+        FLAG_ALLOW_GZIP,
+        FLAG_ALLOW_ICY_METADATA,
+        FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN,
+        FLAG_ALLOW_CACHE_FRAGMENTATION
+      })
   public @interface Flags {}
   /**
-   * Permits an underlying network stack to request that the server use gzip compression.
-   * <p>
-   * Should not typically be set if the data being requested is already compressed (e.g. most audio
-   * and video requests). May be set when requesting other data.
-   * <p>
-   * When a {@link DataSource} is used to request data with this flag set, and if the
-   * {@link DataSource} does make a network request, then the value returned from
-   * {@link DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNSET}. The data read from
-   * {@link DataSource#read(byte[], int, int)} will be the decompressed data.
+   * Allows an underlying network stack to request that the server use gzip compression.
+   *
+   * <p>Should not typically be set if the data being requested is already compressed (e.g. most
+   * audio and video requests). May be set when requesting other data.
+   *
+   * <p>When a {@link DataSource} is used to request data with this flag set, and if the {@link
+   * DataSource} does make a network request, then the value returned from {@link
+   * DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNSET}. The data read from {@link
+   * DataSource#read(byte[], int, int)} will be the decompressed data.
    */
   public static final int FLAG_ALLOW_GZIP = 1;
-
+  /** Allows an underlying network stack to request that the stream contain ICY metadata. */
+  public static final int FLAG_ALLOW_ICY_METADATA = 1 << 1; // 2
+  /** Prevents caching if the length cannot be resolved when the {@link DataSource} is opened. */
+  public static final int FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN = 1 << 2; // 4
   /**
-   * Permits content to be cached even if its length can not be resolved. Typically this's the case
-   * for progressive live streams and when {@link #FLAG_ALLOW_GZIP} is used.
+   * Allows fragmentation of this request into multiple cache files, meaning a cache eviction policy
+   * will be able to evict individual fragments of the data. Depending on the cache implementation,
+   * setting this flag may also enable more concurrent access to the data (e.g. reading one fragment
+   * whilst writing another).
    */
-  public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1; // 2
+  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 4; // 8
 
   /**
    * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
@@ -108,17 +119,14 @@
   public final long length;
   /**
    * A key that uniquely identifies the original stream. Used for cache indexing. May be null if the
-   * {@link DataSpec} is not intended to be used in conjunction with a cache.
+   * data spec is not intended to be used in conjunction with a cache.
    */
   public final @Nullable String key;
-  /**
-   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} and
-   * {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} are the only supported flags.
-   */
+  /** Request {@link Flags flags}. */
   public final @Flags int flags;
 
   /**
-   * Construct a {@link DataSpec} for the given uri and with {@link #key} set to null.
+   * Construct a data spec for the given uri and with {@link #key} set to null.
    *
    * @param uri {@link #uri}.
    */
@@ -127,7 +135,7 @@ public DataSpec(Uri uri) {
   }
 
   /**
-   * Construct a {@link DataSpec} for the given uri and with {@link #key} set to null.
+   * Construct a data spec for the given uri and with {@link #key} set to null.
    *
    * @param uri {@link #uri}.
    * @param flags {@link #flags}.
@@ -137,7 +145,7 @@ public DataSpec(Uri uri, @Flags int flags) {
   }
 
   /**
-   * Construct a {@link DataSpec} where {@link #position} equals {@link #absoluteStreamPosition}.
+   * Construct a data spec where {@link #position} equals {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param absoluteStreamPosition {@link #absoluteStreamPosition}, equal to {@link #position}.
@@ -149,7 +157,7 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long length, @Nullable Str
   }
 
   /**
-   * Construct a {@link DataSpec} where {@link #position} equals {@link #absoluteStreamPosition}.
+   * Construct a data spec where {@link #position} equals {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param absoluteStreamPosition {@link #absoluteStreamPosition}, equal to {@link #position}.
@@ -163,8 +171,7 @@ public DataSpec(
   }
 
   /**
-   * Construct a {@link DataSpec} where {@link #position} may differ from
-   * {@link #absoluteStreamPosition}.
+   * Construct a data spec where {@link #position} may differ from {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
@@ -184,7 +191,7 @@ public DataSpec(
   }
 
   /**
-   * Construct a {@link DataSpec} by inferring the {@link #httpMethod} based on the {@code postBody}
+   * Construct a data spec by inferring the {@link #httpMethod} based on the {@code postBody}
    * parameter. If postBody is non-null, then httpMethod is set to {@link #HTTP_METHOD_POST}. If
    * postBody is null, then httpMethod is set to {@link #HTTP_METHOD_GET}.
    *
@@ -217,8 +224,7 @@ public DataSpec(
   }
 
   /**
-   * Construct a {@link DataSpec} where {@link #position} may differ from {@link
-   * #absoluteStreamPosition}.
+   * Construct a data spec where {@link #position} may differ from {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param httpMethod {@link #httpMethod}.
@@ -309,22 +315,22 @@ public static String getStringForHttpMethod(@HttpMethod int httpMethod) {
   }
 
   /**
-   * Returns a {@link DataSpec} that represents a subrange of the data defined by this DataSpec. The
+   * Returns a data spec that represents a subrange of the data defined by this DataSpec. The
    * subrange includes data from the offset up to the end of this DataSpec.
    *
    * @param offset The offset of the subrange.
-   * @return A {@link DataSpec} that represents a subrange of the data defined by this DataSpec.
+   * @return A data spec that represents a subrange of the data defined by this DataSpec.
    */
   public DataSpec subrange(long offset) {
     return subrange(offset, length == C.LENGTH_UNSET ? C.LENGTH_UNSET : length - offset);
   }
 
   /**
-   * Returns a {@link DataSpec} that represents a subrange of the data defined by this DataSpec.
+   * Returns a data spec that represents a subrange of the data defined by this DataSpec.
    *
    * @param offset The offset of the subrange.
    * @param length The length of the subrange.
-   * @return A {@link DataSpec} that represents a subrange of the data defined by this DataSpec.
+   * @return A data spec that represents a subrange of the data defined by this DataSpec.
    */
   public DataSpec subrange(long offset, long length) {
     if (offset == 0 && this.length == length) {
@@ -343,10 +349,10 @@ public DataSpec subrange(long offset, long length) {
   }
 
   /**
-   * Returns a copy of this {@link DataSpec} with the specified Uri.
+   * Returns a copy of this data spec with the specified Uri.
    *
    * @param uri The new source {@link Uri}.
-   * @return The copied {@link DataSpec} with the specified Uri.
+   * @return The copied data spec with the specified Uri.
    */
   public DataSpec withUri(Uri uri) {
     return new DataSpec(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index e9f70ec92a..76515a98e6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -15,9 +15,14 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import android.os.Looper;
+import androidx.annotation.Nullable;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
@@ -25,9 +30,12 @@
 import com.google.android.exoplayer2.util.EventDispatcher;
 import com.google.android.exoplayer2.util.SlidingPercentile;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
  * Estimates bandwidth by listening to data transfers.
@@ -48,19 +56,19 @@
 
   /** Default initial Wifi bitrate estimate in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI =
-      new long[] {5_700_000, 3_400_000, 1_900_000, 1_000_000, 400_000};
+      new long[] {5_400_000, 3_400_000, 1_900_000, 1_100_000, 400_000};
 
   /** Default initial 2G bitrate estimates in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_2G =
-      new long[] {169_000, 129_000, 114_000, 102_000, 87_000};
+      new long[] {170_000, 139_000, 122_000, 107_000, 90_000};
 
   /** Default initial 3G bitrate estimates in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_3G =
-      new long[] {2_100_000, 1_300_000, 950_000, 700_000, 400_000};
+      new long[] {2_100_000, 1_300_000, 960_000, 770_000, 450_000};
 
   /** Default initial 4G bitrate estimates in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_4G =
-      new long[] {6_900_000, 4_300_000, 2_700_000, 1_600_000, 450_000};
+      new long[] {6_000_000, 3_400_000, 2_100_000, 1_400_000, 570_000};
 
   /**
    * Default initial bitrate estimate used when the device is offline or the network type cannot be
@@ -76,45 +84,24 @@
 
     @Nullable private final Context context;
 
-    @Nullable private Handler eventHandler;
-    @Nullable private EventListener eventListener;
     private SparseArray<Long> initialBitrateEstimates;
     private int slidingWindowMaxWeight;
     private Clock clock;
-
-    /** @deprecated Use {@link #Builder(Context)} instead. */
-    @Deprecated
-    public Builder() {
-      this(/* context= */ null);
-    }
+    private boolean resetOnNetworkTypeChange;
 
     /**
      * Creates a builder with default parameters and without listener.
      *
      * @param context A context.
      */
-    public Builder(@Nullable Context context) {
+    public Builder(Context context) {
+      // Handling of null is for backward compatibility only.
       this.context = context == null ? null : context.getApplicationContext();
       initialBitrateEstimates = getInitialBitrateEstimatesForCountry(Util.getCountryCode(context));
       slidingWindowMaxWeight = DEFAULT_SLIDING_WINDOW_MAX_WEIGHT;
       clock = Clock.DEFAULT;
     }
 
-    /**
-     * Sets an event listener for new bandwidth estimates.
-     *
-     * @param eventHandler A handler for events.
-     * @param eventListener A listener of events.
-     * @return This builder.
-     * @throws IllegalArgumentException If the event handler or listener are null.
-     */
-    public Builder setEventListener(Handler eventHandler, EventListener eventListener) {
-      Assertions.checkArgument(eventHandler != null && eventListener != null);
-      this.eventHandler = eventHandler;
-      this.eventListener = eventListener;
-      return this;
-    }
-
     /**
      * Sets the maximum weight for the sliding window.
      *
@@ -141,9 +128,8 @@ public Builder setInitialBitrateEstimate(long initialBitrateEstimate) {
     }
 
     /**
-     * Sets the initial bitrate estimate in bits per second for a network type that should be
-     * assumed when a bandwidth estimate is unavailable and the current network connection is of the
-     * specified type.
+     * Sets the initial bitrate estimate in bits per second that should be assumed when a bandwidth
+     * estimate is unavailable and the current network connection is of the specified type.
      *
      * @param networkType The {@link C.NetworkType} this initial estimate is for.
      * @param initialBitrateEstimate The initial bitrate estimate in bits per second.
@@ -181,22 +167,31 @@ public Builder setClock(Clock clock) {
       return this;
     }
 
+    /**
+     * Sets whether to reset if the network type changes.
+     *
+     * <p>This method is experimental, and will be renamed or removed in a future release.
+     *
+     * @param resetOnNetworkTypeChange Whether to reset if the network type changes.
+     * @return This builder.
+     */
+    public Builder experimental_resetOnNetworkTypeChange(boolean resetOnNetworkTypeChange) {
+      this.resetOnNetworkTypeChange = resetOnNetworkTypeChange;
+      return this;
+    }
+
     /**
      * Builds the bandwidth meter.
      *
      * @return A bandwidth meter with the configured properties.
      */
     public DefaultBandwidthMeter build() {
-      Long initialBitrateEstimate = initialBitrateEstimates.get(Util.getNetworkType(context));
-      if (initialBitrateEstimate == null) {
-        initialBitrateEstimate = initialBitrateEstimates.get(C.NETWORK_TYPE_UNKNOWN);
-      }
-      DefaultBandwidthMeter bandwidthMeter =
-          new DefaultBandwidthMeter(initialBitrateEstimate, slidingWindowMaxWeight, clock);
-      if (eventHandler != null && eventListener != null) {
-        bandwidthMeter.addEventListener(eventHandler, eventListener);
-      }
-      return bandwidthMeter;
+      return new DefaultBandwidthMeter(
+          context,
+          initialBitrateEstimates,
+          slidingWindowMaxWeight,
+          clock,
+          resetOnNetworkTypeChange);
     }
 
     private static SparseArray<Long> getInitialBitrateEstimatesForCountry(String countryCode) {
@@ -223,6 +218,8 @@ public DefaultBandwidthMeter build() {
   private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
   private static final int BYTES_TRANSFERRED_FOR_ESTIMATE = 512 * 1024;
 
+  @Nullable private final Context context;
+  private final SparseArray<Long> initialBitrateEstimates;
   private final EventDispatcher<EventListener> eventDispatcher;
   private final SlidingPercentile slidingPercentile;
   private final Clock clock;
@@ -231,38 +228,60 @@ public DefaultBandwidthMeter build() {
   private long sampleStartTimeMs;
   private long sampleBytesTransferred;
 
+  @C.NetworkType private int networkType;
   private long totalElapsedTimeMs;
   private long totalBytesTransferred;
   private long bitrateEstimate;
+  private long lastReportedBitrateEstimate;
 
-  /** Creates a bandwidth meter with default parameters. */
-  public DefaultBandwidthMeter() {
-    this(DEFAULT_INITIAL_BITRATE_ESTIMATE, DEFAULT_SLIDING_WINDOW_MAX_WEIGHT, Clock.DEFAULT);
-  }
-
-  /** @deprecated Use {@link Builder} instead. */
-  @Deprecated
-  public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener) {
-    this(DEFAULT_INITIAL_BITRATE_ESTIMATE, DEFAULT_SLIDING_WINDOW_MAX_WEIGHT, Clock.DEFAULT);
-    if (eventHandler != null && eventListener != null) {
-      addEventListener(eventHandler, eventListener);
-    }
-  }
+  private boolean networkTypeOverrideSet;
+  @C.NetworkType private int networkTypeOverride;
 
   /** @deprecated Use {@link Builder} instead. */
   @Deprecated
-  public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener, int maxWeight) {
-    this(DEFAULT_INITIAL_BITRATE_ESTIMATE, maxWeight, Clock.DEFAULT);
-    if (eventHandler != null && eventListener != null) {
-      addEventListener(eventHandler, eventListener);
-    }
+  public DefaultBandwidthMeter() {
+    this(
+        /* context= */ null,
+        /* initialBitrateEstimates= */ new SparseArray<>(),
+        DEFAULT_SLIDING_WINDOW_MAX_WEIGHT,
+        Clock.DEFAULT,
+        /* resetOnNetworkTypeChange= */ false);
   }
 
-  private DefaultBandwidthMeter(long initialBitrateEstimate, int maxWeight, Clock clock) {
+  private DefaultBandwidthMeter(
+      @Nullable Context context,
+      SparseArray<Long> initialBitrateEstimates,
+      int maxWeight,
+      Clock clock,
+      boolean resetOnNetworkTypeChange) {
+    this.context = context == null ? null : context.getApplicationContext();
+    this.initialBitrateEstimates = initialBitrateEstimates;
     this.eventDispatcher = new EventDispatcher<>();
     this.slidingPercentile = new SlidingPercentile(maxWeight);
     this.clock = clock;
-    bitrateEstimate = initialBitrateEstimate;
+    // Set the initial network type and bitrate estimate
+    networkType = context == null ? C.NETWORK_TYPE_UNKNOWN : Util.getNetworkType(context);
+    bitrateEstimate = getInitialBitrateEstimateForNetworkType(networkType);
+    // Register to receive connectivity actions if possible.
+    if (context != null && resetOnNetworkTypeChange) {
+      ConnectivityActionReceiver connectivityActionReceiver =
+          ConnectivityActionReceiver.getInstance(context);
+      connectivityActionReceiver.register(/* bandwidthMeter= */ this);
+    }
+  }
+
+  /**
+   * Overrides the network type. Handled in the same way as if the meter had detected a change from
+   * the current network type to the specified network type internally.
+   *
+   * <p>Applications should not normally call this method. It is intended for testing purposes.
+   *
+   * @param networkType The overriding network type.
+   */
+  public synchronized void setNetworkTypeOverride(@C.NetworkType int networkType) {
+    networkTypeOverride = networkType;
+    networkTypeOverrideSet = true;
+    onConnectivityAction();
   }
 
   @Override
@@ -329,260 +348,372 @@ public synchronized void onTransferEnd(DataSource source, DataSpec dataSpec, boo
           || totalBytesTransferred >= BYTES_TRANSFERRED_FOR_ESTIMATE) {
         bitrateEstimate = (long) slidingPercentile.getPercentile(0.5f);
       }
-    }
-    notifyBandwidthSample(sampleElapsedTimeMs, sampleBytesTransferred, bitrateEstimate);
-    if (--streamCount > 0) {
+      maybeNotifyBandwidthSample(sampleElapsedTimeMs, sampleBytesTransferred, bitrateEstimate);
       sampleStartTimeMs = nowMs;
+      sampleBytesTransferred = 0;
+    } // Else any sample bytes transferred will be carried forward into the next sample.
+    streamCount--;
+  }
+
+  private synchronized void onConnectivityAction() {
+    int networkType =
+        networkTypeOverrideSet
+            ? networkTypeOverride
+            : (context == null ? C.NETWORK_TYPE_UNKNOWN : Util.getNetworkType(context));
+    if (this.networkType == networkType) {
+      return;
+    }
+
+    this.networkType = networkType;
+    if (networkType == C.NETWORK_TYPE_OFFLINE
+        || networkType == C.NETWORK_TYPE_UNKNOWN
+        || networkType == C.NETWORK_TYPE_OTHER) {
+      // It's better not to reset the bandwidth meter for these network types.
+      return;
     }
+
+    // Reset the bitrate estimate and report it, along with any bytes transferred.
+    this.bitrateEstimate = getInitialBitrateEstimateForNetworkType(networkType);
+    long nowMs = clock.elapsedRealtime();
+    int sampleElapsedTimeMs = streamCount > 0 ? (int) (nowMs - sampleStartTimeMs) : 0;
+    maybeNotifyBandwidthSample(sampleElapsedTimeMs, sampleBytesTransferred, bitrateEstimate);
+
+    // Reset the remainder of the state.
+    sampleStartTimeMs = nowMs;
     sampleBytesTransferred = 0;
+    totalBytesTransferred = 0;
+    totalElapsedTimeMs = 0;
+    slidingPercentile.reset();
+  }
+
+  private void maybeNotifyBandwidthSample(
+      int elapsedMs, long bytesTransferred, long bitrateEstimate) {
+    if (elapsedMs == 0 && bytesTransferred == 0 && bitrateEstimate == lastReportedBitrateEstimate) {
+      return;
+    }
+    lastReportedBitrateEstimate = bitrateEstimate;
+    eventDispatcher.dispatch(
+        listener -> listener.onBandwidthSample(elapsedMs, bytesTransferred, bitrateEstimate));
   }
 
-  private void notifyBandwidthSample(int elapsedMs, long bytes, long bitrate) {
-    eventDispatcher.dispatch(listener -> listener.onBandwidthSample(elapsedMs, bytes, bitrate));
+  private long getInitialBitrateEstimateForNetworkType(@C.NetworkType int networkType) {
+    Long initialBitrateEstimate = initialBitrateEstimates.get(networkType);
+    if (initialBitrateEstimate == null) {
+      initialBitrateEstimate = initialBitrateEstimates.get(C.NETWORK_TYPE_UNKNOWN);
+    }
+    if (initialBitrateEstimate == null) {
+      initialBitrateEstimate = DEFAULT_INITIAL_BITRATE_ESTIMATE;
+    }
+    return initialBitrateEstimate;
+  }
+
+  /*
+   * Note: This class only holds a weak reference to DefaultBandwidthMeter instances. It should not
+   * be made non-static, since doing so adds a strong reference (i.e. DefaultBandwidthMeter.this).
+   */
+  private static class ConnectivityActionReceiver extends BroadcastReceiver {
+
+    @MonotonicNonNull private static ConnectivityActionReceiver staticInstance;
+
+    private final Handler mainHandler;
+    private final ArrayList<WeakReference<DefaultBandwidthMeter>> bandwidthMeters;
+
+    public static synchronized ConnectivityActionReceiver getInstance(Context context) {
+      if (staticInstance == null) {
+        staticInstance = new ConnectivityActionReceiver();
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+        context.registerReceiver(staticInstance, filter);
+      }
+      return staticInstance;
+    }
+
+    private ConnectivityActionReceiver() {
+      mainHandler = new Handler(Looper.getMainLooper());
+      bandwidthMeters = new ArrayList<>();
+    }
+
+    public synchronized void register(DefaultBandwidthMeter bandwidthMeter) {
+      removeClearedReferences();
+      bandwidthMeters.add(new WeakReference<>(bandwidthMeter));
+      // Simulate an initial update on the main thread (like the sticky broadcast we'd receive if
+      // we were to register a separate broadcast receiver for each bandwidth meter).
+      mainHandler.post(() -> updateBandwidthMeter(bandwidthMeter));
+    }
+
+    @Override
+    public synchronized void onReceive(Context context, Intent intent) {
+      if (isInitialStickyBroadcast()) {
+        return;
+      }
+      removeClearedReferences();
+      for (int i = 0; i < bandwidthMeters.size(); i++) {
+        WeakReference<DefaultBandwidthMeter> bandwidthMeterReference = bandwidthMeters.get(i);
+        DefaultBandwidthMeter bandwidthMeter = bandwidthMeterReference.get();
+        if (bandwidthMeter != null) {
+          updateBandwidthMeter(bandwidthMeter);
+        }
+      }
+    }
+
+    private void updateBandwidthMeter(DefaultBandwidthMeter bandwidthMeter) {
+      bandwidthMeter.onConnectivityAction();
+    }
+
+    private void removeClearedReferences() {
+      for (int i = bandwidthMeters.size() - 1; i >= 0; i--) {
+        WeakReference<DefaultBandwidthMeter> bandwidthMeterReference = bandwidthMeters.get(i);
+        DefaultBandwidthMeter bandwidthMeter = bandwidthMeterReference.get();
+        if (bandwidthMeter == null) {
+          bandwidthMeters.remove(i);
+        }
+      }
+    }
   }
 
   private static Map<String, int[]> createInitialBitrateCountryGroupAssignment() {
     HashMap<String, int[]> countryGroupAssignment = new HashMap<>();
-    countryGroupAssignment.put("AD", new int[] {1, 0, 0, 0});
-    countryGroupAssignment.put("AE", new int[] {1, 3, 4, 4});
-    countryGroupAssignment.put("AF", new int[] {4, 4, 3, 2});
-    countryGroupAssignment.put("AG", new int[] {3, 2, 1, 2});
-    countryGroupAssignment.put("AI", new int[] {1, 0, 0, 2});
-    countryGroupAssignment.put("AL", new int[] {1, 1, 1, 1});
-    countryGroupAssignment.put("AM", new int[] {2, 2, 4, 3});
-    countryGroupAssignment.put("AO", new int[] {2, 4, 2, 0});
-    countryGroupAssignment.put("AR", new int[] {2, 3, 2, 3});
-    countryGroupAssignment.put("AS", new int[] {3, 4, 4, 1});
-    countryGroupAssignment.put("AT", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("AU", new int[] {0, 3, 0, 0});
-    countryGroupAssignment.put("AW", new int[] {1, 1, 0, 4});
-    countryGroupAssignment.put("AX", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("AD", new int[] {1, 0, 0, 1});
+    countryGroupAssignment.put("AE", new int[] {1, 4, 4, 4});
+    countryGroupAssignment.put("AF", new int[] {4, 4, 3, 3});
+    countryGroupAssignment.put("AG", new int[] {3, 2, 1, 1});
+    countryGroupAssignment.put("AI", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("AL", new int[] {1, 2, 1, 1});
+    countryGroupAssignment.put("AM", new int[] {2, 2, 3, 2});
+    countryGroupAssignment.put("AO", new int[] {3, 4, 2, 0});
+    countryGroupAssignment.put("AQ", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("AR", new int[] {2, 3, 2, 2});
+    countryGroupAssignment.put("AS", new int[] {3, 3, 4, 1});
+    countryGroupAssignment.put("AT", new int[] {0, 2, 0, 0});
+    countryGroupAssignment.put("AU", new int[] {0, 1, 1, 1});
+    countryGroupAssignment.put("AW", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("AX", new int[] {0, 2, 1, 0});
     countryGroupAssignment.put("AZ", new int[] {3, 3, 2, 2});
     countryGroupAssignment.put("BA", new int[] {1, 1, 1, 2});
     countryGroupAssignment.put("BB", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("BD", new int[] {2, 1, 3, 2});
-    countryGroupAssignment.put("BE", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("BF", new int[] {4, 4, 4, 1});
-    countryGroupAssignment.put("BG", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("BD", new int[] {2, 2, 3, 2});
+    countryGroupAssignment.put("BE", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("BF", new int[] {4, 4, 3, 1});
+    countryGroupAssignment.put("BG", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("BH", new int[] {2, 1, 3, 4});
     countryGroupAssignment.put("BI", new int[] {4, 3, 4, 4});
-    countryGroupAssignment.put("BJ", new int[] {4, 3, 4, 3});
-    countryGroupAssignment.put("BL", new int[] {1, 0, 1, 2});
+    countryGroupAssignment.put("BJ", new int[] {4, 3, 4, 4});
+    countryGroupAssignment.put("BL", new int[] {1, 0, 2, 3});
     countryGroupAssignment.put("BM", new int[] {1, 0, 0, 0});
-    countryGroupAssignment.put("BN", new int[] {4, 3, 3, 3});
-    countryGroupAssignment.put("BO", new int[] {2, 2, 1, 2});
-    countryGroupAssignment.put("BQ", new int[] {1, 1, 2, 4});
-    countryGroupAssignment.put("BR", new int[] {2, 3, 2, 2});
-    countryGroupAssignment.put("BS", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("BN", new int[] {4, 2, 3, 3});
+    countryGroupAssignment.put("BO", new int[] {2, 2, 3, 2});
+    countryGroupAssignment.put("BQ", new int[] {1, 0, 3, 4});
+    countryGroupAssignment.put("BR", new int[] {2, 3, 3, 2});
+    countryGroupAssignment.put("BS", new int[] {2, 0, 1, 4});
     countryGroupAssignment.put("BT", new int[] {3, 0, 2, 1});
-    countryGroupAssignment.put("BW", new int[] {4, 4, 2, 3});
-    countryGroupAssignment.put("BY", new int[] {1, 1, 1, 1});
-    countryGroupAssignment.put("BZ", new int[] {2, 3, 3, 1});
-    countryGroupAssignment.put("CA", new int[] {0, 2, 2, 3});
-    countryGroupAssignment.put("CD", new int[] {4, 4, 2, 1});
-    countryGroupAssignment.put("CF", new int[] {4, 4, 3, 3});
+    countryGroupAssignment.put("BW", new int[] {4, 4, 1, 2});
+    countryGroupAssignment.put("BY", new int[] {0, 1, 1, 2});
+    countryGroupAssignment.put("BZ", new int[] {2, 2, 3, 1});
+    countryGroupAssignment.put("CA", new int[] {0, 3, 3, 3});
+    countryGroupAssignment.put("CD", new int[] {4, 4, 3, 2});
+    countryGroupAssignment.put("CF", new int[] {4, 3, 3, 4});
     countryGroupAssignment.put("CG", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("CH", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("CI", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("CK", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("CH", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("CI", new int[] {3, 4, 3, 3});
+    countryGroupAssignment.put("CK", new int[] {2, 4, 1, 0});
     countryGroupAssignment.put("CL", new int[] {2, 2, 2, 3});
-    countryGroupAssignment.put("CM", new int[] {3, 4, 3, 1});
-    countryGroupAssignment.put("CN", new int[] {2, 0, 1, 2});
-    countryGroupAssignment.put("CO", new int[] {2, 3, 2, 1});
+    countryGroupAssignment.put("CM", new int[] {3, 4, 2, 1});
+    countryGroupAssignment.put("CN", new int[] {2, 2, 2, 3});
+    countryGroupAssignment.put("CO", new int[] {2, 3, 2, 2});
     countryGroupAssignment.put("CR", new int[] {2, 2, 4, 4});
-    countryGroupAssignment.put("CU", new int[] {4, 4, 4, 1});
-    countryGroupAssignment.put("CV", new int[] {2, 2, 2, 4});
-    countryGroupAssignment.put("CW", new int[] {1, 1, 0, 0});
-    countryGroupAssignment.put("CX", new int[] {1, 2, 2, 2});
-    countryGroupAssignment.put("CY", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("CU", new int[] {4, 4, 3, 1});
+    countryGroupAssignment.put("CV", new int[] {2, 3, 2, 4});
+    countryGroupAssignment.put("CW", new int[] {1, 0, 0, 0});
+    countryGroupAssignment.put("CX", new int[] {2, 2, 2, 2});
+    countryGroupAssignment.put("CY", new int[] {1, 1, 1, 1});
     countryGroupAssignment.put("CZ", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("DE", new int[] {0, 2, 2, 2});
-    countryGroupAssignment.put("DJ", new int[] {3, 4, 4, 0});
+    countryGroupAssignment.put("DJ", new int[] {3, 3, 4, 0});
     countryGroupAssignment.put("DK", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("DM", new int[] {2, 0, 3, 4});
+    countryGroupAssignment.put("DM", new int[] {1, 0, 0, 3});
     countryGroupAssignment.put("DO", new int[] {3, 3, 4, 4});
     countryGroupAssignment.put("DZ", new int[] {3, 3, 4, 4});
-    countryGroupAssignment.put("EC", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("EC", new int[] {2, 4, 4, 2});
     countryGroupAssignment.put("EE", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("EG", new int[] {3, 3, 1, 1});
-    countryGroupAssignment.put("EH", new int[] {2, 0, 2, 3});
+    countryGroupAssignment.put("EG", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("EH", new int[] {2, 0, 3, 3});
     countryGroupAssignment.put("ER", new int[] {4, 2, 2, 2});
-    countryGroupAssignment.put("ES", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("ES", new int[] {0, 1, 1, 1});
     countryGroupAssignment.put("ET", new int[] {4, 4, 4, 0});
     countryGroupAssignment.put("FI", new int[] {0, 0, 1, 0});
-    countryGroupAssignment.put("FJ", new int[] {3, 2, 3, 3});
-    countryGroupAssignment.put("FK", new int[] {3, 4, 2, 1});
+    countryGroupAssignment.put("FJ", new int[] {3, 1, 3, 3});
+    countryGroupAssignment.put("FK", new int[] {4, 2, 2, 3});
     countryGroupAssignment.put("FM", new int[] {4, 2, 4, 0});
-    countryGroupAssignment.put("FO", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("FR", new int[] {1, 0, 2, 1});
+    countryGroupAssignment.put("FO", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("FR", new int[] {1, 0, 3, 1});
     countryGroupAssignment.put("GA", new int[] {3, 3, 2, 1});
-    countryGroupAssignment.put("GB", new int[] {0, 1, 3, 2});
-    countryGroupAssignment.put("GD", new int[] {2, 0, 3, 0});
+    countryGroupAssignment.put("GB", new int[] {0, 1, 3, 3});
+    countryGroupAssignment.put("GD", new int[] {2, 0, 4, 4});
     countryGroupAssignment.put("GE", new int[] {1, 1, 0, 3});
     countryGroupAssignment.put("GF", new int[] {1, 2, 4, 4});
-    countryGroupAssignment.put("GG", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("GH", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("GG", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("GH", new int[] {3, 3, 3, 2});
     countryGroupAssignment.put("GI", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("GL", new int[] {2, 4, 1, 4});
-    countryGroupAssignment.put("GM", new int[] {4, 3, 3, 0});
-    countryGroupAssignment.put("GN", new int[] {4, 4, 3, 4});
+    countryGroupAssignment.put("GL", new int[] {2, 2, 3, 4});
+    countryGroupAssignment.put("GM", new int[] {4, 3, 3, 2});
+    countryGroupAssignment.put("GN", new int[] {4, 4, 4, 0});
     countryGroupAssignment.put("GP", new int[] {2, 2, 1, 3});
-    countryGroupAssignment.put("GQ", new int[] {4, 4, 3, 1});
+    countryGroupAssignment.put("GQ", new int[] {4, 3, 3, 0});
     countryGroupAssignment.put("GR", new int[] {1, 1, 0, 1});
-    countryGroupAssignment.put("GT", new int[] {3, 2, 3, 4});
-    countryGroupAssignment.put("GU", new int[] {1, 0, 4, 4});
+    countryGroupAssignment.put("GT", new int[] {3, 3, 3, 4});
+    countryGroupAssignment.put("GU", new int[] {1, 2, 4, 4});
     countryGroupAssignment.put("GW", new int[] {4, 4, 4, 0});
     countryGroupAssignment.put("GY", new int[] {3, 4, 1, 0});
-    countryGroupAssignment.put("HK", new int[] {0, 2, 3, 4});
+    countryGroupAssignment.put("HK", new int[] {0, 1, 4, 4});
     countryGroupAssignment.put("HN", new int[] {3, 3, 2, 2});
     countryGroupAssignment.put("HR", new int[] {1, 0, 0, 2});
-    countryGroupAssignment.put("HT", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("HT", new int[] {3, 4, 4, 3});
     countryGroupAssignment.put("HU", new int[] {0, 0, 1, 0});
-    countryGroupAssignment.put("ID", new int[] {2, 3, 3, 4});
-    countryGroupAssignment.put("IE", new int[] {0, 0, 1, 1});
-    countryGroupAssignment.put("IL", new int[] {0, 1, 1, 3});
-    countryGroupAssignment.put("IM", new int[] {0, 1, 0, 1});
-    countryGroupAssignment.put("IN", new int[] {2, 3, 3, 4});
-    countryGroupAssignment.put("IO", new int[] {4, 2, 2, 2});
-    countryGroupAssignment.put("IQ", new int[] {3, 3, 4, 3});
-    countryGroupAssignment.put("IR", new int[] {3, 2, 4, 4});
+    countryGroupAssignment.put("ID", new int[] {3, 2, 3, 4});
+    countryGroupAssignment.put("IE", new int[] {0, 0, 3, 2});
+    countryGroupAssignment.put("IL", new int[] {0, 1, 2, 3});
+    countryGroupAssignment.put("IM", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("IN", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("IO", new int[] {4, 4, 2, 2});
+    countryGroupAssignment.put("IQ", new int[] {3, 3, 4, 4});
+    countryGroupAssignment.put("IR", new int[] {1, 0, 1, 0});
     countryGroupAssignment.put("IS", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("IT", new int[] {1, 0, 1, 3});
-    countryGroupAssignment.put("JE", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("JM", new int[] {3, 3, 3, 2});
+    countryGroupAssignment.put("IT", new int[] {1, 0, 1, 1});
+    countryGroupAssignment.put("JE", new int[] {1, 0, 0, 1});
+    countryGroupAssignment.put("JM", new int[] {3, 2, 2, 1});
     countryGroupAssignment.put("JO", new int[] {1, 1, 1, 2});
-    countryGroupAssignment.put("JP", new int[] {0, 1, 1, 2});
+    countryGroupAssignment.put("JP", new int[] {0, 2, 2, 2});
     countryGroupAssignment.put("KE", new int[] {3, 3, 3, 3});
-    countryGroupAssignment.put("KG", new int[] {2, 2, 3, 3});
-    countryGroupAssignment.put("KH", new int[] {1, 0, 4, 4});
+    countryGroupAssignment.put("KG", new int[] {1, 1, 2, 3});
+    countryGroupAssignment.put("KH", new int[] {2, 0, 4, 4});
     countryGroupAssignment.put("KI", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("KM", new int[] {4, 4, 2, 2});
-    countryGroupAssignment.put("KN", new int[] {1, 0, 1, 3});
-    countryGroupAssignment.put("KP", new int[] {1, 2, 2, 2});
-    countryGroupAssignment.put("KR", new int[] {0, 4, 0, 2});
-    countryGroupAssignment.put("KW", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("KM", new int[] {4, 4, 3, 3});
+    countryGroupAssignment.put("KN", new int[] {1, 0, 1, 4});
+    countryGroupAssignment.put("KP", new int[] {1, 2, 0, 2});
+    countryGroupAssignment.put("KR", new int[] {0, 3, 0, 2});
+    countryGroupAssignment.put("KW", new int[] {2, 2, 1, 2});
     countryGroupAssignment.put("KY", new int[] {1, 1, 0, 2});
-    countryGroupAssignment.put("KZ", new int[] {1, 2, 2, 3});
-    countryGroupAssignment.put("LA", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("KZ", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("LA", new int[] {2, 1, 1, 0});
     countryGroupAssignment.put("LB", new int[] {3, 2, 0, 0});
-    countryGroupAssignment.put("LC", new int[] {2, 2, 1, 0});
-    countryGroupAssignment.put("LI", new int[] {0, 0, 1, 2});
+    countryGroupAssignment.put("LC", new int[] {2, 1, 0, 0});
+    countryGroupAssignment.put("LI", new int[] {0, 0, 2, 2});
     countryGroupAssignment.put("LK", new int[] {1, 1, 2, 2});
-    countryGroupAssignment.put("LR", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("LR", new int[] {3, 4, 4, 1});
     countryGroupAssignment.put("LS", new int[] {3, 3, 2, 0});
-    countryGroupAssignment.put("LT", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("LU", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("LT", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("LU", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("LV", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("LY", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("LY", new int[] {4, 3, 4, 4});
     countryGroupAssignment.put("MA", new int[] {2, 1, 2, 2});
     countryGroupAssignment.put("MC", new int[] {1, 0, 1, 0});
     countryGroupAssignment.put("MD", new int[] {1, 1, 0, 0});
     countryGroupAssignment.put("ME", new int[] {1, 2, 2, 3});
-    countryGroupAssignment.put("MF", new int[] {1, 4, 3, 3});
-    countryGroupAssignment.put("MG", new int[] {3, 4, 1, 2});
+    countryGroupAssignment.put("MF", new int[] {1, 4, 2, 1});
+    countryGroupAssignment.put("MG", new int[] {3, 4, 1, 3});
     countryGroupAssignment.put("MH", new int[] {4, 0, 2, 3});
-    countryGroupAssignment.put("MK", new int[] {1, 0, 0, 1});
-    countryGroupAssignment.put("ML", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MK", new int[] {1, 0, 0, 0});
+    countryGroupAssignment.put("ML", new int[] {4, 4, 4, 3});
     countryGroupAssignment.put("MM", new int[] {2, 3, 1, 2});
-    countryGroupAssignment.put("MN", new int[] {2, 2, 2, 4});
-    countryGroupAssignment.put("MO", new int[] {0, 1, 4, 4});
-    countryGroupAssignment.put("MP", new int[] {0, 0, 4, 4});
+    countryGroupAssignment.put("MN", new int[] {2, 3, 2, 4});
+    countryGroupAssignment.put("MO", new int[] {0, 0, 4, 4});
+    countryGroupAssignment.put("MP", new int[] {0, 2, 4, 4});
     countryGroupAssignment.put("MQ", new int[] {1, 1, 1, 3});
-    countryGroupAssignment.put("MR", new int[] {4, 2, 4, 2});
-    countryGroupAssignment.put("MS", new int[] {1, 2, 1, 2});
-    countryGroupAssignment.put("MT", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("MU", new int[] {2, 2, 4, 4});
-    countryGroupAssignment.put("MV", new int[] {4, 2, 0, 1});
-    countryGroupAssignment.put("MW", new int[] {3, 2, 1, 1});
-    countryGroupAssignment.put("MX", new int[] {2, 4, 3, 1});
-    countryGroupAssignment.put("MY", new int[] {2, 3, 3, 3});
-    countryGroupAssignment.put("MZ", new int[] {3, 3, 2, 4});
-    countryGroupAssignment.put("NA", new int[] {4, 2, 1, 1});
-    countryGroupAssignment.put("NC", new int[] {2, 1, 3, 3});
-    countryGroupAssignment.put("NE", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("NF", new int[] {0, 2, 2, 2});
-    countryGroupAssignment.put("NG", new int[] {3, 4, 2, 2});
-    countryGroupAssignment.put("NI", new int[] {3, 4, 3, 3});
-    countryGroupAssignment.put("NL", new int[] {0, 1, 3, 2});
-    countryGroupAssignment.put("NO", new int[] {0, 0, 1, 0});
-    countryGroupAssignment.put("NP", new int[] {2, 3, 2, 2});
-    countryGroupAssignment.put("NR", new int[] {4, 3, 4, 1});
-    countryGroupAssignment.put("NU", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("MR", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MS", new int[] {1, 4, 0, 3});
+    countryGroupAssignment.put("MT", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("MU", new int[] {2, 2, 3, 4});
+    countryGroupAssignment.put("MV", new int[] {3, 2, 1, 1});
+    countryGroupAssignment.put("MW", new int[] {4, 2, 1, 1});
+    countryGroupAssignment.put("MX", new int[] {2, 4, 3, 2});
+    countryGroupAssignment.put("MY", new int[] {2, 2, 2, 3});
+    countryGroupAssignment.put("MZ", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("NA", new int[] {3, 2, 2, 1});
+    countryGroupAssignment.put("NC", new int[] {2, 1, 3, 2});
+    countryGroupAssignment.put("NE", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("NF", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("NG", new int[] {3, 4, 3, 2});
+    countryGroupAssignment.put("NI", new int[] {3, 3, 3, 4});
+    countryGroupAssignment.put("NL", new int[] {0, 2, 4, 3});
+    countryGroupAssignment.put("NO", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("NP", new int[] {3, 3, 2, 2});
+    countryGroupAssignment.put("NR", new int[] {4, 0, 4, 0});
+    countryGroupAssignment.put("NU", new int[] {2, 2, 2, 1});
     countryGroupAssignment.put("NZ", new int[] {0, 0, 0, 1});
     countryGroupAssignment.put("OM", new int[] {2, 2, 1, 3});
-    countryGroupAssignment.put("PA", new int[] {1, 3, 2, 3});
-    countryGroupAssignment.put("PE", new int[] {2, 2, 4, 4});
-    countryGroupAssignment.put("PF", new int[] {2, 2, 0, 1});
-    countryGroupAssignment.put("PG", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("PA", new int[] {1, 3, 3, 4});
+    countryGroupAssignment.put("PE", new int[] {2, 3, 4, 4});
+    countryGroupAssignment.put("PF", new int[] {3, 1, 0, 1});
+    countryGroupAssignment.put("PG", new int[] {4, 3, 1, 1});
     countryGroupAssignment.put("PH", new int[] {3, 0, 4, 4});
     countryGroupAssignment.put("PK", new int[] {3, 3, 3, 3});
-    countryGroupAssignment.put("PL", new int[] {1, 0, 1, 3});
-    countryGroupAssignment.put("PM", new int[] {0, 2, 2, 3});
-    countryGroupAssignment.put("PR", new int[] {2, 3, 4, 3});
-    countryGroupAssignment.put("PS", new int[] {2, 3, 0, 4});
-    countryGroupAssignment.put("PT", new int[] {1, 1, 1, 1});
-    countryGroupAssignment.put("PW", new int[] {3, 2, 3, 0});
-    countryGroupAssignment.put("PY", new int[] {2, 1, 3, 3});
-    countryGroupAssignment.put("QA", new int[] {2, 3, 1, 2});
-    countryGroupAssignment.put("RE", new int[] {1, 1, 2, 2});
-    countryGroupAssignment.put("RO", new int[] {0, 1, 1, 3});
-    countryGroupAssignment.put("RS", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("PL", new int[] {1, 1, 1, 3});
+    countryGroupAssignment.put("PM", new int[] {0, 2, 0, 0});
+    countryGroupAssignment.put("PR", new int[] {2, 1, 3, 3});
+    countryGroupAssignment.put("PS", new int[] {3, 3, 1, 4});
+    countryGroupAssignment.put("PT", new int[] {1, 1, 0, 1});
+    countryGroupAssignment.put("PW", new int[] {2, 2, 1, 1});
+    countryGroupAssignment.put("PY", new int[] {3, 1, 3, 3});
+    countryGroupAssignment.put("QA", new int[] {2, 3, 0, 1});
+    countryGroupAssignment.put("RE", new int[] {1, 0, 2, 2});
+    countryGroupAssignment.put("RO", new int[] {0, 1, 1, 2});
+    countryGroupAssignment.put("RS", new int[] {1, 2, 0, 0});
     countryGroupAssignment.put("RU", new int[] {0, 1, 1, 1});
-    countryGroupAssignment.put("RW", new int[] {3, 4, 3, 1});
-    countryGroupAssignment.put("SA", new int[] {3, 2, 2, 3});
+    countryGroupAssignment.put("RW", new int[] {3, 4, 2, 4});
+    countryGroupAssignment.put("SA", new int[] {2, 2, 1, 2});
     countryGroupAssignment.put("SB", new int[] {4, 4, 3, 0});
     countryGroupAssignment.put("SC", new int[] {4, 2, 0, 1});
-    countryGroupAssignment.put("SD", new int[] {3, 4, 4, 4});
-    countryGroupAssignment.put("SE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("SD", new int[] {4, 4, 4, 2});
+    countryGroupAssignment.put("SE", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("SG", new int[] {1, 2, 3, 3});
-    countryGroupAssignment.put("SH", new int[] {4, 2, 2, 2});
-    countryGroupAssignment.put("SI", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("SJ", new int[] {3, 2, 0, 2});
+    countryGroupAssignment.put("SH", new int[] {4, 4, 2, 3});
+    countryGroupAssignment.put("SI", new int[] {0, 1, 0, 1});
+    countryGroupAssignment.put("SJ", new int[] {0, 0, 2, 0});
     countryGroupAssignment.put("SK", new int[] {0, 1, 0, 1});
     countryGroupAssignment.put("SL", new int[] {4, 3, 2, 4});
-    countryGroupAssignment.put("SM", new int[] {1, 0, 1, 1});
-    countryGroupAssignment.put("SN", new int[] {4, 4, 4, 2});
-    countryGroupAssignment.put("SO", new int[] {4, 4, 4, 3});
-    countryGroupAssignment.put("SR", new int[] {3, 2, 2, 3});
-    countryGroupAssignment.put("SS", new int[] {4, 3, 4, 2});
-    countryGroupAssignment.put("ST", new int[] {3, 2, 2, 2});
-    countryGroupAssignment.put("SV", new int[] {2, 3, 2, 3});
-    countryGroupAssignment.put("SX", new int[] {2, 4, 2, 0});
-    countryGroupAssignment.put("SY", new int[] {4, 4, 2, 0});
-    countryGroupAssignment.put("SZ", new int[] {3, 4, 1, 1});
-    countryGroupAssignment.put("TC", new int[] {2, 1, 2, 1});
+    countryGroupAssignment.put("SM", new int[] {0, 0, 1, 3});
+    countryGroupAssignment.put("SN", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("SO", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("SR", new int[] {3, 2, 2, 4});
+    countryGroupAssignment.put("SS", new int[] {4, 2, 4, 2});
+    countryGroupAssignment.put("ST", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("SV", new int[] {2, 3, 3, 4});
+    countryGroupAssignment.put("SX", new int[] {2, 4, 1, 0});
+    countryGroupAssignment.put("SY", new int[] {4, 4, 1, 0});
+    countryGroupAssignment.put("SZ", new int[] {3, 4, 2, 3});
+    countryGroupAssignment.put("TC", new int[] {1, 1, 3, 1});
     countryGroupAssignment.put("TD", new int[] {4, 4, 4, 3});
-    countryGroupAssignment.put("TG", new int[] {3, 2, 2, 0});
+    countryGroupAssignment.put("TG", new int[] {3, 3, 1, 0});
     countryGroupAssignment.put("TH", new int[] {1, 3, 4, 4});
     countryGroupAssignment.put("TJ", new int[] {4, 4, 4, 4});
     countryGroupAssignment.put("TL", new int[] {4, 2, 4, 4});
-    countryGroupAssignment.put("TM", new int[] {4, 1, 3, 3});
-    countryGroupAssignment.put("TN", new int[] {2, 2, 1, 2});
-    countryGroupAssignment.put("TO", new int[] {2, 3, 3, 1});
-    countryGroupAssignment.put("TR", new int[] {1, 2, 0, 2});
-    countryGroupAssignment.put("TT", new int[] {2, 1, 1, 0});
+    countryGroupAssignment.put("TM", new int[] {4, 1, 2, 3});
+    countryGroupAssignment.put("TN", new int[] {2, 1, 1, 1});
+    countryGroupAssignment.put("TO", new int[] {3, 3, 3, 1});
+    countryGroupAssignment.put("TR", new int[] {1, 2, 0, 1});
+    countryGroupAssignment.put("TT", new int[] {2, 3, 1, 2});
     countryGroupAssignment.put("TV", new int[] {4, 2, 2, 4});
     countryGroupAssignment.put("TW", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("TZ", new int[] {3, 3, 3, 2});
-    countryGroupAssignment.put("UA", new int[] {0, 2, 1, 3});
-    countryGroupAssignment.put("UG", new int[] {4, 3, 2, 2});
+    countryGroupAssignment.put("TZ", new int[] {3, 3, 4, 3});
+    countryGroupAssignment.put("UA", new int[] {0, 2, 1, 2});
+    countryGroupAssignment.put("UG", new int[] {4, 3, 2, 3});
     countryGroupAssignment.put("US", new int[] {0, 1, 3, 3});
-    countryGroupAssignment.put("UY", new int[] {2, 1, 2, 2});
-    countryGroupAssignment.put("UZ", new int[] {4, 3, 2, 4});
+    countryGroupAssignment.put("UY", new int[] {2, 2, 2, 2});
+    countryGroupAssignment.put("UZ", new int[] {3, 2, 2, 2});
     countryGroupAssignment.put("VA", new int[] {1, 2, 2, 2});
-    countryGroupAssignment.put("VC", new int[] {2, 0, 3, 2});
-    countryGroupAssignment.put("VE", new int[] {3, 4, 4, 3});
-    countryGroupAssignment.put("VG", new int[] {3, 1, 3, 4});
+    countryGroupAssignment.put("VC", new int[] {2, 1, 0, 0});
+    countryGroupAssignment.put("VE", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("VG", new int[] {2, 1, 1, 2});
     countryGroupAssignment.put("VI", new int[] {1, 0, 2, 4});
     countryGroupAssignment.put("VN", new int[] {0, 2, 4, 4});
-    countryGroupAssignment.put("VU", new int[] {4, 1, 3, 2});
-    countryGroupAssignment.put("WS", new int[] {3, 2, 3, 0});
+    countryGroupAssignment.put("VU", new int[] {4, 1, 3, 1});
+    countryGroupAssignment.put("WS", new int[] {3, 2, 3, 1});
     countryGroupAssignment.put("XK", new int[] {1, 2, 1, 0});
     countryGroupAssignment.put("YE", new int[] {4, 4, 4, 2});
-    countryGroupAssignment.put("YT", new int[] {3, 1, 1, 2});
-    countryGroupAssignment.put("ZA", new int[] {2, 3, 1, 2});
-    countryGroupAssignment.put("ZM", new int[] {3, 3, 3, 1});
-    countryGroupAssignment.put("ZW", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("YT", new int[] {2, 0, 2, 3});
+    countryGroupAssignment.put("ZA", new int[] {2, 3, 2, 2});
+    countryGroupAssignment.put("ZM", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("ZW", new int[] {3, 3, 3, 1});
     return Collections.unmodifiableMap(countryGroupAssignment);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index 6504562c58..8b4107850c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -17,7 +17,7 @@
 
 import android.content.Context;
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
@@ -228,7 +228,8 @@ public long open(DataSpec dataSpec) throws IOException {
     // Choose the correct source for the scheme.
     String scheme = dataSpec.uri.getScheme();
     if (Util.isLocalFileUri(dataSpec.uri)) {
-      if (dataSpec.uri.getPath().startsWith("/android_asset/")) {
+      String uriPath = dataSpec.uri.getPath();
+      if (uriPath != null && uriPath.startsWith("/android_asset/")) {
         dataSource = getAssetDataSource();
       } else {
         dataSource = getFileDataSource();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java
index 8183a89064..9639b4ede1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSourceFactory.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.content.Context;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DataSource.Factory;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index c6749e6c8f..6aad517004 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -16,9 +16,10 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.DataSpec.HttpMethod;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
@@ -429,12 +430,20 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
+    boolean allowIcyMetadata = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA);
 
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
       // automatically. This is the behavior we want, so use it.
       return makeConnection(
-          url, httpMethod, httpBody, position, length, allowGzip, true /* followRedirects */);
+          url,
+          httpMethod,
+          httpBody,
+          position,
+          length,
+          allowGzip,
+          allowIcyMetadata,
+          /* followRedirects= */ true);
     }
 
     // We need to handle redirects ourselves to allow cross-protocol redirects.
@@ -442,7 +451,14 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     while (redirectCount++ <= MAX_REDIRECTS) {
       HttpURLConnection connection =
           makeConnection(
-              url, httpMethod, httpBody, position, length, allowGzip, false /* followRedirects */);
+              url,
+              httpMethod,
+              httpBody,
+              position,
+              length,
+              allowGzip,
+              allowIcyMetadata,
+              /* followRedirects= */ false);
       int responseCode = connection.getResponseCode();
       String location = connection.getHeaderField("Location");
       if ((httpMethod == DataSpec.HTTP_METHOD_GET || httpMethod == DataSpec.HTTP_METHOD_HEAD)
@@ -482,6 +498,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
    * @param position The byte offset of the requested data.
    * @param length The length of the requested data, or {@link C#LENGTH_UNSET}.
    * @param allowGzip Whether to allow the use of gzip.
+   * @param allowIcyMetadata Whether to allow ICY metadata.
    * @param followRedirects Whether to follow redirects.
    */
   private HttpURLConnection makeConnection(
@@ -491,6 +508,7 @@ private HttpURLConnection makeConnection(
       long position,
       long length,
       boolean allowGzip,
+      boolean allowIcyMetadata,
       boolean followRedirects)
       throws IOException {
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
@@ -515,6 +533,11 @@ private HttpURLConnection makeConnection(
     if (!allowGzip) {
       connection.setRequestProperty("Accept-Encoding", "identity");
     }
+    if (allowIcyMetadata) {
+      connection.setRequestProperty(
+          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
+          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
+    }
     connection.setInstanceFollowRedirects(followRedirects);
     connection.setDoOutput(httpBody != null);
     connection.setRequestMethod(DataSpec.getStringForHttpMethod(httpMethod));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
index 95ea49132d..371343857f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
@@ -15,9 +15,10 @@
  */
 package com.google.android.exoplayer2.upstream;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
+import com.google.android.exoplayer2.util.Assertions;
 
 /** A {@link Factory} that produces {@link DefaultHttpDataSource} instances. */
 public final class DefaultHttpDataSourceFactory extends BaseFactory {
@@ -93,7 +94,7 @@ public DefaultHttpDataSourceFactory(
       int connectTimeoutMillis,
       int readTimeoutMillis,
       boolean allowCrossProtocolRedirects) {
-    this.userAgent = userAgent;
+    this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.listener = listener;
     this.connectTimeoutMillis = connectTimeoutMillis;
     this.readTimeoutMillis = readTimeoutMillis;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
index e2c5f3ef88..307652f456 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
@@ -18,6 +18,8 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
+import com.google.android.exoplayer2.upstream.Loader.UnexpectedLoaderException;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 
 /** Default implementation of {@link LoadErrorHandlingPolicy}. */
@@ -76,13 +78,16 @@ public long getBlacklistDurationMsFor(
   }
 
   /**
-   * Retries for any exception that is not a subclass of {@link ParserException}. The retry delay is
-   * calculated as {@code Math.min((errorCount - 1) * 1000, 5000)}.
+   * Retries for any exception that is not a subclass of {@link ParserException}, {@link
+   * FileNotFoundException} or {@link UnexpectedLoaderException}. The retry delay is calculated as
+   * {@code Math.min((errorCount - 1) * 1000, 5000)}.
    */
   @Override
   public long getRetryDelayMsFor(
       int dataType, long loadDurationMs, IOException exception, int errorCount) {
     return exception instanceof ParserException
+            || exception instanceof FileNotFoundException
+            || exception instanceof UnexpectedLoaderException
         ? C.TIME_UNSET
         : Math.min((errorCount - 1) * 1000, 5000);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
index 13c5732a62..026bc0b9c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.io.IOException;
 
 /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index 582b2b06da..3cfdc4812b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
index fd1920991e..3a47df7654 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * A {@link DataSource.Factory} that produces {@link FileDataSource}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index e3e93bd6fb..07155ee2bc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index ac3b3c5c5e..878c40dc9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -20,8 +20,8 @@
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index cdcb3787fa..edec849b88 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
@@ -69,6 +69,24 @@
     return Assertions.checkNotNull(loadable.getResult());
   }
 
+  /**
+   * Loads a single parsable object.
+   *
+   * @param dataSource The {@link DataSource} through which the object should be read.
+   * @param parser The {@link Parser} to parse the object from the response.
+   * @param dataSpec The {@link DataSpec} of the object to read.
+   * @param type The type of the data. One of the {@link C}{@code DATA_TYPE_*} constants.
+   * @return The parsed object
+   * @throws IOException Thrown if there is an error while loading or parsing.
+   */
+  public static <T> T load(
+      DataSource dataSource, Parser<? extends T> parser, DataSpec dataSpec, int type)
+      throws IOException {
+    ParsingLoadable<T> loadable = new ParsingLoadable<>(dataSource, dataSpec, type, parser);
+    loadable.load();
+    return Assertions.checkNotNull(loadable.getResult());
+  }
+
   /**
    * The {@link DataSpec} that defines the data to be loaded.
    */
@@ -91,11 +109,7 @@
    * @param parser Parses the object from the response.
    */
   public ParsingLoadable(DataSource dataSource, Uri uri, int type, Parser<? extends T> parser) {
-    this(
-        dataSource,
-        new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH),
-        type,
-        parser);
+    this(dataSource, new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP), type, parser);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
index 9f9a3f9a91..62e68cd920 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
index 7f51efda0f..1f0313594b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
@@ -19,7 +19,7 @@
 import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import java.io.EOFException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java
index 04b29b531c..b7a01505f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/StatsDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
index 3c021b0b74..ecf25f2eb6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
index 8d6b39fa98..e7aab31cc2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 import java.net.DatagramPacket;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index b5b5dc64e6..12905f908c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import java.io.File;
 import java.io.IOException;
 import java.util.NavigableSet;
@@ -48,21 +49,20 @@
     void onSpanRemoved(Cache cache, CacheSpan span);
 
     /**
-     * Called when an existing {@link CacheSpan} is accessed, causing it to be replaced. The new
+     * Called when an existing {@link CacheSpan} is touched, causing it to be replaced. The new
      * {@link CacheSpan} is guaranteed to represent the same data as the one it replaces, however
-     * {@link CacheSpan#file} and {@link CacheSpan#lastAccessTimestamp} may have changed.
-     * <p>
-     * Note that for span replacement, {@link #onSpanAdded(Cache, CacheSpan)} and
-     * {@link #onSpanRemoved(Cache, CacheSpan)} are not called in addition to this method.
+     * {@link CacheSpan#file} and {@link CacheSpan#lastTouchTimestamp} may have changed.
+     *
+     * <p>Note that for span replacement, {@link #onSpanAdded(Cache, CacheSpan)} and {@link
+     * #onSpanRemoved(Cache, CacheSpan)} are not called in addition to this method.
      *
      * @param cache The source of the event.
      * @param oldSpan The old {@link CacheSpan}, which has been removed from the cache.
      * @param newSpan The new {@link CacheSpan}, which has been added to the cache.
      */
     void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan);
-
   }
-  
+
   /**
    * Thrown when an error is encountered when writing data.
    */
@@ -76,8 +76,27 @@ public CacheException(Throwable cause) {
       super(cause);
     }
 
+    public CacheException(String message, Throwable cause) {
+      super(message, cause);
+    }
   }
 
+  /**
+   * Returned by {@link #getUid()} if initialization failed before the unique identifier was read or
+   * generated.
+   */
+  long UID_UNSET = -1;
+
+  /**
+   * Returns a non-negative unique identifier for the cache, or {@link #UID_UNSET} if initialization
+   * failed before the unique identifier was determined.
+   *
+   * <p>Implementations are expected to generate and store the unique identifier alongside the
+   * cached content. If the location of the cache is deleted or swapped, it is expected that a new
+   * unique identifier will be generated when the cache is recreated.
+   */
+  long getUid();
+
   /**
    * Releases the cache. This method must be called when the cache is no longer required. The cache
    * must not be used after calling this method.
@@ -140,8 +159,8 @@ public CacheException(Throwable cause) {
    * obtains the data from some other source. The returned {@link CacheSpan} serves as a lock.
    * Whilst the caller holds the lock it may write data into the hole. It may split data into
    * multiple files. When the caller has finished writing a file it should commit it to the cache by
-   * calling {@link #commitFile(File)}. When the caller has finished writing, it must release the
-   * lock by calling {@link #releaseHoleSpan}.
+   * calling {@link #commitFile(File, long)}. When the caller has finished writing, it must release
+   * the lock by calling {@link #releaseHoleSpan}.
    *
    * @param key The key of the data being requested.
    * @param position The position of the data being requested.
@@ -169,21 +188,22 @@ public CacheException(Throwable cause) {
    *
    * @param key The cache key for the data.
    * @param position The starting position of the data.
-   * @param maxLength The maximum length of the data to be written. Used only to ensure that there
-   *     is enough space in the cache.
+   * @param length The length of the data being written, or {@link C#LENGTH_UNSET} if unknown. Used
+   *     only to ensure that there is enough space in the cache.
    * @return The file into which data should be written.
    * @throws CacheException If an error is encountered.
    */
-  File startFile(String key, long position, long maxLength) throws CacheException;
+  File startFile(String key, long position, long length) throws CacheException;
 
   /**
    * Commits a file into the cache. Must only be called when holding a corresponding hole {@link
    * CacheSpan} obtained from {@link #startReadWrite(String, long)}
    *
    * @param file A newly written cache file.
+   * @param length The length of the newly written cache file in bytes.
    * @throws CacheException If an error is encountered.
    */
-  void commitFile(File file) throws CacheException;
+  void commitFile(File file, long length) throws CacheException;
 
   /**
    * Releases a {@link CacheSpan} obtained from {@link #startReadWrite(String, long)} which
@@ -223,25 +243,6 @@ public CacheException(Throwable cause) {
    */
   long getCachedLength(String key, long position, long length);
 
-  /**
-   * Sets the content length for the given key.
-   *
-   * @param key The cache key for the data.
-   * @param length The length of the data.
-   * @throws CacheException If an error is encountered.
-   */
-  void setContentLength(String key, long length) throws CacheException;
-
-  /**
-   * Returns the content length for the given key if one set, or {@link
-   * com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
-   *
-   * @param key The cache key for the data.
-   * @return The content length for the given key if one set, or {@link
-   *     com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
-   */
-  long getContentLength(String key);
-
   /**
    * Applies {@code mutations} to the {@link ContentMetadata} for the given key. A new {@link
    * CachedContent} is added if there isn't one already with the given key.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 8d310015f8..2caf4c92f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ReusableBufferedOutputStream;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
@@ -30,22 +31,27 @@
 /**
  * Writes data into a cache.
  *
- * <p>If the {@link DataSpec} object used with {@link #open(DataSpec)} method call has the {@code
- * length} field set to {@link C#LENGTH_UNSET} but {@link
- * DataSpec#FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} isn't set then {@link #write(byte[], int, int)} calls
- * are ignored.
+ * <p>If the {@link DataSpec} passed to {@link #open(DataSpec)} has the {@code length} field set to
+ * {@link C#LENGTH_UNSET} and {@link DataSpec#FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN} set, then {@link
+ * #write(byte[], int, int)} calls are ignored.
  */
 public final class CacheDataSink implements DataSink {
 
+  /** Default {@code fragmentSize} recommended for caching use cases. */
+  public static final long DEFAULT_FRAGMENT_SIZE = 5 * 1024 * 1024;
   /** Default buffer size in bytes. */
-  public static final int DEFAULT_BUFFER_SIZE = 20480;
+  public static final int DEFAULT_BUFFER_SIZE = 20 * 1024;
+
+  private static final long MIN_RECOMMENDED_FRAGMENT_SIZE = 2 * 1024 * 1024;
+  private static final String TAG = "CacheDataSink";
 
   private final Cache cache;
-  private final long maxCacheFileSize;
+  private final long fragmentSize;
   private final int bufferSize;
-  private final boolean syncFileDescriptor;
 
+  private boolean syncFileDescriptor;
   private DataSpec dataSpec;
+  private long dataSpecFragmentSize;
   private File file;
   private OutputStream outputStream;
   private FileOutputStream underlyingFileOutputStream;
@@ -65,67 +71,67 @@ public CacheDataSinkException(IOException cause) {
   }
 
   /**
-   * Constructs a CacheDataSink using the {@link #DEFAULT_BUFFER_SIZE}.
+   * Constructs an instance using {@link #DEFAULT_BUFFER_SIZE}.
    *
    * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
-   *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *    multiple cache files.
+   * @param fragmentSize For requests that should be fragmented into multiple cache files, this is
+   *     the maximum size of a cache file in bytes. If set to {@link C#LENGTH_UNSET} then no
+   *     fragmentation will occur. Using a small value allows for finer-grained cache eviction
+   *     policies, at the cost of increased overhead both on the cache implementation and the file
+   *     system. Values under {@code (2 * 1024 * 1024)} are not recommended.
    */
-  public CacheDataSink(Cache cache, long maxCacheFileSize) {
-    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE, true);
+  public CacheDataSink(Cache cache, long fragmentSize) {
+    this(cache, fragmentSize, DEFAULT_BUFFER_SIZE);
   }
 
   /**
-   * Constructs a CacheDataSink using the {@link #DEFAULT_BUFFER_SIZE}.
-   *
    * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for a
-   *     {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *     multiple cache files.
-   * @param syncFileDescriptor Whether file descriptors are sync'd when closing output streams.
-   */
-  public CacheDataSink(Cache cache, long maxCacheFileSize, boolean syncFileDescriptor) {
-    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE, syncFileDescriptor);
-  }
-
-  /**
-   * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for a
-   *     {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *     multiple cache files.
+   * @param fragmentSize For requests that should be fragmented into multiple cache files, this is
+   *     the maximum size of a cache file in bytes. If set to {@link C#LENGTH_UNSET} then no
+   *     fragmentation will occur. Using a small value allows for finer-grained cache eviction
+   *     policies, at the cost of increased overhead both on the cache implementation and the file
+   *     system. Values under {@code (2 * 1024 * 1024)} are not recommended.
    * @param bufferSize The buffer size in bytes for writing to a cache file. A zero or negative
    *     value disables buffering.
    */
-  public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
-    this(cache, maxCacheFileSize, bufferSize, true);
+  public CacheDataSink(Cache cache, long fragmentSize, int bufferSize) {
+    Assertions.checkState(
+        fragmentSize > 0 || fragmentSize == C.LENGTH_UNSET,
+        "fragmentSize must be positive or C.LENGTH_UNSET.");
+    if (fragmentSize != C.LENGTH_UNSET && fragmentSize < MIN_RECOMMENDED_FRAGMENT_SIZE) {
+      Log.w(
+          TAG,
+          "fragmentSize is below the minimum recommended value of "
+              + MIN_RECOMMENDED_FRAGMENT_SIZE
+              + ". This may cause poor cache performance.");
+    }
+    this.cache = Assertions.checkNotNull(cache);
+    this.fragmentSize = fragmentSize == C.LENGTH_UNSET ? Long.MAX_VALUE : fragmentSize;
+    this.bufferSize = bufferSize;
+    syncFileDescriptor = true;
   }
 
   /**
-   * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for a
-   *     {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *     multiple cache files.
-   * @param bufferSize The buffer size in bytes for writing to a cache file. A zero or negative
-   *     value disables buffering.
-   * @param syncFileDescriptor Whether file descriptors are sync'd when closing output streams.
+   * Sets whether file descriptors are synced when closing output streams.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release.
+   *
+   * @param syncFileDescriptor Whether file descriptors are synced when closing output streams.
    */
-  public CacheDataSink(
-      Cache cache, long maxCacheFileSize, int bufferSize, boolean syncFileDescriptor) {
-    this.cache = Assertions.checkNotNull(cache);
-    this.maxCacheFileSize = maxCacheFileSize;
-    this.bufferSize = bufferSize;
+  public void experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
     this.syncFileDescriptor = syncFileDescriptor;
   }
 
   @Override
   public void open(DataSpec dataSpec) throws CacheDataSinkException {
     if (dataSpec.length == C.LENGTH_UNSET
-        && !dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH)) {
+        && dataSpec.isFlagSet(DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN)) {
       this.dataSpec = null;
       return;
     }
     this.dataSpec = dataSpec;
+    this.dataSpecFragmentSize =
+        dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION) ? fragmentSize : Long.MAX_VALUE;
     dataSpecBytesWritten = 0;
     try {
       openNextOutputStream();
@@ -142,12 +148,12 @@ public void write(byte[] buffer, int offset, int length) throws CacheDataSinkExc
     try {
       int bytesWritten = 0;
       while (bytesWritten < length) {
-        if (outputStreamBytesWritten == maxCacheFileSize) {
+        if (outputStreamBytesWritten == dataSpecFragmentSize) {
           closeCurrentOutputStream();
           openNextOutputStream();
         }
-        int bytesToWrite = (int) Math.min(length - bytesWritten,
-            maxCacheFileSize - outputStreamBytesWritten);
+        int bytesToWrite =
+            (int) Math.min(length - bytesWritten, dataSpecFragmentSize - outputStreamBytesWritten);
         outputStream.write(buffer, offset + bytesWritten, bytesToWrite);
         bytesWritten += bytesToWrite;
         outputStreamBytesWritten += bytesToWrite;
@@ -171,10 +177,13 @@ public void close() throws CacheDataSinkException {
   }
 
   private void openNextOutputStream() throws IOException {
-    long maxLength = dataSpec.length == C.LENGTH_UNSET ? maxCacheFileSize
-        : Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize);
-    file = cache.startFile(dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten,
-        maxLength);
+    long length =
+        dataSpec.length == C.LENGTH_UNSET
+            ? C.LENGTH_UNSET
+            : Math.min(dataSpec.length - dataSpecBytesWritten, dataSpecFragmentSize);
+    file =
+        cache.startFile(
+            dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten, length);
     underlyingFileOutputStream = new FileOutputStream(file);
     if (bufferSize > 0) {
       if (bufferedOutputStream == null) {
@@ -209,7 +218,7 @@ private void closeCurrentOutputStream() throws IOException {
       File fileToCommit = file;
       file = null;
       if (success) {
-        cache.commitFile(fileToCommit);
+        cache.commitFile(fileToCommit, outputStreamBytesWritten);
       } else {
         fileToCommit.delete();
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
index 0b9ab66508..856e9db168 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
@@ -23,28 +23,37 @@
 public final class CacheDataSinkFactory implements DataSink.Factory {
 
   private final Cache cache;
-  private final long maxCacheFileSize;
+  private final long fragmentSize;
   private final int bufferSize;
 
-  /**
-   * @see CacheDataSink#CacheDataSink(Cache, long)
-   */
-  public CacheDataSinkFactory(Cache cache, long maxCacheFileSize) {
-    this(cache, maxCacheFileSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
+  private boolean syncFileDescriptor;
+
+  /** @see CacheDataSink#CacheDataSink(Cache, long) */
+  public CacheDataSinkFactory(Cache cache, long fragmentSize) {
+    this(cache, fragmentSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
   }
 
-  /**
-   * @see CacheDataSink#CacheDataSink(Cache, long, int)
-   */
-  public CacheDataSinkFactory(Cache cache, long maxCacheFileSize, int bufferSize) {
+  /** @see CacheDataSink#CacheDataSink(Cache, long, int) */
+  public CacheDataSinkFactory(Cache cache, long fragmentSize, int bufferSize) {
     this.cache = cache;
-    this.maxCacheFileSize = maxCacheFileSize;
+    this.fragmentSize = fragmentSize;
     this.bufferSize = bufferSize;
   }
 
+  /**
+   * See {@link CacheDataSink#experimental_setSyncFileDescriptor(boolean)}.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release.
+   */
+  public CacheDataSinkFactory experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
+    this.syncFileDescriptor = syncFileDescriptor;
+    return this;
+  }
+
   @Override
   public DataSink createDataSink() {
-    return new CacheDataSink(cache, maxCacheFileSize, bufferSize);
+    CacheDataSink dataSink = new CacheDataSink(cache, fragmentSize, bufferSize);
+    dataSink.experimental_setSyncFileDescriptor(syncFileDescriptor);
+    return dataSink;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 3a96544c54..58b2d176cf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.net.Uri;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -42,24 +42,13 @@
  * A {@link DataSource} that reads and writes a {@link Cache}. Requests are fulfilled from the cache
  * when possible. When data is not cached it is requested from an upstream {@link DataSource} and
  * written into the cache.
- *
- * <p>By default requests whose length can not be resolved are not cached. This is to prevent
- * caching of progressive live streams, which should usually not be cached. Caching of this kind of
- * requests can be enabled per request with {@link DataSpec#FLAG_ALLOW_CACHING_UNKNOWN_LENGTH}.
  */
 public final class CacheDataSource implements DataSource {
 
   /**
-   * Default maximum single cache file size.
-   *
-   * @see #CacheDataSource(Cache, DataSource, int)
-   * @see #CacheDataSource(Cache, DataSource, int, long)
-   */
-  public static final long DEFAULT_MAX_CACHE_FILE_SIZE = 2 * 1024 * 1024;
-
-  /**
-   * Flags controlling the cache's behavior. Possible flag values are {@link #FLAG_BLOCK_ON_CACHE},
-   * {@link #FLAG_IGNORE_CACHE_ON_ERROR} and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}.
+   * Flags controlling the CacheDataSource's behavior. Possible flag values are {@link
+   * #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR} and {@link
+   * #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -166,7 +155,7 @@
    * @param upstream A {@link DataSource} for reading data not in the cache.
    */
   public CacheDataSource(Cache cache, DataSource upstream) {
-    this(cache, upstream, 0, DEFAULT_MAX_CACHE_FILE_SIZE);
+    this(cache, upstream, /* flags= */ 0);
   }
 
   /**
@@ -179,29 +168,11 @@ public CacheDataSource(Cache cache, DataSource upstream) {
    *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
    */
   public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags) {
-    this(cache, upstream, flags, DEFAULT_MAX_CACHE_FILE_SIZE);
-  }
-
-  /**
-   * Constructs an instance with default {@link DataSource} and {@link DataSink} instances for
-   * reading and writing the cache. The sink is configured to fragment data such that no single
-   * cache file is greater than maxCacheFileSize bytes.
-   *
-   * @param cache The cache.
-   * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
-   *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the cached data size
-   *     exceeds this value, then the data will be fragmented into multiple cache files. The
-   *     finer-grained this is the finer-grained the eviction policy can be.
-   */
-  public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
-      long maxCacheFileSize) {
     this(
         cache,
         upstream,
         new FileDataSource(),
-        new CacheDataSink(cache, maxCacheFileSize),
+        new CacheDataSink(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE),
         flags,
         /* eventListener= */ null);
   }
@@ -220,8 +191,13 @@ public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
    *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
    * @param eventListener An optional {@link EventListener} to receive events.
    */
-  public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDataSource,
-      DataSink cacheWriteDataSink, @Flags int flags, @Nullable EventListener eventListener) {
+  public CacheDataSource(
+      Cache cache,
+      DataSource upstream,
+      DataSource cacheReadDataSource,
+      @Nullable DataSink cacheWriteDataSink,
+      @Flags int flags,
+      @Nullable EventListener eventListener) {
     this(
         cache,
         upstream,
@@ -251,7 +227,7 @@ public CacheDataSource(
       Cache cache,
       DataSource upstream,
       DataSource cacheReadDataSource,
-      DataSink cacheWriteDataSink,
+      @Nullable DataSink cacheWriteDataSink,
       @Flags int flags,
       @Nullable EventListener eventListener,
       @Nullable CacheKeyFactory cacheKeyFactory) {
@@ -297,7 +273,7 @@ public long open(DataSpec dataSpec) throws IOException {
       if (dataSpec.length != C.LENGTH_UNSET || currentRequestIgnoresCache) {
         bytesRemaining = dataSpec.length;
       } else {
-        bytesRemaining = cache.getContentLength(key);
+        bytesRemaining = ContentMetadata.getContentLength(cache.getContentMetadata(key));
         if (bytesRemaining != C.LENGTH_UNSET) {
           bytesRemaining -= dataSpec.position;
           if (bytesRemaining <= 0) {
@@ -482,16 +458,12 @@ private void openNextSource(boolean checkCache) throws IOException {
     ContentMetadataMutations mutations = new ContentMetadataMutations();
     if (currentDataSpecLengthUnset && resolvedLength != C.LENGTH_UNSET) {
       bytesRemaining = resolvedLength;
-      ContentMetadataInternal.setContentLength(mutations, readPosition + bytesRemaining);
+      ContentMetadataMutations.setContentLength(mutations, readPosition + bytesRemaining);
     }
     if (isReadingFromUpstream()) {
       actualUri = currentDataSource.getUri();
       boolean isRedirected = !uri.equals(actualUri);
-      if (isRedirected) {
-        ContentMetadataInternal.setRedirectedUri(mutations, actualUri);
-      } else {
-        ContentMetadataInternal.removeRedirectedUri(mutations);
-      }
+      ContentMetadataMutations.setRedirectedUri(mutations, isRedirected ? actualUri : null);
     }
     if (isWritingToCache()) {
       cache.applyContentMetadataMutations(key, mutations);
@@ -501,14 +473,15 @@ private void openNextSource(boolean checkCache) throws IOException {
   private void setNoBytesRemainingAndMaybeStoreLength() throws IOException {
     bytesRemaining = 0;
     if (isWritingToCache()) {
-      cache.setContentLength(key, readPosition);
+      ContentMetadataMutations mutations = new ContentMetadataMutations();
+      ContentMetadataMutations.setContentLength(mutations, readPosition);
+      cache.applyContentMetadataMutations(key, mutations);
     }
   }
 
   private static Uri getRedirectedUriOrDefault(Cache cache, String key, Uri defaultUri) {
-    ContentMetadata contentMetadata = cache.getContentMetadata(key);
-    Uri redirectedUri = ContentMetadataInternal.getRedirectedUri(contentMetadata);
-    return redirectedUri == null ? defaultUri : redirectedUri;
+    Uri redirectedUri = ContentMetadata.getRedirectedUri(cache.getContentMetadata(key));
+    return redirectedUri != null ? redirectedUri : defaultUri;
   }
 
   private static boolean isCausedByPositionOutOfRange(IOException e) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
index f0285da274..2f0f6caa2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
@@ -15,69 +15,98 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSource.Factory;
 import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
-import com.google.android.exoplayer2.upstream.cache.CacheDataSource.EventListener;
 
-/**
- * A {@link DataSource.Factory} that produces {@link CacheDataSource}.
- */
+/** A {@link DataSource.Factory} that produces {@link CacheDataSource}. */
 public final class CacheDataSourceFactory implements DataSource.Factory {
 
   private final Cache cache;
   private final DataSource.Factory upstreamFactory;
   private final DataSource.Factory cacheReadDataSourceFactory;
-  private final DataSink.Factory cacheWriteDataSinkFactory;
-  private final int flags;
-  private final EventListener eventListener;
+  @CacheDataSource.Flags private final int flags;
+  @Nullable private final DataSink.Factory cacheWriteDataSinkFactory;
+  @Nullable private final CacheDataSource.EventListener eventListener;
+  @Nullable private final CacheKeyFactory cacheKeyFactory;
 
   /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource)
+   * Constructs a factory which creates {@link CacheDataSource} instances with default {@link
+   * DataSource} and {@link DataSink} instances for reading and writing the cache.
+   *
+   * @param cache The cache.
+   * @param upstreamFactory A {@link DataSource.Factory} for creating upstream {@link DataSource}s
+   *     for reading data not in the cache.
    */
   public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory) {
-    this(cache, upstreamFactory, 0);
+    this(cache, upstreamFactory, /* flags= */ 0);
   }
 
-  /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource, int)
-   */
-  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
-      @CacheDataSource.Flags int flags) {
-    this(cache, upstreamFactory, flags, CacheDataSource.DEFAULT_MAX_CACHE_FILE_SIZE);
+  /** @see CacheDataSource#CacheDataSource(Cache, DataSource, int) */
+  public CacheDataSourceFactory(
+      Cache cache, DataSource.Factory upstreamFactory, @CacheDataSource.Flags int flags) {
+    this(
+        cache,
+        upstreamFactory,
+        new FileDataSourceFactory(),
+        new CacheDataSinkFactory(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE),
+        flags,
+        /* eventListener= */ null);
   }
 
   /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource, int, long)
+   * @see CacheDataSource#CacheDataSource(Cache, DataSource, DataSource, DataSink, int,
+   *     CacheDataSource.EventListener)
    */
-  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
-      @CacheDataSource.Flags int flags, long maxCacheFileSize) {
-    this(cache, upstreamFactory, new FileDataSourceFactory(),
-        new CacheDataSinkFactory(cache, maxCacheFileSize), flags, null);
+  public CacheDataSourceFactory(
+      Cache cache,
+      DataSource.Factory upstreamFactory,
+      DataSource.Factory cacheReadDataSourceFactory,
+      @Nullable DataSink.Factory cacheWriteDataSinkFactory,
+      @CacheDataSource.Flags int flags,
+      @Nullable CacheDataSource.EventListener eventListener) {
+    this(
+        cache,
+        upstreamFactory,
+        cacheReadDataSourceFactory,
+        cacheWriteDataSinkFactory,
+        flags,
+        eventListener,
+        /* cacheKeyFactory= */ null);
   }
 
   /**
    * @see CacheDataSource#CacheDataSource(Cache, DataSource, DataSource, DataSink, int,
-   *     EventListener)
+   *     CacheDataSource.EventListener, CacheKeyFactory)
    */
-  public CacheDataSourceFactory(Cache cache, Factory upstreamFactory,
-      Factory cacheReadDataSourceFactory, DataSink.Factory cacheWriteDataSinkFactory,
-      @CacheDataSource.Flags int flags, EventListener eventListener) {
+  public CacheDataSourceFactory(
+      Cache cache,
+      DataSource.Factory upstreamFactory,
+      DataSource.Factory cacheReadDataSourceFactory,
+      @Nullable DataSink.Factory cacheWriteDataSinkFactory,
+      @CacheDataSource.Flags int flags,
+      @Nullable CacheDataSource.EventListener eventListener,
+      @Nullable CacheKeyFactory cacheKeyFactory) {
     this.cache = cache;
     this.upstreamFactory = upstreamFactory;
     this.cacheReadDataSourceFactory = cacheReadDataSourceFactory;
     this.cacheWriteDataSinkFactory = cacheWriteDataSinkFactory;
     this.flags = flags;
     this.eventListener = eventListener;
+    this.cacheKeyFactory = cacheKeyFactory;
   }
 
   @Override
   public CacheDataSource createDataSource() {
-    return new CacheDataSource(cache, upstreamFactory.createDataSource(),
+    return new CacheDataSource(
+        cache,
+        upstreamFactory.createDataSource(),
         cacheReadDataSourceFactory.createDataSource(),
-        cacheWriteDataSinkFactory != null ? cacheWriteDataSinkFactory.createDataSink() : null,
-        flags, eventListener);
+        cacheWriteDataSinkFactory == null ? null : cacheWriteDataSinkFactory.createDataSink(),
+        flags,
+        eventListener,
+        cacheKeyFactory);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
index 8944b45033..6ebfe01df4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
@@ -15,12 +15,21 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import com.google.android.exoplayer2.C;
+
 /**
  * Evicts data from a {@link Cache}. Implementations should call {@link Cache#removeSpan(CacheSpan)}
  * to evict cache entries based on their eviction policies.
  */
 public interface CacheEvictor extends Cache.Listener {
 
+  /**
+   * Returns whether the evictor requires the {@link Cache} to touch {@link CacheSpan CacheSpans}
+   * when it accesses them. Implementations that do not use {@link CacheSpan#lastTouchTimestamp}
+   * should return {@code false}.
+   */
+  boolean requiresCacheSpanTouches();
+
   /**
    * Called when cache has been initialized.
    */
@@ -32,8 +41,7 @@
    * @param cache The source of the event.
    * @param key The key being written.
    * @param position The starting position of the data being written.
-   * @param maxLength The maximum length of the data being written.
+   * @param length The length of the data being written, or {@link C#LENGTH_UNSET} if unknown.
    */
-  void onStartFile(Cache cache, String key, long position, long maxLength);
-
+  void onStartFile(Cache cache, String key, long position, long length);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadata.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadata.java
new file mode 100644
index 0000000000..7ac80325a5
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadata.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+/** Metadata associated with a cache file. */
+/* package */ final class CacheFileMetadata {
+
+  public final long length;
+  public final long lastTouchTimestamp;
+
+  public CacheFileMetadata(long length, long lastTouchTimestamp) {
+    this.length = length;
+    this.lastTouchTimestamp = lastTouchTimestamp;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java
new file mode 100644
index 0000000000..2a8b393ed3
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import com.google.android.exoplayer2.database.DatabaseIOException;
+import com.google.android.exoplayer2.database.DatabaseProvider;
+import com.google.android.exoplayer2.database.VersionTable;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+/** Maintains an index of cache file metadata. */
+/* package */ final class CacheFileMetadataIndex {
+
+  private static final String TABLE_PREFIX = DatabaseProvider.TABLE_PREFIX + "CacheFileMetadata";
+  private static final int TABLE_VERSION = 1;
+
+  private static final String COLUMN_NAME = "name";
+  private static final String COLUMN_LENGTH = "length";
+  private static final String COLUMN_LAST_TOUCH_TIMESTAMP = "last_touch_timestamp";
+
+  private static final int COLUMN_INDEX_NAME = 0;
+  private static final int COLUMN_INDEX_LENGTH = 1;
+  private static final int COLUMN_INDEX_LAST_TOUCH_TIMESTAMP = 2;
+
+  private static final String WHERE_NAME_EQUALS = COLUMN_INDEX_NAME + " = ?";
+
+  private static final String[] COLUMNS =
+      new String[] {
+        COLUMN_NAME, COLUMN_LENGTH, COLUMN_LAST_TOUCH_TIMESTAMP,
+      };
+  private static final String TABLE_SCHEMA =
+      "("
+          + COLUMN_NAME
+          + " TEXT PRIMARY KEY NOT NULL,"
+          + COLUMN_LENGTH
+          + " INTEGER NOT NULL,"
+          + COLUMN_LAST_TOUCH_TIMESTAMP
+          + " INTEGER NOT NULL)";
+
+  private final DatabaseProvider databaseProvider;
+
+  @MonotonicNonNull private String tableName;
+
+  /**
+   * Deletes index data for the specified cache.
+   *
+   * @param databaseProvider Provides the database in which the index is stored.
+   * @param uid The cache UID.
+   * @throws DatabaseIOException If an error occurs deleting the index data.
+   */
+  public static void delete(DatabaseProvider databaseProvider, long uid)
+      throws DatabaseIOException {
+    String hexUid = Long.toHexString(uid);
+    try {
+      String tableName = getTableName(hexUid);
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.beginTransaction();
+      try {
+        VersionTable.removeVersion(
+            writableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid);
+        dropTable(writableDatabase, tableName);
+        writableDatabase.setTransactionSuccessful();
+      } finally {
+        writableDatabase.endTransaction();
+      }
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /** @param databaseProvider Provides the database in which the index is stored. */
+  public CacheFileMetadataIndex(DatabaseProvider databaseProvider) {
+    this.databaseProvider = databaseProvider;
+  }
+
+  /**
+   * Initializes the index for the given cache UID.
+   *
+   * @param uid The cache UID.
+   * @throws DatabaseIOException If an error occurs initializing the index.
+   */
+  public void initialize(long uid) throws DatabaseIOException {
+    try {
+      String hexUid = Long.toHexString(uid);
+      tableName = getTableName(hexUid);
+      SQLiteDatabase readableDatabase = databaseProvider.getReadableDatabase();
+      int version =
+          VersionTable.getVersion(
+              readableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid);
+      if (version != TABLE_VERSION) {
+        SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+        writableDatabase.beginTransaction();
+        try {
+          VersionTable.setVersion(
+              writableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid, TABLE_VERSION);
+          dropTable(writableDatabase, tableName);
+          writableDatabase.execSQL("CREATE TABLE " + tableName + " " + TABLE_SCHEMA);
+          writableDatabase.setTransactionSuccessful();
+        } finally {
+          writableDatabase.endTransaction();
+        }
+      }
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /**
+   * Returns all file metadata keyed by file name. The returned map is mutable and may be modified
+   * by the caller.
+   *
+   * @return The file metadata keyed by file name.
+   * @throws DatabaseIOException If an error occurs loading the metadata.
+   */
+  public Map<String, CacheFileMetadata> getAll() throws DatabaseIOException {
+    try (Cursor cursor = getCursor()) {
+      Map<String, CacheFileMetadata> fileMetadata = new HashMap<>(cursor.getCount());
+      while (cursor.moveToNext()) {
+        String name = cursor.getString(COLUMN_INDEX_NAME);
+        long length = cursor.getLong(COLUMN_INDEX_LENGTH);
+        long lastTouchTimestamp = cursor.getLong(COLUMN_INDEX_LAST_TOUCH_TIMESTAMP);
+        fileMetadata.put(name, new CacheFileMetadata(length, lastTouchTimestamp));
+      }
+      return fileMetadata;
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /**
+   * Sets metadata for a given file.
+   *
+   * @param name The name of the file.
+   * @param length The file length.
+   * @param lastTouchTimestamp The file last touch timestamp.
+   * @throws DatabaseIOException If an error occurs setting the metadata.
+   */
+  public void set(String name, long length, long lastTouchTimestamp) throws DatabaseIOException {
+    Assertions.checkNotNull(tableName);
+    try {
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_NAME, name);
+      values.put(COLUMN_LENGTH, length);
+      values.put(COLUMN_LAST_TOUCH_TIMESTAMP, lastTouchTimestamp);
+      writableDatabase.replaceOrThrow(tableName, /* nullColumnHack= */ null, values);
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /**
+   * Removes metadata.
+   *
+   * @param name The name of the file whose metadata is to be removed.
+   * @throws DatabaseIOException If an error occurs removing the metadata.
+   */
+  public void remove(String name) throws DatabaseIOException {
+    Assertions.checkNotNull(tableName);
+    try {
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.delete(tableName, WHERE_NAME_EQUALS, new String[] {name});
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  /**
+   * Removes metadata.
+   *
+   * @param names The names of the files whose metadata is to be removed.
+   * @throws DatabaseIOException If an error occurs removing the metadata.
+   */
+  public void removeAll(Set<String> names) throws DatabaseIOException {
+    Assertions.checkNotNull(tableName);
+    try {
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.beginTransaction();
+      try {
+        for (String name : names) {
+          writableDatabase.delete(tableName, WHERE_NAME_EQUALS, new String[] {name});
+        }
+        writableDatabase.setTransactionSuccessful();
+      } finally {
+        writableDatabase.endTransaction();
+      }
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
+  private Cursor getCursor() {
+    Assertions.checkNotNull(tableName);
+    return databaseProvider
+        .getReadableDatabase()
+        .query(
+            tableName,
+            COLUMNS,
+            /* selection */ null,
+            /* selectionArgs= */ null,
+            /* groupBy= */ null,
+            /* having= */ null,
+            /* orderBy= */ null);
+  }
+
+  private static void dropTable(SQLiteDatabase writableDatabase, String tableName) {
+    writableDatabase.execSQL("DROP TABLE IF EXISTS " + tableName);
+  }
+
+  private static String getTableName(String hexUid) {
+    return TABLE_PREFIX + hexUid;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
index 2082740bb4..1e8cf1517d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.io.File;
 
@@ -45,13 +45,12 @@
    * The file corresponding to this {@link CacheSpan}, or null if {@link #isCached} is false.
    */
   public final @Nullable File file;
-  /**
-   * The last access timestamp, or {@link C#TIME_UNSET} if {@link #isCached} is false.
-   */
-  public final long lastAccessTimestamp;
+  /** The last touch timestamp, or {@link C#TIME_UNSET} if {@link #isCached} is false. */
+  public final long lastTouchTimestamp;
 
   /**
-   * Creates a hole CacheSpan which isn't cached, has no last access time and no file associated.
+   * Creates a hole CacheSpan which isn't cached, has no last touch timestamp and no file
+   * associated.
    *
    * @param key The cache key that uniquely identifies the original stream.
    * @param position The position of the {@link CacheSpan} in the original stream.
@@ -69,18 +68,18 @@ public CacheSpan(String key, long position, long length) {
    * @param position The position of the {@link CacheSpan} in the original stream.
    * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
    *     open-ended hole.
-   * @param lastAccessTimestamp The last access timestamp, or {@link C#TIME_UNSET} if {@link
+   * @param lastTouchTimestamp The last touch timestamp, or {@link C#TIME_UNSET} if {@link
    *     #isCached} is false.
    * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
    */
   public CacheSpan(
-      String key, long position, long length, long lastAccessTimestamp, @Nullable File file) {
+      String key, long position, long length, long lastTouchTimestamp, @Nullable File file) {
     this.key = key;
     this.position = position;
     this.length = length;
     this.isCached = file != null;
     this.file = file;
-    this.lastAccessTimestamp = lastAccessTimestamp;
+    this.lastTouchTimestamp = lastTouchTimestamp;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index cee22375a9..219d736835 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -16,7 +16,8 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -31,31 +32,29 @@
 /**
  * Caching related utility methods.
  */
-@SuppressWarnings({"NonAtomicVolatileUpdate", "NonAtomicOperationOnVolatileField"})
 public final class CacheUtil {
 
-  /** Counters used during caching. */
-  public static class CachingCounters {
-    /** The number of bytes already in the cache. */
-    public volatile long alreadyCachedBytes;
-    /** The number of newly cached bytes. */
-    public volatile long newlyCachedBytes;
-    /** The length of the content being cached in bytes, or {@link C#LENGTH_UNSET} if unknown. */
-    public volatile long contentLength = C.LENGTH_UNSET;
+  /** Receives progress updates during cache operations. */
+  public interface ProgressListener {
 
     /**
-     * Returns the sum of {@link #alreadyCachedBytes} and {@link #newlyCachedBytes}.
+     * Called when progress is made during a cache operation.
+     *
+     * @param requestLength The length of the content being cached in bytes, or {@link
+     *     C#LENGTH_UNSET} if unknown.
+     * @param bytesCached The number of bytes that are cached.
+     * @param newBytesCached The number of bytes that have been newly cached since the last progress
+     *     update.
      */
-    public long totalCachedBytes() {
-      return alreadyCachedBytes + newlyCachedBytes;
-    }
+    void onProgress(long requestLength, long bytesCached, long newBytesCached);
   }
 
   /** Default buffer size to be used while caching. */
   public static final int DEFAULT_BUFFER_SIZE_BYTES = 128 * 1024;
 
-  /** Default {@link CacheKeyFactory} that calls through to {@link #getKey}. */
-  public static final CacheKeyFactory DEFAULT_CACHE_KEY_FACTORY = CacheUtil::getKey;
+  /** Default {@link CacheKeyFactory}. */
+  public static final CacheKeyFactory DEFAULT_CACHE_KEY_FACTORY =
+      (dataSpec) -> dataSpec.key != null ? dataSpec.key : generateKey(dataSpec.uri);
 
   /**
    * Generates a cache key out of the given {@link Uri}.
@@ -67,45 +66,43 @@ public static String generateKey(Uri uri) {
   }
 
   /**
-   * Returns the {@code dataSpec.key} if not null, otherwise generates a cache key out of {@code
-   * dataSpec.uri}
-   *
-   * @param dataSpec Defines a content which the requested key is for.
-   */
-  public static String getKey(DataSpec dataSpec) {
-    return dataSpec.key != null ? dataSpec.key : generateKey(dataSpec.uri);
-  }
-
-  /**
-   * Sets a {@link CachingCounters} to contain the number of bytes already downloaded and the
-   * length for the content defined by a {@code dataSpec}. {@link CachingCounters#newlyCachedBytes}
-   * is reset to 0.
+   * Queries the cache to obtain the request length and the number of bytes already cached for a
+   * given {@link DataSpec}.
    *
    * @param dataSpec Defines the data to be checked.
    * @param cache A {@link Cache} which has the data.
-   * @param counters The {@link CachingCounters} to update.
+   * @param cacheKeyFactory An optional factory for cache keys.
+   * @return A pair containing the request length and the number of bytes that are already cached.
    */
-  public static void getCached(DataSpec dataSpec, Cache cache, CachingCounters counters) {
-    String key = getKey(dataSpec);
-    long start = dataSpec.absoluteStreamPosition;
-    long left = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : cache.getContentLength(key);
-    counters.contentLength = left;
-    counters.alreadyCachedBytes = 0;
-    counters.newlyCachedBytes = 0;
-    while (left != 0) {
+  public static Pair<Long, Long> getCached(
+      DataSpec dataSpec, Cache cache, @Nullable CacheKeyFactory cacheKeyFactory) {
+    String key = buildCacheKey(dataSpec, cacheKeyFactory);
+    long position = dataSpec.absoluteStreamPosition;
+    long requestLength;
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      requestLength = dataSpec.length;
+    } else {
+      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
+      requestLength = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
+    }
+    long bytesAlreadyCached = 0;
+    long bytesLeft = requestLength;
+    while (bytesLeft != 0) {
       long blockLength =
-          cache.getCachedLength(key, start, left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
+          cache.getCachedLength(
+              key, position, bytesLeft != C.LENGTH_UNSET ? bytesLeft : Long.MAX_VALUE);
       if (blockLength > 0) {
-        counters.alreadyCachedBytes += blockLength;
+        bytesAlreadyCached += blockLength;
       } else {
         blockLength = -blockLength;
         if (blockLength == Long.MAX_VALUE) {
-          return;
+          break;
         }
       }
-      start += blockLength;
-      left -= left == C.LENGTH_UNSET ? 0 : blockLength;
+      position += blockLength;
+      bytesLeft -= bytesLeft == C.LENGTH_UNSET ? 0 : blockLength;
     }
+    return Pair.create(requestLength, bytesAlreadyCached);
   }
 
   /**
@@ -114,8 +111,9 @@ public static void getCached(DataSpec dataSpec, Cache cache, CachingCounters cou
    *
    * @param dataSpec Defines the data to be cached.
    * @param cache A {@link Cache} to store the data.
+   * @param cacheKeyFactory An optional factory for cache keys.
    * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param counters If not null, updated during caching.
+   * @param progressListener A listener to receive progress updates, or {@code null}.
    * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @throws IOException If an error occurs reading from the source.
    * @throws InterruptedException If the thread was interrupted directly or via {@code isCanceled}.
@@ -123,18 +121,20 @@ public static void getCached(DataSpec dataSpec, Cache cache, CachingCounters cou
   public static void cache(
       DataSpec dataSpec,
       Cache cache,
+      @Nullable CacheKeyFactory cacheKeyFactory,
       DataSource upstream,
-      @Nullable CachingCounters counters,
+      @Nullable ProgressListener progressListener,
       @Nullable AtomicBoolean isCanceled)
       throws IOException, InterruptedException {
     cache(
         dataSpec,
         cache,
+        cacheKeyFactory,
         new CacheDataSource(cache, upstream),
         new byte[DEFAULT_BUFFER_SIZE_BYTES],
         /* priorityTaskManager= */ null,
         /* priority= */ 0,
-        counters,
+        progressListener,
         isCanceled,
         /* enableEOFException= */ false);
   }
@@ -151,12 +151,13 @@ public static void cache(
    *
    * @param dataSpec Defines the data to be cached.
    * @param cache A {@link Cache} to store the data.
+   * @param cacheKeyFactory An optional factory for cache keys.
    * @param dataSource A {@link CacheDataSource} that works on the {@code cache}.
    * @param buffer The buffer to be used while caching.
    * @param priorityTaskManager If not null it's used to check whether it is allowed to proceed with
    *     caching.
    * @param priority The priority of this task. Used with {@code priorityTaskManager}.
-   * @param counters If not null, updated during caching.
+   * @param progressListener A listener to receive progress updates, or {@code null}.
    * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @param enableEOFException Whether to throw an {@link EOFException} if end of input has been
    *     reached unexpectedly.
@@ -166,32 +167,39 @@ public static void cache(
   public static void cache(
       DataSpec dataSpec,
       Cache cache,
+      @Nullable CacheKeyFactory cacheKeyFactory,
       CacheDataSource dataSource,
       byte[] buffer,
       PriorityTaskManager priorityTaskManager,
       int priority,
-      @Nullable CachingCounters counters,
+      @Nullable ProgressListener progressListener,
       @Nullable AtomicBoolean isCanceled,
       boolean enableEOFException)
       throws IOException, InterruptedException {
     Assertions.checkNotNull(dataSource);
     Assertions.checkNotNull(buffer);
 
-    if (counters != null) {
-      // Initialize the CachingCounter values.
-      getCached(dataSpec, cache, counters);
-    } else {
-      // Dummy CachingCounters. No need to initialize as they will not be visible to the caller.
-      counters = new CachingCounters();
+    ProgressNotifier progressNotifier = null;
+    if (progressListener != null) {
+      progressNotifier = new ProgressNotifier(progressListener);
+      Pair<Long, Long> lengthAndBytesAlreadyCached = getCached(dataSpec, cache, cacheKeyFactory);
+      progressNotifier.init(lengthAndBytesAlreadyCached.first, lengthAndBytesAlreadyCached.second);
     }
 
-    String key = getKey(dataSpec);
-    long start = dataSpec.absoluteStreamPosition;
-    long left = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : cache.getContentLength(key);
-    while (left != 0) {
+    String key = buildCacheKey(dataSpec, cacheKeyFactory);
+    long position = dataSpec.absoluteStreamPosition;
+    long bytesLeft;
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      bytesLeft = dataSpec.length;
+    } else {
+      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
+      bytesLeft = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
+    }
+    while (bytesLeft != 0) {
       throwExceptionIfInterruptedOrCancelled(isCanceled);
       long blockLength =
-          cache.getCachedLength(key, start, left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
+          cache.getCachedLength(
+              key, position, bytesLeft != C.LENGTH_UNSET ? bytesLeft : Long.MAX_VALUE);
       if (blockLength > 0) {
         // Skip already cached data.
       } else {
@@ -200,24 +208,24 @@ public static void cache(
         long read =
             readAndDiscard(
                 dataSpec,
-                start,
+                position,
                 blockLength,
                 dataSource,
                 buffer,
                 priorityTaskManager,
                 priority,
-                counters,
+                progressNotifier,
                 isCanceled);
         if (read < blockLength) {
           // Reached to the end of the data.
-          if (enableEOFException && left != C.LENGTH_UNSET) {
+          if (enableEOFException && bytesLeft != C.LENGTH_UNSET) {
             throw new EOFException();
           }
           break;
         }
       }
-      start += blockLength;
-      left -= left == C.LENGTH_UNSET ? 0 : blockLength;
+      position += blockLength;
+      bytesLeft -= bytesLeft == C.LENGTH_UNSET ? 0 : blockLength;
     }
   }
 
@@ -233,7 +241,7 @@ public static void cache(
    * @param priorityTaskManager If not null it's used to check whether it is allowed to proceed with
    *     caching.
    * @param priority The priority of this task.
-   * @param counters Counters to be set during reading.
+   * @param progressNotifier A notifier through which to report progress updates, or {@code null}.
    * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @return Number of read bytes, or 0 if no data is available because the end of the opened range
    *     has been reached.
@@ -246,9 +254,10 @@ private static long readAndDiscard(
       byte[] buffer,
       PriorityTaskManager priorityTaskManager,
       int priority,
-      CachingCounters counters,
+      @Nullable ProgressNotifier progressNotifier,
       AtomicBoolean isCanceled)
       throws IOException, InterruptedException {
+    long positionOffset = absoluteStreamPosition - dataSpec.absoluteStreamPosition;
     while (true) {
       if (priorityTaskManager != null) {
         // Wait for any other thread with higher priority to finish its job.
@@ -264,30 +273,36 @@ private static long readAndDiscard(
                 dataSpec.httpMethod,
                 dataSpec.httpBody,
                 absoluteStreamPosition,
-                dataSpec.position + absoluteStreamPosition - dataSpec.absoluteStreamPosition,
+                /* position= */ dataSpec.position + positionOffset,
                 C.LENGTH_UNSET,
                 dataSpec.key,
-                dataSpec.flags | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+                dataSpec.flags);
         long resolvedLength = dataSource.open(dataSpec);
-        if (counters.contentLength == C.LENGTH_UNSET && resolvedLength != C.LENGTH_UNSET) {
-          counters.contentLength = dataSpec.absoluteStreamPosition + resolvedLength;
+        if (progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
+          progressNotifier.onRequestLengthResolved(positionOffset + resolvedLength);
         }
-        long totalRead = 0;
-        while (totalRead != length) {
+        long totalBytesRead = 0;
+        while (totalBytesRead != length) {
           throwExceptionIfInterruptedOrCancelled(isCanceled);
-          int read = dataSource.read(buffer, 0,
-              length != C.LENGTH_UNSET ? (int) Math.min(buffer.length, length - totalRead)
-                  : buffer.length);
-          if (read == C.RESULT_END_OF_INPUT) {
-            if (counters.contentLength == C.LENGTH_UNSET) {
-              counters.contentLength = dataSpec.absoluteStreamPosition + totalRead;
+          int bytesRead =
+              dataSource.read(
+                  buffer,
+                  0,
+                  length != C.LENGTH_UNSET
+                      ? (int) Math.min(buffer.length, length - totalBytesRead)
+                      : buffer.length);
+          if (bytesRead == C.RESULT_END_OF_INPUT) {
+            if (progressNotifier != null) {
+              progressNotifier.onRequestLengthResolved(positionOffset + totalBytesRead);
             }
             break;
           }
-          totalRead += read;
-          counters.newlyCachedBytes += read;
+          totalBytesRead += bytesRead;
+          if (progressNotifier != null) {
+            progressNotifier.onBytesCached(bytesRead);
+          }
         }
-        return totalRead;
+        return totalBytesRead;
       } catch (PriorityTaskManager.PriorityTooLowException exception) {
         // catch and try again
       } finally {
@@ -296,18 +311,41 @@ private static long readAndDiscard(
     }
   }
 
-  /** Removes all of the data in the {@code cache} pointed by the {@code key}. */
+  /**
+   * Removes all of the data specified by the {@code dataSpec}.
+   *
+   * @param dataSpec Defines the data to be removed.
+   * @param cache A {@link Cache} to store the data.
+   * @param cacheKeyFactory An optional factory for cache keys.
+   */
+  public static void remove(
+      DataSpec dataSpec, Cache cache, @Nullable CacheKeyFactory cacheKeyFactory) {
+    remove(cache, buildCacheKey(dataSpec, cacheKeyFactory));
+  }
+
+  /**
+   * Removes all of the data specified by the {@code key}.
+   *
+   * @param cache A {@link Cache} to store the data.
+   * @param key The key whose data should be removed.
+   */
   public static void remove(Cache cache, String key) {
     NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(key);
     for (CacheSpan cachedSpan : cachedSpans) {
       try {
         cache.removeSpan(cachedSpan);
       } catch (Cache.CacheException e) {
-        // do nothing
+        // Do nothing.
       }
     }
   }
 
+  private static String buildCacheKey(
+      DataSpec dataSpec, @Nullable CacheKeyFactory cacheKeyFactory) {
+    return (cacheKeyFactory != null ? cacheKeyFactory : DEFAULT_CACHE_KEY_FACTORY)
+        .buildCacheKey(dataSpec);
+  }
+
   private static void throwExceptionIfInterruptedOrCancelled(AtomicBoolean isCanceled)
       throws InterruptedException {
     if (Thread.interrupted() || (isCanceled != null && isCanceled.get())) {
@@ -317,4 +355,34 @@ private static void throwExceptionIfInterruptedOrCancelled(AtomicBoolean isCance
 
   private CacheUtil() {}
 
+  private static final class ProgressNotifier {
+    /** The listener to notify when progress is made. */
+    private final ProgressListener listener;
+    /** The length of the content being cached in bytes, or {@link C#LENGTH_UNSET} if unknown. */
+    private long requestLength;
+    /** The number of bytes that are cached. */
+    private long bytesCached;
+
+    public ProgressNotifier(ProgressListener listener) {
+      this.listener = listener;
+    }
+
+    public void init(long requestLength, long bytesCached) {
+      this.requestLength = requestLength;
+      this.bytesCached = bytesCached;
+      listener.onProgress(requestLength, bytesCached, /* newBytesCached= */ 0);
+    }
+
+    public void onRequestLengthResolved(long requestLength) {
+      if (this.requestLength == C.LENGTH_UNSET && requestLength != C.LENGTH_UNSET) {
+        this.requestLength = requestLength;
+        listener.onProgress(requestLength, bytesCached, /* newBytesCached= */ 0);
+      }
+    }
+
+    public void onBytesCached(long newBytesCached) {
+      bytesCached += newBytesCached;
+      listener.onProgress(requestLength, bytesCached, newBytesCached);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
index 97a7828a22..7abb9b3896 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
@@ -15,21 +15,16 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Assertions;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
+import com.google.android.exoplayer2.util.Log;
+import java.io.File;
 import java.util.TreeSet;
 
-/**
- * Defines the cached content for a single stream.
- */
-/*package*/ final class CachedContent {
+/** Defines the cached content for a single stream. */
+/* package */ final class CachedContent {
 
-  private static final int VERSION_METADATA_INTRODUCED = 2;
-  private static final int VERSION_MAX = Integer.MAX_VALUE;
+  private static final String TAG = "CachedContent";
 
   /** The cache file id that uniquely identifies the original stream. */
   public final int id;
@@ -42,29 +37,6 @@
   /** Whether the content is locked. */
   private boolean locked;
 
-  /**
-   * Reads an instance from a {@link DataInputStream}.
-   *
-   * @param version Version of the encoded data.
-   * @param input Input stream containing values needed to initialize CachedContent instance.
-   * @throws IOException If an error occurs during reading values.
-   */
-  public static CachedContent readFromStream(int version, DataInputStream input)
-      throws IOException {
-    int id = input.readInt();
-    String key = input.readUTF();
-    CachedContent cachedContent = new CachedContent(id, key);
-    if (version < VERSION_METADATA_INTRODUCED) {
-      long length = input.readLong();
-      ContentMetadataMutations mutations = new ContentMetadataMutations();
-      ContentMetadataInternal.setContentLength(mutations, length);
-      cachedContent.applyMetadataMutations(mutations);
-    } else {
-      cachedContent.metadata = DefaultContentMetadata.readFromStream(input);
-    }
-    return cachedContent;
-  }
-
   /**
    * Creates a CachedContent.
    *
@@ -72,26 +44,18 @@ public static CachedContent readFromStream(int version, DataInputStream input)
    * @param key The cache stream key.
    */
   public CachedContent(int id, String key) {
+    this(id, key, DefaultContentMetadata.EMPTY);
+  }
+
+  public CachedContent(int id, String key, DefaultContentMetadata metadata) {
     this.id = id;
     this.key = key;
-    this.metadata = DefaultContentMetadata.EMPTY;
+    this.metadata = metadata;
     this.cachedSpans = new TreeSet<>();
   }
 
-  /**
-   * Writes the instance to a {@link DataOutputStream}.
-   *
-   * @param output Output stream to store the values.
-   * @throws IOException If an error occurs during writing values to output.
-   */
-  public void writeToStream(DataOutputStream output) throws IOException {
-    output.writeInt(id);
-    output.writeUTF(key);
-    metadata.writeToStream(output);
-  }
-
   /** Returns the metadata. */
-  public ContentMetadata getMetadata() {
+  public DefaultContentMetadata getMetadata() {
     return metadata;
   }
 
@@ -177,21 +141,30 @@ public long getCachedBytesLength(long position, long length) {
   }
 
   /**
-   * Copies the given span with an updated last access time. Passed span becomes invalid after this
-   * call.
+   * Sets the given span's last touch timestamp. The passed span becomes invalid after this call.
    *
    * @param cacheSpan Span to be copied and updated.
-   * @return a span with the updated last access time.
-   * @throws CacheException If renaming of the underlying span file failed.
+   * @param lastTouchTimestamp The new last touch timestamp.
+   * @param updateFile Whether the span file should be renamed to have its timestamp match the new
+   *     last touch time.
+   * @return A span with the updated last touch timestamp.
    */
-  public SimpleCacheSpan touch(SimpleCacheSpan cacheSpan) throws CacheException {
-    SimpleCacheSpan newCacheSpan = cacheSpan.copyWithUpdatedLastAccessTime(id);
-    if (!cacheSpan.file.renameTo(newCacheSpan.file)) {
-      throw new CacheException("Renaming of " + cacheSpan.file + " to " + newCacheSpan.file
-          + " failed.");
-    }
-    // Replace the in-memory representation of the span.
+  public SimpleCacheSpan setLastTouchTimestamp(
+      SimpleCacheSpan cacheSpan, long lastTouchTimestamp, boolean updateFile) {
     Assertions.checkState(cachedSpans.remove(cacheSpan));
+    File file = cacheSpan.file;
+    if (updateFile) {
+      File directory = file.getParentFile();
+      long position = cacheSpan.position;
+      File newFile = SimpleCacheSpan.getCacheFile(directory, id, position, lastTouchTimestamp);
+      if (file.renameTo(newFile)) {
+        file = newFile;
+      } else {
+        Log.w(TAG, "Failed to rename " + file + " to " + newFile);
+      }
+    }
+    SimpleCacheSpan newCacheSpan =
+        cacheSpan.copyWithFileAndLastTouchTimestamp(file, lastTouchTimestamp);
     cachedSpans.add(newCacheSpan);
     return newCacheSpan;
   }
@@ -210,26 +183,11 @@ public boolean removeSpan(CacheSpan span) {
     return false;
   }
 
-  /**
-   * Calculates a hash code for the header of this {@code CachedContent} which is compatible with
-   * the index file with {@code version}.
-   */
-  public int headerHashCode(int version) {
-    int result = id;
-    result = 31 * result + key.hashCode();
-    if (version < VERSION_METADATA_INTRODUCED) {
-      long length = ContentMetadataInternal.getContentLength(metadata);
-      result = 31 * result + (int) (length ^ (length >>> 32));
-    } else {
-      result = 31 * result + metadata.hashCode();
-    }
-    return result;
-  }
-
   @Override
   public int hashCode() {
-    int result = headerHashCode(VERSION_MAX);
-    result = 31 * result + cachedSpans.hashCode();
+    int result = id;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + metadata.hashCode();
     return result;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 43e6730844..bc5443f365 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -15,14 +15,26 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import android.annotation.SuppressLint;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.database.DatabaseIOException;
+import com.google.android.exoplayer2.database.DatabaseProvider;
+import com.google.android.exoplayer2.database.VersionTable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.AtomicFile;
 import com.google.android.exoplayer2.util.ReusableBufferedOutputStream;
 import com.google.android.exoplayer2.util.Util;
 import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.File;
@@ -32,8 +44,10 @@
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
 import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import javax.crypto.Cipher;
@@ -45,13 +59,11 @@
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** Maintains the index of cached content. */
-/*package*/ class CachedContentIndex {
+/* package */ class CachedContentIndex {
 
-  public static final String FILE_NAME = "cached_content_index.exi";
+  /* package */ static final String FILE_NAME_ATOMIC = "cached_content_index.exi";
 
-  private static final int VERSION = 2;
-
-  private static final int FLAG_ENCRYPTED_INDEX = 1;
+  private static final int INCREMENTAL_METADATA_READ_LENGTH = 10 * 1024 * 1024;
 
   private final HashMap<String, CachedContent> keyToContent;
   /**
@@ -77,85 +89,127 @@
    * efficiently when the index is next stored.
    */
   private final SparseBooleanArray removedIds;
+  /** Tracks ids that are new since the index was last stored. */
+  private final SparseBooleanArray newIds;
+
+  private Storage storage;
+  @Nullable private Storage previousStorage;
 
-  private final AtomicFile atomicFile;
-  private final Cipher cipher;
-  private final SecretKeySpec secretKeySpec;
-  private final boolean encrypt;
-  private boolean changed;
-  private ReusableBufferedOutputStream bufferedOutputStream;
+  /** Returns whether the file is an index file. */
+  public static final boolean isIndexFile(String fileName) {
+    // Atomic file backups add additional suffixes to the file name.
+    return fileName.startsWith(FILE_NAME_ATOMIC);
+  }
 
   /**
-   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   * Deletes index data for the specified cache.
    *
-   * @param cacheDir Directory where the index file is kept.
+   * @param databaseProvider Provides the database in which the index is stored.
+   * @param uid The cache UID.
+   * @throws DatabaseIOException If an error occurs deleting the index data.
    */
-  public CachedContentIndex(File cacheDir) {
-    this(cacheDir, null);
+  public static void delete(DatabaseProvider databaseProvider, long uid)
+      throws DatabaseIOException {
+    DatabaseStorage.delete(databaseProvider, uid);
   }
 
   /**
-   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   * Creates an instance supporting database storage only.
    *
-   * @param cacheDir Directory where the index file is kept.
-   * @param secretKey 16 byte AES key for reading and writing the cache index.
+   * @param databaseProvider Provides the database in which the index is stored.
    */
-  public CachedContentIndex(File cacheDir, byte[] secretKey) {
-    this(cacheDir, secretKey, secretKey != null);
+  public CachedContentIndex(DatabaseProvider databaseProvider) {
+    this(
+        databaseProvider,
+        /* legacyStorageDir= */ null,
+        /* legacyStorageSecretKey= */ null,
+        /* legacyStorageEncrypt= */ false,
+        /* preferLegacyStorage= */ false);
   }
 
   /**
-   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   * Creates an instance supporting either or both of database and legacy storage.
    *
-   * @param cacheDir Directory where the index file is kept.
-   * @param secretKey 16 byte AES key for reading, and optionally writing, the cache index.
-   * @param encrypt Whether the index will be encrypted when written. Must be false if {@code
-   *     secretKey} is null.
+   * @param databaseProvider Provides the database in which the index is stored, or {@code null} to
+   *     use only legacy storage.
+   * @param legacyStorageDir The directory in which any legacy storage is stored, or {@code null} to
+   *     use only database storage.
+   * @param legacyStorageSecretKey A 16 byte AES key for reading, and optionally writing, legacy
+   *     storage.
+   * @param legacyStorageEncrypt Whether to encrypt when writing to legacy storage. Must be false if
+   *     {@code legacyStorageSecretKey} is null.
+   * @param preferLegacyStorage Whether to use prefer legacy storage if both storage types are
+   *     enabled. This option is only useful for downgrading from database storage back to legacy
+   *     storage.
    */
-  public CachedContentIndex(File cacheDir, byte[] secretKey, boolean encrypt) {
-    this.encrypt = encrypt;
-    if (secretKey != null) {
-      Assertions.checkArgument(secretKey.length == 16);
-      try {
-        cipher = getCipher();
-        secretKeySpec = new SecretKeySpec(secretKey, "AES");
-      } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
-        throw new IllegalStateException(e); // Should never happen.
-      }
-    } else {
-      Assertions.checkState(!encrypt);
-      cipher = null;
-      secretKeySpec = null;
-    }
+  public CachedContentIndex(
+      @Nullable DatabaseProvider databaseProvider,
+      @Nullable File legacyStorageDir,
+      @Nullable byte[] legacyStorageSecretKey,
+      boolean legacyStorageEncrypt,
+      boolean preferLegacyStorage) {
+    Assertions.checkState(databaseProvider != null || legacyStorageDir != null);
     keyToContent = new HashMap<>();
     idToKey = new SparseArray<>();
     removedIds = new SparseBooleanArray();
-    atomicFile = new AtomicFile(new File(cacheDir, FILE_NAME));
+    newIds = new SparseBooleanArray();
+    Storage databaseStorage =
+        databaseProvider != null ? new DatabaseStorage(databaseProvider) : null;
+    Storage legacyStorage =
+        legacyStorageDir != null
+            ? new LegacyStorage(
+                new File(legacyStorageDir, FILE_NAME_ATOMIC),
+                legacyStorageSecretKey,
+                legacyStorageEncrypt)
+            : null;
+    if (databaseStorage == null || (legacyStorage != null && preferLegacyStorage)) {
+      storage = legacyStorage;
+      previousStorage = databaseStorage;
+    } else {
+      storage = databaseStorage;
+      previousStorage = legacyStorage;
+    }
   }
 
-  /** Loads the index file. */
-  public void load() {
-    Assertions.checkState(!changed);
-    if (!readFile()) {
-      atomicFile.delete();
-      keyToContent.clear();
-      idToKey.clear();
+  /**
+   * Loads the index data for the given cache UID.
+   *
+   * @param uid The UID of the cache whose index is to be loaded.
+   * @throws IOException If an error occurs initializing the index data.
+   */
+  public void initialize(long uid) throws IOException {
+    storage.initialize(uid);
+    if (previousStorage != null) {
+      previousStorage.initialize(uid);
+    }
+    if (!storage.exists() && previousStorage != null && previousStorage.exists()) {
+      // Copy from previous storage into current storage.
+      previousStorage.load(keyToContent, idToKey);
+      storage.storeFully(keyToContent);
+    } else {
+      // Load from the current storage.
+      storage.load(keyToContent, idToKey);
+    }
+    if (previousStorage != null) {
+      previousStorage.delete();
+      previousStorage = null;
     }
   }
 
-  /** Stores the index data to index file if there is a change. */
-  public void store() throws CacheException {
-    if (!changed) {
-      return;
-    }
-    writeFile();
-    changed = false;
+  /**
+   * Stores the index data to index file if there is a change.
+   *
+   * @throws IOException If an error occurs storing the index data.
+   */
+  public void store() throws IOException {
+    storage.storeIncremental(keyToContent);
     // Make ids that were removed since the index was last stored eligible for re-use.
     int removedIdCount = removedIds.size();
     for (int i = 0; i < removedIdCount; i++) {
       idToKey.remove(removedIds.keyAt(i));
     }
     removedIds.clear();
+    newIds.clear();
   }
 
   /**
@@ -200,11 +254,19 @@ public void maybeRemove(String key) {
     CachedContent cachedContent = keyToContent.get(key);
     if (cachedContent != null && cachedContent.isEmpty() && !cachedContent.isLocked()) {
       keyToContent.remove(key);
-      changed = true;
-      // Keep an entry in idToKey to stop the id from being reused until the index is next stored.
-      idToKey.put(cachedContent.id, /* value= */ null);
-      // Track that the entry should be removed from idToKey when the index is next stored.
-      removedIds.put(cachedContent.id, /* value= */ true);
+      int id = cachedContent.id;
+      boolean neverStored = newIds.get(id);
+      storage.onRemove(cachedContent, neverStored);
+      if (neverStored) {
+        // The id can be reused immediately.
+        idToKey.remove(id);
+        newIds.delete(id);
+      } else {
+        // Keep an entry in idToKey to stop the id from being reused until the index is next stored,
+        // and add an entry to removedIds to track that it should be removed when this does happen.
+        idToKey.put(id, /* value= */ null);
+        removedIds.put(id, /* value= */ true);
+      }
     }
   }
 
@@ -234,7 +296,7 @@ public void removeEmpty() {
   public void applyContentMetadataMutations(String key, ContentMetadataMutations mutations) {
     CachedContent cachedContent = getOrAdd(key);
     if (cachedContent.applyMetadataMutations(mutations)) {
-      changed = true;
+      storage.onUpdate(cachedContent);
     }
   }
 
@@ -244,116 +306,17 @@ public ContentMetadata getContentMetadata(String key) {
     return cachedContent != null ? cachedContent.getMetadata() : DefaultContentMetadata.EMPTY;
   }
 
-  private boolean readFile() {
-    DataInputStream input = null;
-    try {
-      InputStream inputStream = new BufferedInputStream(atomicFile.openRead());
-      input = new DataInputStream(inputStream);
-      int version = input.readInt();
-      if (version < 0 || version > VERSION) {
-        return false;
-      }
-
-      int flags = input.readInt();
-      if ((flags & FLAG_ENCRYPTED_INDEX) != 0) {
-        if (cipher == null) {
-          return false;
-        }
-        byte[] initializationVector = new byte[16];
-        input.readFully(initializationVector);
-        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
-        try {
-          cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
-        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
-          throw new IllegalStateException(e);
-        }
-        input = new DataInputStream(new CipherInputStream(inputStream, cipher));
-      } else if (encrypt) {
-        changed = true; // Force index to be rewritten encrypted after read.
-      }
-
-      int count = input.readInt();
-      int hashCode = 0;
-      for (int i = 0; i < count; i++) {
-        CachedContent cachedContent = CachedContent.readFromStream(version, input);
-        add(cachedContent);
-        hashCode += cachedContent.headerHashCode(version);
-      }
-      int fileHashCode = input.readInt();
-      boolean isEOF = input.read() == -1;
-      if (fileHashCode != hashCode || !isEOF) {
-        return false;
-      }
-    } catch (IOException e) {
-      return false;
-    } finally {
-      if (input != null) {
-        Util.closeQuietly(input);
-      }
-    }
-    return true;
-  }
-
-  private void writeFile() throws CacheException {
-    DataOutputStream output = null;
-    try {
-      OutputStream outputStream = atomicFile.startWrite();
-      if (bufferedOutputStream == null) {
-        bufferedOutputStream = new ReusableBufferedOutputStream(outputStream);
-      } else {
-        bufferedOutputStream.reset(outputStream);
-      }
-      output = new DataOutputStream(bufferedOutputStream);
-      output.writeInt(VERSION);
-
-      int flags = encrypt ? FLAG_ENCRYPTED_INDEX : 0;
-      output.writeInt(flags);
-
-      if (encrypt) {
-        byte[] initializationVector = new byte[16];
-        new Random().nextBytes(initializationVector);
-        output.write(initializationVector);
-        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
-        try {
-          cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
-        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
-          throw new IllegalStateException(e); // Should never happen.
-        }
-        output.flush();
-        output = new DataOutputStream(new CipherOutputStream(bufferedOutputStream, cipher));
-      }
-
-      output.writeInt(keyToContent.size());
-      int hashCode = 0;
-      for (CachedContent cachedContent : keyToContent.values()) {
-        cachedContent.writeToStream(output);
-        hashCode += cachedContent.headerHashCode(VERSION);
-      }
-      output.writeInt(hashCode);
-      atomicFile.endWrite(output);
-      // Avoid calling close twice. Duplicate CipherOutputStream.close calls did
-      // not used to be no-ops: https://android-review.googlesource.com/#/c/272799/
-      output = null;
-    } catch (IOException e) {
-      throw new CacheException(e);
-    } finally {
-      Util.closeQuietly(output);
-    }
-  }
-
   private CachedContent addNew(String key) {
     int id = getNewId(idToKey);
     CachedContent cachedContent = new CachedContent(id, key);
-    add(cachedContent);
-    changed = true;
+    keyToContent.put(key, cachedContent);
+    idToKey.put(id, key);
+    newIds.put(id, true);
+    storage.onUpdate(cachedContent);
     return cachedContent;
   }
 
-  private void add(CachedContent cachedContent) {
-    keyToContent.put(cachedContent.key, cachedContent);
-    idToKey.put(cachedContent.id, cachedContent.key);
-  }
-
+  @SuppressLint("GetInstance") // Suppress warning about specifying "BC" as an explicit provider.
   private static Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException {
     // Workaround for https://issuetracker.google.com/issues/36976726
     if (Util.SDK_INT == 18) {
@@ -371,8 +334,8 @@ private static Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithm
    * than {@link java.lang.Integer#MAX_VALUE} it just returns the next bigger integer. Otherwise it
    * returns the smallest unused non-negative integer.
    */
-  //@VisibleForTesting
-  public static int getNewId(SparseArray<String> idToKey) {
+  @VisibleForTesting
+  /* package */ static int getNewId(SparseArray<String> idToKey) {
     int size = idToKey.size();
     int id = size == 0 ? 0 : (idToKey.keyAt(size - 1) + 1);
     if (id < 0) { // In case if we pass max int value.
@@ -386,4 +349,598 @@ public static int getNewId(SparseArray<String> idToKey) {
     return id;
   }
 
+  /**
+   * Deserializes a {@link DefaultContentMetadata} from the given input stream.
+   *
+   * @param input Input stream to read from.
+   * @return a {@link DefaultContentMetadata} instance.
+   * @throws IOException If an error occurs during reading from the input.
+   */
+  private static DefaultContentMetadata readContentMetadata(DataInputStream input)
+      throws IOException {
+    int size = input.readInt();
+    HashMap<String, byte[]> metadata = new HashMap<>();
+    for (int i = 0; i < size; i++) {
+      String name = input.readUTF();
+      int valueSize = input.readInt();
+      if (valueSize < 0) {
+        throw new IOException("Invalid value size: " + valueSize);
+      }
+      // Grow the array incrementally to avoid OutOfMemoryError in the case that a corrupt (and very
+      // large) valueSize was read. In such cases the implementation below is expected to throw
+      // IOException from one of the readFully calls, due to the end of the input being reached.
+      int bytesRead = 0;
+      int nextBytesToRead = Math.min(valueSize, INCREMENTAL_METADATA_READ_LENGTH);
+      byte[] value = Util.EMPTY_BYTE_ARRAY;
+      while (bytesRead != valueSize) {
+        value = Arrays.copyOf(value, bytesRead + nextBytesToRead);
+        input.readFully(value, bytesRead, nextBytesToRead);
+        bytesRead += nextBytesToRead;
+        nextBytesToRead = Math.min(valueSize - bytesRead, INCREMENTAL_METADATA_READ_LENGTH);
+      }
+      metadata.put(name, value);
+    }
+    return new DefaultContentMetadata(metadata);
+  }
+
+  /**
+   * Serializes itself to a {@link DataOutputStream}.
+   *
+   * @param output Output stream to store the values.
+   * @throws IOException If an error occurs writing to the output.
+   */
+  private static void writeContentMetadata(DefaultContentMetadata metadata, DataOutputStream output)
+      throws IOException {
+    Set<Map.Entry<String, byte[]>> entrySet = metadata.entrySet();
+    output.writeInt(entrySet.size());
+    for (Map.Entry<String, byte[]> entry : entrySet) {
+      output.writeUTF(entry.getKey());
+      byte[] value = entry.getValue();
+      output.writeInt(value.length);
+      output.write(value);
+    }
+  }
+
+  /** Interface for the persistent index. */
+  private interface Storage {
+
+    /** Initializes the storage for the given cache UID. */
+    void initialize(long uid);
+
+    /**
+     * Returns whether the persisted index exists.
+     *
+     * @throws IOException If an error occurs determining whether the persisted index exists.
+     */
+    boolean exists() throws IOException;
+
+    /**
+     * Deletes the persisted index.
+     *
+     * @throws IOException If an error occurs deleting the index.
+     */
+    void delete() throws IOException;
+
+    /**
+     * Loads the persisted index into {@code content} and {@code idToKey}, creating it if it doesn't
+     * already exist.
+     *
+     * <p>If the persisted index is in a permanently bad state (i.e. all further attempts to load it
+     * are also expected to fail) then it will be deleted and the call will return successfully. For
+     * transient failures, {@link IOException} will be thrown.
+     *
+     * @param content The key to content map to populate with persisted data.
+     * @param idToKey The id to key map to populate with persisted data.
+     * @throws IOException If an error occurs loading the index.
+     */
+    void load(HashMap<String, CachedContent> content, SparseArray<@NullableType String> idToKey)
+        throws IOException;
+
+    /**
+     * Writes the persisted index, creating it if it doesn't already exist and replacing any
+     * existing content if it does.
+     *
+     * @param content The key to content map to persist.
+     * @throws IOException If an error occurs persisting the index.
+     */
+    void storeFully(HashMap<String, CachedContent> content) throws IOException;
+
+    /**
+     * Ensures incremental changes to the index since the initial {@link #initialize(long)} or last
+     * {@link #storeFully(HashMap)} are persisted. The storage will have been notified of all such
+     * changes via {@link #onUpdate(CachedContent)} and {@link #onRemove(CachedContent, boolean)}.
+     *
+     * @param content The key to content map to persist.
+     * @throws IOException If an error occurs persisting the index.
+     */
+    void storeIncremental(HashMap<String, CachedContent> content) throws IOException;
+
+    /**
+     * Called when a {@link CachedContent} is added or updated.
+     *
+     * @param cachedContent The updated {@link CachedContent}.
+     */
+    void onUpdate(CachedContent cachedContent);
+
+    /**
+     * Called when a {@link CachedContent} is removed.
+     *
+     * @param cachedContent The removed {@link CachedContent}.
+     * @param neverStored True if the {@link CachedContent} was added more recently than when the
+     *     index was last stored.
+     */
+    void onRemove(CachedContent cachedContent, boolean neverStored);
+  }
+
+  /** {@link Storage} implementation that uses an {@link AtomicFile}. */
+  private static class LegacyStorage implements Storage {
+
+    private static final int VERSION = 2;
+    private static final int VERSION_METADATA_INTRODUCED = 2;
+    private static final int FLAG_ENCRYPTED_INDEX = 1;
+
+    private final boolean encrypt;
+    @Nullable private final Cipher cipher;
+    @Nullable private final SecretKeySpec secretKeySpec;
+    @Nullable private final Random random;
+    private final AtomicFile atomicFile;
+
+    private boolean changed;
+    @Nullable private ReusableBufferedOutputStream bufferedOutputStream;
+
+    public LegacyStorage(File file, @Nullable byte[] secretKey, boolean encrypt) {
+      Cipher cipher = null;
+      SecretKeySpec secretKeySpec = null;
+      if (secretKey != null) {
+        Assertions.checkArgument(secretKey.length == 16);
+        try {
+          cipher = getCipher();
+          secretKeySpec = new SecretKeySpec(secretKey, "AES");
+        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
+          throw new IllegalStateException(e); // Should never happen.
+        }
+      } else {
+        Assertions.checkArgument(!encrypt);
+      }
+      this.encrypt = encrypt;
+      this.cipher = cipher;
+      this.secretKeySpec = secretKeySpec;
+      random = encrypt ? new Random() : null;
+      atomicFile = new AtomicFile(file);
+    }
+
+    @Override
+    public void initialize(long uid) {
+      // Do nothing. Legacy storage uses a separate file for each cache.
+    }
+
+    @Override
+    public boolean exists() {
+      return atomicFile.exists();
+    }
+
+    @Override
+    public void delete() {
+      atomicFile.delete();
+    }
+
+    @Override
+    public void load(
+        HashMap<String, CachedContent> content, SparseArray<@NullableType String> idToKey) {
+      Assertions.checkState(!changed);
+      if (!readFile(content, idToKey)) {
+        content.clear();
+        idToKey.clear();
+        atomicFile.delete();
+      }
+    }
+
+    @Override
+    public void storeFully(HashMap<String, CachedContent> content) throws IOException {
+      writeFile(content);
+      changed = false;
+    }
+
+    @Override
+    public void storeIncremental(HashMap<String, CachedContent> content) throws IOException {
+      if (!changed) {
+        return;
+      }
+      storeFully(content);
+    }
+
+    @Override
+    public void onUpdate(CachedContent cachedContent) {
+      changed = true;
+    }
+
+    @Override
+    public void onRemove(CachedContent cachedContent, boolean neverStored) {
+      changed = true;
+    }
+
+    private boolean readFile(
+        HashMap<String, CachedContent> content, SparseArray<@NullableType String> idToKey) {
+      if (!atomicFile.exists()) {
+        return true;
+      }
+
+      DataInputStream input = null;
+      try {
+        InputStream inputStream = new BufferedInputStream(atomicFile.openRead());
+        input = new DataInputStream(inputStream);
+        int version = input.readInt();
+        if (version < 0 || version > VERSION) {
+          return false;
+        }
+
+        int flags = input.readInt();
+        if ((flags & FLAG_ENCRYPTED_INDEX) != 0) {
+          if (cipher == null) {
+            return false;
+          }
+          byte[] initializationVector = new byte[16];
+          input.readFully(initializationVector);
+          IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+          try {
+            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
+          } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+            throw new IllegalStateException(e);
+          }
+          input = new DataInputStream(new CipherInputStream(inputStream, cipher));
+        } else if (encrypt) {
+          changed = true; // Force index to be rewritten encrypted after read.
+        }
+
+        int count = input.readInt();
+        int hashCode = 0;
+        for (int i = 0; i < count; i++) {
+          CachedContent cachedContent = readCachedContent(version, input);
+          content.put(cachedContent.key, cachedContent);
+          idToKey.put(cachedContent.id, cachedContent.key);
+          hashCode += hashCachedContent(cachedContent, version);
+        }
+        int fileHashCode = input.readInt();
+        boolean isEOF = input.read() == -1;
+        if (fileHashCode != hashCode || !isEOF) {
+          return false;
+        }
+      } catch (IOException e) {
+        return false;
+      } finally {
+        if (input != null) {
+          Util.closeQuietly(input);
+        }
+      }
+      return true;
+    }
+
+    private void writeFile(HashMap<String, CachedContent> content) throws IOException {
+      DataOutputStream output = null;
+      try {
+        OutputStream outputStream = atomicFile.startWrite();
+        if (bufferedOutputStream == null) {
+          bufferedOutputStream = new ReusableBufferedOutputStream(outputStream);
+        } else {
+          bufferedOutputStream.reset(outputStream);
+        }
+        output = new DataOutputStream(bufferedOutputStream);
+        output.writeInt(VERSION);
+
+        int flags = encrypt ? FLAG_ENCRYPTED_INDEX : 0;
+        output.writeInt(flags);
+
+        if (encrypt) {
+          byte[] initializationVector = new byte[16];
+          random.nextBytes(initializationVector);
+          output.write(initializationVector);
+          IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+          try {
+            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
+          } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+            throw new IllegalStateException(e); // Should never happen.
+          }
+          output.flush();
+          output = new DataOutputStream(new CipherOutputStream(bufferedOutputStream, cipher));
+        }
+
+        output.writeInt(content.size());
+        int hashCode = 0;
+        for (CachedContent cachedContent : content.values()) {
+          writeCachedContent(cachedContent, output);
+          hashCode += hashCachedContent(cachedContent, VERSION);
+        }
+        output.writeInt(hashCode);
+        atomicFile.endWrite(output);
+        // Avoid calling close twice. Duplicate CipherOutputStream.close calls did
+        // not used to be no-ops: https://android-review.googlesource.com/#/c/272799/
+        output = null;
+      } finally {
+        Util.closeQuietly(output);
+      }
+    }
+
+    /**
+     * Calculates a hash code for a {@link CachedContent} which is compatible with a particular
+     * index version.
+     */
+    private int hashCachedContent(CachedContent cachedContent, int version) {
+      int result = cachedContent.id;
+      result = 31 * result + cachedContent.key.hashCode();
+      if (version < VERSION_METADATA_INTRODUCED) {
+        long length = ContentMetadata.getContentLength(cachedContent.getMetadata());
+        result = 31 * result + (int) (length ^ (length >>> 32));
+      } else {
+        result = 31 * result + cachedContent.getMetadata().hashCode();
+      }
+      return result;
+    }
+
+    /**
+     * Reads a {@link CachedContent} from a {@link DataInputStream}.
+     *
+     * @param version Version of the encoded data.
+     * @param input Input stream containing values needed to initialize CachedContent instance.
+     * @throws IOException If an error occurs during reading values.
+     */
+    private CachedContent readCachedContent(int version, DataInputStream input) throws IOException {
+      int id = input.readInt();
+      String key = input.readUTF();
+      DefaultContentMetadata metadata;
+      if (version < VERSION_METADATA_INTRODUCED) {
+        long length = input.readLong();
+        ContentMetadataMutations mutations = new ContentMetadataMutations();
+        ContentMetadataMutations.setContentLength(mutations, length);
+        metadata = DefaultContentMetadata.EMPTY.copyWithMutationsApplied(mutations);
+      } else {
+        metadata = readContentMetadata(input);
+      }
+      return new CachedContent(id, key, metadata);
+    }
+
+    /**
+     * Writes a {@link CachedContent} to a {@link DataOutputStream}.
+     *
+     * @param output Output stream to store the values.
+     * @throws IOException If an error occurs during writing values to output.
+     */
+    private void writeCachedContent(CachedContent cachedContent, DataOutputStream output)
+        throws IOException {
+      output.writeInt(cachedContent.id);
+      output.writeUTF(cachedContent.key);
+      writeContentMetadata(cachedContent.getMetadata(), output);
+    }
+  }
+
+  /** {@link Storage} implementation that uses an SQL database. */
+  private static final class DatabaseStorage implements Storage {
+
+    private static final String TABLE_PREFIX = DatabaseProvider.TABLE_PREFIX + "CacheIndex";
+    private static final int TABLE_VERSION = 1;
+
+    private static final String COLUMN_ID = "id";
+    private static final String COLUMN_KEY = "key";
+    private static final String COLUMN_METADATA = "metadata";
+
+    private static final int COLUMN_INDEX_ID = 0;
+    private static final int COLUMN_INDEX_KEY = 1;
+    private static final int COLUMN_INDEX_METADATA = 2;
+
+    private static final String WHERE_ID_EQUALS = COLUMN_ID + " = ?";
+
+    private static final String[] COLUMNS = new String[] {COLUMN_ID, COLUMN_KEY, COLUMN_METADATA};
+    private static final String TABLE_SCHEMA =
+        "("
+            + COLUMN_ID
+            + " INTEGER PRIMARY KEY NOT NULL,"
+            + COLUMN_KEY
+            + " TEXT NOT NULL,"
+            + COLUMN_METADATA
+            + " BLOB NOT NULL)";
+
+    private final DatabaseProvider databaseProvider;
+    private final SparseArray<CachedContent> pendingUpdates;
+
+    private String hexUid;
+    private String tableName;
+
+    public static void delete(DatabaseProvider databaseProvider, long uid)
+        throws DatabaseIOException {
+      delete(databaseProvider, Long.toHexString(uid));
+    }
+
+    public DatabaseStorage(DatabaseProvider databaseProvider) {
+      this.databaseProvider = databaseProvider;
+      pendingUpdates = new SparseArray<>();
+    }
+
+    @Override
+    public void initialize(long uid) {
+      hexUid = Long.toHexString(uid);
+      tableName = getTableName(hexUid);
+    }
+
+    @Override
+    public boolean exists() throws DatabaseIOException {
+      return VersionTable.getVersion(
+              databaseProvider.getReadableDatabase(),
+              VersionTable.FEATURE_CACHE_CONTENT_METADATA,
+              hexUid)
+          != VersionTable.VERSION_UNSET;
+    }
+
+    @Override
+    public void delete() throws DatabaseIOException {
+      delete(databaseProvider, hexUid);
+    }
+
+    @Override
+    public void load(
+        HashMap<String, CachedContent> content, SparseArray<@NullableType String> idToKey)
+        throws IOException {
+      Assertions.checkState(pendingUpdates.size() == 0);
+      try {
+        int version =
+            VersionTable.getVersion(
+                databaseProvider.getReadableDatabase(),
+                VersionTable.FEATURE_CACHE_CONTENT_METADATA,
+                hexUid);
+        if (version != TABLE_VERSION) {
+          SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+          writableDatabase.beginTransaction();
+          try {
+            initializeTable(writableDatabase);
+            writableDatabase.setTransactionSuccessful();
+          } finally {
+            writableDatabase.endTransaction();
+          }
+        }
+
+        try (Cursor cursor = getCursor()) {
+          while (cursor.moveToNext()) {
+            int id = cursor.getInt(COLUMN_INDEX_ID);
+            String key = cursor.getString(COLUMN_INDEX_KEY);
+            byte[] metadataBytes = cursor.getBlob(COLUMN_INDEX_METADATA);
+
+            ByteArrayInputStream inputStream = new ByteArrayInputStream(metadataBytes);
+            DataInputStream input = new DataInputStream(inputStream);
+            DefaultContentMetadata metadata = readContentMetadata(input);
+
+            CachedContent cachedContent = new CachedContent(id, key, metadata);
+            content.put(cachedContent.key, cachedContent);
+            idToKey.put(cachedContent.id, cachedContent.key);
+          }
+        }
+      } catch (SQLiteException e) {
+        content.clear();
+        idToKey.clear();
+        throw new DatabaseIOException(e);
+      }
+    }
+
+    @Override
+    public void storeFully(HashMap<String, CachedContent> content) throws IOException {
+      try {
+        SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+        writableDatabase.beginTransaction();
+        try {
+          initializeTable(writableDatabase);
+          for (CachedContent cachedContent : content.values()) {
+            addOrUpdateRow(writableDatabase, cachedContent);
+          }
+          writableDatabase.setTransactionSuccessful();
+          pendingUpdates.clear();
+        } finally {
+          writableDatabase.endTransaction();
+        }
+      } catch (SQLException e) {
+        throw new DatabaseIOException(e);
+      }
+    }
+
+    @Override
+    public void storeIncremental(HashMap<String, CachedContent> content) throws IOException {
+      if (pendingUpdates.size() == 0) {
+        return;
+      }
+      try {
+        SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+        writableDatabase.beginTransaction();
+        try {
+          for (int i = 0; i < pendingUpdates.size(); i++) {
+            CachedContent cachedContent = pendingUpdates.valueAt(i);
+            if (cachedContent == null) {
+              deleteRow(writableDatabase, pendingUpdates.keyAt(i));
+            } else {
+              addOrUpdateRow(writableDatabase, cachedContent);
+            }
+          }
+          writableDatabase.setTransactionSuccessful();
+          pendingUpdates.clear();
+        } finally {
+          writableDatabase.endTransaction();
+        }
+      } catch (SQLException e) {
+        throw new DatabaseIOException(e);
+      }
+    }
+
+    @Override
+    public void onUpdate(CachedContent cachedContent) {
+      pendingUpdates.put(cachedContent.id, cachedContent);
+    }
+
+    @Override
+    public void onRemove(CachedContent cachedContent, boolean neverStored) {
+      if (neverStored) {
+        pendingUpdates.delete(cachedContent.id);
+      } else {
+        pendingUpdates.put(cachedContent.id, null);
+      }
+    }
+
+    private Cursor getCursor() {
+      return databaseProvider
+          .getReadableDatabase()
+          .query(
+              tableName,
+              COLUMNS,
+              /* selection= */ null,
+              /* selectionArgs= */ null,
+              /* groupBy= */ null,
+              /* having= */ null,
+              /* orderBy= */ null);
+    }
+
+    private void initializeTable(SQLiteDatabase writableDatabase) throws DatabaseIOException {
+      VersionTable.setVersion(
+          writableDatabase, VersionTable.FEATURE_CACHE_CONTENT_METADATA, hexUid, TABLE_VERSION);
+      dropTable(writableDatabase, tableName);
+      writableDatabase.execSQL("CREATE TABLE " + tableName + " " + TABLE_SCHEMA);
+    }
+
+    private void deleteRow(SQLiteDatabase writableDatabase, int key) {
+      writableDatabase.delete(tableName, WHERE_ID_EQUALS, new String[] {Integer.toString(key)});
+    }
+
+    private void addOrUpdateRow(SQLiteDatabase writableDatabase, CachedContent cachedContent)
+        throws IOException {
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      writeContentMetadata(cachedContent.getMetadata(), new DataOutputStream(outputStream));
+      byte[] data = outputStream.toByteArray();
+
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_ID, cachedContent.id);
+      values.put(COLUMN_KEY, cachedContent.key);
+      values.put(COLUMN_METADATA, data);
+      writableDatabase.replaceOrThrow(tableName, /* nullColumnHack= */ null, values);
+    }
+
+    private static void delete(DatabaseProvider databaseProvider, String hexUid)
+        throws DatabaseIOException {
+      try {
+        String tableName = getTableName(hexUid);
+        SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+        writableDatabase.beginTransaction();
+        try {
+          VersionTable.removeVersion(
+              writableDatabase, VersionTable.FEATURE_CACHE_CONTENT_METADATA, hexUid);
+          dropTable(writableDatabase, tableName);
+          writableDatabase.setTransactionSuccessful();
+        } finally {
+          writableDatabase.endTransaction();
+        }
+      } catch (SQLException e) {
+        throw new DatabaseIOException(e);
+      }
+    }
+
+    private static void dropTable(SQLiteDatabase writableDatabase, String tableName) {
+      writableDatabase.execSQL("DROP TABLE IF EXISTS " + tableName);
+    }
+
+    private static String getTableName(String hexUid) {
+      return TABLE_PREFIX + hexUid;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
index 6d090d073e..fb2d4f694f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
@@ -15,9 +15,10 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
 import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NavigableSet;
@@ -195,8 +196,7 @@ public Region(long position, long endOffset) {
 
     @Override
     public int compareTo(@NonNull Region another) {
-      return startOffset < another.startOffset ? -1
-          : startOffset == another.startOffset ? 0 : 1;
+      return Util.compareLong(startOffset, another.startOffset);
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadata.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadata.java
index aacd11f915..4cc6e6b860 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadata.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadata.java
@@ -15,44 +15,73 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+
 /**
  * Interface for an immutable snapshot of keyed metadata.
- *
- * <p>Internal metadata names are prefixed with {@value #INTERNAL_METADATA_NAME_PREFIX}. Custom
- * metadata names should avoid this prefix to prevent clashes.
  */
 public interface ContentMetadata {
 
-  /** Prefix of internal metadata names. */
-  String INTERNAL_METADATA_NAME_PREFIX = "exo_";
+  /**
+   * Prefix for custom metadata keys. Applications can use keys starting with this prefix without
+   * any risk of their keys colliding with ones defined by the ExoPlayer library.
+   */
+  @SuppressWarnings("unused")
+  String KEY_CUSTOM_PREFIX = "custom_";
+  /** Key for redirected uri (type: String). */
+  String KEY_REDIRECTED_URI = "exo_redir";
+  /** Key for content length in bytes (type: long). */
+  String KEY_CONTENT_LENGTH = "exo_len";
 
   /**
    * Returns a metadata value.
    *
-   * @param name Name of the metadata to be returned.
+   * @param key Key of the metadata to be returned.
    * @param defaultValue Value to return if the metadata doesn't exist.
    * @return The metadata value.
    */
-  byte[] get(String name, byte[] defaultValue);
+  @Nullable
+  byte[] get(String key, @Nullable byte[] defaultValue);
 
   /**
    * Returns a metadata value.
    *
-   * @param name Name of the metadata to be returned.
+   * @param key Key of the metadata to be returned.
    * @param defaultValue Value to return if the metadata doesn't exist.
    * @return The metadata value.
    */
-  String get(String name, String defaultValue);
+  @Nullable
+  String get(String key, @Nullable String defaultValue);
 
   /**
    * Returns a metadata value.
    *
-   * @param name Name of the metadata to be returned.
+   * @param key Key of the metadata to be returned.
    * @param defaultValue Value to return if the metadata doesn't exist.
    * @return The metadata value.
    */
-  long get(String name, long defaultValue);
+  long get(String key, long defaultValue);
 
   /** Returns whether the metadata is available. */
-  boolean contains(String name);
+  boolean contains(String key);
+
+  /**
+   * Returns the value stored under {@link #KEY_CONTENT_LENGTH}, or {@link C#LENGTH_UNSET} if not
+   * set.
+   */
+  static long getContentLength(ContentMetadata contentMetadata) {
+    return contentMetadata.get(KEY_CONTENT_LENGTH, C.LENGTH_UNSET);
+  }
+
+  /**
+   * Returns the value stored under {@link #KEY_REDIRECTED_URI} as a {@link Uri}, or {code null} if
+   * not set.
+   */
+  @Nullable
+  static Uri getRedirectedUri(ContentMetadata contentMetadata) {
+    String redirectedUri = contentMetadata.get(KEY_REDIRECTED_URI, (String) null);
+    return redirectedUri == null ? null : Uri.parse(redirectedUri);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataInternal.java
deleted file mode 100644
index 0065018260..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataInternal.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-
-/** Helper classes to easily access and modify internal metadata values. */
-/* package */ final class ContentMetadataInternal {
-
-  private static final String PREFIX = ContentMetadata.INTERNAL_METADATA_NAME_PREFIX;
-  private static final String METADATA_NAME_REDIRECTED_URI = PREFIX + "redir";
-  private static final String METADATA_NAME_CONTENT_LENGTH = PREFIX + "len";
-
-  /** Returns the content length metadata, or {@link C#LENGTH_UNSET} if not set. */
-  public static long getContentLength(ContentMetadata contentMetadata) {
-    return contentMetadata.get(METADATA_NAME_CONTENT_LENGTH, C.LENGTH_UNSET);
-  }
-
-  /** Adds a mutation to set content length metadata value. */
-  public static void setContentLength(ContentMetadataMutations mutations, long length) {
-    mutations.set(METADATA_NAME_CONTENT_LENGTH, length);
-  }
-
-  /** Adds a mutation to remove content length metadata value. */
-  public static void removeContentLength(ContentMetadataMutations mutations) {
-    mutations.remove(METADATA_NAME_CONTENT_LENGTH);
-  }
-
-  /** Returns the redirected uri metadata, or {@code null} if not set. */
-  public @Nullable static Uri getRedirectedUri(ContentMetadata contentMetadata) {
-    String redirectedUri = contentMetadata.get(METADATA_NAME_REDIRECTED_URI, (String) null);
-    return redirectedUri == null ? null : Uri.parse(redirectedUri);
-  }
-
-  /**
-   * Adds a mutation to set redirected uri metadata value. Passing {@code null} as {@code uri} isn't
-   * allowed.
-   */
-  public static void setRedirectedUri(ContentMetadataMutations mutations, Uri uri) {
-    mutations.set(METADATA_NAME_REDIRECTED_URI, uri.toString());
-  }
-
-  /** Adds a mutation to remove redirected uri metadata value. */
-  public static void removeRedirectedUri(ContentMetadataMutations mutations) {
-    mutations.remove(METADATA_NAME_REDIRECTED_URI);
-  }
-
-  private ContentMetadataInternal() {
-    // Prevent instantiation.
-  }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataMutations.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataMutations.java
index 70154b0308..5715b8fbd4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataMutations.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/ContentMetadataMutations.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -30,6 +33,36 @@
  */
 public class ContentMetadataMutations {
 
+  /**
+   * Adds a mutation to set the {@link ContentMetadata#KEY_CONTENT_LENGTH} value, or to remove any
+   * existing value if {@link C#LENGTH_UNSET} is passed.
+   *
+   * @param mutations The mutations to modify.
+   * @param length The length value, or {@link C#LENGTH_UNSET} to remove any existing entry.
+   * @return The mutations instance, for convenience.
+   */
+  public static ContentMetadataMutations setContentLength(
+      ContentMetadataMutations mutations, long length) {
+    return mutations.set(ContentMetadata.KEY_CONTENT_LENGTH, length);
+  }
+
+  /**
+   * Adds a mutation to set the {@link ContentMetadata#KEY_REDIRECTED_URI} value, or to remove any
+   * existing entry if {@code null} is passed.
+   *
+   * @param mutations The mutations to modify.
+   * @param uri The {@link Uri} value, or {@code null} to remove any existing entry.
+   * @return The mutations instance, for convenience.
+   */
+  public static ContentMetadataMutations setRedirectedUri(
+      ContentMetadataMutations mutations, @Nullable Uri uri) {
+    if (uri == null) {
+      return mutations.remove(ContentMetadata.KEY_REDIRECTED_URI);
+    } else {
+      return mutations.set(ContentMetadata.KEY_REDIRECTED_URI, uri.toString());
+    }
+  }
+
   private final Map<String, Object> editedValues;
   private final List<String> removedValues;
 
@@ -45,7 +78,7 @@ public ContentMetadataMutations() {
    *
    * @param name The name of the metadata value.
    * @param value The value to be set.
-   * @return This Editor instance, for convenience.
+   * @return This instance, for convenience.
    */
   public ContentMetadataMutations set(String name, String value) {
     return checkAndSet(name, value);
@@ -56,7 +89,7 @@ public ContentMetadataMutations set(String name, String value) {
    *
    * @param name The name of the metadata value.
    * @param value The value to be set.
-   * @return This Editor instance, for convenience.
+   * @return This instance, for convenience.
    */
   public ContentMetadataMutations set(String name, long value) {
     return checkAndSet(name, value);
@@ -68,7 +101,7 @@ public ContentMetadataMutations set(String name, long value) {
    *
    * @param name The name of the metadata value.
    * @param value The value to be set.
-   * @return This Editor instance, for convenience.
+   * @return This instance, for convenience.
    */
   public ContentMetadataMutations set(String name, byte[] value) {
     return checkAndSet(name, Arrays.copyOf(value, value.length));
@@ -78,7 +111,7 @@ public ContentMetadataMutations set(String name, byte[] value) {
    * Adds a mutation to remove a metadata value.
    *
    * @param name The name of the metadata value.
-   * @return This Editor instance, for convenience.
+   * @return This instance, for convenience.
    */
   public ContentMetadataMutations remove(String name) {
     removedValues.add(name);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java
index e16ff5483a..1f07af938a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadata.java
@@ -15,11 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.Arrays;
@@ -28,6 +25,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 
 /** Default implementation of {@link ContentMetadata}. Values are stored as byte arrays. */
 public final class DefaultContentMetadata implements ContentMetadata {
@@ -36,35 +34,16 @@
   public static final DefaultContentMetadata EMPTY =
       new DefaultContentMetadata(Collections.emptyMap());
 
-  private static final int MAX_VALUE_LENGTH = 10 * 1024 * 1024;
   private int hashCode;
 
-  /**
-   * Deserializes a {@link DefaultContentMetadata} from the given input stream.
-   *
-   * @param input Input stream to read from.
-   * @return a {@link DefaultContentMetadata} instance.
-   * @throws IOException If an error occurs during reading from input.
-   */
-  public static DefaultContentMetadata readFromStream(DataInputStream input) throws IOException {
-    int size = input.readInt();
-    HashMap<String, byte[]> metadata = new HashMap<>();
-    for (int i = 0; i < size; i++) {
-      String name = input.readUTF();
-      int valueSize = input.readInt();
-      if (valueSize < 0 || valueSize > MAX_VALUE_LENGTH) {
-        throw new IOException("Invalid value size: " + valueSize);
-      }
-      byte[] value = new byte[valueSize];
-      input.readFully(value);
-      metadata.put(name, value);
-    }
-    return new DefaultContentMetadata(metadata);
-  }
-
   private final Map<String, byte[]> metadata;
 
-  private DefaultContentMetadata(Map<String, byte[]> metadata) {
+  public DefaultContentMetadata() {
+    this(Collections.emptyMap());
+  }
+
+  /** @param metadata The metadata entries in their raw byte array form. */
+  public DefaultContentMetadata(Map<String, byte[]> metadata) {
     this.metadata = Collections.unmodifiableMap(metadata);
   }
 
@@ -74,30 +53,20 @@ private DefaultContentMetadata(Map<String, byte[]> metadata) {
    */
   public DefaultContentMetadata copyWithMutationsApplied(ContentMetadataMutations mutations) {
     Map<String, byte[]> mutatedMetadata = applyMutations(metadata, mutations);
-    if (isMetadataEqual(mutatedMetadata)) {
+    if (isMetadataEqual(metadata, mutatedMetadata)) {
       return this;
     }
     return new DefaultContentMetadata(mutatedMetadata);
   }
 
-  /**
-   * Serializes itself to a {@link DataOutputStream}.
-   *
-   * @param output Output stream to store the values.
-   * @throws IOException If an error occurs during writing values to output.
-   */
-  public void writeToStream(DataOutputStream output) throws IOException {
-    output.writeInt(metadata.size());
-    for (Entry<String, byte[]> entry : metadata.entrySet()) {
-      output.writeUTF(entry.getKey());
-      byte[] value = entry.getValue();
-      output.writeInt(value.length);
-      output.write(value);
-    }
+  /** Returns the set of metadata entries in their raw byte array form. */
+  public Set<Entry<String, byte[]>> entrySet() {
+    return metadata.entrySet();
   }
 
   @Override
-  public final byte[] get(String name, byte[] defaultValue) {
+  @Nullable
+  public final byte[] get(String name, @Nullable byte[] defaultValue) {
     if (metadata.containsKey(name)) {
       byte[] bytes = metadata.get(name);
       return Arrays.copyOf(bytes, bytes.length);
@@ -107,7 +76,8 @@ public void writeToStream(DataOutputStream output) throws IOException {
   }
 
   @Override
-  public final String get(String name, String defaultValue) {
+  @Nullable
+  public final String get(String name, @Nullable String defaultValue) {
     if (metadata.containsKey(name)) {
       byte[] bytes = metadata.get(name);
       return new String(bytes, Charset.forName(C.UTF8_NAME));
@@ -139,21 +109,7 @@ public boolean equals(@Nullable Object o) {
     if (o == null || getClass() != o.getClass()) {
       return false;
     }
-    return isMetadataEqual(((DefaultContentMetadata) o).metadata);
-  }
-
-  private boolean isMetadataEqual(Map<String, byte[]> otherMetadata) {
-    if (metadata.size() != otherMetadata.size()) {
-      return false;
-    }
-    for (Entry<String, byte[]> entry : metadata.entrySet()) {
-      byte[] value = entry.getValue();
-      byte[] otherValue = otherMetadata.get(entry.getKey());
-      if (!Arrays.equals(value, otherValue)) {
-        return false;
-      }
-    }
-    return true;
+    return isMetadataEqual(metadata, ((DefaultContentMetadata) o).metadata);
   }
 
   @Override
@@ -168,6 +124,20 @@ public int hashCode() {
     return hashCode;
   }
 
+  private static boolean isMetadataEqual(Map<String, byte[]> first, Map<String, byte[]> second) {
+    if (first.size() != second.size()) {
+      return false;
+    }
+    for (Entry<String, byte[]> entry : first.entrySet()) {
+      byte[] value = entry.getValue();
+      byte[] otherValue = second.get(entry.getKey());
+      if (!Arrays.equals(value, otherValue)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   private static Map<String, byte[]> applyMutations(
       Map<String, byte[]> otherMetadata, ContentMetadataMutations mutations) {
     HashMap<String, byte[]> metadata = new HashMap<>(otherMetadata);
@@ -184,18 +154,7 @@ private static void removeValues(HashMap<String, byte[]> metadata, List<String>
 
   private static void addValues(HashMap<String, byte[]> metadata, Map<String, Object> values) {
     for (String name : values.keySet()) {
-      Object value = values.get(name);
-      byte[] bytes = getBytes(value);
-      if (bytes.length > MAX_VALUE_LENGTH) {
-        throw new IllegalArgumentException(
-            "The size of "
-                + name
-                + " ("
-                + bytes.length
-                + ") is greater than maximum allowed: "
-                + MAX_VALUE_LENGTH);
-      }
-      metadata.put(name, bytes);
+      metadata.put(name, getBytes(values.get(name)));
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 79d23dd1b0..44a735f144 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import java.util.Comparator;
 import java.util.TreeSet;
@@ -34,14 +35,21 @@ public LeastRecentlyUsedCacheEvictor(long maxBytes) {
     this.leastRecentlyUsed = new TreeSet<>(this);
   }
 
+  @Override
+  public boolean requiresCacheSpanTouches() {
+    return true;
+  }
+
   @Override
   public void onCacheInitialized() {
     // Do nothing.
   }
 
   @Override
-  public void onStartFile(Cache cache, String key, long position, long maxLength) {
-    evictCache(cache, maxLength);
+  public void onStartFile(Cache cache, String key, long position, long length) {
+    if (length != C.LENGTH_UNSET) {
+      evictCache(cache, length);
+    }
   }
 
   @Override
@@ -65,12 +73,12 @@ public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
 
   @Override
   public int compare(CacheSpan lhs, CacheSpan rhs) {
-    long lastAccessTimestampDelta = lhs.lastAccessTimestamp - rhs.lastAccessTimestamp;
-    if (lastAccessTimestampDelta == 0) {
+    long lastTouchTimestampDelta = lhs.lastTouchTimestamp - rhs.lastTouchTimestamp;
+    if (lastTouchTimestampDelta == 0) {
       // Use the standard compareTo method as a tie-break.
       return lhs.compareTo(rhs);
     }
-    return lhs.lastAccessTimestamp < rhs.lastAccessTimestamp ? -1 : 1;
+    return lhs.lastTouchTimestamp < rhs.lastTouchTimestamp ? -1 : 1;
   }
 
   private void evictCache(Cache cache, long requiredSpace) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java
index b0c8c7e087..da89dc1cb3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java
@@ -24,6 +24,11 @@
  */
 public final class NoOpCacheEvictor implements CacheEvictor {
 
+  @Override
+  public boolean requiresCacheSpanTouches() {
+    return false;
+  }
+
   @Override
   public void onCacheInitialized() {
     // Do nothing.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index ab60be2b4b..b31d3b66f3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -16,37 +16,66 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.os.ConditionVariable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.database.DatabaseIOException;
+import com.google.android.exoplayer2.database.DatabaseProvider;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
+import java.io.IOException;
+import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.NavigableSet;
+import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
- * A {@link Cache} implementation that maintains an in-memory representation. Note, only one
- * instance of SimpleCache is allowed for a given directory at a given time.
+ * A {@link Cache} implementation that maintains an in-memory representation.
+ *
+ * <p>Only one instance of SimpleCache is allowed for a given directory at a given time.
+ *
+ * <p>To delete a SimpleCache, use {@link #delete(File, DatabaseProvider)} rather than deleting the
+ * directory and its contents directly. This is necessary to ensure that associated index data is
+ * also removed.
  */
 public final class SimpleCache implements Cache {
 
   private static final String TAG = "SimpleCache";
+  /**
+   * Cache files are distributed between a number of subdirectories. This helps to avoid poor
+   * performance in cases where the performance of the underlying file system (e.g. FAT32) scales
+   * badly with the number of files per directory. See
+   * https://github.com/google/ExoPlayer/issues/4253.
+   */
+  private static final int SUBDIRECTORY_COUNT = 10;
+
+  private static final String UID_FILE_SUFFIX = ".uid";
+
   private static final HashSet<File> lockedCacheDirs = new HashSet<>();
 
   private static boolean cacheFolderLockingDisabled;
+  private static boolean cacheInitializationExceptionsDisabled;
 
   private final File cacheDir;
   private final CacheEvictor evictor;
-  private final CachedContentIndex index;
+  private final CachedContentIndex contentIndex;
+  @Nullable private final CacheFileMetadataIndex fileIndex;
   private final HashMap<String, ArrayList<Listener>> listeners;
+  private final Random random;
+  private final boolean touchCacheSpans;
 
+  private long uid;
   private long totalSpace;
   private boolean released;
+  @MonotonicNonNull private CacheException initializationException;
 
   /**
    * Returns whether {@code cacheFolder} is locked by a {@link SimpleCache} instance. To unlock the
@@ -73,13 +102,65 @@ public static synchronized void disableCacheFolderLocking() {
     lockedCacheDirs.clear();
   }
 
+  /**
+   * Disables throwing of cache initialization exceptions.
+   *
+   * @deprecated Don't use this. Provided for problematic upgrade cases only.
+   */
+  @Deprecated
+  public static void disableCacheInitializationExceptions() {
+    cacheInitializationExceptionsDisabled = true;
+  }
+
+  /**
+   * Deletes all content belonging to a cache instance.
+   *
+   * @param cacheDir The cache directory.
+   * @param databaseProvider The database in which index data is stored, or {@code null} if the
+   *     cache used a legacy index.
+   */
+  public static void delete(File cacheDir, @Nullable DatabaseProvider databaseProvider) {
+    if (!cacheDir.exists()) {
+      return;
+    }
+
+    File[] files = cacheDir.listFiles();
+    if (files == null) {
+      cacheDir.delete();
+      return;
+    }
+
+    if (databaseProvider != null) {
+      // Make a best effort to read the cache UID and delete associated index data before deleting
+      // cache directory itself.
+      long uid = loadUid(files);
+      if (uid != UID_UNSET) {
+        try {
+          CacheFileMetadataIndex.delete(databaseProvider, uid);
+        } catch (DatabaseIOException e) {
+          Log.w(TAG, "Failed to delete file metadata: " + uid);
+        }
+        try {
+          CachedContentIndex.delete(databaseProvider, uid);
+        } catch (DatabaseIOException e) {
+          Log.w(TAG, "Failed to delete file metadata: " + uid);
+        }
+      }
+    }
+
+    Util.recursiveDelete(cacheDir);
+  }
+
   /**
    * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
    * the directory cannot be used to store other files.
    *
    * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
+   * @param evictor The evictor to be used. For download use cases where cache eviction should not
+   *     occur, use {@link NoOpCacheEvictor}.
+   * @deprecated Use a constructor that takes a {@link DatabaseProvider} for improved performance.
    */
+  @Deprecated
   public SimpleCache(File cacheDir, CacheEvictor evictor) {
     this(cacheDir, evictor, null, false);
   }
@@ -89,11 +170,14 @@ public SimpleCache(File cacheDir, CacheEvictor evictor) {
    * the directory cannot be used to store other files.
    *
    * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
+   * @param evictor The evictor to be used. For download use cases where cache eviction should not
+   *     occur, use {@link NoOpCacheEvictor}.
    * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
    *     The key must be 16 bytes long.
+   * @deprecated Use a constructor that takes a {@link DatabaseProvider} for improved performance.
    */
-  public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey) {
+  @Deprecated
+  public SimpleCache(File cacheDir, CacheEvictor evictor, @Nullable byte[] secretKey) {
     this(cacheDir, evictor, secretKey, secretKey != null);
   }
 
@@ -102,14 +186,24 @@ public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey) {
    * the directory cannot be used to store other files.
    *
    * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
+   * @param evictor The evictor to be used. For download use cases where cache eviction should not
+   *     occur, use {@link NoOpCacheEvictor}.
    * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
    *     The key must be 16 bytes long.
    * @param encrypt Whether the index will be encrypted when written. Must be false if {@code
    *     secretKey} is null.
+   * @deprecated Use a constructor that takes a {@link DatabaseProvider} for improved performance.
    */
-  public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey, boolean encrypt) {
-    this(cacheDir, evictor, new CachedContentIndex(cacheDir, secretKey, encrypt));
+  @Deprecated
+  public SimpleCache(
+      File cacheDir, CacheEvictor evictor, @Nullable byte[] secretKey, boolean encrypt) {
+    this(
+        cacheDir,
+        evictor,
+        /* databaseProvider= */ null,
+        secretKey,
+        encrypt,
+        /* preferLegacyIndex= */ true);
   }
 
   /**
@@ -117,18 +211,77 @@ public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey, boolea
    * the directory cannot be used to store other files.
    *
    * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
-   * @param index The CachedContentIndex to be used.
+   * @param evictor The evictor to be used. For download use cases where cache eviction should not
+   *     occur, use {@link NoOpCacheEvictor}.
+   * @param databaseProvider Provides the database in which the cache index is stored.
+   */
+  public SimpleCache(File cacheDir, CacheEvictor evictor, DatabaseProvider databaseProvider) {
+    this(
+        cacheDir,
+        evictor,
+        databaseProvider,
+        /* legacyIndexSecretKey= */ null,
+        /* legacyIndexEncrypt= */ false,
+        /* preferLegacyIndex= */ false);
+  }
+
+  /**
+   * Constructs the cache. The cache will delete any unrecognized files from the cache directory.
+   * Hence the directory cannot be used to store other files.
+   *
+   * @param cacheDir A dedicated cache directory.
+   * @param evictor The evictor to be used. For download use cases where cache eviction should not
+   *     occur, use {@link NoOpCacheEvictor}.
+   * @param databaseProvider Provides the database in which the cache index is stored, or {@code
+   *     null} to use a legacy index. Using a database index is highly recommended for performance
+   *     reasons.
+   * @param legacyIndexSecretKey A 16 byte AES key for reading, and optionally writing, the legacy
+   *     index. Not used by the database index, however should still be provided when using the
+   *     database index in cases where upgrading from the legacy index may be necessary.
+   * @param legacyIndexEncrypt Whether to encrypt when writing to the legacy index. Must be {@code
+   *     false} if {@code legacyIndexSecretKey} is {@code null}. Not used by the database index.
+   * @param preferLegacyIndex Whether to use the legacy index even if a {@code databaseProvider} is
+   *     provided. Should be {@code false} in nearly all cases. Setting this to {@code true} is only
+   *     useful for downgrading from the database index back to the legacy index.
    */
-  /*package*/ SimpleCache(File cacheDir, CacheEvictor evictor, CachedContentIndex index) {
+  public SimpleCache(
+      File cacheDir,
+      CacheEvictor evictor,
+      @Nullable DatabaseProvider databaseProvider,
+      @Nullable byte[] legacyIndexSecretKey,
+      boolean legacyIndexEncrypt,
+      boolean preferLegacyIndex) {
+    this(
+        cacheDir,
+        evictor,
+        new CachedContentIndex(
+            databaseProvider,
+            cacheDir,
+            legacyIndexSecretKey,
+            legacyIndexEncrypt,
+            preferLegacyIndex),
+        databaseProvider != null && !preferLegacyIndex
+            ? new CacheFileMetadataIndex(databaseProvider)
+            : null);
+  }
+
+  /* package */ SimpleCache(
+      File cacheDir,
+      CacheEvictor evictor,
+      CachedContentIndex contentIndex,
+      @Nullable CacheFileMetadataIndex fileIndex) {
     if (!lockFolder(cacheDir)) {
       throw new IllegalStateException("Another SimpleCache instance uses the folder: " + cacheDir);
     }
 
     this.cacheDir = cacheDir;
     this.evictor = evictor;
-    this.index = index;
-    this.listeners = new HashMap<>();
+    this.contentIndex = contentIndex;
+    this.fileIndex = fileIndex;
+    listeners = new HashMap<>();
+    random = new Random();
+    touchCacheSpans = evictor.requiresCacheSpanTouches();
+    uid = UID_UNSET;
 
     // Start cache initialization.
     final ConditionVariable conditionVariable = new ConditionVariable();
@@ -145,6 +298,22 @@ public void run() {
     conditionVariable.block();
   }
 
+  /**
+   * Checks whether the cache was initialized successfully.
+   *
+   * @throws CacheException If an error occurred during initialization.
+   */
+  public synchronized void checkInitialization() throws CacheException {
+    if (!cacheInitializationExceptionsDisabled && initializationException != null) {
+      throw initializationException;
+    }
+  }
+
+  @Override
+  public synchronized long getUid() {
+    return uid;
+  }
+
   @Override
   public synchronized void release() {
     if (released) {
@@ -153,8 +322,8 @@ public synchronized void release() {
     listeners.clear();
     removeStaleSpans();
     try {
-      index.store();
-    } catch (CacheException e) {
+      contentIndex.store();
+    } catch (IOException e) {
       Log.e(TAG, "Storing index file failed", e);
     } finally {
       unlockFolder(cacheDir);
@@ -192,7 +361,7 @@ public synchronized void removeListener(String key, Listener listener) {
   @Override
   public synchronized NavigableSet<CacheSpan> getCachedSpans(String key) {
     Assertions.checkState(!released);
-    CachedContent cachedContent = index.get(key);
+    CachedContent cachedContent = contentIndex.get(key);
     return cachedContent == null || cachedContent.isEmpty()
         ? new TreeSet<>()
         : new TreeSet<CacheSpan>(cachedContent.getSpans());
@@ -201,7 +370,7 @@ public synchronized void removeListener(String key, Listener listener) {
   @Override
   public synchronized Set<String> getKeys() {
     Assertions.checkState(!released);
-    return new HashSet<>(index.getKeys());
+    return new HashSet<>(contentIndex.getKeys());
   }
 
   @Override
@@ -213,6 +382,9 @@ public synchronized long getCacheSpace() {
   @Override
   public synchronized SimpleCacheSpan startReadWrite(String key, long position)
       throws InterruptedException, CacheException {
+    Assertions.checkState(!released);
+    checkInitialization();
+
     while (true) {
       SimpleCacheSpan span = startReadWriteNonBlocking(key, position);
       if (span != null) {
@@ -228,30 +400,45 @@ public synchronized SimpleCacheSpan startReadWrite(String key, long position)
   }
 
   @Override
-  public synchronized @Nullable SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
+  @Nullable
+  public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
       throws CacheException {
     Assertions.checkState(!released);
-    SimpleCacheSpan cacheSpan = getSpan(key, position);
+    checkInitialization();
+
+    SimpleCacheSpan span = getSpan(key, position);
 
     // Read case.
-    if (cacheSpan.isCached) {
-      try {
-        // Obtain a new span with updated last access timestamp.
-        SimpleCacheSpan newCacheSpan = index.get(key).touch(cacheSpan);
-        notifySpanTouched(cacheSpan, newCacheSpan);
-        return newCacheSpan;
-      } catch (CacheException e) {
-        // Ignore. In worst case the cache span is evicted early.
-        // This happens very rarely [Internal: b/38351639]
-        return cacheSpan;
+    if (span.isCached) {
+      if (!touchCacheSpans) {
+        return span;
       }
+      String fileName = Assertions.checkNotNull(span.file).getName();
+      long length = span.length;
+      long lastTouchTimestamp = System.currentTimeMillis();
+      boolean updateFile = false;
+      if (fileIndex != null) {
+        try {
+          fileIndex.set(fileName, length, lastTouchTimestamp);
+        } catch (IOException e) {
+          Log.w(TAG, "Failed to update index with new touch timestamp.");
+        }
+      } else {
+        // Updating the file itself to incorporate the new last touch timestamp is much slower than
+        // updating the file index. Hence we only update the file if we don't have a file index.
+        updateFile = true;
+      }
+      SimpleCacheSpan newSpan =
+          contentIndex.get(key).setLastTouchTimestamp(span, lastTouchTimestamp, updateFile);
+      notifySpanTouched(span, newSpan);
+      return newSpan;
     }
 
-    CachedContent cachedContent = index.getOrAdd(key);
+    CachedContent cachedContent = contentIndex.getOrAdd(key);
     if (!cachedContent.isLocked()) {
       // Write case, lock available.
       cachedContent.setLocked(true);
-      return cacheSpan;
+      return span;
     }
 
     // Write case, lock not available.
@@ -259,10 +446,11 @@ public synchronized SimpleCacheSpan startReadWrite(String key, long position)
   }
 
   @Override
-  public synchronized File startFile(String key, long position, long maxLength)
-      throws CacheException {
+  public synchronized File startFile(String key, long position, long length) throws CacheException {
     Assertions.checkState(!released);
-    CachedContent cachedContent = index.get(key);
+    checkInitialization();
+
+    CachedContent cachedContent = contentIndex.get(key);
     Assertions.checkNotNull(cachedContent);
     Assertions.checkState(cachedContent.isLocked());
     if (!cacheDir.exists()) {
@@ -270,46 +458,63 @@ public synchronized File startFile(String key, long position, long maxLength)
       cacheDir.mkdirs();
       removeStaleSpans();
     }
-    evictor.onStartFile(this, key, position, maxLength);
-    return SimpleCacheSpan.getCacheFile(
-        cacheDir, cachedContent.id, position, System.currentTimeMillis());
+    evictor.onStartFile(this, key, position, length);
+    // Randomly distribute files into subdirectories with a uniform distribution.
+    File fileDir = new File(cacheDir, Integer.toString(random.nextInt(SUBDIRECTORY_COUNT)));
+    if (!fileDir.exists()) {
+      fileDir.mkdir();
+    }
+    long lastTouchTimestamp = System.currentTimeMillis();
+    return SimpleCacheSpan.getCacheFile(fileDir, cachedContent.id, position, lastTouchTimestamp);
   }
 
   @Override
-  public synchronized void commitFile(File file) throws CacheException {
+  public synchronized void commitFile(File file, long length) throws CacheException {
     Assertions.checkState(!released);
-    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(file, index);
-    Assertions.checkState(span != null);
-    CachedContent cachedContent = index.get(span.key);
-    Assertions.checkNotNull(cachedContent);
-    Assertions.checkState(cachedContent.isLocked());
-    // If the file doesn't exist, don't add it to the in-memory representation.
     if (!file.exists()) {
       return;
     }
-    // If the file has length 0, delete it and don't add it to the in-memory representation.
-    if (file.length() == 0) {
+    if (length == 0) {
       file.delete();
       return;
     }
+
+    SimpleCacheSpan span =
+        Assertions.checkNotNull(SimpleCacheSpan.createCacheEntry(file, length, contentIndex));
+    CachedContent cachedContent = Assertions.checkNotNull(contentIndex.get(span.key));
+    Assertions.checkState(cachedContent.isLocked());
+
     // Check if the span conflicts with the set content length
-    long length = ContentMetadataInternal.getContentLength(cachedContent.getMetadata());
-    if (length != C.LENGTH_UNSET) {
-      Assertions.checkState((span.position + span.length) <= length);
+    long contentLength = ContentMetadata.getContentLength(cachedContent.getMetadata());
+    if (contentLength != C.LENGTH_UNSET) {
+      Assertions.checkState((span.position + span.length) <= contentLength);
+    }
+
+    if (fileIndex != null) {
+      String fileName = file.getName();
+      try {
+        fileIndex.set(fileName, span.length, span.lastTouchTimestamp);
+      } catch (IOException e) {
+        throw new CacheException(e);
+      }
     }
     addSpan(span);
-    index.store();
+    try {
+      contentIndex.store();
+    } catch (IOException e) {
+      throw new CacheException(e);
+    }
     notifyAll();
   }
 
   @Override
   public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
     Assertions.checkState(!released);
-    CachedContent cachedContent = index.get(holeSpan.key);
+    CachedContent cachedContent = contentIndex.get(holeSpan.key);
     Assertions.checkNotNull(cachedContent);
     Assertions.checkState(cachedContent.isLocked());
     cachedContent.setLocked(false);
-    index.maybeRemove(cachedContent.key);
+    contentIndex.maybeRemove(cachedContent.key);
     notifyAll();
   }
 
@@ -322,41 +527,35 @@ public synchronized void removeSpan(CacheSpan span) {
   @Override
   public synchronized boolean isCached(String key, long position, long length) {
     Assertions.checkState(!released);
-    CachedContent cachedContent = index.get(key);
+    CachedContent cachedContent = contentIndex.get(key);
     return cachedContent != null && cachedContent.getCachedBytesLength(position, length) >= length;
   }
 
   @Override
   public synchronized long getCachedLength(String key, long position, long length) {
     Assertions.checkState(!released);
-    CachedContent cachedContent = index.get(key);
+    CachedContent cachedContent = contentIndex.get(key);
     return cachedContent != null ? cachedContent.getCachedBytesLength(position, length) : -length;
   }
 
-  @Override
-  public synchronized void setContentLength(String key, long length) throws CacheException {
-    ContentMetadataMutations mutations = new ContentMetadataMutations();
-    ContentMetadataInternal.setContentLength(mutations, length);
-    applyContentMetadataMutations(key, mutations);
-  }
-
-  @Override
-  public synchronized long getContentLength(String key) {
-    return ContentMetadataInternal.getContentLength(getContentMetadata(key));
-  }
-
   @Override
   public synchronized void applyContentMetadataMutations(
       String key, ContentMetadataMutations mutations) throws CacheException {
     Assertions.checkState(!released);
-    index.applyContentMetadataMutations(key, mutations);
-    index.store();
+    checkInitialization();
+
+    contentIndex.applyContentMetadataMutations(key, mutations);
+    try {
+      contentIndex.store();
+    } catch (IOException e) {
+      throw new CacheException(e);
+    }
   }
 
   @Override
   public synchronized ContentMetadata getContentMetadata(String key) {
     Assertions.checkState(!released);
-    return index.getContentMetadata(key);
+    return contentIndex.getContentMetadata(key);
   }
 
   /**
@@ -372,8 +571,8 @@ public synchronized ContentMetadata getContentMetadata(String key) {
    * @param position The position of the span being requested.
    * @return The corresponding cache {@link SimpleCacheSpan}.
    */
-  private SimpleCacheSpan getSpan(String key, long position) throws CacheException {
-    CachedContent cachedContent = index.get(key);
+  private SimpleCacheSpan getSpan(String key, long position) {
+    CachedContent cachedContent = contentIndex.get(key);
     if (cachedContent == null) {
       return SimpleCacheSpan.createOpenHole(key, position);
     }
@@ -392,55 +591,139 @@ private SimpleCacheSpan getSpan(String key, long position) throws CacheException
   /** Ensures that the cache's in-memory representation has been initialized. */
   private void initialize() {
     if (!cacheDir.exists()) {
-      cacheDir.mkdirs();
-      return;
+      if (!cacheDir.mkdirs()) {
+        String message = "Failed to create cache directory: " + cacheDir;
+        Log.e(TAG, message);
+        initializationException = new CacheException(message);
+        return;
+      }
     }
 
-    index.load();
-
     File[] files = cacheDir.listFiles();
     if (files == null) {
+      String message = "Failed to list cache directory files: " + cacheDir;
+      Log.e(TAG, message);
+      initializationException = new CacheException(message);
       return;
     }
-    for (File file : files) {
-      if (file.getName().equals(CachedContentIndex.FILE_NAME)) {
-        continue;
+
+    uid = loadUid(files);
+    if (uid == UID_UNSET) {
+      try {
+        uid = createUid(cacheDir);
+      } catch (IOException e) {
+        String message = "Failed to create cache UID: " + cacheDir;
+        Log.e(TAG, message, e);
+        initializationException = new CacheException(message, e);
+        return;
       }
-      SimpleCacheSpan span =
-          file.length() > 0 ? SimpleCacheSpan.createCacheEntry(file, index) : null;
-      if (span != null) {
-        addSpan(span);
+    }
+
+    try {
+      contentIndex.initialize(uid);
+      if (fileIndex != null) {
+        fileIndex.initialize(uid);
+        Map<String, CacheFileMetadata> fileMetadata = fileIndex.getAll();
+        loadDirectory(cacheDir, /* isRoot= */ true, files, fileMetadata);
+        fileIndex.removeAll(fileMetadata.keySet());
       } else {
-        file.delete();
+        loadDirectory(cacheDir, /* isRoot= */ true, files, /* fileMetadata= */ null);
       }
+    } catch (IOException e) {
+      String message = "Failed to initialize cache indices: " + cacheDir;
+      Log.e(TAG, message, e);
+      initializationException = new CacheException(message, e);
+      return;
     }
 
-    index.removeEmpty();
+    contentIndex.removeEmpty();
     try {
-      index.store();
-    } catch (CacheException e) {
+      contentIndex.store();
+    } catch (IOException e) {
       Log.e(TAG, "Storing index file failed", e);
     }
   }
 
+  /**
+   * Loads a cache directory. If the root directory is passed, also loads any subdirectories.
+   *
+   * @param directory The directory.
+   * @param isRoot Whether the directory is the root directory.
+   * @param files The files belonging to the directory.
+   * @param fileMetadata A mutable map containing cache file metadata, keyed by file name. The map
+   *     is modified by removing entries for all loaded files. When the method call returns, the map
+   *     will contain only metadata that was unused. May be null if no file metadata is available.
+   */
+  private void loadDirectory(
+      File directory,
+      boolean isRoot,
+      @Nullable File[] files,
+      @Nullable Map<String, CacheFileMetadata> fileMetadata) {
+    if (files == null || files.length == 0) {
+      // Either (a) directory isn't really a directory (b) it's empty, or (c) listing files failed.
+      if (!isRoot) {
+        // For (a) and (b) deletion is the desired result. For (c) it will be a no-op if the
+        // directory is non-empty, so there's no harm in trying.
+        directory.delete();
+      }
+      return;
+    }
+    for (File file : files) {
+      String fileName = file.getName();
+      if (isRoot && fileName.indexOf('.') == -1) {
+        loadDirectory(file, /* isRoot= */ false, file.listFiles(), fileMetadata);
+      } else {
+        if (isRoot
+            && (CachedContentIndex.isIndexFile(fileName) || fileName.endsWith(UID_FILE_SUFFIX))) {
+          // Skip expected UID and index files in the root directory.
+          continue;
+        }
+        long length = C.LENGTH_UNSET;
+        long lastTouchTimestamp = C.TIME_UNSET;
+        CacheFileMetadata metadata = fileMetadata != null ? fileMetadata.remove(fileName) : null;
+        if (metadata != null) {
+          length = metadata.length;
+          lastTouchTimestamp = metadata.lastTouchTimestamp;
+        }
+        SimpleCacheSpan span =
+            SimpleCacheSpan.createCacheEntry(file, length, lastTouchTimestamp, contentIndex);
+        if (span != null) {
+          addSpan(span);
+        } else {
+          file.delete();
+        }
+      }
+    }
+  }
+
   /**
    * Adds a cached span to the in-memory representation.
    *
    * @param span The span to be added.
    */
   private void addSpan(SimpleCacheSpan span) {
-    index.getOrAdd(span.key).addSpan(span);
+    contentIndex.getOrAdd(span.key).addSpan(span);
     totalSpace += span.length;
     notifySpanAdded(span);
   }
 
   private void removeSpanInternal(CacheSpan span) {
-    CachedContent cachedContent = index.get(span.key);
+    CachedContent cachedContent = contentIndex.get(span.key);
     if (cachedContent == null || !cachedContent.removeSpan(span)) {
       return;
     }
     totalSpace -= span.length;
-    index.maybeRemove(cachedContent.key);
+    if (fileIndex != null) {
+      String fileName = span.file.getName();
+      try {
+        fileIndex.remove(fileName);
+      } catch (IOException e) {
+        // This will leave a stale entry in the file index. It will be removed next time the cache
+        // is initialized.
+        Log.w(TAG, "Failed to remove file index entry for: " + fileName);
+      }
+    }
+    contentIndex.maybeRemove(cachedContent.key);
     notifySpanRemoved(span);
   }
 
@@ -450,7 +733,7 @@ private void removeSpanInternal(CacheSpan span) {
    */
   private void removeStaleSpans() {
     ArrayList<CacheSpan> spansToBeRemoved = new ArrayList<>();
-    for (CachedContent cachedContent : index.getAll()) {
+    for (CachedContent cachedContent : contentIndex.getAll()) {
       for (CacheSpan span : cachedContent.getSpans()) {
         if (!span.file.exists()) {
           spansToBeRemoved.add(span);
@@ -492,6 +775,48 @@ private void notifySpanTouched(SimpleCacheSpan oldSpan, CacheSpan newSpan) {
     evictor.onSpanTouched(this, oldSpan, newSpan);
   }
 
+  /**
+   * Loads the cache UID from the files belonging to the root directory.
+   *
+   * @param files The files belonging to the root directory.
+   * @return The loaded UID, or {@link #UID_UNSET} if a UID has not yet been created.
+   * @throws IOException If there is an error loading or generating the UID.
+   */
+  private static long loadUid(File[] files) {
+    for (File file : files) {
+      String fileName = file.getName();
+      if (fileName.endsWith(UID_FILE_SUFFIX)) {
+        try {
+          return parseUid(fileName);
+        } catch (NumberFormatException e) {
+          // This should never happen, but if it does delete the malformed UID file and continue.
+          Log.e(TAG, "Malformed UID file: " + file);
+          file.delete();
+        }
+      }
+    }
+    return UID_UNSET;
+  }
+
+  @SuppressWarnings("TrulyRandom")
+  private static long createUid(File directory) throws IOException {
+    // Generate a non-negative UID.
+    long uid = new SecureRandom().nextLong();
+    uid = uid == Long.MIN_VALUE ? 0 : Math.abs(uid);
+    // Persist it as a file.
+    String hexUid = Long.toString(uid, /* radix= */ 16);
+    File hexUidFile = new File(directory, hexUid + UID_FILE_SUFFIX);
+    if (!hexUidFile.createNewFile()) {
+      // False means that the file already exists, so this should never happen.
+      throw new IOException("Failed to create UID file: " + hexUidFile);
+    }
+    return uid;
+  }
+
+  private static long parseUid(String fileName) {
+    return Long.parseLong(fileName.substring(0, fileName.indexOf('.')), /* radix= */ 16);
+  }
+
   private static synchronized boolean lockFolder(File cacheDir) {
     if (cacheFolderLockingDisabled) {
       return true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
index e12d876ce1..7d9f0c9ff1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -23,12 +23,12 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-/**
- * This class stores span metadata in filename.
- */
-/*package*/ final class SimpleCacheSpan extends CacheSpan {
+/** This class stores span metadata in filename. */
+/* package */ final class SimpleCacheSpan extends CacheSpan {
+
+  /* package */ static final String COMMON_SUFFIX = ".exo";
 
-  private static final String SUFFIX = ".v3.exo";
+  private static final String SUFFIX = ".v3" + COMMON_SUFFIX;
   private static final Pattern CACHE_FILE_PATTERN_V1 = Pattern.compile(
       "^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
   private static final Pattern CACHE_FILE_PATTERN_V2 = Pattern.compile(
@@ -38,16 +38,16 @@
 
   /**
    * Returns a new {@link File} instance from {@code cacheDir}, {@code id}, {@code position}, {@code
-   * lastAccessTimestamp}.
+   * timestamp}.
    *
    * @param cacheDir The parent abstract pathname.
    * @param id The cache file id.
    * @param position The position of the stored data in the original stream.
-   * @param lastAccessTimestamp The last access timestamp.
+   * @param timestamp The file timestamp.
    * @return The cache file.
    */
-  public static File getCacheFile(File cacheDir, int id, long position, long lastAccessTimestamp) {
-    return new File(cacheDir, id + "." + position + "." + lastAccessTimestamp + SUFFIX);
+  public static File getCacheFile(File cacheDir, int id, long position, long timestamp) {
+    return new File(cacheDir, id + "." + position + "." + timestamp + SUFFIX);
   }
 
   /**
@@ -88,12 +88,32 @@ public static SimpleCacheSpan createClosedHole(String key, long position, long l
    * Creates a cache span from an underlying cache file. Upgrades the file if necessary.
    *
    * @param file The cache file.
-   * @param index Cached content index.
+   * @param length The length of the cache file in bytes, or {@link C#LENGTH_UNSET} to query the
+   *     underlying file system. Querying the underlying file system can be expensive, so callers
+   *     that already know the length of the file should pass it explicitly.
+   * @return The span, or null if the file name is not correctly formatted, or if the id is not
+   *     present in the content index, or if the length is 0.
+   */
+  @Nullable
+  public static SimpleCacheSpan createCacheEntry(File file, long length, CachedContentIndex index) {
+    return createCacheEntry(file, length, /* lastTouchTimestamp= */ C.TIME_UNSET, index);
+  }
+
+  /**
+   * Creates a cache span from an underlying cache file. Upgrades the file if necessary.
+   *
+   * @param file The cache file.
+   * @param length The length of the cache file in bytes, or {@link C#LENGTH_UNSET} to query the
+   *     underlying file system. Querying the underlying file system can be expensive, so callers
+   *     that already know the length of the file should pass it explicitly.
+   * @param lastTouchTimestamp The last touch timestamp, or {@link C#TIME_UNSET} to use the file
+   *     timestamp.
    * @return The span, or null if the file name is not correctly formatted, or if the id is not
-   *     present in the content index.
+   *     present in the content index, or if the length is 0.
    */
   @Nullable
-  public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex index) {
+  public static SimpleCacheSpan createCacheEntry(
+      File file, long length, long lastTouchTimestamp, CachedContentIndex index) {
     String name = file.getName();
     if (!name.endsWith(SUFFIX)) {
       file = upgradeFile(file, index);
@@ -107,11 +127,25 @@ public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex ind
     if (!matcher.matches()) {
       return null;
     }
-    long length = file.length();
+
     int id = Integer.parseInt(matcher.group(1));
     String key = index.getKeyForId(id);
-    return key == null ? null : new SimpleCacheSpan(key, Long.parseLong(matcher.group(2)), length,
-        Long.parseLong(matcher.group(3)), file);
+    if (key == null) {
+      return null;
+    }
+
+    if (length == C.LENGTH_UNSET) {
+      length = file.length();
+    }
+    if (length == 0) {
+      return null;
+    }
+
+    long position = Long.parseLong(matcher.group(2));
+    if (lastTouchTimestamp == C.TIME_UNSET) {
+      lastTouchTimestamp = Long.parseLong(matcher.group(3));
+    }
+    return new SimpleCacheSpan(key, position, length, lastTouchTimestamp, file);
   }
 
   /**
@@ -153,28 +187,26 @@ private static File upgradeFile(File file, CachedContentIndex index) {
    * @param position The position of the {@link CacheSpan} in the original stream.
    * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
    *     open-ended hole.
-   * @param lastAccessTimestamp The last access timestamp, or {@link C#TIME_UNSET} if {@link
+   * @param lastTouchTimestamp The last touch timestamp, or {@link C#TIME_UNSET} if {@link
    *     #isCached} is false.
    * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
    */
   private SimpleCacheSpan(
-      String key, long position, long length, long lastAccessTimestamp, @Nullable File file) {
-    super(key, position, length, lastAccessTimestamp, file);
+      String key, long position, long length, long lastTouchTimestamp, @Nullable File file) {
+    super(key, position, length, lastTouchTimestamp, file);
   }
 
   /**
-   * Returns a copy of this CacheSpan whose last access time stamp is set to current time. This
-   * doesn't copy or change the underlying cache file.
+   * Returns a copy of this CacheSpan with a new file and last touch timestamp.
    *
-   * @param id The cache file id.
-   * @return A {@link SimpleCacheSpan} with updated last access time stamp.
+   * @param file The new file.
+   * @param lastTouchTimestamp The new last touch time.
+   * @return A copy with the new file and last touch timestamp.
    * @throws IllegalStateException If called on a non-cached span (i.e. {@link #isCached} is false).
    */
-  public SimpleCacheSpan copyWithUpdatedLastAccessTime(int id) {
+  public SimpleCacheSpan copyWithFileAndLastTouchTimestamp(File file, long lastTouchTimestamp) {
     Assertions.checkState(isCached);
-    long now = System.currentTimeMillis();
-    File newCacheFile = getCacheFile(file.getParentFile(), id, position, now);
-    return new SimpleCacheSpan(key, position, length, now, newCacheFile);
+    return new SimpleCacheSpan(key, position, length, lastTouchTimestamp, file);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
index 801c84dc51..7a7af6b8a4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream.crypto;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
index c6ad5dfe52..b4ccc5bcc4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.util;
 
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
index 4bdee5ceea..74e50dfd92 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -29,7 +29,7 @@
  * has successfully completed.
  *
  * <p>Atomic file guarantees file integrity by ensuring that a file has been completely written and
- * sync'd to disk before removing its backup. As long as the backup file exists, the original file
+ * synced to disk before removing its backup. As long as the backup file exists, the original file
  * is considered to be invalid (left over from a previous attempt to write the file).
  *
  * <p>Atomic file does not confer any file locking semantics. Do not use this class when the file
@@ -52,6 +52,11 @@ public AtomicFile(File baseName) {
     backupName = new File(baseName.getPath() + ".bak");
   }
 
+  /** Returns whether the file or its backup exists. */
+  public boolean exists() {
+    return baseName.exists() || backupName.exists();
+  }
+
   /** Delete the atomic file. This deletes both the base and backup files. */
   public void delete() {
     baseName.delete();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
index 36fc3b1bf8..7a87d7d9a3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
@@ -17,7 +17,7 @@
 
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * An interface through which system clocks can be read and {@link HandlerWrapper}s created. The
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
index 627cf7e070..16a891dbc6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
index deb981f0e8..33b50934f1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
@@ -24,8 +24,8 @@
 import android.opengl.EGLSurface;
 import android.opengl.GLES20;
 import android.os.Handler;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -307,9 +307,6 @@ private static EGLSurface createEGLSurface(
 
   private static void generateTextureIds(int[] textureIdHolder) {
     GLES20.glGenTextures(/* n= */ 1, textureIdHolder, /* offset= */ 0);
-    int errorCode = GLES20.glGetError();
-    if (errorCode != GLES20.GL_NO_ERROR) {
-      throw new GlException("glGenTextures failed. Error: " + Integer.toHexString(errorCode));
-    }
+    GlUtil.checkGlError();
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
index 25f3a0c100..bb3dc8b83a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.util;
 
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
similarity index 50%
rename from library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlUtil.java
rename to library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
index 8fd5d64e1c..7fc46dc363 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
@@ -13,25 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.ui.spherical;
+package com.google.android.exoplayer2.util;
 
 import static android.opengl.GLU.gluErrorString;
 
-import android.annotation.TargetApi;
 import android.opengl.GLES11Ext;
 import android.opengl.GLES20;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.util.Log;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 
 /** GL utility methods. */
-/*package*/ final class GlUtil {
-  private static final String TAG = "Spherical.Utils";
+public final class GlUtil {
+  private static final String TAG = "GlUtil";
 
   /** Class only contains static methods. */
   private GlUtil() {}
@@ -41,78 +39,80 @@ private GlUtil() {}
    * ExoPlayerLibraryInfo#GL_ASSERTIONS_ENABLED} is true throws a {@link RuntimeException}.
    */
   public static void checkGlError() {
-    int error = GLES20.glGetError();
-    int lastError;
-    if (error != GLES20.GL_NO_ERROR) {
-      do {
-        lastError = error;
-        Log.e(TAG, "glError " + gluErrorString(lastError));
-        error = GLES20.glGetError();
-      } while (error != GLES20.GL_NO_ERROR);
-
-      if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED) {
-        throw new RuntimeException("glError " + gluErrorString(lastError));
-      }
+    int lastError = GLES20.GL_NO_ERROR;
+    int error;
+    while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
+      Log.e(TAG, "glError " + gluErrorString(lastError));
+      lastError = error;
+    }
+    if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED && lastError != GLES20.GL_NO_ERROR) {
+      throw new RuntimeException("glError " + gluErrorString(lastError));
     }
   }
 
   /**
-   * Builds a GL shader program from vertex & fragment shader code. The vertex and fragment shaders
-   * are passed as arrays of strings in order to make debugging compilation issues easier.
+   * Builds a GL shader program from vertex and fragment shader code.
    *
-   * @param vertexCode GLES20 vertex shader program.
-   * @param fragmentCode GLES20 fragment shader program.
+   * @param vertexCode GLES20 vertex shader program as arrays of strings. Strings are joined by
+   *     adding a new line character in between each of them.
+   * @param fragmentCode GLES20 fragment shader program as arrays of strings. Strings are joined by
+   *     adding a new line character in between each of them.
    * @return GLES20 program id.
    */
   public static int compileProgram(String[] vertexCode, String[] fragmentCode) {
-    checkGlError();
-    // prepare shaders and OpenGL program
-    int vertexShader = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);
-    GLES20.glShaderSource(vertexShader, TextUtils.join("\n", vertexCode));
-    GLES20.glCompileShader(vertexShader);
-    checkGlError();
+    return compileProgram(TextUtils.join("\n", vertexCode), TextUtils.join("\n", fragmentCode));
+  }
 
-    int fragmentShader = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER);
-    GLES20.glShaderSource(fragmentShader, TextUtils.join("\n", fragmentCode));
-    GLES20.glCompileShader(fragmentShader);
+  /**
+   * Builds a GL shader program from vertex and fragment shader code.
+   *
+   * @param vertexCode GLES20 vertex shader program.
+   * @param fragmentCode GLES20 fragment shader program.
+   * @return GLES20 program id.
+   */
+  public static int compileProgram(String vertexCode, String fragmentCode) {
+    int program = GLES20.glCreateProgram();
     checkGlError();
 
-    int program = GLES20.glCreateProgram();
-    GLES20.glAttachShader(program, vertexShader);
-    GLES20.glAttachShader(program, fragmentShader);
+    // Add the vertex and fragment shaders.
+    addShader(GLES20.GL_VERTEX_SHADER, vertexCode, program);
+    addShader(GLES20.GL_FRAGMENT_SHADER, fragmentCode, program);
 
     // Link and check for errors.
     GLES20.glLinkProgram(program);
-    int[] linkStatus = new int[1];
+    int[] linkStatus = new int[] {GLES20.GL_FALSE};
     GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
     if (linkStatus[0] != GLES20.GL_TRUE) {
-      String errorMsg = "Unable to link shader program: \n" + GLES20.glGetProgramInfoLog(program);
-      Log.e(TAG, errorMsg);
-      if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED) {
-        throw new RuntimeException(errorMsg);
-      }
+      throwGlError("Unable to link shader program: \n" + GLES20.glGetProgramInfoLog(program));
     }
     checkGlError();
 
     return program;
   }
 
-  /** Allocates a FloatBuffer with the given data. */
+  /**
+   * Allocates a FloatBuffer with the given data.
+   *
+   * @param data Used to initialize the new buffer.
+   */
   public static FloatBuffer createBuffer(float[] data) {
-    ByteBuffer bb = ByteBuffer.allocateDirect(data.length * C.BYTES_PER_FLOAT);
-    bb.order(ByteOrder.nativeOrder());
-    FloatBuffer buffer = bb.asFloatBuffer();
-    buffer.put(data);
-    buffer.position(0);
+    return (FloatBuffer) createBuffer(data.length).put(data).flip();
+  }
 
-    return buffer;
+  /**
+   * Allocates a FloatBuffer.
+   *
+   * @param capacity The new buffer's capacity, in floats.
+   */
+  public static FloatBuffer createBuffer(int capacity) {
+    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(capacity * C.BYTES_PER_FLOAT);
+    return byteBuffer.order(ByteOrder.nativeOrder()).asFloatBuffer();
   }
 
   /**
    * Creates a GL_TEXTURE_EXTERNAL_OES with default configuration of GL_LINEAR filtering and
    * GL_CLAMP_TO_EDGE wrapping.
    */
-  @TargetApi(15)
   public static int createExternalTexture() {
     int[] texId = new int[1];
     GLES20.glGenTextures(1, IntBuffer.wrap(texId));
@@ -128,4 +128,27 @@ public static int createExternalTexture() {
     checkGlError();
     return texId[0];
   }
+
+  private static void addShader(int type, String source, int program) {
+    int shader = GLES20.glCreateShader(type);
+    GLES20.glShaderSource(shader, source);
+    GLES20.glCompileShader(shader);
+
+    int[] result = new int[] {GLES20.GL_FALSE};
+    GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, result, 0);
+    if (result[0] != GLES20.GL_TRUE) {
+      throwGlError(GLES20.glGetShaderInfoLog(shader) + ", source: " + source);
+    }
+
+    GLES20.glAttachShader(program, shader);
+    GLES20.glDeleteShader(shader);
+    checkGlError();
+  }
+
+  private static void throwGlError(String errorMsg) {
+    Log.e(TAG, errorMsg);
+    if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED) {
+      throw new RuntimeException(errorMsg);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/LibraryLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/util/LibraryLoader.java
index c12bae0a07..7ee88d8f0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/LibraryLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/LibraryLoader.java
@@ -15,11 +15,15 @@
  */
 package com.google.android.exoplayer2.util;
 
+import java.util.Arrays;
+
 /**
  * Configurable loader for native libraries.
  */
 public final class LibraryLoader {
 
+  private static final String TAG = "LibraryLoader";
+
   private String[] nativeLibraries;
   private boolean loadAttempted;
   private boolean isAvailable;
@@ -54,7 +58,9 @@ public synchronized boolean isAvailable() {
       }
       isAvailable = true;
     } catch (UnsatisfiedLinkError exception) {
-      // Do nothing.
+      // Log a warning as an attempt to check for the library indicates that the app depends on an
+      // extension and generally would expect its native libraries to be available.
+      Log.w(TAG, "Failed to load " + Arrays.toString(nativeLibraries));
     }
     return isAvailable;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
index 34fb684d25..1eb0977847 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -88,8 +88,7 @@ public static void d(String tag, String message) {
   public static void d(String tag, String message, @Nullable Throwable throwable) {
     if (!logStackTraces) {
       d(tag, appendThrowableMessage(message, throwable));
-    }
-    if (logLevel == LOG_LEVEL_ALL) {
+    } else if (logLevel == LOG_LEVEL_ALL) {
       android.util.Log.d(tag, message, throwable);
     }
   }
@@ -105,8 +104,7 @@ public static void i(String tag, String message) {
   public static void i(String tag, String message, @Nullable Throwable throwable) {
     if (!logStackTraces) {
       i(tag, appendThrowableMessage(message, throwable));
-    }
-    if (logLevel <= LOG_LEVEL_INFO) {
+    } else if (logLevel <= LOG_LEVEL_INFO) {
       android.util.Log.i(tag, message, throwable);
     }
   }
@@ -122,8 +120,7 @@ public static void w(String tag, String message) {
   public static void w(String tag, String message, @Nullable Throwable throwable) {
     if (!logStackTraces) {
       w(tag, appendThrowableMessage(message, throwable));
-    }
-    if (logLevel <= LOG_LEVEL_WARNING) {
+    } else if (logLevel <= LOG_LEVEL_WARNING) {
       android.util.Log.w(tag, message, throwable);
     }
   }
@@ -139,8 +136,7 @@ public static void e(String tag, String message) {
   public static void e(String tag, String message, @Nullable Throwable throwable) {
     if (!logStackTraces) {
       e(tag, appendThrowableMessage(message, throwable));
-    }
-    if (logLevel <= LOG_LEVEL_ERROR) {
+    } else if (logLevel <= LOG_LEVEL_ERROR) {
       android.util.Log.e(tag, message, throwable);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index e506ae1b19..e603f76dbc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import java.util.ArrayList;
@@ -37,10 +37,13 @@
   public static final String VIDEO_H265 = BASE_TYPE_VIDEO + "/hevc";
   public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
   public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
+  public static final String VIDEO_AV1 = BASE_TYPE_VIDEO + "/av01";
   public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
   public static final String VIDEO_MPEG = BASE_TYPE_VIDEO + "/mpeg";
   public static final String VIDEO_MPEG2 = BASE_TYPE_VIDEO + "/mpeg2";
   public static final String VIDEO_VC1 = BASE_TYPE_VIDEO + "/wvc1";
+  public static final String VIDEO_DIVX = BASE_TYPE_VIDEO + "/divx";
+  public static final String VIDEO_DOLBY_VISION = BASE_TYPE_VIDEO + "/dolby-vision";
   public static final String VIDEO_UNKNOWN = BASE_TYPE_VIDEO + "/x-unknown";
 
   public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
@@ -55,6 +58,7 @@
   public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
   public static final String AUDIO_E_AC3 = BASE_TYPE_AUDIO + "/eac3";
   public static final String AUDIO_E_AC3_JOC = BASE_TYPE_AUDIO + "/eac3-joc";
+  public static final String AUDIO_AC4 = BASE_TYPE_AUDIO + "/ac4";
   public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
   public static final String AUDIO_DTS = BASE_TYPE_AUDIO + "/vnd.dts";
   public static final String AUDIO_DTS_HD = BASE_TYPE_AUDIO + "/vnd.dts.hd";
@@ -92,6 +96,7 @@
   public static final String APPLICATION_EMSG = BASE_TYPE_APPLICATION + "/x-emsg";
   public static final String APPLICATION_DVBSUBS = BASE_TYPE_APPLICATION + "/dvbsubs";
   public static final String APPLICATION_EXIF = BASE_TYPE_APPLICATION + "/x-exif";
+  public static final String APPLICATION_ICY = BASE_TYPE_APPLICATION + "/x-icy";
 
   private static final ArrayList<CustomMimeType> customMimeTypes = new ArrayList<>();
 
@@ -117,42 +122,22 @@ public static void registerCustomMimeType(String mimeType, String codecPrefix, i
     customMimeTypes.add(customMimeType);
   }
 
-  /**
-   * Whether the top-level type of {@code mimeType} is audio.
-   *
-   * @param mimeType The mimeType to test.
-   * @return Whether the top level type is audio.
-   */
+  /** Returns whether the given string is an audio mime type. */
   public static boolean isAudio(@Nullable String mimeType) {
     return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));
   }
 
-  /**
-   * Whether the top-level type of {@code mimeType} is video.
-   *
-   * @param mimeType The mimeType to test.
-   * @return Whether the top level type is video.
-   */
+  /** Returns whether the given string is a video mime type. */
   public static boolean isVideo(@Nullable String mimeType) {
     return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));
   }
 
-  /**
-   * Whether the top-level type of {@code mimeType} is text.
-   *
-   * @param mimeType The mimeType to test.
-   * @return Whether the top level type is text.
-   */
+  /** Returns whether the given string is a text mime type. */
   public static boolean isText(@Nullable String mimeType) {
     return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType));
   }
 
-  /**
-   * Whether the top-level type of {@code mimeType} is application.
-   *
-   * @param mimeType The mimeType to test.
-   * @return Whether the top level type is application.
-   */
+  /** Returns whether the given string is an application mime type. */
   public static boolean isApplication(@Nullable String mimeType) {
     return BASE_TYPE_APPLICATION.equals(getTopLevelType(mimeType));
   }
@@ -212,6 +197,13 @@ public static boolean isApplication(@Nullable String mimeType) {
       return MimeTypes.VIDEO_H264;
     } else if (codec.startsWith("hev1") || codec.startsWith("hvc1")) {
       return MimeTypes.VIDEO_H265;
+    } else if (codec.startsWith("dvav")
+        || codec.startsWith("dva1")
+        || codec.startsWith("dvhe")
+        || codec.startsWith("dvh1")) {
+      return MimeTypes.VIDEO_DOLBY_VISION;
+    } else if (codec.startsWith("av01")) {
+      return MimeTypes.VIDEO_AV1;
     } else if (codec.startsWith("vp9") || codec.startsWith("vp09")) {
       return MimeTypes.VIDEO_VP9;
     } else if (codec.startsWith("vp8") || codec.startsWith("vp08")) {
@@ -237,6 +229,8 @@ public static boolean isApplication(@Nullable String mimeType) {
       return MimeTypes.AUDIO_E_AC3;
     } else if (codec.startsWith("ec+3")) {
       return MimeTypes.AUDIO_E_AC3_JOC;
+    } else if (codec.startsWith("ac-4") || codec.startsWith("dac4")) {
+      return MimeTypes.AUDIO_AC4;
     } else if (codec.startsWith("dtsc") || codec.startsWith("dtse")) {
       return MimeTypes.AUDIO_DTS;
     } else if (codec.startsWith("dtsh") || codec.startsWith("dtsl")) {
@@ -301,6 +295,8 @@ public static String getMimeTypeFromMp4ObjectType(int objectType) {
         return MimeTypes.AUDIO_DTS_HD;
       case 0xAD:
         return MimeTypes.AUDIO_OPUS;
+      case 0xAE:
+        return MimeTypes.AUDIO_AC4;
       default:
         return null;
     }
@@ -354,6 +350,8 @@ public static int getTrackType(@Nullable String mimeType) {
       case MimeTypes.AUDIO_E_AC3:
       case MimeTypes.AUDIO_E_AC3_JOC:
         return C.ENCODING_E_AC3;
+      case MimeTypes.AUDIO_AC4:
+        return C.ENCODING_AC4;
       case MimeTypes.AUDIO_DTS:
         return C.ENCODING_DTS;
       case MimeTypes.AUDIO_DTS_HD:
@@ -376,10 +374,8 @@ public static int getTrackTypeOfCodec(String codec) {
   }
 
   /**
-   * Returns the top-level type of {@code mimeType}.
-   *
-   * @param mimeType The mimeType whose top-level type is required.
-   * @return The top-level type, or null if the mimeType is null.
+   * Returns the top-level type of {@code mimeType}, or null if {@code mimeType} is null or does not
+   * contain a forward slash character ({@code '/'}).
    */
   private static @Nullable String getTopLevelType(@Nullable String mimeType) {
     if (mimeType == null) {
@@ -387,7 +383,7 @@ public static int getTrackTypeOfCodec(String codec) {
     }
     int indexOfSlash = mimeType.indexOf('/');
     if (indexOfSlash == -1) {
-      throw new IllegalArgumentException("Invalid mime type: " + mimeType);
+      return null;
     }
     return mimeType.substring(0, indexOfSlash);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
index e45ab0952e..4cd03f566d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
@@ -21,14 +21,14 @@
 import android.app.NotificationManager;
 import android.content.Context;
 import android.content.Intent;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import android.support.annotation.StringRes;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringRes;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
-/** Utility methods for displaying {@link android.app.Notification}s. */
+/** Utility methods for displaying {@link Notification Notifications}. */
 @SuppressLint("InlinedApi")
 public final class NotificationUtil {
 
@@ -66,25 +66,25 @@
    * NotificationChannel} and {@link
    * NotificationManager#createNotificationChannel(NotificationChannel)} for details.
    *
-   * @param context A {@link Context} to retrieve {@link NotificationManager}.
-   * @param id The id of the channel. Must be unique per package. The value may be truncated if it
-   *     is too long.
-   * @param name A string resource identifier for the user visible name of the channel. You can
-   *     rename this channel when the system locale changes by listening for the {@link
-   *     Intent#ACTION_LOCALE_CHANGED} broadcast. The recommended maximum length is 40 characters;
-   *     the value may be truncated if it is too long.
+   * @param context A {@link Context}.
+   * @param id The id of the channel. Must be unique per package. The value may be truncated if it's
+   *     too long.
+   * @param nameResourceId A string resource identifier for the user visible name of the channel.
+   *     You can rename this channel when the system locale changes by listening for the {@link
+   *     Intent#ACTION_LOCALE_CHANGED} broadcast. The recommended maximum length is 40 characters.
+   *     The value may be truncated if it is too long.
    * @param importance The importance of the channel. This controls how interruptive notifications
    *     posted to this channel are. One of {@link #IMPORTANCE_UNSPECIFIED}, {@link
    *     #IMPORTANCE_NONE}, {@link #IMPORTANCE_MIN}, {@link #IMPORTANCE_LOW}, {@link
    *     #IMPORTANCE_DEFAULT} and {@link #IMPORTANCE_HIGH}.
    */
   public static void createNotificationChannel(
-      Context context, String id, @StringRes int name, @Importance int importance) {
+      Context context, String id, @StringRes int nameResourceId, @Importance int importance) {
     if (Util.SDK_INT >= 26) {
       NotificationManager notificationManager =
           (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
       NotificationChannel channel =
-          new NotificationChannel(id, context.getString(name), importance);
+          new NotificationChannel(id, context.getString(nameResourceId), importance);
       notificationManager.createNotificationChannel(channel);
     }
   }
@@ -92,13 +92,13 @@ public static void createNotificationChannel(
   /**
    * Post a notification to be shown in the status bar. If a notification with the same id has
    * already been posted by your application and has not yet been canceled, it will be replaced by
-   * the updated information. If {@code notification} is null, then cancels a previously shown
-   * notification.
+   * the updated information. If {@code notification} is {@code null} then any notification
+   * previously shown with the specified id will be cancelled.
    *
-   * @param context A {@link Context} to retrieve {@link NotificationManager}.
-   * @param id An identifier for this notification unique within your application.
-   * @param notification A {@link Notification} object describing what to show the user. If null,
-   *     then cancels a previously shown notification.
+   * @param context A {@link Context}.
+   * @param id The notification id.
+   * @param notification The {@link Notification} to post, or {@code null} to cancel a previously
+   *     shown notification.
    */
   public static void setNotification(Context context, int id, @Nullable Notification notification) {
     NotificationManager notificationManager =
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index b928ffc02b..0c5116624e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
index cc23c9763c..3485877bc4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.Player;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
index f9be1a53b2..c9c21023c3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
@@ -65,6 +65,14 @@ public SlidingPercentile(int maxWeight) {
     currentSortOrder = SORT_ORDER_NONE;
   }
 
+  /** Resets the sliding percentile. */
+  public void reset() {
+    samples.clear();
+    currentSortOrder = SORT_ORDER_NONE;
+    nextSampleIndex = 0;
+    totalWeight = 0;
+  }
+
   /**
    * Adds a new weighted value.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
index 72d3df46e1..be526595c6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
@@ -18,7 +18,7 @@
 import android.os.Handler;
 import android.os.Handler.Callback;
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * The standard implementation of {@link Clock}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java
index 3fe3c56c15..3ac76eb54c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/TimedValueQueue.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.util.Arrays;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index f7c045dbb0..97bcb68708 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -15,16 +15,21 @@
  */
 package com.google.android.exoplayer2.util;
 
+import static android.content.Context.UI_MODE_SERVICE;
+
 import android.Manifest.permission;
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
+import android.app.UiModeManager;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Configuration;
+import android.content.res.Resources;
 import android.graphics.Point;
 import android.media.AudioFormat;
 import android.net.ConnectivityManager;
@@ -35,7 +40,7 @@
 import android.os.Looper;
 import android.os.Parcel;
 import android.security.NetworkSecurityPolicy;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.view.Display;
@@ -44,8 +49,15 @@
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.File;
@@ -151,6 +163,7 @@ private Util() {}
    * @param intent The intent to pass to the called method.
    * @return The result of the called method.
    */
+  @Nullable
   public static ComponentName startForegroundService(Context context, Intent intent) {
     if (Util.SDK_INT >= 26) {
       return context.startForegroundService(intent);
@@ -173,7 +186,7 @@ public static boolean maybeRequestReadExternalStoragePermission(Activity activit
       return false;
     }
     for (Uri uri : uris) {
-      if (Util.isLocalFileUri(uri)) {
+      if (isLocalFileUri(uri)) {
         if (activity.checkSelfPermission(permission.READ_EXTERNAL_STORAGE)
             != PackageManager.PERMISSION_GRANTED) {
           activity.requestPermissions(new String[] {permission.READ_EXTERNAL_STORAGE}, 0);
@@ -200,7 +213,8 @@ public static boolean checkCleartextTrafficPermitted(Uri... uris) {
     }
     for (Uri uri : uris) {
       if ("http".equals(uri.getScheme())
-          && !NetworkSecurityPolicy.getInstance().isCleartextTrafficPermitted(uri.getHost())) {
+          && !NetworkSecurityPolicy.getInstance()
+              .isCleartextTrafficPermitted(Assertions.checkNotNull(uri.getHost()))) {
         // The security policy prevents cleartext traffic.
         return false;
       }
@@ -242,7 +256,7 @@ public static boolean areEqual(@Nullable Object o1, @Nullable Object o2) {
    */
   public static boolean contains(Object[] items, Object item) {
     for (Object arrayItem : items) {
-      if (Util.areEqual(arrayItem, item)) {
+      if (areEqual(arrayItem, item)) {
         return true;
       }
     }
@@ -301,6 +315,25 @@ public static boolean contains(Object[] items, Object item) {
     return Arrays.copyOf(input, length);
   }
 
+  /**
+   * Concatenates two non-null type arrays.
+   *
+   * @param first The first array.
+   * @param second The second array.
+   * @return The concatenated result.
+   */
+  @SuppressWarnings({"nullness:assignment.type.incompatible"})
+  public static <T> T[] nullSafeArrayConcatenation(T[] first, T[] second) {
+    T[] concatenation = Arrays.copyOf(first, first.length + second.length);
+    System.arraycopy(
+        /* src= */ second,
+        /* srcPos= */ 0,
+        /* dest= */ concatenation,
+        /* destPos= */ first.length,
+        /* length= */ second.length);
+    return concatenation;
+  }
+
   /**
    * Creates a {@link Handler} with the specified {@link Handler.Callback} on the current {@link
    * Looper} thread. The method accepts partially initialized objects as callback under the
@@ -357,7 +390,7 @@ public static ExecutorService newSingleThreadExecutor(final String threadName) {
    *
    * @param dataSource The {@link DataSource} to close.
    */
-  public static void closeQuietly(DataSource dataSource) {
+  public static void closeQuietly(@Nullable DataSource dataSource) {
     try {
       if (dataSource != null) {
         dataSource.close();
@@ -373,7 +406,7 @@ public static void closeQuietly(DataSource dataSource) {
    *
    * @param closeable The {@link Closeable} to close.
    */
-  public static void closeQuietly(Closeable closeable) {
+  public static void closeQuietly(@Nullable Closeable closeable) {
     try {
       if (closeable != null) {
         closeable.close();
@@ -406,15 +439,26 @@ public static void writeBoolean(Parcel parcel, boolean value) {
   }
 
   /**
-   * Returns a normalized RFC 639-2/T code for {@code language}.
+   * Returns a normalized IETF BCP 47 language tag for {@code language}.
    *
-   * @param language A case-insensitive ISO 639 alpha-2 or alpha-3 language code.
+   * @param language A case-insensitive language code supported by {@link
+   *     Locale#forLanguageTag(String)}.
    * @return The all-lowercase normalized code, or null if the input was null, or {@code
    *     language.toLowerCase()} if the language could not be normalized.
    */
-  public static @Nullable String normalizeLanguageCode(@Nullable String language) {
+  public static @PolyNull String normalizeLanguageCode(@PolyNull String language) {
+    if (language == null) {
+      return null;
+    }
     try {
-      return language == null ? null : new Locale(language).getISO3Language();
+      Locale locale = getLocaleForLanguageTag(language);
+      int localeLanguageLength = locale.getLanguage().length();
+      String normLanguage = locale.getISO3Language();
+      if (normLanguage.isEmpty()) {
+        return toLowerInvariant(language);
+      }
+      String normTag = getLocaleLanguageTag(locale);
+      return toLowerInvariant(normLanguage + normTag.substring(localeLanguageLength));
     } catch (MissingResourceException e) {
       return toLowerInvariant(language);
     }
@@ -634,7 +678,7 @@ public static int binarySearchFloor(int[] array, int value, boolean inclusive,
     if (index < 0) {
       index = -(index + 2);
     } else {
-      while ((--index) >= 0 && array[index] == value) {}
+      while (--index >= 0 && array[index] == value) {}
       if (inclusive) {
         index++;
       }
@@ -666,7 +710,7 @@ public static int binarySearchFloor(long[] array, long value, boolean inclusive,
     if (index < 0) {
       index = -(index + 2);
     } else {
-      while ((--index) >= 0 && array[index] == value) {}
+      while (--index >= 0 && array[index] == value) {}
       if (inclusive) {
         index++;
       }
@@ -702,7 +746,7 @@ public static int binarySearchFloor(long[] array, long value, boolean inclusive,
     if (index < 0) {
       index = -(index + 2);
     } else {
-      while ((--index) >= 0 && list.get(index).compareTo(value) == 0) {}
+      while (--index >= 0 && list.get(index).compareTo(value) == 0) {}
       if (inclusive) {
         index++;
       }
@@ -710,6 +754,39 @@ public static int binarySearchFloor(long[] array, long value, boolean inclusive,
     return stayInBounds ? Math.max(0, index) : index;
   }
 
+  /**
+   * Returns the index of the smallest element in {@code array} that is greater than (or optionally
+   * equal to) a specified {@code value}.
+   *
+   * <p>The search is performed using a binary search algorithm, so the array must be sorted. If the
+   * array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the last one will be returned.
+   *
+   * @param array The array to search.
+   * @param value The value being searched for.
+   * @param inclusive If the value is present in the array, whether to return the corresponding
+   *     index. If false then the returned index corresponds to the smallest element strictly
+   *     greater than the value.
+   * @param stayInBounds If true, then {@code (a.length - 1)} will be returned in the case that the
+   *     value is greater than the largest element in the array. If false then {@code a.length} will
+   *     be returned.
+   * @return The index of the smallest element in {@code array} that is greater than (or optionally
+   *     equal to) {@code value}.
+   */
+  public static int binarySearchCeil(
+      int[] array, int value, boolean inclusive, boolean stayInBounds) {
+    int index = Arrays.binarySearch(array, value);
+    if (index < 0) {
+      index = ~index;
+    } else {
+      while (++index < array.length && array[index] == value) {}
+      if (inclusive) {
+        index--;
+      }
+    }
+    return stayInBounds ? Math.min(array.length - 1, index) : index;
+  }
+
   /**
    * Returns the index of the smallest element in {@code array} that is greater than (or optionally
    * equal to) a specified {@code value}.
@@ -735,7 +812,7 @@ public static int binarySearchCeil(
     if (index < 0) {
       index = ~index;
     } else {
-      while ((++index) < array.length && array[index] == value) {}
+      while (++index < array.length && array[index] == value) {}
       if (inclusive) {
         index--;
       }
@@ -773,7 +850,7 @@ public static int binarySearchCeil(
       index = ~index;
     } else {
       int listSize = list.size();
-      while ((++index) < listSize && list.get(index).compareTo(value) == 0) {}
+      while (++index < listSize && list.get(index).compareTo(value) == 0) {}
       if (inclusive) {
         index--;
       }
@@ -1352,7 +1429,7 @@ public static int getStreamTypeForAudioUsage(@C.AudioUsage int usage) {
    * @return The derived {@link UUID}, or {@code null} if one could not be derived.
    */
   public static @Nullable UUID getDrmUuid(String drmScheme) {
-    switch (Util.toLowerInvariant(drmScheme)) {
+    switch (toLowerInvariant(drmScheme)) {
       case "widevine":
         return C.WIDEVINE_UUID;
       case "playready":
@@ -1402,7 +1479,7 @@ public static int inferContentType(Uri uri) {
    */
   @C.ContentType
   public static int inferContentType(String fileName) {
-    fileName = Util.toLowerInvariant(fileName);
+    fileName = toLowerInvariant(fileName);
     if (fileName.endsWith(".mpd")) {
       return C.TYPE_DASH;
     } else if (fileName.endsWith(".m3u8")) {
@@ -1568,7 +1645,7 @@ private static boolean shouldEscapeCharacter(char c) {
    * and is not declared to be thrown.
    */
   public static void sneakyThrow(Throwable t) {
-    Util.sneakyThrowInternal(t);
+    sneakyThrowInternal(t);
   }
 
   @SuppressWarnings("unchecked")
@@ -1619,31 +1696,24 @@ public static int crc(byte[] bytes, int start, int end, int initialValue) {
   }
 
   /**
-   * Returns the {@link C.NetworkType} of the current network connection. {@link
-   * C#NETWORK_TYPE_UNKNOWN} will be returned if the {@code ACCESS_NETWORK_STATE} permission is not
-   * granted or the network connection type couldn't be determined.
+   * Returns the {@link C.NetworkType} of the current network connection.
    *
    * @param context A context to access the connectivity manager.
-   * @return The {@link C.NetworkType} of the current network connection, or {@link
-   *     C#NETWORK_TYPE_UNKNOWN} if the {@code ACCESS_NETWORK_STATE} permission is not granted or
-   *     {@code context} is null.
+   * @return The {@link C.NetworkType} of the current network connection.
    */
-  public static @C.NetworkType int getNetworkType(@Nullable Context context) {
+  @C.NetworkType
+  public static int getNetworkType(Context context) {
     if (context == null) {
+      // Note: This is for backward compatibility only (context used to be @Nullable).
       return C.NETWORK_TYPE_UNKNOWN;
     }
     NetworkInfo networkInfo;
-    try {
-      ConnectivityManager connectivityManager =
-          (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-      if (connectivityManager == null) {
-        return C.NETWORK_TYPE_UNKNOWN;
-      }
-      networkInfo = connectivityManager.getActiveNetworkInfo();
-    } catch (SecurityException e) {
-      // Permission ACCESS_NETWORK_STATE not granted.
+    ConnectivityManager connectivityManager =
+        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+    if (connectivityManager == null) {
       return C.NETWORK_TYPE_UNKNOWN;
     }
+    networkInfo = connectivityManager.getActiveNetworkInfo();
     if (networkInfo == null || !networkInfo.isConnected()) {
       return C.NETWORK_TYPE_OFFLINE;
     }
@@ -1658,7 +1728,7 @@ public static int crc(byte[] bytes, int start, int end, int initialValue) {
         return getMobileNetworkType(networkInfo);
       case ConnectivityManager.TYPE_ETHERNET:
         return C.NETWORK_TYPE_ETHERNET;
-      default: // Ethernet, VPN, Bluetooth, Dummy.
+      default: // VPN, Bluetooth, Dummy.
         return C.NETWORK_TYPE_OTHER;
     }
   }
@@ -1684,6 +1754,18 @@ public static String getCountryCode(@Nullable Context context) {
     return toUpperInvariant(Locale.getDefault().getCountry());
   }
 
+  /**
+   * Returns a non-empty array of normalized IETF BCP 47 language tags for the system languages
+   * ordered by preference.
+   */
+  public static String[] getSystemLanguageCodes() {
+    String[] systemLocales = getSystemLocales();
+    for (int i = 0; i < systemLocales.length; i++) {
+      systemLocales[i] = normalizeLanguageCode(systemLocales[i]);
+    }
+    return systemLocales;
+  }
+
   /**
    * Uncompresses the data in {@code input}.
    *
@@ -1731,6 +1813,20 @@ public static boolean inflate(
     }
   }
 
+  /**
+   * Returns whether the app is running on a TV device.
+   *
+   * @param context Any context.
+   * @return Whether the app is running on a TV device.
+   */
+  public static boolean isTv(Context context) {
+    // See https://developer.android.com/training/tv/start/hardware.html#runtime-check.
+    UiModeManager uiModeManager =
+        (UiModeManager) context.getApplicationContext().getSystemService(UI_MODE_SERVICE);
+    return uiModeManager != null
+        && uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION;
+  }
+
   /**
    * Gets the physical size of the default display, in pixels.
    *
@@ -1750,43 +1846,40 @@ public static Point getPhysicalDisplaySize(Context context) {
    * @return The physical display size, in pixels.
    */
   public static Point getPhysicalDisplaySize(Context context, Display display) {
-    if (Util.SDK_INT < 25 && display.getDisplayId() == Display.DEFAULT_DISPLAY) {
-      // Before API 25 the Display object does not provide a working way to identify Android TVs
-      // that can show 4k resolution in a SurfaceView, so check for supported devices here.
-      if ("Sony".equals(Util.MANUFACTURER) && Util.MODEL.startsWith("BRAVIA")
+    if (Util.SDK_INT <= 28 && display.getDisplayId() == Display.DEFAULT_DISPLAY && isTv(context)) {
+      // On Android TVs it is common for the UI to be configured for a lower resolution than
+      // SurfaceViews can output. Before API 26 the Display object does not provide a way to
+      // identify this case, and up to and including API 28 many devices still do not correctly set
+      // their hardware compositor output size.
+
+      // Sony Android TVs advertise support for 4k output via a system feature.
+      if ("Sony".equals(Util.MANUFACTURER)
+          && Util.MODEL.startsWith("BRAVIA")
           && context.getPackageManager().hasSystemFeature("com.sony.dtv.hardware.panel.qfhd")) {
         return new Point(3840, 2160);
-      } else if (("NVIDIA".equals(Util.MANUFACTURER) && Util.MODEL.contains("SHIELD"))
-          || ("philips".equals(Util.toLowerInvariant(Util.MANUFACTURER))
-              && (Util.MODEL.startsWith("QM1")
-                  || Util.MODEL.equals("QV151E")
-                  || Util.MODEL.equals("TPM171E")))) {
-        // Attempt to read sys.display-size.
-        String sysDisplaySize = null;
+      }
+
+      // Otherwise check the system property for display size. From API 28 treble may prevent the
+      // system from writing sys.display-size so we check vendor.display-size instead.
+      String displaySize =
+          Util.SDK_INT < 28
+              ? getSystemProperty("sys.display-size")
+              : getSystemProperty("vendor.display-size");
+      // If we managed to read the display size, attempt to parse it.
+      if (!TextUtils.isEmpty(displaySize)) {
         try {
-          @SuppressLint("PrivateApi")
-          Class<?> systemProperties = Class.forName("android.os.SystemProperties");
-          Method getMethod = systemProperties.getMethod("get", String.class);
-          sysDisplaySize = (String) getMethod.invoke(systemProperties, "sys.display-size");
-        } catch (Exception e) {
-          Log.e(TAG, "Failed to read sys.display-size", e);
-        }
-        // If we managed to read sys.display-size, attempt to parse it.
-        if (!TextUtils.isEmpty(sysDisplaySize)) {
-          try {
-            String[] sysDisplaySizeParts = split(sysDisplaySize.trim(), "x");
-            if (sysDisplaySizeParts.length == 2) {
-              int width = Integer.parseInt(sysDisplaySizeParts[0]);
-              int height = Integer.parseInt(sysDisplaySizeParts[1]);
-              if (width > 0 && height > 0) {
-                return new Point(width, height);
-              }
+          String[] displaySizeParts = split(displaySize.trim(), "x");
+          if (displaySizeParts.length == 2) {
+            int width = Integer.parseInt(displaySizeParts[0]);
+            int height = Integer.parseInt(displaySizeParts[1]);
+            if (width > 0 && height > 0) {
+              return new Point(width, height);
             }
-          } catch (NumberFormatException e) {
-            // Do nothing.
           }
-          Log.e(TAG, "Invalid sys.display-size: " + sysDisplaySize);
+        } catch (NumberFormatException e) {
+          // Do nothing.
         }
+        Log.e(TAG, "Invalid display size: " + displaySize);
       }
     }
 
@@ -1795,14 +1888,51 @@ public static Point getPhysicalDisplaySize(Context context, Display display) {
       getDisplaySizeV23(display, displaySize);
     } else if (Util.SDK_INT >= 17) {
       getDisplaySizeV17(display, displaySize);
-    } else if (Util.SDK_INT >= 16) {
-      getDisplaySizeV16(display, displaySize);
     } else {
-      getDisplaySizeV9(display, displaySize);
+      getDisplaySizeV16(display, displaySize);
     }
     return displaySize;
   }
 
+  /**
+   * Extract renderer capabilities for the renderers created by the provided renderers factory.
+   *
+   * @param renderersFactory A {@link RenderersFactory}.
+   * @param drmSessionManager An optional {@link DrmSessionManager} used by the renderers.
+   * @return The {@link RendererCapabilities} for each renderer created by the {@code
+   *     renderersFactory}.
+   */
+  public static RendererCapabilities[] getRendererCapabilities(
+      RenderersFactory renderersFactory,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+    Renderer[] renderers =
+        renderersFactory.createRenderers(
+            new Handler(),
+            new VideoRendererEventListener() {},
+            new AudioRendererEventListener() {},
+            (cues) -> {},
+            (metadata) -> {},
+            drmSessionManager);
+    RendererCapabilities[] capabilities = new RendererCapabilities[renderers.length];
+    for (int i = 0; i < renderers.length; i++) {
+      capabilities[i] = renderers[i].getCapabilities();
+    }
+    return capabilities;
+  }
+
+  @Nullable
+  private static String getSystemProperty(String name) {
+    try {
+      @SuppressLint("PrivateApi")
+      Class<?> systemProperties = Class.forName("android.os.SystemProperties");
+      Method getMethod = systemProperties.getMethod("get", String.class);
+      return (String) getMethod.invoke(systemProperties, name);
+    } catch (Exception e) {
+      Log.e(TAG, "Failed to read system property " + name, e);
+      return null;
+    }
+  }
+
   @TargetApi(23)
   private static void getDisplaySizeV23(Display display, Point outSize) {
     Display.Mode mode = display.getMode();
@@ -1815,15 +1945,37 @@ private static void getDisplaySizeV17(Display display, Point outSize) {
     display.getRealSize(outSize);
   }
 
-  @TargetApi(16)
   private static void getDisplaySizeV16(Display display, Point outSize) {
     display.getSize(outSize);
   }
 
-  @SuppressWarnings("deprecation")
-  private static void getDisplaySizeV9(Display display, Point outSize) {
-    outSize.x = display.getWidth();
-    outSize.y = display.getHeight();
+  private static String[] getSystemLocales() {
+    return SDK_INT >= 24
+        ? getSystemLocalesV24()
+        : new String[] {getLocaleLanguageTag(Resources.getSystem().getConfiguration().locale)};
+  }
+
+  @TargetApi(24)
+  private static String[] getSystemLocalesV24() {
+    return Util.split(Resources.getSystem().getConfiguration().getLocales().toLanguageTags(), ",");
+  }
+
+  private static Locale getLocaleForLanguageTag(String languageTag) {
+    return Util.SDK_INT >= 21 ? getLocaleForLanguageTagV21(languageTag) : new Locale(languageTag);
+  }
+
+  @TargetApi(21)
+  private static Locale getLocaleForLanguageTagV21(String languageTag) {
+    return Locale.forLanguageTag(languageTag);
+  }
+
+  private static String getLocaleLanguageTag(Locale locale) {
+    return SDK_INT >= 21 ? getLocaleLanguageTagV21(locale) : locale.toString();
+  }
+
+  @TargetApi(21)
+  private static String getLocaleLanguageTagV21(Locale locale) {
+    return locale.toLanguageTag();
   }
 
   private static @C.NetworkType int getMobileNetworkType(NetworkInfo networkInfo) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java
index 3b72a60fb9..a9b252b775 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/XmlPullParserUtil.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
index 77ca936a90..1b3943caf7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
@@ -17,7 +17,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
@@ -135,16 +135,16 @@ public void writeToParcel(Parcel dest, int flags) {
     }
   }
 
-  public static final Parcelable.Creator<ColorInfo> CREATOR = new Parcelable.Creator<ColorInfo>() {
-    @Override
-    public ColorInfo createFromParcel(Parcel in) {
-      return new ColorInfo(in);
-    }
-
-    @Override
-    public ColorInfo[] newArray(int size) {
-      return new ColorInfo[0];
-    }
-  };
-
+  public static final Parcelable.Creator<ColorInfo> CREATOR =
+      new Parcelable.Creator<ColorInfo>() {
+        @Override
+        public ColorInfo createFromParcel(Parcel in) {
+          return new ColorInfo(in);
+        }
+
+        @Override
+        public ColorInfo[] newArray(int size) {
+          return new ColorInfo[size];
+        }
+      };
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java b/library/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java
new file mode 100644
index 0000000000..3aeff9d553
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+/** Dolby Vision configuration data. */
+public final class DolbyVisionConfig {
+
+  /**
+   * Parses Dolby Vision configuration data.
+   *
+   * @param data A {@link ParsableByteArray}, whose position is set to the start of the Dolby Vision
+   *     configuration data to parse.
+   * @return The {@link DolbyVisionConfig} corresponding to the configuration, or {@code null} if
+   *     the configuration isn't supported.
+   */
+  @Nullable
+  public static DolbyVisionConfig parse(ParsableByteArray data) {
+    data.skipBytes(2); // dv_version_major, dv_version_minor
+    int profileData = data.readUnsignedByte();
+    int dvProfile = (profileData >> 1);
+    int dvLevel = ((profileData & 0x1) << 5) | ((data.readUnsignedByte() >> 3) & 0x1F);
+    String codecsPrefix;
+    if (dvProfile == 4 || dvProfile == 5) {
+      codecsPrefix = "dvhe";
+    } else if (dvProfile == 8) {
+      codecsPrefix = "hev1";
+    } else if (dvProfile == 9) {
+      codecsPrefix = "avc3";
+    } else {
+      return null;
+    }
+    String codecs = codecsPrefix + ".0" + dvProfile + ".0" + dvLevel;
+    return new DolbyVisionConfig(dvProfile, dvLevel, codecs);
+  }
+
+  /** The profile number. */
+  public final int profile;
+  /** The level number. */
+  public final int level;
+  /** The RFC 6381 codecs string. */
+  public final String codecs;
+
+  private DolbyVisionConfig(int profile, int level, String codecs) {
+    this.profile = profile;
+    this.level = level;
+    this.codecs = codecs;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
index c43d81010f..f302279f06 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
@@ -29,7 +29,7 @@
 import android.os.Handler.Callback;
 import android.os.HandlerThread;
 import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.EGLSurfaceTexture;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java b/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java
index 089ff6343f..727883f678 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/HevcConfig.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.video;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 40b25c2b2e..193fbddfec 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -25,9 +25,10 @@
 import android.media.MediaFormat;
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.CallSuper;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.CallSuper;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import android.util.Pair;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -51,6 +52,7 @@
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
 import java.nio.ByteBuffer;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -68,7 +70,6 @@
  *       a {@link android.view.SurfaceView}.
  * </ul>
  */
-@TargetApi(16)
 public class MediaCodecVideoRenderer extends MediaCodecRenderer {
 
   private static final String TAG = "MediaCodecVideoRenderer";
@@ -210,16 +211,64 @@ public MediaCodecVideoRenderer(
    * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
-  public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
+  public MediaCodecVideoRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      long allowedJoiningTimeMs,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify) {
+    this(
+        context,
+        mediaCodecSelector,
+        allowedJoiningTimeMs,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        /* enableDecoderFallback= */ false,
+        eventHandler,
+        eventListener,
+        maxDroppedFramesToNotify);
+  }
+
+  /**
+   * @param context A context.
+   * @param mediaCodecSelector A decoder selector.
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
+   *     content is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   */
+  public MediaCodecVideoRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
       long allowedJoiningTimeMs,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
-      @Nullable VideoRendererEventListener eventListener, int maxDroppedFramesToNotify) {
+      boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify) {
     super(
         C.TRACK_TYPE_VIDEO,
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         /* assumedMinimumCodecOperatingRate= */ 30);
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
@@ -256,11 +305,14 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
       }
     }
     List<MediaCodecInfo> decoderInfos =
-        mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecryption);
+        getDecoderInfos(mediaCodecSelector, format, requiresSecureDecryption);
     if (decoderInfos.isEmpty()) {
       return requiresSecureDecryption
               && !mediaCodecSelector
-                  .getDecoderInfos(format.sampleMimeType, /* requiresSecureDecoder= */ false)
+                  .getDecoderInfos(
+                      format.sampleMimeType,
+                      /* requiresSecureDecoder= */ false,
+                      /* requiresTunnelingDecoder= */ false)
                   .isEmpty()
           ? FORMAT_UNSUPPORTED_DRM
           : FORMAT_UNSUPPORTED_SUBTYPE;
@@ -275,16 +327,43 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         decoderInfo.isSeamlessAdaptationSupported(format)
             ? ADAPTIVE_SEAMLESS
             : ADAPTIVE_NOT_SEAMLESS;
-    int tunnelingSupport = decoderInfo.tunneling ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
+    int tunnelingSupport = TUNNELING_NOT_SUPPORTED;
+    if (isFormatSupported) {
+      List<MediaCodecInfo> tunnelingDecoderInfos =
+          mediaCodecSelector.getDecoderInfos(
+              format.sampleMimeType,
+              requiresSecureDecryption,
+              /* requiresTunnelingDecoder= */ true);
+      if (!tunnelingDecoderInfos.isEmpty()) {
+        MediaCodecInfo tunnelingDecoderInfo = tunnelingDecoderInfos.get(0);
+        if (tunnelingDecoderInfo.isFormatSupported(format)
+            && tunnelingDecoderInfo.isSeamlessAdaptationSupported(format)) {
+          tunnelingSupport = TUNNELING_SUPPORTED;
+        }
+      }
+    }
     int formatSupport = isFormatSupported ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
     return adaptiveSupport | tunnelingSupport | formatSupport;
   }
 
+  @Override
+  protected List<MediaCodecInfo> getDecoderInfos(
+      MediaCodecSelector mediaCodecSelector, Format format, boolean requiresSecureDecoder)
+      throws DecoderQueryException {
+    List<MediaCodecInfo> decoderInfos =
+        mediaCodecSelector.getDecoderInfos(format.sampleMimeType, requiresSecureDecoder, tunneling);
+    return Collections.unmodifiableList(decoderInfos);
+  }
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
+    int oldTunnelingAudioSessionId = tunnelingAudioSessionId;
     tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
     tunneling = tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET;
+    if (tunnelingAudioSessionId != oldTunnelingAudioSessionId) {
+      releaseCodec();
+    }
     eventDispatcher.enabled(decoderCounters);
     frameReleaseTimeHelper.enable();
   }
@@ -361,26 +440,35 @@ protected void onStopped() {
 
   @Override
   protected void onDisabled() {
-    currentWidth = Format.NO_VALUE;
-    currentHeight = Format.NO_VALUE;
-    currentPixelWidthHeightRatio = Format.NO_VALUE;
-    pendingPixelWidthHeightRatio = Format.NO_VALUE;
-    outputStreamOffsetUs = C.TIME_UNSET;
     lastInputTimeUs = C.TIME_UNSET;
+    outputStreamOffsetUs = C.TIME_UNSET;
     pendingOutputStreamOffsetCount = 0;
     clearReportedVideoSize();
     clearRenderedFirstFrame();
     frameReleaseTimeHelper.disable();
     tunnelingOnFrameRenderedListener = null;
-    tunneling = false;
     try {
       super.onDisabled();
     } finally {
-      decoderCounters.ensureUpdated();
       eventDispatcher.disabled(decoderCounters);
     }
   }
 
+  @Override
+  protected void onReset() {
+    try {
+      super.onReset();
+    } finally {
+      if (dummySurface != null) {
+        if (surface == dummySurface) {
+          surface = null;
+        }
+        dummySurface.release();
+        dummySurface = null;
+      }
+    }
+  }
+
   @Override
   public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
@@ -415,10 +503,9 @@ private void setSurface(Surface surface) throws ExoPlaybackException {
     if (this.surface != surface) {
       this.surface = surface;
       @State int state = getState();
-      if (state == STATE_ENABLED || state == STATE_STARTED) {
-        MediaCodec codec = getCodec();
-        if (Util.SDK_INT >= 23 && codec != null && surface != null
-            && !codecNeedsSetOutputSurfaceWorkaround) {
+      MediaCodec codec = getCodec();
+      if (codec != null) {
+        if (Util.SDK_INT >= 23 && surface != null && !codecNeedsSetOutputSurfaceWorkaround) {
           setOutputSurfaceV23(codec, surface);
         } else {
           releaseCodec();
@@ -508,25 +595,21 @@ protected void releaseCodec() {
       super.releaseCodec();
     } finally {
       buffersInCodecCount = 0;
-      if (dummySurface != null) {
-        if (surface == dummySurface) {
-          surface = null;
-        }
-        dummySurface.release();
-        dummySurface = null;
-      }
     }
   }
 
   @CallSuper
   @Override
-  protected void flushCodec() throws ExoPlaybackException {
-    super.flushCodec();
-    buffersInCodecCount = 0;
+  protected boolean flushOrReleaseCodec() {
+    try {
+      return super.flushOrReleaseCodec();
+    } finally {
+      buffersInCodecCount = 0;
+    }
   }
 
   @Override
-  protected float getCodecOperatingRate(
+  protected float getCodecOperatingRateV23(
       float operatingRate, Format format, Format[] streamFormats) {
     // Use the highest known stream frame-rate up front, to avoid having to reconfigure the codec
     // should an adaptive switch to that stream occur.
@@ -859,7 +942,7 @@ protected boolean maybeDropBuffersToKeyframe(MediaCodec codec, int index, long p
     // We dropped some buffers to catch up, so update the decoder counters and flush the codec,
     // which releases all pending buffers buffers including the current output buffer.
     updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
-    flushCodec();
+    flushOrReinitializeCodec();
     return true;
   }
 
@@ -1050,6 +1133,16 @@ protected MediaFormat getMediaFormat(
     MediaFormatUtil.maybeSetFloat(mediaFormat, MediaFormat.KEY_FRAME_RATE, format.frameRate);
     MediaFormatUtil.maybeSetInteger(mediaFormat, MediaFormat.KEY_ROTATION, format.rotationDegrees);
     MediaFormatUtil.maybeSetColorInfo(mediaFormat, format.colorInfo);
+    if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {
+      // Some phones require the profile to be set on the codec.
+      // See https://github.com/google/ExoPlayer/pull/5438.
+      Pair<Integer, Integer> codecProfileAndLevel =
+          MediaCodecUtil.getCodecProfileAndLevel(format.codecs);
+      if (codecProfileAndLevel != null) {
+        MediaFormatUtil.maybeSetInteger(
+            mediaFormat, MediaFormat.KEY_PROFILE, codecProfileAndLevel.first);
+      }
+    }
     // Set codec max values.
     mediaFormat.setInteger(MediaFormat.KEY_MAX_WIDTH, codecMaxValues.width);
     mediaFormat.setInteger(MediaFormat.KEY_MAX_HEIGHT, codecMaxValues.height);
@@ -1303,8 +1396,9 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
     }
     synchronized (MediaCodecVideoRenderer.class) {
       if (!evaluatedDeviceNeedsSetOutputSurfaceWorkaround) {
-        if (Util.SDK_INT <= 27 && "dangal".equals(Util.DEVICE)) {
-          // Dangal is affected on API level 27: https://github.com/google/ExoPlayer/issues/5169.
+        if (Util.SDK_INT <= 27 && ("dangal".equals(Util.DEVICE) || "HWEML".equals(Util.DEVICE))) {
+          // A small number of devices are affected on API level 27:
+          // https://github.com/google/ExoPlayer/issues/5169.
           deviceNeedsSetOutputSurfaceWorkaround = true;
         } else if (Util.SDK_INT >= 27) {
           // In general, devices running API level 27 or later should be unaffected. Do nothing.
@@ -1322,7 +1416,8 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
           // https://github.com/google/ExoPlayer/issues/4315,
           // https://github.com/google/ExoPlayer/issues/4419,
           // https://github.com/google/ExoPlayer/issues/4460,
-          // https://github.com/google/ExoPlayer/issues/4468.
+          // https://github.com/google/ExoPlayer/issues/4468,
+          // https://github.com/google/ExoPlayer/issues/5312.
           switch (Util.DEVICE) {
             case "1601":
             case "1713":
@@ -1378,6 +1473,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
             case "HWBLN-H":
             case "HWCAM-H":
             case "HWVNS-H":
+            case "HWWAS-H":
             case "i9031":
             case "iball8735_9806":
             case "Infinix-X572":
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
index 3c0fb92191..caa79d7c18 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
@@ -21,7 +21,7 @@
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Choreographer;
 import android.view.Choreographer.FrameCallback;
 import android.view.Display;
@@ -32,7 +32,6 @@
 /**
  * Makes a best effort to adjust frame release timestamps for a smoother visual result.
  */
-@TargetApi(16)
 public final class VideoFrameReleaseTimeHelper {
 
   private static final long CHOREOGRAPHER_SAMPLE_DELAY_MILLIS = 500;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
index 7d78ba03c7..2f76a2c23d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
@@ -17,7 +17,7 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import android.view.TextureView;
 import com.google.android.exoplayer2.Format;
@@ -179,6 +179,7 @@ public void renderedFirstFrame(@Nullable Surface surface) {
 
     /** Invokes {@link VideoRendererEventListener#onVideoDisabled(DecoderCounters)}. */
     public void disabled(DecoderCounters counters) {
+      counters.ensureUpdated();
       if (listener != null) {
         handler.post(
             () -> {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
index 4a8354d17f..eb7110834b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.video.spherical;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -72,12 +72,12 @@ protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlayba
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
-    reset();
+    resetListener();
   }
 
   @Override
   protected void onDisabled() {
-    reset();
+    resetListener();
   }
 
   @Override
@@ -124,7 +124,7 @@ public boolean isReady() {
     return result;
   }
 
-  private void reset() {
+  private void resetListener() {
     lastTimestampUs = 0;
     if (listener != null) {
       listener.onCameraMotionReset();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java
index d7404cbce4..d464bf04fa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueue.java
@@ -61,7 +61,7 @@ public void reset() {
    * timestamp to {@code matrix}. Removes all older rotations and the returned one from the queue.
    * Does nothing if there is no such rotation.
    *
-   * @param matrix A float array to hold the rotation matrix.
+   * @param matrix The rotation matrix.
    * @param timestampUs The time in microseconds to query the rotation.
    * @return Whether a rotation matrix is copied to {@code matrix}.
    */
@@ -83,8 +83,11 @@ public boolean pollRotationMatrix(float[] matrix, long timestampUs) {
   /**
    * Computes a recentering matrix from the given angle-axis rotation only accounting for yaw. Roll
    * and tilt will not be compensated.
+   *
+   * @param recenterMatrix The recenter matrix.
+   * @param rotationMatrix The rotation matrix.
    */
-  private static void computeRecenterMatrix(float[] recenterMatrix, float[] rotationMatrix) {
+  public static void computeRecenterMatrix(float[] recenterMatrix, float[] rotationMatrix) {
     // The re-centering matrix is computed as follows:
     // recenter.row(2) = temp.col(2).transpose();
     // recenter.row(0) = recenter.row(1).cross(recenter.row(2)).normalized();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
index 3d4879d50a..8ba24bb06e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.video.spherical;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.StereoMode;
 import com.google.android.exoplayer2.util.Assertions;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java
index 7a3c4998b3..527aa5db4f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoder.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.video.spherical;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
diff --git a/library/core/src/test/assets/download-actions/dash-download-v0 b/library/core/src/test/assets/download-actions/dash-download-v0
new file mode 100644
index 0000000000..980f0000b7
Binary files /dev/null and b/library/core/src/test/assets/download-actions/dash-download-v0 differ
diff --git a/library/core/src/test/assets/download-actions/dash-remove-v0 b/library/core/src/test/assets/download-actions/dash-remove-v0
new file mode 100644
index 0000000000..03e37b1e0d
Binary files /dev/null and b/library/core/src/test/assets/download-actions/dash-remove-v0 differ
diff --git a/library/core/src/test/assets/download-actions/hls-download-v0 b/library/core/src/test/assets/download-actions/hls-download-v0
new file mode 100644
index 0000000000..88c46b8b09
Binary files /dev/null and b/library/core/src/test/assets/download-actions/hls-download-v0 differ
diff --git a/library/core/src/test/assets/download-actions/hls-download-v1 b/library/core/src/test/assets/download-actions/hls-download-v1
new file mode 100644
index 0000000000..9a3ab7129e
Binary files /dev/null and b/library/core/src/test/assets/download-actions/hls-download-v1 differ
diff --git a/library/core/src/test/assets/download-actions/hls-remove-v0 b/library/core/src/test/assets/download-actions/hls-remove-v0
new file mode 100644
index 0000000000..163dfed1bf
Binary files /dev/null and b/library/core/src/test/assets/download-actions/hls-remove-v0 differ
diff --git a/library/core/src/test/assets/download-actions/hls-remove-v1 b/library/core/src/test/assets/download-actions/hls-remove-v1
new file mode 100644
index 0000000000..35fbd32718
Binary files /dev/null and b/library/core/src/test/assets/download-actions/hls-remove-v1 differ
diff --git a/library/core/src/test/assets/download-actions/progressive-download-v0 b/library/core/src/test/assets/download-actions/progressive-download-v0
new file mode 100644
index 0000000000..618419e183
Binary files /dev/null and b/library/core/src/test/assets/download-actions/progressive-download-v0 differ
diff --git a/library/core/src/test/assets/download-actions/progressive-remove-v0 b/library/core/src/test/assets/download-actions/progressive-remove-v0
new file mode 100644
index 0000000000..7a522b85f4
Binary files /dev/null and b/library/core/src/test/assets/download-actions/progressive-remove-v0 differ
diff --git a/library/core/src/test/assets/download-actions/ss-download-v0 b/library/core/src/test/assets/download-actions/ss-download-v0
new file mode 100644
index 0000000000..da0d2f6be5
Binary files /dev/null and b/library/core/src/test/assets/download-actions/ss-download-v0 differ
diff --git a/library/core/src/test/assets/download-actions/ss-download-v1 b/library/core/src/test/assets/download-actions/ss-download-v1
new file mode 100644
index 0000000000..9db30a8af5
Binary files /dev/null and b/library/core/src/test/assets/download-actions/ss-download-v1 differ
diff --git a/library/core/src/test/assets/download-actions/ss-remove-v0 b/library/core/src/test/assets/download-actions/ss-remove-v0
new file mode 100644
index 0000000000..a3811cd4ce
Binary files /dev/null and b/library/core/src/test/assets/download-actions/ss-remove-v0 differ
diff --git a/library/core/src/test/assets/download-actions/ss-remove-v1 b/library/core/src/test/assets/download-actions/ss-remove-v1
new file mode 100644
index 0000000000..fd3c8c194c
Binary files /dev/null and b/library/core/src/test/assets/download-actions/ss-remove-v1 differ
diff --git a/library/core/src/test/assets/mp4/sample.mp4.0.dump b/library/core/src/test/assets/mp4/sample.mp4.0.dump
index efc804d48b..37e1054f79 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.0.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.0.dump
@@ -12,7 +12,7 @@ track 0:
     maxInputSize = 36722
     width = 1080
     height = 720
-    frameRate = -1.0
+    frameRate = 29.970028
     rotationDegrees = 0
     pixelWidthHeightRatio = 1.0
     channelCount = -1
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -352,6 +352,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 44:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/mp4/sample.mp4.1.dump b/library/core/src/test/assets/mp4/sample.mp4.1.dump
index 10104b5e81..6284e85034 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.1.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.1.dump
@@ -12,7 +12,7 @@ track 0:
     maxInputSize = 36722
     width = 1080
     height = 720
-    frameRate = -1.0
+    frameRate = 29.970028
     rotationDegrees = 0
     pixelWidthHeightRatio = 1.0
     channelCount = -1
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -304,6 +304,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 32:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/mp4/sample.mp4.2.dump b/library/core/src/test/assets/mp4/sample.mp4.2.dump
index 8af96be673..15b56a036f 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.2.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.2.dump
@@ -12,7 +12,7 @@ track 0:
     maxInputSize = 36722
     width = 1080
     height = 720
-    frameRate = -1.0
+    frameRate = 29.970028
     rotationDegrees = 0
     pixelWidthHeightRatio = 1.0
     channelCount = -1
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -244,6 +244,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 17:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/mp4/sample.mp4.3.dump b/library/core/src/test/assets/mp4/sample.mp4.3.dump
index f1259661ed..073d5c774a 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.3.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.3.dump
@@ -12,7 +12,7 @@ track 0:
     maxInputSize = 36722
     width = 1080
     height = 720
-    frameRate = -1.0
+    frameRate = 29.970028
     rotationDegrees = 0
     pixelWidthHeightRatio = 1.0
     channelCount = -1
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -184,6 +184,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 2:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/offline/action_file_for_download_index_upgrade.exi b/library/core/src/test/assets/offline/action_file_for_download_index_upgrade.exi
new file mode 100644
index 0000000000..0bf49b133a
Binary files /dev/null and b/library/core/src/test/assets/offline/action_file_for_download_index_upgrade.exi differ
diff --git a/library/core/src/test/assets/offline/action_file_incomplete_header.exi b/library/core/src/test/assets/offline/action_file_incomplete_header.exi
new file mode 100644
index 0000000000..593f4708db
Binary files /dev/null and b/library/core/src/test/assets/offline/action_file_incomplete_header.exi differ
diff --git a/library/core/src/test/assets/offline/action_file_no_data.exi b/library/core/src/test/assets/offline/action_file_no_data.exi
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/library/core/src/test/assets/offline/action_file_one_action.exi b/library/core/src/test/assets/offline/action_file_one_action.exi
new file mode 100644
index 0000000000..a196d8a322
Binary files /dev/null and b/library/core/src/test/assets/offline/action_file_one_action.exi differ
diff --git a/library/core/src/test/assets/offline/action_file_two_actions.exi b/library/core/src/test/assets/offline/action_file_two_actions.exi
new file mode 100644
index 0000000000..35c9b35e1e
Binary files /dev/null and b/library/core/src/test/assets/offline/action_file_two_actions.exi differ
diff --git a/library/core/src/test/assets/offline/action_file_unsupported_version.exi b/library/core/src/test/assets/offline/action_file_unsupported_version.exi
new file mode 100644
index 0000000000..25e0dee842
Binary files /dev/null and b/library/core/src/test/assets/offline/action_file_unsupported_version.exi differ
diff --git a/library/core/src/test/assets/offline/action_file_zero_actions.exi b/library/core/src/test/assets/offline/action_file_zero_actions.exi
new file mode 100644
index 0000000000..1b1cb4d44c
Binary files /dev/null and b/library/core/src/test/assets/offline/action_file_zero_actions.exi differ
diff --git a/library/core/src/test/assets/ts/sample.ac4 b/library/core/src/test/assets/ts/sample.ac4
new file mode 100644
index 0000000000..721f53cdd7
Binary files /dev/null and b/library/core/src/test/assets/ts/sample.ac4 differ
diff --git a/library/core/src/test/assets/ts/sample.ac4.0.dump b/library/core/src/test/assets/ts/sample.ac4.0.dump
new file mode 100644
index 0000000000..03ae07707a
--- /dev/null
+++ b/library/core/src/test/assets/ts/sample.ac4.0.dump
@@ -0,0 +1,106 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = [[timeUs=0, position=0]]
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = 0
+    containerMimeType = null
+    sampleMimeType = audio/ac4
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = 2
+    sampleRate = 48000
+    pcmEncoding = -1
+    encoderDelay = 0
+    encoderPadding = 0
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  total output bytes = 7594
+  sample count = 19
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 366, hash B4277F9E
+  sample 1:
+    time = 40000
+    flags = 1
+    data = length 366, hash E8E0A142
+  sample 2:
+    time = 80000
+    flags = 1
+    data = length 366, hash 2E5073D0
+  sample 3:
+    time = 120000
+    flags = 1
+    data = length 366, hash 850E71D8
+  sample 4:
+    time = 160000
+    flags = 1
+    data = length 366, hash 69CD444E
+  sample 5:
+    time = 200000
+    flags = 1
+    data = length 366, hash BD24F36D
+  sample 6:
+    time = 240000
+    flags = 1
+    data = length 366, hash E24F2490
+  sample 7:
+    time = 280000
+    flags = 1
+    data = length 366, hash EE6F1F06
+  sample 8:
+    time = 320000
+    flags = 1
+    data = length 366, hash 2DAB000F
+  sample 9:
+    time = 360000
+    flags = 1
+    data = length 366, hash 8102B7EC
+  sample 10:
+    time = 400000
+    flags = 1
+    data = length 366, hash 55BF59AC
+  sample 11:
+    time = 440000
+    flags = 1
+    data = length 494, hash CBC2E09F
+  sample 12:
+    time = 480000
+    flags = 1
+    data = length 519, hash 9DAF56E9
+  sample 13:
+    time = 520000
+    flags = 1
+    data = length 598, hash 8169EE2
+  sample 14:
+    time = 560000
+    flags = 1
+    data = length 435, hash 28C21246
+  sample 15:
+    time = 600000
+    flags = 1
+    data = length 365, hash FF14716D
+  sample 16:
+    time = 640000
+    flags = 1
+    data = length 392, hash 4CC96B29
+  sample 17:
+    time = 680000
+    flags = 1
+    data = length 373, hash D7AC6D4E
+  sample 18:
+    time = 720000
+    flags = 1
+    data = length 392, hash 99F2511F
+tracksEnded = true
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/CTest.java b/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
index f56510f654..26a7102b16 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
@@ -19,14 +19,12 @@
 
 import android.annotation.SuppressLint;
 import android.media.MediaCodec;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link C}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link C}. */
+@RunWith(AndroidJUnit4.class)
 public class CTest {
 
   @SuppressLint("InlinedApi")
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java b/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
index 93ec5e0264..31f432db15 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
@@ -17,15 +17,15 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.DefaultLoadControl.Builder;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link DefaultLoadControl}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class DefaultLoadControlTest {
 
   private static final float SPEED = 1f;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java b/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java
index d2d032870e..be0f7f55c7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java
@@ -22,6 +22,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.MockitoAnnotations.initMocks;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
 import com.google.android.exoplayer2.testutil.FakeClock;
 import com.google.android.exoplayer2.testutil.FakeMediaClockRenderer;
@@ -29,12 +30,9 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link DefaultMediaClock}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link DefaultMediaClock}. */
+@RunWith(AndroidJUnit4.class)
 public class DefaultMediaClockTest {
 
   private static final long TEST_POSITION_US = 123456789012345678L;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index d131ed0f51..a715289a04 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -19,8 +19,11 @@
 import static org.junit.Assert.fail;
 
 import android.content.Context;
-import android.support.annotation.Nullable;
+import android.graphics.SurfaceTexture;
+import androidx.annotation.Nullable;
 import android.view.Surface;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.Player.EventListener;
 import com.google.android.exoplayer2.Timeline.Window;
@@ -65,12 +68,10 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Unit test for {@link ExoPlayer}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public final class ExoPlayerTest {
 
@@ -85,7 +86,7 @@
 
   @Before
   public void setUp() {
-    context = RuntimeEnvironment.application;
+    context = ApplicationProvider.getApplicationContext();
   }
 
   /**
@@ -267,10 +268,8 @@ public void testRepreparationGivesFreshSourceInfo() throws Exception {
         new FakeMediaSource(timeline, new Object(), Builder.VIDEO_FORMAT) {
           @Override
           public synchronized void prepareSourceInternal(
-              ExoPlayer player,
-              boolean isTopLevelSource,
               @Nullable TransferListener mediaTransferListener) {
-            super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+            super.prepareSourceInternal(mediaTransferListener);
             // We've queued a source info refresh on the playback thread's event queue. Allow the
             // test thread to prepare the player with the third source, and block this thread (the
             // playback thread) until the test thread's call to prepare() has returned.
@@ -498,12 +497,12 @@ public void testSeekProcessedCallback() throws Exception {
             .waitForPlaybackState(Player.STATE_READY)
             .seek(10)
             // Start playback and wait until playback reaches second window.
-            .play()
-            .waitForPositionDiscontinuity()
+            .playUntilStartOfWindow(/* windowIndex= */ 1)
             // Seek twice in concession, expecting the first seek to be replaced (and thus except
             // only on seek processed callback).
             .seek(5)
             .seek(60)
+            .play()
             .build();
     final List<Integer> playbackStatesWhenSeekProcessed = new ArrayList<>();
     EventListener eventListener =
@@ -550,12 +549,9 @@ public void testSeekProcessedCalledWithIllegalSeekPosition() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testSeekProcessedCalledWithIllegalSeekPosition")
             .waitForPlaybackState(Player.STATE_BUFFERING)
-            // Cause an illegal seek exception by seeking to an invalid position while the media
-            // source is still being prepared and the player doesn't immediately know it will fail.
-            // Because the media source prepares immediately, the exception will be thrown when the
-            // player processed the seek.
+            // The illegal seek position will end playback.
             .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
-            .waitForPlaybackState(Player.STATE_IDLE)
+            .waitForPlaybackState(Player.STATE_ENDED)
             .build();
     final boolean[] onSeekProcessedCalled = new boolean[1];
     EventListener listener =
@@ -567,13 +563,7 @@ public void onSeekProcessed() {
         };
     ExoPlayerTestRunner testRunner =
         new Builder().setActionSchedule(actionSchedule).setEventListener(listener).build(context);
-    try {
-      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
-      fail();
-    } catch (ExoPlaybackException e) {
-      // Expected exception.
-      assertThat(e.getUnexpectedException()).isInstanceOf(IllegalSeekPositionException.class);
-    }
+    testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
     assertThat(onSeekProcessedCalled[0]).isTrue();
   }
 
@@ -773,7 +763,7 @@ public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreRemad
     }
     // There are 2 renderers, and track selections are made twice. The second time one renderer is
     // disabled, so only one out of the two track selections is enabled.
-    assertThat(createdTrackSelections).hasSize(4);
+    assertThat(createdTrackSelections).hasSize(3);
     assertThat(numSelectionsEnabled).isEqualTo(3);
   }
 
@@ -1125,6 +1115,45 @@ public void testSeekBeforeRepreparationPossibleAfterStopWithReset() throws Excep
     testRunner.assertPlayedPeriodIndices(0, 1);
   }
 
+  @Test
+  public void testReprepareAndKeepPositionWithNewMediaSource() throws Exception {
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ new Object()));
+    Timeline secondTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ new Object()));
+    MediaSource secondSource = new FakeMediaSource(secondTimeline, /* manifest= */ null);
+    AtomicLong positionAfterReprepare = new AtomicLong();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testReprepareAndKeepPositionWithNewMediaSource")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 2000)
+            .prepareSource(secondSource, /* resetPosition= */ false, /* resetState= */ true)
+            .waitForTimelineChanged(secondTimeline)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionAfterReprepare.set(player.getCurrentPosition());
+                  }
+                })
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build(context)
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS)
+            .blockUntilEnded(TIMEOUT_MS);
+
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, secondTimeline);
+    assertThat(positionAfterReprepare.get()).isAtLeast(2000L);
+  }
+
   @Test
   public void testStopDuringPreparationOverwritesPreparation() throws Exception {
     Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
@@ -1257,59 +1286,51 @@ public void run(SimpleExoPlayer player) {
   }
 
   @Test
-  public void testPlaybackErrorDuringSourceInfoRefreshStillUpdatesTimeline() throws Exception {
+  public void testInvalidSeekPositionAfterSourceInfoRefreshStillUpdatesTimeline() throws Exception {
     final Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
     final FakeMediaSource mediaSource =
         new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testPlaybackErrorDuringSourceInfoRefreshStillUpdatesTimeline")
+        new ActionSchedule.Builder("testInvalidSeekPositionSourceInfoRefreshStillUpdatesTimeline")
             .waitForPlaybackState(Player.STATE_BUFFERING)
-            // Cause an internal exception by seeking to an invalid position while the media source
-            // is still being prepared. The error will be thrown while the player handles the new
-            // source info.
+            // Seeking to an invalid position will end playback.
             .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
             .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
-            .waitForPlaybackState(Player.STATE_IDLE)
+            .waitForPlaybackState(Player.STATE_ENDED)
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
             .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .build(context);
-    try {
-      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
-      fail();
-    } catch (ExoPlaybackException e) {
-      // Expected exception.
-      assertThat(e.getUnexpectedException()).isInstanceOf(IllegalSeekPositionException.class);
-    }
+    testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+
     testRunner.assertTimelinesEqual(timeline);
     testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
   }
 
   @Test
-  public void testPlaybackErrorDuringSourceInfoRefreshWithShuffleModeEnabledUsesCorrectFirstPeriod()
-      throws Exception {
+  public void
+      testInvalidSeekPositionAfterSourceInfoRefreshWithShuffleModeEnabledUsesCorrectFirstPeriod()
+          throws Exception {
     FakeMediaSource mediaSource =
         new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1), /* manifest= */ null);
     ConcatenatingMediaSource concatenatingMediaSource =
         new ConcatenatingMediaSource(
             /* isAtomic= */ false, new FakeShuffleOrder(0), mediaSource, mediaSource);
-    AtomicInteger windowIndexAfterError = new AtomicInteger();
+    AtomicInteger windowIndexAfterUpdate = new AtomicInteger();
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testPlaybackErrorDuringSourceInfoRefreshUsesCorrectFirstPeriod")
+        new ActionSchedule.Builder("testInvalidSeekPositionSourceInfoRefreshUsesCorrectFirstPeriod")
             .setShuffleModeEnabled(true)
             .waitForPlaybackState(Player.STATE_BUFFERING)
-            // Cause an internal exception by seeking to an invalid position while the media source
-            // is still being prepared. The error will be thrown while the player handles the new
-            // source info.
+            // Seeking to an invalid position will end playback.
             .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
-            .waitForPlaybackState(Player.STATE_IDLE)
+            .waitForPlaybackState(Player.STATE_ENDED)
             .executeRunnable(
                 new PlayerRunnable() {
                   @Override
                   public void run(SimpleExoPlayer player) {
-                    windowIndexAfterError.set(player.getCurrentWindowIndex());
+                    windowIndexAfterUpdate.set(player.getCurrentWindowIndex());
                   }
                 })
             .build();
@@ -1318,14 +1339,9 @@ public void run(SimpleExoPlayer player) {
             .setMediaSource(concatenatingMediaSource)
             .setActionSchedule(actionSchedule)
             .build(context);
-    try {
-      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
-      fail();
-    } catch (ExoPlaybackException e) {
-      // Expected exception.
-      assertThat(e.getUnexpectedException()).isInstanceOf(IllegalSeekPositionException.class);
-    }
-    assertThat(windowIndexAfterError.get()).isEqualTo(1);
+    testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(windowIndexAfterUpdate.get()).isEqualTo(1);
   }
 
   @Test
@@ -2030,15 +2046,17 @@ public void testTimelineUpdateDropsPrebufferedPeriods() throws Exception {
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPlayedPeriodIndices(0, 1);
     // Assert that the second period was re-created from the new timeline.
-    assertThat(mediaSource.getCreatedMediaPeriods())
-        .containsExactly(
-            new MediaPeriodId(
-                timeline1.getUidOfPeriod(/* periodIndex= */ 0), /* windowSequenceNumber= */ 0),
-            new MediaPeriodId(
-                timeline1.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 1),
-            new MediaPeriodId(
-                timeline2.getUidOfPeriod(/* periodIndex= */ 1), /* windowSequenceNumber= */ 2))
-        .inOrder();
+    assertThat(mediaSource.getCreatedMediaPeriods()).hasSize(3);
+    assertThat(mediaSource.getCreatedMediaPeriods().get(0).periodUid)
+        .isEqualTo(timeline1.getUidOfPeriod(/* periodIndex= */ 0));
+    assertThat(mediaSource.getCreatedMediaPeriods().get(1).periodUid)
+        .isEqualTo(timeline1.getUidOfPeriod(/* periodIndex= */ 1));
+    assertThat(mediaSource.getCreatedMediaPeriods().get(2).periodUid)
+        .isEqualTo(timeline2.getUidOfPeriod(/* periodIndex= */ 1));
+    assertThat(mediaSource.getCreatedMediaPeriods().get(1).windowSequenceNumber)
+        .isGreaterThan(mediaSource.getCreatedMediaPeriods().get(0).windowSequenceNumber);
+    assertThat(mediaSource.getCreatedMediaPeriods().get(2).windowSequenceNumber)
+        .isGreaterThan(mediaSource.getCreatedMediaPeriods().get(1).windowSequenceNumber);
   }
 
   @Test
@@ -2058,8 +2076,11 @@ public void testRepeatedSeeksToUnpreparedPeriodInSameWindowKeepsWindowSequenceNu
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
             .seek(/* windowIndex= */ 0, /* positionMs= */ 9999)
+            .waitForSeekProcessed()
             .seek(/* windowIndex= */ 0, /* positionMs= */ 1)
+            .waitForSeekProcessed()
             .seek(/* windowIndex= */ 0, /* positionMs= */ 9999)
+            .waitForSeekProcessed()
             .play()
             .build();
     ExoPlayerTestRunner testRunner =
@@ -2590,8 +2611,8 @@ public void run(SimpleExoPlayer player) {
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
-    final Surface surface1 = new Surface(null);
-    final Surface surface2 = new Surface(null);
+    final Surface surface1 = new Surface(new SurfaceTexture(/* texName= */ 0));
+    final Surface surface2 = new Surface(new SurfaceTexture(/* texName= */ 1));
     return builder
         .executeRunnable(
             new PlayerRunnable() {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
index 33e6ed0838..96bb606eae 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
@@ -21,6 +21,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
@@ -32,22 +33,19 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link Format}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link Format}. */
+@RunWith(AndroidJUnit4.class)
 public final class FormatTest {
 
-  private static final List<byte[]> INIT_DATA;
+  private static final List<byte[]> initData;
   static {
     byte[] initData1 = new byte[] {1, 2, 3};
     byte[] initData2 = new byte[] {4, 5, 6};
-    List<byte[]> initData = new ArrayList<>();
-    initData.add(initData1);
-    initData.add(initData2);
-    INIT_DATA = Collections.unmodifiableList(initData);
+    List<byte[]> initDataList = new ArrayList<>();
+    initDataList.add(initData1);
+    initDataList.add(initData2);
+    initData = Collections.unmodifiableList(initDataList);
   }
 
   @Test
@@ -68,11 +66,17 @@ public void testParcelable() {
         new Format(
             "id",
             "label",
+            C.SELECTION_FLAG_DEFAULT,
+            C.ROLE_FLAG_MAIN,
+            /* bitrate= */ 1024,
+            "codec",
+            metadata,
             /* containerMimeType= */ MimeTypes.VIDEO_MP4,
             /* sampleMimeType= */ MimeTypes.VIDEO_H264,
-            "codec",
-            /* bitrate= */ 1024,
             /* maxInputSize= */ 2048,
+            initData,
+            drmInitData,
+            Format.OFFSET_SAMPLE_RELATIVE,
             /* width= */ 1920,
             /* height= */ 1080,
             /* frameRate= */ 24,
@@ -86,13 +90,8 @@ public void testParcelable() {
             C.ENCODING_PCM_24BIT,
             /* encoderDelay= */ 1001,
             /* encoderPadding= */ 1002,
-            C.SELECTION_FLAG_DEFAULT,
             "language",
-            /* accessibilityChannel= */ Format.NO_VALUE,
-            Format.OFFSET_SAMPLE_RELATIVE,
-            INIT_DATA,
-            drmInitData,
-            metadata);
+            /* accessibilityChannel= */ Format.NO_VALUE);
 
     Parcel parcel = Parcel.obtain();
     formatToParcel.writeToParcel(parcel, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
new file mode 100644
index 0000000000..73f42c5fc9
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
@@ -0,0 +1,463 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.SinglePeriodTimeline;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState;
+import com.google.android.exoplayer2.source.ads.SinglePeriodAdTimeline;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.upstream.Allocator;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link MediaPeriodQueue}. */
+@RunWith(AndroidJUnit4.class)
+public final class MediaPeriodQueueTest {
+
+  private static final long CONTENT_DURATION_US = 30 * C.MICROS_PER_SECOND;
+  private static final long AD_DURATION_US = 10 * C.MICROS_PER_SECOND;
+  private static final long FIRST_AD_START_TIME_US = 10 * C.MICROS_PER_SECOND;
+  private static final long SECOND_AD_START_TIME_US = 20 * C.MICROS_PER_SECOND;
+
+  private static final Timeline CONTENT_TIMELINE =
+      new SinglePeriodTimeline(CONTENT_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false);
+  private static final Uri AD_URI = Uri.EMPTY;
+
+  private MediaPeriodQueue mediaPeriodQueue;
+  private AdPlaybackState adPlaybackState;
+  private Timeline timeline;
+  private Object periodUid;
+
+  private PlaybackInfo playbackInfo;
+  private RendererCapabilities[] rendererCapabilities;
+  private TrackSelector trackSelector;
+  private Allocator allocator;
+  private MediaSource mediaSource;
+
+  @Before
+  public void setUp() {
+    mediaPeriodQueue = new MediaPeriodQueue();
+    mediaSource = mock(MediaSource.class);
+    rendererCapabilities = new RendererCapabilities[0];
+    trackSelector = mock(TrackSelector.class);
+    allocator = mock(Allocator.class);
+  }
+
+  @Test
+  public void getNextMediaPeriodInfo_withoutAds_returnsLastMediaPeriodInfo() {
+    setupTimeline(/* initialPositionUs= */ 0);
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ 0,
+        /* endPositionUs= */ C.TIME_UNSET,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ true,
+        /* nextAdGroupIndex= */ C.INDEX_UNSET);
+  }
+
+  @Test
+  public void getNextMediaPeriodInfo_withPrerollAd_returnsCorrectMediaPeriodInfos() {
+    setupTimeline(/* initialPositionUs= */ 0, /* adGroupTimesUs= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    assertNextMediaPeriodInfoIsAd(/* adGroupIndex= */ 0, /* contentPositionUs= */ 0);
+    advance();
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ 0,
+        /* endPositionUs= */ C.TIME_UNSET,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ true,
+        /* nextAdGroupIndex= */ C.INDEX_UNSET);
+  }
+
+  @Test
+  public void getNextMediaPeriodInfo_withMidrollAds_returnsCorrectMediaPeriodInfos() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ 0,
+        /* endPositionUs= */ FIRST_AD_START_TIME_US,
+        /* durationUs= */ FIRST_AD_START_TIME_US,
+        /* isLast= */ false,
+        /* nextAdGroupIndex= */ 0);
+    // The next media period info should be null as we haven't loaded the ad yet.
+    advance();
+    assertNull(getNextMediaPeriodInfo());
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    assertNextMediaPeriodInfoIsAd(
+        /* adGroupIndex= */ 0, /* contentPositionUs= */ FIRST_AD_START_TIME_US);
+    advance();
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ FIRST_AD_START_TIME_US,
+        /* endPositionUs= */ SECOND_AD_START_TIME_US,
+        /* durationUs= */ SECOND_AD_START_TIME_US,
+        /* isLast= */ false,
+        /* nextAdGroupIndex= */ 1);
+    advance();
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    assertNextMediaPeriodInfoIsAd(
+        /* adGroupIndex= */ 1, /* contentPositionUs= */ SECOND_AD_START_TIME_US);
+    advance();
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ SECOND_AD_START_TIME_US,
+        /* endPositionUs= */ C.TIME_UNSET,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ true,
+        /* nextAdGroupIndex= */ C.INDEX_UNSET);
+  }
+
+  @Test
+  public void getNextMediaPeriodInfo_withMidrollAndPostroll_returnsCorrectMediaPeriodInfos() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        C.TIME_END_OF_SOURCE);
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ 0,
+        /* endPositionUs= */ FIRST_AD_START_TIME_US,
+        /* durationUs= */ FIRST_AD_START_TIME_US,
+        /* isLast= */ false,
+        /* nextAdGroupIndex= */ 0);
+    advance();
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    assertNextMediaPeriodInfoIsAd(
+        /* adGroupIndex= */ 0, /* contentPositionUs= */ FIRST_AD_START_TIME_US);
+    advance();
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ FIRST_AD_START_TIME_US,
+        /* endPositionUs= */ C.TIME_END_OF_SOURCE,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ false,
+        /* nextAdGroupIndex= */ 1);
+    advance();
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    assertNextMediaPeriodInfoIsAd(
+        /* adGroupIndex= */ 1, /* contentPositionUs= */ CONTENT_DURATION_US);
+    advance();
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ CONTENT_DURATION_US,
+        /* endPositionUs= */ C.TIME_UNSET,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ true,
+        /* nextAdGroupIndex= */ C.INDEX_UNSET);
+  }
+
+  @Test
+  public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaPeriodInfo() {
+    setupTimeline(/* initialPositionUs= */ 0, /* adGroupTimesUs= */ C.TIME_END_OF_SOURCE);
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ 0,
+        /* endPositionUs= */ C.TIME_END_OF_SOURCE,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ false,
+        /* nextAdGroupIndex= */ 0);
+    advance();
+    setAdGroupFailedToLoad(/* adGroupIndex= */ 0);
+    assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+        /* startPositionUs= */ CONTENT_DURATION_US,
+        /* endPositionUs= */ C.TIME_UNSET,
+        /* durationUs= */ CONTENT_DURATION_US,
+        /* isLast= */ true,
+        /* nextAdGroupIndex= */ C.INDEX_UNSET);
+  }
+
+  @Test
+  public void
+      updateQueuedPeriods_withDurationChangeAfterReadingPeriod_handlesChangeAndRemovesPeriodsAfterChangedPeriod() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    enqueueNext(); // Content before first ad.
+    advancePlaying();
+    enqueueNext(); // First ad.
+    enqueueNext(); // Content between ads.
+    enqueueNext(); // Second ad.
+
+    // Change position of second ad (= change duration of content between ads).
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US + 1);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    boolean changeHandled =
+        mediaPeriodQueue.updateQueuedPeriods(
+            /* rendererPositionUs= */ 0, /* maxRendererReadPositionUs= */ 0);
+
+    assertThat(changeHandled).isTrue();
+    assertThat(getQueueLength()).isEqualTo(3);
+  }
+
+  @Test
+  public void
+      updateQueuedPeriods_withDurationChangeBeforeReadingPeriod_doesntHandleChangeAndRemovesPeriodsAfterChangedPeriod() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    enqueueNext(); // Content before first ad.
+    advancePlaying();
+    enqueueNext(); // First ad.
+    enqueueNext(); // Content between ads.
+    enqueueNext(); // Second ad.
+    advanceReading(); // Reading first ad.
+
+    // Change position of first ad (= change duration of content before first ad).
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US + 1,
+        SECOND_AD_START_TIME_US);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    boolean changeHandled =
+        mediaPeriodQueue.updateQueuedPeriods(
+            /* rendererPositionUs= */ 0, /* maxRendererReadPositionUs= */ FIRST_AD_START_TIME_US);
+
+    assertThat(changeHandled).isFalse();
+    assertThat(getQueueLength()).isEqualTo(1);
+  }
+
+  @Test
+  public void
+      updateQueuedPeriods_withDurationChangeInReadingPeriodAfterReadingPosition_handlesChangeAndRemovesPeriodsAfterChangedPeriod() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    enqueueNext(); // Content before first ad.
+    advancePlaying();
+    enqueueNext(); // First ad.
+    enqueueNext(); // Content between ads.
+    enqueueNext(); // Second ad.
+    advanceReading(); // Reading first ad.
+    advanceReading(); // Reading content between ads.
+
+    // Change position of second ad (= change duration of content between ads).
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US - 1000);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    long readingPositionAtStartOfContentBetweenAds = FIRST_AD_START_TIME_US + AD_DURATION_US;
+    boolean changeHandled =
+        mediaPeriodQueue.updateQueuedPeriods(
+            /* rendererPositionUs= */ 0,
+            /* maxRendererReadPositionUs= */ readingPositionAtStartOfContentBetweenAds);
+
+    assertThat(changeHandled).isTrue();
+    assertThat(getQueueLength()).isEqualTo(3);
+  }
+
+  @Test
+  public void
+      updateQueuedPeriods_withDurationChangeInReadingPeriodBeforeReadingPosition_doesntHandleChangeAndRemovesPeriodsAfterChangedPeriod() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    enqueueNext(); // Content before first ad.
+    advancePlaying();
+    enqueueNext(); // First ad.
+    enqueueNext(); // Content between ads.
+    enqueueNext(); // Second ad.
+    advanceReading(); // Reading first ad.
+    advanceReading(); // Reading content between ads.
+
+    // Change position of second ad (= change duration of content between ads).
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US - 1000);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    long readingPositionAtEndOfContentBetweenAds = SECOND_AD_START_TIME_US + AD_DURATION_US;
+    boolean changeHandled =
+        mediaPeriodQueue.updateQueuedPeriods(
+            /* rendererPositionUs= */ 0,
+            /* maxRendererReadPositionUs= */ readingPositionAtEndOfContentBetweenAds);
+
+    assertThat(changeHandled).isFalse();
+    assertThat(getQueueLength()).isEqualTo(3);
+  }
+
+  @Test
+  public void
+      updateQueuedPeriods_withDurationChangeInReadingPeriodReadToEnd_doesntHandleChangeAndRemovesPeriodsAfterChangedPeriod() {
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    enqueueNext(); // Content before first ad.
+    advancePlaying();
+    enqueueNext(); // First ad.
+    enqueueNext(); // Content between ads.
+    enqueueNext(); // Second ad.
+    advanceReading(); // Reading first ad.
+    advanceReading(); // Reading content between ads.
+
+    // Change position of second ad (= change duration of content between ads).
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US - 1000);
+    setAdGroupLoaded(/* adGroupIndex= */ 0);
+    setAdGroupLoaded(/* adGroupIndex= */ 1);
+    boolean changeHandled =
+        mediaPeriodQueue.updateQueuedPeriods(
+            /* rendererPositionUs= */ 0, /* maxRendererReadPositionUs= */ C.TIME_END_OF_SOURCE);
+
+    assertThat(changeHandled).isFalse();
+    assertThat(getQueueLength()).isEqualTo(3);
+  }
+
+  private void setupTimeline(long initialPositionUs, long... adGroupTimesUs) {
+    adPlaybackState =
+        new AdPlaybackState(adGroupTimesUs).withContentDurationUs(CONTENT_DURATION_US);
+    timeline = new SinglePeriodAdTimeline(CONTENT_TIMELINE, adPlaybackState);
+    periodUid = timeline.getUidOfPeriod(/* periodIndex= */ 0);
+    mediaPeriodQueue.setTimeline(timeline);
+    playbackInfo =
+        new PlaybackInfo(
+            timeline,
+            /* manifest= */ null,
+            mediaPeriodQueue.resolveMediaPeriodIdForAds(periodUid, initialPositionUs),
+            /* startPositionUs= */ 0,
+            /* contentPositionUs= */ 0,
+            Player.STATE_READY,
+            /* isLoading= */ false,
+            /* trackGroups= */ null,
+            /* trackSelectorResult= */ null,
+            /* loadingMediaPeriodId= */ null,
+            /* bufferedPositionUs= */ 0,
+            /* totalBufferedDurationUs= */ 0,
+            /* positionUs= */ 0);
+  }
+
+  private void advance() {
+    enqueueNext();
+    advancePlaying();
+  }
+
+  private void advancePlaying() {
+    mediaPeriodQueue.advancePlayingPeriod();
+  }
+
+  private void advanceReading() {
+    mediaPeriodQueue.advanceReadingPeriod();
+  }
+
+  private void enqueueNext() {
+    mediaPeriodQueue.enqueueNextMediaPeriod(
+        rendererCapabilities, trackSelector, allocator, mediaSource, getNextMediaPeriodInfo());
+  }
+
+  private MediaPeriodInfo getNextMediaPeriodInfo() {
+    return mediaPeriodQueue.getNextMediaPeriodInfo(/* rendererPositionUs= */ 0, playbackInfo);
+  }
+
+  private void setAdGroupLoaded(int adGroupIndex) {
+    long[][] newDurations = new long[adPlaybackState.adGroupCount][];
+    for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
+      newDurations[i] =
+          i == adGroupIndex ? new long[] {AD_DURATION_US} : adPlaybackState.adGroups[i].durationsUs;
+    }
+    adPlaybackState =
+        adPlaybackState
+            .withAdCount(adGroupIndex, /* adCount= */ 1)
+            .withAdUri(adGroupIndex, /* adIndexInAdGroup= */ 0, AD_URI)
+            .withAdDurationsUs(newDurations);
+    updateTimeline();
+  }
+
+  private void setAdGroupFailedToLoad(int adGroupIndex) {
+    adPlaybackState =
+        adPlaybackState
+            .withAdCount(adGroupIndex, /* adCount= */ 1)
+            .withAdLoadError(adGroupIndex, /* adIndexInAdGroup= */ 0);
+    updateTimeline();
+  }
+
+  private void updateTimeline() {
+    timeline = new SinglePeriodAdTimeline(CONTENT_TIMELINE, adPlaybackState);
+    mediaPeriodQueue.setTimeline(timeline);
+  }
+
+  private void assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
+      long startPositionUs,
+      long endPositionUs,
+      long durationUs,
+      boolean isLast,
+      int nextAdGroupIndex) {
+    assertThat(getNextMediaPeriodInfo())
+        .isEqualTo(
+            new MediaPeriodInfo(
+                new MediaPeriodId(periodUid, /* windowSequenceNumber= */ 0, nextAdGroupIndex),
+                startPositionUs,
+                /* contentPositionUs= */ C.TIME_UNSET,
+                endPositionUs,
+                durationUs,
+                /* isLastInTimelinePeriod= */ isLast,
+                /* isFinal= */ isLast));
+  }
+
+  private void assertNextMediaPeriodInfoIsAd(int adGroupIndex, long contentPositionUs) {
+    assertThat(getNextMediaPeriodInfo())
+        .isEqualTo(
+            new MediaPeriodInfo(
+                new MediaPeriodId(
+                    periodUid,
+                    adGroupIndex,
+                    /* adIndexInAdGroup= */ 0,
+                    /* windowSequenceNumber= */ 0),
+                /* startPositionUs= */ 0,
+                contentPositionUs,
+                /* endPositionUs= */ C.TIME_UNSET,
+                /* durationUs= */ AD_DURATION_US,
+                /* isLastInTimelinePeriod= */ false,
+                /* isFinal= */ false));
+  }
+
+  private int getQueueLength() {
+    int length = 0;
+    MediaPeriodHolder periodHolder = mediaPeriodQueue.getFrontPeriod();
+    while (periodHolder != null) {
+      length++;
+      periodHolder = periodHolder.getNext();
+    }
+    return length;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
index 88617ce8ec..d6e65cb34d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
@@ -15,15 +15,15 @@
  */
 package com.google.android.exoplayer2;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
 import com.google.android.exoplayer2.testutil.TimelineAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link Timeline}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class TimelineTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
index 3649685f3e..af9591d1b7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
@@ -19,8 +19,10 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -56,12 +58,10 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Integration test for {@link AnalyticsCollector}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public final class AnalyticsCollectorTest {
 
@@ -533,7 +533,7 @@ public void testReprepareAfterError() throws Exception {
         .containsExactly(WINDOW_0 /* prepared */, WINDOW_0 /* prepared */);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
         .containsExactly(period0Seq0, period0Seq0, period0Seq0, period0Seq0);
-    assertThat(listener.getEvents(EVENT_PLAYER_ERROR)).containsExactly(WINDOW_0);
+    assertThat(listener.getEvents(EVENT_PLAYER_ERROR)).containsExactly(period0Seq0);
     assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0Seq0, period0Seq0);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
@@ -727,7 +727,7 @@ private static TestAnalyticsListener runAnalyticsTest(
           .setRenderersFactory(renderersFactory)
           .setAnalyticsListener(listener)
           .setActionSchedule(actionSchedule)
-          .build(RuntimeEnvironment.application)
+          .build(ApplicationProvider.getApplicationContext())
           .start()
           .blockUntilActionScheduleFinished(TIMEOUT_MS)
           .blockUntilEnded(TIMEOUT_MS);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java
index e41e270966..8a7d0b6f06 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/Ac3UtilTest.java
@@ -17,13 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.Util;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link Ac3Util}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class Ac3UtilTest {
 
   private static final int TRUEHD_SYNCFRAME_SAMPLE_COUNT = 40;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
index 086c4ebc7f..272c944e46 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
@@ -22,19 +22,22 @@
 import static org.junit.Assert.fail;
 
 import android.content.Context;
+import android.media.AudioFocusRequest;
 import android.media.AudioManager;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.util.Util;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowAudioManager;
 
 /** Unit tests for {@link AudioFocusManager}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class AudioFocusManagerTest {
   private static final int NO_COMMAND_RECEIVED = ~PLAYER_COMMAND_WAIT_FOR_CALLBACK;
 
@@ -46,10 +49,12 @@
   @Before
   public void setUp() {
     audioManager =
-        (AudioManager) RuntimeEnvironment.application.getSystemService(Context.AUDIO_SERVICE);
+        (AudioManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
 
     testPlayerControl = new TestPlayerControl();
-    audioFocusManager = new AudioFocusManager(RuntimeEnvironment.application, testPlayerControl);
+    audioFocusManager =
+        new AudioFocusManager(ApplicationProvider.getApplicationContext(), testPlayerControl);
   }
 
   @Test
@@ -69,6 +74,7 @@ public void setAudioAttributes_withNullUsage_doesNotManageAudioFocus() {
   }
 
   @Test
+  @Config(maxSdk = 25)
   public void setAudioAttributes_withNullUsage_releasesAudioFocus() {
     // Create attributes and request audio focus.
     AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
@@ -92,6 +98,31 @@ public void setAudioAttributes_withNullUsage_releasesAudioFocus() {
     assertThat(lastRequest).isNotNull();
   }
 
+  @Test
+  @Config(minSdk = 26)
+  public void setAudioAttributes_withNullUsage_releasesAudioFocus_v26() {
+    // Create attributes and request audio focus.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(getAudioFocusGainFromRequest(request)).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+
+    // Ensure that setting null audio attributes with audio focus releases audio focus.
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    AudioFocusRequest lastRequest =
+        Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest();
+    assertThat(lastRequest).isNotNull();
+  }
+
   @Test
   public void setAudioAttributes_withUsageAlarm_throwsIllegalArgumentException() {
     // Ensure that audio attributes that map to AUDIOFOCUS_GAIN_TRANSIENT* throw
@@ -117,7 +148,7 @@ public void setAudioAttributes_withUsageMedia_usesAudioFocusGain() {
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
     ShadowAudioManager.AudioFocusRequest request =
         Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
-    assertThat(request.durationHint).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+    assertThat(getAudioFocusGainFromRequest(request)).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
   }
 
   @Test
@@ -133,7 +164,7 @@ public void setAudioAttributes_inStateEnded_requestsAudioFocus() {
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
     ShadowAudioManager.AudioFocusRequest request =
         Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
-    assertThat(request.durationHint).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+    assertThat(getAudioFocusGainFromRequest(request)).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
   }
 
   @Test
@@ -189,12 +220,12 @@ public void onAudioFocusChange_withDuckEnabled_volumeReducedAndRestored() {
                 media, /* playWhenReady= */ true, Player.STATE_READY))
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
 
-    ShadowAudioManager.AudioFocusRequest request =
-        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
-    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+    audioFocusManager
+        .getFocusListener()
+        .onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
     assertThat(testPlayerControl.lastVolumeMultiplier).isLessThan(1.0f);
     assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(NO_COMMAND_RECEIVED);
-    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+    audioFocusManager.getFocusListener().onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
     assertThat(testPlayerControl.lastVolumeMultiplier).isEqualTo(1.0f);
   }
 
@@ -215,12 +246,12 @@ public void onAudioFocusChange_withPausedWhenDucked_sendsCommandWaitForCallback(
                 media, /* playWhenReady= */ true, Player.STATE_READY))
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
 
-    ShadowAudioManager.AudioFocusRequest request =
-        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
-    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+    audioFocusManager
+        .getFocusListener()
+        .onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
     assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
     assertThat(testPlayerControl.lastVolumeMultiplier).isEqualTo(1.0f);
-    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+    audioFocusManager.getFocusListener().onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
     assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
   }
 
@@ -237,14 +268,13 @@ public void onAudioFocusChange_withTransientLost_sendsCommandWaitForCallback() {
                 media, /* playWhenReady= */ true, Player.STATE_READY))
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
 
-    ShadowAudioManager.AudioFocusRequest request =
-        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
-    request.listener.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);
+    audioFocusManager.getFocusListener().onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);
     assertThat(testPlayerControl.lastVolumeMultiplier).isEqualTo(1.0f);
     assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
   }
 
   @Test
+  @Config(maxSdk = 25)
   public void onAudioFocusChange_withAudioFocusLost_sendsDoNotPlayAndAbandondsFocus() {
     // Ensure that AUDIOFOCUS_LOSS causes AudioFocusManager to pause playback and abandon audio
     // focus.
@@ -271,6 +301,32 @@ public void onAudioFocusChange_withAudioFocusLost_sendsDoNotPlayAndAbandondsFocu
   }
 
   @Test
+  @Config(minSdk = 26)
+  public void onAudioFocusChange_withAudioFocusLost_sendsDoNotPlayAndAbandondsFocus_v26() {
+    // Ensure that AUDIOFOCUS_LOSS causes AudioFocusManager to pause playback and abandon audio
+    // focus.
+    AudioAttributes media =
+        new AudioAttributes.Builder()
+            .setUsage(C.USAGE_MEDIA)
+            .setContentType(C.CONTENT_TYPE_SPEECH)
+            .build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest()).isNull();
+
+    audioFocusManager.getFocusListener().onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
+    assertThat(testPlayerControl.lastPlayerCommand).isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest())
+        .isEqualTo(Shadows.shadowOf(audioManager).getLastAudioFocusRequest().audioFocusRequest);
+  }
+
+  @Test
+  @Config(maxSdk = 25)
   public void handleStop_withAudioFocus_abandonsAudioFocus() {
     // Ensure that handleStop causes AudioFocusManager to abandon audio focus.
     AudioAttributes media =
@@ -295,6 +351,32 @@ public void handleStop_withAudioFocus_abandonsAudioFocus() {
   }
 
   @Test
+  @Config(minSdk = 26)
+  public void handleStop_withAudioFocus_abandonsAudioFocus_v26() {
+    // Ensure that handleStop causes AudioFocusManager to abandon audio focus.
+    AudioAttributes media =
+        new AudioAttributes.Builder()
+            .setUsage(C.USAGE_MEDIA)
+            .setContentType(C.CONTENT_TYPE_SPEECH)
+            .build();
+
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest()).isNull();
+
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    audioFocusManager.handleStop();
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest())
+        .isEqualTo(request.audioFocusRequest);
+  }
+
+  @Test
+  @Config(maxSdk = 25)
   public void handleStop_withoutAudioFocus_stillAbandonsFocus() {
     // Ensure that handleStop causes AudioFocusManager to call through to abandon audio focus
     // even if focus wasn't requested.
@@ -320,6 +402,7 @@ public void handleStop_withoutAudioFocus_stillAbandonsFocus() {
   }
 
   @Test
+  @Config(maxSdk = 25)
   public void handleStop_withoutHandlingAudioFocus_isNoOp() {
     // Ensure that handleStop is a no-op if audio focus isn't handled.
     Shadows.shadowOf(audioManager)
@@ -337,6 +420,31 @@ public void handleStop_withoutHandlingAudioFocus_isNoOp() {
     assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
   }
 
+  @Test
+  @Config(minSdk = 26)
+  public void handleStop_withoutHandlingAudioFocus_isNoOp_v26() {
+    // Ensure that handleStop is a no-op if audio focus isn't handled.
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ false, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest()).isNull();
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request).isNull();
+
+    audioFocusManager.handleStop();
+    assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusRequest()).isNull();
+  }
+
+  private int getAudioFocusGainFromRequest(ShadowAudioManager.AudioFocusRequest audioFocusRequest) {
+    return Util.SDK_INT >= 26
+        ? audioFocusRequest.audioFocusRequest.getFocusGain()
+        : audioFocusRequest.durationHint;
+  }
+
   private static class TestPlayerControl implements AudioFocusManager.PlayerControl {
     private float lastVolumeMultiplier = 1.0f;
     private int lastPlayerCommand = NO_COMMAND_RECEIVED;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java
new file mode 100644
index 0000000000..d41c99183d
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.OLDEST_SDK;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.PlaybackParameters;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link DefaultAudioSink}.
+ *
+ * <p>Note: the Robolectric-provided AudioTrack instantiated in the audio sink uses only the Java
+ * part of AudioTrack with a {@code ShadowPlayerBase} underneath. This means it will not consume
+ * data (i.e., the {@link android.media.AudioTrack#write} methods just return 0), so these tests are
+ * currently limited to verifying behavior that doesn't rely on consuming data, and the position
+ * will stay at its initial value. For example, we can't verify {@link
+ * AudioSink#handleBuffer(ByteBuffer, long)} handling a complete buffer, or queueing audio then
+ * draining to the end of the stream. This could be worked around by having a test-only mode where
+ * {@link DefaultAudioSink} automatically treats audio as consumed.
+ */
+@RunWith(AndroidJUnit4.class)
+public final class DefaultAudioSinkTest {
+
+  private static final int CHANNEL_COUNT_MONO = 1;
+  private static final int CHANNEL_COUNT_STEREO = 2;
+  private static final int BYTES_PER_FRAME_16_BIT = 2;
+  private static final int SAMPLE_RATE_44_1 = 44100;
+  private static final int TRIM_100_MS_FRAME_COUNT = 4410;
+  private static final int TRIM_10_MS_FRAME_COUNT = 441;
+
+  private DefaultAudioSink defaultAudioSink;
+  private ArrayAudioBufferSink arrayAudioBufferSink;
+
+  @Before
+  public void setUp() {
+    // For capturing output.
+    arrayAudioBufferSink = new ArrayAudioBufferSink();
+    TeeAudioProcessor teeAudioProcessor = new TeeAudioProcessor(arrayAudioBufferSink);
+    defaultAudioSink =
+        new DefaultAudioSink(
+            AudioCapabilities.DEFAULT_AUDIO_CAPABILITIES,
+            new DefaultAudioSink.DefaultAudioProcessorChain(teeAudioProcessor),
+            /* enableConvertHighResIntPcmToFloat= */ false);
+  }
+
+  @Test
+  public void handlesBufferAfterReset() throws Exception {
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    // After reset and re-configure we can successfully queue more input.
+    defaultAudioSink.reset();
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+  }
+
+  @Test
+  public void handlesBufferAfterReset_withPlaybackParameters() throws Exception {
+    PlaybackParameters playbackParameters = new PlaybackParameters(1.5f);
+    defaultAudioSink.setPlaybackParameters(playbackParameters);
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    // After reset and re-configure we can successfully queue more input.
+    defaultAudioSink.reset();
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+    assertThat(defaultAudioSink.getPlaybackParameters()).isEqualTo(playbackParameters);
+  }
+
+  @Test
+  public void handlesBufferAfterReset_withFormatChange() throws Exception {
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    // After reset and re-configure we can successfully queue more input.
+    defaultAudioSink.reset();
+    configureDefaultAudioSink(CHANNEL_COUNT_MONO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+  }
+
+  @Test
+  public void handlesBufferAfterReset_withFormatChangeAndPlaybackParameters() throws Exception {
+    PlaybackParameters playbackParameters = new PlaybackParameters(1.5f);
+    defaultAudioSink.setPlaybackParameters(playbackParameters);
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    // After reset and re-configure we can successfully queue more input.
+    defaultAudioSink.reset();
+    configureDefaultAudioSink(CHANNEL_COUNT_MONO);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+    assertThat(defaultAudioSink.getPlaybackParameters()).isEqualTo(playbackParameters);
+  }
+
+  @Test
+  public void trimsStartFrames() throws Exception {
+    configureDefaultAudioSink(
+        CHANNEL_COUNT_STEREO,
+        /* trimStartFrames= */ TRIM_100_MS_FRAME_COUNT,
+        /* trimEndFrames= */ 0);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    assertThat(arrayAudioBufferSink.output)
+        .hasLength(
+            (BYTES_PER_FRAME_16_BIT
+                * CHANNEL_COUNT_STEREO
+                * (SAMPLE_RATE_44_1 - TRIM_100_MS_FRAME_COUNT)));
+  }
+
+  @Test
+  public void trimsEndFrames() throws Exception {
+    configureDefaultAudioSink(
+        CHANNEL_COUNT_STEREO,
+        /* trimStartFrames= */ 0,
+        /* trimEndFrames= */ TRIM_10_MS_FRAME_COUNT);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    assertThat(arrayAudioBufferSink.output)
+        .hasLength(
+            (BYTES_PER_FRAME_16_BIT
+                * CHANNEL_COUNT_STEREO
+                * (SAMPLE_RATE_44_1 - TRIM_10_MS_FRAME_COUNT)));
+  }
+
+  @Test
+  public void trimsStartAndEndFrames() throws Exception {
+    configureDefaultAudioSink(
+        CHANNEL_COUNT_STEREO,
+        /* trimStartFrames= */ TRIM_100_MS_FRAME_COUNT,
+        /* trimEndFrames= */ TRIM_10_MS_FRAME_COUNT);
+    defaultAudioSink.handleBuffer(createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0);
+
+    assertThat(arrayAudioBufferSink.output)
+        .hasLength(
+            (BYTES_PER_FRAME_16_BIT
+                * CHANNEL_COUNT_STEREO
+                * (SAMPLE_RATE_44_1 - TRIM_100_MS_FRAME_COUNT - TRIM_10_MS_FRAME_COUNT)));
+  }
+
+  @Test
+  public void getCurrentPosition_returnsPositionFromFirstBuffer() throws Exception {
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(
+        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND);
+    assertThat(defaultAudioSink.getCurrentPositionUs(/* sourceEnded= */ false))
+        .isEqualTo(5 * C.MICROS_PER_SECOND);
+
+    defaultAudioSink.reset();
+    configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
+    defaultAudioSink.handleBuffer(
+        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 8 * C.MICROS_PER_SECOND);
+    assertThat(defaultAudioSink.getCurrentPositionUs(/* sourceEnded= */ false))
+        .isEqualTo(8 * C.MICROS_PER_SECOND);
+  }
+
+  @Config(minSdk = OLDEST_SDK, maxSdk = 20)
+  @Test
+  public void doesNotSupportFloatOutputBeforeApi21() {
+    assertThat(defaultAudioSink.supportsOutput(CHANNEL_COUNT_STEREO, C.ENCODING_PCM_FLOAT))
+        .isFalse();
+  }
+
+  @Config(minSdk = 21, maxSdk = NEWEST_SDK)
+  @Test
+  public void supportsFloatOutputFromApi21() {
+    assertThat(defaultAudioSink.supportsOutput(CHANNEL_COUNT_STEREO, C.ENCODING_PCM_FLOAT))
+        .isTrue();
+  }
+
+  private void configureDefaultAudioSink(int channelCount) throws AudioSink.ConfigurationException {
+    configureDefaultAudioSink(channelCount, /* trimStartFrames= */ 0, /* trimEndFrames= */ 0);
+  }
+
+  private void configureDefaultAudioSink(int channelCount, int trimStartFrames, int trimEndFrames)
+      throws AudioSink.ConfigurationException {
+    defaultAudioSink.configure(
+        C.ENCODING_PCM_16BIT,
+        channelCount,
+        SAMPLE_RATE_44_1,
+        /* specifiedBufferSize= */ 0,
+        /* outputChannels= */ null,
+        /* trimStartFrames= */ trimStartFrames,
+        /* trimEndFrames= */ trimEndFrames);
+  }
+
+  /** Creates a one second silence buffer for 44.1 kHz stereo 16-bit audio. */
+  private static ByteBuffer createDefaultSilenceBuffer() {
+    return ByteBuffer.allocateDirect(
+            SAMPLE_RATE_44_1 * CHANNEL_COUNT_STEREO * BYTES_PER_FRAME_16_BIT)
+        .order(ByteOrder.nativeOrder());
+  }
+
+  private static final class ArrayAudioBufferSink implements TeeAudioProcessor.AudioBufferSink {
+
+    private byte[] output;
+
+    public ArrayAudioBufferSink() {
+      output = new byte[0];
+    }
+
+    @Override
+    public void flush(int sampleRateHz, int channelCount, int encoding) {
+      output = new byte[0];
+    }
+
+    @Override
+    public void handleBuffer(ByteBuffer buffer) {
+      int position = buffer.position();
+      int remaining = buffer.remaining();
+      output = Arrays.copyOf(output, output.length + remaining);
+      buffer.get(output, 0, remaining);
+      buffer.position(position);
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java
index bd559218c6..128591124d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessorTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.audio.AudioProcessor.UnhandledFormatException;
 import com.google.android.exoplayer2.util.Assertions;
@@ -26,10 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link SilenceSkippingAudioProcessor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class SilenceSkippingAudioProcessorTest {
 
   private static final int TEST_SIGNAL_SAMPLE_RATE_HZ = 1000;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
index 8dc60a15a4..950061e9bc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
@@ -24,6 +24,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererConfiguration;
@@ -39,13 +40,10 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/**
- * Unit test for {@link SimpleDecoderAudioRenderer}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link SimpleDecoderAudioRenderer}. */
+@RunWith(AndroidJUnit4.class)
 public class SimpleDecoderAudioRendererTest {
 
   private static final Format FORMAT = Format.createSampleFormat(null, MimeTypes.AUDIO_RAW, 0);
@@ -103,7 +101,8 @@ public void testImmediatelyReadEndOfStreamPlaysAudioSinkToEndOfStream() throws E
     }
     verify(mockAudioSink, times(1)).playToEndOfStream();
     audioRenderer.disable();
-    verify(mockAudioSink, times(1)).release();
+    audioRenderer.reset();
+    verify(mockAudioSink, times(1)).reset();
   }
 
   private static final class FakeDecoder
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
index 1ba462d4af..837d7a97a4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
@@ -18,16 +18,14 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link SonicAudioProcessor}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link SonicAudioProcessor}. */
+@RunWith(AndroidJUnit4.class)
 public final class SonicAudioProcessorTest {
 
   private SonicAudioProcessor sonicAudioProcessor;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/database/VersionTableTest.java b/library/core/src/test/java/com/google/android/exoplayer2/database/VersionTableTest.java
new file mode 100644
index 0000000000..08b0c52fe5
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/database/VersionTableTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.database;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.database.sqlite.SQLiteDatabase;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link VersionTable}. */
+@RunWith(AndroidJUnit4.class)
+public class VersionTableTest {
+
+  private static final int FEATURE_1 = 1;
+  private static final int FEATURE_2 = 2;
+  private static final String INSTANCE_1 = "1";
+  private static final String INSTANCE_2 = "2";
+
+  private DatabaseProvider databaseProvider;
+  private SQLiteDatabase database;
+
+  @Before
+  public void setUp() {
+    databaseProvider = TestUtil.getTestDatabaseProvider();
+    database = databaseProvider.getWritableDatabase();
+  }
+
+  @Test
+  public void getVersion_unsetFeature_returnsVersionUnset() throws DatabaseIOException {
+    int version = VersionTable.getVersion(database, FEATURE_1, INSTANCE_1);
+    assertThat(version).isEqualTo(VersionTable.VERSION_UNSET);
+  }
+
+  @Test
+  public void getVersion_unsetVersion_returnsVersionUnset() throws DatabaseIOException {
+    VersionTable.setVersion(database, FEATURE_1, INSTANCE_1, 1);
+    int version = VersionTable.getVersion(database, FEATURE_1, INSTANCE_2);
+    assertThat(version).isEqualTo(VersionTable.VERSION_UNSET);
+  }
+
+  @Test
+  public void getVersion_returnsSetVersion() throws DatabaseIOException {
+    VersionTable.setVersion(database, FEATURE_1, INSTANCE_1, 1);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_1)).isEqualTo(1);
+
+    VersionTable.setVersion(database, FEATURE_1, INSTANCE_1, 2);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_1)).isEqualTo(2);
+
+    VersionTable.setVersion(database, FEATURE_2, INSTANCE_1, 3);
+    assertThat(VersionTable.getVersion(database, FEATURE_2, INSTANCE_1)).isEqualTo(3);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_1)).isEqualTo(2);
+
+    VersionTable.setVersion(database, FEATURE_2, INSTANCE_2, 4);
+    assertThat(VersionTable.getVersion(database, FEATURE_2, INSTANCE_2)).isEqualTo(4);
+    assertThat(VersionTable.getVersion(database, FEATURE_2, INSTANCE_1)).isEqualTo(3);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_1)).isEqualTo(2);
+  }
+
+  @Test
+  public void removeVersion_removesSetVersion() throws DatabaseIOException {
+    VersionTable.setVersion(database, FEATURE_1, INSTANCE_1, 1);
+    VersionTable.setVersion(database, FEATURE_1, INSTANCE_2, 2);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_1)).isEqualTo(1);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_2)).isEqualTo(2);
+
+    VersionTable.removeVersion(database, FEATURE_1, INSTANCE_1);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_1))
+        .isEqualTo(VersionTable.VERSION_UNSET);
+    assertThat(VersionTable.getVersion(database, FEATURE_1, INSTANCE_2)).isEqualTo(2);
+  }
+
+  @Test
+  public void doesTableExist_nonExistingTable_returnsFalse() {
+    assertThat(VersionTable.tableExists(database, "NonExistingTable")).isFalse();
+  }
+
+  @Test
+  public void doesTableExist_existingTable_returnsTrue() {
+    String table = "TestTable";
+    databaseProvider.getWritableDatabase().execSQL("CREATE TABLE " + table + " (dummy INTEGER)");
+    assertThat(VersionTable.tableExists(database, table)).isTrue();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
index 460a237698..d12319ad46 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
@@ -17,16 +17,14 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.Util;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/**
- * Unit test for {@link ClearKeyUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link ClearKeyUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class ClearKeyUtilTest {
 
   private static final byte[] SINGLE_KEY_RESPONSE =
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
index 2b740de113..36287d0579 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
@@ -22,6 +22,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -29,12 +30,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link DrmInitData}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link DrmInitData}. */
+@RunWith(AndroidJUnit4.class)
 public class DrmInitDataTest {
 
   private static final SchemeData DATA_1 = new SchemeData(WIDEVINE_UUID, VIDEO_MP4,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
index 6f62b7fcfc..30dde1db57 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
@@ -21,6 +21,7 @@
 import static org.mockito.Mockito.when;
 
 import android.util.Pair;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.testutil.RobolectricUtil;
@@ -31,11 +32,10 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 /** Tests {@link OfflineLicenseHelper}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public class OfflineLicenseHelperTest {
 
@@ -92,9 +92,12 @@ public void testDownloadLicenseFailsIfNullInitData() throws Exception {
   public void testDownloadLicenseFailsIfNoKeySetIdIsReturned() throws Exception {
     setStubLicenseAndPlaybackDurationValues(1000, 200);
 
-    byte[] offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(newDrmInitData());
-
-    assertThat(offlineLicenseKeySetId).isNull();
+    try {
+      offlineLicenseHelper.downloadLicense(newDrmInitData());
+      fail();
+    } catch (Exception e) {
+      // Expected.
+    }
   }
 
   @Test
@@ -145,7 +148,7 @@ private void setDefaultStubKeySetId()
 
   private void setStubKeySetId(byte[] keySetId)
       throws android.media.NotProvisionedException, android.media.DeniedByServerException {
-    when(mediaDrm.provideKeyResponse(any(byte[].class), any(byte[].class))).thenReturn(keySetId);
+    when(mediaDrm.provideKeyResponse(any(byte[].class), any())).thenReturn(keySetId);
   }
 
   private static void assertOfflineLicenseKeySetIdEqual(
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java
index 0fa33dd348..bc3ccf499f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ConstantBitrateSeekMapTest.java
@@ -18,13 +18,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link ConstantBitrateSeekMap}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class ConstantBitrateSeekMapTest {
 
   private ConstantBitrateSeekMap constantBitrateSeekMap;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
index 8b26361578..6dbec3ecf4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
@@ -22,6 +22,7 @@
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -30,12 +31,9 @@
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link DefaultExtractorInput}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link DefaultExtractorInput}. */
+@RunWith(AndroidJUnit4.class)
 public class DefaultExtractorInputTest {
 
   private static final String TEST_URI = "http://www.google.com";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactoryTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactoryTest.java
index 148e04ca77..be9100cb9d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactoryTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactoryTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.amr.AmrExtractor;
 import com.google.android.exoplayer2.extractor.flv.FlvExtractor;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
@@ -25,6 +26,7 @@
 import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
 import com.google.android.exoplayer2.extractor.ogg.OggExtractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.Ac4Extractor;
 import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
 import com.google.android.exoplayer2.extractor.ts.PsExtractor;
 import com.google.android.exoplayer2.extractor.ts.TsExtractor;
@@ -33,10 +35,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link DefaultExtractorsFactory}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DefaultExtractorsFactoryTest {
 
   @Test
@@ -62,7 +63,8 @@ public void testCreateExtractors_returnExpectedClasses() {
           OggExtractor.class,
           PsExtractor.class,
           WavExtractor.class,
-          AmrExtractor.class
+          AmrExtractor.class,
+          Ac4Extractor.class
         };
 
     assertThat(listCreatedExtractorClasses).containsNoDuplicates();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
index 3271e1ddf6..0401b2be83 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
@@ -17,15 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link Extractor}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link Extractor}. */
+@RunWith(AndroidJUnit4.class)
 public final class ExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java
index f43f356482..59e904a5a4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/Id3PeekerTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
@@ -26,10 +27,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link Id3Peeker}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class Id3PeekerTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java
index 9f9051087d..d131fce6b7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorSeekTest.java
@@ -18,6 +18,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
@@ -30,11 +32,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link AmrExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AmrExtractorSeekTest {
 
   private static final Random random = new Random(1234L);
@@ -51,7 +51,7 @@
   @Before
   public void setUp() {
     dataSource =
-        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+        new DefaultDataSourceFactory(ApplicationProvider.getApplicationContext(), "UserAgent")
             .createDataSource();
   }
 
@@ -62,7 +62,7 @@ public void testAmrExtractorReads_returnSeekableSeekMap_forNarrowBandAmr()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
 
@@ -82,7 +82,7 @@ public void testSeeking_handlesSeekingToPositionInFile_extractsCorrectFrame_forN
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
 
@@ -109,7 +109,7 @@ public void testSeeking_handlesSeekToEoF_extractsLastFrame_forNarrowBandAmr()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -136,7 +136,7 @@ public void testSeeking_handlesSeekingBackward_extractsCorrectFrames_forNarrowBa
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -165,7 +165,7 @@ public void testSeeking_handlesSeekingForward_extractsCorrectFrames_forNarrowBan
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -194,7 +194,7 @@ public void testSeeking_handlesRandomSeeks_extractsCorrectFrames_forNarrowBandAm
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -223,7 +223,7 @@ public void testAmrExtractorReads_returnSeekableSeekMap_forWideBandAmr()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
 
@@ -243,7 +243,7 @@ public void testSeeking_handlesSeekingToPositionInFile_extractsCorrectFrame_forW
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
 
@@ -270,7 +270,7 @@ public void testSeeking_handlesSeekToEoF_extractsLastFrame_forWideBandAmr()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -297,7 +297,7 @@ public void testSeeking_handlesSeekingBackward_extractsCorrectFrames_forWideBand
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -326,7 +326,7 @@ public void testSeeking_handlesSeekingForward_extractsCorrectFrames_forWideBandA
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
@@ -355,7 +355,7 @@ public void testSeeking_handlesRandomSeeks_extractsCorrectFrames_forWideBandAmr(
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAmrExtractor(), RuntimeEnvironment.application, fileName)
+                createAmrExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AmrExtractor extractor = createAmrExtractor();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java
index c3c33e3350..de7642a94b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/amr/AmrExtractorTest.java
@@ -22,7 +22,8 @@
 import static com.google.common.truth.Truth.assertThat;
 import static junit.framework.Assert.fail;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.PositionHolder;
@@ -34,10 +35,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link AmrExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AmrExtractorTest {
 
   private static final Random RANDOM = new Random(1234);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
index 316148d9b9..e0505095fe 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link FlvExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class FlvExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
index 7383f8a538..642b9946ed 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -26,30 +27,27 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests {@link DefaultEbmlReader}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests {@link DefaultEbmlReader}. */
+@RunWith(AndroidJUnit4.class)
 public class DefaultEbmlReaderTest {
 
   @Test
   public void testMasterElement() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x1A, 0x45, 0xDF, 0xA3, 0x84, 0x42, 0x85, 0x81, 0x01);
-    TestOutput expected = new TestOutput();
-    expected.startMasterElement(TestOutput.ID_EBML, 5, 4);
-    expected.integerElement(TestOutput.ID_DOC_TYPE_READ_VERSION, 1);
-    expected.endMasterElement(TestOutput.ID_EBML);
+    TestProcessor expected = new TestProcessor();
+    expected.startMasterElement(TestProcessor.ID_EBML, 5, 4);
+    expected.integerElement(TestProcessor.ID_DOC_TYPE_READ_VERSION, 1);
+    expected.endMasterElement(TestProcessor.ID_EBML);
     assertEvents(input, expected.events);
   }
 
   @Test
   public void testMasterElementEmpty() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x18, 0x53, 0x80, 0x67, 0x80);
-    TestOutput expected = new TestOutput();
-    expected.startMasterElement(TestOutput.ID_SEGMENT, 5, 0);
-    expected.endMasterElement(TestOutput.ID_SEGMENT);
+    TestProcessor expected = new TestProcessor();
+    expected.startMasterElement(TestProcessor.ID_SEGMENT, 5, 0);
+    expected.endMasterElement(TestProcessor.ID_SEGMENT);
     assertEvents(input, expected.events);
   }
 
@@ -57,8 +55,8 @@ public void testMasterElementEmpty() throws IOException, InterruptedException {
   public void testUnsignedIntegerElement() throws IOException, InterruptedException {
     // 0xFE is chosen because for signed integers it should be interpreted as -2
     ExtractorInput input = createTestInput(0x42, 0xF7, 0x81, 0xFE);
-    TestOutput expected = new TestOutput();
-    expected.integerElement(TestOutput.ID_EBML_READ_VERSION, 254);
+    TestProcessor expected = new TestProcessor();
+    expected.integerElement(TestProcessor.ID_EBML_READ_VERSION, 254);
     assertEvents(input, expected.events);
   }
 
@@ -66,8 +64,8 @@ public void testUnsignedIntegerElement() throws IOException, InterruptedExceptio
   public void testUnsignedIntegerElementLarge() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x42, 0xF7, 0x88, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
-    TestOutput expected = new TestOutput();
-    expected.integerElement(TestOutput.ID_EBML_READ_VERSION, Long.MAX_VALUE);
+    TestProcessor expected = new TestProcessor();
+    expected.integerElement(TestProcessor.ID_EBML_READ_VERSION, Long.MAX_VALUE);
     assertEvents(input, expected.events);
   }
 
@@ -76,32 +74,32 @@ public void testUnsignedIntegerElementTooLargeBecomesNegative()
       throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x42, 0xF7, 0x88, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
-    TestOutput expected = new TestOutput();
-    expected.integerElement(TestOutput.ID_EBML_READ_VERSION, -1);
+    TestProcessor expected = new TestProcessor();
+    expected.integerElement(TestProcessor.ID_EBML_READ_VERSION, -1);
     assertEvents(input, expected.events);
   }
 
   @Test
   public void testStringElement() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x42, 0x82, 0x86, 0x41, 0x62, 0x63, 0x31, 0x32, 0x33);
-    TestOutput expected = new TestOutput();
-    expected.stringElement(TestOutput.ID_DOC_TYPE, "Abc123");
+    TestProcessor expected = new TestProcessor();
+    expected.stringElement(TestProcessor.ID_DOC_TYPE, "Abc123");
     assertEvents(input, expected.events);
   }
 
   @Test
   public void testStringElementWithZeroPadding() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x42, 0x82, 0x86, 0x41, 0x62, 0x63, 0x00, 0x00, 0x00);
-    TestOutput expected = new TestOutput();
-    expected.stringElement(TestOutput.ID_DOC_TYPE, "Abc");
+    TestProcessor expected = new TestProcessor();
+    expected.stringElement(TestProcessor.ID_DOC_TYPE, "Abc");
     assertEvents(input, expected.events);
   }
 
   @Test
   public void testStringElementEmpty() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x42, 0x82, 0x80);
-    TestOutput expected = new TestOutput();
-    expected.stringElement(TestOutput.ID_DOC_TYPE, "");
+    TestProcessor expected = new TestProcessor();
+    expected.stringElement(TestProcessor.ID_DOC_TYPE, "");
     assertEvents(input, expected.events);
   }
 
@@ -109,8 +107,8 @@ public void testStringElementEmpty() throws IOException, InterruptedException {
   public void testFloatElementFourBytes() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x44, 0x89, 0x84, 0x3F, 0x80, 0x00, 0x00);
-    TestOutput expected = new TestOutput();
-    expected.floatElement(TestOutput.ID_DURATION, 1.0);
+    TestProcessor expected = new TestProcessor();
+    expected.floatElement(TestProcessor.ID_DURATION, 1.0);
     assertEvents(input, expected.events);
   }
 
@@ -118,8 +116,8 @@ public void testFloatElementFourBytes() throws IOException, InterruptedException
   public void testFloatElementEightBytes() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x44, 0x89, 0x88, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
-    TestOutput expected = new TestOutput();
-    expected.floatElement(TestOutput.ID_DURATION, -2.0);
+    TestProcessor expected = new TestProcessor();
+    expected.floatElement(TestProcessor.ID_DURATION, -2.0);
     assertEvents(input, expected.events);
   }
 
@@ -127,8 +125,10 @@ public void testFloatElementEightBytes() throws IOException, InterruptedExceptio
   public void testBinaryElement() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0xA3, 0x88, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08);
-    TestOutput expected = new TestOutput();
-    expected.binaryElement(TestOutput.ID_SIMPLE_BLOCK, 8,
+    TestProcessor expected = new TestProcessor();
+    expected.binaryElement(
+        TestProcessor.ID_SIMPLE_BLOCK,
+        8,
         createTestInput(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08));
     assertEvents(input, expected.events);
   }
@@ -136,7 +136,7 @@ public void testBinaryElement() throws IOException, InterruptedException {
   private static void assertEvents(ExtractorInput input, List<String> expectedEvents)
       throws IOException, InterruptedException {
     DefaultEbmlReader reader = new DefaultEbmlReader();
-    TestOutput output = new TestOutput();
+    TestProcessor output = new TestProcessor();
     reader.init(output);
 
     // We expect the number of successful reads to equal the number of expected events.
@@ -164,10 +164,8 @@ private static ExtractorInput createTestInput(int... data) {
         .build();
   }
 
-  /**
-   * An {@link EbmlReaderOutput} that records each event callback.
-   */
-  private static final class TestOutput implements EbmlReaderOutput {
+  /** An {@link EbmlProcessor} that records each event callback. */
+  private static final class TestProcessor implements EbmlProcessor {
 
     // Element IDs
     private static final int ID_EBML = 0x1A45DFA3;
@@ -182,22 +180,23 @@ private static ExtractorInput createTestInput(int... data) {
     private final List<String> events = new ArrayList<>();
 
     @Override
-    public @ElementType int getElementType(int id) {
+    @EbmlProcessor.ElementType
+    public int getElementType(int id) {
       switch (id) {
         case ID_EBML:
         case ID_SEGMENT:
-          return TYPE_MASTER;
+          return EbmlProcessor.ELEMENT_TYPE_MASTER;
         case ID_EBML_READ_VERSION:
         case ID_DOC_TYPE_READ_VERSION:
-          return TYPE_UNSIGNED_INT;
+          return EbmlProcessor.ELEMENT_TYPE_UNSIGNED_INT;
         case ID_DOC_TYPE:
-          return TYPE_STRING;
+          return EbmlProcessor.ELEMENT_TYPE_STRING;
         case ID_SIMPLE_BLOCK:
-          return TYPE_BINARY;
+          return EbmlProcessor.ELEMENT_TYPE_BINARY;
         case ID_DURATION:
-          return TYPE_FLOAT;
+          return EbmlProcessor.ELEMENT_TYPE_FLOAT;
         default:
-          return TYPE_UNKNOWN;
+          return EbmlProcessor.ELEMENT_TYPE_UNKNOWN;
       }
     }
 
@@ -219,12 +218,12 @@ public void endMasterElement(int id) {
 
     @Override
     public void integerElement(int id, long value) {
-      events.add(formatEvent(id, "integer=" + String.valueOf(value)));
+      events.add(formatEvent(id, "integer=" + value));
     }
 
     @Override
     public void floatElement(int id, double value) {
-      events.add(formatEvent(id, "float=" + String.valueOf(value)));
+      events.add(formatEvent(id, "float=" + value));
     }
 
     @Override
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
index 2e673037d0..9c20a9668f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link MatroskaExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class MatroskaExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
index a13a185b3e..86df3f50e3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
@@ -20,6 +20,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
@@ -28,12 +29,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link VarintReader}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link VarintReader}. */
+@RunWith(AndroidJUnit4.class)
 public final class VarintReaderTest {
 
   private static final byte MAX_BYTE = (byte) 0xFF;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
index 62a4f1a193..670296cc13 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link Mp3Extractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class Mp3ExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
index 6df40b5dcc..96fee1d07a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.SeekMap.SeekPoints;
@@ -26,12 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link XingSeeker}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link XingSeeker}. */
+@RunWith(AndroidJUnit4.class)
 public final class XingSeekerTest {
 
   // Xing header/payload from http://storage.googleapis.com/exoplayer-test-media-0/play.mp3.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
index 9c7f0e8acc..712f8e43fe 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
@@ -17,16 +17,14 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link AtomParsers}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link AtomParsers}. */
+@RunWith(AndroidJUnit4.class)
 public final class AtomParsersTest {
 
   private static final String ATOM_HEADER = "000000000000000000000000";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
index f9362f9cda..a29dfcc310 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
@@ -23,10 +24,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link FragmentedMp4Extractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class FragmentedMp4ExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntryTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntryTest.java
new file mode 100644
index 0000000000..ea1ec1d8cd
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntryTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link MdtaMetadataEntry}. */
+@RunWith(AndroidJUnit4.class)
+public final class MdtaMetadataEntryTest {
+
+  @Test
+  public void testParcelable() {
+    MdtaMetadataEntry mdtaMetadataEntryToParcel =
+        new MdtaMetadataEntry("test", new byte[] {1, 2}, 3, 4);
+
+    Parcel parcel = Parcel.obtain();
+    mdtaMetadataEntryToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    MdtaMetadataEntry mdtaMetadataEntryFromParcel =
+        MdtaMetadataEntry.CREATOR.createFromParcel(parcel);
+    assertThat(mdtaMetadataEntryFromParcel).isEqualTo(mdtaMetadataEntryToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
index 8850a755be..981ee17e92 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
@@ -15,15 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.annotation.TargetApi;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link Mp4Extractor}. */
-@TargetApi(16)
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class Mp4ExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
index d7a13ab061..13d4529451 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
@@ -21,17 +21,15 @@
 import static com.google.android.exoplayer2.extractor.mp4.Atom.parseFullAtomVersion;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.UUID;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link PsshAtomUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link PsshAtomUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class PsshAtomUtilTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
index 1b6df9c5a4..8d1818845d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -26,10 +27,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link DefaultOggSeeker}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DefaultOggSeekerTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
index ef38282691..d6691f50f8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.OggTestData;
@@ -27,12 +28,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link DefaultOggSeeker} utility methods.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link DefaultOggSeeker} utility methods. */
+@RunWith(AndroidJUnit4.class)
 public final class DefaultOggSeekerUtilMethodsTest {
 
   private final Random random = new Random(0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
index 289c168725..b09f7f204f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
@@ -25,10 +26,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link OggExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class OggExtractorTest {
 
   private static final ExtractorFactory OGG_EXTRACTOR_FACTORY = OggExtractor::new;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
index e9af630f83..70f64d3dbe 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
@@ -17,6 +17,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -27,11 +29,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link OggPacket}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class OggPacketTest {
 
   private static final String TEST_FILE = "ogg/bear.opus";
@@ -233,7 +233,7 @@ public void testReadZeroSizedPacketsAtEndOfStream() throws Exception {
 
   @Test
   public void testParseRealFile() throws IOException, InterruptedException {
-    byte[] data = TestUtil.getByteArray(RuntimeEnvironment.application, TEST_FILE);
+    byte[] data = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TEST_FILE);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
     int packetCounter = 0;
     while (readPacket(input)) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
index 930d067d2b..3c8911adec 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import com.google.android.exoplayer2.testutil.OggTestData;
@@ -24,12 +25,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link OggPageHeader}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link OggPageHeader}. */
+@RunWith(AndroidJUnit4.class)
 public final class OggPageHeaderTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
index eca94f076e..0b36924e55 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
@@ -17,15 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link VorbisBitArray}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link VorbisBitArray}. */
+@RunWith(AndroidJUnit4.class)
 public final class VorbisBitArrayTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
index f0361c5395..ab521fc99e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ogg.VorbisReader.VorbisSetup;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
@@ -28,12 +29,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link VorbisReader}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link VorbisReader}. */
+@RunWith(AndroidJUnit4.class)
 public final class VorbisReaderTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
index 5b395771fc..dc3b1510ef 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
@@ -20,17 +20,15 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link VorbisUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link VorbisUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class VorbisUtilTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
index 62ad774fd3..bd7a63e43a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
@@ -15,17 +15,15 @@
  */
 package com.google.android.exoplayer2.extractor.rawcc;
 
-import android.annotation.TargetApi;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.util.MimeTypes;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link RawCcExtractor}. */
-@TargetApi(16)
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class RawCcExtractorTest {
 
   @Test
@@ -41,6 +39,7 @@ public void testRawCcSample() throws Exception {
                     /* codecs= */ "cea608",
                     /* bitrate= */ Format.NO_VALUE,
                     /* selectionFlags= */ 0,
+                    /* roleFlags= */ 0,
                     /* language= */ null,
                     /* accessibilityChannel= */ 1)),
         "rawcc/sample.rawcc");
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
index 92dcf10f19..0fe15ac86e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link Ac3Extractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class Ac3ExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac4ExtractorTest.java
new file mode 100644
index 0000000000..3d1bafc7dc
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac4ExtractorTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.testutil.ExtractorAsserts;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link Ac4Extractor}. */
+@RunWith(AndroidJUnit4.class)
+public final class Ac4ExtractorTest {
+
+  @Test
+  public void testAc4Sample() throws Exception {
+    ExtractorAsserts.assertBehavior(Ac4Extractor::new, "ts/sample.ac4");
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java
index c0a35427b0..4527e41f34 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorSeekTest.java
@@ -18,6 +18,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
@@ -30,11 +32,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link AdtsExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AdtsExtractorSeekTest {
 
   private static final Random random = new Random(1234L);
@@ -49,7 +49,7 @@
   @Before
   public void setUp() {
     dataSource =
-        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+        new DefaultDataSourceFactory(ApplicationProvider.getApplicationContext(), "UserAgent")
             .createDataSource();
   }
 
@@ -60,7 +60,7 @@ public void testAdtsExtractorReads_returnSeekableSeekMap()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+                createAdtsExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
 
@@ -80,7 +80,7 @@ public void testSeeking_handlesSeekingToPositionInFile_extractsCorrectSample()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+                createAdtsExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
 
@@ -107,7 +107,7 @@ public void testSeeking_handlesSeekToEoF_extractsLastSample()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+                createAdtsExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AdtsExtractor extractor = createAdtsExtractor();
@@ -134,7 +134,7 @@ public void testSeeking_handlesSeekingBackward_extractsCorrectSamples()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+                createAdtsExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AdtsExtractor extractor = createAdtsExtractor();
@@ -163,7 +163,7 @@ public void testSeeking_handlesSeekingForward_extractsCorrectSamples()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+                createAdtsExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AdtsExtractor extractor = createAdtsExtractor();
@@ -192,7 +192,7 @@ public void testSeeking_handlesRandomSeeks_extractsCorrectSamples()
     Uri fileUri = TestUtil.buildAssetUri(fileName);
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                createAdtsExtractor(), RuntimeEnvironment.application, fileName)
+                createAdtsExtractor(), ApplicationProvider.getApplicationContext(), fileName)
             .trackOutputs
             .get(0);
     AdtsExtractor extractor = createAdtsExtractor();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
index 7f0db67133..25e2a336ff 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link AdtsExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AdtsExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index 62da914f5b..1562475822 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
@@ -28,10 +29,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Test for {@link AdtsReader}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class AdtsReaderTest {
 
   public static final byte[] ID3_DATA_1 =
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java
index 418b2726bf..d522178ceb 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsDurationReaderTest.java
@@ -17,6 +17,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
@@ -25,11 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link PsDurationReader}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class PsDurationReaderTest {
 
   private PsDurationReader tsDurationReader;
@@ -50,7 +50,8 @@ public void testIsDurationReadPending_returnFalseByDefault() {
   public void testReadDuration_returnsCorrectDuration() throws IOException, InterruptedException {
     FakeExtractorInput input =
         new FakeExtractorInput.Builder()
-            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ps"))
+            .setData(
+                TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), "ts/sample.ps"))
             .build();
 
     int result = Extractor.RESULT_CONTINUE;
@@ -69,7 +70,8 @@ public void testReadDuration_midStream_returnsCorrectDuration()
       throws IOException, InterruptedException {
     FakeExtractorInput input =
         new FakeExtractorInput.Builder()
-            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ps"))
+            .setData(
+                TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), "ts/sample.ps"))
             .build();
 
     input.setPosition(1234);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java
index 33be3a26fd..f974a86622 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorSeekTest.java
@@ -19,6 +19,8 @@
 
 import android.content.Context;
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -39,11 +41,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Seeking tests for {@link PsExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class PsExtractorSeekTest {
 
   private static final String PS_FILE_PATH = "ts/elephants_dream.mpg";
@@ -63,11 +63,12 @@
   public void setUp() throws IOException, InterruptedException {
     expectedOutput = new FakeExtractorOutput();
     positionHolder = new PositionHolder();
-    extractAllSamplesFromFileToExpectedOutput(RuntimeEnvironment.application, PS_FILE_PATH);
+    extractAllSamplesFromFileToExpectedOutput(
+        ApplicationProvider.getApplicationContext(), PS_FILE_PATH);
     expectedTrackOutput = expectedOutput.trackOutputs.get(VIDEO_TRACK_ID);
 
     dataSource =
-        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+        new DefaultDataSourceFactory(ApplicationProvider.getApplicationContext(), "UserAgent")
             .createDataSource();
     totalInputLength = readInputLength();
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
index 0e0fd52175..4cf8f817fe 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link PsExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class PsExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index 7bff736b4a..a089751464 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -20,6 +20,7 @@
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -30,12 +31,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link SectionReader}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link SectionReader}. */
+@RunWith(AndroidJUnit4.class)
 public final class SectionReaderTest {
 
   private byte[] packetPayload;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java
index e7e100f38c..b1531e91f7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsDurationReaderTest.java
@@ -17,6 +17,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
@@ -25,11 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link TsDurationReader}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TsDurationReaderTest {
 
   private TsDurationReader tsDurationReader;
@@ -50,7 +50,9 @@ public void testIsDurationReadPending_returnFalseByDefault() {
   public void testReadDuration_returnsCorrectDuration() throws IOException, InterruptedException {
     FakeExtractorInput input =
         new FakeExtractorInput.Builder()
-            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/bbb_2500ms.ts"))
+            .setData(
+                TestUtil.getByteArray(
+                    ApplicationProvider.getApplicationContext(), "ts/bbb_2500ms.ts"))
             .setSimulateIOErrors(false)
             .setSimulateUnknownLength(false)
             .setSimulatePartialReads(false)
@@ -73,7 +75,9 @@ public void testReadDuration_midStream_returnsCorrectDuration()
       throws IOException, InterruptedException {
     FakeExtractorInput input =
         new FakeExtractorInput.Builder()
-            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/bbb_2500ms.ts"))
+            .setData(
+                TestUtil.getByteArray(
+                    ApplicationProvider.getApplicationContext(), "ts/bbb_2500ms.ts"))
             .setSimulateIOErrors(false)
             .setSimulateUnknownLength(false)
             .setSimulatePartialReads(false)
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java
index 4d421b05a4..956ccc2390 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorSeekTest.java
@@ -18,6 +18,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
@@ -34,11 +36,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Seeking tests for {@link TsExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TsExtractorSeekTest {
 
   private static final String TEST_FILE = "ts/bbb_2500ms.ts";
@@ -57,12 +57,12 @@ public void setUp() throws IOException, InterruptedException {
     positionHolder = new PositionHolder();
     expectedTrackOutput =
         TestUtil.extractAllSamplesFromFile(
-                new TsExtractor(), RuntimeEnvironment.application, TEST_FILE)
+                new TsExtractor(), ApplicationProvider.getApplicationContext(), TEST_FILE)
             .trackOutputs
             .get(AUDIO_TRACK_ID);
 
     dataSource =
-        new DefaultDataSourceFactory(RuntimeEnvironment.application, "UserAgent")
+        new DefaultDataSourceFactory(ApplicationProvider.getApplicationContext(), "UserAgent")
             .createDataSource();
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index beaa5ffa83..f1b962a712 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -18,6 +18,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.util.SparseArray;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -37,11 +39,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link TsExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TsExtractorTest {
 
   private static final int TS_PACKET_SIZE = 188;
@@ -55,7 +55,8 @@ public void testSample() throws Exception {
   @Test
   public void testStreamWithJunkData() throws Exception {
     Random random = new Random(0);
-    byte[] fileData = TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ts");
+    byte[] fileData =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), "ts/sample.ts");
     ByteArrayOutputStream out = new ByteArrayOutputStream(fileData.length * 2);
     int bytesLeft = fileData.length;
 
@@ -74,7 +75,7 @@ public void testStreamWithJunkData() throws Exception {
     fileData = out.toByteArray();
 
     ExtractorAsserts.assertOutput(
-        TsExtractor::new, "ts/sample.ts", fileData, RuntimeEnvironment.application);
+        TsExtractor::new, "ts/sample.ts", fileData, ApplicationProvider.getApplicationContext());
   }
 
   @Test
@@ -84,7 +85,8 @@ public void testCustomPesReader() throws Exception {
         new TsExtractor(TsExtractor.MODE_MULTI_PMT, new TimestampAdjuster(0), factory);
     FakeExtractorInput input =
         new FakeExtractorInput.Builder()
-            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ts"))
+            .setData(
+                TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), "ts/sample.ts"))
             .setSimulateIOErrors(false)
             .setSimulateUnknownLength(false)
             .setSimulatePartialReads(false)
@@ -114,7 +116,9 @@ public void testCustomInitialSectionReader() throws Exception {
         new TsExtractor(TsExtractor.MODE_MULTI_PMT, new TimestampAdjuster(0), factory);
     FakeExtractorInput input =
         new FakeExtractorInput.Builder()
-            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample_with_sdt.ts"))
+            .setData(
+                TestUtil.getByteArray(
+                    ApplicationProvider.getApplicationContext(), "ts/sample_with_sdt.ts"))
             .setSimulateIOErrors(false)
             .setSimulateUnknownLength(false)
             .setSimulatePartialReads(false)
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
index f4df4036f6..c617b672e2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer2.extractor.wav;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link WavExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class WavExtractorTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
index c6558e3fc9..d870afac3a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -17,17 +17,15 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import java.nio.ByteBuffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link EventMessageDecoder}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link EventMessageDecoder}. */
+@RunWith(AndroidJUnit4.class)
 public final class EventMessageDecoderTest {
 
   @Test
@@ -51,7 +49,6 @@ public void testDecodeEventMessage() {
     assertThat(eventMessage.durationMs).isEqualTo(3000);
     assertThat(eventMessage.id).isEqualTo(1000403);
     assertThat(eventMessage.messageData).isEqualTo(new byte[]{0, 1, 2, 3, 4});
-    assertThat(eventMessage.presentationTimeUs).isEqualTo(1000000);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
index 7195548fbf..ca8303d3e2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
@@ -17,41 +17,41 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link EventMessageEncoder}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link EventMessageEncoder}. */
+@RunWith(AndroidJUnit4.class)
 public final class EventMessageEncoderTest {
 
   @Test
   public void testEncodeEventStream() throws IOException {
-    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000000);
-    byte[] expectedEmsgBody = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -45, // id = 1000403
-        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
-    byte[] encodedByteArray = new EventMessageEncoder().encode(eventMessage, 48000);
+    EventMessage eventMessage =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+    byte[] expectedEmsgBody =
+        new byte[] {
+          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+          49, 50, 51, 0, // value = "123"
+          0, 0, 3, -24, // timescale = 1000
+          0, 0, 0, 0, // presentation_time_delta = 0
+          0, 0, 11, -72, // event_duration = 3000
+          0, 15, 67, -45, // id = 1000403
+          0, 1, 2, 3, 4
+        }; // message_data = {0, 1, 2, 3, 4}
+    byte[] encodedByteArray = new EventMessageEncoder().encode(eventMessage);
     assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
   }
 
   @Test
   public void testEncodeDecodeEventStream() throws IOException {
-    EventMessage expectedEmsg = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000000);
-    byte[] encodedByteArray = new EventMessageEncoder().encode(expectedEmsg, 48000);
+    EventMessage expectedEmsg =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+    byte[] encodedByteArray = new EventMessageEncoder().encode(expectedEmsg);
     MetadataInputBuffer buffer = new MetadataInputBuffer();
     buffer.data = ByteBuffer.allocate(encodedByteArray.length).put(encodedByteArray);
 
@@ -63,30 +63,34 @@ public void testEncodeDecodeEventStream() throws IOException {
 
   @Test
   public void testEncodeEventStreamMultipleTimesWorkingCorrectly() throws IOException {
-    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000000);
-    byte[] expectedEmsgBody = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -45, // id = 1000403
-        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
-    EventMessage eventMessage1 = new EventMessage("urn:test", "123", 3000, 1000402,
-        new byte[] {4, 3, 2, 1, 0}, 1000000);
-    byte[] expectedEmsgBody1 = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -46, // id = 1000402
-        4, 3, 2, 1, 0}; // message_data = {4, 3, 2, 1, 0}
+    EventMessage eventMessage =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+    byte[] expectedEmsgBody =
+        new byte[] {
+          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+          49, 50, 51, 0, // value = "123"
+          0, 0, 3, -24, // timescale = 1000
+          0, 0, 0, 0, // presentation_time_delta = 0
+          0, 0, 11, -72, // event_duration = 3000
+          0, 15, 67, -45, // id = 1000403
+          0, 1, 2, 3, 4
+        }; // message_data = {0, 1, 2, 3, 4}
+    EventMessage eventMessage1 =
+        new EventMessage("urn:test", "123", 3000, 1000402, new byte[] {4, 3, 2, 1, 0});
+    byte[] expectedEmsgBody1 =
+        new byte[] {
+          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+          49, 50, 51, 0, // value = "123"
+          0, 0, 3, -24, // timescale = 1000
+          0, 0, 0, 0, // presentation_time_delta = 0
+          0, 0, 11, -72, // event_duration = 3000
+          0, 15, 67, -46, // id = 1000402
+          4, 3, 2, 1, 0
+        }; // message_data = {4, 3, 2, 1, 0}
     EventMessageEncoder eventMessageEncoder = new EventMessageEncoder();
-    byte[] encodedByteArray = eventMessageEncoder.encode(eventMessage, 48000);
+    byte[] encodedByteArray = eventMessageEncoder.encode(eventMessage);
     assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
-    byte[] encodedByteArray1 = eventMessageEncoder.encode(eventMessage1, 48000);
+    byte[] encodedByteArray1 = eventMessageEncoder.encode(eventMessage1);
     assertThat(encodedByteArray1).isEqualTo(expectedEmsgBody1);
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
index 30e1cd6c1f..d9e9ab7ea7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -18,20 +18,18 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link EventMessage}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link EventMessage}. */
+@RunWith(AndroidJUnit4.class)
 public final class EventMessageTest {
 
   @Test
   public void testEventMessageParcelable() {
-    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000);
+    EventMessage eventMessage =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
     // Write to parcel.
     Parcel parcel = Parcel.obtain();
     eventMessage.writeToParcel(parcel, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
new file mode 100644
index 0000000000..9cbcea5814
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.icy;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.metadata.Metadata;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link IcyDecoder}. */
+@RunWith(AndroidJUnit4.class)
+public final class IcyDecoderTest {
+
+  @Test
+  public void decode() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='test title';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEqualTo("test title");
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
+  @Test
+  public void decode_titleOnly() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='test title';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEqualTo("test title");
+    assertThat(streamInfo.url).isNull();
+  }
+
+  @Test
+  public void decode_semiColonInTitle() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='test; title';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEqualTo("test; title");
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
+  @Test
+  public void decode_quoteInTitle() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='test' title';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEqualTo("test' title");
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
+  @Test
+  public void decode_notIcy() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("NotIcyData");
+
+    assertThat(metadata).isNull();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyHeadersTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyHeadersTest.java
new file mode 100644
index 0000000000..93f88c76e7
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyHeadersTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.icy;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link IcyHeaders}. */
+@RunWith(AndroidJUnit4.class)
+public final class IcyHeadersTest {
+
+  @Test
+  public void parcelEquals() {
+    IcyHeaders icyHeaders =
+        new IcyHeaders(
+            /* bitrate= */ 1234,
+            "genre",
+            "name",
+            "url",
+            /* isPublic= */ true,
+            /* metadataInterval= */ 5678);
+    // Write to parcel.
+    Parcel parcel = Parcel.obtain();
+    icyHeaders.writeToParcel(parcel, 0);
+    // Create from parcel.
+    parcel.setDataPosition(0);
+    IcyHeaders fromParcelIcyHeaders = IcyHeaders.CREATOR.createFromParcel(parcel);
+    // Assert equals.
+    assertThat(fromParcelIcyHeaders).isEqualTo(icyHeaders);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyStreamInfoTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyStreamInfoTest.java
new file mode 100644
index 0000000000..2bffe171d3
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyStreamInfoTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.icy;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link IcyInfo}. */
+@RunWith(AndroidJUnit4.class)
+public final class IcyStreamInfoTest {
+
+  @Test
+  public void parcelEquals() {
+    IcyInfo streamInfo = new IcyInfo("name", "url");
+    // Write to parcel.
+    Parcel parcel = Parcel.obtain();
+    streamInfo.writeToParcel(parcel, 0);
+    // Create from parcel.
+    parcel.setDataPosition(0);
+    IcyInfo fromParcelStreamInfo = IcyInfo.CREATOR.createFromParcel(parcel);
+    // Assert equals.
+    assertThat(fromParcelStreamInfo).isEqualTo(streamInfo);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
index 714f77a752..fbd824c7c1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
@@ -18,14 +18,12 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link ChapterFrame}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link ChapterFrame}. */
+@RunWith(AndroidJUnit4.class)
 public final class ChapterFrameTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
index 98a99a4219..daf9ff1bb5 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
@@ -18,14 +18,12 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link ChapterTocFrame}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link ChapterTocFrame}. */
+@RunWith(AndroidJUnit4.class)
 public final class ChapterTocFrameTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index 3fa491ea50..a20cbb66a2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.Assertions;
@@ -24,12 +25,9 @@
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link Id3Decoder}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link Id3Decoder}. */
+@RunWith(AndroidJUnit4.class)
 public final class Id3DecoderTest {
 
   private static final byte[] TAG_HEADER = new byte[] {'I', 'D', '3', 4, 0, 0, 0, 0, 0, 0};
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
index 3e6520beca..d6bbecdf6c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
@@ -18,12 +18,12 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Test for {@link MlltFrame}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class MlltFrameTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
index d8a4e97791..92fa147c30 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -18,6 +18,7 @@
 import static com.google.android.exoplayer2.C.TIME_UNSET;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
@@ -26,12 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link SpliceInfoDecoder}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link SpliceInfoDecoder}. */
+@RunWith(AndroidJUnit4.class)
 public final class SpliceInfoDecoderTest {
 
   private SpliceInfoDecoder decoder;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java
index 634d541d39..7abfa44886 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileTest.java
@@ -18,30 +18,36 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
-import com.google.android.exoplayer2.offline.DownloadAction.Deserializer;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.util.Collections;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit tests for {@link ActionFile}. */
-@RunWith(RobolectricTestRunner.class)
+@SuppressWarnings("deprecation")
+@RunWith(AndroidJUnit4.class)
 public class ActionFileTest {
 
   private File tempFile;
+  private DownloadRequest expectedAction1;
+  private DownloadRequest expectedAction2;
 
   @Before
   public void setUp() throws Exception {
-    tempFile = Util.createTempFile(RuntimeEnvironment.application, "ExoPlayerTest");
+    tempFile = Util.createTempFile(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
+    expectedAction1 =
+        buildExpectedRequest(Uri.parse("http://test1.uri"), TestUtil.buildTestData(16));
+    expectedAction2 =
+        buildExpectedRequest(Uri.parse("http://test2.uri"), TestUtil.buildTestData(32));
   }
 
   @After
@@ -51,8 +57,9 @@ public void tearDown() throws Exception {
 
   @Test
   public void testLoadNoDataThrowsIOException() throws Exception {
+    ActionFile actionFile = getActionFile("offline/action_file_no_data.exi");
     try {
-      loadActions(new Object[] {});
+      actionFile.load();
       Assert.fail();
     } catch (IOException e) {
       // Expected exception.
@@ -61,8 +68,9 @@ public void testLoadNoDataThrowsIOException() throws Exception {
 
   @Test
   public void testLoadIncompleteHeaderThrowsIOException() throws Exception {
+    ActionFile actionFile = getActionFile("offline/action_file_incomplete_header.exi");
     try {
-      loadActions(new Object[] {ActionFile.VERSION});
+      actionFile.load();
       Assert.fail();
     } catch (IOException e) {
       // Expected exception.
@@ -70,196 +78,59 @@ public void testLoadIncompleteHeaderThrowsIOException() throws Exception {
   }
 
   @Test
-  public void testLoadCompleteHeaderZeroAction() throws Exception {
-    DownloadAction[] actions = loadActions(new Object[] {ActionFile.VERSION, 0});
+  public void testLoadZeroActions() throws Exception {
+    ActionFile actionFile = getActionFile("offline/action_file_zero_actions.exi");
+    DownloadRequest[] actions = actionFile.load();
     assertThat(actions).isNotNull();
     assertThat(actions).hasLength(0);
   }
 
   @Test
-  public void testLoadAction() throws Exception {
-    byte[] data = Util.getUtf8Bytes("321");
-    DownloadAction[] actions =
-        loadActions(
-            new Object[] {
-              ActionFile.VERSION,
-              1, // Action count
-              "type2", // Action 1
-              FakeDownloadAction.VERSION,
-              data,
-            },
-            new FakeDeserializer("type2"));
-    assertThat(actions).isNotNull();
+  public void testLoadOneAction() throws Exception {
+    ActionFile actionFile = getActionFile("offline/action_file_one_action.exi");
+    DownloadRequest[] actions = actionFile.load();
     assertThat(actions).hasLength(1);
-    assertAction(actions[0], "type2", FakeDownloadAction.VERSION, data);
+    assertThat(actions[0]).isEqualTo(expectedAction1);
   }
 
   @Test
-  public void testLoadActions() throws Exception {
-    byte[] data1 = Util.getUtf8Bytes("123");
-    byte[] data2 = Util.getUtf8Bytes("321");
-    DownloadAction[] actions =
-        loadActions(
-            new Object[] {
-              ActionFile.VERSION,
-              2, // Action count
-              "type1", // Action 1
-              FakeDownloadAction.VERSION,
-              data1,
-              "type2", // Action 2
-              FakeDownloadAction.VERSION,
-              data2,
-            },
-            new FakeDeserializer("type1"),
-            new FakeDeserializer("type2"));
-    assertThat(actions).isNotNull();
+  public void testLoadTwoActions() throws Exception {
+    ActionFile actionFile = getActionFile("offline/action_file_two_actions.exi");
+    DownloadRequest[] actions = actionFile.load();
     assertThat(actions).hasLength(2);
-    assertAction(actions[0], "type1", FakeDownloadAction.VERSION, data1);
-    assertAction(actions[1], "type2", FakeDownloadAction.VERSION, data2);
+    assertThat(actions[0]).isEqualTo(expectedAction1);
+    assertThat(actions[1]).isEqualTo(expectedAction2);
   }
 
   @Test
-  public void testLoadNotSupportedVersion() throws Exception {
+  public void testLoadUnsupportedVersion() throws Exception {
+    ActionFile actionFile = getActionFile("offline/action_file_unsupported_version.exi");
     try {
-      loadActions(
-          new Object[] {
-            ActionFile.VERSION + 1,
-            1, // Action count
-            "type2", // Action 1
-            FakeDownloadAction.VERSION,
-            Util.getUtf8Bytes("321"),
-          },
-          new FakeDeserializer("type2"));
+      actionFile.load();
       Assert.fail();
     } catch (IOException e) {
       // Expected exception.
     }
   }
 
-  @Test
-  public void testLoadNotSupportedActionVersion() throws Exception {
-    try {
-      loadActions(
-          new Object[] {
-            ActionFile.VERSION,
-            1, // Action count
-            "type2", // Action 1
-            FakeDownloadAction.VERSION + 1,
-            Util.getUtf8Bytes("321"),
-          },
-          new FakeDeserializer("type2"));
-      Assert.fail();
-    } catch (IOException e) {
-      // Expected exception.
-    }
-  }
-
-  @Test
-  public void testLoadNotSupportedType() throws Exception {
-    try {
-      loadActions(
-          new Object[] {
-            ActionFile.VERSION,
-            1, // Action count
-            "type2", // Action 1
-            FakeDownloadAction.VERSION,
-            Util.getUtf8Bytes("321"),
-          },
-          new FakeDeserializer("type1"));
-      Assert.fail();
-    } catch (DownloadException e) {
-      // Expected exception.
+  private ActionFile getActionFile(String fileName) throws IOException {
+    // Copy the test data from the asset to where the ActionFile expects it to be.
+    byte[] actionFileBytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), fileName);
+    try (FileOutputStream output = new FileOutputStream(tempFile)) {
+      output.write(actionFileBytes);
     }
+    // Load the action file.
+    return new ActionFile(tempFile);
   }
 
-  @Test
-  public void testStoreAndLoadNoActions() throws Exception {
-    doTestSerializationRoundTrip(new DownloadAction[0]);
+  private static DownloadRequest buildExpectedRequest(Uri uri, byte[] data) {
+    return new DownloadRequest(
+        /* id= */ uri.toString(),
+        DownloadRequest.TYPE_PROGRESSIVE,
+        uri,
+        /* streamKeys= */ Collections.emptyList(),
+        /* customCacheKey= */ null,
+        data);
   }
-
-  @Test
-  public void testStoreAndLoadActions() throws Exception {
-    doTestSerializationRoundTrip(
-        new DownloadAction[] {
-          new FakeDownloadAction("type1", Util.getUtf8Bytes("123")),
-          new FakeDownloadAction("type2", Util.getUtf8Bytes("321")),
-        },
-        new FakeDeserializer("type1"),
-        new FakeDeserializer("type2"));
-  }
-
-  private void doTestSerializationRoundTrip(DownloadAction[] actions,
-      Deserializer... deserializers) throws IOException {
-    ActionFile actionFile = new ActionFile(tempFile);
-    actionFile.store(actions);
-    assertThat(actionFile.load(deserializers)).isEqualTo(actions);
-  }
-
-  private DownloadAction[] loadActions(Object[] values, Deserializer... deserializers)
-      throws IOException {
-    FileOutputStream fileOutputStream = new FileOutputStream(tempFile);
-    DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream);
-    try {
-      for (Object value : values) {
-        if (value instanceof Integer) {
-          dataOutputStream.writeInt((Integer) value);
-        } else if (value instanceof String) {
-          dataOutputStream.writeUTF((String) value);
-        } else if (value instanceof byte[]) {
-          byte[] data = (byte[]) value;
-          dataOutputStream.writeInt(data.length);
-          dataOutputStream.write(data);
-        } else {
-          throw new IllegalArgumentException();
-        }
-      }
-    } finally {
-      dataOutputStream.close();
-    }
-    return new ActionFile(tempFile).load(deserializers);
-  }
-
-  private static void assertAction(DownloadAction action, String type, int version, byte[] data) {
-    assertThat(action).isInstanceOf(FakeDownloadAction.class);
-    assertThat(action.type).isEqualTo(type);
-    assertThat(((FakeDownloadAction) action).version).isEqualTo(version);
-    assertThat(((FakeDownloadAction) action).data).isEqualTo(data);
-  }
-
-  private static class FakeDeserializer extends Deserializer {
-
-    FakeDeserializer(String type) {
-      super(type, FakeDownloadAction.VERSION);
-    }
-
-    @Override
-    public DownloadAction readFromStream(int version, DataInputStream input) throws IOException {
-      int dataLength = input.readInt();
-      byte[] data = new byte[dataLength];
-      input.readFully(data);
-      return new FakeDownloadAction(type, data);
-    }
-  }
-
-  private static class FakeDownloadAction extends DownloadAction {
-
-    public static final int VERSION = 0;
-
-    private FakeDownloadAction(String type, byte[] data) {
-      super(type, VERSION, Uri.parse("http://test.com"), /* isRemoveAction= */ false, data);
-    }
-
-    @Override
-    protected void writeToStream(DataOutputStream output) throws IOException {
-      output.writeInt(data.length);
-      output.write(data);
-    }
-
-    @Override
-    public Downloader createDownloader(DownloaderConstructorHelper downloaderConstructorHelper) {
-      return null;
-    }
-
-  }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtilTest.java
new file mode 100644
index 0000000000..2f36b7f48c
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtilTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.android.exoplayer2.offline.DownloadRequest.TYPE_PROGRESSIVE;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.database.ExoDatabaseProvider;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link ActionFileUpgradeUtil}. */
+@RunWith(AndroidJUnit4.class)
+public class ActionFileUpgradeUtilTest {
+
+  private static final long NOW_MS = 1234;
+
+  private File tempFile;
+  private ExoDatabaseProvider databaseProvider;
+  private DefaultDownloadIndex downloadIndex;
+
+  @Before
+  public void setUp() throws Exception {
+    tempFile = Util.createTempFile(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
+    databaseProvider = new ExoDatabaseProvider(ApplicationProvider.getApplicationContext());
+    downloadIndex = new DefaultDownloadIndex(databaseProvider);
+  }
+
+  @After
+  public void tearDown() {
+    databaseProvider.close();
+    tempFile.delete();
+  }
+
+  @Test
+  public void upgradeAndDelete_createsDownloads() throws IOException {
+    // Copy the test asset to a file.
+    byte[] actionFileBytes =
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(),
+            "offline/action_file_for_download_index_upgrade.exi");
+    try (FileOutputStream output = new FileOutputStream(tempFile)) {
+      output.write(actionFileBytes);
+    }
+
+    StreamKey expectedStreamKey1 =
+        new StreamKey(/* periodIndex= */ 3, /* groupIndex= */ 4, /* trackIndex= */ 5);
+    StreamKey expectedStreamKey2 =
+        new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 1, /* trackIndex= */ 2);
+    DownloadRequest expectedRequest1 =
+        new DownloadRequest(
+            "key123",
+            /* type= */ "test",
+            Uri.parse("https://www.test.com/download1"),
+            asList(expectedStreamKey1),
+            /* customCacheKey= */ "key123",
+            new byte[] {1, 2, 3, 4});
+    DownloadRequest expectedRequest2 =
+        new DownloadRequest(
+            "key234",
+            /* type= */ "test",
+            Uri.parse("https://www.test.com/download2"),
+            asList(expectedStreamKey2),
+            /* customCacheKey= */ "key234",
+            new byte[] {5, 4, 3, 2, 1});
+
+    ActionFileUpgradeUtil.upgradeAndDelete(
+        tempFile,
+        /* downloadIdProvider= */ null,
+        downloadIndex,
+        /* deleteOnFailure= */ true,
+        /* addNewDownloadsAsCompleted= */ false);
+
+    assertDownloadIndexContainsRequest(expectedRequest1, Download.STATE_QUEUED);
+    assertDownloadIndexContainsRequest(expectedRequest2, Download.STATE_QUEUED);
+  }
+
+  @Test
+  public void mergeRequest_nonExistingDownload_createsNewDownload() throws IOException {
+    byte[] data = new byte[] {1, 2, 3, 4};
+    DownloadRequest request =
+        new DownloadRequest(
+            "id",
+            TYPE_PROGRESSIVE,
+            Uri.parse("https://www.test.com/download"),
+            asList(
+                new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 1, /* trackIndex= */ 2),
+                new StreamKey(/* periodIndex= */ 3, /* groupIndex= */ 4, /* trackIndex= */ 5)),
+            /* customCacheKey= */ "key123",
+            data);
+
+    ActionFileUpgradeUtil.mergeRequest(
+        request, downloadIndex, /* addNewDownloadAsCompleted= */ false, NOW_MS);
+
+    assertDownloadIndexContainsRequest(request, Download.STATE_QUEUED);
+  }
+
+  @Test
+  public void mergeRequest_existingDownload_createsMergedDownload() throws IOException {
+    StreamKey streamKey1 =
+        new StreamKey(/* periodIndex= */ 3, /* groupIndex= */ 4, /* trackIndex= */ 5);
+    StreamKey streamKey2 =
+        new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 1, /* trackIndex= */ 2);
+    DownloadRequest request1 =
+        new DownloadRequest(
+            "id",
+            TYPE_PROGRESSIVE,
+            Uri.parse("https://www.test.com/download1"),
+            asList(streamKey1),
+            /* customCacheKey= */ "key123",
+            new byte[] {1, 2, 3, 4});
+    DownloadRequest request2 =
+        new DownloadRequest(
+            "id",
+            TYPE_PROGRESSIVE,
+            Uri.parse("https://www.test.com/download2"),
+            asList(streamKey2),
+            /* customCacheKey= */ "key123",
+            new byte[] {5, 4, 3, 2, 1});
+    ActionFileUpgradeUtil.mergeRequest(
+        request1, downloadIndex, /* addNewDownloadAsCompleted= */ false, NOW_MS);
+    ActionFileUpgradeUtil.mergeRequest(
+        request2, downloadIndex, /* addNewDownloadAsCompleted= */ false, NOW_MS);
+
+    Download download = downloadIndex.getDownload(request2.id);
+    assertThat(download).isNotNull();
+    assertThat(download.request.type).isEqualTo(request2.type);
+    assertThat(download.request.customCacheKey).isEqualTo(request2.customCacheKey);
+    assertThat(download.request.data).isEqualTo(request2.data);
+    assertThat(download.request.uri).isEqualTo(request2.uri);
+    assertThat(download.request.streamKeys).containsExactly(streamKey1, streamKey2);
+    assertThat(download.state).isEqualTo(Download.STATE_QUEUED);
+  }
+
+  @Test
+  public void mergeRequest_addNewDownloadAsCompleted() throws IOException {
+    StreamKey streamKey1 =
+        new StreamKey(/* periodIndex= */ 3, /* groupIndex= */ 4, /* trackIndex= */ 5);
+    StreamKey streamKey2 =
+        new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 1, /* trackIndex= */ 2);
+    DownloadRequest request1 =
+        new DownloadRequest(
+            "id1",
+            TYPE_PROGRESSIVE,
+            Uri.parse("https://www.test.com/download1"),
+            asList(streamKey1),
+            /* customCacheKey= */ "key123",
+            new byte[] {1, 2, 3, 4});
+    DownloadRequest request2 =
+        new DownloadRequest(
+            "id2",
+            TYPE_PROGRESSIVE,
+            Uri.parse("https://www.test.com/download2"),
+            asList(streamKey2),
+            /* customCacheKey= */ "key123",
+            new byte[] {5, 4, 3, 2, 1});
+    ActionFileUpgradeUtil.mergeRequest(
+        request1, downloadIndex, /* addNewDownloadAsCompleted= */ false, NOW_MS);
+
+    // Merging existing download, keeps it queued.
+    ActionFileUpgradeUtil.mergeRequest(
+        request1, downloadIndex, /* addNewDownloadAsCompleted= */ true, NOW_MS);
+    assertThat(downloadIndex.getDownload(request1.id).state).isEqualTo(Download.STATE_QUEUED);
+
+    // New download is merged as completed.
+    ActionFileUpgradeUtil.mergeRequest(
+        request2, downloadIndex, /* addNewDownloadAsCompleted= */ true, NOW_MS);
+    assertThat(downloadIndex.getDownload(request2.id).state).isEqualTo(Download.STATE_COMPLETED);
+  }
+
+  private void assertDownloadIndexContainsRequest(DownloadRequest request, int state)
+      throws IOException {
+    Download download = downloadIndex.getDownload(request.id);
+    assertThat(download.request).isEqualTo(request);
+    assertThat(download.state).isEqualTo(state);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static List<StreamKey> asList(StreamKey... streamKeys) {
+    return Arrays.asList(streamKeys);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DefaultDownloadIndexTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DefaultDownloadIndexTest.java
new file mode 100644
index 0000000000..f42a1c6086
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DefaultDownloadIndexTest.java
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.database.sqlite.SQLiteDatabase;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.database.DatabaseIOException;
+import com.google.android.exoplayer2.database.ExoDatabaseProvider;
+import com.google.android.exoplayer2.database.VersionTable;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link DefaultDownloadIndex}. */
+@RunWith(AndroidJUnit4.class)
+public class DefaultDownloadIndexTest {
+
+  private static final String EMPTY_NAME = "";
+
+  private ExoDatabaseProvider databaseProvider;
+  private DefaultDownloadIndex downloadIndex;
+
+  @Before
+  public void setUp() {
+    databaseProvider = new ExoDatabaseProvider(ApplicationProvider.getApplicationContext());
+    downloadIndex = new DefaultDownloadIndex(databaseProvider);
+  }
+
+  @After
+  public void tearDown() {
+    databaseProvider.close();
+  }
+
+  @Test
+  public void getDownload_nonExistingId_returnsNull() throws DatabaseIOException {
+    assertThat(downloadIndex.getDownload("non existing id")).isNull();
+  }
+
+  @Test
+  public void addAndGetDownload_nonExistingId_returnsTheSameDownload() throws DatabaseIOException {
+    String id = "id";
+    Download download = new DownloadBuilder(id).build();
+
+    downloadIndex.putDownload(download);
+    Download readDownload = downloadIndex.getDownload(id);
+
+    assertEqual(readDownload, download);
+  }
+
+  @Test
+  public void addAndGetDownload_existingId_returnsUpdatedDownload() throws DatabaseIOException {
+    String id = "id";
+    DownloadBuilder downloadBuilder = new DownloadBuilder(id);
+    downloadIndex.putDownload(downloadBuilder.build());
+
+    Download download =
+        downloadBuilder
+            .setType("different type")
+            .setUri("different uri")
+            .setCacheKey("different cacheKey")
+            .setState(Download.STATE_FAILED)
+            .setPercentDownloaded(50)
+            .setBytesDownloaded(200)
+            .setContentLength(400)
+            .setFailureReason(Download.FAILURE_REASON_UNKNOWN)
+            .setStopReason(0x12345678)
+            .setStartTimeMs(10)
+            .setUpdateTimeMs(20)
+            .setStreamKeys(
+                new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 1, /* trackIndex= */ 2),
+                new StreamKey(/* periodIndex= */ 3, /* groupIndex= */ 4, /* trackIndex= */ 5))
+            .setCustomMetadata(new byte[] {0, 1, 2, 3, 7, 8, 9, 10})
+            .build();
+    downloadIndex.putDownload(download);
+    Download readDownload = downloadIndex.getDownload(id);
+
+    assertThat(readDownload).isNotNull();
+    assertEqual(readDownload, download);
+  }
+
+  @Test
+  public void releaseAndRecreateDownloadIndex_returnsTheSameDownload() throws DatabaseIOException {
+    String id = "id";
+    Download download = new DownloadBuilder(id).build();
+    downloadIndex.putDownload(download);
+
+    downloadIndex = new DefaultDownloadIndex(databaseProvider);
+    Download readDownload = downloadIndex.getDownload(id);
+    assertThat(readDownload).isNotNull();
+    assertEqual(readDownload, download);
+  }
+
+  @Test
+  public void removeDownload_nonExistingId_doesNotFail() throws DatabaseIOException {
+    downloadIndex.removeDownload("non existing id");
+  }
+
+  @Test
+  public void removeDownload_existingId_getDownloadReturnsNull() throws DatabaseIOException {
+    String id = "id";
+    Download download = new DownloadBuilder(id).build();
+    downloadIndex.putDownload(download);
+    downloadIndex.removeDownload(id);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    assertThat(readDownload).isNull();
+  }
+
+  @Test
+  public void getDownloads_emptyDownloadIndex_returnsEmptyArray() throws DatabaseIOException {
+    assertThat(downloadIndex.getDownloads().getCount()).isEqualTo(0);
+  }
+
+  @Test
+  public void getDownloads_noState_returnsAllDownloadStatusSortedByStartTime()
+      throws DatabaseIOException {
+    Download download1 = new DownloadBuilder("id1").setStartTimeMs(1).build();
+    downloadIndex.putDownload(download1);
+    Download download2 = new DownloadBuilder("id2").setStartTimeMs(0).build();
+    downloadIndex.putDownload(download2);
+
+    try (DownloadCursor cursor = downloadIndex.getDownloads()) {
+      assertThat(cursor.getCount()).isEqualTo(2);
+      cursor.moveToNext();
+      assertEqual(cursor.getDownload(), download2);
+      cursor.moveToNext();
+      assertEqual(cursor.getDownload(), download1);
+    }
+  }
+
+  @Test
+  public void getDownloads_withStates_returnsAllDownloadStatusWithTheSameStates()
+      throws DatabaseIOException {
+    Download download1 =
+        new DownloadBuilder("id1").setStartTimeMs(0).setState(Download.STATE_REMOVING).build();
+    downloadIndex.putDownload(download1);
+    Download download2 =
+        new DownloadBuilder("id2").setStartTimeMs(1).setState(Download.STATE_STOPPED).build();
+    downloadIndex.putDownload(download2);
+    Download download3 =
+        new DownloadBuilder("id3").setStartTimeMs(2).setState(Download.STATE_COMPLETED).build();
+    downloadIndex.putDownload(download3);
+
+    try (DownloadCursor cursor =
+        downloadIndex.getDownloads(Download.STATE_REMOVING, Download.STATE_COMPLETED)) {
+      assertThat(cursor.getCount()).isEqualTo(2);
+      cursor.moveToNext();
+      assertEqual(cursor.getDownload(), download1);
+      cursor.moveToNext();
+      assertEqual(cursor.getDownload(), download3);
+    }
+  }
+
+  @Test
+  public void putDownload_setsVersion() throws DatabaseIOException {
+    SQLiteDatabase readableDatabase = databaseProvider.getReadableDatabase();
+    assertThat(VersionTable.getVersion(readableDatabase, VersionTable.FEATURE_OFFLINE, EMPTY_NAME))
+        .isEqualTo(VersionTable.VERSION_UNSET);
+
+    downloadIndex.putDownload(new DownloadBuilder("id1").build());
+
+    assertThat(VersionTable.getVersion(readableDatabase, VersionTable.FEATURE_OFFLINE, EMPTY_NAME))
+        .isEqualTo(DefaultDownloadIndex.TABLE_VERSION);
+  }
+
+  @Test
+  public void downloadIndex_versionDowngradeWipesData() throws DatabaseIOException {
+    Download download1 = new DownloadBuilder("id1").build();
+    downloadIndex.putDownload(download1);
+    DownloadCursor cursor = downloadIndex.getDownloads();
+    assertThat(cursor.getCount()).isEqualTo(1);
+    cursor.close();
+
+    SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+    VersionTable.setVersion(
+        writableDatabase, VersionTable.FEATURE_OFFLINE, EMPTY_NAME, Integer.MAX_VALUE);
+
+    downloadIndex = new DefaultDownloadIndex(databaseProvider);
+
+    cursor = downloadIndex.getDownloads();
+    assertThat(cursor.getCount()).isEqualTo(0);
+    cursor.close();
+    assertThat(VersionTable.getVersion(writableDatabase, VersionTable.FEATURE_OFFLINE, EMPTY_NAME))
+        .isEqualTo(DefaultDownloadIndex.TABLE_VERSION);
+  }
+
+  @Test
+  public void setStopReason_setReasonToNone() throws Exception {
+    String id = "id";
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(id).setState(Download.STATE_COMPLETED).setStopReason(0x12345678);
+    Download download = downloadBuilder.build();
+    downloadIndex.putDownload(download);
+
+    downloadIndex.setStopReason(Download.STOP_REASON_NONE);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    Download expectedDownload = downloadBuilder.setStopReason(Download.STOP_REASON_NONE).build();
+    assertEqual(readDownload, expectedDownload);
+  }
+
+  @Test
+  public void setStopReason_setReason() throws Exception {
+    String id = "id";
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(id)
+            .setState(Download.STATE_FAILED)
+            .setFailureReason(Download.FAILURE_REASON_UNKNOWN);
+    Download download = downloadBuilder.build();
+    downloadIndex.putDownload(download);
+    int stopReason = 0x12345678;
+
+    downloadIndex.setStopReason(stopReason);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    Download expectedDownload = downloadBuilder.setStopReason(stopReason).build();
+    assertEqual(readDownload, expectedDownload);
+  }
+
+  @Test
+  public void setStopReason_notTerminalState_doesNotSetStopReason() throws Exception {
+    String id = "id";
+    DownloadBuilder downloadBuilder = new DownloadBuilder(id).setState(Download.STATE_DOWNLOADING);
+    Download download = downloadBuilder.build();
+    downloadIndex.putDownload(download);
+    int notMetRequirements = 0x12345678;
+
+    downloadIndex.setStopReason(notMetRequirements);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    assertEqual(readDownload, download);
+  }
+
+  @Test
+  public void setSingleDownloadStopReason_setReasonToNone() throws Exception {
+    String id = "id";
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(id).setState(Download.STATE_COMPLETED).setStopReason(0x12345678);
+    Download download = downloadBuilder.build();
+    downloadIndex.putDownload(download);
+
+    downloadIndex.setStopReason(id, Download.STOP_REASON_NONE);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    Download expectedDownload = downloadBuilder.setStopReason(Download.STOP_REASON_NONE).build();
+    assertEqual(readDownload, expectedDownload);
+  }
+
+  @Test
+  public void setSingleDownloadStopReason_setReason() throws Exception {
+    String id = "id";
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(id)
+            .setState(Download.STATE_FAILED)
+            .setFailureReason(Download.FAILURE_REASON_UNKNOWN);
+    Download download = downloadBuilder.build();
+    downloadIndex.putDownload(download);
+    int stopReason = 0x12345678;
+
+    downloadIndex.setStopReason(id, stopReason);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    Download expectedDownload = downloadBuilder.setStopReason(stopReason).build();
+    assertEqual(readDownload, expectedDownload);
+  }
+
+  @Test
+  public void setSingleDownloadStopReason_notTerminalState_doesNotSetStopReason() throws Exception {
+    String id = "id";
+    DownloadBuilder downloadBuilder = new DownloadBuilder(id).setState(Download.STATE_DOWNLOADING);
+    Download download = downloadBuilder.build();
+    downloadIndex.putDownload(download);
+    int notMetRequirements = 0x12345678;
+
+    downloadIndex.setStopReason(id, notMetRequirements);
+
+    Download readDownload = downloadIndex.getDownload(id);
+    assertEqual(readDownload, download);
+  }
+
+  private static void assertEqual(Download download, Download that) {
+    assertThat(download.request).isEqualTo(that.request);
+    assertThat(download.state).isEqualTo(that.state);
+    assertThat(download.startTimeMs).isEqualTo(that.startTimeMs);
+    assertThat(download.updateTimeMs).isEqualTo(that.updateTimeMs);
+    assertThat(download.contentLength).isEqualTo(that.contentLength);
+    assertThat(download.stopReason).isEqualTo(that.stopReason);
+    assertThat(download.failureReason).isEqualTo(that.failureReason);
+    assertThat(download.getPercentDownloaded()).isEqualTo(that.getPercentDownloaded());
+    assertThat(download.getBytesDownloaded()).isEqualTo(that.getBytesDownloaded());
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DefaultDownloaderFactoryTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DefaultDownloaderFactoryTest.java
new file mode 100644
index 0000000000..c3d23c7d22
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DefaultDownloaderFactoryTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+
+/** Unit tests for {@link DefaultDownloaderFactory}. */
+@RunWith(AndroidJUnit4.class)
+public final class DefaultDownloaderFactoryTest {
+
+  @Test
+  public void createProgressiveDownloader() throws Exception {
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    DownloaderFactory factory = new DefaultDownloaderFactory(constructorHelper);
+
+    Downloader downloader =
+        factory.createDownloader(
+            new DownloadRequest(
+                "id",
+                DownloadRequest.TYPE_PROGRESSIVE,
+                Uri.parse("https://www.test.com/download"),
+                /* streamKeys= */ Collections.emptyList(),
+                /* customCacheKey= */ null,
+                /* data= */ null));
+    assertThat(downloader).isInstanceOf(ProgressiveDownloader.class);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadBuilder.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadBuilder.java
new file mode 100644
index 0000000000..e07166a21c
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadBuilder.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Builder for {@link Download}.
+ *
+ * <p>Defines default values for each field (except {@code id}) to facilitate {@link Download}
+ * creation for tests. Tests must avoid depending on the default values but explicitly set tested
+ * parameters during test initialization.
+ */
+/* package */ final class DownloadBuilder {
+
+  private final DownloadProgress progress;
+
+  private String id;
+  private String type;
+  private Uri uri;
+  private List<StreamKey> streamKeys;
+  @Nullable private String cacheKey;
+  private byte[] customMetadata;
+
+  @Download.State private int state;
+  private long startTimeMs;
+  private long updateTimeMs;
+  private long contentLength;
+  private int stopReason;
+  private int failureReason;
+
+  /* package */ DownloadBuilder(String id) {
+    this(
+        id,
+        "type",
+        Uri.parse("uri"),
+        /* streamKeys= */ Collections.emptyList(),
+        /* cacheKey= */ null,
+        new byte[0]);
+  }
+
+  /* package */ DownloadBuilder(DownloadRequest request) {
+    this(
+        request.id,
+        request.type,
+        request.uri,
+        request.streamKeys,
+        request.customCacheKey,
+        request.data);
+  }
+
+  /* package */ DownloadBuilder(
+      String id,
+      String type,
+      Uri uri,
+      List<StreamKey> streamKeys,
+      String cacheKey,
+      byte[] customMetadata) {
+    this.id = id;
+    this.type = type;
+    this.uri = uri;
+    this.streamKeys = streamKeys;
+    this.cacheKey = cacheKey;
+    this.customMetadata = customMetadata;
+    this.state = Download.STATE_QUEUED;
+    this.contentLength = C.LENGTH_UNSET;
+    this.failureReason = Download.FAILURE_REASON_NONE;
+    this.progress = new DownloadProgress();
+  }
+
+  public DownloadBuilder setId(String id) {
+    this.id = id;
+    return this;
+  }
+
+  public DownloadBuilder setType(String type) {
+    this.type = type;
+    return this;
+  }
+
+  public DownloadBuilder setUri(String uri) {
+    this.uri = Uri.parse(uri);
+    return this;
+  }
+
+  public DownloadBuilder setUri(Uri uri) {
+    this.uri = uri;
+    return this;
+  }
+
+  public DownloadBuilder setCacheKey(@Nullable String cacheKey) {
+    this.cacheKey = cacheKey;
+    return this;
+  }
+
+  public DownloadBuilder setState(@Download.State int state) {
+    this.state = state;
+    return this;
+  }
+
+  public DownloadBuilder setPercentDownloaded(float percentDownloaded) {
+    progress.percentDownloaded = percentDownloaded;
+    return this;
+  }
+
+  public DownloadBuilder setBytesDownloaded(long bytesDownloaded) {
+    progress.bytesDownloaded = bytesDownloaded;
+    return this;
+  }
+
+  public DownloadBuilder setContentLength(long contentLength) {
+    this.contentLength = contentLength;
+    return this;
+  }
+
+  public DownloadBuilder setFailureReason(int failureReason) {
+    this.failureReason = failureReason;
+    return this;
+  }
+
+  public DownloadBuilder setStopReason(int stopReason) {
+    this.stopReason = stopReason;
+    return this;
+  }
+
+  public DownloadBuilder setStartTimeMs(long startTimeMs) {
+    this.startTimeMs = startTimeMs;
+    return this;
+  }
+
+  public DownloadBuilder setUpdateTimeMs(long updateTimeMs) {
+    this.updateTimeMs = updateTimeMs;
+    return this;
+  }
+
+  public DownloadBuilder setStreamKeys(StreamKey... streamKeys) {
+    this.streamKeys = Arrays.asList(streamKeys);
+    return this;
+  }
+
+  public DownloadBuilder setCustomMetadata(byte[] customMetadata) {
+    this.customMetadata = customMetadata;
+    return this;
+  }
+
+  public Download build() {
+    DownloadRequest request =
+        new DownloadRequest(id, type, uri, streamKeys, cacheKey, customMetadata);
+    return new Download(
+        request,
+        state,
+        startTimeMs,
+        updateTimeMs,
+        contentLength,
+        stopReason,
+        failureReason,
+        progress);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadHelperTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadHelperTest.java
new file mode 100644
index 0000000000..f06e90dc48
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadHelperTest.java
@@ -0,0 +1,526 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.offline.DownloadHelper.Callback;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.testutil.FakeMediaPeriod;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeRenderer;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.ParametersBuilder;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.ConditionVariable;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+
+/** Unit tests for {@link DownloadHelper}. */
+@RunWith(AndroidJUnit4.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public class DownloadHelperTest {
+
+  private static final String TEST_DOWNLOAD_TYPE = "downloadType";
+  private static final String TEST_CACHE_KEY = "cacheKey";
+  private static final Timeline TEST_TIMELINE =
+      new FakeTimeline(new TimelineWindowDefinition(/* periodCount= */ 2, /* id= */ new Object()));
+  private static final Object TEST_MANIFEST = new Object();
+
+  private static final Format VIDEO_FORMAT_LOW = createVideoFormat(/* bitrate= */ 200_000);
+  private static final Format VIDEO_FORMAT_HIGH = createVideoFormat(/* bitrate= */ 800_000);
+  private static final Format AUDIO_FORMAT_US = createAudioFormat(/* language= */ "US");
+  private static final Format AUDIO_FORMAT_ZH = createAudioFormat(/* language= */ "ZH");
+  private static final Format TEXT_FORMAT_US = createTextFormat(/* language= */ "US");
+  private static final Format TEXT_FORMAT_ZH = createTextFormat(/* language= */ "ZH");
+
+  private static final TrackGroup TRACK_GROUP_VIDEO_BOTH =
+      new TrackGroup(VIDEO_FORMAT_LOW, VIDEO_FORMAT_HIGH);
+  private static final TrackGroup TRACK_GROUP_VIDEO_SINGLE = new TrackGroup(VIDEO_FORMAT_LOW);
+  private static final TrackGroup TRACK_GROUP_AUDIO_US = new TrackGroup(AUDIO_FORMAT_US);
+  private static final TrackGroup TRACK_GROUP_AUDIO_ZH = new TrackGroup(AUDIO_FORMAT_ZH);
+  private static final TrackGroup TRACK_GROUP_TEXT_US = new TrackGroup(TEXT_FORMAT_US);
+  private static final TrackGroup TRACK_GROUP_TEXT_ZH = new TrackGroup(TEXT_FORMAT_ZH);
+  private static final TrackGroupArray TRACK_GROUP_ARRAY_ALL =
+      new TrackGroupArray(
+          TRACK_GROUP_VIDEO_BOTH,
+          TRACK_GROUP_AUDIO_US,
+          TRACK_GROUP_AUDIO_ZH,
+          TRACK_GROUP_TEXT_US,
+          TRACK_GROUP_TEXT_ZH);
+  private static final TrackGroupArray TRACK_GROUP_ARRAY_SINGLE =
+      new TrackGroupArray(TRACK_GROUP_VIDEO_SINGLE, TRACK_GROUP_AUDIO_US);
+  private static final TrackGroupArray[] TRACK_GROUP_ARRAYS =
+      new TrackGroupArray[] {TRACK_GROUP_ARRAY_ALL, TRACK_GROUP_ARRAY_SINGLE};
+
+  private Uri testUri;
+
+  private DownloadHelper downloadHelper;
+
+  @Before
+  public void setUp() {
+    testUri = Uri.parse("http://test.uri");
+
+    FakeRenderer videoRenderer = new FakeRenderer(VIDEO_FORMAT_LOW, VIDEO_FORMAT_HIGH);
+    FakeRenderer audioRenderer = new FakeRenderer(AUDIO_FORMAT_US, AUDIO_FORMAT_ZH);
+    FakeRenderer textRenderer = new FakeRenderer(TEXT_FORMAT_US, TEXT_FORMAT_ZH);
+    RenderersFactory renderersFactory =
+        (handler, videoListener, audioListener, metadata, text, drm) ->
+            new Renderer[] {textRenderer, audioRenderer, videoRenderer};
+
+    downloadHelper =
+        new DownloadHelper(
+            TEST_DOWNLOAD_TYPE,
+            testUri,
+            TEST_CACHE_KEY,
+            new TestMediaSource(),
+            DownloadHelper.DEFAULT_TRACK_SELECTOR_PARAMETERS,
+            Util.getRendererCapabilities(renderersFactory, /* drmSessionManager= */ null));
+  }
+
+  @Test
+  public void getManifest_returnsManifest() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+
+    Object manifest = downloadHelper.getManifest();
+
+    assertThat(manifest).isEqualTo(TEST_MANIFEST);
+  }
+
+  @Test
+  public void getPeriodCount_returnsPeriodCount() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+
+    int periodCount = downloadHelper.getPeriodCount();
+
+    assertThat(periodCount).isEqualTo(2);
+  }
+
+  @Test
+  public void getTrackGroups_returnsTrackGroups() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+
+    TrackGroupArray trackGroupArrayPeriod0 = downloadHelper.getTrackGroups(/* periodIndex= */ 0);
+    TrackGroupArray trackGroupArrayPeriod1 = downloadHelper.getTrackGroups(/* periodIndex= */ 1);
+
+    assertThat(trackGroupArrayPeriod0).isEqualTo(TRACK_GROUP_ARRAYS[0]);
+    assertThat(trackGroupArrayPeriod1).isEqualTo(TRACK_GROUP_ARRAYS[1]);
+  }
+
+  @Test
+  public void getMappedTrackInfo_returnsMappedTrackInfo() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+
+    MappedTrackInfo mappedTracks0 = downloadHelper.getMappedTrackInfo(/* periodIndex= */ 0);
+    MappedTrackInfo mappedTracks1 = downloadHelper.getMappedTrackInfo(/* periodIndex= */ 1);
+
+    assertThat(mappedTracks0.getRendererCount()).isEqualTo(3);
+    assertThat(mappedTracks0.getRendererType(/* rendererIndex= */ 0)).isEqualTo(C.TRACK_TYPE_TEXT);
+    assertThat(mappedTracks0.getRendererType(/* rendererIndex= */ 1)).isEqualTo(C.TRACK_TYPE_AUDIO);
+    assertThat(mappedTracks0.getRendererType(/* rendererIndex= */ 2)).isEqualTo(C.TRACK_TYPE_VIDEO);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 0).length).isEqualTo(2);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 1).length).isEqualTo(2);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 2).length).isEqualTo(1);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 0).get(/* index= */ 0))
+        .isEqualTo(TRACK_GROUP_TEXT_US);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 0).get(/* index= */ 1))
+        .isEqualTo(TRACK_GROUP_TEXT_ZH);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 1).get(/* index= */ 0))
+        .isEqualTo(TRACK_GROUP_AUDIO_US);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 1).get(/* index= */ 1))
+        .isEqualTo(TRACK_GROUP_AUDIO_ZH);
+    assertThat(mappedTracks0.getTrackGroups(/* rendererIndex= */ 2).get(/* index= */ 0))
+        .isEqualTo(TRACK_GROUP_VIDEO_BOTH);
+
+    assertThat(mappedTracks1.getRendererCount()).isEqualTo(3);
+    assertThat(mappedTracks1.getRendererType(/* rendererIndex= */ 0)).isEqualTo(C.TRACK_TYPE_TEXT);
+    assertThat(mappedTracks1.getRendererType(/* rendererIndex= */ 1)).isEqualTo(C.TRACK_TYPE_AUDIO);
+    assertThat(mappedTracks1.getRendererType(/* rendererIndex= */ 2)).isEqualTo(C.TRACK_TYPE_VIDEO);
+    assertThat(mappedTracks1.getTrackGroups(/* rendererIndex= */ 0).length).isEqualTo(0);
+    assertThat(mappedTracks1.getTrackGroups(/* rendererIndex= */ 1).length).isEqualTo(1);
+    assertThat(mappedTracks1.getTrackGroups(/* rendererIndex= */ 2).length).isEqualTo(1);
+    assertThat(mappedTracks1.getTrackGroups(/* rendererIndex= */ 1).get(/* index= */ 0))
+        .isEqualTo(TRACK_GROUP_AUDIO_US);
+    assertThat(mappedTracks1.getTrackGroups(/* rendererIndex= */ 2).get(/* index= */ 0))
+        .isEqualTo(TRACK_GROUP_VIDEO_SINGLE);
+  }
+
+  @Test
+  public void getTrackSelections_returnsInitialSelection() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+
+    List<TrackSelection> selectedText0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 2);
+    List<TrackSelection> selectedText1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 2);
+
+    assertSingleTrackSelectionEquals(selectedText0, TRACK_GROUP_TEXT_US, 0);
+    assertSingleTrackSelectionEquals(selectedAudio0, TRACK_GROUP_AUDIO_US, 0);
+    assertSingleTrackSelectionEquals(selectedVideo0, TRACK_GROUP_VIDEO_BOTH, 1);
+
+    assertThat(selectedText1).isEmpty();
+    assertSingleTrackSelectionEquals(selectedAudio1, TRACK_GROUP_AUDIO_US, 0);
+    assertSingleTrackSelectionEquals(selectedVideo1, TRACK_GROUP_VIDEO_SINGLE, 0);
+  }
+
+  @Test
+  public void getTrackSelections_afterClearTrackSelections_isEmpty() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+
+    // Clear only one period selection to verify second period selection is untouched.
+    downloadHelper.clearTrackSelections(/* periodIndex= */ 0);
+    List<TrackSelection> selectedText0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 2);
+    List<TrackSelection> selectedText1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 2);
+
+    assertThat(selectedText0).isEmpty();
+    assertThat(selectedAudio0).isEmpty();
+    assertThat(selectedVideo0).isEmpty();
+
+    // Verify
+    assertThat(selectedText1).isEmpty();
+    assertSingleTrackSelectionEquals(selectedAudio1, TRACK_GROUP_AUDIO_US, 0);
+    assertSingleTrackSelectionEquals(selectedVideo1, TRACK_GROUP_VIDEO_SINGLE, 0);
+  }
+
+  @Test
+  public void getTrackSelections_afterReplaceTrackSelections_returnsNewSelections()
+      throws Exception {
+    prepareDownloadHelper(downloadHelper);
+    DefaultTrackSelector.Parameters parameters =
+        new ParametersBuilder()
+            .setPreferredAudioLanguage("ZH")
+            .setPreferredTextLanguage("ZH")
+            .setRendererDisabled(/* rendererIndex= */ 2, true)
+            .build();
+
+    // Replace only one period selection to verify second period selection is untouched.
+    downloadHelper.replaceTrackSelections(/* periodIndex= */ 0, parameters);
+    List<TrackSelection> selectedText0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 2);
+    List<TrackSelection> selectedText1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 2);
+
+    assertSingleTrackSelectionEquals(selectedText0, TRACK_GROUP_TEXT_ZH, 0);
+    assertSingleTrackSelectionEquals(selectedAudio0, TRACK_GROUP_AUDIO_ZH, 0);
+    assertThat(selectedVideo0).isEmpty();
+
+    assertThat(selectedText1).isEmpty();
+    assertSingleTrackSelectionEquals(selectedAudio1, TRACK_GROUP_AUDIO_US, 0);
+    assertSingleTrackSelectionEquals(selectedVideo1, TRACK_GROUP_VIDEO_SINGLE, 0);
+  }
+
+  @Test
+  public void getTrackSelections_afterAddTrackSelections_returnsCombinedSelections()
+      throws Exception {
+    prepareDownloadHelper(downloadHelper);
+    // Select parameters to require some merging of track groups because the new parameters add
+    // all video tracks to initial video single track selection.
+    DefaultTrackSelector.Parameters parameters =
+        new ParametersBuilder()
+            .setPreferredAudioLanguage("ZH")
+            .setPreferredTextLanguage("US")
+            .build();
+
+    // Add only to one period selection to verify second period selection is untouched.
+    downloadHelper.addTrackSelection(/* periodIndex= */ 0, parameters);
+    List<TrackSelection> selectedText0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 2);
+    List<TrackSelection> selectedText1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 2);
+
+    assertSingleTrackSelectionEquals(selectedText0, TRACK_GROUP_TEXT_US, 0);
+    assertThat(selectedAudio0).hasSize(2);
+    assertTrackSelectionEquals(selectedAudio0.get(0), TRACK_GROUP_AUDIO_US, 0);
+    assertTrackSelectionEquals(selectedAudio0.get(1), TRACK_GROUP_AUDIO_ZH, 0);
+    assertSingleTrackSelectionEquals(selectedVideo0, TRACK_GROUP_VIDEO_BOTH, 0, 1);
+
+    assertThat(selectedText1).isEmpty();
+    assertSingleTrackSelectionEquals(selectedAudio1, TRACK_GROUP_AUDIO_US, 0);
+    assertSingleTrackSelectionEquals(selectedVideo1, TRACK_GROUP_VIDEO_SINGLE, 0);
+  }
+
+  @Test
+  public void getTrackSelections_afterAddAudioLanguagesToSelection_returnsCombinedSelections()
+      throws Exception {
+    prepareDownloadHelper(downloadHelper);
+    downloadHelper.clearTrackSelections(/* periodIndex= */ 0);
+    downloadHelper.clearTrackSelections(/* periodIndex= */ 1);
+
+    // Add a non-default language, and a non-existing language (which will select the default).
+    downloadHelper.addAudioLanguagesToSelection("ZH", "Klingonese");
+    List<TrackSelection> selectedText0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 2);
+    List<TrackSelection> selectedText1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 2);
+
+    assertThat(selectedVideo0).isEmpty();
+    assertThat(selectedText0).isEmpty();
+    assertThat(selectedAudio0).hasSize(2);
+    assertTrackSelectionEquals(selectedAudio0.get(0), TRACK_GROUP_AUDIO_ZH, 0);
+    assertTrackSelectionEquals(selectedAudio0.get(1), TRACK_GROUP_AUDIO_US, 0);
+
+    assertThat(selectedVideo1).isEmpty();
+    assertThat(selectedText1).isEmpty();
+    assertSingleTrackSelectionEquals(selectedAudio1, TRACK_GROUP_AUDIO_US, 0);
+  }
+
+  @Test
+  public void getTrackSelections_afterAddTextLanguagesToSelection_returnsCombinedSelections()
+      throws Exception {
+    prepareDownloadHelper(downloadHelper);
+    downloadHelper.clearTrackSelections(/* periodIndex= */ 0);
+    downloadHelper.clearTrackSelections(/* periodIndex= */ 1);
+
+    // Add a non-default language, and a non-existing language (which will select the default).
+    downloadHelper.addTextLanguagesToSelection(
+        /* selectUndeterminedTextLanguage= */ true, "ZH", "Klingonese");
+    List<TrackSelection> selectedText0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo0 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 0, /* rendererIndex= */ 2);
+    List<TrackSelection> selectedText1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 0);
+    List<TrackSelection> selectedAudio1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 1);
+    List<TrackSelection> selectedVideo1 =
+        downloadHelper.getTrackSelections(/* periodIndex= */ 1, /* rendererIndex= */ 2);
+
+    assertThat(selectedVideo0).isEmpty();
+    assertThat(selectedAudio0).isEmpty();
+    assertThat(selectedText0).hasSize(2);
+    assertTrackSelectionEquals(selectedText0.get(0), TRACK_GROUP_TEXT_ZH, 0);
+    assertTrackSelectionEquals(selectedText0.get(1), TRACK_GROUP_TEXT_US, 0);
+
+    assertThat(selectedVideo1).isEmpty();
+    assertThat(selectedAudio1).isEmpty();
+    assertThat(selectedText1).isEmpty();
+  }
+
+  @Test
+  public void getDownloadRequest_createsDownloadRequest_withAllSelectedTracks() throws Exception {
+    prepareDownloadHelper(downloadHelper);
+    // Ensure we have track groups with multiple indices, renderers with multiple track groups and
+    // also renderers without any track groups.
+    DefaultTrackSelector.Parameters parameters =
+        new ParametersBuilder()
+            .setPreferredAudioLanguage("ZH")
+            .setPreferredTextLanguage("US")
+            .build();
+    downloadHelper.addTrackSelection(/* periodIndex= */ 0, parameters);
+    byte[] data = new byte[10];
+    Arrays.fill(data, (byte) 123);
+
+    DownloadRequest downloadRequest = downloadHelper.getDownloadRequest(data);
+
+    assertThat(downloadRequest.type).isEqualTo(TEST_DOWNLOAD_TYPE);
+    assertThat(downloadRequest.uri).isEqualTo(testUri);
+    assertThat(downloadRequest.customCacheKey).isEqualTo(TEST_CACHE_KEY);
+    assertThat(downloadRequest.data).isEqualTo(data);
+    assertThat(downloadRequest.streamKeys)
+        .containsExactly(
+            new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 0, /* trackIndex= */ 0),
+            new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 0, /* trackIndex= */ 1),
+            new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 1, /* trackIndex= */ 0),
+            new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 2, /* trackIndex= */ 0),
+            new StreamKey(/* periodIndex= */ 0, /* groupIndex= */ 3, /* trackIndex= */ 0),
+            new StreamKey(/* periodIndex= */ 1, /* groupIndex= */ 0, /* trackIndex= */ 0),
+            new StreamKey(/* periodIndex= */ 1, /* groupIndex= */ 1, /* trackIndex= */ 0));
+  }
+
+  private static void prepareDownloadHelper(DownloadHelper downloadHelper) throws Exception {
+    AtomicReference<Exception> prepareException = new AtomicReference<>(null);
+    ConditionVariable preparedCondition = new ConditionVariable();
+    downloadHelper.prepare(
+        new Callback() {
+          @Override
+          public void onPrepared(DownloadHelper helper) {
+            preparedCondition.open();
+          }
+
+          @Override
+          public void onPrepareError(DownloadHelper helper, IOException e) {
+            prepareException.set(e);
+            preparedCondition.open();
+          }
+        });
+    while (!preparedCondition.block(0)) {
+      ShadowLooper.runMainLooperToNextTask();
+    }
+    if (prepareException.get() != null) {
+      throw prepareException.get();
+    }
+  }
+
+  private static Format createVideoFormat(int bitrate) {
+    return Format.createVideoSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        /* bitrate= */ bitrate,
+        /* maxInputSize= */ Format.NO_VALUE,
+        /* width= */ 480,
+        /* height= */ 360,
+        /* frameRate= */ Format.NO_VALUE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null);
+  }
+
+  private static Format createAudioFormat(String language) {
+    return Format.createAudioSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+        /* codecs= */ null,
+        /* bitrate= */ 48000,
+        /* maxInputSize= */ Format.NO_VALUE,
+        /* channelCount= */ 2,
+        /* sampleRate */ 44100,
+        /* initializationData= */ null,
+        /* drmInitData= */ null,
+        /* selectionFlags= */ C.SELECTION_FLAG_DEFAULT,
+        /* language= */ language);
+  }
+
+  private static Format createTextFormat(String language) {
+    return Format.createTextSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ MimeTypes.TEXT_VTT,
+        /* selectionFlags= */ C.SELECTION_FLAG_DEFAULT,
+        /* language= */ language);
+  }
+
+  private static void assertSingleTrackSelectionEquals(
+      List<TrackSelection> trackSelectionList, TrackGroup trackGroup, int... tracks) {
+    assertThat(trackSelectionList).hasSize(1);
+    assertTrackSelectionEquals(trackSelectionList.get(0), trackGroup, tracks);
+  }
+
+  private static void assertTrackSelectionEquals(
+      TrackSelection trackSelection, TrackGroup trackGroup, int... tracks) {
+    assertThat(trackSelection.getTrackGroup()).isEqualTo(trackGroup);
+    assertThat(trackSelection.length()).isEqualTo(tracks.length);
+    int[] selectedTracksInGroup = new int[trackSelection.length()];
+    for (int i = 0; i < trackSelection.length(); i++) {
+      selectedTracksInGroup[i] = trackSelection.getIndexInTrackGroup(i);
+    }
+    Arrays.sort(selectedTracksInGroup);
+    Arrays.sort(tracks);
+    assertThat(selectedTracksInGroup).isEqualTo(tracks);
+  }
+
+  private static final class TestMediaSource extends FakeMediaSource {
+
+    public TestMediaSource() {
+      super(TEST_TIMELINE, TEST_MANIFEST);
+    }
+
+    @Override
+    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+      int periodIndex = TEST_TIMELINE.getIndexOfPeriod(id.periodUid);
+      return new FakeMediaPeriod(
+          TRACK_GROUP_ARRAYS[periodIndex],
+          new EventDispatcher()
+              .withParameters(/* windowIndex= */ 0, id, /* mediaTimeOffsetMs= */ 0)) {
+        @Override
+        public List<StreamKey> getStreamKeys(List<TrackSelection> trackSelections) {
+          List<StreamKey> result = new ArrayList<>();
+          for (TrackSelection trackSelection : trackSelections) {
+            int groupIndex =
+                TRACK_GROUP_ARRAYS[periodIndex].indexOf(trackSelection.getTrackGroup());
+            for (int i = 0; i < trackSelection.length(); i++) {
+              result.add(
+                  new StreamKey(periodIndex, groupIndex, trackSelection.getIndexInTrackGroup(i)));
+            }
+          }
+          return result;
+        }
+      };
+    }
+
+    @Override
+    public void releasePeriod(MediaPeriod mediaPeriod) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
index 234377895f..2b9ef11235 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
@@ -16,382 +16,517 @@
 package com.google.android.exoplayer2.offline;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState.State;
+import com.google.android.exoplayer2.offline.Download.State;
+import com.google.android.exoplayer2.scheduler.Requirements;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
+import com.google.android.exoplayer2.testutil.DummyMainThread.TestRunnable;
 import com.google.android.exoplayer2.testutil.RobolectricUtil;
 import com.google.android.exoplayer2.testutil.TestDownloadManagerListener;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache;
-import com.google.android.exoplayer2.util.Util;
-import java.io.DataOutputStream;
-import java.io.File;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 /** Tests {@link DownloadManager}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public class DownloadManagerTest {
 
-  /* Used to check if condition becomes true in this time interval. */
+  /** Used to check if condition becomes true in this time interval. */
   private static final int ASSERT_TRUE_TIMEOUT = 10000;
-  /* Used to check if condition stays false for this time interval. */
+  /** Used to check if condition stays false for this time interval. */
   private static final int ASSERT_FALSE_TIME = 1000;
-  /* Maximum retry delay in DownloadManager. */
+  /** Maximum retry delay in DownloadManager. */
   private static final int MAX_RETRY_DELAY = 5000;
-
+  /** Maximum number of times a downloader can be restarted before doing a released check. */
+  private static final int MAX_STARTS_BEFORE_RELEASED = 1;
+  /** A stop reason. */
+  private static final int APP_STOP_REASON = 1;
+  /** The minimum number of times a task must be retried before failing. */
   private static final int MIN_RETRY_COUNT = 3;
+  /** Dummy value for the current time. */
+  private static final long NOW_MS = 1234;
 
   private Uri uri1;
   private Uri uri2;
   private Uri uri3;
   private DummyMainThread dummyMainThread;
-  private File actionFile;
+  private DefaultDownloadIndex downloadIndex;
   private TestDownloadManagerListener downloadManagerListener;
+  private FakeDownloaderFactory downloaderFactory;
   private DownloadManager downloadManager;
 
   @Before
   public void setUp() throws Exception {
+    ShadowLog.stream = System.out;
     MockitoAnnotations.initMocks(this);
     uri1 = Uri.parse("http://abc.com/media1");
     uri2 = Uri.parse("http://abc.com/media2");
     uri3 = Uri.parse("http://abc.com/media3");
     dummyMainThread = new DummyMainThread();
-    actionFile = Util.createTempFile(RuntimeEnvironment.application, "ExoPlayerTest");
+    downloadIndex = new DefaultDownloadIndex(TestUtil.getTestDatabaseProvider());
+    downloaderFactory = new FakeDownloaderFactory();
     setUpDownloadManager(100);
   }
 
   @After
   public void tearDown() throws Exception {
     releaseDownloadManager();
-    actionFile.delete();
     dummyMainThread.release();
   }
 
   @Test
-  public void testDownloadActionRuns() throws Throwable {
-    doTestActionRuns(createDownloadAction(uri1));
+  public void downloadRunner_multipleInstancePerContent_throwsException() {
+    boolean exceptionThrown = false;
+    try {
+      new DownloadRunner(uri1);
+      new DownloadRunner(uri1);
+      // can't put fail() here as it would be caught in the catch below.
+    } catch (Throwable e) {
+      exceptionThrown = true;
+    }
+    assertThat(exceptionThrown).isTrue();
   }
 
   @Test
-  public void testRemoveActionRuns() throws Throwable {
-    doTestActionRuns(createRemoveAction(uri1));
+  public void multipleRequestsForTheSameContent_executedOnTheSameTask() {
+    // Two download requests on first task
+    new DownloadRunner(uri1).postDownloadRequest().postDownloadRequest();
+    // One download, one remove requests on second task
+    new DownloadRunner(uri2).postDownloadRequest().postRemoveRequest();
+    // Two remove requests on third task
+    new DownloadRunner(uri3).postRemoveRequest().postRemoveRequest();
   }
 
   @Test
-  public void testDownloadRetriesThenFails() throws Throwable {
-    FakeDownloadAction downloadAction = createDownloadAction(uri1);
-    downloadAction.post();
-    FakeDownloader fakeDownloader = downloadAction.getFakeDownloader();
-    fakeDownloader.enableDownloadIOException = true;
-    for (int i = 0; i <= MIN_RETRY_COUNT; i++) {
-      fakeDownloader.assertStarted(MAX_RETRY_DELAY).unblock();
-    }
-    downloadAction.assertFailed();
-    downloadManagerListener.clearDownloadError();
+  public void requestsForDifferentContent_executedOnDifferentTasks() {
+    TaskWrapper task1 = new DownloadRunner(uri1).postDownloadRequest().getTask();
+    TaskWrapper task2 = new DownloadRunner(uri2).postDownloadRequest().getTask();
+    TaskWrapper task3 = new DownloadRunner(uri3).postRemoveRequest().getTask();
 
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    assertThat(task1).isNoneOf(task2, task3);
+    assertThat(task2).isNotEqualTo(task3);
   }
 
   @Test
-  public void testDownloadNoRetryWhenCanceled() throws Throwable {
-    FakeDownloadAction downloadAction = createDownloadAction(uri1).ignoreInterrupts();
-    downloadAction.getFakeDownloader().enableDownloadIOException = true;
-    downloadAction.post().assertStarted();
-
-    FakeDownloadAction removeAction = createRemoveAction(uri1).post();
-
-    downloadAction.unblock().assertCanceled();
-    removeAction.unblock();
+  public void postDownloadRequest_downloads() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    TaskWrapper task = runner.postDownloadRequest().getTask();
+    task.assertDownloading();
+    runner.getDownloader(0).unblock().assertReleased().assertStartCount(1);
+    task.assertCompleted();
+    runner.assertCreatedDownloaderCount(1);
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    assertThat(downloadManager.getCurrentDownloads()).isEmpty();
+  }
 
+  @Test
+  public void postRemoveRequest_removes() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    TaskWrapper task = runner.postDownloadRequest().postRemoveRequest().getTask();
+    task.assertRemoving();
+    runner.getDownloader(1).unblock().assertReleased().assertStartCount(1);
+    task.assertRemoved();
+    runner.assertCreatedDownloaderCount(2);
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    assertThat(downloadManager.getCurrentDownloads()).isEmpty();
   }
 
   @Test
-  public void testDownloadRetriesThenContinues() throws Throwable {
-    FakeDownloadAction downloadAction = createDownloadAction(uri1);
-    downloadAction.post();
-    FakeDownloader fakeDownloader = downloadAction.getFakeDownloader();
-    fakeDownloader.enableDownloadIOException = true;
+  public void downloadFails_retriesThenTaskFails() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    runner.postDownloadRequest();
+    FakeDownloader downloader = runner.getDownloader(0);
+
     for (int i = 0; i <= MIN_RETRY_COUNT; i++) {
-      fakeDownloader.assertStarted(MAX_RETRY_DELAY);
-      if (i == MIN_RETRY_COUNT) {
-        fakeDownloader.enableDownloadIOException = false;
-      }
-      fakeDownloader.unblock();
+      downloader.assertStarted(MAX_RETRY_DELAY).fail();
     }
-    downloadAction.assertCompleted();
 
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    downloader.assertReleased().assertStartCount(MIN_RETRY_COUNT + 1);
+    runner.getTask().assertFailed();
+    downloadManagerListener.blockUntilTasksComplete();
+    assertThat(downloadManager.getCurrentDownloads()).isEmpty();
   }
 
   @Test
-  @SuppressWarnings({"NonAtomicVolatileUpdate", "NonAtomicOperationOnVolatileField"})
-  public void testDownloadRetryCountResetsOnProgress() throws Throwable {
-    FakeDownloadAction downloadAction = createDownloadAction(uri1);
-    downloadAction.post();
-    FakeDownloader fakeDownloader = downloadAction.getFakeDownloader();
-    fakeDownloader.enableDownloadIOException = true;
-    fakeDownloader.downloadedBytes = 0;
-    for (int i = 0; i <= MIN_RETRY_COUNT + 10; i++) {
-      fakeDownloader.assertStarted(MAX_RETRY_DELAY);
-      fakeDownloader.downloadedBytes++;
-      if (i == MIN_RETRY_COUNT + 10) {
-        fakeDownloader.enableDownloadIOException = false;
-      }
-      fakeDownloader.unblock();
+  public void downloadFails_retries() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    runner.postDownloadRequest();
+    FakeDownloader downloader = runner.getDownloader(0);
+
+    for (int i = 0; i < MIN_RETRY_COUNT; i++) {
+      downloader.assertStarted(MAX_RETRY_DELAY).fail();
     }
-    downloadAction.assertCompleted();
+    downloader.assertStarted(MAX_RETRY_DELAY).unblock();
 
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    downloader.assertReleased().assertStartCount(MIN_RETRY_COUNT + 1);
+    runner.getTask().assertCompleted();
+    downloadManagerListener.blockUntilTasksComplete();
+    assertThat(downloadManager.getCurrentDownloads()).isEmpty();
   }
 
   @Test
-  public void testDifferentMediaDownloadActionsStartInParallel() throws Throwable {
-    doTestActionsRunInParallel(createDownloadAction(uri1), createDownloadAction(uri2));
+  public void downloadProgressOnRetry_retryCountResets() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    runner.postDownloadRequest();
+    FakeDownloader downloader = runner.getDownloader(0);
+
+    int tooManyRetries = MIN_RETRY_COUNT + 10;
+    for (int i = 0; i < tooManyRetries; i++) {
+      downloader.incrementBytesDownloaded();
+      downloader.assertStarted(MAX_RETRY_DELAY).fail();
+    }
+    downloader.assertStarted(MAX_RETRY_DELAY).unblock();
+
+    downloader.assertReleased().assertStartCount(tooManyRetries + 1);
+    runner.getTask().assertCompleted();
+    downloadManagerListener.blockUntilTasksComplete();
   }
 
   @Test
-  public void testDifferentMediaDifferentActionsStartInParallel() throws Throwable {
-    doTestActionsRunInParallel(createDownloadAction(uri1), createRemoveAction(uri2));
+  public void removeCancelsDownload() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    FakeDownloader downloader1 = runner.getDownloader(0);
+
+    runner.postDownloadRequest();
+    downloader1.assertStarted();
+    runner.postRemoveRequest();
+
+    downloader1.assertCanceled().assertStartCount(1);
+    runner.getDownloader(1).unblock().assertNotCanceled();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testSameMediaDownloadActionsStartInParallel() throws Throwable {
-    doTestActionsRunInParallel(createDownloadAction(uri1), createDownloadAction(uri1));
+  public void downloadNotCancelRemove() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    FakeDownloader downloader1 = runner.getDownloader(1);
+
+    runner.postDownloadRequest().postRemoveRequest();
+    downloader1.assertStarted();
+    runner.postDownloadRequest();
+
+    downloader1.unblock().assertNotCanceled();
+    runner.getDownloader(2).unblock().assertNotCanceled();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testSameMediaRemoveActionWaitsDownloadAction() throws Throwable {
-    doTestActionsRunSequentially(createDownloadAction(uri1), createRemoveAction(uri1));
+  public void secondSameRemoveRequestIgnored() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    FakeDownloader downloader1 = runner.getDownloader(1);
+
+    runner.postDownloadRequest().postRemoveRequest();
+    downloader1.assertStarted();
+    runner.postRemoveRequest();
+
+    downloader1.unblock().assertNotCanceled();
+    runner.getTask().assertRemoved();
+    runner.assertCreatedDownloaderCount(2);
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testSameMediaDownloadActionWaitsRemoveAction() throws Throwable {
-    doTestActionsRunSequentially(createRemoveAction(uri1), createDownloadAction(uri1));
+  public void differentDownloadRequestsMerged() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1);
+    FakeDownloader downloader1 = runner.getDownloader(0);
+
+    StreamKey streamKey1 = new StreamKey(/* groupIndex= */ 0, /* trackIndex= */ 0);
+    StreamKey streamKey2 = new StreamKey(/* groupIndex= */ 1, /* trackIndex= */ 1);
+
+    runner.postDownloadRequest(streamKey1);
+    downloader1.assertStarted();
+    runner.postDownloadRequest(streamKey2);
+
+    downloader1.assertCanceled();
+
+    FakeDownloader downloader2 = runner.getDownloader(1);
+    downloader2.assertStarted();
+    assertThat(downloader2.request.streamKeys).containsExactly(streamKey1, streamKey2);
+    downloader2.unblock();
+
+    runner.getTask().assertCompleted();
+    runner.assertCreatedDownloaderCount(2);
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testSameMediaRemoveActionWaitsRemoveAction() throws Throwable {
-    doTestActionsRunSequentially(createRemoveAction(uri1), createRemoveAction(uri1));
+  public void requestsForDifferentContent_executedInParallel() throws Throwable {
+    DownloadRunner runner1 = new DownloadRunner(uri1).postDownloadRequest();
+    DownloadRunner runner2 = new DownloadRunner(uri2).postDownloadRequest();
+    FakeDownloader downloader1 = runner1.getDownloader(0);
+    FakeDownloader downloader2 = runner2.getDownloader(0);
+
+    downloader1.assertStarted();
+    downloader2.assertStarted();
+    downloader1.unblock();
+    downloader2.unblock();
+
+    runner1.getTask().assertCompleted();
+    runner2.getTask().assertCompleted();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testSameMediaMultipleActions() throws Throwable {
-    FakeDownloadAction downloadAction1 = createDownloadAction(uri1).ignoreInterrupts();
-    FakeDownloadAction downloadAction2 = createDownloadAction(uri1).ignoreInterrupts();
-    FakeDownloadAction removeAction1 = createRemoveAction(uri1);
-    FakeDownloadAction downloadAction3 = createDownloadAction(uri1);
-    FakeDownloadAction removeAction2 = createRemoveAction(uri1);
-
-    // Two download actions run in parallel.
-    downloadAction1.post().assertStarted();
-    downloadAction2.post().assertStarted();
-    // removeAction1 is added. It interrupts the two download actions' threads but they are
-    // configured to ignore it so removeAction1 doesn't start.
-    removeAction1.post().assertDoesNotStart();
-
-    // downloadAction2 finishes but it isn't enough to start removeAction1.
-    downloadAction2.unblock().assertCanceled();
-    removeAction1.assertDoesNotStart();
-    // downloadAction3 is post to DownloadManager but it waits for removeAction1 to finish.
-    downloadAction3.post().assertDoesNotStart();
-
-    // When downloadAction1 finishes, removeAction1 starts.
-    downloadAction1.unblock().assertCanceled();
-    removeAction1.assertStarted();
-    // downloadAction3 still waits removeAction1
-    downloadAction3.assertDoesNotStart();
-
-    // removeAction2 is posted. removeAction1 and downloadAction3 is canceled so removeAction2
-    // starts immediately.
-    removeAction2.post();
-    removeAction1.assertCanceled();
-    downloadAction3.assertCanceled();
-    removeAction2.assertStarted().unblock().assertCompleted();
+  public void requestsForDifferentContent_ifMaxDownloadIs1_executedSequentially() throws Throwable {
+    setUpDownloadManager(1);
+    DownloadRunner runner1 = new DownloadRunner(uri1).postDownloadRequest();
+    DownloadRunner runner2 = new DownloadRunner(uri2).postDownloadRequest();
+    FakeDownloader downloader1 = runner1.getDownloader(0);
+    FakeDownloader downloader2 = runner2.getDownloader(0);
+
+    downloader1.assertStarted();
+    downloader2.assertDoesNotStart();
+    runner2.getTask().assertQueued();
+    downloader1.unblock();
+    downloader2.assertStarted();
+    downloader2.unblock();
+
+    runner1.getTask().assertCompleted();
+    runner2.getTask().assertCompleted();
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testMultipleRemoveActionWaitsLastCancelsAllOther() throws Throwable {
-    FakeDownloadAction removeAction1 = createRemoveAction(uri1).ignoreInterrupts();
-    FakeDownloadAction removeAction2 = createRemoveAction(uri1);
-    FakeDownloadAction removeAction3 = createRemoveAction(uri1);
-
-    removeAction1.post().assertStarted();
-    removeAction2.post().assertDoesNotStart();
-    removeAction3.post().assertDoesNotStart();
-
-    removeAction2.assertCanceled();
-
-    removeAction1.unblock().assertCanceled();
-    removeAction3.assertStarted().unblock().assertCompleted();
+  public void removeRequestForDifferentContent_ifMaxDownloadIs1_executedInParallel()
+      throws Throwable {
+    setUpDownloadManager(1);
+    DownloadRunner runner1 = new DownloadRunner(uri1).postDownloadRequest();
+    DownloadRunner runner2 = new DownloadRunner(uri2).postDownloadRequest().postRemoveRequest();
+    FakeDownloader downloader1 = runner1.getDownloader(0);
+    FakeDownloader downloader2 = runner2.getDownloader(0);
+
+    downloader1.assertStarted();
+    downloader2.assertStarted();
+    downloader1.unblock();
+    downloader2.unblock();
+
+    runner1.getTask().assertCompleted();
+    runner2.getTask().assertRemoved();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+  }
 
+  @Test
+  public void downloadRequestFollowingRemove_ifMaxDownloadIs1_isNotStarted() throws Throwable {
+    setUpDownloadManager(1);
+    DownloadRunner runner1 = new DownloadRunner(uri1).postDownloadRequest();
+    DownloadRunner runner2 = new DownloadRunner(uri2).postDownloadRequest().postRemoveRequest();
+    runner2.postDownloadRequest();
+    FakeDownloader downloader1 = runner1.getDownloader(0);
+    FakeDownloader downloader2 = runner2.getDownloader(0);
+    FakeDownloader downloader3 = runner2.getDownloader(1);
+
+    downloader1.assertStarted();
+    downloader2.assertStarted();
+    downloader2.unblock();
+    downloader3.assertDoesNotStart();
+    downloader1.unblock();
+    downloader3.assertStarted();
+    downloader3.unblock();
+
+    runner1.getTask().assertCompleted();
+    runner2.getTask().assertCompleted();
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testGetTasks() throws Throwable {
-    FakeDownloadAction removeAction = createRemoveAction(uri1);
-    FakeDownloadAction downloadAction1 = createDownloadAction(uri1);
-    FakeDownloadAction downloadAction2 = createDownloadAction(uri1);
+  public void getCurrentDownloads_returnsCurrentDownloads() {
+    TaskWrapper task1 = new DownloadRunner(uri1).postDownloadRequest().getTask();
+    TaskWrapper task2 = new DownloadRunner(uri2).postDownloadRequest().getTask();
+    TaskWrapper task3 =
+        new DownloadRunner(uri3).postDownloadRequest().postRemoveRequest().getTask();
 
-    removeAction.post().assertStarted();
-    downloadAction1.post().assertDoesNotStart();
-    downloadAction2.post().assertDoesNotStart();
+    task3.assertRemoving();
+    List<Download> downloads = downloadManager.getCurrentDownloads();
 
-    TaskState[] states = downloadManager.getAllTaskStates();
-    assertThat(states).hasLength(3);
-    assertThat(states[0].action).isEqualTo(removeAction);
-    assertThat(states[1].action).isEqualTo(downloadAction1);
-    assertThat(states[2].action).isEqualTo(downloadAction2);
+    assertThat(downloads).hasSize(3);
+    String[] taskIds = {task1.taskId, task2.taskId, task3.taskId};
+    String[] downloadIds = {
+      downloads.get(0).request.id, downloads.get(1).request.id, downloads.get(2).request.id
+    };
+    assertThat(downloadIds).isEqualTo(taskIds);
   }
 
   @Test
-  public void testMultipleWaitingDownloadActionStartsInParallel() throws Throwable {
-    FakeDownloadAction removeAction = createRemoveAction(uri1);
-    FakeDownloadAction downloadAction1 = createDownloadAction(uri1);
-    FakeDownloadAction downloadAction2 = createDownloadAction(uri1);
+  public void pauseAndResume() throws Throwable {
+    DownloadRunner runner1 = new DownloadRunner(uri1);
+    DownloadRunner runner2 = new DownloadRunner(uri2);
+    DownloadRunner runner3 = new DownloadRunner(uri3);
 
-    removeAction.post().assertStarted();
-    downloadAction1.post().assertDoesNotStart();
-    downloadAction2.post().assertDoesNotStart();
+    runner1.postDownloadRequest().getTask().assertDownloading();
+    runner2.postDownloadRequest().postRemoveRequest().getTask().assertRemoving();
+    runner2.postDownloadRequest();
 
-    removeAction.unblock().assertCompleted();
-    downloadAction1.assertStarted();
-    downloadAction2.assertStarted();
-    downloadAction1.unblock().assertCompleted();
-    downloadAction2.unblock().assertCompleted();
+    runOnMainThread(() -> downloadManager.pauseDownloads());
 
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
-  }
+    runner1.getTask().assertQueued();
 
-  @Test
-  public void testDifferentMediaDownloadActionsPreserveOrder() throws Throwable {
-    FakeDownloadAction removeAction = createRemoveAction(uri1).ignoreInterrupts();
-    FakeDownloadAction downloadAction1 = createDownloadAction(uri1);
-    FakeDownloadAction downloadAction2 = createDownloadAction(uri2);
+    // remove requests aren't stopped.
+    runner2.getDownloader(1).unblock().assertReleased();
+    runner2.getTask().assertQueued();
+    // Although remove2 is finished, download2 doesn't start.
+    runner2.getDownloader(2).assertDoesNotStart();
 
-    removeAction.post().assertStarted();
-    downloadAction1.post().assertDoesNotStart();
-    downloadAction2.post().assertDoesNotStart();
+    // When a new remove request is added, it cancels stopped download requests with the same media.
+    runner1.postRemoveRequest();
+    runner1.getDownloader(1).assertStarted().unblock();
+    runner1.getTask().assertRemoved();
 
-    removeAction.unblock().assertCompleted();
-    downloadAction1.assertStarted();
-    downloadAction2.assertStarted();
-    downloadAction1.unblock().assertCompleted();
-    downloadAction2.unblock().assertCompleted();
+    // New download requests can be added but they don't start.
+    runner3.postDownloadRequest().getDownloader(0).assertDoesNotStart();
+
+    runOnMainThread(() -> downloadManager.resumeDownloads());
+
+    runner2.getDownloader(2).assertStarted().unblock();
+    runner3.getDownloader(0).assertStarted().unblock();
 
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testDifferentMediaRemoveActionsDoNotPreserveOrder() throws Throwable {
-    FakeDownloadAction downloadAction = createDownloadAction(uri1).ignoreInterrupts();
-    FakeDownloadAction removeAction1 = createRemoveAction(uri1);
-    FakeDownloadAction removeAction2 = createRemoveAction(uri2);
+  public void setAndClearSingleDownloadStopReason() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1).postDownloadRequest();
+    TaskWrapper task = runner.getTask();
+
+    task.assertDownloading();
+
+    runOnMainThread(() -> downloadManager.setStopReason(task.taskId, APP_STOP_REASON));
 
-    downloadAction.post().assertStarted();
-    removeAction1.post().assertDoesNotStart();
-    removeAction2.post().assertStarted();
+    task.assertStopped();
 
-    downloadAction.unblock().assertCanceled();
-    removeAction2.unblock().assertCompleted();
+    runOnMainThread(() -> downloadManager.setStopReason(task.taskId, Download.STOP_REASON_NONE));
 
-    removeAction1.assertStarted();
-    removeAction1.unblock().assertCompleted();
+    runner.getDownloader(1).assertStarted().unblock();
 
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testStopAndResume() throws Throwable {
-    FakeDownloadAction download1Action = createDownloadAction(uri1);
-    FakeDownloadAction remove2Action = createRemoveAction(uri2);
-    FakeDownloadAction download2Action = createDownloadAction(uri2);
-    FakeDownloadAction remove1Action = createRemoveAction(uri1);
-    FakeDownloadAction download3Action = createDownloadAction(uri3);
+  public void setSingleDownloadStopReasonThenRemove_removesDownload() throws Throwable {
+    DownloadRunner runner = new DownloadRunner(uri1).postDownloadRequest();
+    TaskWrapper task = runner.getTask();
 
-    download1Action.post().assertStarted();
-    remove2Action.post().assertStarted();
-    download2Action.post().assertDoesNotStart();
+    task.assertDownloading();
 
-    runOnMainThread(() -> downloadManager.stopDownloads());
+    runOnMainThread(() -> downloadManager.setStopReason(task.taskId, APP_STOP_REASON));
 
-    download1Action.assertStopped();
+    task.assertStopped();
 
-    // remove actions aren't stopped.
-    remove2Action.unblock().assertCompleted();
-    // Although remove2Action is finished, download2Action doesn't start.
-    download2Action.assertDoesNotStart();
+    runner.postRemoveRequest();
+    runner.getDownloader(1).assertStarted().unblock();
+    task.assertRemoved();
 
-    // When a new remove action is added, it cancels stopped download actions with the same media.
-    remove1Action.post();
-    download1Action.assertCanceled();
-    remove1Action.assertStarted().unblock().assertCompleted();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+  }
+
+  @Test
+  public void setSingleDownloadStopReason_doesNotAffectOtherDownloads() throws Throwable {
+    DownloadRunner runner1 = new DownloadRunner(uri1);
+    DownloadRunner runner2 = new DownloadRunner(uri2);
+    DownloadRunner runner3 = new DownloadRunner(uri3);
 
-    // New download actions can be added but they don't start.
-    download3Action.post().assertDoesNotStart();
+    runner1.postDownloadRequest().getTask().assertDownloading();
+    runner2.postDownloadRequest().postRemoveRequest().getTask().assertRemoving();
 
-    runOnMainThread(() -> downloadManager.startDownloads());
+    runOnMainThread(() -> downloadManager.setStopReason(runner1.getTask().taskId, APP_STOP_REASON));
 
-    download2Action.assertStarted().unblock().assertCompleted();
-    download3Action.assertStarted().unblock().assertCompleted();
+    runner1.getTask().assertStopped();
+
+    // Other downloads aren't affected.
+    runner2.getDownloader(1).unblock().assertReleased();
+
+    // New download requests can be added and they start.
+    runner3.postDownloadRequest().getDownloader(0).assertStarted().unblock();
 
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
   @Test
-  public void testResumeBeforeTotallyStopped() throws Throwable {
-    setUpDownloadManager(2);
-    FakeDownloadAction download1Action = createDownloadAction(uri1).ignoreInterrupts();
-    FakeDownloadAction download2Action = createDownloadAction(uri2);
-    FakeDownloadAction download3Action = createDownloadAction(uri3);
+  public void mergeRequest_removing_becomesRestarting() {
+    DownloadRequest downloadRequest = createDownloadRequest();
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(downloadRequest).setState(Download.STATE_REMOVING);
+    Download download = downloadBuilder.build();
 
-    download1Action.post().assertStarted();
-    download2Action.post().assertStarted();
-    // download3Action doesn't start as DM was configured to run two downloads in parallel.
-    download3Action.post().assertDoesNotStart();
+    Download mergedDownload =
+        DownloadManager.mergeRequest(download, downloadRequest, download.stopReason, NOW_MS);
 
-    runOnMainThread(() -> downloadManager.stopDownloads());
+    Download expectedDownload =
+        downloadBuilder.setStartTimeMs(NOW_MS).setState(Download.STATE_RESTARTING).build();
+    assertEqualIgnoringUpdateTime(mergedDownload, expectedDownload);
+  }
 
-    // download1Action doesn't stop yet as it ignores interrupts.
-    download2Action.assertStopped();
+  @Test
+  public void mergeRequest_failed_becomesQueued() {
+    DownloadRequest downloadRequest = createDownloadRequest();
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(downloadRequest)
+            .setState(Download.STATE_FAILED)
+            .setFailureReason(Download.FAILURE_REASON_UNKNOWN);
+    Download download = downloadBuilder.build();
+
+    Download mergedDownload =
+        DownloadManager.mergeRequest(download, downloadRequest, download.stopReason, NOW_MS);
+
+    Download expectedDownload =
+        downloadBuilder
+            .setStartTimeMs(NOW_MS)
+            .setState(Download.STATE_QUEUED)
+            .setFailureReason(Download.FAILURE_REASON_NONE)
+            .build();
+    assertEqualIgnoringUpdateTime(mergedDownload, expectedDownload);
+  }
 
-    runOnMainThread(() -> downloadManager.startDownloads());
+  @Test
+  public void mergeRequest_stopped_staysStopped() {
+    DownloadRequest downloadRequest = createDownloadRequest();
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(downloadRequest)
+            .setState(Download.STATE_STOPPED)
+            .setStopReason(/* stopReason= */ 1);
+    Download download = downloadBuilder.build();
 
-    // download2Action starts immediately.
-    download2Action.assertStarted();
+    Download mergedDownload =
+        DownloadManager.mergeRequest(download, downloadRequest, download.stopReason, NOW_MS);
 
-    // download3Action doesn't start as download1Action still holds its slot.
-    download3Action.assertDoesNotStart();
+    assertEqualIgnoringUpdateTime(mergedDownload, download);
+  }
 
-    // when unblocked download1Action stops and starts immediately.
-    download1Action.unblock().assertStopped().assertStarted();
+  @Test
+  public void mergeRequest_completedWithStopReason_becomesStopped() {
+    DownloadRequest downloadRequest = createDownloadRequest();
+    DownloadBuilder downloadBuilder =
+        new DownloadBuilder(downloadRequest)
+            .setState(Download.STATE_COMPLETED)
+            .setStopReason(/* stopReason= */ 1);
+    Download download = downloadBuilder.build();
 
-    download1Action.unblock();
-    download2Action.unblock();
-    download3Action.unblock();
+    Download mergedDownload =
+        DownloadManager.mergeRequest(download, downloadRequest, download.stopReason, NOW_MS);
 
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    Download expectedDownload =
+        downloadBuilder.setStartTimeMs(NOW_MS).setState(Download.STATE_STOPPED).build();
+    assertEqualIgnoringUpdateTime(mergedDownload, expectedDownload);
   }
 
-  private void setUpDownloadManager(final int maxActiveDownloadTasks) throws Exception {
+  private void setUpDownloadManager(final int maxParallelDownloads) throws Exception {
     if (downloadManager != null) {
       releaseDownloadManager();
     }
@@ -400,17 +535,15 @@ private void setUpDownloadManager(final int maxActiveDownloadTasks) throws Excep
           () -> {
             downloadManager =
                 new DownloadManager(
-                    new DownloaderConstructorHelper(
-                        Mockito.mock(Cache.class), DummyDataSource.FACTORY),
-                    maxActiveDownloadTasks,
-                    MIN_RETRY_COUNT,
-                    actionFile,
-                    ProgressiveDownloadAction.DESERIALIZER);
+                    ApplicationProvider.getApplicationContext(), downloadIndex, downloaderFactory);
+            downloadManager.setMaxParallelDownloads(maxParallelDownloads);
+            downloadManager.setMinRetryCount(MIN_RETRY_COUNT);
+            downloadManager.setRequirements(new Requirements(0));
+            downloadManager.resumeDownloads();
             downloadManagerListener =
                 new TestDownloadManagerListener(downloadManager, dummyMainThread);
-            downloadManager.addListener(downloadManagerListener);
-            downloadManager.startDownloads();
           });
+      downloadManagerListener.waitUntilInitialized();
     } catch (Throwable throwable) {
       throw new Exception(throwable);
     }
@@ -424,158 +557,214 @@ private void releaseDownloadManager() throws Exception {
     }
   }
 
-  private void doTestActionRuns(FakeDownloadAction action) throws Throwable {
-    action.post().assertStarted().unblock().assertCompleted();
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+  private void runOnMainThread(TestRunnable r) {
+    dummyMainThread.runTestOnMainThread(r);
   }
 
-  private void doTestActionsRunSequentially(FakeDownloadAction action1, FakeDownloadAction action2)
-      throws Throwable {
-    action1.ignoreInterrupts().post().assertStarted();
-    action2.post().assertDoesNotStart();
-
-    action1.unblock();
-    action2.assertStarted();
-
-    action2.unblock().assertCompleted();
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+  private static void assertEqualIgnoringUpdateTime(Download download, Download that) {
+    assertThat(download.request).isEqualTo(that.request);
+    assertThat(download.state).isEqualTo(that.state);
+    assertThat(download.startTimeMs).isEqualTo(that.startTimeMs);
+    assertThat(download.contentLength).isEqualTo(that.contentLength);
+    assertThat(download.failureReason).isEqualTo(that.failureReason);
+    assertThat(download.stopReason).isEqualTo(that.stopReason);
+    assertThat(download.getPercentDownloaded()).isEqualTo(that.getPercentDownloaded());
+    assertThat(download.getBytesDownloaded()).isEqualTo(that.getBytesDownloaded());
   }
 
-  private void doTestActionsRunInParallel(FakeDownloadAction action1, FakeDownloadAction action2)
-      throws Throwable {
-    action1.post().assertStarted();
-    action2.post().assertStarted();
-    action1.unblock().assertCompleted();
-    action2.unblock().assertCompleted();
-    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+  private static DownloadRequest createDownloadRequest() {
+    return new DownloadRequest(
+        "id",
+        DownloadRequest.TYPE_DASH,
+        Uri.parse("https://www.test.com/download"),
+        Collections.emptyList(),
+        /* customCacheKey= */ null,
+        /* data= */ null);
   }
 
-  private FakeDownloadAction createDownloadAction(Uri uri) {
-    return new FakeDownloadAction(uri, /* isRemoveAction= */ false);
-  }
+  private final class DownloadRunner {
 
-  private FakeDownloadAction createRemoveAction(Uri uri) {
-    return new FakeDownloadAction(uri, /* isRemoveAction= */ true);
-  }
+    private final Uri uri;
+    private final String id;
+    private final ArrayList<FakeDownloader> downloaders;
+    private int createdDownloaderCount = 0;
+    private FakeDownloader downloader;
+    private final TaskWrapper taskWrapper;
 
-  private void runOnMainThread(final Runnable r) {
-    dummyMainThread.runOnMainThread(r);
-  }
+    private DownloadRunner(Uri uri) {
+      this.uri = uri;
+      id = uri.toString();
+      downloaders = new ArrayList<>();
+      downloader = addDownloader();
+      downloaderFactory.registerDownloadRunner(this);
+      taskWrapper = new TaskWrapper(id);
+    }
 
-  private class FakeDownloadAction extends DownloadAction {
+    private DownloadRunner postRemoveRequest() {
+      runOnMainThread(() -> downloadManager.removeDownload(id));
+      return this;
+    }
 
-    private final FakeDownloader downloader;
+    private DownloadRunner postDownloadRequest(StreamKey... keys) {
+      DownloadRequest downloadRequest =
+          new DownloadRequest(
+              id,
+              DownloadRequest.TYPE_PROGRESSIVE,
+              uri,
+              Arrays.asList(keys),
+              /* customCacheKey= */ null,
+              /* data= */ null);
+      runOnMainThread(() -> downloadManager.addDownload(downloadRequest));
+      return this;
+    }
 
-    private FakeDownloadAction(Uri uri, boolean isRemoveAction) {
-      super("Fake", /* version= */ 0, uri, isRemoveAction, /* data= */ null);
-      this.downloader = new FakeDownloader(isRemoveAction);
+    private synchronized FakeDownloader addDownloader() {
+      FakeDownloader fakeDownloader = new FakeDownloader();
+      downloaders.add(fakeDownloader);
+      return fakeDownloader;
     }
 
-    @Override
-    protected void writeToStream(DataOutputStream output) {
-      // do nothing.
+    private synchronized FakeDownloader getDownloader(int index) {
+      while (downloaders.size() <= index) {
+        addDownloader();
+      }
+      return downloaders.get(index);
     }
 
-    @Override
-    public Downloader createDownloader(DownloaderConstructorHelper downloaderConstructorHelper) {
+    private synchronized Downloader createDownloader(DownloadRequest request) {
+      downloader = getDownloader(createdDownloaderCount++);
+      downloader.request = request;
       return downloader;
     }
 
-    private FakeDownloader getFakeDownloader() {
-      return downloader;
+    private TaskWrapper getTask() {
+      return taskWrapper;
     }
 
-    private FakeDownloadAction post() {
-      runOnMainThread(() -> downloadManager.handleAction(FakeDownloadAction.this));
-      return this;
+    private void assertCreatedDownloaderCount(int count) {
+      assertThat(createdDownloaderCount).isEqualTo(count);
     }
+  }
 
-    private FakeDownloadAction assertDoesNotStart() throws InterruptedException {
-      Thread.sleep(ASSERT_FALSE_TIME);
-      assertThat(downloader.started.getCount()).isEqualTo(1);
-      return this;
+  private final class TaskWrapper {
+    private final String taskId;
+
+    private TaskWrapper(String taskId) {
+      this.taskId = taskId;
     }
 
-    private FakeDownloadAction assertStarted() throws InterruptedException {
-      downloader.assertStarted(ASSERT_TRUE_TIMEOUT);
-      return assertState(TaskState.STATE_STARTED);
+    private TaskWrapper assertDownloading() {
+      return assertState(Download.STATE_DOWNLOADING);
     }
 
-    private FakeDownloadAction assertCompleted() {
-      return assertState(TaskState.STATE_COMPLETED);
+    private TaskWrapper assertCompleted() {
+      return assertState(Download.STATE_COMPLETED);
     }
 
-    private FakeDownloadAction assertFailed() {
-      return assertState(TaskState.STATE_FAILED);
+    private TaskWrapper assertRemoving() {
+      return assertState(Download.STATE_REMOVING);
     }
 
-    private FakeDownloadAction assertCanceled() {
-      return assertState(TaskState.STATE_CANCELED);
+    private TaskWrapper assertFailed() {
+      return assertState(Download.STATE_FAILED);
     }
 
-    private FakeDownloadAction assertStopped() {
-      return assertState(TaskState.STATE_QUEUED);
+    private TaskWrapper assertQueued() {
+      return assertState(Download.STATE_QUEUED);
     }
 
-    private FakeDownloadAction assertState(@State int expectedState) {
-      while (true) {
-        Integer state = null;
-        try {
-          state = downloadManagerListener.pollStateChange(this, ASSERT_TRUE_TIMEOUT);
-        } catch (InterruptedException e) {
-          fail(e.getMessage());
-        }
-        if (expectedState == state) {
-          return this;
-        }
-      }
+    private TaskWrapper assertStopped() {
+      return assertState(Download.STATE_STOPPED);
     }
 
-    private FakeDownloadAction unblock() {
-      downloader.unblock();
+    private TaskWrapper assertState(@State int expectedState) {
+      downloadManagerListener.assertState(taskId, expectedState, ASSERT_TRUE_TIMEOUT);
       return this;
     }
 
-    private FakeDownloadAction ignoreInterrupts() {
-      downloader.ignoreInterrupts = true;
+    private TaskWrapper assertRemoved() {
+      downloadManagerListener.assertRemoved(taskId, ASSERT_TRUE_TIMEOUT);
       return this;
     }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+      return taskId.equals(((TaskWrapper) o).taskId);
+    }
+
+    @Override
+    public int hashCode() {
+      return taskId.hashCode();
+    }
   }
 
-  private static class FakeDownloader implements Downloader {
+  private static final class FakeDownloaderFactory implements DownloaderFactory {
+
+    private final HashMap<Uri, DownloadRunner> downloaders;
+
+    public FakeDownloaderFactory() {
+      downloaders = new HashMap<>();
+    }
+
+    public void registerDownloadRunner(DownloadRunner downloadRunner) {
+      assertThat(downloaders.put(downloadRunner.uri, downloadRunner)).isNull();
+    }
+
+    @Override
+    public Downloader createDownloader(DownloadRequest request) {
+      return downloaders.get(request.uri).createDownloader(request);
+    }
+  }
+
+  private static final class FakeDownloader implements Downloader {
 
     private final com.google.android.exoplayer2.util.ConditionVariable blocker;
-    private final boolean isRemoveAction;
 
+    private DownloadRequest request;
     private CountDownLatch started;
-    private boolean ignoreInterrupts;
+    private volatile boolean interrupted;
+    private volatile boolean cancelled;
     private volatile boolean enableDownloadIOException;
-    private volatile int downloadedBytes = C.LENGTH_UNSET;
+    private volatile int startCount;
+    private volatile int bytesDownloaded;
 
-    private FakeDownloader(boolean isRemoveAction) {
-      this.isRemoveAction = isRemoveAction;
+    private FakeDownloader() {
       this.started = new CountDownLatch(1);
       this.blocker = new com.google.android.exoplayer2.util.ConditionVariable();
     }
 
+    @SuppressWarnings({"NonAtomicOperationOnVolatileField", "NonAtomicVolatileUpdate"})
     @Override
-    public void download() throws InterruptedException, IOException {
-      assertThat(isRemoveAction).isFalse();
+    public void download(ProgressListener listener) throws InterruptedException, IOException {
+      // It's ok to update this directly as no other thread will update it.
+      startCount++;
       started.countDown();
       block();
+      if (bytesDownloaded > 0) {
+        listener.onProgress(C.LENGTH_UNSET, bytesDownloaded, C.PERCENTAGE_UNSET);
+      }
       if (enableDownloadIOException) {
+        enableDownloadIOException = false;
         throw new IOException();
       }
     }
 
     @Override
     public void cancel() {
-      // Do nothing.
+      cancelled = true;
     }
 
+    @SuppressWarnings({"NonAtomicOperationOnVolatileField", "NonAtomicVolatileUpdate"})
     @Override
     public void remove() throws InterruptedException {
-      assertThat(isRemoveAction).isTrue();
+      // It's ok to update this directly as no other thread will update it.
+      startCount++;
       started.countDown();
       block();
     }
@@ -587,9 +776,8 @@ private void block() throws InterruptedException {
             blocker.block();
             break;
           } catch (InterruptedException e) {
-            if (!ignoreInterrupts) {
-              throw e;
-            }
+            interrupted = true;
+            throw e;
           }
         }
       } finally {
@@ -597,25 +785,64 @@ private void block() throws InterruptedException {
       }
     }
 
+    private FakeDownloader assertStarted() throws InterruptedException {
+      return assertStarted(ASSERT_TRUE_TIMEOUT);
+    }
+
     private FakeDownloader assertStarted(int timeout) throws InterruptedException {
       assertThat(started.await(timeout, TimeUnit.MILLISECONDS)).isTrue();
       started = new CountDownLatch(1);
       return this;
     }
 
+    private FakeDownloader assertStartCount(int count) {
+      assertThat(startCount).isEqualTo(count);
+      return this;
+    }
+
+    private FakeDownloader assertReleased() throws InterruptedException {
+      int count = 0;
+      while (started.await(ASSERT_TRUE_TIMEOUT, TimeUnit.MILLISECONDS)) {
+        if (count++ >= MAX_STARTS_BEFORE_RELEASED) {
+          fail();
+        }
+        started = new CountDownLatch(1);
+      }
+      return this;
+    }
+
+    private FakeDownloader assertCanceled() throws InterruptedException {
+      assertReleased();
+      assertThat(interrupted).isTrue();
+      assertThat(cancelled).isTrue();
+      return this;
+    }
+
+    private FakeDownloader assertNotCanceled() throws InterruptedException {
+      assertReleased();
+      assertThat(interrupted).isFalse();
+      assertThat(cancelled).isFalse();
+      return this;
+    }
+
     private FakeDownloader unblock() {
       blocker.open();
       return this;
     }
 
-    @Override
-    public long getDownloadedBytes() {
-      return downloadedBytes;
+    private FakeDownloader fail() {
+      enableDownloadIOException = true;
+      return unblock();
     }
 
-    @Override
-    public float getDownloadPercentage() {
-      return Float.NaN;
+    private void assertDoesNotStart() throws InterruptedException {
+      Thread.sleep(ASSERT_FALSE_TIME);
+      assertThat(started.getCount()).isEqualTo(1);
+    }
+
+    @SuppressWarnings({"NonAtomicOperationOnVolatileField", "NonAtomicVolatileUpdate"})
+    private void incrementBytesDownloaded() {
+      bytesDownloaded++;
     }
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadRequestTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadRequestTest.java
new file mode 100644
index 0000000000..a55b1e1283
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadRequestTest.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.android.exoplayer2.offline.DownloadRequest.TYPE_DASH;
+import static com.google.android.exoplayer2.offline.DownloadRequest.TYPE_HLS;
+import static com.google.android.exoplayer2.offline.DownloadRequest.TYPE_PROGRESSIVE;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.net.Uri;
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link DownloadRequest}. */
+@RunWith(AndroidJUnit4.class)
+public class DownloadRequestTest {
+
+  private Uri uri1;
+  private Uri uri2;
+
+  @Before
+  public void setUp() {
+    uri1 = Uri.parse("http://test/1.uri");
+    uri2 = Uri.parse("http://test/2.uri");
+  }
+
+  @Test
+  public void testMergeRequests_withDifferentIds_fails() {
+    DownloadRequest request1 =
+        new DownloadRequest(
+            "id1",
+            TYPE_DASH,
+            uri1,
+            /* streamKeys= */ Collections.emptyList(),
+            /* customCacheKey= */ null,
+            /* data= */ null);
+    DownloadRequest request2 =
+        new DownloadRequest(
+            "id2",
+            TYPE_DASH,
+            uri2,
+            /* streamKeys= */ Collections.emptyList(),
+            /* customCacheKey= */ null,
+            /* data= */ null);
+    try {
+      request1.copyWithMergedRequest(request2);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testMergeRequests_withDifferentTypes_fails() {
+    DownloadRequest request1 =
+        new DownloadRequest(
+            "id1",
+            TYPE_DASH,
+            uri1,
+            /* streamKeys= */ Collections.emptyList(),
+            /* customCacheKey= */ null,
+            /* data= */ null);
+    DownloadRequest request2 =
+        new DownloadRequest(
+            "id1",
+            TYPE_HLS,
+            uri1,
+            /* streamKeys= */ Collections.emptyList(),
+            /* customCacheKey= */ null,
+            /* data= */ null);
+    try {
+      request1.copyWithMergedRequest(request2);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testMergeRequest_withSameRequest() {
+    DownloadRequest request1 = createRequest(uri1, new StreamKey(0, 0, 0));
+
+    DownloadRequest mergedRequest = request1.copyWithMergedRequest(request1);
+    assertEqual(request1, mergedRequest);
+  }
+
+  @Test
+  public void testMergeRequests_withEmptyStreamKeys() {
+    DownloadRequest request1 = createRequest(uri1, new StreamKey(0, 0, 0));
+    DownloadRequest request2 = createRequest(uri1);
+
+    // If either of the requests have empty streamKeys, the merge should have empty streamKeys.
+    DownloadRequest mergedRequest = request1.copyWithMergedRequest(request2);
+    assertThat(mergedRequest.streamKeys).isEmpty();
+
+    mergedRequest = request2.copyWithMergedRequest(request1);
+    assertThat(mergedRequest.streamKeys).isEmpty();
+  }
+
+  @Test
+  public void testMergeRequests_withOverlappingStreamKeys() {
+    StreamKey streamKey1 = new StreamKey(0, 1, 2);
+    StreamKey streamKey2 = new StreamKey(3, 4, 5);
+    StreamKey streamKey3 = new StreamKey(6, 7, 8);
+    DownloadRequest request1 = createRequest(uri1, streamKey1, streamKey2);
+    DownloadRequest request2 = createRequest(uri1, streamKey2, streamKey3);
+
+    // Merged streamKeys should be in their original order without duplicates.
+    DownloadRequest mergedRequest = request1.copyWithMergedRequest(request2);
+    assertThat(mergedRequest.streamKeys).containsExactly(streamKey1, streamKey2, streamKey3);
+
+    mergedRequest = request2.copyWithMergedRequest(request1);
+    assertThat(mergedRequest.streamKeys).containsExactly(streamKey2, streamKey3, streamKey1);
+  }
+
+  @Test
+  public void testMergeRequests_withDifferentFields() {
+    byte[] data1 = new byte[] {0, 1, 2};
+    byte[] data2 = new byte[] {3, 4, 5};
+    DownloadRequest request1 =
+        new DownloadRequest(
+            "id1",
+            TYPE_PROGRESSIVE,
+            uri1,
+            /* streamKeys= */ Collections.emptyList(),
+            "key1",
+            /* data= */ data1);
+    DownloadRequest request2 =
+        new DownloadRequest(
+            "id1",
+            TYPE_PROGRESSIVE,
+            uri2,
+            /* streamKeys= */ Collections.emptyList(),
+            "key2",
+            /* data= */ data2);
+
+    // uri, customCacheKey and data should be from the request being merged.
+    DownloadRequest mergedRequest = request1.copyWithMergedRequest(request2);
+    assertThat(mergedRequest.uri).isEqualTo(uri2);
+    assertThat(mergedRequest.customCacheKey).isEqualTo("key2");
+    assertThat(mergedRequest.data).isEqualTo(data2);
+
+    mergedRequest = request2.copyWithMergedRequest(request1);
+    assertThat(mergedRequest.uri).isEqualTo(uri1);
+    assertThat(mergedRequest.customCacheKey).isEqualTo("key1");
+    assertThat(mergedRequest.data).isEqualTo(data1);
+  }
+
+  @Test
+  public void testParcelable() {
+    ArrayList<StreamKey> streamKeys = new ArrayList<>();
+    streamKeys.add(new StreamKey(1, 2, 3));
+    streamKeys.add(new StreamKey(4, 5, 6));
+    DownloadRequest requestToParcel =
+        new DownloadRequest(
+            "id",
+            "type",
+            Uri.parse("https://abc.def/ghi"),
+            streamKeys,
+            "key",
+            new byte[] {1, 2, 3, 4, 5});
+    Parcel parcel = Parcel.obtain();
+    requestToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    DownloadRequest requestFromParcel = DownloadRequest.CREATOR.createFromParcel(parcel);
+    assertThat(requestFromParcel).isEqualTo(requestToParcel);
+
+    parcel.recycle();
+  }
+
+  @SuppressWarnings("EqualsWithItself")
+  @Test
+  public void testEquals() {
+    DownloadRequest request1 = createRequest(uri1);
+    assertThat(request1.equals(request1)).isTrue();
+
+    DownloadRequest request2 = createRequest(uri1);
+    DownloadRequest request3 = createRequest(uri1);
+    assertEqual(request2, request3);
+
+    DownloadRequest request4 = createRequest(uri1);
+    DownloadRequest request5 = createRequest(uri1, new StreamKey(0, 0, 0));
+    assertNotEqual(request4, request5);
+
+    DownloadRequest request6 = createRequest(uri1, new StreamKey(0, 1, 1));
+    DownloadRequest request7 = createRequest(uri1, new StreamKey(0, 0, 0));
+    assertNotEqual(request6, request7);
+
+    DownloadRequest request8 = createRequest(uri1);
+    DownloadRequest request9 = createRequest(uri2);
+    assertNotEqual(request8, request9);
+
+    DownloadRequest request10 = createRequest(uri1, new StreamKey(0, 0, 0), new StreamKey(0, 1, 1));
+    DownloadRequest request11 = createRequest(uri1, new StreamKey(0, 1, 1), new StreamKey(0, 0, 0));
+    assertEqual(request10, request11);
+
+    DownloadRequest request12 = createRequest(uri1, new StreamKey(0, 0, 0));
+    DownloadRequest request13 = createRequest(uri1, new StreamKey(0, 1, 1), new StreamKey(0, 0, 0));
+    assertNotEqual(request12, request13);
+
+    DownloadRequest request14 = createRequest(uri1);
+    DownloadRequest request15 = createRequest(uri1);
+    assertEqual(request14, request15);
+  }
+
+  private static void assertNotEqual(DownloadRequest request1, DownloadRequest request2) {
+    assertThat(request1).isNotEqualTo(request2);
+    assertThat(request2).isNotEqualTo(request1);
+  }
+
+  private static void assertEqual(DownloadRequest request1, DownloadRequest request2) {
+    assertThat(request1).isEqualTo(request2);
+    assertThat(request2).isEqualTo(request1);
+  }
+
+  private static DownloadRequest createRequest(Uri uri, StreamKey... keys) {
+    return new DownloadRequest(
+        uri.toString(), TYPE_DASH, uri, toList(keys), /* customCacheKey= */ null, /* data= */ null);
+  }
+
+  private static List<StreamKey> toList(StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
+    Collections.addAll(keysList, keys);
+    return keysList;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java
deleted file mode 100644
index df5e7dd044..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/ProgressiveDownloadActionTest.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.offline;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-
-/** Unit tests for {@link ProgressiveDownloadAction}. */
-@RunWith(RobolectricTestRunner.class)
-public class ProgressiveDownloadActionTest {
-
-  private Uri uri1;
-  private Uri uri2;
-
-  @Before
-  public void setUp() {
-    uri1 = Uri.parse("http://test1.uri");
-    uri2 = Uri.parse("http://test2.uri");
-  }
-
-  @Test
-  public void testDownloadActionIsNotRemoveAction() throws Exception {
-    DownloadAction action = createDownloadAction(uri1, null);
-    assertThat(action.isRemoveAction).isFalse();
-  }
-
-  @Test
-  public void testRemoveActionisRemoveAction() throws Exception {
-    DownloadAction action2 = createRemoveAction(uri1, null);
-    assertThat(action2.isRemoveAction).isTrue();
-  }
-
-  @Test
-  public void testCreateDownloader() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    DownloadAction action = createDownloadAction(uri1, null);
-    DownloaderConstructorHelper constructorHelper =
-        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
-    assertThat(action.createDownloader(constructorHelper)).isNotNull();
-  }
-
-  @Test
-  public void testSameUriCacheKeyDifferentAction_IsSameMedia() throws Exception {
-    DownloadAction action1 = createRemoveAction(uri1, null);
-    DownloadAction action2 = createDownloadAction(uri1, null);
-    assertSameMedia(action1, action2);
-  }
-
-  @Test
-  public void testNullCacheKeyDifferentUriAction_IsNotSameMedia() throws Exception {
-    DownloadAction action3 = createRemoveAction(uri2, null);
-    DownloadAction action4 = createDownloadAction(uri1, null);
-    assertNotSameMedia(action3, action4);
-  }
-
-  @Test
-  public void testSameCacheKeyDifferentUriAction_IsSameMedia() throws Exception {
-    DownloadAction action5 = createRemoveAction(uri2, "key");
-    DownloadAction action6 = createDownloadAction(uri1, "key");
-    assertSameMedia(action5, action6);
-  }
-
-  @Test
-  public void testSameUriDifferentCacheKeyAction_IsNotSameMedia() throws Exception {
-    DownloadAction action7 = createRemoveAction(uri1, "key");
-    DownloadAction action8 = createDownloadAction(uri1, "key2");
-    assertNotSameMedia(action7, action8);
-  }
-
-  @Test
-  public void testSameUriNullCacheKeyAction_IsNotSameMedia() throws Exception {
-    DownloadAction action1 = createRemoveAction(uri1, "key");
-    DownloadAction action2 = createDownloadAction(uri1, null);
-    assertNotSameMedia(action1, action2);
-  }
-
-  @Test
-  public void testEquals() throws Exception {
-    DownloadAction action1 = createRemoveAction(uri1, null);
-    assertThat(action1.equals(action1)).isTrue();
-
-    DownloadAction action2 = createRemoveAction(uri1, null);
-    DownloadAction action3 = createRemoveAction(uri1, null);
-    assertThat(action2.equals(action3)).isTrue();
-
-    DownloadAction action4 = createRemoveAction(uri1, null);
-    DownloadAction action5 = createDownloadAction(uri1, null);
-    assertThat(action4.equals(action5)).isFalse();
-
-    DownloadAction action6 = createRemoveAction(uri1, null);
-    DownloadAction action7 = createRemoveAction(uri1, "key");
-    assertThat(action6.equals(action7)).isFalse();
-
-    DownloadAction action8 = createRemoveAction(uri1, "key2");
-    DownloadAction action9 = createRemoveAction(uri1, "key");
-    assertThat(action8.equals(action9)).isFalse();
-
-    DownloadAction action10 = createRemoveAction(uri1, null);
-    DownloadAction action11 = createRemoveAction(uri2, null);
-    assertThat(action10.equals(action11)).isFalse();
-  }
-
-  @Test
-  public void testSerializerGetType() throws Exception {
-    DownloadAction action = createDownloadAction(uri1, null);
-    assertThat(action.type).isNotNull();
-  }
-
-  @Test
-  public void testSerializerWriteRead() throws Exception {
-    doTestSerializationRoundTrip(createDownloadAction(uri1, null));
-    doTestSerializationRoundTrip(createRemoveAction(uri2, "key"));
-  }
-
-  private void assertSameMedia(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1.isSameMedia(action2)).isTrue();
-    assertThat(action2.isSameMedia(action1)).isTrue();
-  }
-
-  private void assertNotSameMedia(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1.isSameMedia(action2)).isFalse();
-    assertThat(action2.isSameMedia(action1)).isFalse();
-  }
-
-  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream output = new DataOutputStream(out);
-    DownloadAction.serializeToStream(action, output);
-
-    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
-    DataInputStream input = new DataInputStream(in);
-    DownloadAction action2 =
-        DownloadAction.deserializeFromStream(
-            new DownloadAction.Deserializer[] {ProgressiveDownloadAction.DESERIALIZER}, input);
-
-    assertThat(action2).isEqualTo(action);
-  }
-
-  private static DownloadAction createDownloadAction(Uri uri1, String customCacheKey) {
-    return ProgressiveDownloadAction.createDownloadAction(uri1, null, customCacheKey);
-  }
-
-  private static DownloadAction createRemoveAction(Uri uri1, String customCacheKey) {
-    return ProgressiveDownloadAction.createRemoveAction(uri1, null, customCacheKey);
-  }
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/StreamKeyTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/StreamKeyTest.java
new file mode 100644
index 0000000000..a18c278913
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/StreamKeyTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link StreamKey}. */
+@RunWith(AndroidJUnit4.class)
+public class StreamKeyTest {
+
+  @Test
+  public void testParcelable() {
+    StreamKey streamKeyToParcel = new StreamKey(1, 2, 3);
+    Parcel parcel = Parcel.obtain();
+    streamKeyToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    StreamKey streamKeyFromParcel = StreamKey.CREATOR.createFromParcel(parcel);
+    assertThat(streamKeyFromParcel).isEqualTo(streamKeyToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
index ee8cdf4887..fc29e134d9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -19,7 +19,8 @@
 import static org.junit.Assert.fail;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
@@ -42,11 +43,10 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 /** Unit tests for {@link ClippingMediaSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public final class ClippingMediaSourceTest {
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
index 82d7f21852..4a881d53b4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
@@ -17,15 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link CompositeSequenceableLoader}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link CompositeSequenceableLoader}. */
+@RunWith(AndroidJUnit4.class)
 public final class CompositeSequenceableLoaderTest {
 
   /**
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
index dd1221f160..2c4ca7c334 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
@@ -17,13 +17,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.mock;
 
 import android.os.ConditionVariable;
+import android.os.Handler;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSource.SourceInfoRefreshListener;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
@@ -41,12 +44,10 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 /** Unit tests for {@link ConcatenatingMediaSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public final class ConcatenatingMediaSourceTest {
 
@@ -415,58 +416,101 @@ public void testIllegalArguments() {
 
   @Test
   public void testCustomCallbackBeforePreparationAddSingle() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    mediaSource.addMediaSource(createFakeMediaSource(), runnable);
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () ->
+            mediaSource.addMediaSource(
+                createFakeMediaSource(), new Handler(), runnableInvoked::open));
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationAddMultiple() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    mediaSource.addMediaSources(
-        Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
-        runnable);
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () ->
+            mediaSource.addMediaSources(
+                Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                new Handler(),
+                runnableInvoked::open));
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationAddSingleWithIndex() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), runnable);
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () ->
+            mediaSource.addMediaSource(
+                /* index */ 0, createFakeMediaSource(), new Handler(), runnableInvoked::open));
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationAddMultipleWithIndex() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    mediaSource.addMediaSources(
-        /* index */ 0,
-        Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
-        runnable);
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () ->
+            mediaSource.addMediaSources(
+                /* index */ 0,
+                Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                new Handler(),
+                runnableInvoked::open));
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationRemove() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    mediaSource.addMediaSource(createFakeMediaSource());
-    mediaSource.removeMediaSource(/* index */ 0, runnable);
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () -> {
+          mediaSource.addMediaSource(createFakeMediaSource());
+          mediaSource.removeMediaSource(/* index */ 0, new Handler(), runnableInvoked::open);
+        });
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationMove() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    mediaSource.addMediaSources(
-        Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}));
-    mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, runnable);
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () -> {
+          mediaSource.addMediaSources(
+              Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}));
+          mediaSource.moveMediaSource(
+              /* fromIndex */ 1, /* toIndex */ 0, new Handler(), runnableInvoked::open);
+        });
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
@@ -476,7 +520,8 @@ public void testCustomCallbackAfterPreparationAddSingle() throws IOException {
       testRunner.prepareSource();
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          () -> mediaSource.addMediaSource(createFakeMediaSource(), timelineGrabber));
+          () ->
+              mediaSource.addMediaSource(createFakeMediaSource(), new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(1);
     } finally {
@@ -495,6 +540,7 @@ public void testCustomCallbackAfterPreparationAddMultiple() throws IOException {
               mediaSource.addMediaSources(
                   Arrays.asList(
                       new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                  new Handler(),
                   timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
@@ -511,7 +557,8 @@ public void testCustomCallbackAfterPreparationAddSingleWithIndex() throws IOExce
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
           () ->
-              mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), timelineGrabber));
+              mediaSource.addMediaSource(
+                  /* index */ 0, createFakeMediaSource(), new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(1);
     } finally {
@@ -531,6 +578,7 @@ public void testCustomCallbackAfterPreparationAddMultipleWithIndex() throws IOEx
                   /* index */ 0,
                   Arrays.asList(
                       new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                  new Handler(),
                   timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
@@ -549,7 +597,7 @@ public void testCustomCallbackAfterPreparationRemove() throws IOException {
 
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          () -> mediaSource.removeMediaSource(/* index */ 0, timelineGrabber));
+          () -> mediaSource.removeMediaSource(/* index */ 0, new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(0);
     } finally {
@@ -571,7 +619,9 @@ public void testCustomCallbackAfterPreparationMove() throws IOException {
 
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          () -> mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, timelineGrabber));
+          () ->
+              mediaSource.moveMediaSource(
+                  /* fromIndex */ 1, /* toIndex */ 0, new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
     } finally {
@@ -579,6 +629,29 @@ public void testCustomCallbackAfterPreparationMove() throws IOException {
     }
   }
 
+  @Test
+  public void testCustomCallbackIsCalledAfterRelease() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    ConditionVariable callbackCalledCondition = new ConditionVariable();
+    try {
+      dummyMainThread.runOnMainThread(
+          () -> {
+            SourceInfoRefreshListener listener = mock(SourceInfoRefreshListener.class);
+            mediaSource.addMediaSources(Arrays.asList(createMediaSources(2)));
+            mediaSource.prepareSource(listener, /* mediaTransferListener= */ null);
+            mediaSource.moveMediaSource(
+                /* currentIndex= */ 0,
+                /* newIndex= */ 1,
+                new Handler(),
+                callbackCalledCondition::open);
+            mediaSource.releaseSource(listener);
+          });
+      assertThat(callbackCalledCondition.block(MediaSourceTestRunner.TIMEOUT_MS)).isTrue();
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
   @Test
   public void testPeriodCreationWithAds() throws IOException, InterruptedException {
     // Create concatenated media source with ad child source.
@@ -819,7 +892,7 @@ public void testClear() throws IOException {
     testRunner.prepareSource();
     final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
 
-    dummyMainThread.runOnMainThread(() -> mediaSource.clear(timelineGrabber));
+    dummyMainThread.runOnMainThread(() -> mediaSource.clear(new Handler(), timelineGrabber));
 
     Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
     assertThat(timeline.isEmpty()).isTrue();
@@ -964,10 +1037,19 @@ public void testSetShuffleOrderAfterPreparation() throws Exception {
 
   @Test
   public void testCustomCallbackBeforePreparationSetShuffleOrder() throws Exception {
-    Runnable runnable = Mockito.mock(Runnable.class);
-    mediaSource.setShuffleOrder(new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0), runnable);
+    ConditionVariable runnableInvoked = new ConditionVariable();
 
-    verify(runnable).run();
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    dummyMainThread.runOnMainThread(
+        () ->
+            mediaSource.setShuffleOrder(
+                new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0),
+                new Handler(),
+                runnableInvoked::open));
+    runnableInvoked.block(MediaSourceTestRunner.TIMEOUT_MS);
+    dummyMainThread.release();
+
+    assertThat(runnableInvoked.block(0)).isTrue();
   }
 
   @Test
@@ -981,7 +1063,9 @@ public void testCustomCallbackAfterPreparationSetShuffleOrder() throws Exception
       dummyMainThread.runOnMainThread(
           () ->
               mediaSource.setShuffleOrder(
-                  new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 3), timelineGrabber));
+                  new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 3),
+                  new Handler(),
+                  timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(0);
     } finally {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
index 9b7455ee37..68de5fef18 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
@@ -28,11 +29,10 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 /** Unit tests for {@link LoopingMediaSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public class LoopingMediaSourceTest {
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
index 3318f5a42f..130ba3c2dd 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MergingMediaSource.IllegalMergeException;
@@ -29,11 +30,10 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 /** Unit tests for {@link MergingMediaSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public class MergingMediaSourceTest {
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
index 3d78ecfb4c..450f0ecd3a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
@@ -23,7 +23,8 @@
 import static java.lang.Long.MIN_VALUE;
 import static java.util.Arrays.copyOfRange;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -36,12 +37,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Test for {@link SampleQueue}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Test for {@link SampleQueue}. */
+@RunWith(AndroidJUnit4.class)
 public final class SampleQueueTest {
 
   private static final int ALLOCATION_SIZE = 16;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
index 430ceb87f1..8fce472c68 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
@@ -18,17 +18,15 @@
 import static com.google.android.exoplayer2.C.INDEX_UNSET;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.source.ShuffleOrder.UnshuffledShuffleOrder;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link ShuffleOrder}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link ShuffleOrder}. */
+@RunWith(AndroidJUnit4.class)
 public final class ShuffleOrderTest {
 
   public static final long RANDOM_SEED = 1234567890L;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
index 1b57341d33..bdd6820efa 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
@@ -18,18 +18,16 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.util.Pair;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.Timeline.Window;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link SinglePeriodTimeline}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link SinglePeriodTimeline}. */
+@RunWith(AndroidJUnit4.class)
 public final class SinglePeriodTimelineTest {
 
   private Window window;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupArrayTest.java
index 86778a0fa0..36adc97147 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupArrayTest.java
@@ -18,14 +18,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.MimeTypes;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link TrackGroupArray}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TrackGroupArrayTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupTest.java
index 1900f3c586..4de1f8eb84 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/TrackGroupTest.java
@@ -18,14 +18,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.MimeTypes;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link TrackGroup}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TrackGroupTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
index da03df9b8a..80e7383d12 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
@@ -19,14 +19,14 @@
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link AdPlaybackState}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AdPlaybackStateTest {
 
   private static final long[] TEST_AD_GROUP_TMES_US = new long[] {0, C.msToUs(10_000)};
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/chunk/MediaChunkListIteratorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/chunk/MediaChunkListIteratorTest.java
new file mode 100644
index 0000000000..d2169d0a38
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/chunk/MediaChunkListIteratorTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.chunk;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.testutil.FakeMediaChunk;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests for {@link MediaChunkListIterator}. */
+@RunWith(AndroidJUnit4.class)
+public class MediaChunkListIteratorTest {
+
+  private static final Format TEST_FORMAT = Format.createSampleFormat(null, null, 0);
+
+  private FakeMediaChunk testChunk1;
+  private FakeMediaChunk testChunk2;
+
+  @Before
+  public void setUp() {
+    testChunk1 = new FakeMediaChunk(TEST_FORMAT, 0, 10);
+    testChunk2 = new FakeMediaChunk(TEST_FORMAT, 10, 20);
+  }
+
+  @Test
+  public void iterator_reverseOrderFalse_returnsItemsInNormalOrder() {
+    MediaChunkListIterator iterator =
+        new MediaChunkListIterator(
+            Arrays.asList(testChunk1, testChunk2), /* reverseOrder= */ false);
+    assertThat(iterator.isEnded()).isFalse();
+    assertThat(iterator.next()).isTrue();
+    assertEqual(iterator, testChunk1);
+    assertThat(iterator.next()).isTrue();
+    assertEqual(iterator, testChunk2);
+    assertThat(iterator.next()).isFalse();
+    assertThat(iterator.isEnded()).isTrue();
+  }
+
+  @Test
+  public void iterator_reverseOrderTrue_returnsItemsInReverseOrder() {
+    MediaChunkListIterator iterator =
+        new MediaChunkListIterator(
+            Arrays.asList(testChunk1, testChunk2), /* reverseOrder= */ true);
+    assertThat(iterator.isEnded()).isFalse();
+    assertThat(iterator.next()).isTrue();
+    assertEqual(iterator, testChunk2);
+    assertThat(iterator.next()).isTrue();
+    assertEqual(iterator, testChunk1);
+    assertThat(iterator.next()).isFalse();
+    assertThat(iterator.isEnded()).isTrue();
+  }
+
+  private static void assertEqual(MediaChunkListIterator iterator, FakeMediaChunk chunk) {
+    assertThat(iterator.getChunkStartTimeUs()).isEqualTo(chunk.startTimeUs);
+    assertThat(iterator.getChunkEndTimeUs()).isEqualTo(chunk.endTimeUs);
+    assertThat(iterator.getDataSpec()).isEqualTo(chunk.dataSpec);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
index 746066cb35..ab67ac115b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
@@ -17,16 +17,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
 import java.util.ArrayList;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link SsaDecoder}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class SsaDecoderTest {
 
   private static final String EMPTY = "ssa/empty";
@@ -40,7 +40,7 @@
   @Test
   public void testDecodeEmpty() throws IOException {
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), EMPTY);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(0);
@@ -50,7 +50,7 @@ public void testDecodeEmpty() throws IOException {
   @Test
   public void testDecodeTypical() throws IOException {
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
@@ -61,13 +61,16 @@ public void testDecodeTypical() throws IOException {
 
   @Test
   public void testDecodeTypicalWithInitializationData() throws IOException {
-    byte[] headerBytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_HEADER_ONLY);
-    byte[] formatBytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_FORMAT_ONLY);
+    byte[] headerBytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL_HEADER_ONLY);
+    byte[] formatBytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL_FORMAT_ONLY);
     ArrayList<byte[]> initializationData = new ArrayList<>();
     initializationData.add(formatBytes);
     initializationData.add(headerBytes);
     SsaDecoder decoder = new SsaDecoder(initializationData);
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_DIALOGUE_ONLY);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL_DIALOGUE_ONLY);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
@@ -80,7 +83,8 @@ public void testDecodeTypicalWithInitializationData() throws IOException {
   public void testDecodeInvalidTimecodes() throws IOException {
     // Parsing should succeed, parsing the third cue only.
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, INVALID_TIMECODES);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), INVALID_TIMECODES);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
@@ -90,7 +94,8 @@ public void testDecodeInvalidTimecodes() throws IOException {
   @Test
   public void testDecodeNoEndTimecodes() throws IOException {
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_END_TIMECODES);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), NO_END_TIMECODES);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(3);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
index 1430c70e09..9520262207 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
@@ -17,16 +17,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.text.Cue;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link SubripDecoder}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class SubripDecoderTest {
 
   private static final String EMPTY_FILE = "subrip/empty";
@@ -43,7 +43,7 @@
   @Test
   public void testDecodeEmpty() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY_FILE);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), EMPTY_FILE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(0);
@@ -53,7 +53,7 @@ public void testDecodeEmpty() throws IOException {
   @Test
   public void testDecodeTypical() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_FILE);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL_FILE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
@@ -66,7 +66,8 @@ public void testDecodeTypical() throws IOException {
   public void testDecodeTypicalWithByteOrderMark() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
     byte[] bytes =
-        TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_WITH_BYTE_ORDER_MARK);
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), TYPICAL_WITH_BYTE_ORDER_MARK);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
@@ -78,7 +79,9 @@ public void testDecodeTypicalWithByteOrderMark() throws IOException {
   @Test
   public void testDecodeTypicalExtraBlankLine() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_EXTRA_BLANK_LINE);
+    byte[] bytes =
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), TYPICAL_EXTRA_BLANK_LINE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
@@ -91,7 +94,9 @@ public void testDecodeTypicalExtraBlankLine() throws IOException {
   public void testDecodeTypicalMissingTimecode() throws IOException {
     // Parsing should succeed, parsing the first and third cues only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_MISSING_TIMECODE);
+    byte[] bytes =
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), TYPICAL_MISSING_TIMECODE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
@@ -103,7 +108,9 @@ public void testDecodeTypicalMissingTimecode() throws IOException {
   public void testDecodeTypicalMissingSequence() throws IOException {
     // Parsing should succeed, parsing the first and third cues only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_MISSING_SEQUENCE);
+    byte[] bytes =
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), TYPICAL_MISSING_SEQUENCE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
@@ -116,7 +123,8 @@ public void testDecodeTypicalNegativeTimestamps() throws IOException {
     // Parsing should succeed, parsing the third cue only.
     SubripDecoder decoder = new SubripDecoder();
     byte[] bytes =
-        TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_NEGATIVE_TIMESTAMPS);
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), TYPICAL_NEGATIVE_TIMESTAMPS);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
@@ -127,7 +135,8 @@ public void testDecodeTypicalNegativeTimestamps() throws IOException {
   public void testDecodeTypicalUnexpectedEnd() throws IOException {
     // Parsing should succeed, parsing the first and second cues only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_UNEXPECTED_END);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL_UNEXPECTED_END);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
@@ -138,7 +147,8 @@ public void testDecodeTypicalUnexpectedEnd() throws IOException {
   @Test
   public void testDecodeNoEndTimecodes() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_END_TIMECODES_FILE);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), NO_END_TIMECODES_FILE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertThat(subtitle.getEventTimeCount()).isEqualTo(3);
@@ -159,7 +169,8 @@ public void testDecodeNoEndTimecodes() throws IOException {
   @Test
   public void testDecodeCueWithTag() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_WITH_TAGS);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), TYPICAL_WITH_TAGS);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
     assertTypicalCue1(subtitle, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
index 72fff9606c..000d0634ce 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
@@ -30,6 +30,8 @@
 import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
 import android.text.style.UnderlineSpan;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
@@ -39,11 +41,9 @@
 import java.util.Map;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link TtmlDecoder}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TtmlDecoderTest {
 
   private static final String INLINE_ATTRIBUTES_TTML_FILE = "ttml/inline_style_attributes.xml";
@@ -700,7 +700,7 @@ private TtmlNode queryChildrenForTag(TtmlNode node, String tag, int pos) {
 
   private TtmlSubtitle getSubtitle(String file) throws IOException, SubtitleDecoderException {
     TtmlDecoder ttmlDecoder = new TtmlDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, file);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), file);
     return ttmlDecoder.decode(bytes, bytes.length, false);
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
index 536ddbabbc..40fd6f288a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
@@ -24,16 +24,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.graphics.Color;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link TtmlRenderUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link TtmlRenderUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class TtmlRenderUtilTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
index aa46584f54..24b5ca678f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
@@ -26,13 +26,13 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import android.graphics.Color;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link TtmlStyle}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class TtmlStyleTest {
 
   private static final String FONT_FAMILY = "serif";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
index 155b8f5993..16b997e117 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
@@ -25,6 +25,8 @@
 import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
 import android.text.style.UnderlineSpan;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.text.Cue;
@@ -34,11 +36,9 @@
 import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link Tx3gDecoder}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class Tx3gDecoderTest {
 
   private static final String NO_SUBTITLE = "tx3g/no_subtitle";
@@ -56,7 +56,7 @@
   @Test
   public void testDecodeNoSubtitle() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_SUBTITLE);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), NO_SUBTITLE);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     assertThat(subtitle.getCues(0)).isEmpty();
   }
@@ -64,7 +64,8 @@ public void testDecodeNoSubtitle() throws IOException, SubtitleDecoderException
   @Test
   public void testDecodeJustText() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_JUST_TEXT);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_JUST_TEXT);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
@@ -75,7 +76,8 @@ public void testDecodeJustText() throws IOException, SubtitleDecoderException {
   @Test
   public void testDecodeWithStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
@@ -92,7 +94,8 @@ public void testDecodeWithStyl() throws IOException, SubtitleDecoderException {
   public void testDecodeWithStylAllDefaults() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes =
-        TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL_ALL_DEFAULTS);
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), SAMPLE_WITH_STYL_ALL_DEFAULTS);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
@@ -103,7 +106,8 @@ public void testDecodeWithStylAllDefaults() throws IOException, SubtitleDecoderE
   @Test
   public void testDecodeUtf16BeNoStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_UTF16_BE_NO_STYL);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_UTF16_BE_NO_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("你好");
@@ -114,7 +118,8 @@ public void testDecodeUtf16BeNoStyl() throws IOException, SubtitleDecoderExcepti
   @Test
   public void testDecodeUtf16LeNoStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_UTF16_LE_NO_STYL);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_UTF16_LE_NO_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("你好");
@@ -125,7 +130,9 @@ public void testDecodeUtf16LeNoStyl() throws IOException, SubtitleDecoderExcepti
   @Test
   public void testDecodeWithMultipleStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_MULTIPLE_STYL);
+    byte[] bytes =
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), SAMPLE_WITH_MULTIPLE_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("Line 2\nLine 3");
@@ -144,7 +151,8 @@ public void testDecodeWithMultipleStyl() throws IOException, SubtitleDecoderExce
   public void testDecodeWithOtherExtension() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.emptyList());
     byte[] bytes =
-        TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_OTHER_EXTENSION);
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), SAMPLE_WITH_OTHER_EXTENSION);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
@@ -158,9 +166,11 @@ public void testDecodeWithOtherExtension() throws IOException, SubtitleDecoderEx
 
   @Test
   public void testInitializationDecodeWithStyl() throws IOException, SubtitleDecoderException {
-    byte[] initBytes = TestUtil.getByteArray(RuntimeEnvironment.application, INITIALIZATION);
+    byte[] initBytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), INITIALIZATION);
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.singletonList(initBytes));
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
@@ -179,9 +189,11 @@ public void testInitializationDecodeWithStyl() throws IOException, SubtitleDecod
 
   @Test
   public void testInitializationDecodeWithTbox() throws IOException, SubtitleDecoderException {
-    byte[] initBytes = TestUtil.getByteArray(RuntimeEnvironment.application, INITIALIZATION);
+    byte[] initBytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), INITIALIZATION);
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.singletonList(initBytes));
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_TBOX);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_WITH_TBOX);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
@@ -200,9 +212,11 @@ public void testInitializationDecodeWithTbox() throws IOException, SubtitleDecod
   public void testInitializationAllDefaultsDecodeWithStyl()
       throws IOException, SubtitleDecoderException {
     byte[] initBytes =
-        TestUtil.getByteArray(RuntimeEnvironment.application, INITIALIZATION_ALL_DEFAULTS);
+        TestUtil.getByteArray(
+            ApplicationProvider.getApplicationContext(), INITIALIZATION_ALL_DEFAULTS);
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.singletonList(initBytes));
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
+    byte[] bytes =
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
     assertThat(text.toString()).isEqualTo("CC Test");
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
index b81c0c68c3..fb9e1a875f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
@@ -18,17 +18,15 @@
 import static com.google.android.exoplayer2.text.webvtt.CssParser.parseNextToken;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link CssParser}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link CssParser}. */
+@RunWith(AndroidJUnit4.class)
 public final class CssParserTest {
 
   private CssParser parser;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
index f0c426ea65..f930c4590f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
@@ -18,18 +18,16 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link Mp4WebvttDecoder}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link Mp4WebvttDecoder}. */
+@RunWith(AndroidJUnit4.class)
 public final class Mp4WebvttDecoderTest {
 
   private static final byte[] SINGLE_CUE_SAMPLE = {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
index 9e42f0c049..32d2dc2060 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
@@ -23,15 +23,13 @@
 import android.text.Spanned;
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link WebvttCueParser}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link WebvttCueParser}. */
+@RunWith(AndroidJUnit4.class)
 public final class WebvttCueParserTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
index c4724bc8b9..2a7289c039 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
@@ -26,6 +26,8 @@
 import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
 import android.text.style.UnderlineSpan;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
@@ -33,11 +35,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit test for {@link WebvttDecoder}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class WebvttDecoderTest {
 
   private static final String TYPICAL_FILE = "webvtt/typical";
@@ -55,7 +55,7 @@
   @Test
   public void testDecodeEmpty() throws IOException {
     WebvttDecoder decoder = new WebvttDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY_FILE);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), EMPTY_FILE);
     try {
       decoder.decode(bytes, bytes.length, /* reset= */ false);
       fail();
@@ -394,7 +394,7 @@ public void testWithComplexCssSelectors() throws IOException, SubtitleDecoderExc
   private WebvttSubtitle getSubtitleForTestAsset(String asset)
       throws IOException, SubtitleDecoderException {
     WebvttDecoder decoder = new WebvttDecoder();
-    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, asset);
+    byte[] bytes = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), asset);
     return decoder.decode(bytes, bytes.length, /* reset= */ false);
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
index af165ffe9b..0f0f2572b7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
@@ -19,18 +19,16 @@
 import static com.google.common.truth.Truth.assertThat;
 import static java.lang.Long.MAX_VALUE;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.text.Cue;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link WebvttSubtitle}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link WebvttSubtitle}. */
+@RunWith(AndroidJUnit4.class)
 public class WebvttSubtitleTest {
 
   private static final String FIRST_SUBTITLE_STRING = "This is the first subtitle.";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
index 3ddc809ca4..cb7ef40726 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
@@ -16,6 +16,9 @@
 package com.google.android.exoplayer2.trackselection;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -23,30 +26,28 @@
 import static org.mockito.Mockito.when;
 import static org.mockito.MockitoAnnotations.initMocks;
 
-import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.testutil.FakeClock;
+import com.google.android.exoplayer2.testutil.FakeMediaChunk;
+import com.google.android.exoplayer2.trackselection.TrackSelection.Definition;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.DefaultHttpDataSource;
 import com.google.android.exoplayer2.util.MimeTypes;
-import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentMatcher;
 import org.mockito.Mock;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link AdaptiveTrackSelection}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AdaptiveTrackSelectionTest {
 
   private static final MediaChunkIterator[] THREE_EMPTY_MEDIA_CHUNK_ITERATORS =
@@ -66,15 +67,20 @@ public void setUp() {
   }
 
   @Test
+  @SuppressWarnings("deprecation")
   public void testFactoryUsesInitiallyProvidedBandwidthMeter() {
     BandwidthMeter initialBandwidthMeter = mock(BandwidthMeter.class);
     BandwidthMeter injectedBandwidthMeter = mock(BandwidthMeter.class);
-    Format format = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
-    @SuppressWarnings("deprecation")
-    AdaptiveTrackSelection adaptiveTrackSelection =
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    TrackSelection[] trackSelections =
         new AdaptiveTrackSelection.Factory(initialBandwidthMeter)
-            .createTrackSelection(new TrackGroup(format), injectedBandwidthMeter, /* tracks= */ 0);
-    adaptiveTrackSelection.updateSelectedTrack(
+            .createTrackSelections(
+                new Definition[] {
+                  new Definition(new TrackGroup(format1, format2), /* tracks= */ 0, 1)
+                },
+                injectedBandwidthMeter);
+    trackSelections[0].updateSelectedTrack(
         /* playbackPositionUs= */ 0,
         /* bufferedDurationUs= */ 0,
         /* availableDurationUs= */ C.TIME_UNSET,
@@ -225,6 +231,59 @@ public void testUpdateSelectedTrackSwitchDownIfNotBufferedEnough() {
     assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
   }
 
+  @Test
+  public void testUpdateSelectedTrackSwitchUpIfTrackBitrateEstimateIsLow() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    // The second measurement onward returns 1500L, which isn't enough to switch up to format3 as
+    // the format bitrate is 2000.
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(1000L, 1500L);
+
+    // But TrackBitrateEstimator returns 1500 for 3rd track so it should switch up.
+    TrackBitrateEstimator estimator = mock(TrackBitrateEstimator.class);
+    when(estimator.getBitrates(any(), any(), any(), any()))
+        .then(
+            (invocation) -> {
+              int[] returnValue = new int[] {500, 1000, 1500};
+              int[] inputArray = (int[]) invocation.getArguments()[3];
+              System.arraycopy(returnValue, 0, inputArray, 0, returnValue.length);
+              return returnValue;
+            });
+
+    adaptiveTrackSelection = adaptiveTrackSelection(trackGroup);
+    adaptiveTrackSelection.experimental_setTrackBitrateEstimator(estimator);
+
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ AdaptiveTrackSelection
+                .DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS
+            * 1000,
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
+
+    ArgumentMatcher<Format[]> matcher =
+        new ArgumentMatcher<Format[]>() {
+          @Override
+          public boolean matches(Format[] argument) {
+            Format[] formats = (Format[]) argument;
+            return formats.length == 3
+                && Arrays.asList(formats).containsAll(Arrays.asList(format1, format2, format3));
+          }
+        };
+    verify(estimator)
+        .getBitrates(
+            argThat(matcher),
+            eq(Collections.emptyList()),
+            eq(THREE_EMPTY_MEDIA_CHUNK_ITERATORS),
+            any());
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format3);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
   @Test
   public void testEvaluateQueueSizeReturnQueueSizeIfBandwidthIsNotImproved() {
     Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
@@ -327,64 +386,70 @@ public void testEvaluateQueueSizeRetainMoreThanMinimumDurationAfterDiscard() {
   }
 
   private AdaptiveTrackSelection adaptiveTrackSelection(TrackGroup trackGroup) {
-    return new AdaptiveTrackSelection(
-        trackGroup,
-        selectedAllTracksInGroup(trackGroup),
-        mockBandwidthMeter,
-        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
-        AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
-        /* bandwidthFraction= */ 1.0f,
-        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
-        AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
-        fakeClock);
+    return adaptiveTrackSelectionWithMinDurationForQualityIncreaseMs(
+        trackGroup, AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS);
   }
 
   private AdaptiveTrackSelection adaptiveTrackSelectionWithMinDurationForQualityIncreaseMs(
       TrackGroup trackGroup, long minDurationForQualityIncreaseMs) {
-    return new AdaptiveTrackSelection(
-        trackGroup,
-        selectedAllTracksInGroup(trackGroup),
-        mockBandwidthMeter,
-        minDurationForQualityIncreaseMs,
-        AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
-        /* bandwidthFraction= */ 1.0f,
-        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
-        AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
-        fakeClock);
+    return prepareTrackSelection(
+        new AdaptiveTrackSelection(
+            trackGroup,
+            selectedAllTracksInGroup(trackGroup),
+            mockBandwidthMeter,
+            minDurationForQualityIncreaseMs,
+            AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+            /* bandwidthFraction= */ 1.0f,
+            AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+            AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+            fakeClock));
   }
 
   private AdaptiveTrackSelection adaptiveTrackSelectionWithMaxDurationForQualityDecreaseMs(
       TrackGroup trackGroup, long maxDurationForQualityDecreaseMs) {
-    return new AdaptiveTrackSelection(
-        trackGroup,
-        selectedAllTracksInGroup(trackGroup),
-        mockBandwidthMeter,
-        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
-        maxDurationForQualityDecreaseMs,
-        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
-        /* bandwidthFraction= */ 1.0f,
-        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
-        AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
-        fakeClock);
+    return prepareTrackSelection(
+        new AdaptiveTrackSelection(
+            trackGroup,
+            selectedAllTracksInGroup(trackGroup),
+            mockBandwidthMeter,
+            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+            maxDurationForQualityDecreaseMs,
+            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+            /* bandwidthFraction= */ 1.0f,
+            AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+            AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+            fakeClock));
   }
 
   private AdaptiveTrackSelection adaptiveTrackSelectionWithMinTimeBetweenBufferReevaluationMs(
       TrackGroup trackGroup,
       long durationToRetainAfterDiscardMs,
       long minTimeBetweenBufferReevaluationMs) {
-    return new AdaptiveTrackSelection(
-        trackGroup,
-        selectedAllTracksInGroup(trackGroup),
-        mockBandwidthMeter,
-        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
-        AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-        durationToRetainAfterDiscardMs,
-        /* bandwidthFraction= */ 1.0f,
-        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
-        minTimeBetweenBufferReevaluationMs,
-        fakeClock);
+    return prepareTrackSelection(
+        new AdaptiveTrackSelection(
+            trackGroup,
+            selectedAllTracksInGroup(trackGroup),
+            mockBandwidthMeter,
+            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+            AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+            durationToRetainAfterDiscardMs,
+            /* bandwidthFraction= */ 1.0f,
+            AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+            minTimeBetweenBufferReevaluationMs,
+            fakeClock));
+  }
+
+  private AdaptiveTrackSelection prepareTrackSelection(
+      AdaptiveTrackSelection adaptiveTrackSelection) {
+    adaptiveTrackSelection.enable();
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ 0,
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
+    return adaptiveTrackSelection;
   }
 
   private int[] selectedAllTracksInGroup(TrackGroup trackGroup) {
@@ -409,35 +474,4 @@ private static Format videoFormat(int bitrate, int width, int height) {
         /* drmInitData= */ null);
   }
 
-  private static final class FakeMediaChunk extends MediaChunk {
-
-    private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT", null);
-
-    public FakeMediaChunk(Format trackFormat, long startTimeUs, long endTimeUs) {
-      super(
-          DATA_SOURCE,
-          new DataSpec(Uri.EMPTY),
-          trackFormat,
-          C.SELECTION_REASON_ADAPTIVE,
-          null,
-          startTimeUs,
-          endTimeUs,
-          0);
-    }
-
-    @Override
-    public void cancelLoad() {
-      // Do nothing.
-    }
-
-    @Override
-    public void load() throws IOException, InterruptedException {
-      // Do nothing.
-    }
-
-    @Override
-    public boolean isLoadCompleted() {
-      return true;
-    }
-  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/BufferSizeAdaptiveTrackSelectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/BufferSizeAdaptiveTrackSelectionTest.java
new file mode 100644
index 0000000000..8b20630a23
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/BufferSizeAdaptiveTrackSelectionTest.java
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.util.Pair;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+/** Unit test for the track selection created by {@link BufferSizeAdaptationBuilder}. */
+@RunWith(AndroidJUnit4.class)
+public final class BufferSizeAdaptiveTrackSelectionTest {
+
+  private static final int MIN_BUFFER_MS = 15_000;
+  private static final int MAX_BUFFER_MS = 50_000;
+  private static final int HYSTERESIS_BUFFER_MS = 10_000;
+  private static final float BANDWIDTH_FRACTION = 0.5f;
+  private static final int MIN_BUFFER_FOR_QUALITY_INCREASE_MS = 10_000;
+
+  /**
+   * Factor between bitrates is always the same (=2.2). That means buffer levels should be linearly
+   * distributed between MIN_BUFFER=15s and MAX_BUFFER-HYSTERESIS=50s-10s=40s.
+   */
+  private static final Format format1 =
+      createVideoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+
+  private static final Format format2 =
+      createVideoFormat(/* bitrate= */ 1100, /* width= */ 640, /* height= */ 480);
+  private static final Format format3 =
+      createVideoFormat(/* bitrate= */ 2420, /* width= */ 960, /* height= */ 720);
+  private static final int BUFFER_LEVEL_FORMAT_2 =
+      (MIN_BUFFER_MS + MAX_BUFFER_MS - HYSTERESIS_BUFFER_MS) / 2;
+  private static final int BUFFER_LEVEL_FORMAT_3 = MAX_BUFFER_MS - HYSTERESIS_BUFFER_MS;
+
+  @Mock private BandwidthMeter mockBandwidthMeter;
+  private TrackSelection trackSelection;
+
+  @Before
+  public void setUp() {
+    initMocks(this);
+    Pair<TrackSelection.Factory, LoadControl> trackSelectionFactoryAndLoadControl =
+        new BufferSizeAdaptationBuilder()
+            .setBufferDurationsMs(
+                MIN_BUFFER_MS,
+                MAX_BUFFER_MS,
+                /* bufferForPlaybackMs= */ 1000,
+                /* bufferForPlaybackAfterRebufferMs= */ 1000)
+            .setHysteresisBufferMs(HYSTERESIS_BUFFER_MS)
+            .setStartUpTrackSelectionParameters(
+                BANDWIDTH_FRACTION, MIN_BUFFER_FOR_QUALITY_INCREASE_MS)
+            .buildPlayerComponents();
+    trackSelection =
+        trackSelectionFactoryAndLoadControl
+            .first
+            .createTrackSelections(
+                new TrackSelection.Definition[] {
+                  new TrackSelection.Definition(
+                      new TrackGroup(format1, format2, format3), /* tracks= */ 0, 1, 2)
+                },
+                mockBandwidthMeter)[0];
+    trackSelection.enable();
+  }
+
+  @Test
+  public void updateSelectedTrack_usesBandwidthEstimateForInitialSelection() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void updateSelectedTrack_withLowerBandwidthEstimateDuringStartUp_switchesDown() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(0L);
+
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format1);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  @Test
+  public void
+      updateSelectedTrack_withHigherBandwidthEstimateDuringStartUp_andLowBuffer_keepsSelection() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format3));
+
+    updateSelectedTrack(/* bufferedDurationMs= */ MIN_BUFFER_FOR_QUALITY_INCREASE_MS - 1);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void
+      updateSelectedTrack_withHigherBandwidthEstimateDuringStartUp_andHighBuffer_switchesUp() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format3));
+
+    updateSelectedTrack(/* bufferedDurationMs= */ MIN_BUFFER_FOR_QUALITY_INCREASE_MS);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format3);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  @Test
+  public void
+      updateSelectedTrack_withIncreasedBandwidthEstimate_onceSteadyStateBufferIsReached_keepsSelection() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format3));
+
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void
+      updateSelectedTrack_withDecreasedBandwidthEstimate_onceSteadyStateBufferIsReached_keepsSelection() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(0L);
+
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void updateSelectedTrack_withIncreasedBufferInSteadyState_switchesUp() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_3);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format3);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  @Test
+  public void updateSelectedTrack_withDecreasedBufferInSteadyState_switchesDown() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(0L);
+
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2 - HYSTERESIS_BUFFER_MS - 1);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format1);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  @Test
+  public void
+      updateSelectedTrack_withDecreasedBufferInSteadyState_withinHysteresis_keepsSelection() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(0L);
+
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2 - HYSTERESIS_BUFFER_MS);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void onDiscontinuity_switchesBackToStartUpState() {
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(getBitrateEstimateEnoughFor(format2));
+    updateSelectedTrack(/* bufferedDurationMs= */ 0);
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(0L);
+
+    trackSelection.onDiscontinuity();
+    updateSelectedTrack(/* bufferedDurationMs= */ BUFFER_LEVEL_FORMAT_2 - 1);
+
+    assertThat(trackSelection.getSelectedFormat()).isEqualTo(format1);
+    assertThat(trackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  private void updateSelectedTrack(long bufferedDurationMs) {
+    trackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ C.msToUs(bufferedDurationMs),
+        /* availableDurationUs= */ C.TIME_UNSET,
+        /* queue= */ Collections.emptyList(),
+        /* mediaChunkIterators= */ new MediaChunkIterator[] {
+          MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY
+        });
+  }
+
+  private static Format createVideoFormat(int bitrate, int width, int height) {
+    return Format.createVideoSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        /* bitrate= */ bitrate,
+        /* maxInputSize= */ Format.NO_VALUE,
+        /* width= */ width,
+        /* height= */ height,
+        /* frameRate= */ Format.NO_VALUE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null);
+  }
+
+  private static long getBitrateEstimateEnoughFor(Format format) {
+    return (long) (format.bitrate / BANDWIDTH_FRACTION) + 1;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index 94f6abd87b..83fe34db97 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -15,14 +15,12 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
+import static com.google.android.exoplayer2.RendererCapabilities.ADAPTIVE_NOT_SEAMLESS;
 import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES;
 import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_HANDLED;
 import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_UNSUPPORTED_SUBTYPE;
 import static com.google.android.exoplayer2.RendererConfiguration.DEFAULT;
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyVararg;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -32,13 +30,17 @@
 import android.os.Parcel;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.Parameters;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.ParametersBuilder;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
@@ -48,15 +50,13 @@
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Before;
+import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link DefaultTrackSelector}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link DefaultTrackSelector}. */
+@RunWith(AndroidJUnit4.class)
 public final class DefaultTrackSelectorTest {
 
   private static final RendererCapabilities ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES =
@@ -83,7 +83,6 @@
   private static final TrackGroup AUDIO_TRACK_GROUP = new TrackGroup(AUDIO_FORMAT);
   private static final TrackGroupArray TRACK_GROUPS =
       new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);
-
   private static final TrackSelection[] TRACK_SELECTIONS =
       new TrackSelection[] {
         new FixedTrackSelection(VIDEO_TRACK_GROUP, 0), new FixedTrackSelection(AUDIO_TRACK_GROUP, 0)
@@ -91,12 +90,20 @@
   private static final TrackSelection[] TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER =
       new TrackSelection[] {new FixedTrackSelection(VIDEO_TRACK_GROUP, 0), null};
 
-  @Mock
-  private InvalidationListener invalidationListener;
+  private static final Timeline TIMELINE = new FakeTimeline(/* windowCount= */ 1);
+
+  private static MediaPeriodId periodId;
+
+  @Mock private InvalidationListener invalidationListener;
   @Mock private BandwidthMeter bandwidthMeter;
 
   private DefaultTrackSelector trackSelector;
 
+  @BeforeClass
+  public static void setUpBeforeClass() {
+    periodId = new MediaPeriodId(TIMELINE.getUidOfPeriod(/* periodIndex= */ 0));
+  }
+
   @Before
   public void setUp() {
     initMocks(this);
@@ -118,26 +125,36 @@ public void testParametersParcelable() {
 
     Parameters parametersToParcel =
         new Parameters(
-            selectionOverrides,
-            rendererDisabledFlags,
+            // Video
+            /* maxVideoWidth= */ 0,
+            /* maxVideoHeight= */ 1,
+            /* maxVideoFrameRate= */ 2,
+            /* maxVideoBitrate= */ 3,
+            /* exceedVideoConstraintsIfNecessary= */ false,
+            /* allowVideoMixedMimeTypeAdaptiveness= */ true,
+            /* allowVideoNonSeamlessAdaptiveness= */ false,
+            /* viewportWidth= */ 4,
+            /* viewportHeight= */ 5,
+            /* viewportOrientationMayChange= */ true,
+            // Audio
             /* preferredAudioLanguage= */ "en",
+            /* maxAudioChannelCount= */ 6,
+            /* maxAudioBitrate= */ 7,
+            /* exceedAudioConstraintsIfNecessary= */ false,
+            /* allowAudioMixedMimeTypeAdaptiveness= */ true,
+            /* allowAudioMixedSampleRateAdaptiveness= */ false,
+            // Text
             /* preferredTextLanguage= */ "de",
-            /* selectUndeterminedTextLanguage= */ false,
-            /* disabledTextTrackSelectionFlags= */ 0,
-            /* forceLowestBitrate= */ true,
+            /* selectUndeterminedTextLanguage= */ true,
+            /* disabledTextTrackSelectionFlags= */ 8,
+            // General
+            /* forceLowestBitrate= */ false,
             /* forceHighestSupportedBitrate= */ true,
-            /* allowMixedMimeAdaptiveness= */ false,
-            /* allowNonSeamlessAdaptiveness= */ true,
-            /* maxVideoWidth= */ 1,
-            /* maxVideoHeight= */ 2,
-            /* maxVideoFrameRate= */ 3,
-            /* maxVideoBitrate= */ 4,
-            /* exceedVideoConstraintsIfNecessary= */ false,
-            /* exceedRendererCapabilitiesIfNecessary= */ true,
-            /* viewportWidth= */ 5,
-            /* viewportHeight= */ 6,
-            /* viewportOrientationMayChange= */ false,
-            /* tunnelingAudioSessionId= */ C.AUDIO_SESSION_ID_UNSET);
+            /* exceedRendererCapabilitiesIfNecessary= */ false,
+            /* tunnelingAudioSessionId= */ C.AUDIO_SESSION_ID_UNSET,
+            // Overrides
+            selectionOverrides,
+            rendererDisabledFlags);
 
     Parcel parcel = Parcel.obtain();
     parametersToParcel.writeToParcel(parcel, 0);
@@ -170,14 +187,13 @@ public void testSelectionOverrideParcelable() {
   /** Tests that a null override clears a track selection. */
   @Test
   public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
             .setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null));
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertTrackSelections(result, new TrackSelection[] {null, TRACK_SELECTIONS[1]});
+    TrackSelectorResult result =
+        trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);
+    assertSelections(result, new TrackSelection[] {null, TRACK_SELECTIONS[1]});
     assertThat(result.rendererConfigurations)
         .isEqualTo(new RendererConfiguration[] {null, DEFAULT});
   }
@@ -185,15 +201,14 @@ public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
   /** Tests that a null override can be cleared. */
   @Test
   public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
             .setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null)
             .clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP)));
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertTrackSelections(result, TRACK_SELECTIONS);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);
+    assertSelections(result, TRACK_SELECTIONS);
     assertThat(result.rendererConfigurations)
         .isEqualTo(new RendererConfiguration[] {DEFAULT, DEFAULT});
   }
@@ -201,8 +216,6 @@ public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackExceptio
   /** Tests that an override is not applied for a different set of available track groups. */
   @Test
   public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
@@ -210,8 +223,10 @@ public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlayb
     TrackSelectorResult result =
         trackSelector.selectTracks(
             RENDERER_CAPABILITIES,
-            new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP));
-    assertTrackSelections(result, TRACK_SELECTIONS);
+            new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP),
+            periodId,
+            TIMELINE);
+    assertSelections(result, TRACK_SELECTIONS);
     assertThat(result.rendererConfigurations)
         .isEqualTo(new RendererConfiguration[] {DEFAULT, DEFAULT});
   }
@@ -219,11 +234,10 @@ public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlayb
   /** Tests disabling a renderer. */
   @Test
   public void testSelectTracksWithDisabledRenderer() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
-    trackSelector.setParameters(trackSelector.buildUponParameters().setRendererDisabled(1, true));
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertTrackSelections(result, new TrackSelection[] {TRACK_SELECTIONS[0], null});
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setRendererDisabled(1, true));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);
+    assertSelections(result, new TrackSelection[] {TRACK_SELECTIONS[0], null});
     assertThat(new RendererConfiguration[] {DEFAULT, null})
         .isEqualTo(result.rendererConfigurations);
   }
@@ -231,15 +245,14 @@ public void testSelectTracksWithDisabledRenderer() throws ExoPlaybackException {
   /** Tests that a disabled renderer can be enabled again. */
   @Test
   public void testSelectTracksWithClearedDisabledRenderer() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
             .setRendererDisabled(1, true)
             .setRendererDisabled(1, false));
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertTrackSelections(result, TRACK_SELECTIONS);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);
+    assertSelections(result, TRACK_SELECTIONS);
     assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})
         .isEqualTo(result.rendererConfigurations);
   }
@@ -247,11 +260,10 @@ public void testSelectTracksWithClearedDisabledRenderer() throws ExoPlaybackExce
   /** Tests a no-sample renderer is enabled without a track selection by default. */
   @Test
   public void testSelectTracksWithNoSampleRenderer() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
     TrackSelectorResult result =
-        trackSelector.selectTracks(RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
-    assertTrackSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);
+        trackSelector.selectTracks(
+            RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS, periodId, TIMELINE);
+    assertSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);
     assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})
         .isEqualTo(result.rendererConfigurations);
   }
@@ -259,12 +271,11 @@ public void testSelectTracksWithNoSampleRenderer() throws ExoPlaybackException {
   /** Tests disabling a no-sample renderer. */
   @Test
   public void testSelectTracksWithDisabledNoSampleRenderer() throws ExoPlaybackException {
-    DefaultTrackSelector trackSelector = new DefaultTrackSelector();
-    trackSelector.init(invalidationListener, bandwidthMeter);
-    trackSelector.setParameters(trackSelector.buildUponParameters().setRendererDisabled(1, true));
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setRendererDisabled(1, true));
     TrackSelectorResult result =
-        trackSelector.selectTracks(RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
-    assertTrackSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);
+        trackSelector.selectTracks(
+            RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS, periodId, TIMELINE);
+    assertSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);
     assertThat(new RendererConfiguration[] {DEFAULT, null})
         .isEqualTo(result.rendererConfigurations);
   }
@@ -277,8 +288,7 @@ public void testSelectTracksWithDisabledNoSampleRenderer() throws ExoPlaybackExc
   @Test
   public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListener()
       throws Exception {
-    trackSelector.init(invalidationListener, /* bandwidthMeter= */ null);
-
+    trackSelector.setParameters(Parameters.DEFAULT);
     verify(invalidationListener, never()).onTrackSelectionsInvalidated();
   }
 
@@ -289,10 +299,8 @@ public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListen
   @Test
   public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
       throws Exception {
-    Parameters parameters = new ParametersBuilder().setPreferredAudioLanguage("eng").build();
-    trackSelector.init(invalidationListener, /* bandwidthMeter= */ null);
+    Parameters parameters = Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("eng").build();
     trackSelector.setParameters(parameters);
-
     verify(invalidationListener).onTrackSelectionsInvalidated();
   }
 
@@ -304,11 +312,9 @@ public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
   @Test
   public void testSetParameterWithSameParametersDoesNotNotifyInvalidationListenerAgain()
       throws Exception {
-    ParametersBuilder builder = new ParametersBuilder().setPreferredAudioLanguage("eng");
-    trackSelector.init(invalidationListener, /* bandwidthMeter= */ null);
+    ParametersBuilder builder = Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("eng");
     trackSelector.setParameters(builder.build());
     trackSelector.setParameters(builder.build());
-
     verify(invalidationListener, times(1)).onTrackSelectionsInvalidated();
   }
 
@@ -318,14 +324,21 @@ public void testSetParameterWithSameParametersDoesNotNotifyInvalidationListenerA
    */
   @Test
   public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
-    Format audioFormat = buildAudioFormat("audio", /* language= */ null, /* selectionFlags= */ 0);
+    Format audioFormat =
+        buildAudioFormatWithLanguageAndFlags(
+            "audio", /* language= */ null, /* selectionFlags= */ 0);
     Format formatWithSelectionFlag =
-        buildAudioFormat("audio", /* language= */ null, C.SELECTION_FLAG_DEFAULT);
+        buildAudioFormatWithLanguageAndFlags(
+            "audio", /* language= */ null, C.SELECTION_FLAG_DEFAULT);
+    TrackGroupArray trackGroups = wrapFormats(audioFormat, formatWithSelectionFlag);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(formatWithSelectionFlag, audioFormat));
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(formatWithSelectionFlag);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, formatWithSelectionFlag);
   }
 
   /**
@@ -335,21 +348,23 @@ public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
   @Test
   public void testSelectTracksSelectPreferredAudioLanguage()
       throws Exception {
-    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
-
     Format frAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, "fra");
     Format enAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
+    TrackGroupArray trackGroups = wrapFormats(frAudioFormat, enAudioFormat);
 
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("eng").build());
     TrackSelectorResult result =
         trackSelector.selectTracks(
             new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-            wrapFormats(frAudioFormat, enAudioFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(enAudioFormat);
+            wrapFormats(frAudioFormat, enAudioFormat),
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, enAudioFormat);
   }
 
   /**
@@ -359,20 +374,23 @@ public void testSelectTracksSelectPreferredAudioLanguage()
   @Test
   public void testSelectTracksSelectPreferredAudioLanguageOverSelectionFlag()
       throws Exception {
-    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
-
     Format frAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "fra");
     Format enAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
+    TrackGroupArray trackGroups = wrapFormats(frAudioFormat, enAudioFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        wrapFormats(frAudioFormat, enAudioFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(enAudioFormat);
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("eng").build());
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, enAudioFormat);
   }
 
   /**
@@ -383,6 +401,7 @@ public void testSelectTracksSelectPreferredAudioLanguageOverSelectionFlag()
   public void testSelectTracksPreferTrackWithinCapabilities() throws Exception {
     Format supportedFormat = buildAudioFormat("supportedFormat");
     Format exceededFormat = buildAudioFormat("exceededFormat");
+    TrackGroupArray trackGroups = wrapFormats(exceededFormat, supportedFormat);
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);
@@ -390,11 +409,13 @@ public void testSelectTracksPreferTrackWithinCapabilities() throws Exception {
     RendererCapabilities mappedAudioRendererCapabilities =
         new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {mappedAudioRendererCapabilities},
-        singleTrackGroup(exceededFormat, supportedFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {mappedAudioRendererCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, supportedFormat);
   }
 
   /**
@@ -407,11 +428,15 @@ public void testSelectTracksWithNoTrackWithinCapabilitiesSelectExceededCapabilit
     Format audioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(audioFormat));
+    TrackGroupArray trackGroups = singleTrackGroup(audioFormat);
 
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(audioFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, audioFormat);
   }
 
   /**
@@ -422,17 +447,20 @@ public void testSelectTracksWithNoTrackWithinCapabilitiesSelectExceededCapabilit
   @Test
   public void testSelectTracksWithNoTrackWithinCapabilitiesAndSetByParamsReturnNoSelection()
       throws Exception {
-    trackSelector.setParameters(
-        new ParametersBuilder().setExceedRendererCapabilitiesIfNecessary(false).build());
-
     Format audioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(audioFormat));
+    TrackGroupArray trackGroups = singleTrackGroup(audioFormat);
 
-    assertThat(result.selections.get(0)).isNull();
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setExceedRendererCapabilitiesIfNecessary(false).build());
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertNoSelection(result.selections.get(0));
   }
 
   /**
@@ -442,12 +470,23 @@ public void testSelectTracksWithNoTrackWithinCapabilitiesAndSetByParamsReturnNoS
   @Test
   public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlag()
       throws Exception {
+    Format exceededWithSelectionFlagFormat =
+        Format.createAudioSampleFormat(
+            "exceededFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            Format.NO_VALUE,
+            Format.NO_VALUE,
+            2,
+            44100,
+            null,
+            null,
+            C.SELECTION_FLAG_DEFAULT,
+            null);
     Format supportedFormat =
         Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
             Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    Format exceededWithSelectionFlagFormat =
-        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, null);
+    TrackGroupArray trackGroups = wrapFormats(exceededWithSelectionFlagFormat, supportedFormat);
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);
@@ -455,11 +494,13 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlag()
     RendererCapabilities mappedAudioRendererCapabilities =
         new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {mappedAudioRendererCapabilities},
-        singleTrackGroup(exceededWithSelectionFlagFormat, supportedFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {mappedAudioRendererCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, supportedFormat);
   }
 
   /**
@@ -470,14 +511,23 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlag()
   @Test
   public void testSelectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage()
       throws Exception {
-    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
-
+    Format exceededEnFormat =
+        Format.createAudioSampleFormat(
+            "exceededFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            Format.NO_VALUE,
+            Format.NO_VALUE,
+            2,
+            44100,
+            null,
+            null,
+            0,
+            "eng");
     Format supportedFrFormat =
         Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
             Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fra");
-    Format exceededEnFormat =
-        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
+    TrackGroupArray trackGroups = wrapFormats(exceededEnFormat, supportedFrFormat);
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(exceededEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
@@ -485,11 +535,15 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage()
     RendererCapabilities mappedAudioRendererCapabilities =
         new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {mappedAudioRendererCapabilities},
-        singleTrackGroup(exceededEnFormat, supportedFrFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFrFormat);
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("eng").build());
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {mappedAudioRendererCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, supportedFrFormat);
   }
 
   /**
@@ -500,14 +554,23 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage()
   @Test
   public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlagAndPreferredLanguage()
       throws Exception {
-    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
-
+    Format exceededDefaultSelectionEnFormat =
+        Format.createAudioSampleFormat(
+            "exceededFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            Format.NO_VALUE,
+            Format.NO_VALUE,
+            2,
+            44100,
+            null,
+            null,
+            C.SELECTION_FLAG_DEFAULT,
+            "eng");
     Format supportedFrFormat =
         Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
             Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fra");
-    Format exceededDefaultSelectionEnFormat =
-        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "eng");
+    TrackGroupArray trackGroups = wrapFormats(exceededDefaultSelectionEnFormat, supportedFrFormat);
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(exceededDefaultSelectionEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
@@ -515,11 +578,15 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlagAndPre
     RendererCapabilities mappedAudioRendererCapabilities =
         new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {mappedAudioRendererCapabilities},
-        singleTrackGroup(exceededDefaultSelectionEnFormat, supportedFrFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFrFormat);
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("eng").build());
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {mappedAudioRendererCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, supportedFrFormat);
   }
 
   /**
@@ -529,18 +596,31 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlagAndPre
   @Test
   public void testSelectTracksWithinCapabilitiesSelectHigherNumChannel()
       throws Exception {
+    Format higherChannelFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            Format.NO_VALUE,
+            Format.NO_VALUE,
+            6,
+            44100,
+            null,
+            null,
+            0,
+            null);
     Format lowerChannelFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    Format higherChannelFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 6, 44100, null, null, 0, null);
-
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherChannelFormat, lowerChannelFormat));
+    TrackGroupArray trackGroups = wrapFormats(higherChannelFormat, lowerChannelFormat);
 
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(higherChannelFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, higherChannelFormat);
   }
 
   /**
@@ -556,33 +636,58 @@ public void testSelectTracksWithinCapabilitiesSelectHigherSampleRate()
     Format lowerSampleRateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 22050, null, null, 0, null);
+    TrackGroupArray trackGroups = wrapFormats(higherSampleRateFormat, lowerSampleRateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherSampleRateFormat, lowerSampleRateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(higherSampleRateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, higherSampleRateFormat);
   }
 
   /**
-   * Tests that track selector will select audio tracks with higher bit-rate when other factors
-   * are the same, and tracks are within renderer's capabilities.
+   * Tests that track selector will select audio tracks with higher bit-rate when other factors are
+   * the same, and tracks are within renderer's capabilities.
    */
   @Test
-  public void testSelectTracksWithinCapabilitiesSelectHigherBitrate()
-      throws Exception {
+  public void testSelectTracksWithinCapabilitiesSelectHigherBitrate() throws Exception {
     Format lowerBitrateFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
-            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            15000,
+            Format.NO_VALUE,
+            2,
+            44100,
+            null,
+            null,
+            0,
+            null);
     Format higherBitrateFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
-            Format.NO_VALUE, 2, 44100, null, null, 0, null);
-
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(lowerBitrateFormat, higherBitrateFormat));
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            30000,
+            Format.NO_VALUE,
+            2,
+            44100,
+            null,
+            null,
+            0,
+            null);
+    TrackGroupArray trackGroups = wrapFormats(lowerBitrateFormat, higherBitrateFormat);
 
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(higherBitrateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, higherBitrateFormat);
   }
 
   /**
@@ -593,19 +698,32 @@ public void testSelectTracksWithinCapabilitiesSelectHigherBitrate()
   @Test
   public void testSelectTracksPreferHigherNumChannelBeforeSampleRate()
       throws Exception {
+    Format higherChannelLowerSampleRateFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            Format.NO_VALUE,
+            Format.NO_VALUE,
+            6,
+            22050,
+            null,
+            null,
+            0,
+            null);
     Format lowerChannelHigherSampleRateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    Format higherChannelLowerSampleRateFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 6, 22050, null, null, 0, null);
+    TrackGroupArray trackGroups =
+        wrapFormats(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat())
-        .isEqualTo(higherChannelLowerSampleRateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, higherChannelLowerSampleRateFormat);
   }
 
   /**
@@ -622,13 +740,16 @@ public void testSelectTracksPreferHigherSampleRateBeforeBitrate()
     Format lowerSampleRateHigherBitrateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
             Format.NO_VALUE, 2, 22050, null, null, 0, null);
+    TrackGroupArray trackGroups =
+        wrapFormats(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat())
-        .isEqualTo(higherSampleRateLowerBitrateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, higherSampleRateLowerBitrateFormat);
   }
 
   /**
@@ -638,18 +759,31 @@ public void testSelectTracksPreferHigherSampleRateBeforeBitrate()
   @Test
   public void testSelectTracksExceedingCapabilitiesSelectLowerNumChannel()
       throws Exception {
+    Format higherChannelFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            null,
+            Format.NO_VALUE,
+            Format.NO_VALUE,
+            6,
+            44100,
+            null,
+            null,
+            0,
+            null);
     Format lowerChannelFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    Format higherChannelFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 6, 44100, null, null, 0, null);
-
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherChannelFormat, lowerChannelFormat));
+    TrackGroupArray trackGroups = wrapFormats(higherChannelFormat, lowerChannelFormat);
 
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerChannelFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, lowerChannelFormat);
   }
 
   /**
@@ -665,12 +799,15 @@ public void testSelectTracksExceedingCapabilitiesSelectLowerSampleRate()
     Format higherSampleRateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    TrackGroupArray trackGroups = wrapFormats(higherSampleRateFormat, lowerSampleRateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherSampleRateFormat, lowerSampleRateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerSampleRateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, lowerSampleRateFormat);
   }
 
   /**
@@ -686,12 +823,15 @@ public void testSelectTracksExceedingCapabilitiesSelectLowerBitrate()
     Format higherBitrateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    TrackGroupArray trackGroups = wrapFormats(lowerBitrateFormat, higherBitrateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(lowerBitrateFormat, higherBitrateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerBitrateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, lowerBitrateFormat);
   }
 
   /**
@@ -708,13 +848,16 @@ public void testSelectTracksExceedingCapabilitiesPreferLowerNumChannelBeforeSamp
     Format higherChannelLowerSampleRateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 6, 22050, null, null, 0, null);
+    TrackGroupArray trackGroups =
+        wrapFormats(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat())
-        .isEqualTo(lowerChannelHigherSampleRateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, lowerChannelHigherSampleRateFormat);
   }
 
   /**
@@ -731,18 +874,21 @@ public void testSelectTracksExceedingCapabilitiesPreferLowerSampleRateBeforeBitr
     Format lowerSampleRateHigherBitrateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
             Format.NO_VALUE, 2, 22050, null, null, 0, null);
+    TrackGroupArray trackGroups =
+        wrapFormats(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
-        singleTrackGroup(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat));
-
-    assertThat(result.selections.get(0).getSelectedFormat())
-        .isEqualTo(lowerSampleRateHigherBitrateFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, lowerSampleRateHigherBitrateFormat);
   }
 
   /** Tests text track selection flags. */
   @Test
-  public void testsTextTrackSelectionFlags() throws ExoPlaybackException {
+  public void testTextTrackSelectionFlags() throws ExoPlaybackException {
     Format forcedOnly = buildTextFormat("forcedOnly", "eng", C.SELECTION_FLAG_FORCED);
     Format forcedDefault =
         buildTextFormat("forcedDefault", "eng", C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT);
@@ -754,83 +900,114 @@ public void testsTextTrackSelectionFlags() throws ExoPlaybackException {
         new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};
 
     // There is no text language preference, the first track flagged as default should be selected.
+    TrackGroupArray trackGroups = wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag);
     TrackSelectorResult result =
-        trackSelector.selectTracks(
-            textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedDefault);
+        trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, forcedDefault);
 
     // Ditto.
-    result =
-        trackSelector.selectTracks(
-            textRendererCapabilities, wrapFormats(forcedOnly, noFlag, defaultOnly));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(defaultOnly);
+    trackGroups = wrapFormats(forcedOnly, noFlag, defaultOnly);
+    result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, defaultOnly);
 
-    // With no language preference and no text track flagged as default, the first forced should be
+    // Default flags are disabled and no language preference is provided, so no text track is
     // selected.
-    result = trackSelector.selectTracks(textRendererCapabilities, wrapFormats(forcedOnly, noFlag));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedOnly);
-
+    trackGroups = wrapFormats(defaultOnly, noFlag, forcedOnly, forcedDefault);
     trackSelector.setParameters(
         Parameters.DEFAULT
             .buildUpon()
             .setDisabledTextTrackSelectionFlags(C.SELECTION_FLAG_DEFAULT)
             .build());
+    result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
 
-    // Default flags are disabled, so the first track flagged as forced should be selected.
-    result =
-        trackSelector.selectTracks(
-            textRendererCapabilities, wrapFormats(defaultOnly, noFlag, forcedOnly, forcedDefault));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedOnly);
-
-    trackSelector.setParameters(
-        trackSelector.getParameters().buildUpon().setPreferredAudioLanguage("spa").build());
-
-    // Default flags are disabled, but there is a text track flagged as forced whose language
-    // matches the preferred audio language.
-    result =
-        trackSelector.selectTracks(
-            textRendererCapabilities,
-            wrapFormats(forcedDefault, forcedOnly, defaultOnly, noFlag, forcedOnlySpanish));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedOnlySpanish);
-
+    // All selection flags are disabled and there is no language preference, so nothing should be
+    // selected.
+    trackGroups = wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag);
     trackSelector.setParameters(
         trackSelector
             .getParameters()
             .buildUpon()
             .setDisabledTextTrackSelectionFlags(C.SELECTION_FLAG_DEFAULT | C.SELECTION_FLAG_FORCED)
             .build());
-
-    // All selection flags are disabled and there is no language preference, so nothing should be
-    // selected.
-    result =
-        trackSelector.selectTracks(
-            textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
-    assertThat(result.selections.get(0)).isNull();
-
-    trackSelector.setParameters(
-        Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("eng").build());
+    result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
 
     // There is a preferred language, so the first language-matching track flagged as default should
     // be selected.
-    result =
-        trackSelector.selectTracks(
-            textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedDefault);
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("eng").build());
+    result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, forcedDefault);
 
+    // Same as above, but the default flag is disabled. If multiple tracks match the preferred
+    // language, those not flagged as forced are preferred, as they likely include the contents of
+    // forced subtitles.
+    trackGroups = wrapFormats(noFlag, forcedOnly, forcedDefault, defaultOnly);
     trackSelector.setParameters(
         trackSelector
             .getParameters()
             .buildUpon()
             .setDisabledTextTrackSelectionFlags(C.SELECTION_FLAG_DEFAULT)
             .build());
+    result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, noFlag);
+  }
 
-    // Same as above, but the default flag is disabled. If multiple tracks match the preferred
-    // language, those not flagged as forced are preferred, as they likely include the contents of
-    // forced subtitles.
-    result =
-        trackSelector.selectTracks(
-            textRendererCapabilities, wrapFormats(noFlag, forcedOnly, forcedDefault, defaultOnly));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(noFlag);
+  /**
+   * Tests that the default track selector will select a forced text track matching the selected
+   * audio language when no text language preferences match.
+   */
+  @Test
+  public void testSelectingForcedTextTrackMatchesAudioLanguage() throws ExoPlaybackException {
+    Format forcedEnglish =
+        buildTextFormat(/* id= */ "forcedEnglish", /* language= */ "eng", C.SELECTION_FLAG_FORCED);
+    Format forcedGerman =
+        buildTextFormat(/* id= */ "forcedGerman", /* language= */ "deu", C.SELECTION_FLAG_FORCED);
+    Format forcedNoLanguage =
+        buildTextFormat(
+            /* id= */ "forcedNoLanguage",
+            /* language= */ C.LANGUAGE_UNDETERMINED,
+            C.SELECTION_FLAG_FORCED);
+    Format audio = buildAudioFormat(/* id= */ "audio");
+    Format germanAudio =
+        buildAudioFormat(
+            /* id= */ "germanAudio",
+            MimeTypes.AUDIO_AAC,
+            /* bitrate= */ Format.NO_VALUE,
+            "deu",
+            /* selectionFlags= */ 0,
+            /* channelCount= */ Format.NO_VALUE,
+            /* sampleRate= */ Format.NO_VALUE);
+
+    RendererCapabilities[] rendererCapabilities =
+        new RendererCapabilities[] {
+          ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES,
+          ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES
+        };
+
+    // Neither the audio nor the forced text track define a language. We select them both under the
+    // assumption that they have matching language.
+    TrackGroupArray trackGroups = wrapFormats(audio, forcedNoLanguage);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(1), trackGroups, forcedNoLanguage);
+
+    // No forced text track should be selected because none of the forced text tracks' languages
+    // matches the selected audio language.
+    trackGroups = wrapFormats(audio, forcedEnglish, forcedGerman);
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(1));
+
+    // The audio declares german. The german forced track should be selected.
+    trackGroups = wrapFormats(germanAudio, forcedGerman, forcedEnglish);
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(1), trackGroups, forcedGerman);
+
+    // Ditto
+    trackGroups = wrapFormats(germanAudio, forcedEnglish, forcedGerman);
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(1), trackGroups, forcedGerman);
   }
 
   /**
@@ -848,39 +1025,37 @@ public void testSelectUndeterminedTextLanguageAsFallback() throws ExoPlaybackExc
     RendererCapabilities[] textRendererCapabilites =
         new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};
 
+    TrackGroupArray trackGroups = wrapFormats(spanish, german, undeterminedUnd, undeterminedNull);
     TrackSelectorResult result =
-        trackSelector.selectTracks(
-            textRendererCapabilites,
-            wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
-    assertThat(result.selections.get(0)).isNull();
+        trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
 
     trackSelector.setParameters(
-        new ParametersBuilder().setSelectUndeterminedTextLanguage(true).build());
-    result = trackSelector.selectTracks(textRendererCapabilites,
-        wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(undeterminedUnd);
+        Parameters.DEFAULT.buildUpon().setSelectUndeterminedTextLanguage(true).build());
+    result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, undeterminedUnd);
 
-    ParametersBuilder builder = new ParametersBuilder().setPreferredTextLanguage("spa");
+    ParametersBuilder builder = Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("spa");
     trackSelector.setParameters(builder.build());
-    result = trackSelector.selectTracks(textRendererCapabilites,
-        wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(spanish);
+    result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, spanish);
+
+    trackGroups = wrapFormats(german, undeterminedUnd, undeterminedNull);
 
-    result = trackSelector.selectTracks(textRendererCapabilites,
-        wrapFormats(german, undeterminedUnd, undeterminedNull));
-    assertThat(result.selections.get(0)).isNull();
+    result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
 
     trackSelector.setParameters(builder.setSelectUndeterminedTextLanguage(true).build());
-    result = trackSelector.selectTracks(textRendererCapabilites,
-        wrapFormats(german, undeterminedUnd, undeterminedNull));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(undeterminedUnd);
+    result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, undeterminedUnd);
 
-    result = trackSelector.selectTracks(textRendererCapabilites,
-        wrapFormats(german, undeterminedNull));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(undeterminedNull);
+    trackGroups = wrapFormats(german, undeterminedNull);
+    result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, undeterminedNull);
 
-    result = trackSelector.selectTracks(textRendererCapabilites, wrapFormats(german));
-    assertThat(result.selections.get(0)).isNull();
+    trackGroups = wrapFormats(german);
+    result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
   }
 
   /** Tests audio track selection when there are multiple audio renderers. */
@@ -905,105 +1080,255 @@ public void testSelectPreferredTextTrackMultipleRenderers() throws Exception {
 
     RendererCapabilities[] rendererCapabilities =
         new RendererCapabilities[] {firstRendererCapabilities, secondRendererCapabilities};
+    TrackGroupArray trackGroups = wrapFormats(english, german);
 
     // Without an explicit language preference, nothing should be selected.
     TrackSelectorResult result =
-        trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
-    assertThat(result.selections.get(0)).isNull();
-    assertThat(result.selections.get(1)).isNull();
+        trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
+    assertNoSelection(result.selections.get(1));
 
     // Explicit language preference for english. First renderer should be used.
-    trackSelector.setParameters(trackSelector.buildUponParameters().setPreferredTextLanguage("en"));
-    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(english);
-    assertThat(result.selections.get(1)).isNull();
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("en"));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, english);
+    assertNoSelection(result.selections.get(1));
 
     // Explicit language preference for German. Second renderer should be used.
-    trackSelector.setParameters(trackSelector.buildUponParameters().setPreferredTextLanguage("de"));
-    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
-    assertThat(result.selections.get(0)).isNull();
-    assertThat(result.selections.get(1).getFormat(0)).isSameAs(german);
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("de"));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
+    assertFixedSelection(result.selections.get(1), trackGroups, german);
   }
 
   /**
-   * Tests that track selector will select audio tracks with lower bitrate when {@link Parameters}
-   * indicate lowest bitrate preference, even when tracks are within capabilities.
+   * Tests that track selector will select the lowest bitrate supported audio track when {@link
+   * Parameters#forceLowestBitrate} is set.
    */
   @Test
   public void testSelectTracksWithinCapabilitiesAndForceLowestBitrateSelectLowerBitrate()
       throws Exception {
-    trackSelector.setParameters(new ParametersBuilder().setForceLowestBitrate(true).build());
-
-    Format lowerBitrateFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
-            Format.NO_VALUE, 2, 44100, null, null, 0, null);
-    Format higherBitrateFormat =
-        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
-            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format unsupportedLowBitrateFormat = buildAudioFormatWithBitrate("unsupportedLowBitrate", 5000);
+    Format lowerBitrateFormat = buildAudioFormatWithBitrate("lowBitrate", 15000);
+    Format higherBitrateFormat = buildAudioFormatWithBitrate("highBitrate", 30000);
+    TrackGroupArray trackGroups =
+        wrapFormats(unsupportedLowBitrateFormat, lowerBitrateFormat, higherBitrateFormat);
 
-    TrackSelectorResult result = trackSelector.selectTracks(
-        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(lowerBitrateFormat, higherBitrateFormat));
+    Map<String, Integer> mappedCapabilities = new HashMap<>();
+    mappedCapabilities.put(unsupportedLowBitrateFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
+    mappedCapabilities.put(lowerBitrateFormat.id, FORMAT_HANDLED);
+    mappedCapabilities.put(higherBitrateFormat.id, FORMAT_HANDLED);
+    RendererCapabilities mappedAudioRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
 
-    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerBitrateFormat);
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setForceLowestBitrate(true).build());
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {mappedAudioRendererCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, lowerBitrateFormat);
   }
 
+  /**
+   * Tests that track selector will select the highest bitrate supported audio track when {@link
+   * Parameters#forceHighestSupportedBitrate} is set.
+   */
   @Test
-  public void testSelectTracksWithMultipleAudioTracksReturnsAdaptiveTrackSelection()
+  public void testSelectTracksWithinCapabilitiesAndForceHighestBitrateSelectHigherBitrate()
       throws Exception {
-    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
-    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
-    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
-        .thenReturn(adaptiveTrackSelection);
+    Format lowerBitrateFormat = buildAudioFormatWithBitrate("lowerBitrateFormat", 5000);
+    Format higherBitrateFormat = buildAudioFormatWithBitrate("higherBitrateFormat", 15000);
+    Format exceedsBitrateFormat = buildAudioFormatWithBitrate("exceedsBitrateFormat", 30000);
+    TrackGroupArray trackGroups =
+        wrapFormats(lowerBitrateFormat, higherBitrateFormat, exceedsBitrateFormat);
 
-    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
-    trackSelector.init(invalidationListener, bandwidthMeter);
+    Map<String, Integer> mappedCapabilities = new HashMap<>();
+    mappedCapabilities.put(lowerBitrateFormat.id, FORMAT_HANDLED);
+    mappedCapabilities.put(higherBitrateFormat.id, FORMAT_HANDLED);
+    mappedCapabilities.put(exceedsBitrateFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
+    RendererCapabilities mappedAudioRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
+
+    trackSelector.setParameters(
+        new ParametersBuilder().setForceHighestSupportedBitrate(true).build());
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {mappedAudioRendererCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, higherBitrateFormat);
+  }
 
-    TrackGroupArray trackGroupArray = singleTrackGroup(AUDIO_FORMAT, AUDIO_FORMAT);
+  @Test
+  public void testSelectTracksWithMultipleAudioTracks() throws Exception {
+    TrackGroupArray trackGroups = singleTrackGroup(buildAudioFormat("0"), buildAudioFormat("1"));
     TrackSelectorResult result =
         trackSelector.selectTracks(
-            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroupArray);
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
 
     assertThat(result.length).isEqualTo(1);
-    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
-    verify(adaptiveTrackSelectionFactory)
-        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 0, 1);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
   }
 
   @Test
-  public void testSelectTracksWithMultipleAudioTracksOverrideReturnsAdaptiveTrackSelection()
-      throws Exception {
-    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
-    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
-    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
-        .thenReturn(adaptiveTrackSelection);
+  public void testSelectTracksWithMultipleAudioTracksWithMixedSampleRates() throws Exception {
+    Format highSampleRateAudioFormat =
+        buildAudioFormatWithSampleRate("44100", /* sampleRate= */ 44100);
+    Format lowSampleRateAudioFormat =
+        buildAudioFormatWithSampleRate("22050", /* sampleRate= */ 22050);
+
+    // Should not adapt between mixed sample rates by default, so we expect a fixed selection
+    // containing the higher sample rate stream.
+    TrackGroupArray trackGroups =
+        singleTrackGroup(highSampleRateAudioFormat, lowSampleRateAudioFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, highSampleRateAudioFormat);
 
-    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
-    trackSelector.init(invalidationListener, bandwidthMeter);
+    // The same applies if the tracks are provided in the opposite order.
+    trackGroups = singleTrackGroup(lowSampleRateAudioFormat, highSampleRateAudioFormat);
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, highSampleRateAudioFormat);
+
+    // If we explicitly enable mixed sample rate adaptiveness, expect an adaptive selection.
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setAllowAudioMixedSampleRateAdaptiveness(true));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleAudioTracksWithMixedMimeTypes() throws Exception {
+    Format aacAudioFormat = buildAudioFormatWithMimeType("aac", MimeTypes.AUDIO_AAC);
+    Format opusAudioFormat = buildAudioFormatWithMimeType("opus", MimeTypes.AUDIO_OPUS);
+
+    // Should not adapt between mixed mime types by default, so we expect a fixed selection
+    // containing the first stream.
+    TrackGroupArray trackGroups = singleTrackGroup(aacAudioFormat, opusAudioFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, aacAudioFormat);
+
+    // The same applies if the tracks are provided in the opposite order.
+    trackGroups = singleTrackGroup(opusAudioFormat, aacAudioFormat);
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, opusAudioFormat);
+
+    // If we explicitly enable mixed mime type adaptiveness, expect an adaptive selection.
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setAllowAudioMixedMimeTypeAdaptiveness(true));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleAudioTracksWithMixedChannelCounts() throws Exception {
+    Format stereoAudioFormat =
+        buildAudioFormatWithChannelCount("2-channels", /* channelCount= */ 2);
+    Format surroundAudioFormat =
+        buildAudioFormatWithChannelCount("5-channels", /* channelCount= */ 5);
+
+    // Should not adapt between different channel counts, so we expect a fixed selection containing
+    // the track with more channels.
+    TrackGroupArray trackGroups = singleTrackGroup(stereoAudioFormat, surroundAudioFormat);
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, surroundAudioFormat);
+
+    // The same applies if the tracks are provided in the opposite order.
+    trackGroups = singleTrackGroup(surroundAudioFormat, stereoAudioFormat);
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, surroundAudioFormat);
+
+    // If we constrain the channel count to 4 we expect a fixed selection containing the track with
+    // fewer channels.
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setMaxAudioChannelCount(4));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, stereoAudioFormat);
 
-    TrackGroupArray trackGroupArray = singleTrackGroup(AUDIO_FORMAT, AUDIO_FORMAT, AUDIO_FORMAT);
+    // If we constrain the channel count to 2 we expect a fixed selection containing the track with
+    // fewer channels.
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setMaxAudioChannelCount(2));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, stereoAudioFormat);
+
+    // If we constrain the channel count to 1 we expect a fixed selection containing the track with
+    // fewer channels.
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setMaxAudioChannelCount(1));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, stereoAudioFormat);
+
+    // If we disable exceeding of constraints we expect no selection.
+    trackSelector.setParameters(
+        Parameters.DEFAULT
+            .buildUpon()
+            .setMaxAudioChannelCount(1)
+            .setExceedAudioConstraintsIfNecessary(false));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertNoSelection(result.selections.get(0));
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleAudioTracksOverrideReturnsAdaptiveTrackSelection()
+      throws Exception {
+    TrackGroupArray trackGroups =
+        singleTrackGroup(buildAudioFormat("0"), buildAudioFormat("1"), buildAudioFormat("2"));
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
             .setSelectionOverride(
                 /* rendererIndex= */ 0,
-                trackGroupArray,
+                trackGroups,
                 new SelectionOverride(/* groupIndex= */ 0, /* tracks= */ 1, 2)));
     TrackSelectorResult result =
         trackSelector.selectTracks(
-            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroupArray);
+            new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
 
     assertThat(result.length).isEqualTo(1);
-    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
-    verify(adaptiveTrackSelectionFactory)
-        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 1, 2);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1, 2);
   }
 
   /** Tests audio track selection when there are multiple audio renderers. */
   @Test
   public void testSelectPreferredAudioTrackMultipleRenderers() throws Exception {
-    Format english = buildAudioFormat("en", "en");
-    Format german = buildAudioFormat("de", "de");
+    Format english = buildAudioFormatWithLanguage("en", "en");
+    Format german = buildAudioFormatWithLanguage("de", "de");
 
     // First renderer handles english.
     Map<String, Integer> firstRendererMappedCapabilities = new HashMap<>();
@@ -1023,84 +1348,168 @@ public void testSelectPreferredAudioTrackMultipleRenderers() throws Exception {
         new RendererCapabilities[] {firstRendererCapabilities, secondRendererCapabilities};
 
     // Without an explicit language preference, prefer the first renderer.
+    TrackGroupArray trackGroups = wrapFormats(english, german);
     TrackSelectorResult result =
-        trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(english);
-    assertThat(result.selections.get(1)).isNull();
+        trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, english);
+    assertNoSelection(result.selections.get(1));
 
     // Explicit language preference for english. First renderer should be used.
-    trackSelector.setParameters(
-        trackSelector.buildUponParameters().setPreferredAudioLanguage("en"));
-    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
-    assertThat(result.selections.get(0).getFormat(0)).isSameAs(english);
-    assertThat(result.selections.get(1)).isNull();
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("en"));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, english);
+    assertNoSelection(result.selections.get(1));
 
     // Explicit language preference for German. Second renderer should be used.
-    trackSelector.setParameters(
-        trackSelector.buildUponParameters().setPreferredAudioLanguage("de"));
-    result = trackSelector.selectTracks(rendererCapabilities, wrapFormats(english, german));
-    assertThat(result.selections.get(0)).isNull();
-    assertThat(result.selections.get(1).getFormat(0)).isSameAs(german);
+    trackSelector.setParameters(Parameters.DEFAULT.buildUpon().setPreferredAudioLanguage("de"));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertNoSelection(result.selections.get(0));
+    assertFixedSelection(result.selections.get(1), trackGroups, german);
   }
 
   @Test
-  public void testSelectTracksWithMultipleVideoTracksReturnsAdaptiveTrackSelection()
+  public void testSelectTracksWithMultipleVideoTracks() throws Exception {
+    TrackGroupArray trackGroups = singleTrackGroup(buildVideoFormat("0"), buildVideoFormat("1"));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+
+    assertThat(result.length).isEqualTo(1);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+  }
+
+  @Test
+  public void testSelectTracksWithMultipleVideoTracksWithNonSeamlessAdaptiveness()
       throws Exception {
-    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
-    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
-    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
-        .thenReturn(adaptiveTrackSelection);
+    FakeRendererCapabilities nonSeamlessVideoCapabilities =
+        new FakeRendererCapabilities(C.TRACK_TYPE_VIDEO, FORMAT_HANDLED | ADAPTIVE_NOT_SEAMLESS);
 
-    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
-    trackSelector.init(invalidationListener, bandwidthMeter);
+    // Should do non-seamless adaptiveness by default, so expect an adaptive selection.
+    TrackGroupArray trackGroups = singleTrackGroup(buildVideoFormat("0"), buildVideoFormat("1"));
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setAllowVideoNonSeamlessAdaptiveness(true));
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {nonSeamlessVideoCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    // If we explicitly disable non-seamless adaptiveness, expect a fixed selection.
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setAllowVideoNonSeamlessAdaptiveness(false));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {nonSeamlessVideoCapabilities},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups.get(0), 0);
+  }
 
-    TrackGroupArray trackGroupArray = singleTrackGroup(VIDEO_FORMAT, VIDEO_FORMAT);
+  @Test
+  public void testSelectTracksWithMultipleVideoTracksWithMixedMimeTypes() throws Exception {
+    Format h264VideoFormat = buildVideoFormatWithMimeType("h264", MimeTypes.VIDEO_H264);
+    Format h265VideoFormat = buildVideoFormatWithMimeType("h265", MimeTypes.VIDEO_H265);
+
+    // Should not adapt between mixed mime types by default, so we expect a fixed selection
+    // containing the first stream.
+    TrackGroupArray trackGroups = singleTrackGroup(h264VideoFormat, h265VideoFormat);
     TrackSelectorResult result =
         trackSelector.selectTracks(
-            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroupArray);
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, h264VideoFormat);
+
+    // The same applies if the tracks are provided in the opposite order.
+    trackGroups = singleTrackGroup(h265VideoFormat, h264VideoFormat);
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
+    assertThat(result.length).isEqualTo(1);
+    assertFixedSelection(result.selections.get(0), trackGroups, h265VideoFormat);
 
+    // If we explicitly enable mixed mime type adaptiveness, expect an adaptive selection.
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setAllowVideoMixedMimeTypeAdaptiveness(true));
+    result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
     assertThat(result.length).isEqualTo(1);
-    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
-    verify(adaptiveTrackSelectionFactory)
-        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 0, 1);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
   }
 
   @Test
   public void testSelectTracksWithMultipleVideoTracksOverrideReturnsAdaptiveTrackSelection()
       throws Exception {
-    TrackSelection adaptiveTrackSelection = mock(TrackSelection.class);
-    TrackSelection.Factory adaptiveTrackSelectionFactory = mock(TrackSelection.Factory.class);
-    when(adaptiveTrackSelectionFactory.createTrackSelection(any(), any(), anyVararg()))
-        .thenReturn(adaptiveTrackSelection);
-
-    trackSelector = new DefaultTrackSelector(adaptiveTrackSelectionFactory);
-    trackSelector.init(invalidationListener, bandwidthMeter);
-
-    TrackGroupArray trackGroupArray = singleTrackGroup(VIDEO_FORMAT, VIDEO_FORMAT, VIDEO_FORMAT);
+    TrackGroupArray trackGroups =
+        singleTrackGroup(buildVideoFormat("0"), buildVideoFormat("1"), buildVideoFormat("2"));
     trackSelector.setParameters(
         trackSelector
             .buildUponParameters()
             .setSelectionOverride(
                 /* rendererIndex= */ 0,
-                trackGroupArray,
+                trackGroups,
                 new SelectionOverride(/* groupIndex= */ 0, /* tracks= */ 1, 2)));
     TrackSelectorResult result =
         trackSelector.selectTracks(
-            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroupArray);
+            new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);
 
     assertThat(result.length).isEqualTo(1);
-    assertThat(result.selections.get(0)).isEqualTo(adaptiveTrackSelection);
-    verify(adaptiveTrackSelectionFactory)
-        .createTrackSelection(trackGroupArray.get(0), bandwidthMeter, 1, 2);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1, 2);
   }
 
-  private static void assertTrackSelections(TrackSelectorResult result, TrackSelection[] expected) {
+  private static void assertSelections(TrackSelectorResult result, TrackSelection[] expected) {
     assertThat(result.length).isEqualTo(expected.length);
     for (int i = 0; i < expected.length; i++) {
       assertThat(result.selections.get(i)).isEqualTo(expected[i]);
     }
   }
 
+  private static void assertFixedSelection(
+      TrackSelection selection, TrackGroupArray trackGroups, Format expectedFormat) {
+    int trackGroupIndex = -1;
+    for (int i = 0; i < trackGroups.length; i++) {
+      int expectedTrack = trackGroups.get(i).indexOf(expectedFormat);
+      if (expectedTrack != -1) {
+        assertThat(trackGroupIndex).isEqualTo(-1);
+        assertFixedSelection(selection, trackGroups.get(i), expectedTrack);
+        trackGroupIndex = i;
+      }
+    }
+    // Assert that we found the expected format in a track group
+    assertThat(trackGroupIndex).isNotEqualTo(-1);
+  }
+
+  private static void assertFixedSelection(
+      TrackSelection selection, TrackGroup expectedTrackGroup, int expectedTrack) {
+    assertThat(selection).isInstanceOf(FixedTrackSelection.class);
+    assertThat(selection.getTrackGroup()).isEqualTo(expectedTrackGroup);
+    assertThat(selection.length()).isEqualTo(1);
+    assertThat(selection.getIndexInTrackGroup(0)).isEqualTo(expectedTrack);
+    assertThat(selection.getFormat(0))
+        .isSameAs(expectedTrackGroup.getFormat(selection.getIndexInTrackGroup(0)));
+  }
+
+  private static void assertNoSelection(TrackSelection selection) {
+    assertThat(selection).isNull();
+  }
+
+  private static void assertAdaptiveSelection(
+      TrackSelection selection, TrackGroup expectedTrackGroup, int... expectedTracks) {
+    assertThat(selection).isInstanceOf(AdaptiveTrackSelection.class);
+    assertThat(selection.getTrackGroup()).isEqualTo(expectedTrackGroup);
+    assertThat(selection.length()).isEqualTo(expectedTracks.length);
+    for (int i = 0; i < expectedTracks.length; i++) {
+      assertThat(selection.getIndexInTrackGroup(i)).isEqualTo(expectedTracks[i]);
+      assertThat(selection.getFormat(i))
+          .isSameAs(expectedTrackGroup.getFormat(selection.getIndexInTrackGroup(i)));
+    }
+  }
+
   private static TrackGroupArray singleTrackGroup(Format... formats) {
     return new TrackGroupArray(new TrackGroup(formats));
   }
@@ -1113,10 +1522,10 @@ private static TrackGroupArray wrapFormats(Format... formats) {
     return new TrackGroupArray(trackGroups);
   }
 
-  private static Format buildVideoFormat(String id) {
+  private static Format buildVideoFormatWithMimeType(String id, String mimeType) {
     return Format.createVideoSampleFormat(
         id,
-        MimeTypes.VIDEO_H264,
+        mimeType,
         null,
         Format.NO_VALUE,
         Format.NO_VALUE,
@@ -1127,23 +1536,97 @@ private static Format buildVideoFormat(String id) {
         null);
   }
 
-  private static Format buildAudioFormat(String id) {
-    return buildAudioFormat(id, /* language= */ null);
+  private static Format buildVideoFormat(String id) {
+    return buildVideoFormatWithMimeType(id, MimeTypes.VIDEO_H264);
   }
 
-  private static Format buildAudioFormat(String id, String language) {
-    return buildAudioFormat(id, language, /* selectionFlags= */ 0);
+  private static Format buildAudioFormatWithLanguage(String id, String language) {
+    return buildAudioFormatWithLanguageAndFlags(id, language, /* selectionFlags= */ 0);
   }
 
-  private static Format buildAudioFormat(String id, String language, int selectionFlags) {
-    return Format.createAudioSampleFormat(
+  private static Format buildAudioFormatWithLanguageAndFlags(
+      String id, String language, int selectionFlags) {
+    return buildAudioFormat(
         id,
         MimeTypes.AUDIO_AAC,
-        /* codecs= */ null,
         /* bitrate= */ Format.NO_VALUE,
-        /* maxInputSize= */ Format.NO_VALUE,
+        language,
+        selectionFlags,
         /* channelCount= */ 2,
-        /* sampleRate= */ 44100,
+        /* sampleRate= */ 44100);
+  }
+
+  private static Format buildAudioFormatWithBitrate(String id, int bitrate) {
+    return buildAudioFormat(
+        id,
+        MimeTypes.AUDIO_AAC,
+        bitrate,
+        /* language= */ null,
+        /* selectionFlags= */ 0,
+        /* channelCount= */ 2,
+        /* sampleRate= */ 44100);
+  }
+
+  private static Format buildAudioFormatWithSampleRate(String id, int sampleRate) {
+    return buildAudioFormat(
+        id,
+        MimeTypes.AUDIO_AAC,
+        /* bitrate= */ Format.NO_VALUE,
+        /* language= */ null,
+        /* selectionFlags= */ 0,
+        /* channelCount= */ 2,
+        sampleRate);
+  }
+
+  private static Format buildAudioFormatWithChannelCount(String id, int channelCount) {
+    return buildAudioFormat(
+        id,
+        MimeTypes.AUDIO_AAC,
+        /* bitrate= */ Format.NO_VALUE,
+        /* language= */ null,
+        /* selectionFlags= */ 0,
+        channelCount,
+        /* sampleRate= */ 44100);
+  }
+
+  private static Format buildAudioFormatWithMimeType(String id, String mimeType) {
+    return buildAudioFormat(
+        id,
+        mimeType,
+        /* bitrate= */ Format.NO_VALUE,
+        /* language= */ null,
+        /* selectionFlags= */ 0,
+        /* channelCount= */ 2,
+        /* sampleRate= */ 44100);
+  }
+
+  private static Format buildAudioFormat(String id) {
+    return buildAudioFormat(
+        id,
+        MimeTypes.AUDIO_AAC,
+        /* bitrate= */ Format.NO_VALUE,
+        /* language= */ null,
+        /* selectionFlags= */ 0,
+        /* channelCount= */ 2,
+        /* sampleRate= */ 44100);
+  }
+
+  private static Format buildAudioFormat(
+      String id,
+      String mimeType,
+      int bitrate,
+      String language,
+      int selectionFlags,
+      int channelCount,
+      int sampleRate) {
+    return Format.createAudioSampleFormat(
+        id,
+        mimeType,
+        /* codecs= */ null,
+        bitrate,
+        /* maxInputSize= */ Format.NO_VALUE,
+        channelCount,
+        sampleRate,
         /* initializationData= */ null,
         /* drmInitData= */ null,
         selectionFlags,
@@ -1163,6 +1646,7 @@ private static Format buildTextFormat(String id, String language, int selectionF
         /* codecs= */ null,
         /* bitrate= */ Format.NO_VALUE,
         selectionFlags,
+        /* roleFlags= */ 0,
         language);
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
index fa3d74b15f..efb828fc57 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
@@ -18,22 +18,24 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.util.Pair;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.util.MimeTypes;
+import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link MappingTrackSelector}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link MappingTrackSelector}. */
+@RunWith(AndroidJUnit4.class)
 public final class MappingTrackSelectorTest {
 
   private static final RendererCapabilities VIDEO_CAPABILITIES =
@@ -51,6 +53,14 @@
           Format.NO_VALUE, 2, 44100, null, null, 0, null));
   private static final TrackGroupArray TRACK_GROUPS = new TrackGroupArray(
       VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);
+  private static final Timeline TIMELINE = new FakeTimeline(/* windowCount= */ 1);
+
+  private static MediaPeriodId periodId;
+
+  @BeforeClass
+  public static void setUpBeforeClass() {
+    periodId = new MediaPeriodId(TIMELINE.getUidOfPeriod(/* periodIndex= */ 0));
+  }
 
   /**
    * Tests that the video and audio track groups are mapped onto the correct renderers.
@@ -58,7 +68,7 @@
   @Test
   public void testMapping() throws ExoPlaybackException {
     FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
-    trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
+    trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);
     trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP);
     trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
   }
@@ -72,7 +82,7 @@ public void testMappingReverseOrder() throws ExoPlaybackException {
     FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
     RendererCapabilities[] reverseOrderRendererCapabilities = new RendererCapabilities[] {
         AUDIO_CAPABILITIES, VIDEO_CAPABILITIES};
-    trackSelector.selectTracks(reverseOrderRendererCapabilities, TRACK_GROUPS);
+    trackSelector.selectTracks(reverseOrderRendererCapabilities, TRACK_GROUPS, periodId, TIMELINE);
     trackSelector.assertMappedTrackGroups(0, AUDIO_TRACK_GROUP);
     trackSelector.assertMappedTrackGroups(1, VIDEO_TRACK_GROUP);
   }
@@ -86,7 +96,7 @@ public void testMappingMulti() throws ExoPlaybackException {
     FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
     TrackGroupArray multiTrackGroups = new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP,
         VIDEO_TRACK_GROUP);
-    trackSelector.selectTracks(RENDERER_CAPABILITIES, multiTrackGroups);
+    trackSelector.selectTracks(RENDERER_CAPABILITIES, multiTrackGroups, periodId, TIMELINE);
     trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP, VIDEO_TRACK_GROUP);
     trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtilTest.java
new file mode 100644
index 0000000000..9acef96c0b
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtilTest.java
@@ -0,0 +1,617 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.testutil.FakeMediaChunk;
+import com.google.android.exoplayer2.testutil.FakeMediaChunkIterator;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** {@link TrackSelectionUtil} tests. */
+@RunWith(AndroidJUnit4.class)
+public class TrackSelectionUtilTest {
+
+  public static final long MAX_DURATION_US = 30 * C.MICROS_PER_SECOND;
+
+  @Test
+  public void getAverageBitrate_emptyIterator_returnsNoValue() {
+    assertThat(TrackSelectionUtil.getAverageBitrate(MediaChunkIterator.EMPTY, MAX_DURATION_US))
+        .isEqualTo(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getAverageBitrate_oneChunk_returnsChunkBitrate() {
+    long[] chunkTimeBoundariesSec = {12, 17};
+    long[] chunkLengths = {10};
+
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(16);
+  }
+
+  @Test
+  public void getAverageBitrate_multipleSameDurationChunks_returnsAverageChunkBitrate() {
+    long[] chunkTimeBoundariesSec = {0, 5, 10};
+    long[] chunkLengths = {10, 20};
+
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(24);
+  }
+
+  @Test
+  public void getAverageBitrate_multipleDifferentDurationChunks_returnsAverageChunkBitrate() {
+    long[] chunkTimeBoundariesSec = {0, 5, 15, 30};
+    long[] chunkLengths = {10, 20, 30};
+
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(16);
+  }
+
+  @Test
+  public void getAverageBitrate_firstChunkLengthUnset_returnsNoValue() {
+    long[] chunkTimeBoundariesSec = {0, 5, 15, 30};
+    long[] chunkLengths = {C.LENGTH_UNSET, 20, 30};
+
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US))
+        .isEqualTo(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getAverageBitrate_secondChunkLengthUnset_returnsFirstChunkBitrate() {
+    long[] chunkTimeBoundariesSec = {0, 5, 15, 30};
+    long[] chunkLengths = {10, C.LENGTH_UNSET, 30};
+
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(16);
+  }
+
+  @Test
+  public void
+      getAverageBitrate_chunksExceedingMaxDuration_returnsAverageChunkBitrateUpToMaxDuration() {
+    long[] chunkTimeBoundariesSec = {0, 5, 15, 45, 50};
+    long[] chunkLengths = {10, 20, 30, 100};
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    long maxDurationUs = 30 * C.MICROS_PER_SECOND;
+    int averageBitrate = TrackSelectionUtil.getAverageBitrate(iterator, maxDurationUs);
+
+    assertThat(averageBitrate).isEqualTo(12);
+  }
+
+  @Test
+  public void getAverageBitrate_zeroMaxDuration_returnsNoValue() {
+    long[] chunkTimeBoundariesSec = {0, 5, 10};
+    long[] chunkLengths = {10, 20};
+
+    FakeMediaChunkIterator iterator =
+        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
+
+    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, /* maxDurationUs= */ 0))
+        .isEqualTo(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_noIterator_returnsEmptyArray() {
+    assertThat(
+            TrackSelectionUtil.getBitratesUsingFutureInfo(
+                new MediaChunkIterator[0], new Format[0], MAX_DURATION_US, /* bitrates= */ null))
+        .hasLength(0);
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_emptyIterator_returnsNoValue() {
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingFutureInfo(
+            new MediaChunkIterator[] {MediaChunkIterator.EMPTY},
+            new Format[] {createFormatWithBitrate(10)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_twoTracksZeroMaxDuration_returnsNoValue() {
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
+    FakeMediaChunkIterator iterator2 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
+            /* chunkLengths= */ new long[] {10, 20, 30});
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingFutureInfo(
+            new MediaChunkIterator[] {iterator1, iterator2},
+            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
+            /* maxDurationUs= */ 0,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE, Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_twoTracks_returnsBitrates() {
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
+    FakeMediaChunkIterator iterator2 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
+            /* chunkLengths= */ new long[] {10, 20, 30});
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingFutureInfo(
+            new MediaChunkIterator[] {iterator1, iterator2},
+            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_bitratesArrayGiven_returnsTheSameArray() {
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
+    FakeMediaChunkIterator iterator2 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
+            /* chunkLengths= */ new long[] {10, 20, 30});
+
+    int[] bitratesArrayToUse = new int[2];
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingFutureInfo(
+            new MediaChunkIterator[] {iterator1, iterator2},
+            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
+            MAX_DURATION_US,
+            bitratesArrayToUse);
+
+    assertThat(bitrates).isSameAs(bitratesArrayToUse);
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_emptyIterator_returnsEstimationUsingClosest() {
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {10});
+    Format format1 = createFormatWithBitrate(10);
+    MediaChunkIterator iterator2 = MediaChunkIterator.EMPTY;
+    Format format2 = createFormatWithBitrate(20);
+    FakeMediaChunkIterator iterator3 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {50});
+    Format format3 = createFormatWithBitrate(25);
+    FakeMediaChunkIterator iterator4 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {20});
+    Format format4 = createFormatWithBitrate(30);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingFutureInfo(
+            new MediaChunkIterator[] {iterator1, iterator2, iterator3, iterator4},
+            new Format[] {format1, format2, format3, format4},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16, 64, 80, 32).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingFutureInfo_formatWithoutBitrate_returnsNoValueForEmpty() {
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {10});
+    Format format1 = createFormatWithBitrate(10);
+    MediaChunkIterator iterator2 = MediaChunkIterator.EMPTY;
+    Format format2 = createFormatWithBitrate(Format.NO_VALUE);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingFutureInfo(
+            new MediaChunkIterator[] {iterator1, iterator2},
+            new Format[] {format1, format2},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16, Format.NO_VALUE).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_noFormat_returnsEmptyArray() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk), new Format[0], MAX_DURATION_US, /* bitrates= */ null);
+
+    assertThat(bitrates).hasLength(0);
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_emptyQueue_returnsNoValue() {
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.emptyList(),
+            new Format[] {createFormatWithBitrate(10)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_oneChunkFormatNoBitrate_returnsNoValue() {
+    Format format = createFormatWithBitrate(Format.NO_VALUE);
+    FakeMediaChunk chunk =
+        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {format},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_oneChunkNoLength_returnsNoValue() {
+    Format format = createFormatWithBitrate(10);
+    FakeMediaChunk chunk =
+        createChunk(
+            format, /* length= */ C.LENGTH_UNSET, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {format},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_oneChunkWithSameFormat_returnsBitrates() {
+    Format format = createFormatWithBitrate(10);
+    FakeMediaChunk chunk =
+        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {format},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(8).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_zeroMaxDuration_returnsNoValue() {
+    Format format = createFormatWithBitrate(10);
+    FakeMediaChunk chunk =
+        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {format},
+            /* maxDurationUs= */ 0,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_multipleChunkWithSameFormat_returnsAverageBitrate() {
+    Format format = createFormatWithBitrate(10);
+    FakeMediaChunk chunk =
+        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
+    FakeMediaChunk chunk2 =
+        createChunk(format, /* length= */ 20, /* startTimeSec= */ 10, /* endTimeSec= */ 20);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Arrays.asList(chunk, chunk2),
+            new Format[] {format},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(12).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_oneChunkWithDifferentFormat_returnsEstimationBitrate() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {createFormatWithBitrate(20)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_trackFormatNoBitrate_returnsNoValue() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {createFormatWithBitrate(Format.NO_VALUE)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_multipleTracks_returnsBitrates() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16, 24).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastInfo_bitratesArrayGiven_returnsTheSameArray() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitratesArrayToUse = new int[2];
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Collections.singletonList(chunk),
+            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
+            MAX_DURATION_US,
+            bitratesArrayToUse);
+
+    assertThat(bitrates).isSameAs(bitratesArrayToUse);
+  }
+
+  @Test
+  public void
+      getBitratesUsingPastInfo_multipleChunkExceedingMaxDuration_returnsAverageUntilMaxDuration() {
+    Format format = createFormatWithBitrate(10);
+    FakeMediaChunk chunk =
+        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 20);
+    FakeMediaChunk chunk2 =
+        createChunk(format, /* length= */ 40, /* startTimeSec= */ 20, /* endTimeSec= */ 40);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Arrays.asList(chunk, chunk2),
+            new Format[] {format},
+            /* maxDurationUs= */ 30 * C.MICROS_PER_SECOND,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(12).inOrder();
+  }
+
+  @Test
+  public void
+      getBitratesUsingPastInfo_chunksWithDifferentFormats_returnsChunkAverageBitrateForLastFormat() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+    FakeMediaChunk chunk2 =
+        createChunk(
+            createFormatWithBitrate(20),
+            /* length= */ 40,
+            /* startTimeSec= */ 10,
+            /* endTimeSec= */ 20);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastInfo(
+            Arrays.asList(chunk, chunk2),
+            new Format[] {createFormatWithBitrate(10)},
+            MAX_DURATION_US,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastAndFutureInfo_noPastInfo_returnsBitratesUsingOnlyFutureInfo() {
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
+    FakeMediaChunkIterator iterator2 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
+            /* chunkLengths= */ new long[] {10, 20, 30});
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
+            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
+            Collections.emptyList(),
+            MAX_DURATION_US,
+            new MediaChunkIterator[] {iterator1, iterator2},
+            MAX_DURATION_US,
+            /* useFormatBitrateAsLowerBound= */ false,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastAndFutureInfo_noFutureInfo_returnsBitratesUsingOnlyPastInfo() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
+            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
+            Collections.singletonList(chunk),
+            MAX_DURATION_US,
+            new MediaChunkIterator[] {MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY},
+            MAX_DURATION_US,
+            /* useFormatBitrateAsLowerBound= */ false,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16, 24).inOrder();
+  }
+
+  @Test
+  public void
+      getBitratesUsingPastAndFutureInfo_pastAndFutureInfo_returnsBitratesUsingOnlyFutureInfo() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(5),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+    FakeMediaChunkIterator iterator1 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
+    FakeMediaChunkIterator iterator2 =
+        new FakeMediaChunkIterator(
+            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
+            /* chunkLengths= */ new long[] {10, 20, 30});
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
+            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
+            Collections.singletonList(chunk),
+            MAX_DURATION_US,
+            new MediaChunkIterator[] {iterator1, iterator2},
+            MAX_DURATION_US,
+            /* useFormatBitrateAsLowerBound= */ false,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
+  }
+
+  @Test
+  public void getBitratesUsingPastAndFutureInfo_noPastAndFutureInfo_returnsBitratesOfFormats() {
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
+            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
+            Collections.emptyList(),
+            MAX_DURATION_US,
+            new MediaChunkIterator[] {MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY},
+            MAX_DURATION_US,
+            /* useFormatBitrateAsLowerBound= */ false,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(10, 20).inOrder();
+  }
+
+  @Test
+  public void
+      getBitratesUsingPastAndFutureInfo_estimatesLowerAndUseFormatBitrateAsLowerBoundTrue_returnsBitratesOfFormats() {
+    FakeMediaChunk chunk =
+        createChunk(
+            createFormatWithBitrate(10),
+            /* length= */ 10,
+            /* startTimeSec= */ 0,
+            /* endTimeSec= */ 10);
+
+    int[] bitrates =
+        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
+            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
+            Collections.singletonList(chunk),
+            MAX_DURATION_US,
+            new MediaChunkIterator[] {MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY},
+            MAX_DURATION_US,
+            /* useFormatBitrateAsLowerBound= */ true,
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(20, 30).inOrder();
+  }
+
+  private static FakeMediaChunk createChunk(
+      Format format, int length, int startTimeSec, int endTimeSec) {
+    DataSpec dataSpec =
+        new DataSpec(
+            Uri.EMPTY, /* absoluteStreamPosition= */ 0, length, /* key= */ null, /* flags= */ 0);
+    return new FakeMediaChunk(
+        dataSpec, format, startTimeSec * C.MICROS_PER_SECOND, endTimeSec * C.MICROS_PER_SECOND);
+  }
+
+  private static Format createFormatWithBitrate(int bitrate) {
+    return Format.createSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ null,
+        /* codecs= */ null,
+        bitrate,
+        /* drmInitData= */ null);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java
index 615f680bb5..477f7226a4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectorTest.java
@@ -18,8 +18,11 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
@@ -27,26 +30,30 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link TrackSelector}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class TrackSelectorTest {
 
   private TrackSelector trackSelector;
 
   @Before
   public void setUp() {
-    trackSelector = new TrackSelector() {
-      @Override
-      public TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
-          TrackGroupArray trackGroups) throws ExoPlaybackException {
-        throw new UnsupportedOperationException();
-      }
+    trackSelector =
+        new TrackSelector() {
+          @Override
+          public TrackSelectorResult selectTracks(
+              RendererCapabilities[] rendererCapabilities,
+              TrackGroupArray trackGroups,
+              MediaPeriodId periodId,
+              Timeline timeline)
+              throws ExoPlaybackException {
+            throw new UnsupportedOperationException();
+          }
 
-      @Override
-      public void onSelectionActivated(Object info) {}
-    };
+          @Override
+          public void onSelectionActivated(Object info) {}
+        };
   }
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimatorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimatorTest.java
new file mode 100644
index 0000000000..887338078e
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimatorTest.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
+import com.google.android.exoplayer2.testutil.FakeMediaChunk;
+import com.google.android.exoplayer2.testutil.FakeMediaChunkIterator;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** {@link WindowedTrackBitrateEstimator} tests. */
+@RunWith(AndroidJUnit4.class)
+public class WindowedTrackBitrateEstimatorTest {
+
+  private static final long MAX_DURATION_MS = 30_000;
+
+  @Test
+  public void getBitrates_zeroMaxDuration_returnsFormatBitrates() {
+    WindowedTrackBitrateEstimator estimator =
+        new WindowedTrackBitrateEstimator(
+            /* maxPastDurationMs= */ 0,
+            /* maxFutureDurationMs= */ 0,
+            /* useFormatBitrateAsLowerBound= */ false);
+    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
+    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
+    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
+    Format format1 = createFormatWithBitrate(10);
+    Format format2 = createFormatWithBitrate(20);
+
+    int[] bitrates =
+        estimator.getBitrates(
+            new Format[] {format1, format2},
+            Collections.singletonList(chunk),
+            new MediaChunkIterator[] {iterator1, iterator2},
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(10, 20).inOrder();
+  }
+
+  @Test
+  public void getBitrates_futureMaxDurationSet_returnsEstimateUsingFutureChunks() {
+    WindowedTrackBitrateEstimator estimator =
+        new WindowedTrackBitrateEstimator(
+            /* maxPastDurationMs= */ 0, MAX_DURATION_MS, /* useFormatBitrateAsLowerBound= */ false);
+    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
+    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
+    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
+    Format format1 = createFormatWithBitrate(10);
+    Format format2 = createFormatWithBitrate(20);
+
+    int[] bitrates =
+        estimator.getBitrates(
+            new Format[] {format1, format2},
+            Collections.singletonList(chunk),
+            new MediaChunkIterator[] {iterator1, iterator2},
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
+  }
+
+  @Test
+  public void getBitrates_pastMaxDurationSet_returnsEstimateUsingPastChunks() {
+    WindowedTrackBitrateEstimator estimator =
+        new WindowedTrackBitrateEstimator(
+            MAX_DURATION_MS,
+            /* maxFutureDurationMs= */ 0,
+            /* useFormatBitrateAsLowerBound= */ false);
+    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
+    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
+    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
+    Format format1 = createFormatWithBitrate(10);
+    Format format2 = createFormatWithBitrate(20);
+
+    int[] bitrates =
+        estimator.getBitrates(
+            new Format[] {format1, format2},
+            Collections.singletonList(chunk),
+            new MediaChunkIterator[] {iterator1, iterator2},
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(16, 32).inOrder();
+  }
+
+  @Test
+  public void
+      getBitrates_useFormatBitrateAsLowerBoundSetTrue_returnsEstimateIfOnlyHigherThanFormat() {
+    WindowedTrackBitrateEstimator estimator =
+        new WindowedTrackBitrateEstimator(
+            MAX_DURATION_MS, MAX_DURATION_MS, /* useFormatBitrateAsLowerBound= */ true);
+    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
+    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(80);
+    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
+    Format format1 = createFormatWithBitrate(10);
+    Format format2 = createFormatWithBitrate(20);
+
+    int[] bitrates =
+        estimator.getBitrates(
+            new Format[] {format1, format2},
+            Collections.singletonList(chunk),
+            new MediaChunkIterator[] {iterator1, iterator2},
+            /* bitrates= */ null);
+
+    assertThat(bitrates).asList().containsExactly(80, 20).inOrder();
+  }
+
+  @Test
+  public void getBitrates_bitratesArrayGiven_returnsTheSameArray() {
+    WindowedTrackBitrateEstimator estimator =
+        new WindowedTrackBitrateEstimator(
+            MAX_DURATION_MS, MAX_DURATION_MS, /* useFormatBitrateAsLowerBound= */ true);
+    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
+    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
+    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
+    Format format1 = createFormatWithBitrate(10);
+    Format format2 = createFormatWithBitrate(20);
+
+    int[] bitratesArrayToUse = new int[2];
+    int[] bitrates =
+        estimator.getBitrates(
+            new Format[] {format1, format2},
+            Collections.singletonList(chunk),
+            new MediaChunkIterator[] {iterator1, iterator2},
+            bitratesArrayToUse);
+
+    assertThat(bitrates).isSameAs(bitratesArrayToUse);
+  }
+
+  private static MediaChunk createMediaChunk(int formatBitrate, int actualBitrate) {
+    int length = actualBitrate / C.BITS_PER_BYTE;
+    DataSpec dataSpec =
+        new DataSpec(
+            Uri.EMPTY, /* absoluteStreamPosition= */ 0, length, /* key= */ null, /* flags= */ 0);
+    Format format = createFormatWithBitrate(formatBitrate);
+    return new FakeMediaChunk(
+        dataSpec, format, /* startTimeUs= */ 0L, /* endTimeUs= */ C.MICROS_PER_SECOND);
+  }
+
+  private static Format createFormatWithBitrate(int bitrate) {
+    return Format.createSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ null,
+        /* codecs= */ null,
+        bitrate,
+        /* drmInitData= */ null);
+  }
+
+  private static MediaChunkIterator createMediaChunkIteratorWithBitrate(int bitrate) {
+    return new FakeMediaChunkIterator(
+        /* chunkTimeBoundariesSec= */ new long[] {0, 1},
+        /* chunkLengths= */ new long[] {bitrate / C.BITS_PER_BYTE});
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
index 7ffc14d51f..7e25eacfe2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
@@ -16,37 +16,37 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit tests for {@link AssetDataSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class AssetDataSourceTest {
 
   private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";
 
   @Test
   public void testReadFileUri() throws Exception {
-    AssetDataSource dataSource = new AssetDataSource(RuntimeEnvironment.application);
+    AssetDataSource dataSource = new AssetDataSource(ApplicationProvider.getApplicationContext());
     DataSpec dataSpec = new DataSpec(Uri.parse("file:///android_asset/" + DATA_PATH));
     TestUtil.assertDataSourceContent(
         dataSource,
         dataSpec,
-        TestUtil.getByteArray(RuntimeEnvironment.application, DATA_PATH),
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), DATA_PATH),
         true);
   }
 
   @Test
   public void testReadAssetUri() throws Exception {
-    AssetDataSource dataSource = new AssetDataSource(RuntimeEnvironment.application);
+    AssetDataSource dataSource = new AssetDataSource(ApplicationProvider.getApplicationContext());
     DataSpec dataSpec = new DataSpec(Uri.parse("asset:///" + DATA_PATH));
     TestUtil.assertDataSourceContent(
         dataSource,
         dataSpec,
-        TestUtil.getByteArray(RuntimeEnvironment.application, DATA_PATH),
+        TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), DATA_PATH),
         true);
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java
index 7155c37e29..289de08c47 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/BaseDataSourceTest.java
@@ -18,15 +18,15 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link BaseDataSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class BaseDataSourceTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
index f04f01bd5f..ee64e56c51 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
@@ -18,16 +18,14 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link ByteArrayDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link ByteArrayDataSource}. */
+@RunWith(AndroidJUnit4.class)
 public final class ByteArrayDataSourceTest {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
index dd1ae30bdb..2df9a608e9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
@@ -20,17 +20,15 @@
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link DataSchemeDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link DataSchemeDataSource}. */
+@RunWith(AndroidJUnit4.class)
 public final class DataSchemeDataSourceTest {
 
   private DataSource schemeDataDataSource;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
index f47cfc4469..257f1c45b3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
@@ -18,18 +18,16 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link DataSourceInputStream}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link DataSourceInputStream}. */
+@RunWith(AndroidJUnit4.class)
 public final class DataSourceInputStreamTest {
 
   private static final byte[] TEST_DATA = TestUtil.buildTestData(16);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
index ebdb45909b..d8d22a7b2f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
@@ -15,27 +15,31 @@
  */
 package com.google.android.exoplayer2.upstream;
 
-import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static com.google.common.truth.Truth.assertThat;
 
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.net.NetworkInfo.DetailedState;
+import android.net.Uri;
 import android.telephony.TelephonyManager;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.FakeClock;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import java.util.Random;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 /** Unit test for {@link DefaultBandwidthMeter}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DefaultBandwidthMeterTest {
 
+  private static final int SIMULATED_TRANSFER_COUNT = 100;
   private static final String FAST_COUNTRY_ISO = "EE";
   private static final String SLOW_COUNTRY_ISO = "PG";
 
@@ -52,10 +56,11 @@
   public void setUp() {
     connectivityManager =
         (ConnectivityManager)
-            RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE);
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
     telephonyManager =
         (TelephonyManager)
-            RuntimeEnvironment.application.getSystemService(Context.TELEPHONY_SERVICE);
+            ApplicationProvider.getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);
     Shadows.shadowOf(telephonyManager).setNetworkCountryIso(FAST_COUNTRY_ISO);
     networkInfoOffline =
         ShadowNetworkInfo.newInstance(
@@ -105,12 +110,12 @@ public void setUp() {
   public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor2G() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeterWifi =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateWifi = bandwidthMeterWifi.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter2g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
 
     assertThat(initialEstimateWifi).isGreaterThan(initialEstimate2g);
@@ -120,12 +125,12 @@ public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor2G() {
   public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor3G() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeterWifi =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateWifi = bandwidthMeterWifi.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo3g);
     DefaultBandwidthMeter bandwidthMeter3g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
 
     assertThat(initialEstimateWifi).isGreaterThan(initialEstimate3g);
@@ -135,12 +140,12 @@ public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor3G() {
   public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor2G() {
     setActiveNetworkInfo(networkInfoEthernet);
     DefaultBandwidthMeter bandwidthMeterEthernet =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateEthernet = bandwidthMeterEthernet.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter2g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
 
     assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate2g);
@@ -150,12 +155,12 @@ public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor2G
   public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor3G() {
     setActiveNetworkInfo(networkInfoEthernet);
     DefaultBandwidthMeter bandwidthMeterEthernet =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateEthernet = bandwidthMeterEthernet.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo3g);
     DefaultBandwidthMeter bandwidthMeter3g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
 
     assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate3g);
@@ -165,12 +170,12 @@ public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor3G
   public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor2G() {
     setActiveNetworkInfo(networkInfo4g);
     DefaultBandwidthMeter bandwidthMeter4g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate4g = bandwidthMeter4g.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter2g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
 
     assertThat(initialEstimate4g).isGreaterThan(initialEstimate2g);
@@ -180,12 +185,12 @@ public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor2G() {
   public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor3G() {
     setActiveNetworkInfo(networkInfo4g);
     DefaultBandwidthMeter bandwidthMeter4g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate4g = bandwidthMeter4g.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo3g);
     DefaultBandwidthMeter bandwidthMeter3g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
 
     assertThat(initialEstimate4g).isGreaterThan(initialEstimate3g);
@@ -195,12 +200,12 @@ public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor3G() {
   public void defaultInitialBitrateEstimate_for3G_isGreaterThanEstimateFor2G() {
     setActiveNetworkInfo(networkInfo3g);
     DefaultBandwidthMeter bandwidthMeter3g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
 
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter2g =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
 
     assertThat(initialEstimate3g).isGreaterThan(initialEstimate2g);
@@ -210,7 +215,7 @@ public void defaultInitialBitrateEstimate_for3G_isGreaterThanEstimateFor2G() {
   public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
     setActiveNetworkInfo(networkInfoOffline);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
 
     assertThat(initialEstimate).isGreaterThan(100_000L);
@@ -223,12 +228,12 @@ public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
     setActiveNetworkInfo(networkInfoWifi);
     setNetworkCountryIso(FAST_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterFast =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
 
     setNetworkCountryIso(SLOW_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterSlow =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
 
     assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
@@ -240,12 +245,12 @@ public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
     setActiveNetworkInfo(networkInfoEthernet);
     setNetworkCountryIso(FAST_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterFast =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
 
     setNetworkCountryIso(SLOW_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterSlow =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
 
     assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
@@ -257,12 +262,12 @@ public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
     setActiveNetworkInfo(networkInfo2g);
     setNetworkCountryIso(FAST_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterFast =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
 
     setNetworkCountryIso(SLOW_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterSlow =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
 
     assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
@@ -274,12 +279,12 @@ public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
     setActiveNetworkInfo(networkInfo3g);
     setNetworkCountryIso(FAST_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterFast =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
 
     setNetworkCountryIso(SLOW_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterSlow =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
 
     assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
@@ -291,12 +296,12 @@ public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
     setActiveNetworkInfo(networkInfo4g);
     setNetworkCountryIso(FAST_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterFast =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
 
     setNetworkCountryIso(SLOW_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterSlow =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
 
     assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
@@ -306,7 +311,7 @@ public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
   public void initialBitrateEstimateOverwrite_whileConnectedToNetwork_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -318,7 +323,7 @@ public void initialBitrateEstimateOverwrite_whileConnectedToNetwork_setsInitialE
   public void initialBitrateEstimateOverwrite_whileOffline_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfoOffline);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -330,7 +335,7 @@ public void initialBitrateEstimateOverwrite_whileOffline_setsInitialEstimate() {
   public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -343,7 +348,7 @@ public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsIni
       initialBitrateEstimateOverwrite_forWifi_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -356,7 +361,7 @@ public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsIni
       initialBitrateEstimateOverwrite_forEthernet_whileConnectedToEthernet_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfoEthernet);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_ETHERNET, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -369,7 +374,7 @@ public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsIni
       initialBitrateEstimateOverwrite_forEthernet_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -381,7 +386,7 @@ public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsIni
   public void initialBitrateEstimateOverwrite_for2G_whileConnectedTo2G_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfo2g);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -394,7 +399,7 @@ public void initialBitrateEstimateOverwrite_for2G_whileConnectedTo2G_setsInitial
       initialBitrateEstimateOverwrite_for2G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -406,7 +411,7 @@ public void initialBitrateEstimateOverwrite_for2G_whileConnectedTo2G_setsInitial
   public void initialBitrateEstimateOverwrite_for3G_whileConnectedTo3G_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfo3g);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_3G, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -419,7 +424,7 @@ public void initialBitrateEstimateOverwrite_for3G_whileConnectedTo3G_setsInitial
       initialBitrateEstimateOverwrite_for3G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_3G, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -431,7 +436,7 @@ public void initialBitrateEstimateOverwrite_for3G_whileConnectedTo3G_setsInitial
   public void initialBitrateEstimateOverwrite_for4G_whileConnectedTo4G_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfo4g);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_4G, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -444,7 +449,7 @@ public void initialBitrateEstimateOverwrite_for4G_whileConnectedTo4G_setsInitial
       initialBitrateEstimateOverwrite_for4G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_4G, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -456,7 +461,7 @@ public void initialBitrateEstimateOverwrite_for4G_whileConnectedTo4G_setsInitial
   public void initialBitrateEstimateOverwrite_forOffline_whileOffline_setsInitialEstimate() {
     setActiveNetworkInfo(networkInfoOffline);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_OFFLINE, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -469,7 +474,7 @@ public void initialBitrateEstimateOverwrite_forOffline_whileOffline_setsInitialE
       initialBitrateEstimateOverwrite_forOffline_whileConnectedToNetwork_doesNotSetInitialEstimate() {
     setActiveNetworkInfo(networkInfoWifi);
     DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(C.NETWORK_TYPE_OFFLINE, 123456789)
             .build();
     long initialEstimate = bandwidthMeter.getBitrateEstimate();
@@ -481,12 +486,12 @@ public void initialBitrateEstimateOverwrite_forOffline_whileOffline_setsInitialE
   public void initialBitrateEstimateOverwrite_forCountry_usesDefaultValuesForCountry() {
     setNetworkCountryIso(SLOW_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterSlow =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
     long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
 
     setNetworkCountryIso(FAST_COUNTRY_ISO);
     DefaultBandwidthMeter bandwidthMeterFastWithSlowOverwrite =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
             .setInitialBitrateEstimate(SLOW_COUNTRY_ISO)
             .build();
     long initialEstimateFastWithSlowOverwrite =
@@ -496,6 +501,48 @@ public void initialBitrateEstimateOverwrite_forCountry_usesDefaultValuesForCount
   }
 
   @Test
+  public void networkTypeOverride_updatesBitrateEstimate() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();
+    long initialEstimateEthernet = bandwidthMeter.getBitrateEstimate();
+
+    bandwidthMeter.setNetworkTypeOverride(C.NETWORK_TYPE_2G);
+    long initialEstimate2g = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void networkTypeOverride_doesFullReset() {
+    // Simulate transfers for an ethernet connection.
+    setActiveNetworkInfo(networkInfoEthernet);
+    FakeClock clock = new FakeClock(/* initialTimeMs= */ 0);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
+            .setClock(clock)
+            .build();
+    long[] bitrateEstimatesWithNewInstance = simulateTransfers(bandwidthMeter, clock);
+
+    // Create a new instance and seed with some transfers.
+    setActiveNetworkInfo(networkInfo2g);
+    bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext())
+            .setClock(clock)
+            .build();
+    simulateTransfers(bandwidthMeter, clock);
+
+    // Override the network type to ethernet and simulate transfers again.
+    bandwidthMeter.setNetworkTypeOverride(C.NETWORK_TYPE_ETHERNET);
+    long[] bitrateEstimatesAfterReset = simulateTransfers(bandwidthMeter, clock);
+
+    // If overriding the network type fully reset the bandwidth meter, we expect the bitrate
+    // estimates generated during simulation to be the same.
+    assertThat(bitrateEstimatesAfterReset).isEqualTo(bitrateEstimatesWithNewInstance);
+  }
+
+  @Test
+  @SuppressWarnings("deprecation")
   public void defaultInitialBitrateEstimate_withoutContext_isReasonable() {
     DefaultBandwidthMeter bandwidthMeterWithBuilder =
         new DefaultBandwidthMeter.Builder(/* context= */ null).build();
@@ -510,17 +557,6 @@ public void defaultInitialBitrateEstimate_withoutContext_isReasonable() {
     assertThat(initialEstimateWithoutBuilder).isLessThan(50_000_000L);
   }
 
-  @Test
-  public void defaultInitialBitrateEstimate_withoutAccessNetworkStatePermission_isReasonable() {
-    Shadows.shadowOf(RuntimeEnvironment.application).denyPermissions(ACCESS_NETWORK_STATE);
-    DefaultBandwidthMeter bandwidthMeter =
-        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
-    long initialEstimate = bandwidthMeter.getBitrateEstimate();
-
-    assertThat(initialEstimate).isGreaterThan(100_000L);
-    assertThat(initialEstimate).isLessThan(50_000_000L);
-  }
-
   private void setActiveNetworkInfo(NetworkInfo networkInfo) {
     Shadows.shadowOf(connectivityManager).setActiveNetworkInfo(networkInfo);
   }
@@ -528,4 +564,23 @@ private void setActiveNetworkInfo(NetworkInfo networkInfo) {
   private void setNetworkCountryIso(String countryIso) {
     Shadows.shadowOf(telephonyManager).setNetworkCountryIso(countryIso);
   }
+
+  private static long[] simulateTransfers(DefaultBandwidthMeter bandwidthMeter, FakeClock clock) {
+    long[] bitrateEstimates = new long[SIMULATED_TRANSFER_COUNT];
+    Random random = new Random(/* seed= */ 0);
+    DataSource dataSource = new FakeDataSource();
+    DataSpec dataSpec = new DataSpec(Uri.parse("https://dummy.com"));
+    for (int i = 0; i < SIMULATED_TRANSFER_COUNT; i++) {
+      bandwidthMeter.onTransferStart(dataSource, dataSpec, /* isNetwork= */ true);
+      clock.advanceTime(random.nextInt(/* bound= */ 5000));
+      bandwidthMeter.onBytesTransferred(
+          dataSource,
+          dataSpec,
+          /* isNetwork= */ true,
+          /* bytes= */ random.nextInt(5 * 1024 * 1024));
+      bandwidthMeter.onTransferEnd(dataSource, dataSpec, /* isNetwork= */ true);
+      bitrateEstimates[i] = bandwidthMeter.getBitrateEstimate();
+    }
+    return bitrateEstimates;
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
index 5576588857..8840abfcdc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
@@ -18,18 +18,17 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link DefaultLoadErrorHandlingPolicy}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DefaultLoadErrorHandlingPolicyTest {
 
   @Test
@@ -60,7 +59,7 @@ public void getBlacklistDurationMsFor_dontBlacklistUnexpectedHttpCodes() {
 
   @Test
   public void getBlacklistDurationMsFor_dontBlacklistUnexpectedExceptions() {
-    FileNotFoundException exception = new FileNotFoundException();
+    IOException exception = new IOException();
     assertThat(getDefaultPolicyBlacklistOutputFor(exception)).isEqualTo(C.TIME_UNSET);
   }
 
@@ -72,9 +71,9 @@ public void getRetryDelayMsFor_dontRetryParserException() {
 
   @Test
   public void getRetryDelayMsFor_successiveRetryDelays() {
-    assertThat(getDefaultPolicyRetryDelayOutputFor(new FileNotFoundException(), 3)).isEqualTo(2000);
-    assertThat(getDefaultPolicyRetryDelayOutputFor(new FileNotFoundException(), 5)).isEqualTo(4000);
-    assertThat(getDefaultPolicyRetryDelayOutputFor(new FileNotFoundException(), 9)).isEqualTo(5000);
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new IOException(), 3)).isEqualTo(2000);
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new IOException(), 5)).isEqualTo(4000);
+    assertThat(getDefaultPolicyRetryDelayOutputFor(new IOException(), 9)).isEqualTo(5000);
   }
 
   private static long getDefaultPolicyBlacklistOutputFor(IOException exception) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
deleted file mode 100644
index 9304dc6dc3..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.testutil.FakeDataSet;
-import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSourceInputStream;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
-import java.util.ArrayList;
-
-/** Assertion methods for {@link com.google.android.exoplayer2.upstream.cache.Cache}. */
-/* package */ final class CacheAsserts {
-
-  /**
-   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
-    ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    Uri[] uris = new Uri[allData.size()];
-    for (int i = 0; i < allData.size(); i++) {
-      uris[i] = allData.get(i).uri;
-    }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
-
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
-      throws IOException {
-    Uri[] uris = new Uri[uriStrings.length];
-    for (int i = 0; i < uriStrings.length; i++) {
-      uris[i] = Uri.parse(uriStrings[i]);
-    }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
-
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    int totalLength = 0;
-    for (Uri uri : uris) {
-      byte[] data = fakeDataSet.getData(uri).getData();
-      assertDataCached(cache, uri, data);
-      totalLength += data.length;
-    }
-    assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
-  }
-
-  /**
-   * Asserts that the cache contains the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    for (Uri uri : uris) {
-      assertDataCached(cache, uri, fakeDataSet.getData(uri).getData());
-    }
-  }
-
-  /**
-   * Asserts that the cache contains the given data for {@code uriString} or not.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    DataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    DataSpec dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
-    String messageToPrepend = "Cached data doesn't match expected for '" + uri + "'";
-    assertReadData(dataSource, dataSpec, expected, messageToPrepend);
-  }
-
-  /**
-   * Asserts that the read data from {@code dataSource} specified by {@code dataSpec} is equal to
-   * {@code expected} or not.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertReadData(
-      DataSource dataSource, DataSpec dataSpec, byte[] expected, String messageToPrepend)
-      throws IOException {
-    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
-    byte[] bytes = null;
-    try {
-      bytes = Util.toByteArray(inputStream);
-    } catch (IOException e) {
-      // Ignore
-    } finally {
-      inputStream.close();
-    }
-    assertWithMessage(messageToPrepend).that(bytes).isEqualTo(expected);
-  }
-
-  /** Asserts that there is no cache content for the given {@code uriStrings}. */
-  public static void assertDataNotCached(Cache cache, String... uriStrings) {
-    for (String uriString : uriStrings) {
-      assertWithMessage("There is cached data for '" + uriString + "'")
-          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString))))
-          .isEmpty();
-    }
-  }
-
-  /** Asserts that the cache is empty. */
-  public static void assertCacheEmpty(Cache cache) {
-    assertThat(cache.getCacheSpace()).isEqualTo(0);
-  }
-
-  private CacheAsserts() {}
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index 2285a68062..956a5fc283 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -15,12 +15,16 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.CacheAsserts;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -35,33 +39,38 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit tests for {@link CacheDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link CacheDataSource}. */
+@RunWith(AndroidJUnit4.class)
 public final class CacheDataSourceTest {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-  private static final int MAX_CACHE_FILE_SIZE = 3;
-  private static final String CACHE_KEY_PREFIX = "myCacheKeyFactoryPrefix";
+  private static final int CACHE_FRAGMENT_SIZE = 3;
+  private static final String DATASPEC_KEY = "dataSpecKey";
 
   private Uri testDataUri;
-  private String fixedCacheKey;
-  private String expectedCacheKey;
+  private DataSpec unboundedDataSpec;
+  private DataSpec boundedDataSpec;
+  private DataSpec unboundedDataSpecWithKey;
+  private DataSpec boundedDataSpecWithKey;
+  private String defaultCacheKey;
+  private String customCacheKey;
+  private CacheKeyFactory cacheKeyFactory;
   private File tempFolder;
   private SimpleCache cache;
-  private CacheKeyFactory cacheKeyFactory;
 
   @Before
   public void setUp() throws Exception {
-    testDataUri = Uri.parse("test_data");
-    fixedCacheKey = CacheUtil.generateKey(testDataUri);
-    expectedCacheKey = fixedCacheKey;
-    cacheKeyFactory = dataSpec -> CACHE_KEY_PREFIX + "." + CacheUtil.generateKey(dataSpec.uri);
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    testDataUri = Uri.parse("https://www.test.com/data");
+    unboundedDataSpec = buildDataSpec(/* unbounded= */ true, /* key= */ null);
+    boundedDataSpec = buildDataSpec(/* unbounded= */ false, /* key= */ null);
+    unboundedDataSpecWithKey = buildDataSpec(/* unbounded= */ true, DATASPEC_KEY);
+    boundedDataSpecWithKey = buildDataSpec(/* unbounded= */ false, DATASPEC_KEY);
+    defaultCacheKey = CacheUtil.DEFAULT_CACHE_KEY_FACTORY.buildCacheKey(unboundedDataSpec);
+    customCacheKey = "customKey." + defaultCacheKey;
+    cacheKeyFactory = dataSpec -> customCacheKey;
+    tempFolder =
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
 
@@ -71,244 +80,194 @@ public void tearDown() throws Exception {
   }
 
   @Test
-  public void testMaxCacheFileSize() throws Exception {
+  public void testFragmentSize() throws Exception {
     CacheDataSource cacheDataSource = createCacheDataSource(false, false);
-    assertReadDataContentLength(cacheDataSource, false, false);
+    assertReadDataContentLength(cacheDataSource, boundedDataSpec, false, false);
     for (String key : cache.getKeys()) {
       for (CacheSpan cacheSpan : cache.getCachedSpans(key)) {
-        assertThat(cacheSpan.length <= MAX_CACHE_FILE_SIZE).isTrue();
-        assertThat(cacheSpan.file.length() <= MAX_CACHE_FILE_SIZE).isTrue();
+        assertThat(cacheSpan.length <= CACHE_FRAGMENT_SIZE).isTrue();
+        assertThat(cacheSpan.file.length() <= CACHE_FRAGMENT_SIZE).isTrue();
       }
     }
   }
 
   @Test
   public void testCacheAndReadUnboundedRequest() throws Exception {
-    assertCacheAndRead(/* unboundedRequest= */ true, /* simulateUnknownLength= */ false);
+    assertCacheAndRead(unboundedDataSpec, /* unknownLength= */ false);
   }
 
   @Test
   public void testCacheAndReadUnknownLength() throws Exception {
-    assertCacheAndRead(/* unboundedRequest= */ false, /* simulateUnknownLength= */ true);
+    assertCacheAndRead(boundedDataSpec, /* unknownLength= */ true);
   }
 
   @Test
   public void testCacheAndReadUnboundedRequestUnknownLength() throws Exception {
-    assertCacheAndRead(/* unboundedRequest= */ true, /* simulateUnknownLength= */ true);
+    assertCacheAndRead(unboundedDataSpec, /* unknownLength= */ true);
   }
 
   @Test
   public void testCacheAndRead() throws Exception {
-    assertCacheAndRead(/* unboundedRequest= */ false, /* simulateUnknownLength= */ false);
+    assertCacheAndRead(boundedDataSpec, /* unknownLength= */ false);
   }
 
   @Test
   public void testUnsatisfiableRange() throws Exception {
     // Bounded request but the content length is unknown. This forces all data to be cached but not
-    // the length
-    assertCacheAndRead(/* unboundedRequest= */ false, /* simulateUnknownLength= */ true);
+    // the length.
+    assertCacheAndRead(boundedDataSpec, /* unknownLength= */ true);
 
     // Now do an unbounded request. This will read all of the data from cache and then try to read
     // more from upstream which will cause to a 416 so CDS will store the length.
     CacheDataSource cacheDataSource =
-        createCacheDataSource(/* setReadException= */ true, /* simulateUnknownLength= */ true);
+        createCacheDataSource(/* setReadException= */ true, /* unknownLength= */ true);
     assertReadDataContentLength(
-        cacheDataSource, /* unboundedRequest= */ true, /* unknownLength= */ true);
+        cacheDataSource, unboundedDataSpec, /* unknownLength= */ true, /* customCacheKey= */ false);
 
-    // If the user try to access off range then it should throw an IOException
+    // If the user try to access off range then it should throw an IOException.
     try {
       cacheDataSource =
-          createCacheDataSource(/* setReadException= */ false, /* simulateUnknownLength= */ false);
-      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+          createCacheDataSource(/* setReadException= */ false, /* unknownLength= */ false);
+      cacheDataSource.open(buildDataSpec(TEST_DATA.length, /* length= */ 1, defaultCacheKey));
       fail();
     } catch (IOException e) {
-      // success
+      // Expected.
     }
   }
 
   @Test
   public void testCacheAndReadUnboundedRequestWithCacheKeyFactoryWithNullDataSpecCacheKey()
       throws Exception {
-    fixedCacheKey = null;
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
-
-    assertCacheAndRead(
-        /* unboundedRequest= */ true, /* simulateUnknownLength= */ false, cacheKeyFactory);
+    assertCacheAndRead(unboundedDataSpec, /* unknownLength= */ false, cacheKeyFactory);
   }
 
   @Test
   public void testCacheAndReadUnknownLengthWithCacheKeyFactoryOverridingWithNullDataSpecCacheKey()
       throws Exception {
-    fixedCacheKey = null;
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
-
-    assertCacheAndRead(
-        /* unboundedRequest= */ false, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    assertCacheAndRead(boundedDataSpec, /* unknownLength= */ true, cacheKeyFactory);
   }
 
   @Test
   public void
       testCacheAndReadUnboundedRequestUnknownLengthWithCacheKeyFactoryWithNullDataSpecCacheKey()
           throws Exception {
-    fixedCacheKey = null;
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
-
-    assertCacheAndRead(
-        /* unboundedRequest= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    assertCacheAndRead(unboundedDataSpec, /* unknownLength= */ true, cacheKeyFactory);
   }
 
   @Test
   public void testCacheAndReadWithCacheKeyFactoryWithNullDataSpecCacheKey() throws Exception {
-    fixedCacheKey = null;
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
-
-    assertCacheAndRead(
-        /* unboundedRequest= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
+    assertCacheAndRead(boundedDataSpec, /* unknownLength= */ false, cacheKeyFactory);
   }
 
   @Test
   public void testUnsatisfiableRangeWithCacheKeyFactoryNullDataSpecCacheKey() throws Exception {
-    fixedCacheKey = null;
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, /* key= */ null));
-
     // Bounded request but the content length is unknown. This forces all data to be cached but not
-    // the length
-    assertCacheAndRead(
-        /* unboundedRequest= */ false, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    // the length.
+    assertCacheAndRead(boundedDataSpec, /* unknownLength= */ true, cacheKeyFactory);
 
     // Now do an unbounded request. This will read all of the data from cache and then try to read
     // more from upstream which will cause to a 416 so CDS will store the length.
     CacheDataSource cacheDataSource =
         createCacheDataSource(
-            /* setReadException= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+            /* setReadException= */ true, /* unknownLength= */ true, cacheKeyFactory);
     assertReadDataContentLength(
-        cacheDataSource, /* unboundedRequest= */ true, /* unknownLength= */ true);
+        cacheDataSource, unboundedDataSpec, /* unknownLength= */ true, /* customCacheKey= */ true);
 
-    // If the user try to access off range then it should throw an IOException
+    // If the user try to access off range then it should throw an IOException.
     try {
       cacheDataSource =
           createCacheDataSource(
-              /* setReadException= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
-      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+              /* setReadException= */ false, /* unknownLength= */ false, cacheKeyFactory);
+      cacheDataSource.open(buildDataSpec(TEST_DATA.length, /* length= */ 1, customCacheKey));
       fail();
     } catch (IOException e) {
-      // success
+      // Expected.
     }
   }
 
   @Test
   public void testCacheAndReadUnboundedRequestWithCacheKeyFactoryOverridingDataSpecCacheKey()
       throws Exception {
-    fixedCacheKey = CacheUtil.generateKey(testDataUri);
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
-
-    assertCacheAndRead(true, false, cacheKeyFactory);
+    assertCacheAndRead(unboundedDataSpecWithKey, false, cacheKeyFactory);
   }
 
   @Test
   public void testCacheAndReadUnknownLengthWithCacheKeyFactoryOverridingDataSpecCacheKey()
       throws Exception {
-    fixedCacheKey = CacheUtil.generateKey(testDataUri);
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
-
-    assertCacheAndRead(false, true, cacheKeyFactory);
+    assertCacheAndRead(boundedDataSpecWithKey, true, cacheKeyFactory);
   }
 
   @Test
   public void
       testCacheAndReadUnboundedRequestUnknownLengthWithCacheKeyFactoryOverridingDataSpecCacheKey()
           throws Exception {
-    fixedCacheKey = CacheUtil.generateKey(testDataUri);
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
-
-    assertCacheAndRead(
-        /* unboundedRequest= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    assertCacheAndRead(unboundedDataSpecWithKey, /* unknownLength= */ true, cacheKeyFactory);
   }
 
   @Test
   public void testCacheAndReadWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
-    fixedCacheKey = CacheUtil.generateKey(testDataUri);
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
-
-    assertCacheAndRead(
-        /* unboundedRequest= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
+    assertCacheAndRead(boundedDataSpecWithKey, /* unknownLength= */ false, cacheKeyFactory);
   }
 
   @Test
   public void testUnsatisfiableRangeWithCacheKeyFactoryOverridingDataSpecCacheKey()
       throws Exception {
-    fixedCacheKey = CacheUtil.generateKey(testDataUri);
-    expectedCacheKey =
-        cacheKeyFactory.buildCacheKey(
-            new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
-
     // Bounded request but the content length is unknown. This forces all data to be cached but not
-    // the length
-    assertCacheAndRead(
-        /* unboundedRequest= */ false, /* simulateUnknownLength= */ true, cacheKeyFactory);
+    // the length.
+    assertCacheAndRead(boundedDataSpecWithKey, /* unknownLength= */ true, cacheKeyFactory);
 
     // Now do an unbounded request. This will read all of the data from cache and then try to read
     // more from upstream which will cause to a 416 so CDS will store the length.
     CacheDataSource cacheDataSource =
         createCacheDataSource(
-            /* setReadException= */ true, /* simulateUnknownLength= */ true, cacheKeyFactory);
+            /* setReadException= */ true, /* unknownLength= */ true, cacheKeyFactory);
     assertReadDataContentLength(
-        cacheDataSource, /* unboundedRequest= */ true, /* unknownLength= */ true);
+        cacheDataSource,
+        unboundedDataSpecWithKey,
+        /* unknownLength= */ true,
+        /* customCacheKey= */ true);
 
-    // If the user try to access off range then it should throw an IOException
+    // If the user try to access off range then it should throw an IOException.
     try {
       cacheDataSource =
           createCacheDataSource(
-              /* setReadException= */ false, /* simulateUnknownLength= */ false, cacheKeyFactory);
-      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, fixedCacheKey));
+              /* setReadException= */ false, /* unknownLength= */ false, cacheKeyFactory);
+      cacheDataSource.open(buildDataSpec(TEST_DATA.length, /* length= */ 1, customCacheKey));
       fail();
     } catch (IOException e) {
-      // success
+      // Expected.
     }
   }
 
   @Test
   public void testContentLengthEdgeCases() throws Exception {
-    // Read partial at EOS but don't cross it so length is unknown
+    DataSpec dataSpec = buildDataSpec(TEST_DATA.length - 2, 2);
+
+    // Read partial at EOS but don't cross it so length is unknown.
     CacheDataSource cacheDataSource = createCacheDataSource(false, true);
-    assertReadData(cacheDataSource, true, TEST_DATA.length - 2, 2);
-    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(C.LENGTH_UNSET);
+    assertReadData(cacheDataSource, dataSpec, true);
+    assertThat(ContentMetadata.getContentLength(cache.getContentMetadata(defaultCacheKey)))
+        .isEqualTo(C.LENGTH_UNSET);
 
     // Now do an unbounded request for whole data. This will cause a bounded request from upstream.
     // End of data from upstream shouldn't be mixed up with EOS and cause length set wrong.
     cacheDataSource = createCacheDataSource(false, true);
-    assertReadDataContentLength(cacheDataSource, true, true);
+    assertReadDataContentLength(cacheDataSource, unboundedDataSpec, true, false);
 
-    // Now the length set correctly do an unbounded request with offset
+    // Now the length set correctly do an unbounded request with offset.
     assertThat(
             cacheDataSource.open(
-                new DataSpec(testDataUri, TEST_DATA.length - 2, C.LENGTH_UNSET, expectedCacheKey)))
+                buildDataSpec(TEST_DATA.length - 2, C.LENGTH_UNSET, defaultCacheKey)))
         .isEqualTo(2);
 
-    // An unbounded request with offset for not cached content
-    assertThat(
-            cacheDataSource.open(
-                new DataSpec(
-                    Uri.parse("notCachedUri"), TEST_DATA.length - 2, C.LENGTH_UNSET, null)))
-        .isEqualTo(C.LENGTH_UNSET);
+    // An unbounded request with offset for not cached content.
+    dataSpec =
+        new DataSpec(
+            Uri.parse("https://www.test.com/other"),
+            TEST_DATA.length - 2,
+            C.LENGTH_UNSET,
+            /* key= */ null);
+    assertThat(cacheDataSource.open(dataSpec)).isEqualTo(C.LENGTH_UNSET);
   }
 
   @Test
@@ -321,13 +280,13 @@ public void testUnknownLengthContentReadInOneConnectionAndLengthIsResolved() thr
         .setSimulateUnknownLength(true);
     CacheDataSource cacheDataSource = new CacheDataSource(cache, upstream, 0);
 
-    int flags = DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH;
-    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, expectedCacheKey, flags));
+    cacheDataSource.open(unboundedDataSpec);
     TestUtil.readToEnd(cacheDataSource);
     cacheDataSource.close();
 
     assertThat(upstream.getAndClearOpenedDataSpecs()).hasLength(1);
-    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(TEST_DATA.length);
+    assertThat(ContentMetadata.getContentLength(cache.getContentMetadata(defaultCacheKey)))
+        .isEqualTo(TEST_DATA.length);
   }
 
   @Test
@@ -338,7 +297,7 @@ public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
         new CacheDataSource(
             cache, upstream, CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
 
-    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, expectedCacheKey));
+    cacheDataSource.open(unboundedDataSpec);
     TestUtil.readToEnd(cacheDataSource);
     cacheDataSource.close();
 
@@ -348,7 +307,7 @@ public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
   @Test
   public void testReadOnlyCache() throws Exception {
     CacheDataSource cacheDataSource = createCacheDataSource(false, false, 0, null);
-    assertReadDataContentLength(cacheDataSource, false, false);
+    assertReadDataContentLength(cacheDataSource, boundedDataSpec, false, false);
     assertCacheEmpty(cache);
   }
 
@@ -367,13 +326,11 @@ public void testSwitchToCacheSourceWithReadOnlyCacheDataSource() throws Exceptio
         new CacheDataSource(cache, upstream, new FileDataSource(), null, 0, null);
 
     // Open source and read some data from upstream as the data hasn't cached yet.
-    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
-    cacheDataSource.open(dataSpec);
+    cacheDataSource.open(unboundedDataSpec);
     byte[] buffer = new byte[1024];
     cacheDataSource.read(buffer, 0, buffer.length);
 
-    // Cache the data.
-    // Although we use another FakeDataSource instance, it shouldn't matter.
+    // Cache the data. Although we use another FakeDataSource instance, it shouldn't matter.
     FakeDataSource upstream2 =
         new FakeDataSource(
             new FakeDataSource()
@@ -381,7 +338,13 @@ public void testSwitchToCacheSourceWithReadOnlyCacheDataSource() throws Exceptio
                 .newDefaultData()
                 .appendReadData(1024 * 1024)
                 .endData());
-    CacheUtil.cache(dataSpec, cache, upstream2, /* counters= */ null, /* isCanceled= */ null);
+    CacheUtil.cache(
+        unboundedDataSpec,
+        cache,
+        /* cacheKeyFactory= */ null,
+        upstream2,
+        /* progressListener= */ null,
+        /* isCanceled= */ null);
 
     // Read the rest of the data.
     TestUtil.readToEnd(cacheDataSource);
@@ -400,7 +363,7 @@ public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Excep
         .appendReadData(1);
 
     // Lock the content on the cache.
-    SimpleCacheSpan cacheSpan = cache.startReadWriteNonBlocking(expectedCacheKey, 0);
+    SimpleCacheSpan cacheSpan = cache.startReadWriteNonBlocking(defaultCacheKey, 0);
     assertThat(cacheSpan).isNotNull();
     assertThat(cacheSpan.isHoleSpan()).isTrue();
 
@@ -408,8 +371,7 @@ public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Excep
     CacheDataSource cacheDataSource = new CacheDataSource(cache, upstream, 0);
 
     // Open source and read some data from upstream without writing to cache as the data is locked.
-    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
-    cacheDataSource.open(dataSpec);
+    cacheDataSource.open(unboundedDataSpec);
     byte[] buffer = new byte[1024];
     cacheDataSource.read(buffer, 0, buffer.length);
 
@@ -417,8 +379,7 @@ public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Excep
     cache.releaseHoleSpan(cacheSpan);
     assertCacheEmpty(cache);
 
-    // Cache the data.
-    // Although we use another FakeDataSource instance, it shouldn't matter.
+    // Cache the data. Although we use another FakeDataSource instance, it shouldn't matter.
     FakeDataSource upstream2 =
         new FakeDataSource(
             new FakeDataSource()
@@ -426,7 +387,13 @@ public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Excep
                 .newDefaultData()
                 .appendReadData(1024 * 1024)
                 .endData());
-    CacheUtil.cache(dataSpec, cache, upstream2, /* counters= */ null, /* isCanceled= */ null);
+    CacheUtil.cache(
+        unboundedDataSpec,
+        cache,
+        /* cacheKeyFactory= */ null,
+        upstream2,
+        /* progressListener= */ null,
+        /* isCanceled= */ null);
 
     // Read the rest of the data.
     TestUtil.readToEnd(cacheDataSource);
@@ -438,23 +405,30 @@ public void testDeleteCachedWhileReadingFromUpstreamWithReadOnlyCacheDataSourceD
       throws Exception {
     // Create a fake data source with a 1 KB default data.
     FakeDataSource upstream = new FakeDataSource();
-    upstream.getDataSet().newDefaultData().appendReadData(1024).endData();
+    int dataLength = 1024;
+    upstream.getDataSet().newDefaultData().appendReadData(dataLength).endData();
 
     // Cache the latter half of the data.
-    DataSpec dataSpec = new DataSpec(testDataUri, 512, C.LENGTH_UNSET, fixedCacheKey);
-    CacheUtil.cache(dataSpec, cache, upstream, /* counters= */ null, /* isCanceled= */ null);
+    int halfDataLength = 512;
+    DataSpec dataSpec = buildDataSpec(halfDataLength, C.LENGTH_UNSET);
+    CacheUtil.cache(
+        dataSpec,
+        cache,
+        /* cacheKeyFactory= */ null,
+        upstream,
+        /* progressListener= */ null,
+        /* isCanceled= */ null);
 
     // Create cache read-only CacheDataSource.
     CacheDataSource cacheDataSource =
         new CacheDataSource(cache, upstream, new FileDataSource(), null, 0, null);
 
     // Open source and read some data from upstream as the data hasn't cached yet.
-    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
-    cacheDataSource.open(dataSpec);
+    cacheDataSource.open(unboundedDataSpec);
     TestUtil.readExactly(cacheDataSource, 100);
 
     // Delete cached data.
-    CacheUtil.remove(cache, expectedCacheKey);
+    CacheUtil.remove(unboundedDataSpec, cache, /* cacheKeyFactory= */ null);
     assertCacheEmpty(cache);
 
     // Read the rest of the data.
@@ -472,21 +446,26 @@ public void testDeleteCachedWhileReadingFromUpstreamWithBlockingCacheDataSourceD
 
     // Cache the latter half of the data.
     int halfDataLength = 512;
-    DataSpec dataSpec = new DataSpec(testDataUri, halfDataLength, C.LENGTH_UNSET, fixedCacheKey);
-    CacheUtil.cache(dataSpec, cache, upstream, /* counters= */ null, /* isCanceled= */ null);
+    DataSpec dataSpec = buildDataSpec(/* position= */ 0, halfDataLength);
+    CacheUtil.cache(
+        dataSpec,
+        cache,
+        /* cacheKeyFactory= */ null,
+        upstream,
+        /* progressListener= */ null,
+        /* isCanceled= */ null);
 
     // Create blocking CacheDataSource.
     CacheDataSource cacheDataSource =
         new CacheDataSource(cache, upstream, CacheDataSource.FLAG_BLOCK_ON_CACHE);
 
-    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, fixedCacheKey);
-    cacheDataSource.open(dataSpec);
+    cacheDataSource.open(unboundedDataSpec);
 
     // Read the first half from upstream as it hasn't cached yet.
     TestUtil.readExactly(cacheDataSource, halfDataLength);
 
     // Delete the cached latter half.
-    NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(expectedCacheKey);
+    NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(defaultCacheKey);
     for (CacheSpan cachedSpan : cachedSpans) {
       if (cachedSpan.position >= halfDataLength) {
         cache.removeSpan(cachedSpan);
@@ -498,116 +477,108 @@ public void testDeleteCachedWhileReadingFromUpstreamWithBlockingCacheDataSourceD
     cacheDataSource.close();
   }
 
-  private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknownLength)
-      throws IOException {
-    // Read all data from upstream and write to cache
-    CacheDataSource cacheDataSource = createCacheDataSource(false, simulateUnknownLength);
-    assertReadDataContentLength(cacheDataSource, unboundedRequest, simulateUnknownLength);
-
-    // Just read from cache
-    cacheDataSource = createCacheDataSource(true, simulateUnknownLength);
-    assertReadDataContentLength(
-        cacheDataSource,
-        unboundedRequest,
-        // Length is already cached.
-        /* unknownLength= */ false);
+  private void assertCacheAndRead(DataSpec dataSpec, boolean unknownLength) throws IOException {
+    assertCacheAndRead(dataSpec, unknownLength, /* cacheKeyFactory= */ null);
   }
 
   private void assertCacheAndRead(
-      boolean unboundedRequest, boolean simulateUnknownLength, CacheKeyFactory cacheKeyFactory)
+      DataSpec dataSpec, boolean unknownLength, @Nullable CacheKeyFactory cacheKeyFactory)
       throws IOException {
-    // Read all data from upstream and write to cache
+    // Read all data from upstream and write to cache.
     CacheDataSource cacheDataSource =
-        createCacheDataSource(
-            /* setReadException= */ false, simulateUnknownLength, cacheKeyFactory);
-    assertReadDataContentLength(cacheDataSource, unboundedRequest, simulateUnknownLength);
+        createCacheDataSource(/* setReadException= */ false, unknownLength, cacheKeyFactory);
+    assertReadDataContentLength(cacheDataSource, dataSpec, unknownLength, cacheKeyFactory != null);
 
-    // Just read from cache
+    // Just read from cache.
     cacheDataSource =
-        createCacheDataSource(/* setReadException= */ true, simulateUnknownLength, cacheKeyFactory);
+        createCacheDataSource(/* setReadException= */ true, unknownLength, cacheKeyFactory);
     assertReadDataContentLength(
         cacheDataSource,
-        unboundedRequest,
-        // Length is already cached.
-        /* unknownLength= */ false);
+        dataSpec,
+        /* unknownLength= */ false,
+        /* customCacheKey= */ cacheKeyFactory != null);
   }
 
   /**
    * Reads data until EOI and compares it to {@link #TEST_DATA}. Also checks content length returned
    * from open() call and the cached content length.
    */
-  private void assertReadDataContentLength(CacheDataSource cacheDataSource,
-      boolean unboundedRequest, boolean unknownLength) throws IOException {
-    int length = unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length;
-    assertReadData(cacheDataSource, unknownLength, 0, length);
-    // If !unboundedRequest, CacheDataSource doesn't reach EOS so shouldn't cache content length
-    assertThat(cache.getContentLength(expectedCacheKey))
-        .isEqualTo(!unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length);
-  }
-
-  private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLength, int position,
-      int length) throws IOException {
-    int testDataLength = TEST_DATA.length - position;
-    if (length != C.LENGTH_UNSET) {
-      testDataLength = Math.min(testDataLength, length);
+  private void assertReadDataContentLength(
+      CacheDataSource cacheDataSource,
+      DataSpec dataSpec,
+      boolean unknownLength,
+      boolean customCacheKey)
+      throws IOException {
+    assertReadData(cacheDataSource, dataSpec, unknownLength);
+    // If the request was unbounded then the content length should be cached, either because the
+    // content length was known or because EOS was read. If the request was bounded then the content
+    // length will not have been determined.
+    ContentMetadata metadata =
+        cache.getContentMetadata(customCacheKey ? this.customCacheKey : defaultCacheKey);
+    assertThat(ContentMetadata.getContentLength(metadata))
+        .isEqualTo(dataSpec.length == C.LENGTH_UNSET ? TEST_DATA.length : C.LENGTH_UNSET);
+  }
+
+  private void assertReadData(
+      CacheDataSource cacheDataSource, DataSpec dataSpec, boolean unknownLength)
+      throws IOException {
+    int position = (int) dataSpec.absoluteStreamPosition;
+    int requestLength = (int) dataSpec.length;
+    int readLength = TEST_DATA.length - position;
+    if (requestLength != C.LENGTH_UNSET) {
+      readLength = Math.min(readLength, requestLength);
     }
-    DataSpec dataSpec =
-        new DataSpec(
-            testDataUri,
-            position,
-            length,
-            fixedCacheKey,
-            DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
-    assertThat(cacheDataSource.open(dataSpec)).isEqualTo(unknownLength ? length : testDataLength);
+    assertThat(cacheDataSource.open(dataSpec))
+        .isEqualTo(unknownLength ? requestLength : readLength);
     cacheDataSource.close();
 
-    byte[] expected = Arrays.copyOfRange(TEST_DATA, position, position + testDataLength);
-    CacheAsserts.assertReadData(
-        cacheDataSource, dataSpec, expected, "Cached data doesn't match the original data");
+    byte[] expected = Arrays.copyOfRange(TEST_DATA, position, position + readLength);
+    CacheAsserts.assertReadData(cacheDataSource, dataSpec, expected);
   }
 
-  private CacheDataSource createCacheDataSource(boolean setReadException,
-      boolean simulateUnknownLength) {
-    return createCacheDataSource(setReadException, simulateUnknownLength,
-        CacheDataSource.FLAG_BLOCK_ON_CACHE);
+  private CacheDataSource createCacheDataSource(boolean setReadException, boolean unknownLength) {
+    return createCacheDataSource(
+        setReadException, unknownLength, CacheDataSource.FLAG_BLOCK_ON_CACHE);
   }
 
   private CacheDataSource createCacheDataSource(
-      boolean setReadException, boolean simulateUnknownLength, CacheKeyFactory cacheKeyFactory) {
+      boolean setReadException, boolean unknownLength, CacheKeyFactory cacheKeyFactory) {
     return createCacheDataSource(
         setReadException,
-        simulateUnknownLength,
+        unknownLength,
         CacheDataSource.FLAG_BLOCK_ON_CACHE,
-        new CacheDataSink(cache, MAX_CACHE_FILE_SIZE),
+        new CacheDataSink(cache, CACHE_FRAGMENT_SIZE),
         cacheKeyFactory);
   }
 
-  private CacheDataSource createCacheDataSource(boolean setReadException,
-      boolean simulateUnknownLength, @CacheDataSource.Flags int flags) {
-    return createCacheDataSource(setReadException, simulateUnknownLength, flags,
-        new CacheDataSink(cache, MAX_CACHE_FILE_SIZE));
+  private CacheDataSource createCacheDataSource(
+      boolean setReadException, boolean unknownLength, @CacheDataSource.Flags int flags) {
+    return createCacheDataSource(
+        setReadException, unknownLength, flags, new CacheDataSink(cache, CACHE_FRAGMENT_SIZE));
   }
 
-  private CacheDataSource createCacheDataSource(boolean setReadException,
-      boolean simulateUnknownLength, @CacheDataSource.Flags int flags,
+  private CacheDataSource createCacheDataSource(
+      boolean setReadException,
+      boolean unknownLength,
+      @CacheDataSource.Flags int flags,
       CacheDataSink cacheWriteDataSink) {
     return createCacheDataSource(
-        setReadException,
-        simulateUnknownLength,
-        flags,
-        cacheWriteDataSink,
-        /* cacheKeyFactory= */ null);
+        setReadException, unknownLength, flags, cacheWriteDataSink, /* cacheKeyFactory= */ null);
   }
 
   private CacheDataSource createCacheDataSource(
       boolean setReadException,
-      boolean simulateUnknownLength,
+      boolean unknownLength,
       @CacheDataSource.Flags int flags,
       CacheDataSink cacheWriteDataSink,
       CacheKeyFactory cacheKeyFactory) {
     FakeDataSource upstream = new FakeDataSource();
-    FakeData fakeData = upstream.getDataSet().newDefaultData()
-        .setSimulateUnknownLength(simulateUnknownLength).appendReadData(TEST_DATA);
+    FakeData fakeData =
+        upstream
+            .getDataSet()
+            .newDefaultData()
+            .setSimulateUnknownLength(unknownLength)
+            .appendReadData(TEST_DATA);
     if (setReadException) {
       fakeData.appendReadError(new IOException("Shouldn't read from upstream"));
     }
@@ -621,4 +592,16 @@ private CacheDataSource createCacheDataSource(
         cacheKeyFactory);
   }
 
+  private DataSpec buildDataSpec(boolean unbounded, @Nullable String key) {
+    return buildDataSpec(/* position= */ 0, unbounded ? C.LENGTH_UNSET : TEST_DATA.length, key);
+  }
+
+  private DataSpec buildDataSpec(long position, long length) {
+    return buildDataSpec(position, length, /* key= */ null);
+  }
+
+  private DataSpec buildDataSpec(long position, long length, @Nullable String key) {
+    return new DataSpec(
+        testDataUri, position, length, key, DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION);
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
index 1e6febd8a9..bb32f47ba8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
@@ -21,6 +21,8 @@
 
 import android.content.Context;
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -37,13 +39,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
-/**
- * Additional tests for {@link CacheDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Additional tests for {@link CacheDataSource}. */
+@RunWith(AndroidJUnit4.class)
 public final class CacheDataSourceTest2 {
 
   private static final String EXO_CACHE_DIR = "exo";
@@ -83,7 +81,8 @@ public void testWithEncryption() throws IOException {
   private void testReads(boolean useEncryption) throws IOException {
     FakeDataSource upstreamSource = buildFakeUpstreamSource();
     CacheDataSource source =
-        buildCacheDataSource(RuntimeEnvironment.application, upstreamSource, useEncryption);
+        buildCacheDataSource(
+            ApplicationProvider.getApplicationContext(), upstreamSource, useEncryption);
     // First read, should arrive from upstream.
     testRead(END_ON_BOUNDARY, source);
     assertSingleOpen(upstreamSource, 0, OFFSET_ON_BOUNDARY);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
index 36fb78894f..9a449b2ebd 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
@@ -15,23 +15,22 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import static android.net.Uri.EMPTY;
-import static android.net.Uri.parse;
 import static com.google.android.exoplayer2.C.LENGTH_UNSET;
-import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
-import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCachedData;
-import static com.google.android.exoplayer2.upstream.cache.CacheUtil.generateKey;
-import static com.google.android.exoplayer2.upstream.cache.CacheUtil.getKey;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import android.util.Pair;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
+import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.File;
@@ -42,13 +41,9 @@
 import org.mockito.Answers;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
-/**
- * Tests {@link CacheUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests {@link CacheUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class CacheUtilTest {
 
   /**
@@ -83,8 +78,11 @@ public long getCachedLength(String key, long position, long length) {
     }
 
     @Override
-    public long getContentLength(String key) {
-      return contentLength;
+    public ContentMetadata getContentMetadata(String key) {
+      DefaultContentMetadata metadata = new DefaultContentMetadata();
+      ContentMetadataMutations mutations = new ContentMetadataMutations();
+      ContentMetadataMutations.setContentLength(mutations, contentLength);
+      return metadata.copyWithMutationsApplied(mutations);
     }
   }
 
@@ -96,92 +94,108 @@ public long getContentLength(String key) {
   public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     mockCache.init();
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    tempFolder =
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
 
   @After
-  public void tearDown() throws Exception {
+  public void tearDown() {
     Util.recursiveDelete(tempFolder);
   }
 
   @Test
-  public void testGenerateKey() throws Exception {
-    assertThat(generateKey(EMPTY)).isNotNull();
+  public void testGenerateKey() {
+    assertThat(CacheUtil.generateKey(Uri.EMPTY)).isNotNull();
 
     Uri testUri = Uri.parse("test");
     String key = CacheUtil.generateKey(testUri);
     assertThat(key).isNotNull();
 
-    // Should generate the same key for the same input
-    assertThat(generateKey(testUri)).isEqualTo(key);
+    // Should generate the same key for the same input.
+    assertThat(CacheUtil.generateKey(testUri)).isEqualTo(key);
 
-    // Should generate different key for different input
-    assertThat(key.equals(generateKey(parse("test2")))).isFalse();
+    // Should generate different key for different input.
+    assertThat(key.equals(CacheUtil.generateKey(Uri.parse("test2")))).isFalse();
   }
 
   @Test
-  public void testGetKey() throws Exception {
+  public void testDefaultCacheKeyFactory_buildCacheKey() {
     Uri testUri = Uri.parse("test");
     String key = "key";
-    // If DataSpec.key is present, returns it
-    assertThat(getKey(new DataSpec(testUri, 0, LENGTH_UNSET, key))).isEqualTo(key);
-    // If not generates a new one using DataSpec.uri
-    assertThat(getKey(new DataSpec(testUri, 0, LENGTH_UNSET, null)))
-        .isEqualTo(generateKey(testUri));
-  }
-
-  @Test
-  public void testDefaultCacheKeyFactory_buildCacheKey() throws Exception {
-    Uri testUri = Uri.parse("test");
-    String key = "key";
-    // If DataSpec.key is present, returns it
+    // If DataSpec.key is present, returns it.
     assertThat(
             CacheUtil.DEFAULT_CACHE_KEY_FACTORY.buildCacheKey(
                 new DataSpec(testUri, 0, LENGTH_UNSET, key)))
         .isEqualTo(key);
-    // If not generates a new one using DataSpec.uri
+    // If not generates a new one using DataSpec.uri.
     assertThat(
             CacheUtil.DEFAULT_CACHE_KEY_FACTORY.buildCacheKey(
                 new DataSpec(testUri, 0, LENGTH_UNSET, null)))
-        .isEqualTo(generateKey(testUri));
+        .isEqualTo(testUri.toString());
   }
 
   @Test
-  public void testGetCachedNoData() throws Exception {
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
+  public void testGetCachedNoData() {
+    Pair<Long, Long> contentLengthAndBytesCached =
+        CacheUtil.getCached(
+            new DataSpec(Uri.parse("test")), mockCache, /* cacheKeyFactory= */ null);
 
-    assertCounters(counters, 0, 0, C.LENGTH_UNSET);
+    assertThat(contentLengthAndBytesCached.first).isEqualTo(C.LENGTH_UNSET);
+    assertThat(contentLengthAndBytesCached.second).isEqualTo(0);
   }
 
   @Test
-  public void testGetCachedDataUnknownLength() throws Exception {
+  public void testGetCachedDataUnknownLength() {
     // Mock there is 100 bytes cached at the beginning
     mockCache.spansAndGaps = new int[] {100};
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
+    Pair<Long, Long> contentLengthAndBytesCached =
+        CacheUtil.getCached(
+            new DataSpec(Uri.parse("test")), mockCache, /* cacheKeyFactory= */ null);
 
-    assertCounters(counters, 100, 0, C.LENGTH_UNSET);
+    assertThat(contentLengthAndBytesCached.first).isEqualTo(C.LENGTH_UNSET);
+    assertThat(contentLengthAndBytesCached.second).isEqualTo(100);
   }
 
   @Test
-  public void testGetCachedNoDataKnownLength() throws Exception {
+  public void testGetCachedNoDataKnownLength() {
     mockCache.contentLength = 1000;
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
+    Pair<Long, Long> contentLengthAndBytesCached =
+        CacheUtil.getCached(
+            new DataSpec(Uri.parse("test")), mockCache, /* cacheKeyFactory= */ null);
 
-    assertCounters(counters, 0, 0, 1000);
+    assertThat(contentLengthAndBytesCached.first).isEqualTo(1000);
+    assertThat(contentLengthAndBytesCached.second).isEqualTo(0);
   }
 
   @Test
-  public void testGetCached() throws Exception {
+  public void testGetCached() {
     mockCache.contentLength = 1000;
     mockCache.spansAndGaps = new int[] {100, 100, 200};
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
+    Pair<Long, Long> contentLengthAndBytesCached =
+        CacheUtil.getCached(
+            new DataSpec(Uri.parse("test")), mockCache, /* cacheKeyFactory= */ null);
 
-    assertCounters(counters, 300, 0, 1000);
+    assertThat(contentLengthAndBytesCached.first).isEqualTo(1000);
+    assertThat(contentLengthAndBytesCached.second).isEqualTo(300);
+  }
+
+  @Test
+  public void testGetCachedFromNonZeroPosition() {
+    mockCache.contentLength = 1000;
+    mockCache.spansAndGaps = new int[] {100, 100, 200};
+    Pair<Long, Long> contentLengthAndBytesCached =
+        CacheUtil.getCached(
+            new DataSpec(
+                Uri.parse("test"),
+                /* absoluteStreamPosition= */ 100,
+                /* length= */ C.LENGTH_UNSET,
+                /* key= */ null),
+            mockCache,
+            /* cacheKeyFactory= */ null);
+
+    assertThat(contentLengthAndBytesCached.first).isEqualTo(900);
+    assertThat(contentLengthAndBytesCached.second).isEqualTo(200);
   }
 
   @Test
@@ -191,9 +205,14 @@ public void testCache() throws Exception {
 
     CachingCounters counters = new CachingCounters();
     CacheUtil.cache(
-        new DataSpec(Uri.parse("test_data")), cache, dataSource, counters, /* isCanceled= */ null);
+        new DataSpec(Uri.parse("test_data")),
+        cache,
+        /* cacheKeyFactory= */ null,
+        dataSource,
+        counters,
+        /* isCanceled= */ null);
 
-    assertCounters(counters, 0, 100, 100);
+    counters.assertValues(0, 100, 100);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -205,13 +224,21 @@ public void testCacheSetOffsetAndLength() throws Exception {
     Uri testUri = Uri.parse("test_data");
     DataSpec dataSpec = new DataSpec(testUri, 10, 20, null);
     CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters, /* isCanceled= */ null);
+    CacheUtil.cache(
+        dataSpec, cache, /* cacheKeyFactory= */ null, dataSource, counters, /* isCanceled= */ null);
 
-    assertCounters(counters, 0, 20, 20);
+    counters.assertValues(0, 20, 20);
+    counters.reset();
 
-    CacheUtil.cache(new DataSpec(testUri), cache, dataSource, counters, /* isCanceled= */ null);
+    CacheUtil.cache(
+        new DataSpec(testUri),
+        cache,
+        /* cacheKeyFactory= */ null,
+        dataSource,
+        counters,
+        /* isCanceled= */ null);
 
-    assertCounters(counters, 20, 80, 100);
+    counters.assertValues(20, 80, 100);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -224,9 +251,10 @@ public void testCacheUnknownLength() throws Exception {
 
     DataSpec dataSpec = new DataSpec(Uri.parse("test_data"));
     CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters, /* isCanceled= */ null);
+    CacheUtil.cache(
+        dataSpec, cache, /* cacheKeyFactory= */ null, dataSource, counters, /* isCanceled= */ null);
 
-    assertCounters(counters, 0, 100, 100);
+    counters.assertValues(0, 100, 100);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -240,13 +268,21 @@ public void testCacheUnknownLengthPartialCaching() throws Exception {
     Uri testUri = Uri.parse("test_data");
     DataSpec dataSpec = new DataSpec(testUri, 10, 20, null);
     CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters, /* isCanceled= */ null);
+    CacheUtil.cache(
+        dataSpec, cache, /* cacheKeyFactory= */ null, dataSource, counters, /* isCanceled= */ null);
 
-    assertCounters(counters, 0, 20, 20);
+    counters.assertValues(0, 20, 20);
+    counters.reset();
 
-    CacheUtil.cache(new DataSpec(testUri), cache, dataSource, counters, /* isCanceled= */ null);
+    CacheUtil.cache(
+        new DataSpec(testUri),
+        cache,
+        /* cacheKeyFactory= */ null,
+        dataSource,
+        counters,
+        /* isCanceled= */ null);
 
-    assertCounters(counters, 20, 80, 100);
+    counters.assertValues(20, 80, 100);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -258,9 +294,10 @@ public void testCacheLengthExceedsActualDataLength() throws Exception {
     Uri testUri = Uri.parse("test_data");
     DataSpec dataSpec = new DataSpec(testUri, 0, 1000, null);
     CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters, /* isCanceled= */ null);
+    CacheUtil.cache(
+        dataSpec, cache, /* cacheKeyFactory= */ null, dataSource, counters, /* isCanceled= */ null);
 
-    assertCounters(counters, 0, 100, 1000);
+    counters.assertValues(0, 100, 1000);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -276,11 +313,12 @@ public void testCacheThrowEOFException() throws Exception {
       CacheUtil.cache(
           dataSpec,
           cache,
+          /* cacheKeyFactory= */ null,
           new CacheDataSource(cache, dataSource),
           new byte[CacheUtil.DEFAULT_BUFFER_SIZE_BYTES],
           /* priorityTaskManager= */ null,
           /* priority= */ 0,
-          /* counters= */ null,
+          /* progressListener= */ null,
           /* isCanceled= */ null,
           /* enableEOFException= */ true);
       fail();
@@ -296,17 +334,22 @@ public void testCachePolling() throws Exception {
         new FakeDataSet()
             .newData("test_data")
             .appendReadData(TestUtil.buildTestData(100))
-            .appendReadAction(() -> assertCounters(counters, 0, 100, 300))
+            .appendReadAction(() -> counters.assertValues(0, 100, 300))
             .appendReadData(TestUtil.buildTestData(100))
-            .appendReadAction(() -> assertCounters(counters, 0, 200, 300))
+            .appendReadAction(() -> counters.assertValues(0, 200, 300))
             .appendReadData(TestUtil.buildTestData(100))
             .endData();
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
 
     CacheUtil.cache(
-        new DataSpec(Uri.parse("test_data")), cache, dataSource, counters, /* isCanceled= */ null);
+        new DataSpec(Uri.parse("test_data")),
+        cache,
+        /* cacheKeyFactory= */ null,
+        dataSource,
+        counters,
+        /* isCanceled= */ null);
 
-    assertCounters(counters, 0, 300, 300);
+    counters.assertValues(0, 300, 300);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -316,27 +359,58 @@ public void testRemove() throws Exception {
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
 
     Uri uri = Uri.parse("test_data");
+    DataSpec dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION);
     CacheUtil.cache(
-        new DataSpec(uri),
+        dataSpec,
         cache,
-        // set maxCacheFileSize to 10 to make sure there are multiple spans
-        new CacheDataSource(cache, dataSource, 0, 10),
+        /* cacheKeyFactory= */ null,
+        // Set fragmentSize to 10 to make sure there are multiple spans.
+        new CacheDataSource(
+            cache,
+            dataSource,
+            new FileDataSource(),
+            new CacheDataSink(cache, /* fragmentSize= */ 10),
+            /* flags= */ 0,
+            /* eventListener= */ null),
         new byte[CacheUtil.DEFAULT_BUFFER_SIZE_BYTES],
         /* priorityTaskManager= */ null,
         /* priority= */ 0,
-        /* counters= */ null,
+        /* progressListener= */ null,
         /* isCanceled= */ null,
         true);
-    CacheUtil.remove(cache, CacheUtil.generateKey(uri));
+    CacheUtil.remove(dataSpec, cache, /* cacheKeyFactory= */ null);
 
     assertCacheEmpty(cache);
   }
 
-  private static void assertCounters(CachingCounters counters, int alreadyCachedBytes,
-      int newlyCachedBytes, int contentLength) {
-    assertThat(counters.alreadyCachedBytes).isEqualTo(alreadyCachedBytes);
-    assertThat(counters.newlyCachedBytes).isEqualTo(newlyCachedBytes);
-    assertThat(counters.contentLength).isEqualTo(contentLength);
-  }
+  private static final class CachingCounters implements CacheUtil.ProgressListener {
+
+    private long contentLength = C.LENGTH_UNSET;
+    private long bytesAlreadyCached;
+    private long bytesNewlyCached;
+    private boolean seenFirstProgressUpdate;
 
+    @Override
+    public void onProgress(long contentLength, long bytesCached, long newBytesCached) {
+      this.contentLength = contentLength;
+      if (!seenFirstProgressUpdate) {
+        bytesAlreadyCached = bytesCached;
+        seenFirstProgressUpdate = true;
+      }
+      bytesNewlyCached = bytesCached - bytesAlreadyCached;
+    }
+
+    public void assertValues(int bytesAlreadyCached, int bytesNewlyCached, int contentLength) {
+      assertThat(this.bytesAlreadyCached).isEqualTo(bytesAlreadyCached);
+      assertThat(this.bytesNewlyCached).isEqualTo(bytesNewlyCached);
+      assertThat(this.contentLength).isEqualTo(contentLength);
+    }
+
+    public void reset() {
+      contentLength = C.LENGTH_UNSET;
+      bytesAlreadyCached = 0;
+      bytesNewlyCached = 0;
+      seenFirstProgressUpdate = false;
+    }
+  }
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
similarity index 71%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
index 964f7266b5..cee5703ff8 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
@@ -19,10 +19,11 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import android.net.Uri;
+import androidx.annotation.Nullable;
 import android.util.SparseArray;
-import androidx.test.InstrumentationRegistry;
-import androidx.test.runner.AndroidJUnit4;
-import com.google.android.exoplayer2.C;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileInputStream;
@@ -73,14 +74,12 @@
       0, 0, 0, 0, 0, 0, 10, 0, // original_content_length
       0x12, 0x15, 0x66, (byte) 0x8A // hashcode_of_CachedContent_array
   };
-  private CachedContentIndex index;
   private File cacheDir;
 
   @Before
   public void setUp() throws Exception {
     cacheDir =
-        Util.createTempDirectory(InstrumentationRegistry.getTargetContext(), "ExoPlayerTest");
-    index = new CachedContentIndex(cacheDir);
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
   }
 
   @After
@@ -94,15 +93,23 @@ public void testAddGetRemove() throws Exception {
     final String key2 = "key2";
     final String key3 = "key3";
 
+    CachedContentIndex index = newInstance();
+
     // Add two CachedContents with add methods
     CachedContent cachedContent1 = index.getOrAdd(key1);
     CachedContent cachedContent2 = index.getOrAdd(key2);
     assertThat(cachedContent1.id != cachedContent2.id).isTrue();
 
     // add a span
+    int cacheFileLength = 20;
     File cacheSpanFile =
-        SimpleCacheSpanTest.createCacheSpanFile(cacheDir, cachedContent1.id, 10, 20, 30);
-    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, index);
+        SimpleCacheSpanTest.createCacheSpanFile(
+            cacheDir,
+            cachedContent1.id,
+            /* offset= */ 10,
+            cacheFileLength,
+            /* lastTouchTimestamp= */ 30);
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, cacheFileLength, index);
     assertThat(span).isNotNull();
     cachedContent1.addSpan(span);
 
@@ -139,49 +146,56 @@ public void testAddGetRemove() throws Exception {
   }
 
   @Test
-  public void testStoreAndLoad() throws Exception {
-    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir));
+  public void testLegacyStoreAndLoad() throws Exception {
+    assertStoredAndLoadedEqual(newLegacyInstance(), newLegacyInstance());
   }
 
   @Test
-  public void testLoadV1() throws Exception {
-    FileOutputStream fos = new FileOutputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
+  public void testLegacyLoadV1() throws Exception {
+    CachedContentIndex index = newLegacyInstance();
+
+    FileOutputStream fos =
+        new FileOutputStream(new File(cacheDir, CachedContentIndex.FILE_NAME_ATOMIC));
     fos.write(testIndexV1File);
     fos.close();
 
-    index.load();
+    index.initialize(/* uid= */ 0);
     assertThat(index.getAll()).hasSize(2);
 
     assertThat(index.assignIdForKey("ABCDE")).isEqualTo(5);
     ContentMetadata metadata = index.get("ABCDE").getMetadata();
-    assertThat(ContentMetadataInternal.getContentLength(metadata)).isEqualTo(10);
+    assertThat(ContentMetadata.getContentLength(metadata)).isEqualTo(10);
 
     assertThat(index.assignIdForKey("KLMNO")).isEqualTo(2);
     ContentMetadata metadata2 = index.get("KLMNO").getMetadata();
-    assertThat(ContentMetadataInternal.getContentLength(metadata2)).isEqualTo(2560);
+    assertThat(ContentMetadata.getContentLength(metadata2)).isEqualTo(2560);
   }
 
   @Test
-  public void testLoadV2() throws Exception {
-    FileOutputStream fos = new FileOutputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
+  public void testLegacyLoadV2() throws Exception {
+    CachedContentIndex index = newLegacyInstance();
+
+    FileOutputStream fos =
+        new FileOutputStream(new File(cacheDir, CachedContentIndex.FILE_NAME_ATOMIC));
     fos.write(testIndexV2File);
     fos.close();
 
-    index.load();
+    index.initialize(/* uid= */ 0);
     assertThat(index.getAll()).hasSize(2);
 
     assertThat(index.assignIdForKey("ABCDE")).isEqualTo(5);
     ContentMetadata metadata = index.get("ABCDE").getMetadata();
-    assertThat(ContentMetadataInternal.getContentLength(metadata)).isEqualTo(10);
-    assertThat(ContentMetadataInternal.getRedirectedUri(metadata)).isEqualTo(Uri.parse("abcde"));
+    assertThat(ContentMetadata.getContentLength(metadata)).isEqualTo(10);
+    assertThat(ContentMetadata.getRedirectedUri(metadata)).isEqualTo(Uri.parse("abcde"));
 
     assertThat(index.assignIdForKey("KLMNO")).isEqualTo(2);
     ContentMetadata metadata2 = index.get("KLMNO").getMetadata();
-    assertThat(ContentMetadataInternal.getContentLength(metadata2)).isEqualTo(2560);
+    assertThat(ContentMetadata.getContentLength(metadata2)).isEqualTo(2560);
   }
 
   @Test
   public void testAssignIdForKeyAndGetKeyForId() {
+    CachedContentIndex index = newInstance();
     final String key1 = "key1";
     final String key2 = "key2";
     int id1 = index.assignIdForKey(key1);
@@ -206,21 +220,19 @@ public void testGetNewId() {
   }
 
   @Test
-  public void testEncryption() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
-    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
+  public void testLegacyEncryption() throws Exception {
+    byte[] key = Util.getUtf8Bytes("Bar12345Bar12345"); // 128 bit key
+    byte[] key2 = Util.getUtf8Bytes("Foo12345Foo12345"); // 128 bit key
 
-    assertStoredAndLoadedEqual(
-        new CachedContentIndex(cacheDir, key), new CachedContentIndex(cacheDir, key));
+    assertStoredAndLoadedEqual(newLegacyInstance(key), newLegacyInstance(key));
 
     // Rename the index file from the test above
-    File file1 = new File(cacheDir, CachedContentIndex.FILE_NAME);
+    File file1 = new File(cacheDir, CachedContentIndex.FILE_NAME_ATOMIC);
     File file2 = new File(cacheDir, "file2compare");
     assertThat(file1.renameTo(file2)).isTrue();
 
     // Write a new index file
-    assertStoredAndLoadedEqual(
-        new CachedContentIndex(cacheDir, key), new CachedContentIndex(cacheDir, key));
+    assertStoredAndLoadedEqual(newLegacyInstance(key), newLegacyInstance(key));
 
     assertThat(file1.length()).isEqualTo(file2.length());
     // Assert file content is different
@@ -232,8 +244,7 @@ public void testEncryption() throws Exception {
 
     boolean threw = false;
     try {
-      assertStoredAndLoadedEqual(
-          new CachedContentIndex(cacheDir, key), new CachedContentIndex(cacheDir, key2));
+      assertStoredAndLoadedEqual(newLegacyInstance(key), newLegacyInstance(key2));
     } catch (AssertionError e) {
       threw = true;
     }
@@ -242,8 +253,7 @@ public void testEncryption() throws Exception {
         .isTrue();
 
     try {
-      assertStoredAndLoadedEqual(
-          new CachedContentIndex(cacheDir, key), new CachedContentIndex(cacheDir));
+      assertStoredAndLoadedEqual(newLegacyInstance(key), newLegacyInstance());
     } catch (AssertionError e) {
       threw = true;
     }
@@ -252,18 +262,18 @@ public void testEncryption() throws Exception {
         .isTrue();
 
     // Non encrypted index file can be read even when encryption key provided.
-    assertStoredAndLoadedEqual(
-        new CachedContentIndex(cacheDir), new CachedContentIndex(cacheDir, key));
+    assertStoredAndLoadedEqual(newLegacyInstance(), newLegacyInstance(key));
 
     // Test multiple store() calls
-    CachedContentIndex index = new CachedContentIndex(cacheDir, key);
+    CachedContentIndex index = newLegacyInstance(key);
     index.getOrAdd("key3");
     index.store();
-    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir, key));
+    assertStoredAndLoadedEqual(index, newLegacyInstance(key));
   }
 
   @Test
   public void testRemoveEmptyNotLockedCachedContent() {
+    CachedContentIndex index = newInstance();
     CachedContent cachedContent = index.getOrAdd("key1");
 
     index.maybeRemove(cachedContent.key);
@@ -273,10 +283,18 @@ public void testRemoveEmptyNotLockedCachedContent() {
 
   @Test
   public void testCantRemoveNotEmptyCachedContent() throws Exception {
+    CachedContentIndex index = newInstance();
+
     CachedContent cachedContent = index.getOrAdd("key1");
-    File cacheSpanFile =
-        SimpleCacheSpanTest.createCacheSpanFile(cacheDir, cachedContent.id, 10, 20, 30);
-    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, index);
+    long cacheFileLength = 20;
+    File cacheFile =
+        SimpleCacheSpanTest.createCacheSpanFile(
+            cacheDir,
+            cachedContent.id,
+            /* offset= */ 10,
+            cacheFileLength,
+            /* lastTouchTimestamp= */ 30);
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheFile, cacheFileLength, index);
     cachedContent.addSpan(span);
 
     index.maybeRemove(cachedContent.key);
@@ -286,6 +304,7 @@ public void testCantRemoveNotEmptyCachedContent() throws Exception {
 
   @Test
   public void testCantRemoveLockedCachedContent() {
+    CachedContentIndex index = newInstance();
     CachedContent cachedContent = index.getOrAdd("key1");
     cachedContent.setLocked(true);
 
@@ -297,15 +316,15 @@ public void testCantRemoveLockedCachedContent() {
   private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentIndex index2)
       throws IOException {
     ContentMetadataMutations mutations1 = new ContentMetadataMutations();
-    ContentMetadataInternal.setContentLength(mutations1, 2560);
+    ContentMetadataMutations.setContentLength(mutations1, 2560);
     index.getOrAdd("KLMNO").applyMetadataMutations(mutations1);
     ContentMetadataMutations mutations2 = new ContentMetadataMutations();
-    ContentMetadataInternal.setContentLength(mutations2, 10);
-    ContentMetadataInternal.setRedirectedUri(mutations2, Uri.parse("abcde"));
+    ContentMetadataMutations.setContentLength(mutations2, 10);
+    ContentMetadataMutations.setRedirectedUri(mutations2, Uri.parse("abcde"));
     index.getOrAdd("ABCDE").applyMetadataMutations(mutations2);
     index.store();
 
-    index2.load();
+    index2.initialize(/* uid= */ 0);
     Set<String> keys = index.getKeys();
     Set<String> keys2 = index2.getKeys();
     assertThat(keys2).isEqualTo(keys);
@@ -313,4 +332,21 @@ private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentI
       assertThat(index2.get(key)).isEqualTo(index.get(key));
     }
   }
+
+  private CachedContentIndex newInstance() {
+    return new CachedContentIndex(TestUtil.getTestDatabaseProvider());
+  }
+
+  private CachedContentIndex newLegacyInstance() {
+    return newLegacyInstance(null);
+  }
+
+  private CachedContentIndex newLegacyInstance(@Nullable byte[] key) {
+    return new CachedContentIndex(
+        /* databaseProvider= */ null,
+        cacheDir,
+        /* legacyStorageSecretKey= */ key,
+        /* legacyStorageEncrypt= */ key != null,
+        /* preferLegacyStorage= */ true);
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
index f8da2b1085..b00ee73f0f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -20,7 +20,10 @@
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.when;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -32,11 +35,9 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Tests for {@link CachedRegionTracker}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class CachedRegionTrackerTest {
 
   private static final String CACHE_KEY = "abc";
@@ -63,8 +64,9 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     when(cache.addListener(anyString(), any(Cache.Listener.class))).thenReturn(new TreeSet<>());
     tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
-    cacheDir = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
-    index = new CachedContentIndex(cacheDir);
+    cacheDir =
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
+    index = new CachedContentIndex(TestUtil.getTestDatabaseProvider());
   }
 
   @After
@@ -128,12 +130,12 @@ public void testGetRegion_subchunkEstimation() throws Exception {
   private CacheSpan newCacheSpan(int position, int length) throws IOException {
     int id = index.assignIdForKey(CACHE_KEY);
     File cacheFile = createCacheSpanFile(cacheDir, id, position, length, 0);
-    return SimpleCacheSpan.createCacheEntry(cacheFile, index);
+    return SimpleCacheSpan.createCacheEntry(cacheFile, length, index);
   }
 
   public static File createCacheSpanFile(
-      File cacheDir, int id, long offset, int length, long lastAccessTimestamp) throws IOException {
-    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastAccessTimestamp);
+      File cacheDir, int id, long offset, int length, long lastTouchTimestamp) throws IOException {
+    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastTouchTimestamp);
     createTestFile(cacheFile, length);
     return cacheFile;
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadataTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadataTest.java
index e1dc68eac6..9c9b7073eb 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadataTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/DefaultContentMetadataTest.java
@@ -17,17 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests {@link DefaultContentMetadata}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class DefaultContentMetadataTest {
 
   private DefaultContentMetadata contentMetadata;
@@ -133,24 +129,6 @@ public void testRemoveAndAddMetadata() throws Exception {
     assertThat(contentMetadata.get("metadata name", "default value")).isEqualTo("value");
   }
 
-  @Test
-  public void testSerializeDeserialize() throws Exception {
-    byte[] metadata3 = {1, 2, 3};
-    contentMetadata =
-        createContentMetadata(
-            "metadata1 name", "value", "metadata2 name", 12345, "metadata3 name", metadata3);
-
-    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    contentMetadata.writeToStream(new DataOutputStream(outputStream));
-    ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
-    DefaultContentMetadata contentMetadata2 =
-        DefaultContentMetadata.readFromStream(new DataInputStream(inputStream));
-
-    assertThat(contentMetadata2.get("metadata1 name", "default value")).isEqualTo("value");
-    assertThat(contentMetadata2.get("metadata2 name", 0)).isEqualTo(12345);
-    assertThat(contentMetadata2.get("metadata3 name", new byte[] {})).isEqualTo(metadata3);
-  }
-
   @Test
   public void testEqualsStringValues() throws Exception {
     DefaultContentMetadata metadata1 = createContentMetadata("metadata1", "value");
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
index 84327e1091..482174e3da 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
@@ -15,17 +15,15 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link LeastRecentlyUsedCacheEvictor}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link LeastRecentlyUsedCacheEvictor}. */
+@RunWith(AndroidJUnit4.class)
 public class LeastRecentlyUsedCacheEvictorTest {
 
   @Before
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
similarity index 71%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
index c422bf33fa..39be9fbcd8 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
@@ -18,13 +18,14 @@
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
-import androidx.test.InstrumentationRegistry;
-import androidx.test.runner.AndroidJUnit4;
+import android.util.LongSparseArray;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.util.HashMap;
 import java.util.Set;
 import java.util.TreeSet;
 import org.junit.After;
@@ -36,28 +37,21 @@
 @RunWith(AndroidJUnit4.class)
 public class SimpleCacheSpanTest {
 
-  private CachedContentIndex index;
-  private File cacheDir;
-
-  public static File createCacheSpanFile(File cacheDir, int id, long offset, int length,
-      long lastAccessTimestamp) throws IOException {
-    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastAccessTimestamp);
+  public static File createCacheSpanFile(
+      File cacheDir, int id, long offset, long length, long lastTouchTimestamp) throws IOException {
+    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastTouchTimestamp);
     createTestFile(cacheFile, length);
     return cacheFile;
   }
 
-  public static CacheSpan createCacheSpan(CachedContentIndex index, File cacheDir, String key,
-      long offset, int length, long lastAccessTimestamp) throws IOException {
-    int id = index.assignIdForKey(key);
-    File cacheFile = createCacheSpanFile(cacheDir, id, offset, length, lastAccessTimestamp);
-    return SimpleCacheSpan.createCacheEntry(cacheFile, index);
-  }
+  private CachedContentIndex index;
+  private File cacheDir;
 
   @Before
   public void setUp() throws Exception {
     cacheDir =
-        Util.createTempDirectory(InstrumentationRegistry.getTargetContext(), "ExoPlayerTest");
-    index = new CachedContentIndex(cacheDir);
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
+    index = new CachedContentIndex(TestUtil.getTestDatabaseProvider());
   }
 
   @After
@@ -86,15 +80,15 @@ public void testCacheFile() throws Exception {
 
   @Test
   public void testUpgradeFileName() throws Exception {
-    String key = "asd\u00aa";
+    String key = "abc%def";
     int id = index.assignIdForKey(key);
     File v3file = createTestFile(id + ".0.1.v3.exo");
-    File v2file = createTestFile("asd%aa.1.2.v2.exo");
-    File wrongEscapedV2file = createTestFile("asd%za.3.4.v2.exo");
-    File v1File = createTestFile("asd\u00aa.5.6.v1.exo");
+    File v2file = createTestFile("abc%25def.1.2.v2.exo"); // %25 is '%' after escaping
+    File wrongEscapedV2file = createTestFile("abc%2Gdef.3.4.v2.exo"); // 2G is invalid hex
+    File v1File = createTestFile("abc%def.5.6.v1.exo"); // V1 did not escape
 
     for (File file : cacheDir.listFiles()) {
-      SimpleCacheSpan cacheEntry = SimpleCacheSpan.createCacheEntry(file, index);
+      SimpleCacheSpan cacheEntry = SimpleCacheSpan.createCacheEntry(file, file.length(), index);
       if (file.equals(wrongEscapedV2file)) {
         assertThat(cacheEntry).isNull();
       } else {
@@ -117,21 +111,21 @@ public void testUpgradeFileName() throws Exception {
     TreeSet<SimpleCacheSpan> spans = index.get(key).getSpans();
     assertWithMessage("upgradeOldFiles() shouldn't add any spans.").that(spans.isEmpty()).isTrue();
 
-    HashMap<Long, Long> cachedPositions = new HashMap<>();
+    LongSparseArray<Long> cachedPositions = new LongSparseArray<>();
     for (File file : files) {
-      SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(file, index);
+      SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(file, file.length(), index);
       if (cacheSpan != null) {
         assertThat(cacheSpan.key).isEqualTo(key);
-        cachedPositions.put(cacheSpan.position, cacheSpan.lastAccessTimestamp);
+        cachedPositions.put(cacheSpan.position, cacheSpan.lastTouchTimestamp);
       }
     }
 
-    assertThat(cachedPositions.get((long) 0)).isEqualTo(1);
-    assertThat(cachedPositions.get((long) 1)).isEqualTo(2);
-    assertThat(cachedPositions.get((long) 5)).isEqualTo(6);
+    assertThat(cachedPositions.get(0)).isEqualTo(1);
+    assertThat(cachedPositions.get(1)).isEqualTo(2);
+    assertThat(cachedPositions.get(5)).isEqualTo(6);
   }
 
-  private static void createTestFile(File file, int length) throws IOException {
+  private static void createTestFile(File file, long length) throws IOException {
     FileOutputStream output = new FileOutputStream(file);
     for (int i = 0; i < length; i++) {
       output.write(i);
@@ -145,11 +139,12 @@ private File createTestFile(String name) throws IOException {
     return file;
   }
 
-  private void assertCacheSpan(String key, long offset, long lastAccessTimestamp)
+  private void assertCacheSpan(String key, long offset, long lastTouchTimestamp)
       throws IOException {
     int id = index.assignIdForKey(key);
-    File cacheFile = createCacheSpanFile(cacheDir, id, offset, 1, lastAccessTimestamp);
-    SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
+    long cacheFileLength = 1;
+    File cacheFile = createCacheSpanFile(cacheDir, id, offset, cacheFileLength, lastTouchTimestamp);
+    SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, cacheFileLength, index);
     String message = cacheFile.toString();
     assertWithMessage(message).that(cacheSpan).isNotNull();
     assertWithMessage(message).that(cacheFile.getParentFile()).isEqualTo(cacheDir);
@@ -158,14 +153,14 @@ private void assertCacheSpan(String key, long offset, long lastAccessTimestamp)
     assertWithMessage(message).that(cacheSpan.length).isEqualTo(1);
     assertWithMessage(message).that(cacheSpan.isCached).isTrue();
     assertWithMessage(message).that(cacheSpan.file).isEqualTo(cacheFile);
-    assertWithMessage(message).that(cacheSpan.lastAccessTimestamp).isEqualTo(lastAccessTimestamp);
+    assertWithMessage(message).that(cacheSpan.lastTouchTimestamp).isEqualTo(lastTouchTimestamp);
   }
 
-  private void assertNullCacheSpan(File parent, String key, long offset,
-      long lastAccessTimestamp) {
-    File cacheFile = SimpleCacheSpan.getCacheFile(parent, index.assignIdForKey(key), offset,
-        lastAccessTimestamp);
-    CacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
+  private void assertNullCacheSpan(File parent, String key, long offset, long lastTouchTimestamp) {
+    long cacheFileLength = 0;
+    File cacheFile =
+        SimpleCacheSpan.getCacheFile(parent, index.assignIdForKey(key), offset, lastTouchTimestamp);
+    CacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, cacheFileLength, index);
     assertWithMessage(cacheFile.toString()).that(cacheSpan).isNull();
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index 15bbb8c108..da2815f09f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -21,7 +21,9 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.mockito.Mockito.doAnswer;
 
-import com.google.android.exoplayer2.C;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
@@ -37,13 +39,9 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit tests for {@link SimpleCache}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link SimpleCache}. */
+@RunWith(AndroidJUnit4.class)
 public class SimpleCacheTest {
 
   private static final String KEY_1 = "key1";
@@ -54,14 +52,43 @@
   @Before
   public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
-    cacheDir = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    cacheDir = Util.createTempFile(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
+    // Delete the file. SimpleCache initialization should create a directory with the same name.
+    assertThat(cacheDir.delete()).isTrue();
   }
 
   @After
-  public void tearDown() throws Exception {
+  public void tearDown() {
     Util.recursiveDelete(cacheDir);
   }
 
+  @Test
+  public void testCacheInitialization() {
+    SimpleCache cache = getSimpleCache();
+
+    // Cache initialization should have created a non-negative UID.
+    long uid = cache.getUid();
+    assertThat(uid).isAtLeast(0L);
+    // And the cache directory.
+    assertThat(cacheDir.exists()).isTrue();
+
+    // Reinitialization should load the same non-negative UID.
+    cache.release();
+    cache = getSimpleCache();
+    assertThat(cache.getUid()).isEqualTo(uid);
+  }
+
+  @Test
+  public void testCacheInitializationError() throws IOException {
+    // Creating a file where the cache should be will cause an error during initialization.
+    assertThat(cacheDir.createNewFile()).isTrue();
+
+    // Cache initialization should not throw an exception, but no UID will be generated.
+    SimpleCache cache = getSimpleCache();
+    long uid = cache.getUid();
+    assertThat(uid).isEqualTo(-1L);
+  }
+
   @Test
   public void testCommittingOneFile() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
@@ -75,7 +102,7 @@ public void testCommittingOneFile() throws Exception {
     NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
     assertThat(cachedSpans.isEmpty()).isTrue();
     assertThat(simpleCache.getCacheSpace()).isEqualTo(0);
-    assertThat(cacheDir.listFiles()).hasLength(0);
+    assertNoCacheFiles(cacheDir);
 
     addCache(simpleCache, KEY_1, 0, 15);
 
@@ -106,18 +133,26 @@ public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
   }
 
   @Test
-  public void testSetGetLength() throws Exception {
+  public void testSetGetContentMetadata() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
-    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(LENGTH_UNSET);
+    assertThat(ContentMetadata.getContentLength(simpleCache.getContentMetadata(KEY_1)))
+        .isEqualTo(LENGTH_UNSET);
 
-    simpleCache.setContentLength(KEY_1, 15);
-    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(15);
+    ContentMetadataMutations mutations = new ContentMetadataMutations();
+    ContentMetadataMutations.setContentLength(mutations, 15);
+    simpleCache.applyContentMetadataMutations(KEY_1, mutations);
+    assertThat(ContentMetadata.getContentLength(simpleCache.getContentMetadata(KEY_1)))
+        .isEqualTo(15);
 
     simpleCache.startReadWrite(KEY_1, 0);
     addCache(simpleCache, KEY_1, 0, 15);
-    simpleCache.setContentLength(KEY_1, 150);
-    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(150);
+
+    mutations = new ContentMetadataMutations();
+    ContentMetadataMutations.setContentLength(mutations, 150);
+    simpleCache.applyContentMetadataMutations(KEY_1, mutations);
+    assertThat(ContentMetadata.getContentLength(simpleCache.getContentMetadata(KEY_1)))
+        .isEqualTo(150);
 
     addCache(simpleCache, KEY_1, 140, 10);
 
@@ -125,14 +160,16 @@ public void testSetGetLength() throws Exception {
 
     // Check if values are kept after cache is reloaded.
     SimpleCache simpleCache2 = getSimpleCache();
-    assertThat(simpleCache2.getContentLength(KEY_1)).isEqualTo(150);
+    assertThat(ContentMetadata.getContentLength(simpleCache2.getContentMetadata(KEY_1)))
+        .isEqualTo(150);
 
     // Removing the last span shouldn't cause the length be change next time cache loaded
     SimpleCacheSpan lastSpan = simpleCache2.startReadWrite(KEY_1, 145);
     simpleCache2.removeSpan(lastSpan);
     simpleCache2.release();
     simpleCache2 = getSimpleCache();
-    assertThat(simpleCache2.getContentLength(KEY_1)).isEqualTo(150);
+    assertThat(ContentMetadata.getContentLength(simpleCache2.getContentMetadata(KEY_1)))
+        .isEqualTo(150);
   }
 
   @Test
@@ -170,7 +207,8 @@ public void testReloadCacheWithoutRelease() throws Exception {
     // Don't release the cache. This means the index file wont have been written to disk after the
     // data for KEY_2 was removed. Move the cache instead, so we can reload it without failing the
     // folder locking check.
-    File cacheDir2 = Util.createTempFile(RuntimeEnvironment.application, "ExoPlayerTest");
+    File cacheDir2 =
+        Util.createTempFile(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
     cacheDir2.delete();
     cacheDir.renameTo(cacheDir2);
 
@@ -189,7 +227,7 @@ public void testReloadCacheWithoutRelease() throws Exception {
 
   @Test
   public void testEncryptedIndex() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key = Util.getUtf8Bytes("Bar12345Bar12345"); // 128 bit key
     SimpleCache simpleCache = getEncryptedSimpleCache(key);
 
     // write data
@@ -208,7 +246,7 @@ public void testEncryptedIndex() throws Exception {
 
   @Test
   public void testEncryptedIndexWrongKey() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key = Util.getUtf8Bytes("Bar12345Bar12345"); // 128 bit key
     SimpleCache simpleCache = getEncryptedSimpleCache(key);
 
     // write data
@@ -218,17 +256,17 @@ public void testEncryptedIndexWrongKey() throws Exception {
     simpleCache.release();
 
     // Reload cache
-    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key2 = Util.getUtf8Bytes("Foo12345Foo12345"); // 128 bit key
     simpleCache = getEncryptedSimpleCache(key2);
 
     // Cache should be cleared
     assertThat(simpleCache.getKeys()).isEmpty();
-    assertThat(cacheDir.listFiles()).hasLength(0);
+    assertNoCacheFiles(cacheDir);
   }
 
   @Test
   public void testEncryptedIndexLostKey() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key = Util.getUtf8Bytes("Bar12345Bar12345"); // 128 bit key
     SimpleCache simpleCache = getEncryptedSimpleCache(key);
 
     // write data
@@ -242,7 +280,7 @@ public void testEncryptedIndexLostKey() throws Exception {
 
     // Cache should be cleared
     assertThat(simpleCache.getKeys()).isEmpty();
-    assertThat(cacheDir.listFiles()).hasLength(0);
+    assertNoCacheFiles(cacheDir);
   }
 
   @Test
@@ -283,9 +321,11 @@ public void testGetCachedLength() throws Exception {
   /* Tests https://github.com/google/ExoPlayer/issues/3260 case. */
   @Test
   public void testExceptionDuringEvictionByLeastRecentlyUsedCacheEvictorNotHang() throws Exception {
-    CachedContentIndex index = Mockito.spy(new CachedContentIndex(cacheDir));
+    CachedContentIndex contentIndex =
+        Mockito.spy(new CachedContentIndex(TestUtil.getTestDatabaseProvider()));
     SimpleCache simpleCache =
-        new SimpleCache(cacheDir, new LeastRecentlyUsedCacheEvictor(20), index);
+        new SimpleCache(
+            cacheDir, new LeastRecentlyUsedCacheEvictor(20), contentIndex, /* fileIndex= */ null);
 
     // Add some content.
     CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
@@ -296,7 +336,7 @@ public void testExceptionDuringEvictionByLeastRecentlyUsedCacheEvictorNotHang()
             invocation -> {
               throw new CacheException("SimpleCacheTest");
             })
-        .when(index)
+        .when(contentIndex)
         .store();
 
     // Adding more content will make LeastRecentlyUsedCacheEvictor evict previous content.
@@ -367,7 +407,7 @@ private static void addCache(SimpleCache simpleCache, String key, int position,
     } finally {
       fos.close();
     }
-    simpleCache.commitFile(file);
+    simpleCache.commitFile(file, length);
   }
 
   private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOException {
@@ -381,6 +421,20 @@ private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOEx
     }
   }
 
+  private static void assertNoCacheFiles(File dir) {
+    File[] files = dir.listFiles();
+    if (files == null) {
+      return;
+    }
+    for (File file : files) {
+      if (file.isDirectory()) {
+        assertNoCacheFiles(file);
+      } else {
+        assertThat(file.getName().endsWith(SimpleCacheSpan.COMMON_SUFFIX)).isFalse();
+      }
+    }
+  }
+
   private static byte[] generateData(String key, int position, int length) {
     byte[] bytes = new byte[length];
     new Random((long) (key.hashCode() ^ position)).nextBytes(bytes);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
index 40b626a7db..fde2bf5a30 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Random;
@@ -25,12 +26,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link AesFlushingCipher}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link AesFlushingCipher}. */
+@RunWith(AndroidJUnit4.class)
 public class AesFlushingCipherTest {
 
   private static final int DATA_LENGTH = 65536;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
index 4d80a9647e..c0bf459be8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
@@ -17,6 +17,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -25,13 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
-/**
- * Tests {@link AtomicFile}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests {@link AtomicFile}. */
+@RunWith(AndroidJUnit4.class)
 public final class AtomicFileTest {
 
   private File tempFolder;
@@ -40,7 +38,8 @@
 
   @Before
   public void setUp() throws Exception {
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    tempFolder =
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
     file = new File(tempFolder, "atomicFile");
     atomicFile = new AtomicFile(file);
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
index af596c35f3..0392f8b26d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
@@ -24,14 +24,12 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.graphics.Color;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for <code>ColorParser</code>.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for <code>ColorParser</code>. */
+@RunWith(AndroidJUnit4.class)
 public final class ColorParserTest {
 
   // Negative tests.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java
index c607e92055..288ad918b2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java
@@ -17,12 +17,12 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link MimeTypes}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class MimeTypesTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
index 473e5a8b05..2cc26feda3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
@@ -18,16 +18,14 @@
 import static com.google.android.exoplayer2.testutil.TestUtil.createByteArray;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link NalUnitUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link NalUnitUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class NalUnitUtilTest {
 
   private static final int TEST_PARTIAL_NAL_POSITION = 4;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
index 438643b933..e2552589fa 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
@@ -17,15 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link ParsableBitArray}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link ParsableBitArray}. */
+@RunWith(AndroidJUnit4.class)
 public final class ParsableBitArrayTest {
 
   private static final byte[] TEST_DATA = new byte[] {0x3C, (byte) 0xD2, (byte) 0x5F, (byte) 0x01,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
index 701f532d6a..7b441b83a1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
@@ -19,16 +19,14 @@
 import static java.nio.charset.Charset.forName;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link ParsableByteArray}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link ParsableByteArray}. */
+@RunWith(AndroidJUnit4.class)
 public final class ParsableByteArrayTest {
 
   private static final byte[] TEST_DATA =
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
index 210c42cfa5..3940c3d2a1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
@@ -19,14 +19,12 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link ParsableNalUnitBitArray}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests for {@link ParsableNalUnitBitArray}. */
+@RunWith(AndroidJUnit4.class)
 public final class ParsableNalUnitBitArrayTest {
 
   private static final byte[] NO_ESCAPING_TEST_DATA = createByteArray(0, 3, 0, 1, 3, 0, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
index 4daa29afd0..77f59962d0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
@@ -17,15 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.ByteArrayOutputStream;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests {@link ReusableBufferedOutputStream}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Tests {@link ReusableBufferedOutputStream}. */
+@RunWith(AndroidJUnit4.class)
 public final class ReusableBufferedOutputStreamTest {
 
   private static final byte[] TEST_DATA_1 = Util.getUtf8Bytes("test data 1");
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java
index ca34bc3216..f21e15a0ed 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/TimedValueQueueTest.java
@@ -17,13 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link TimedValueQueue}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class TimedValueQueueTest {
 
   private TimedValueQueue<String> queue;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
index 82c62ecb3e..95d8a6b9a0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
@@ -20,14 +20,12 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link UriUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link UriUtil}. */
+@RunWith(AndroidJUnit4.class)
 public final class UriUtilTest {
 
   /**
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
index baf8aa7c40..9abec0cd8f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -24,6 +24,7 @@
 import static com.google.android.exoplayer2.util.Util.unescapeFileName;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.util.ArrayList;
@@ -33,12 +34,10 @@
 import java.util.zip.Deflater;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-/**
- * Unit tests for {@link Util}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit tests for {@link Util}. */
+@RunWith(AndroidJUnit4.class)
 public class UtilTest {
 
   @Test
@@ -266,6 +265,31 @@ public void testInflate() {
     assertThat(Arrays.copyOf(output.data, output.limit())).isEqualTo(testData);
   }
 
+  @Test
+  @Config(sdk = 21)
+  public void testNormalizeLanguageCodeV21() {
+    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("spa");
+    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("spa");
+    assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("spa-ar");
+    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("spa-ar");
+    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("spa-ar-dialect");
+    assertThat(Util.normalizeLanguageCode("es-419")).isEqualTo("spa-419");
+    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zho-hans-tw");
+    assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zho-tw");
+    assertThat(Util.normalizeLanguageCode("und")).isEqualTo("und");
+    assertThat(Util.normalizeLanguageCode("DoesNotExist")).isEqualTo("doesnotexist");
+  }
+
+  @Test
+  @Config(sdk = 16)
+  public void testNormalizeLanguageCode() {
+    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("spa");
+    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("spa");
+    assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("und")).isEqualTo("und");
+    assertThat(Util.normalizeLanguageCode("DoesNotExist")).isEqualTo("doesnotexist");
+  }
+
   private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
     assertThat(escapeFileName(fileName)).isEqualTo(escapedFileName);
     assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
@@ -275,5 +299,4 @@ private static void assertEscapeUnescapeFileName(String fileName) {
     String escapedFileName = Util.escapeFileName(fileName);
     assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java
index 071cd582d5..887c8da09f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/FrameRotationQueueTest.java
@@ -18,13 +18,13 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.opengl.Matrix;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests {@link FrameRotationQueue}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class FrameRotationQueueTest {
 
   private FrameRotationQueue frameRotationQueue;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java
index af1a8421b4..1dadfe9909 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionDecoderTest.java
@@ -17,16 +17,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import junit.framework.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link ProjectionDecoder}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class ProjectionDecoderTest {
 
   private static final byte[] PROJ_DATA =
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java
index 0e2d0999fb..8add0eac61 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/video/spherical/ProjectionTest.java
@@ -19,13 +19,13 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link Projection}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class ProjectionTest {
   private static final float EPSILON = .00001f;
 
diff --git a/library/core/src/test/resources/robolectric.properties b/library/core/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/library/core/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/library/dash/README.md b/library/dash/README.md
index 394a38a332..7831033b99 100644
--- a/library/dash/README.md
+++ b/library/dash/README.md
@@ -9,4 +9,4 @@ play DASH content, instantiate a `DashMediaSource` and pass it to
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.source.dash.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/dash/build.gradle b/library/dash/build.gradle
index 40b014aaf9..f6981a2220 100644
--- a/library/dash/build.gradle
+++ b/library/dash/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -26,7 +25,6 @@ android {
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
@@ -36,12 +34,14 @@ android {
         //    testCoverageEnabled = true
         // }
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/library/dash/proguard-rules.txt b/library/dash/proguard-rules.txt
deleted file mode 100644
index f8725fff4d..0000000000
--- a/library/dash/proguard-rules.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-# Proguard rules specific to the dash module.
-
-# Constructors accessed via reflection in SegmentDownloadAction
--dontnote com.google.android.exoplayer2.source.dash.offline.DashDownloadAction
--keepclassmembers class com.google.android.exoplayer2.source.dash.offline.DashDownloadAction {
-  static ** DESERIALIZER;
-}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
index c6cdc88f2f..40d4e468bd 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
@@ -16,13 +16,15 @@
 package com.google.android.exoplayer2.source.dash;
 
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
 import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerTrackEmsgHandler;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.TransferListener;
+import java.util.List;
 
 /**
  * An {@link ChunkSource} for DASH streams.
@@ -41,10 +43,8 @@
      * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
      *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds,
      *     specified as the server's unix time minus the local elapsed time. If unknown, set to 0.
-     * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
-     *     message track.
-     * @param enableCea608Track Whether the chunks generated by the source may output a CEA-608
-     *     track.
+     * @param enableEventMessageTrack Whether to output an event message track.
+     * @param closedCaptionFormats The {@link Format Formats} of closed caption tracks to be output.
      * @param transferListener The transfer listener which should be informed of any data transfers.
      *     May be null if no listener is available.
      * @return The created {@link DashChunkSource}.
@@ -58,7 +58,7 @@ DashChunkSource createDashChunkSource(
         int type,
         long elapsedRealtimeOffsetMs,
         boolean enableEventMessageTrack,
-        boolean enableCea608Track,
+        List<Format> closedCaptionFormats,
         @Nullable PlayerTrackEmsgHandler playerEmsgHandler,
         @Nullable TransferListener transferListener);
   }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index 5c9a933508..431a0a4bd9 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer2.source.dash;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.util.Pair;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
@@ -46,6 +47,7 @@
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -54,6 +56,8 @@
 import java.util.Arrays;
 import java.util.IdentityHashMap;
 import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /** A DASH {@link MediaPeriod}. */
 /* package */ final class DashMediaPeriod
@@ -61,11 +65,13 @@
         SequenceableLoader.Callback<ChunkSampleStream<DashChunkSource>>,
         ChunkSampleStream.ReleaseCallback<DashChunkSource> {
 
+  private static final Pattern CEA608_SERVICE_DESCRIPTOR_REGEX = Pattern.compile("CC([1-4])=(.+)");
+
   /* package */ final int id;
   private final DashChunkSource.Factory chunkSourceFactory;
   private final @Nullable TransferListener transferListener;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
-  private final long elapsedRealtimeOffset;
+  private final long elapsedRealtimeOffsetMs;
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
@@ -93,7 +99,7 @@ public DashMediaPeriod(
       @Nullable TransferListener transferListener,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       EventDispatcher eventDispatcher,
-      long elapsedRealtimeOffset,
+      long elapsedRealtimeOffsetMs,
       LoaderErrorThrower manifestLoaderErrorThrower,
       Allocator allocator,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
@@ -105,7 +111,7 @@ public DashMediaPeriod(
     this.transferListener = transferListener;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
-    this.elapsedRealtimeOffset = elapsedRealtimeOffset;
+    this.elapsedRealtimeOffsetMs = elapsedRealtimeOffsetMs;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
@@ -191,6 +197,49 @@ public TrackGroupArray getTrackGroups() {
     return trackGroups;
   }
 
+  @Override
+  public List<StreamKey> getStreamKeys(List<TrackSelection> trackSelections) {
+    List<AdaptationSet> manifestAdaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
+    List<StreamKey> streamKeys = new ArrayList<>();
+    for (TrackSelection trackSelection : trackSelections) {
+      int trackGroupIndex = trackGroups.indexOf(trackSelection.getTrackGroup());
+      TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
+      if (trackGroupInfo.trackGroupCategory != TrackGroupInfo.CATEGORY_PRIMARY) {
+        // Ignore non-primary tracks.
+        continue;
+      }
+      int[] adaptationSetIndices = trackGroupInfo.adaptationSetIndices;
+      int[] trackIndices = new int[trackSelection.length()];
+      for (int i = 0; i < trackSelection.length(); i++) {
+        trackIndices[i] = trackSelection.getIndexInTrackGroup(i);
+      }
+      Arrays.sort(trackIndices);
+
+      int currentAdaptationSetIndex = 0;
+      int totalTracksInPreviousAdaptationSets = 0;
+      int tracksInCurrentAdaptationSet =
+          manifestAdaptationSets.get(adaptationSetIndices[0]).representations.size();
+      for (int i = 0; i < trackIndices.length; i++) {
+        while (trackIndices[i]
+            >= totalTracksInPreviousAdaptationSets + tracksInCurrentAdaptationSet) {
+          currentAdaptationSetIndex++;
+          totalTracksInPreviousAdaptationSets += tracksInCurrentAdaptationSet;
+          tracksInCurrentAdaptationSet =
+              manifestAdaptationSets
+                  .get(adaptationSetIndices[currentAdaptationSetIndex])
+                  .representations
+                  .size();
+        }
+        streamKeys.add(
+            new StreamKey(
+                periodIndex,
+                adaptationSetIndices[currentAdaptationSetIndex],
+                trackIndices[i] - totalTracksInPreviousAdaptationSets));
+      }
+    }
+    return streamKeys;
+  }
+
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
@@ -412,18 +461,28 @@ private int getPrimaryStreamIndex(int embeddedStreamIndex, int[] streamIndexToTr
 
     int primaryGroupCount = groupedAdaptationSetIndices.length;
     boolean[] primaryGroupHasEventMessageTrackFlags = new boolean[primaryGroupCount];
-    boolean[] primaryGroupHasCea608TrackFlags = new boolean[primaryGroupCount];
-    int totalEmbeddedTrackGroupCount = identifyEmbeddedTracks(primaryGroupCount, adaptationSets,
-        groupedAdaptationSetIndices, primaryGroupHasEventMessageTrackFlags,
-        primaryGroupHasCea608TrackFlags);
+    Format[][] primaryGroupCea608TrackFormats = new Format[primaryGroupCount][];
+    int totalEmbeddedTrackGroupCount =
+        identifyEmbeddedTracks(
+            primaryGroupCount,
+            adaptationSets,
+            groupedAdaptationSetIndices,
+            primaryGroupHasEventMessageTrackFlags,
+            primaryGroupCea608TrackFormats);
 
     int totalGroupCount = primaryGroupCount + totalEmbeddedTrackGroupCount + eventStreams.size();
     TrackGroup[] trackGroups = new TrackGroup[totalGroupCount];
     TrackGroupInfo[] trackGroupInfos = new TrackGroupInfo[totalGroupCount];
 
-    int trackGroupCount = buildPrimaryAndEmbeddedTrackGroupInfos(adaptationSets,
-        groupedAdaptationSetIndices, primaryGroupCount, primaryGroupHasEventMessageTrackFlags,
-        primaryGroupHasCea608TrackFlags, trackGroups, trackGroupInfos);
+    int trackGroupCount =
+        buildPrimaryAndEmbeddedTrackGroupInfos(
+            adaptationSets,
+            groupedAdaptationSetIndices,
+            primaryGroupCount,
+            primaryGroupHasEventMessageTrackFlags,
+            primaryGroupCea608TrackFormats,
+            trackGroups,
+            trackGroupInfos);
 
     buildManifestEventTrackGroupInfos(eventStreams, trackGroups, trackGroupInfos, trackGroupCount);
 
@@ -452,13 +511,22 @@ private int getPrimaryStreamIndex(int embeddedStreamIndex, int[] streamIndexToTr
       if (adaptationSetSwitchingProperty == null) {
         groupedAdaptationSetIndices[groupCount++] = new int[] {i};
       } else {
-        String[] extraAdaptationSetIds = adaptationSetSwitchingProperty.value.split(",");
+        String[] extraAdaptationSetIds = Util.split(adaptationSetSwitchingProperty.value, ",");
         int[] adaptationSetIndices = new int[1 + extraAdaptationSetIds.length];
         adaptationSetIndices[0] = i;
+        int outputIndex = 1;
         for (int j = 0; j < extraAdaptationSetIds.length; j++) {
-          int extraIndex = idToIndexMap.get(Integer.parseInt(extraAdaptationSetIds[j]));
-          adaptationSetUsedFlags[extraIndex] = true;
-          adaptationSetIndices[1 + j] = extraIndex;
+          int extraIndex =
+              idToIndexMap.get(
+                  Integer.parseInt(extraAdaptationSetIds[j]), /* valueIfKeyNotFound= */ -1);
+          if (extraIndex != -1) {
+            adaptationSetUsedFlags[extraIndex] = true;
+            adaptationSetIndices[outputIndex] = extraIndex;
+            outputIndex++;
+          }
+        }
+        if (outputIndex < adaptationSetIndices.length) {
+          adaptationSetIndices = Arrays.copyOf(adaptationSetIndices, outputIndex);
         }
         groupedAdaptationSetIndices[groupCount++] = adaptationSetIndices;
       }
@@ -470,39 +538,46 @@ private int getPrimaryStreamIndex(int embeddedStreamIndex, int[] streamIndexToTr
 
   /**
    * Iterates through list of primary track groups and identifies embedded tracks.
-   * <p>
+   *
    * @param primaryGroupCount The number of primary track groups.
    * @param adaptationSets The list of {@link AdaptationSet} of the current DASH period.
-   * @param groupedAdaptationSetIndices The indices of {@link AdaptationSet} that belongs to
-   *     the same primary group, grouped in primary track groups order.
-   * @param primaryGroupHasEventMessageTrackFlags An output array containing boolean flag, each
-   *     indicates whether the corresponding primary track group contains an embedded event message
-   *     track.
-   * @param primaryGroupHasCea608TrackFlags An output array containing boolean flag, each
-   *     indicates whether the corresponding primary track group contains an embedded Cea608 track.
-   * @return Total number of embedded tracks.
+   * @param groupedAdaptationSetIndices The indices of {@link AdaptationSet} that belongs to the
+   *     same primary group, grouped in primary track groups order.
+   * @param primaryGroupHasEventMessageTrackFlags An output array to be filled with flags indicating
+   *     whether each of the primary track groups contains an embedded event message track.
+   * @param primaryGroupCea608TrackFormats An output array to be filled with track formats for
+   *     CEA-608 tracks embedded in each of the primary track groups.
+   * @return Total number of embedded track groups.
    */
-  private static int identifyEmbeddedTracks(int primaryGroupCount,
-      List<AdaptationSet> adaptationSets, int[][] groupedAdaptationSetIndices,
-      boolean[] primaryGroupHasEventMessageTrackFlags, boolean[] primaryGroupHasCea608TrackFlags) {
-    int numEmbeddedTrack = 0;
+  private static int identifyEmbeddedTracks(
+      int primaryGroupCount,
+      List<AdaptationSet> adaptationSets,
+      int[][] groupedAdaptationSetIndices,
+      boolean[] primaryGroupHasEventMessageTrackFlags,
+      Format[][] primaryGroupCea608TrackFormats) {
+    int numEmbeddedTrackGroups = 0;
     for (int i = 0; i < primaryGroupCount; i++) {
       if (hasEventMessageTrack(adaptationSets, groupedAdaptationSetIndices[i])) {
         primaryGroupHasEventMessageTrackFlags[i] = true;
-        numEmbeddedTrack++;
+        numEmbeddedTrackGroups++;
       }
-      if (hasCea608Track(adaptationSets, groupedAdaptationSetIndices[i])) {
-        primaryGroupHasCea608TrackFlags[i] = true;
-        numEmbeddedTrack++;
+      primaryGroupCea608TrackFormats[i] =
+          getCea608TrackFormats(adaptationSets, groupedAdaptationSetIndices[i]);
+      if (primaryGroupCea608TrackFormats[i].length != 0) {
+        numEmbeddedTrackGroups++;
       }
     }
-    return numEmbeddedTrack;
+    return numEmbeddedTrackGroups;
   }
 
-  private static int buildPrimaryAndEmbeddedTrackGroupInfos(List<AdaptationSet> adaptationSets,
-      int[][] groupedAdaptationSetIndices, int primaryGroupCount,
-      boolean[] primaryGroupHasEventMessageTrackFlags, boolean[] primaryGroupHasCea608TrackFlags,
-      TrackGroup[] trackGroups, TrackGroupInfo[] trackGroupInfos) {
+  private static int buildPrimaryAndEmbeddedTrackGroupInfos(
+      List<AdaptationSet> adaptationSets,
+      int[][] groupedAdaptationSetIndices,
+      int primaryGroupCount,
+      boolean[] primaryGroupHasEventMessageTrackFlags,
+      Format[][] primaryGroupCea608TrackFormats,
+      TrackGroup[] trackGroups,
+      TrackGroupInfo[] trackGroupInfos) {
     int trackGroupCount = 0;
     for (int i = 0; i < primaryGroupCount; i++) {
       int[] adaptationSetIndices = groupedAdaptationSetIndices[i];
@@ -520,7 +595,7 @@ private static int buildPrimaryAndEmbeddedTrackGroupInfos(List<AdaptationSet> ad
       int eventMessageTrackGroupIndex =
           primaryGroupHasEventMessageTrackFlags[i] ? trackGroupCount++ : C.INDEX_UNSET;
       int cea608TrackGroupIndex =
-          primaryGroupHasCea608TrackFlags[i] ? trackGroupCount++ : C.INDEX_UNSET;
+          primaryGroupCea608TrackFormats[i].length != 0 ? trackGroupCount++ : C.INDEX_UNSET;
 
       trackGroups[primaryTrackGroupIndex] = new TrackGroup(formats);
       trackGroupInfos[primaryTrackGroupIndex] =
@@ -538,9 +613,7 @@ private static int buildPrimaryAndEmbeddedTrackGroupInfos(List<AdaptationSet> ad
             TrackGroupInfo.embeddedEmsgTrack(adaptationSetIndices, primaryTrackGroupIndex);
       }
       if (cea608TrackGroupIndex != C.INDEX_UNSET) {
-        Format format = Format.createTextSampleFormat(firstAdaptationSet.id + ":cea608",
-            MimeTypes.APPLICATION_CEA608, 0, null);
-        trackGroups[cea608TrackGroupIndex] = new TrackGroup(format);
+        trackGroups[cea608TrackGroupIndex] = new TrackGroup(primaryGroupCea608TrackFormats[i]);
         trackGroupInfos[cea608TrackGroupIndex] =
             TrackGroupInfo.embeddedCea608Track(adaptationSetIndices, primaryTrackGroupIndex);
       }
@@ -562,25 +635,39 @@ private static void buildManifestEventTrackGroupInfos(List<EventStream> eventStr
   private ChunkSampleStream<DashChunkSource> buildSampleStream(TrackGroupInfo trackGroupInfo,
       TrackSelection selection, long positionUs) {
     int embeddedTrackCount = 0;
-    int[] embeddedTrackTypes = new int[2];
-    Format[] embeddedTrackFormats = new Format[2];
     boolean enableEventMessageTrack =
         trackGroupInfo.embeddedEventMessageTrackGroupIndex != C.INDEX_UNSET;
+    TrackGroup embeddedEventMessageTrackGroup = null;
     if (enableEventMessageTrack) {
-      embeddedTrackFormats[embeddedTrackCount] =
-          trackGroups.get(trackGroupInfo.embeddedEventMessageTrackGroupIndex).getFormat(0);
-      embeddedTrackTypes[embeddedTrackCount++] = C.TRACK_TYPE_METADATA;
+      embeddedEventMessageTrackGroup =
+          trackGroups.get(trackGroupInfo.embeddedEventMessageTrackGroupIndex);
+      embeddedTrackCount++;
     }
-    boolean enableCea608Track = trackGroupInfo.embeddedCea608TrackGroupIndex != C.INDEX_UNSET;
-    if (enableCea608Track) {
-      embeddedTrackFormats[embeddedTrackCount] =
-          trackGroups.get(trackGroupInfo.embeddedCea608TrackGroupIndex).getFormat(0);
-      embeddedTrackTypes[embeddedTrackCount++] = C.TRACK_TYPE_TEXT;
+    boolean enableCea608Tracks = trackGroupInfo.embeddedCea608TrackGroupIndex != C.INDEX_UNSET;
+    TrackGroup embeddedCea608TrackGroup = null;
+    if (enableCea608Tracks) {
+      embeddedCea608TrackGroup = trackGroups.get(trackGroupInfo.embeddedCea608TrackGroupIndex);
+      embeddedTrackCount += embeddedCea608TrackGroup.length;
     }
-    if (embeddedTrackCount < embeddedTrackTypes.length) {
-      embeddedTrackFormats = Arrays.copyOf(embeddedTrackFormats, embeddedTrackCount);
-      embeddedTrackTypes = Arrays.copyOf(embeddedTrackTypes, embeddedTrackCount);
+
+    Format[] embeddedTrackFormats = new Format[embeddedTrackCount];
+    int[] embeddedTrackTypes = new int[embeddedTrackCount];
+    embeddedTrackCount = 0;
+    if (enableEventMessageTrack) {
+      embeddedTrackFormats[embeddedTrackCount] = embeddedEventMessageTrackGroup.getFormat(0);
+      embeddedTrackTypes[embeddedTrackCount] = C.TRACK_TYPE_METADATA;
+      embeddedTrackCount++;
+    }
+    List<Format> embeddedCea608TrackFormats = new ArrayList<>();
+    if (enableCea608Tracks) {
+      for (int i = 0; i < embeddedCea608TrackGroup.length; i++) {
+        embeddedTrackFormats[embeddedTrackCount] = embeddedCea608TrackGroup.getFormat(i);
+        embeddedTrackTypes[embeddedTrackCount] = C.TRACK_TYPE_TEXT;
+        embeddedCea608TrackFormats.add(embeddedTrackFormats[embeddedTrackCount]);
+        embeddedTrackCount++;
+      }
     }
+
     PlayerTrackEmsgHandler trackPlayerEmsgHandler =
         manifest.dynamic && enableEventMessageTrack
             ? playerEmsgHandler.newPlayerTrackEmsgHandler()
@@ -593,9 +680,9 @@ private static void buildManifestEventTrackGroupInfos(List<EventStream> eventStr
             trackGroupInfo.adaptationSetIndices,
             selection,
             trackGroupInfo.trackType,
-            elapsedRealtimeOffset,
+            elapsedRealtimeOffsetMs,
             enableEventMessageTrack,
-            enableCea608Track,
+            embeddedCea608TrackFormats,
             trackPlayerEmsgHandler,
             transferListener);
     ChunkSampleStream<DashChunkSource> stream =
@@ -640,18 +727,60 @@ private static boolean hasEventMessageTrack(List<AdaptationSet> adaptationSets,
     return false;
   }
 
-  private static boolean hasCea608Track(List<AdaptationSet> adaptationSets,
-      int[] adaptationSetIndices) {
+  private static Format[] getCea608TrackFormats(
+      List<AdaptationSet> adaptationSets, int[] adaptationSetIndices) {
     for (int i : adaptationSetIndices) {
+      AdaptationSet adaptationSet = adaptationSets.get(i);
       List<Descriptor> descriptors = adaptationSets.get(i).accessibilityDescriptors;
       for (int j = 0; j < descriptors.size(); j++) {
         Descriptor descriptor = descriptors.get(j);
         if ("urn:scte:dash:cc:cea-608:2015".equals(descriptor.schemeIdUri)) {
-          return true;
+          String value = descriptor.value;
+          if (value == null) {
+            // There are embedded CEA-608 tracks, but service information is not declared.
+            return new Format[] {buildCea608TrackFormat(adaptationSet.id)};
+          }
+          String[] services = Util.split(value, ";");
+          Format[] formats = new Format[services.length];
+          for (int k = 0; k < services.length; k++) {
+            Matcher matcher = CEA608_SERVICE_DESCRIPTOR_REGEX.matcher(services[k]);
+            if (!matcher.matches()) {
+              // If we can't parse service information for all services, assume a single track.
+              return new Format[] {buildCea608TrackFormat(adaptationSet.id)};
+            }
+            formats[k] =
+                buildCea608TrackFormat(
+                    adaptationSet.id,
+                    /* language= */ matcher.group(2),
+                    /* accessibilityChannel= */ Integer.parseInt(matcher.group(1)));
+          }
+          return formats;
         }
       }
     }
-    return false;
+    return new Format[0];
+  }
+
+  private static Format buildCea608TrackFormat(int adaptationSetId) {
+    return buildCea608TrackFormat(
+        adaptationSetId, /* language= */ null, /* accessibilityChannel= */ Format.NO_VALUE);
+  }
+
+  private static Format buildCea608TrackFormat(
+      int adaptationSetId, String language, int accessibilityChannel) {
+    return Format.createTextSampleFormat(
+        adaptationSetId
+            + ":cea608"
+            + (accessibilityChannel != Format.NO_VALUE ? ":" + accessibilityChannel : ""),
+        MimeTypes.APPLICATION_CEA608,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* selectionFlags= */ 0,
+        language,
+        accessibilityChannel,
+        /* drmInitData= */ null,
+        Format.OFFSET_SAMPLE_RELATIVE,
+        /* initializationData= */ null);
   }
 
   @SuppressWarnings("unchecked")
@@ -687,7 +816,7 @@ private static boolean hasCea608Track(List<AdaptationSet> adaptationSets,
 
     public final int[] adaptationSetIndices;
     public final int trackType;
-    public @TrackGroupCategory final int trackGroupCategory;
+    @TrackGroupCategory public final int trackGroupCategory;
 
     public final int eventStreamGroupIndex;
     public final int primaryTrackGroupIndex;
@@ -707,7 +836,7 @@ public static TrackGroupInfo primaryTrack(
           primaryTrackGroupIndex,
           embeddedEventMessageTrackGroupIndex,
           embeddedCea608TrackGroupIndex,
-          -1);
+          /* eventStreamGroupIndex= */ -1);
     }
 
     public static TrackGroupInfo embeddedEmsgTrack(int[] adaptationSetIndices,
@@ -719,7 +848,7 @@ public static TrackGroupInfo embeddedEmsgTrack(int[] adaptationSetIndices,
           primaryTrackGroupIndex,
           C.INDEX_UNSET,
           C.INDEX_UNSET,
-          -1);
+          /* eventStreamGroupIndex= */ -1);
     }
 
     public static TrackGroupInfo embeddedCea608Track(int[] adaptationSetIndices,
@@ -731,15 +860,15 @@ public static TrackGroupInfo embeddedCea608Track(int[] adaptationSetIndices,
           primaryTrackGroupIndex,
           C.INDEX_UNSET,
           C.INDEX_UNSET,
-          -1);
+          /* eventStreamGroupIndex= */ -1);
     }
 
     public static TrackGroupInfo mpdEventTrack(int eventStreamIndex) {
       return new TrackGroupInfo(
           C.TRACK_TYPE_METADATA,
           CATEGORY_MANIFEST_EVENTS,
-          null,
-          -1,
+          new int[0],
+          /* primaryTrackGroupIndex= */ -1,
           C.INDEX_UNSET,
           C.INDEX_UNSET,
           eventStreamIndex);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index c8de8f02b1..cdc32553f3 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -18,14 +18,15 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.offline.FilteringManifestParser;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.BaseMediaSource;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.DefaultCompositeSequenceableLoaderFactory;
@@ -59,6 +60,7 @@
 import java.nio.charset.Charset;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
+import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.regex.Matcher;
@@ -75,15 +77,16 @@
   public static final class Factory implements AdsMediaSource.MediaSourceFactory {
 
     private final DashChunkSource.Factory chunkSourceFactory;
-    private final @Nullable DataSource.Factory manifestDataSourceFactory;
+    @Nullable private final DataSource.Factory manifestDataSourceFactory;
 
-    private @Nullable ParsingLoadable.Parser<? extends DashManifest> manifestParser;
+    @Nullable private ParsingLoadable.Parser<? extends DashManifest> manifestParser;
+    @Nullable private List<StreamKey> streamKeys;
     private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
     private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private long livePresentationDelayMs;
     private boolean livePresentationDelayOverridesManifest;
     private boolean isCreateCalled;
-    private @Nullable Object tag;
+    @Nullable private Object tag;
 
     /**
      * Creates a new factory for {@link DashMediaSource}s.
@@ -210,6 +213,19 @@ public Factory setManifestParser(
       return this;
     }
 
+    /**
+     * Sets a list of {@link StreamKey stream keys} by which the manifest is filtered.
+     *
+     * @param streamKeys A list of {@link StreamKey stream keys}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setStreamKeys(List<StreamKey> streamKeys) {
+      Assertions.checkState(!isCreateCalled);
+      this.streamKeys = streamKeys;
+      return this;
+    }
+
     /**
      * Sets the factory to create composite {@link SequenceableLoader}s for when this media source
      * loads data from multiple streams (video, audio etc...). The default is an instance of {@link
@@ -240,6 +256,9 @@ public Factory setCompositeSequenceableLoaderFactory(
     public DashMediaSource createMediaSource(DashManifest manifest) {
       Assertions.checkArgument(!manifest.dynamic);
       isCreateCalled = true;
+      if (streamKeys != null && !streamKeys.isEmpty()) {
+        manifest = manifest.copy(streamKeys);
+      }
       return new DashMediaSource(
           manifest,
           /* manifestUri= */ null,
@@ -281,6 +300,9 @@ public DashMediaSource createMediaSource(Uri manifestUri) {
       if (manifestParser == null) {
         manifestParser = new DashManifestParser();
       }
+      if (streamKeys != null) {
+        manifestParser = new FilteringManifestParser<>(manifestParser, streamKeys);
+      }
       return new DashMediaSource(
           /* manifest= */ null,
           Assertions.checkNotNull(manifestUri),
@@ -614,10 +636,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     if (sideloadedManifest) {
       processManifest(false);
@@ -635,7 +654,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId periodId, Allocator allocator) {
+  public MediaPeriod createPeriod(
+      MediaPeriodId periodId, Allocator allocator, long startPositionUs) {
     int periodIndex = (Integer) periodId.periodUid - firstPeriodId;
     EventDispatcher periodEventDispatcher =
         createEventDispatcher(periodId, manifest.getPeriod(periodIndex).startMs);
@@ -716,17 +736,17 @@ public void releaseSourceInternal() {
         loadable.bytesLoaded());
     DashManifest newManifest = loadable.getResult();
 
-    int periodCount = manifest == null ? 0 : manifest.getPeriodCount();
+    int oldPeriodCount = manifest == null ? 0 : manifest.getPeriodCount();
     int removedPeriodCount = 0;
     long newFirstPeriodStartTimeMs = newManifest.getPeriod(0).startMs;
-    while (removedPeriodCount < periodCount
+    while (removedPeriodCount < oldPeriodCount
         && manifest.getPeriod(removedPeriodCount).startMs < newFirstPeriodStartTimeMs) {
       removedPeriodCount++;
     }
 
     if (newManifest.dynamic) {
       boolean isManifestStale = false;
-      if (periodCount - removedPeriodCount > newManifest.getPeriodCount()) {
+      if (oldPeriodCount - removedPeriodCount > newManifest.getPeriodCount()) {
         // After discarding old periods, we should never have more periods than listed in the new
         // manifest. That would mean that a previously announced period is no longer advertised. If
         // this condition occurs, assume that we are hitting a manifest server that is out of sync
@@ -776,8 +796,8 @@ public void releaseSourceInternal() {
       }
     }
 
-    if (periodCount == 0) {
-      if (manifest.utcTiming != null) {
+    if (oldPeriodCount == 0) {
+      if (manifest.dynamic && manifest.utcTiming != null) {
         resolveUtcTimingElement(manifest.utcTiming);
       } else {
         processManifest(true);
@@ -792,8 +812,15 @@ public void releaseSourceInternal() {
       ParsingLoadable<DashManifest> loadable,
       long elapsedRealtimeMs,
       long loadDurationMs,
-      IOException error) {
-    boolean isFatal = error instanceof ParserException;
+      IOException error,
+      int errorCount) {
+    long retryDelayMs =
+        loadErrorHandlingPolicy.getRetryDelayMsFor(
+            C.DATA_TYPE_MANIFEST, loadDurationMs, error, errorCount);
+    LoadErrorAction loadErrorAction =
+        retryDelayMs == C.TIME_UNSET
+            ? Loader.DONT_RETRY_FATAL
+            : Loader.createRetryAction(/* resetErrorCount= */ false, retryDelayMs);
     manifestEventDispatcher.loadError(
         loadable.dataSpec,
         loadable.getUri(),
@@ -803,8 +830,8 @@ public void releaseSourceInternal() {
         loadDurationMs,
         loadable.bytesLoaded(),
         error,
-        isFatal);
-    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
+        !loadErrorAction.isRetry());
+    return loadErrorAction;
   }
 
   /* package */ void onUtcTimestampLoadCompleted(ParsingLoadable<Long> loadable,
@@ -1276,7 +1303,7 @@ public LoadErrorAction onLoadError(
         long loadDurationMs,
         IOException error,
         int errorCount) {
-      return onManifestLoadError(loadable, elapsedRealtimeMs, loadDurationMs, error);
+      return onManifestLoadError(loadable, elapsedRealtimeMs, loadDurationMs, error, errorCount);
     }
 
   }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
index 743462bd89..6a6e08ce1d 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.dash;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 5e20fb769c..057f0262d0 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -17,8 +17,8 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
-import android.support.annotation.CheckResult;
-import android.support.annotation.Nullable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
@@ -54,7 +54,6 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -86,7 +85,7 @@ public DashChunkSource createDashChunkSource(
         int trackType,
         long elapsedRealtimeOffsetMs,
         boolean enableEventMessageTrack,
-        boolean enableCea608Track,
+        List<Format> closedCaptionFormats,
         @Nullable PlayerTrackEmsgHandler playerEmsgHandler,
         @Nullable TransferListener transferListener) {
       DataSource dataSource = dataSourceFactory.createDataSource();
@@ -104,7 +103,7 @@ public DashChunkSource createDashChunkSource(
           elapsedRealtimeOffsetMs,
           maxSegmentsPerLoad,
           enableEventMessageTrack,
-          enableCea608Track,
+          closedCaptionFormats,
           playerEmsgHandler);
     }
 
@@ -141,9 +140,8 @@ public DashChunkSource createDashChunkSource(
    * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request. Note
    *     that segments will only be combined if their {@link Uri}s are the same and if their data
    *     ranges are adjacent.
-   * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
-   *     message track.
-   * @param enableCea608Track Whether the chunks generated by the source may output a CEA-608 track.
+   * @param enableEventMessageTrack Whether to output an event message track.
+   * @param closedCaptionFormats The {@link Format Formats} of closed caption tracks to be output.
    * @param playerTrackEmsgHandler The {@link PlayerTrackEmsgHandler} instance to handle emsg
    *     messages targeting the player. Maybe null if this is not necessary.
    */
@@ -158,7 +156,7 @@ public DefaultDashChunkSource(
       long elapsedRealtimeOffsetMs,
       int maxSegmentsPerLoad,
       boolean enableEventMessageTrack,
-      boolean enableCea608Track,
+      List<Format> closedCaptionFormats,
       @Nullable PlayerTrackEmsgHandler playerTrackEmsgHandler) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
@@ -184,7 +182,7 @@ public DefaultDashChunkSource(
               trackType,
               representation,
               enableEventMessageTrack,
-              enableCea608Track,
+              closedCaptionFormats,
               playerTrackEmsgHandler);
     }
   }
@@ -457,10 +455,10 @@ private long getSegmentNum(
   }
 
   private ArrayList<Representation> getRepresentations() {
-    List<AdaptationSet> manifestAdapationSets = manifest.getPeriod(periodIndex).adaptationSets;
+    List<AdaptationSet> manifestAdaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
     ArrayList<Representation> representations = new ArrayList<>();
     for (int adaptationSetIndex : adaptationSetIndices) {
-      representations.addAll(manifestAdapationSets.get(adaptationSetIndex).representations);
+      representations.addAll(manifestAdaptationSets.get(adaptationSetIndex).representations);
     }
     return representations;
   }
@@ -579,12 +577,14 @@ protected Chunk newMediaChunk(
      * Creates iterator.
      *
      * @param representation The {@link RepresentationHolder} to wrap.
-     * @param segmentNum The number of the segment this iterator will be pointing to initially.
+     * @param firstAvailableSegmentNum The number of the first available segment.
      * @param lastAvailableSegmentNum The number of the last available segment.
      */
     public RepresentationSegmentIterator(
-        RepresentationHolder representation, long segmentNum, long lastAvailableSegmentNum) {
-      super(/* fromIndex= */ segmentNum, /* toIndex= */ lastAvailableSegmentNum);
+        RepresentationHolder representation,
+        long firstAvailableSegmentNum,
+        long lastAvailableSegmentNum) {
+      super(/* fromIndex= */ firstAvailableSegmentNum, /* toIndex= */ lastAvailableSegmentNum);
       this.representationHolder = representation;
     }
 
@@ -627,7 +627,7 @@ public long getChunkEndTimeUs() {
         int trackType,
         Representation representation,
         boolean enableEventMessageTrack,
-        boolean enableCea608Track,
+        List<Format> closedCaptionFormats,
         TrackOutput playerEmsgTrackOutput) {
       this(
           periodDurationUs,
@@ -636,7 +636,7 @@ public long getChunkEndTimeUs() {
               trackType,
               representation,
               enableEventMessageTrack,
-              enableCea608Track,
+              closedCaptionFormats,
               playerEmsgTrackOutput),
           /* segmentNumShift= */ 0,
           representation.getIndex());
@@ -781,7 +781,7 @@ private static boolean mimeTypeIsRawText(String mimeType) {
         int trackType,
         Representation representation,
         boolean enableEventMessageTrack,
-        boolean enableCea608Track,
+        List<Format> closedCaptionFormats,
         TrackOutput playerEmsgTrackOutput) {
       String containerMimeType = representation.format.containerMimeType;
       if (mimeTypeIsRawText(containerMimeType)) {
@@ -797,12 +797,6 @@ private static boolean mimeTypeIsRawText(String mimeType) {
         if (enableEventMessageTrack) {
           flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
         }
-        // TODO: Use caption format information from the manifest if available.
-        List<Format> closedCaptionFormats =
-            enableCea608Track
-                ? Collections.singletonList(
-                    Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0, null))
-                : Collections.emptyList();
         extractor =
             new FragmentedMp4Extractor(
                 flags, null, null, null, closedCaptionFormats, playerEmsgTrackOutput);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
index 9f812b8e84..f06a709960 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
@@ -112,8 +112,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       }
     }
     int sampleIndex = currentIndex++;
-    byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex],
-        eventStream.timescale);
+    byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex]);
     if (serializedEvent != null) {
       buffer.ensureSpaceForWrite(serializedEvent.length);
       buffer.setFlags(C.BUFFER_FLAG_KEY_FRAME);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
index be299308a9..34e1ecc2b6 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
@@ -19,7 +19,7 @@
 
 import android.os.Handler;
 import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -121,7 +121,7 @@ public void updateManifest(DashManifest newManifest) {
     removePreviouslyExpiredManifestPublishTimeValues();
   }
 
-  /* package*/ boolean maybeRefreshManifestBeforeLoadingNextChunk(long presentationPositionUs) {
+  /* package */ boolean maybeRefreshManifestBeforeLoadingNextChunk(long presentationPositionUs) {
     if (!manifest.dynamic) {
       return false;
     }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
index 3637b80ecb..0c3f641cbe 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.dash.manifest;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.FilterableManifest;
 import com.google.android.exoplayer2.offline.StreamKey;
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index f017ae64ad..c4f61a73cd 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -66,21 +66,9 @@
   private static final Pattern CEA_708_ACCESSIBILITY_PATTERN =
       Pattern.compile("([1-9]|[1-5][0-9]|6[0-3])=.*");
 
-  private final String contentId;
   private final XmlPullParserFactory xmlParserFactory;
 
-  /**
-   * Equivalent to calling {@code new DashManifestParser(null)}.
-   */
   public DashManifestParser() {
-    this(null);
-  }
-
-  /**
-   * @param contentId An optional content identifier to include in the parsed manifest.
-   */
-  public DashManifestParser(String contentId) {
-    this.contentId = contentId;
     try {
       xmlParserFactory = XmlPullParserFactory.newInstance();
     } catch (XmlPullParserException e) {
@@ -288,9 +276,9 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
     ArrayList<Descriptor> inbandEventStreams = new ArrayList<>();
     ArrayList<Descriptor> accessibilityDescriptors = new ArrayList<>();
+    ArrayList<Descriptor> roleDescriptors = new ArrayList<>();
     ArrayList<Descriptor> supplementalProperties = new ArrayList<>();
     List<RepresentationInfo> representationInfos = new ArrayList<>();
-    @C.SelectionFlags int selectionFlags = 0;
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -312,7 +300,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
         language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
         contentType = checkContentTypeConsistency(contentType, parseContentType(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp, "Role")) {
-        selectionFlags |= parseRole(xpp);
+        roleDescriptors.add(parseDescriptor(xpp, "Role"));
       } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
         audioChannels = parseAudioChannelConfiguration(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "Accessibility")) {
@@ -333,7 +321,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
                 audioChannels,
                 audioSamplingRate,
                 language,
-                selectionFlags,
+                roleDescriptors,
                 accessibilityDescriptors,
                 segmentBase);
         contentType = checkContentTypeConsistency(contentType,
@@ -355,8 +343,9 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     // Build the representations.
     List<Representation> representations = new ArrayList<>(representationInfos.size());
     for (int i = 0; i < representationInfos.size(); i++) {
-      representations.add(buildRepresentation(representationInfos.get(i), contentId,
-          drmSchemeType, drmSchemeDatas, inbandEventStreams));
+      representations.add(
+          buildRepresentation(
+              representationInfos.get(i), drmSchemeType, drmSchemeDatas, inbandEventStreams));
     }
 
     return buildAdaptationSet(id, contentType, representations, accessibilityDescriptors,
@@ -475,24 +464,6 @@ protected int getContentType(Format format) {
     return Pair.create(schemeType, schemeData);
   }
 
-  /**
-   * Parses a Role element.
-   *
-   * @param xpp The parser from which to read.
-   * @throws XmlPullParserException If an error occurs parsing the element.
-   * @throws IOException If an error occurs reading the element.
-   * @return {@link C.SelectionFlags} parsed from the element.
-   */
-  protected int parseRole(XmlPullParser xpp) throws XmlPullParserException, IOException {
-    String schemeIdUri = parseString(xpp, "schemeIdUri", null);
-    String value = parseString(xpp, "value", null);
-    do {
-      xpp.next();
-    } while (!XmlPullParserUtil.isEndTag(xpp, "Role"));
-    return "urn:mpeg:dash:role:2011".equals(schemeIdUri) && "main".equals(value)
-        ? C.SELECTION_FLAG_DEFAULT : 0;
-  }
-
   /**
    * Parses children of AdaptationSet elements not specifically parsed elsewhere.
    *
@@ -519,7 +490,7 @@ protected RepresentationInfo parseRepresentation(
       int adaptationSetAudioChannels,
       int adaptationSetAudioSamplingRate,
       String adaptationSetLanguage,
-      @C.SelectionFlags int adaptationSetSelectionFlags,
+      List<Descriptor> adaptationSetRoleDescriptors,
       List<Descriptor> adaptationSetAccessibilityDescriptors,
       SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
@@ -583,7 +554,7 @@ protected RepresentationInfo parseRepresentation(
             audioSamplingRate,
             bandwidth,
             adaptationSetLanguage,
-            adaptationSetSelectionFlags,
+            adaptationSetRoleDescriptors,
             adaptationSetAccessibilityDescriptors,
             codecs,
             supplementalProperties);
@@ -604,11 +575,14 @@ protected Format buildFormat(
       int audioSamplingRate,
       int bitrate,
       String language,
-      @C.SelectionFlags int selectionFlags,
+      List<Descriptor> roleDescriptors,
       List<Descriptor> accessibilityDescriptors,
       String codecs,
       List<Descriptor> supplementalProperties) {
     String sampleMimeType = getSampleMimeType(containerMimeType, codecs);
+    @C.SelectionFlags int selectionFlags = parseSelectionFlagsFromRoleDescriptors(roleDescriptors);
+    @C.RoleFlags int roleFlags = parseRoleFlagsFromRoleDescriptors(roleDescriptors);
+    roleFlags |= parseRoleFlagsFromAccessibilityDescriptors(accessibilityDescriptors);
     if (sampleMimeType != null) {
       if (MimeTypes.AUDIO_E_AC3.equals(sampleMimeType)) {
         sampleMimeType = parseEac3SupplementalProperties(supplementalProperties);
@@ -625,7 +599,8 @@ protected Format buildFormat(
             height,
             frameRate,
             /* initializationData= */ null,
-            selectionFlags);
+            selectionFlags,
+            roleFlags);
       } else if (MimeTypes.isAudio(sampleMimeType)) {
         return Format.createAudioContainerFormat(
             id,
@@ -638,6 +613,7 @@ protected Format buildFormat(
             audioSamplingRate,
             /* initializationData= */ null,
             selectionFlags,
+            roleFlags,
             language);
       } else if (mimeTypeIsRawText(sampleMimeType)) {
         int accessibilityChannel;
@@ -656,16 +632,27 @@ protected Format buildFormat(
             codecs,
             bitrate,
             selectionFlags,
+            roleFlags,
             language,
             accessibilityChannel);
       }
     }
     return Format.createContainerFormat(
-        id, label, containerMimeType, sampleMimeType, codecs, bitrate, selectionFlags, language);
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        selectionFlags,
+        roleFlags,
+        language);
   }
 
-  protected Representation buildRepresentation(RepresentationInfo representationInfo,
-      String contentId, String extraDrmSchemeType, ArrayList<SchemeData> extraDrmSchemeDatas,
+  protected Representation buildRepresentation(
+      RepresentationInfo representationInfo,
+      String extraDrmSchemeType,
+      ArrayList<SchemeData> extraDrmSchemeDatas,
       ArrayList<Descriptor> extraInbandEventStreams) {
     Format format = representationInfo.format;
     String drmSchemeType = representationInfo.drmSchemeType != null
@@ -679,8 +666,12 @@ protected Representation buildRepresentation(RepresentationInfo representationIn
     }
     ArrayList<Descriptor> inbandEventStreams = representationInfo.inbandEventStreams;
     inbandEventStreams.addAll(extraInbandEventStreams);
-    return Representation.newInstance(contentId, representationInfo.revisionId, format,
-        representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStreams);
+    return Representation.newInstance(
+        representationInfo.revisionId,
+        format,
+        representationInfo.baseUrl,
+        representationInfo.segmentBase,
+        inbandEventStreams);
   }
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
@@ -834,13 +825,13 @@ protected EventStream parseEventStream(XmlPullParser xpp)
     String schemeIdUri = parseString(xpp, "schemeIdUri", "");
     String value = parseString(xpp, "value", "");
     long timescale = parseLong(xpp, "timescale", 1);
-    List<EventMessage> eventMessages = new ArrayList<>();
+    List<Pair<Long, EventMessage>> eventMessages = new ArrayList<>();
     ByteArrayOutputStream scratchOutputStream = new ByteArrayOutputStream(512);
     do {
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Event")) {
-        EventMessage event = parseEvent(xpp, schemeIdUri, value, timescale,
-            scratchOutputStream);
+        Pair<Long, EventMessage> event =
+            parseEvent(xpp, schemeIdUri, value, timescale, scratchOutputStream);
         eventMessages.add(event);
       } else {
         maybeSkipTag(xpp);
@@ -850,9 +841,9 @@ protected EventStream parseEventStream(XmlPullParser xpp)
     long[] presentationTimesUs = new long[eventMessages.size()];
     EventMessage[] events = new EventMessage[eventMessages.size()];
     for (int i = 0; i < eventMessages.size(); i++) {
-      EventMessage event = eventMessages.get(i);
-      presentationTimesUs[i] = event.presentationTimeUs;
-      events[i] = event;
+      Pair<Long, EventMessage> event = eventMessages.get(i);
+      presentationTimesUs[i] = event.first;
+      events[i] = event.second;
     }
     return buildEventStream(schemeIdUri, value, timescale, presentationTimesUs, events);
   }
@@ -871,11 +862,12 @@ protected EventStream buildEventStream(String schemeIdUri, String value, long ti
    * @param timescale The timescale of the parent EventStream.
    * @param scratchOutputStream A {@link ByteArrayOutputStream} that is used when parsing event
    *     objects.
-   * @return The {@link EventMessage} parsed from this EventStream node.
+   * @return A pair containing the node's presentation timestamp in microseconds and the parsed
+   *     {@link EventMessage}.
    * @throws XmlPullParserException If there is any error parsing this node.
    * @throws IOException If there is any error reading from the underlying input stream.
    */
-  protected EventMessage parseEvent(
+  protected Pair<Long, EventMessage> parseEvent(
       XmlPullParser xpp,
       String schemeIdUri,
       String value,
@@ -890,13 +882,14 @@ protected EventMessage parseEvent(
         timescale);
     String messageData = parseString(xpp, "messageData", null);
     byte[] eventObject = parseEventObject(xpp, scratchOutputStream);
-    return buildEvent(
-        schemeIdUri,
-        value,
-        id,
-        durationMs,
-        messageData == null ? eventObject : Util.getUtf8Bytes(messageData),
-        presentationTimesUs);
+    return Pair.create(
+        presentationTimesUs,
+        buildEvent(
+            schemeIdUri,
+            value,
+            id,
+            durationMs,
+            messageData == null ? eventObject : Util.getUtf8Bytes(messageData)));
   }
 
   /**
@@ -963,9 +956,9 @@ protected EventMessage parseEvent(
     return scratchOutputStream.toByteArray();
   }
 
-  protected EventMessage buildEvent(String schemeIdUri, String value, long id,
-      long durationMs, byte[] messageData, long presentationTimeUs) {
-    return new EventMessage(schemeIdUri, value, durationMs, id, messageData, presentationTimeUs);
+  protected EventMessage buildEvent(
+      String schemeIdUri, String value, long id, long durationMs, byte[] messageData) {
+    return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
   }
 
   protected List<SegmentTimelineElement> parseSegmentTimeline(XmlPullParser xpp)
@@ -1067,6 +1060,103 @@ protected int parseAudioChannelConfiguration(XmlPullParser xpp)
     return audioChannels;
   }
 
+  // Selection flag parsing.
+
+  protected int parseSelectionFlagsFromRoleDescriptors(List<Descriptor> roleDescriptors) {
+    for (int i = 0; i < roleDescriptors.size(); i++) {
+      Descriptor descriptor = roleDescriptors.get(i);
+      if ("urn:mpeg:dash:role:2011".equalsIgnoreCase(descriptor.schemeIdUri)
+          && "main".equals(descriptor.value)) {
+        return C.SELECTION_FLAG_DEFAULT;
+      }
+    }
+    return 0;
+  }
+
+  // Role and Accessibility parsing.
+
+  @C.RoleFlags
+  protected int parseRoleFlagsFromRoleDescriptors(List<Descriptor> roleDescriptors) {
+    @C.RoleFlags int result = 0;
+    for (int i = 0; i < roleDescriptors.size(); i++) {
+      Descriptor descriptor = roleDescriptors.get(i);
+      if ("urn:mpeg:dash:role:2011".equalsIgnoreCase(descriptor.schemeIdUri)) {
+        result |= parseDashRoleSchemeValue(descriptor.value);
+      }
+    }
+    return result;
+  }
+
+  @C.RoleFlags
+  protected int parseRoleFlagsFromAccessibilityDescriptors(
+      List<Descriptor> accessibilityDescriptors) {
+    @C.RoleFlags int result = 0;
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      Descriptor descriptor = accessibilityDescriptors.get(i);
+      if ("urn:mpeg:dash:role:2011".equalsIgnoreCase(descriptor.schemeIdUri)) {
+        result |= parseDashRoleSchemeValue(descriptor.value);
+      } else if ("urn:tva:metadata:cs:AudioPurposeCS:2007"
+          .equalsIgnoreCase(descriptor.schemeIdUri)) {
+        result |= parseTvaAudioPurposeCsValue(descriptor.value);
+      }
+    }
+    return result;
+  }
+
+  @C.RoleFlags
+  protected int parseDashRoleSchemeValue(String value) {
+    if (value == null) {
+      return 0;
+    }
+    switch (value) {
+      case "main":
+        return C.ROLE_FLAG_MAIN;
+      case "alternate":
+        return C.ROLE_FLAG_ALTERNATE;
+      case "supplementary":
+        return C.ROLE_FLAG_SUPPLEMENTARY;
+      case "commentary":
+        return C.ROLE_FLAG_COMMENTARY;
+      case "dub":
+        return C.ROLE_FLAG_DUB;
+      case "emergency":
+        return C.ROLE_FLAG_EMERGENCY;
+      case "caption":
+        return C.ROLE_FLAG_CAPTION;
+      case "subtitle":
+        return C.ROLE_FLAG_SUBTITLE;
+      case "sign":
+        return C.ROLE_FLAG_SIGN;
+      case "description":
+        return C.ROLE_FLAG_DESCRIBES_VIDEO;
+      case "enhanced-audio-intelligibility":
+        return C.ROLE_FLAG_ENHANCED_DIALOG_INTELLIGIBILITY;
+      default:
+        return 0;
+    }
+  }
+
+  @C.RoleFlags
+  protected int parseTvaAudioPurposeCsValue(String value) {
+    if (value == null) {
+      return 0;
+    }
+    switch (value) {
+      case "1": // Audio description for the visually impaired.
+        return C.ROLE_FLAG_DESCRIBES_VIDEO;
+      case "2": // Audio description for the hard of hearing.
+        return C.ROLE_FLAG_ENHANCED_DIALOG_INTELLIGIBILITY;
+      case "3": // Supplemental commentary.
+        return C.ROLE_FLAG_SUPPLEMENTARY;
+      case "4": // Director's commentary.
+        return C.ROLE_FLAG_COMMENTARY;
+      case "6": // Main programme audio.
+        return C.ROLE_FLAG_MAIN;
+      default:
+        return 0;
+    }
+  }
+
   // Utility methods.
 
   /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Descriptor.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Descriptor.java
index 0e21df64bb..493a8da09c 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Descriptor.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Descriptor.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer2.source.dash.manifest;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
index b6f7ef0a3b..18614ca4b0 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.dash.manifest;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.util.Collections;
 import java.util.List;
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
index e3072c86bd..62934d7433 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.dash.manifest;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 
 /** A parsed program information element. */
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java
index e226667337..c7bb4adec5 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.dash.manifest;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.UriUtil;
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
index 44daa1d016..0884bcc65c 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
@@ -35,19 +35,10 @@
   public static final long REVISION_ID_DEFAULT = -1;
 
   /**
-   * Identifies the piece of content to which this {@link Representation} belongs.
-   * <p>
-   * For example, all {@link Representation}s belonging to a video should have the same content
-   * identifier that uniquely identifies that video.
-   */
-  public final String contentId;
-  /**
-   * Identifies the revision of the content.
-   * <p>
-   * If the media for a given ({@link #contentId} can change over time without a change to the
-   * {@link #format}'s {@link Format#id} (e.g. as a result of re-encoding the media with an
-   * updated encoder), then this identifier must uniquely identify the revision of the media. The
-   * timestamp at which the media was encoded is often a suitable.
+   * Identifies the revision of the media contained within the representation. If the media can
+   * change over time (e.g. as a result of it being re-encoded), then this identifier can be set to
+   * uniquely identify the revision of the media. The timestamp at which the media was encoded is
+   * often a suitable.
    */
   public final long revisionId;
   /**
@@ -72,22 +63,20 @@
   /**
    * Constructs a new instance.
    *
-   * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
    * @param baseUrl The base URL.
    * @param segmentBase A segment base element for the representation.
    * @return The constructed instance.
    */
-  public static Representation newInstance(String contentId, long revisionId, Format format,
-      String baseUrl, SegmentBase segmentBase) {
-    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, null);
+  public static Representation newInstance(
+      long revisionId, Format format, String baseUrl, SegmentBase segmentBase) {
+    return newInstance(revisionId, format, baseUrl, segmentBase, null);
   }
 
   /**
    * Constructs a new instance.
    *
-   * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
    * @param baseUrl The base URL.
@@ -95,43 +84,58 @@ public static Representation newInstance(String contentId, long revisionId, Form
    * @param inbandEventStreams The in-band event streams in the representation. May be null.
    * @return The constructed instance.
    */
-  public static Representation newInstance(String contentId, long revisionId, Format format,
-      String baseUrl, SegmentBase segmentBase, List<Descriptor> inbandEventStreams) {
-    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams,
-        null);
+  public static Representation newInstance(
+      long revisionId,
+      Format format,
+      String baseUrl,
+      SegmentBase segmentBase,
+      List<Descriptor> inbandEventStreams) {
+    return newInstance(revisionId, format, baseUrl, segmentBase, inbandEventStreams, null);
   }
 
   /**
    * Constructs a new instance.
    *
-   * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
    * @param baseUrl The base URL of the representation.
    * @param segmentBase A segment base element for the representation.
    * @param inbandEventStreams The in-band event streams in the representation. May be null.
-   * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null. This
+   * @param cacheKey An optional key to be returned from {@link #getCacheKey()}, or null. This
    *     parameter is ignored if {@code segmentBase} consists of multiple segments.
    * @return The constructed instance.
    */
-  public static Representation newInstance(String contentId, long revisionId, Format format,
-      String baseUrl, SegmentBase segmentBase, List<Descriptor> inbandEventStreams,
-      String customCacheKey) {
+  public static Representation newInstance(
+      long revisionId,
+      Format format,
+      String baseUrl,
+      SegmentBase segmentBase,
+      List<Descriptor> inbandEventStreams,
+      String cacheKey) {
     if (segmentBase instanceof SingleSegmentBase) {
-      return new SingleSegmentRepresentation(contentId, revisionId, format, baseUrl,
-          (SingleSegmentBase) segmentBase, inbandEventStreams, customCacheKey, C.LENGTH_UNSET);
+      return new SingleSegmentRepresentation(
+          revisionId,
+          format,
+          baseUrl,
+          (SingleSegmentBase) segmentBase,
+          inbandEventStreams,
+          cacheKey,
+          C.LENGTH_UNSET);
     } else if (segmentBase instanceof MultiSegmentBase) {
-      return new MultiSegmentRepresentation(contentId, revisionId, format, baseUrl,
-          (MultiSegmentBase) segmentBase, inbandEventStreams);
+      return new MultiSegmentRepresentation(
+          revisionId, format, baseUrl, (MultiSegmentBase) segmentBase, inbandEventStreams);
     } else {
       throw new IllegalArgumentException("segmentBase must be of type SingleSegmentBase or "
           + "MultiSegmentBase");
     }
   }
 
-  private Representation(String contentId, long revisionId, Format format, String baseUrl,
-      SegmentBase segmentBase, List<Descriptor> inbandEventStreams) {
-    this.contentId = contentId;
+  private Representation(
+      long revisionId,
+      Format format,
+      String baseUrl,
+      SegmentBase segmentBase,
+      List<Descriptor> inbandEventStreams) {
     this.revisionId = revisionId;
     this.format = format;
     this.baseUrl = baseUrl;
@@ -162,10 +166,7 @@ public RangedUri getInitializationUri() {
    */
   public abstract DashSegmentIndex getIndex();
 
-  /**
-   * Returns a cache key for the representation if a custom cache key or content id has been
-   * provided and there is only single segment.
-   */
+  /** Returns a cache key for the representation if set, or null. */
   public abstract String getCacheKey();
 
   /**
@@ -188,7 +189,6 @@ public RangedUri getInitializationUri() {
     private final SingleSegmentIndex segmentIndex;
 
     /**
-     * @param contentId Identifies the piece of content to which this representation belongs.
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
      * @param uri The uri of the media.
@@ -197,39 +197,49 @@ public RangedUri getInitializationUri() {
      * @param indexStart The offset of the first byte of index data.
      * @param indexEnd The offset of the last byte of index data.
      * @param inbandEventStreams The in-band event streams in the representation. May be null.
-     * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
+     * @param cacheKey An optional key to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
-    public static SingleSegmentRepresentation newInstance(String contentId, long revisionId,
-        Format format, String uri, long initializationStart, long initializationEnd,
-        long indexStart, long indexEnd, List<Descriptor> inbandEventStreams, String customCacheKey,
+    public static SingleSegmentRepresentation newInstance(
+        long revisionId,
+        Format format,
+        String uri,
+        long initializationStart,
+        long initializationEnd,
+        long indexStart,
+        long indexEnd,
+        List<Descriptor> inbandEventStreams,
+        String cacheKey,
         long contentLength) {
       RangedUri rangedUri = new RangedUri(null, initializationStart,
           initializationEnd - initializationStart + 1);
       SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, indexStart,
           indexEnd - indexStart + 1);
-      return new SingleSegmentRepresentation(contentId, revisionId,
-          format, uri, segmentBase, inbandEventStreams, customCacheKey, contentLength);
+      return new SingleSegmentRepresentation(
+          revisionId, format, uri, segmentBase, inbandEventStreams, cacheKey, contentLength);
     }
 
     /**
-     * @param contentId Identifies the piece of content to which this representation belongs.
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
      * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
      * @param inbandEventStreams The in-band event streams in the representation. May be null.
-     * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
+     * @param cacheKey An optional key to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
-    public SingleSegmentRepresentation(String contentId, long revisionId, Format format,
-        String baseUrl, SingleSegmentBase segmentBase, List<Descriptor> inbandEventStreams,
-        String customCacheKey, long contentLength) {
-      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
+    public SingleSegmentRepresentation(
+        long revisionId,
+        Format format,
+        String baseUrl,
+        SingleSegmentBase segmentBase,
+        List<Descriptor> inbandEventStreams,
+        String cacheKey,
+        long contentLength) {
+      super(revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.uri = Uri.parse(baseUrl);
       this.indexUri = segmentBase.getIndex();
-      this.cacheKey = customCacheKey != null ? customCacheKey
-          : contentId != null ? contentId + "." + format.id + "." + revisionId : null;
+      this.cacheKey = cacheKey;
       this.contentLength = contentLength;
       // If we have an index uri then the index is defined externally, and we shouldn't return one
       // directly. If we don't, then we can't do better than an index defining a single segment.
@@ -263,16 +273,19 @@ public String getCacheKey() {
     private final MultiSegmentBase segmentBase;
 
     /**
-     * @param contentId Identifies the piece of content to which this representation belongs.
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
      * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
      * @param inbandEventStreams The in-band event streams in the representation. May be null.
      */
-    public MultiSegmentRepresentation(String contentId, long revisionId, Format format,
-        String baseUrl, MultiSegmentBase segmentBase, List<Descriptor> inbandEventStreams) {
-      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
+    public MultiSegmentRepresentation(
+        long revisionId,
+        Format format,
+        String baseUrl,
+        MultiSegmentBase segmentBase,
+        List<Descriptor> inbandEventStreams) {
+      super(revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.segmentBase = segmentBase;
     }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java
index a7ce7eb9a0..7d13993655 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java
@@ -139,7 +139,10 @@ private static int parseTemplate(String template, String[] urlPieces, int[] iden
           String formatTag = DEFAULT_FORMAT_TAG;
           if (formatTagIndex != -1) {
             formatTag = identifier.substring(formatTagIndex);
-            if (!formatTag.endsWith("d")) {
+            // Allowed conversions are decimal integer (which is the only conversion allowed by the
+            // DASH specification) and hexadecimal integer (due to existing content that uses it).
+            // Else we assume that the conversion is missing, and that it should be decimal integer.
+            if (!formatTag.endsWith("d") && !formatTag.endsWith("x")) {
               formatTag += "d";
             }
             identifier = identifier.substring(0, formatTagIndex);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java
deleted file mode 100644
index f36a018e5b..0000000000
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadAction.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.offline.DownloadAction;
-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.SegmentDownloadAction;
-import com.google.android.exoplayer2.offline.StreamKey;
-import java.util.Collections;
-import java.util.List;
-
-/** An action to download or remove downloaded DASH streams. */
-public final class DashDownloadAction extends SegmentDownloadAction {
-
-  private static final String TYPE = "dash";
-  private static final int VERSION = 0;
-
-  public static final Deserializer DESERIALIZER =
-      new SegmentDownloadActionDeserializer(TYPE, VERSION) {
-        @Override
-        protected DownloadAction createDownloadAction(
-            Uri uri, boolean isRemoveAction, byte[] data, List<StreamKey> keys) {
-          return new DashDownloadAction(uri, isRemoveAction, data, keys);
-        }
-      };
-
-  /**
-   * Creates a DASH download action.
-   *
-   * @param uri The URI of the media to be downloaded.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded.
-   */
-  public static DashDownloadAction createDownloadAction(
-      Uri uri, @Nullable byte[] data, List<StreamKey> keys) {
-    return new DashDownloadAction(uri, /* isRemoveAction= */ false, data, keys);
-  }
-
-  /**
-   * Creates a DASH remove action.
-   *
-   * @param uri The URI of the media to be removed.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   */
-  public static DashDownloadAction createRemoveAction(Uri uri, @Nullable byte[] data) {
-    return new DashDownloadAction(uri, /* isRemoveAction= */ true, data, Collections.emptyList());
-  }
-
-  /**
-   * @param uri The DASH manifest URI.
-   * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
-   * @param data Optional custom data for this action.
-   * @param keys Keys of representations to be downloaded. If empty, all representations are
-   *     downloaded. If {@code removeAction} is true, {@code keys} must be empty.
-   * @deprecated Use {@link #createDownloadAction(Uri, byte[], List)} or {@link
-   *     #createRemoveAction(Uri, byte[])}.
-   */
-  @Deprecated
-  public DashDownloadAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<StreamKey> keys) {
-    super(TYPE, VERSION, uri, isRemoveAction, data, keys);
-  }
-
-  @Override
-  public DashDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
-    return new DashDownloader(uri, keys, constructorHelper);
-  }
-
-}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java
deleted file mode 100644
index 91e41b9ded..0000000000
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadHelper.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.offline.DownloadHelper;
-import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.offline.TrackKey;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
-import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
-import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
-import com.google.android.exoplayer2.source.dash.manifest.Representation;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.ParsingLoadable;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
-
-/** A {@link DownloadHelper} for DASH streams. */
-public final class DashDownloadHelper extends DownloadHelper {
-
-  private final Uri uri;
-  private final DataSource.Factory manifestDataSourceFactory;
-
-  private @MonotonicNonNull DashManifest manifest;
-
-  public DashDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory) {
-    this.uri = uri;
-    this.manifestDataSourceFactory = manifestDataSourceFactory;
-  }
-
-  @Override
-  protected void prepareInternal() throws IOException {
-    DataSource dataSource = manifestDataSourceFactory.createDataSource();
-    manifest =
-        ParsingLoadable.load(dataSource, new DashManifestParser(), uri, C.DATA_TYPE_MANIFEST);
-  }
-
-  /** Returns the DASH manifest. Must not be called until after preparation completes. */
-  public DashManifest getManifest() {
-    Assertions.checkNotNull(manifest);
-    return manifest;
-  }
-
-  @Override
-  public int getPeriodCount() {
-    Assertions.checkNotNull(manifest);
-    return manifest.getPeriodCount();
-  }
-
-  @Override
-  public TrackGroupArray getTrackGroups(int periodIndex) {
-    Assertions.checkNotNull(manifest);
-    List<AdaptationSet> adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
-    TrackGroup[] trackGroups = new TrackGroup[adaptationSets.size()];
-    for (int i = 0; i < trackGroups.length; i++) {
-      List<Representation> representations = adaptationSets.get(i).representations;
-      Format[] formats = new Format[representations.size()];
-      int representationsCount = representations.size();
-      for (int j = 0; j < representationsCount; j++) {
-        formats[j] = representations.get(j).format;
-      }
-      trackGroups[i] = new TrackGroup(formats);
-    }
-    return new TrackGroupArray(trackGroups);
-  }
-
-  @Override
-  public DashDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    return DashDownloadAction.createDownloadAction(uri, data, toStreamKeys(trackKeys));
-  }
-
-  @Override
-  public DashDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return DashDownloadAction.createRemoveAction(uri, data);
-  }
-
-  private static List<StreamKey> toStreamKeys(List<TrackKey> trackKeys) {
-    List<StreamKey> streamKeys = new ArrayList<>(trackKeys.size());
-    for (int i = 0; i < trackKeys.size(); i++) {
-      TrackKey trackKey = trackKeys.get(i);
-      streamKeys.add(new StreamKey(trackKey.periodIndex, trackKey.groupIndex, trackKey.trackIndex));
-    }
-    return streamKeys;
-  }
-}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
index 68120d6177..2754a3341a 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.dash.offline;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
 import com.google.android.exoplayer2.offline.DownloadException;
@@ -28,11 +28,13 @@
 import com.google.android.exoplayer2.source.dash.DashWrappingSegmentIndex;
 import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
 import com.google.android.exoplayer2.source.dash.manifest.Period;
 import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -43,7 +45,7 @@
  * <p>Example usage:
  *
  * <pre>{@code
- * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor());
+ * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor(), databaseProvider);
  * DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
  * DownloaderConstructorHelper constructorHelper =
  *     new DownloaderConstructorHelper(cache, factory);
@@ -53,7 +55,7 @@
  *     new DashDownloader(
  *         manifestUrl, Collections.singletonList(new StreamKey(0, 0, 0)), constructorHelper);
  * // Perform the download.
- * dashDownloader.download();
+ * dashDownloader.download(progressListener);
  * // Access downloaded data using CacheDataSource
  * CacheDataSource cacheDataSource =
  *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
@@ -73,8 +75,9 @@ public DashDownloader(
   }
 
   @Override
-  protected DashManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
-    return DashUtil.loadManifest(dataSource, uri);
+  protected DashManifest getManifest(DataSource dataSource, DataSpec dataSpec) throws IOException {
+    return ParsingLoadable.load(
+        dataSource, new DashManifestParser(), dataSpec, C.DATA_TYPE_MANIFEST);
   }
 
   @Override
@@ -121,8 +124,7 @@ private static void addSegmentsForAdaptationSet(
         if (!allowIncompleteList) {
           throw e;
         }
-        // Loading failed, but generating an incomplete segment list is allowed. Advance to the next
-        // representation.
+        // Generating an incomplete segment list is allowed. Advance to the next representation.
         continue;
       }
 
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaPeriodTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaPeriodTest.java
new file mode 100644
index 0000000000..9f92e7df3c
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaPeriodTest.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import static org.mockito.Mockito.mock;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerEmsgCallback;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Descriptor;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer2.source.dash.manifest.UtcTimingElement;
+import com.google.android.exoplayer2.testutil.MediaPeriodAsserts;
+import com.google.android.exoplayer2.testutil.MediaPeriodAsserts.FilterableManifestMediaPeriodFactory;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link DashMediaPeriod}. */
+@RunWith(AndroidJUnit4.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class DashMediaPeriodTest {
+
+  @Test
+  public void getSteamKeys_isCompatibleWithDashManifestFilter() {
+    // Test manifest which covers various edge cases:
+    //  - Multiple periods.
+    //  - Single and multiple representations per adaptation set.
+    //  - Switch descriptors combining multiple adaptations sets.
+    //  - Embedded track groups.
+    // All cases are deliberately combined in one test to catch potential indexing problems which
+    // only occur in combination.
+    DashManifest testManifest =
+        createDashManifest(
+            createPeriod(
+                createAdaptationSet(
+                    /* id= */ 0,
+                    /* trackType= */ C.TRACK_TYPE_VIDEO,
+                    /* descriptor= */ null,
+                    createVideoRepresentation(/* bitrate= */ 1000000))),
+            createPeriod(
+                createAdaptationSet(
+                    /* id= */ 100,
+                    /* trackType= */ C.TRACK_TYPE_VIDEO,
+                    /* descriptor= */ createSwitchDescriptor(/* ids= */ 103, 104),
+                    createVideoRepresentationWithInbandEventStream(/* bitrate= */ 200000),
+                    createVideoRepresentationWithInbandEventStream(/* bitrate= */ 400000),
+                    createVideoRepresentationWithInbandEventStream(/* bitrate= */ 600000)),
+                createAdaptationSet(
+                    /* id= */ 101,
+                    /* trackType= */ C.TRACK_TYPE_AUDIO,
+                    /* descriptor= */ createSwitchDescriptor(/* ids= */ 102),
+                    createAudioRepresentation(/* bitrate= */ 48000),
+                    createAudioRepresentation(/* bitrate= */ 96000)),
+                createAdaptationSet(
+                    /* id= */ 102,
+                    /* trackType= */ C.TRACK_TYPE_AUDIO,
+                    /* descriptor= */ createSwitchDescriptor(/* ids= */ 101),
+                    createAudioRepresentation(/* bitrate= */ 256000)),
+                createAdaptationSet(
+                    /* id= */ 103,
+                    /* trackType= */ C.TRACK_TYPE_VIDEO,
+                    /* descriptor= */ createSwitchDescriptor(/* ids= */ 100, 104),
+                    createVideoRepresentationWithInbandEventStream(/* bitrate= */ 800000),
+                    createVideoRepresentationWithInbandEventStream(/* bitrate= */ 1000000)),
+                createAdaptationSet(
+                    /* id= */ 104,
+                    /* trackType= */ C.TRACK_TYPE_VIDEO,
+                    /* descriptor= */ createSwitchDescriptor(/* ids= */ 100, 103),
+                    createVideoRepresentationWithInbandEventStream(/* bitrate= */ 2000000)),
+                createAdaptationSet(
+                    /* id= */ 105,
+                    /* trackType= */ C.TRACK_TYPE_TEXT,
+                    /* descriptor= */ null,
+                    createTextRepresentation(/* language= */ "eng")),
+                createAdaptationSet(
+                    /* id= */ 105,
+                    /* trackType= */ C.TRACK_TYPE_TEXT,
+                    /* descriptor= */ null,
+                    createTextRepresentation(/* language= */ "ger"))));
+    FilterableManifestMediaPeriodFactory<DashManifest> mediaPeriodFactory =
+        (manifest, periodIndex) ->
+            new DashMediaPeriod(
+                /* id= */ periodIndex,
+                manifest,
+                periodIndex,
+                mock(DashChunkSource.Factory.class),
+                mock(TransferListener.class),
+                mock(LoadErrorHandlingPolicy.class),
+                new EventDispatcher()
+                    .withParameters(
+                        /* windowIndex= */ 0,
+                        /* mediaPeriodId= */ new MediaPeriodId(/* periodUid= */ new Object()),
+                        /* mediaTimeOffsetMs= */ 0),
+                /* elapsedRealtimeOffsetMs= */ 0,
+                mock(LoaderErrorThrower.class),
+                mock(Allocator.class),
+                mock(CompositeSequenceableLoaderFactory.class),
+                mock(PlayerEmsgCallback.class));
+
+    // Ignore embedded metadata as we don't want to select primary group just to get embedded track.
+    MediaPeriodAsserts.assertGetStreamKeysAndManifestFilterIntegration(
+        mediaPeriodFactory,
+        testManifest,
+        /* periodIndex= */ 1,
+        /* ignoredMimeType= */ "application/x-emsg");
+  }
+
+  private static DashManifest createDashManifest(Period... periods) {
+    return new DashManifest(
+        /* availabilityStartTimeMs= */ 0,
+        /* durationMs= */ 5000,
+        /* minBufferTimeMs= */ 1,
+        /* dynamic= */ false,
+        /* minUpdatePeriodMs= */ 2,
+        /* timeShiftBufferDepthMs= */ 3,
+        /* suggestedPresentationDelayMs= */ 4,
+        /* publishTimeMs= */ 12345,
+        /* programInformation= */ null,
+        new UtcTimingElement("", ""),
+        Uri.EMPTY,
+        Arrays.asList(periods));
+  }
+
+  private static Period createPeriod(AdaptationSet... adaptationSets) {
+    return new Period(/* id= */ null, /* startMs= */ 0, Arrays.asList(adaptationSets));
+  }
+
+  private static AdaptationSet createAdaptationSet(
+      int id, int trackType, @Nullable Descriptor descriptor, Representation... representations) {
+    return new AdaptationSet(
+        id,
+        trackType,
+        Arrays.asList(representations),
+        /* accessibilityDescriptors= */ Collections.emptyList(),
+        descriptor == null ? Collections.emptyList() : Collections.singletonList(descriptor));
+  }
+
+  private static Representation createVideoRepresentation(int bitrate) {
+    return Representation.newInstance(
+        /* revisionId= */ 0,
+        createVideoFormat(bitrate),
+        /* baseUrl= */ "",
+        new SingleSegmentBase());
+  }
+
+  private static Representation createVideoRepresentationWithInbandEventStream(int bitrate) {
+    return Representation.newInstance(
+        /* revisionId= */ 0,
+        createVideoFormat(bitrate),
+        /* baseUrl= */ "",
+        new SingleSegmentBase(),
+        Collections.singletonList(getInbandEventDescriptor()));
+  }
+
+  private static Format createVideoFormat(int bitrate) {
+    return Format.createContainerFormat(
+        /* id= */ null,
+        /* label= */ null,
+        MimeTypes.VIDEO_MP4,
+        MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        bitrate,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        /* language= */ null);
+  }
+
+  private static Representation createAudioRepresentation(int bitrate) {
+    return Representation.newInstance(
+        /* revisionId= */ 0,
+        Format.createContainerFormat(
+            /* id= */ null,
+            /* label= */ null,
+            MimeTypes.AUDIO_MP4,
+            MimeTypes.AUDIO_AAC,
+            /* codecs= */ null,
+            bitrate,
+            /* selectionFlags= */ 0,
+            /* roleFlags= */ 0,
+            /* language= */ null),
+        /* baseUrl= */ "",
+        new SingleSegmentBase());
+  }
+
+  private static Representation createTextRepresentation(String language) {
+    return Representation.newInstance(
+        /* revisionId= */ 0,
+        Format.createContainerFormat(
+            /* id= */ null,
+            /* label= */ null,
+            MimeTypes.APPLICATION_MP4,
+            MimeTypes.TEXT_VTT,
+            /* codecs= */ null,
+            /* bitrate= */ Format.NO_VALUE,
+            /* selectionFlags= */ 0,
+            /* roleFlags= */ 0,
+            language),
+        /* baseUrl= */ "",
+        new SingleSegmentBase());
+  }
+
+  private static Descriptor createSwitchDescriptor(int... ids) {
+    StringBuilder idString = new StringBuilder();
+    idString.append(ids[0]);
+    for (int i = 1; i < ids.length; i++) {
+      idString.append(",").append(ids[i]);
+    }
+    return new Descriptor(
+        /* schemeIdUri= */ "urn:mpeg:dash:adaptation-set-switching:2016",
+        /* value= */ idString.toString(),
+        /* id= */ null);
+  }
+
+  private static Descriptor getInbandEventDescriptor() {
+    return new Descriptor(
+        /* schemeIdUri= */ "inBandSchemeIdUri", /* value= */ "inBandValue", /* id= */ "inBandId");
+  }
+}
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java
index 1c440c70be..2aca8c3c05 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Util;
@@ -25,10 +26,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link DashMediaSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DashMediaSourceTest {
 
   @Test
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
index c09c765d83..a53b1ff80d 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
@@ -30,10 +31,9 @@
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link DashUtil}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class DashUtilTest {
 
   @Test
@@ -85,11 +85,12 @@ private static Representation newRepresentations(DrmInitData drmInitData) {
             /* height= */ 768,
             Format.NO_VALUE,
             /* initializationData= */ null,
-            /* selectionFlags= */ 0);
+            /* selectionFlags= */ 0,
+            /* roleFlags= */ 0);
     if (drmInitData != null) {
       format = format.copyWithDrmInitData(drmInitData);
     }
-    return Representation.newInstance("", 0, format, "", new SingleSegmentBase());
+    return Representation.newInstance(0, format, "", new SingleSegmentBase());
   }
 
   private static DrmInitData newDrmInitData() {
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
index 9c3752551a..b946931f59 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -29,12 +30,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link EventSampleStream}.
- */
-@RunWith(RobolectricTestRunner.class)
+/** Unit test for {@link EventSampleStream}. */
+@RunWith(AndroidJUnit4.class)
 public final class EventSampleStreamTest {
 
   private static final String SCHEME_ID = "urn:test";
@@ -111,7 +109,7 @@ public void testReadDataOutOfBoundReturnEndOfStreamAfterFormatForDynamicEventSam
   @Test
   public void testReadDataReturnDataAfterFormat() {
     long presentationTimeUs = 1000000;
-    EventMessage eventMessage = newEventMessageWithIdAndTime(1, presentationTimeUs);
+    EventMessage eventMessage = newEventMessageWithId(1);
     EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs}, new EventMessage[] {eventMessage});
     EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
@@ -133,8 +131,8 @@ public void testReadDataReturnDataAfterFormat() {
   public void testSkipDataThenReadDataReturnDataFromSkippedPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
     EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -159,8 +157,8 @@ public void testSkipDataThenReadDataReturnDataFromSkippedPosition() {
   public void testSeekToUsThenReadDataReturnDataFromSeekPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
     EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -186,9 +184,9 @@ public void testUpdateEventStreamContinueToReadAfterLastReadSamplePresentationTi
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -220,9 +218,9 @@ public void testSkipDataThenUpdateStreamContinueToReadFromSkippedPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -253,9 +251,9 @@ public void testSkipDataThenUpdateStreamContinueToReadDoNotSkippedMoreThanAvaila
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1},
         new EventMessage[] {eventMessage1});
@@ -287,9 +285,9 @@ public void testSeekToUsThenUpdateStreamContinueToReadFromSeekPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -319,9 +317,9 @@ public void testSeekToThenUpdateStreamContinueToReadFromSeekPositionEvenSeekMore
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1},
         new EventMessage[] {eventMessage1});
@@ -345,12 +343,12 @@ private int readData(EventSampleStream sampleStream) {
     return sampleStream.readData(formatHolder, inputBuffer, false);
   }
 
-  private EventMessage newEventMessageWithIdAndTime(int id, long presentationTimeUs) {
-    return new EventMessage(SCHEME_ID, VALUE, DURATION_MS, id, MESSAGE_DATA, presentationTimeUs);
+  private EventMessage newEventMessageWithId(int id) {
+    return new EventMessage(SCHEME_ID, VALUE, DURATION_MS, id, MESSAGE_DATA);
   }
 
   private byte[] getEncodedMessage(EventMessage eventMessage) {
-    return eventMessageEncoder.encode(eventMessage, TIME_SCALE);
+    return eventMessageEncoder.encode(eventMessage);
   }
 
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index a1693f6985..d1e795e643 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -18,6 +18,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.emsg.EventMessage;
@@ -29,11 +31,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit tests for {@link DashManifestParser}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class DashManifestParserTest {
 
   private static final String SAMPLE_MPD_1 = "sample_mpd_1";
@@ -47,10 +47,11 @@ public void testParseMediaPresentationDescription() throws IOException {
     DashManifestParser parser = new DashManifestParser();
     parser.parse(
         Uri.parse("https://example.com/test.mpd"),
-        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_1));
+        TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD_1));
     parser.parse(
         Uri.parse("https://example.com/test.mpd"),
-        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_2_UNKNOWN_MIME_TYPE));
+        TestUtil.getInputStream(
+            ApplicationProvider.getApplicationContext(), SAMPLE_MPD_2_UNKNOWN_MIME_TYPE));
   }
 
   @Test
@@ -59,7 +60,8 @@ public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IO
     DashManifest mpd =
         parser.parse(
             Uri.parse("https://example.com/test.mpd"),
-            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_3_SEGMENT_TEMPLATE));
+            TestUtil.getInputStream(
+                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_3_SEGMENT_TEMPLATE));
 
     assertThat(mpd.getPeriodCount()).isEqualTo(1);
 
@@ -90,7 +92,8 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
     DashManifest mpd =
         parser.parse(
             Uri.parse("https://example.com/test.mpd"),
-            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_4_EVENT_STREAM));
+            TestUtil.getInputStream(
+                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_4_EVENT_STREAM));
 
     Period period = mpd.getPeriod(0);
     assertThat(period.eventStreams).hasSize(3);
@@ -104,52 +107,53 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
             "call",
             10000,
             0,
-            "+ 1 800 10101010".getBytes(Charset.forName(C.UTF8_NAME)),
-            0);
+            "+ 1 800 10101010".getBytes(Charset.forName(C.UTF8_NAME)));
     assertThat(eventStream1.events[0]).isEqualTo(expectedEvent1);
+    assertThat(eventStream1.presentationTimesUs[0]).isEqualTo(0);
 
     // assert CData-structured event stream
     EventStream eventStream2 = period.eventStreams.get(1);
     assertThat(eventStream2.events.length).isEqualTo(1);
-    assertThat(eventStream2.events[0])
-        .isEqualTo(
-            new EventMessage(
-                "urn:dvb:iptv:cpm:2014",
-                "",
-                1500000,
-                1,
-                Util.getUtf8Bytes(
-                    "<![CDATA[<BroadcastEvent>\n"
-                        + "      <Program crid=\"crid://broadcaster.example.com/ABCDEF\"/>\n"
-                        + "      <InstanceDescription>\n"
-                        + "      <Title xml:lang=\"en\">The title</Title>\n"
-                        + "      <Synopsis xml:lang=\"en\" length=\"medium\">"
-                        + "The description</Synopsis>\n"
-                        + "      <ParentalGuidance>\n"
-                        + "      <mpeg7:ParentalRating href=\"urn:dvb:iptv:rating:2014:15\"/>\n"
-                        + "      <mpeg7:Region>GB</mpeg7:Region>\n"
-                        + "      </ParentalGuidance>\n"
-                        + "      </InstanceDescription>\n"
-                        + "      </BroadcastEvent>]]>"),
-                300000000));
+    EventMessage expectedEvent2 =
+        new EventMessage(
+            "urn:dvb:iptv:cpm:2014",
+            "",
+            1500000,
+            1,
+            Util.getUtf8Bytes(
+                "<![CDATA[<BroadcastEvent>\n"
+                    + "      <Program crid=\"crid://broadcaster.example.com/ABCDEF\"/>\n"
+                    + "      <InstanceDescription>\n"
+                    + "      <Title xml:lang=\"en\">The title</Title>\n"
+                    + "      <Synopsis xml:lang=\"en\" length=\"medium\">"
+                    + "The description</Synopsis>\n"
+                    + "      <ParentalGuidance>\n"
+                    + "      <mpeg7:ParentalRating href=\"urn:dvb:iptv:rating:2014:15\"/>\n"
+                    + "      <mpeg7:Region>GB</mpeg7:Region>\n"
+                    + "      </ParentalGuidance>\n"
+                    + "      </InstanceDescription>\n"
+                    + "      </BroadcastEvent>]]>"));
+
+    assertThat(eventStream2.events[0]).isEqualTo(expectedEvent2);
+    assertThat(eventStream2.presentationTimesUs[0]).isEqualTo(300000000);
 
     // assert xml-structured event stream
     EventStream eventStream3 = period.eventStreams.get(2);
     assertThat(eventStream3.events.length).isEqualTo(1);
-    assertThat(eventStream3.events[0])
-        .isEqualTo(
-            new EventMessage(
-                "urn:scte:scte35:2014:xml+bin",
-                "",
-                1000000,
-                2,
-                Util.getUtf8Bytes(
-                    "<scte35:Signal>\n"
-                        + "         <scte35:Binary>\n"
-                        + "         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==\n"
-                        + "         </scte35:Binary>\n"
-                        + "       </scte35:Signal>"),
-                1000000000));
+    EventMessage expectedEvent3 =
+        new EventMessage(
+            "urn:scte:scte35:2014:xml+bin",
+            "",
+            1000000,
+            2,
+            Util.getUtf8Bytes(
+                "<scte35:Signal>\n"
+                    + "         <scte35:Binary>\n"
+                    + "         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==\n"
+                    + "         </scte35:Binary>\n"
+                    + "       </scte35:Signal>"));
+    assertThat(eventStream3.events[0]).isEqualTo(expectedEvent3);
+    assertThat(eventStream3.presentationTimesUs[0]).isEqualTo(1000000000);
   }
 
   @Test
@@ -158,7 +162,7 @@ public void testParseMediaPresentationDescriptionCanParseProgramInformation() th
     DashManifest mpd =
         parser.parse(
             Uri.parse("Https://example.com/test.mpd"),
-            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_1));
+            TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD_1));
     ProgramInformation expectedProgramInformation =
         new ProgramInformation(
             "MediaTitle", "MediaSource", "MediaCopyright", "www.example.com", "enUs");
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
index 0d08df42e9..a336602965 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
@@ -27,10 +28,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link DashManifest}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class DashManifestTest {
 
   private static final UtcTimingElement DUMMY_UTC_TIMING = new UtcTimingElement("", "");
@@ -214,7 +214,8 @@ private static void assertManifestEquals(DashManifest expected, DashManifest act
   }
 
   private static Representation newRepresentation() {
-    return Representation.newInstance("", 0, DUMMY_FORMAT, "", DUMMY_SEGMENT_BASE);
+    return Representation.newInstance(
+        /* revisionId= */ 0, DUMMY_FORMAT, /* baseUrl= */ "", DUMMY_SEGMENT_BASE);
   }
 
   private static DashManifest newDashManifest(int duration, Period... periods) {
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
index 16c9a4706e..be1866206d 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
@@ -17,13 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link RangedUri}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class RangedUriTest {
 
   private static final String BASE_URI = "http://www.test.com/";
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
deleted file mode 100644
index 12c0b9239e..0000000000
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.manifest;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
-import com.google.android.exoplayer2.util.MimeTypes;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-/** Unit test for {@link Representation}. */
-@RunWith(RobolectricTestRunner.class)
-public class RepresentationTest {
-
-  @Test
-  public void testGetCacheKey() {
-    String uri = "http://www.google.com";
-    SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
-    Format format = createVideoContainerFormat("0");
-    Representation representation =
-        Representation.newInstance("test_stream_1", 3, format, uri, base);
-    assertThat(representation.getCacheKey()).isEqualTo("test_stream_1.0.3");
-
-    format = createVideoContainerFormat("150");
-    representation =
-        Representation.newInstance(
-            "test_stream_1", Representation.REVISION_ID_DEFAULT, format, uri, base);
-    assertThat(representation.getCacheKey()).isEqualTo("test_stream_1.150.-1");
-  }
-
-  private static Format createVideoContainerFormat(String id) {
-    return Format.createVideoContainerFormat(
-        id,
-        "label",
-        /* containerMimeType= */ MimeTypes.APPLICATION_MP4,
-        /* sampleMimeType= */ MimeTypes.VIDEO_H264,
-        /* codecs= */ null,
-        /* bitrate= */ 2500000,
-        /* width= */ 1920,
-        /* height= */ 1080,
-        /* frameRate= */ Format.NO_VALUE,
-        /* initializationData= */ null,
-        /* selectionFlags= */ 0);
-  }
-}
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
index 4192280c81..c65c2d0b0c 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
@@ -18,12 +18,12 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link UrlTemplate}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class UrlTemplateTest {
 
   @Test
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java
deleted file mode 100644
index 0ebf6bb628..0000000000
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadActionTest.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.offline;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.offline.DownloadAction;
-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-
-/** Unit tests for {@link DashDownloadAction}. */
-@RunWith(RobolectricTestRunner.class)
-public class DashDownloadActionTest {
-
-  private Uri uri1;
-  private Uri uri2;
-
-  @Before
-  public void setUp() {
-    uri1 = Uri.parse("http://test1.uri");
-    uri2 = Uri.parse("http://test2.uri");
-  }
-
-  @Test
-  public void testDownloadActionIsNotRemoveAction() {
-    DownloadAction action = createDownloadAction(uri1);
-    assertThat(action.isRemoveAction).isFalse();
-  }
-
-  @Test
-  public void testRemoveActionIsRemoveAction() {
-    DownloadAction action2 = createRemoveAction(uri1);
-    assertThat(action2.isRemoveAction).isTrue();
-  }
-
-  @Test
-  public void testCreateDownloader() {
-    MockitoAnnotations.initMocks(this);
-    DownloadAction action = createDownloadAction(uri1);
-    DownloaderConstructorHelper constructorHelper =
-        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
-    assertThat(action.createDownloader(constructorHelper)).isNotNull();
-  }
-
-  @Test
-  public void testSameUriDifferentAction_IsSameMedia() {
-    DownloadAction action1 = createRemoveAction(uri1);
-    DownloadAction action2 = createDownloadAction(uri1);
-    assertThat(action1.isSameMedia(action2)).isTrue();
-  }
-
-  @Test
-  public void testDifferentUriAndAction_IsNotSameMedia() {
-    DownloadAction action3 = createRemoveAction(uri2);
-    DownloadAction action4 = createDownloadAction(uri1);
-    assertThat(action3.isSameMedia(action4)).isFalse();
-  }
-
-  @SuppressWarnings("EqualsWithItself")
-  @Test
-  public void testEquals() {
-    DownloadAction action1 = createRemoveAction(uri1);
-    assertThat(action1.equals(action1)).isTrue();
-
-    DownloadAction action2 = createRemoveAction(uri1);
-    DownloadAction action3 = createRemoveAction(uri1);
-    assertEqual(action2, action3);
-
-    DownloadAction action4 = createRemoveAction(uri1);
-    DownloadAction action5 = createDownloadAction(uri1);
-    assertNotEqual(action4, action5);
-
-    DownloadAction action6 = createDownloadAction(uri1);
-    DownloadAction action7 = createDownloadAction(uri1, new StreamKey(0, 0, 0));
-    assertNotEqual(action6, action7);
-
-    DownloadAction action8 = createDownloadAction(uri1, new StreamKey(1, 1, 1));
-    DownloadAction action9 = createDownloadAction(uri1, new StreamKey(0, 0, 0));
-    assertNotEqual(action8, action9);
-
-    DownloadAction action10 = createRemoveAction(uri1);
-    DownloadAction action11 = createRemoveAction(uri2);
-    assertNotEqual(action10, action11);
-
-    DownloadAction action12 =
-        createDownloadAction(uri1, new StreamKey(0, 0, 0), new StreamKey(1, 1, 1));
-    DownloadAction action13 =
-        createDownloadAction(uri1, new StreamKey(1, 1, 1), new StreamKey(0, 0, 0));
-    assertEqual(action12, action13);
-
-    DownloadAction action14 = createDownloadAction(uri1, new StreamKey(0, 0, 0));
-    DownloadAction action15 =
-        createDownloadAction(uri1, new StreamKey(1, 1, 1), new StreamKey(0, 0, 0));
-    assertNotEqual(action14, action15);
-
-    DownloadAction action16 = createDownloadAction(uri1);
-    DownloadAction action17 = createDownloadAction(uri1);
-    assertEqual(action16, action17);
-  }
-
-  @Test
-  public void testSerializerGetType() {
-    DownloadAction action = createDownloadAction(uri1);
-    assertThat(action.type).isNotNull();
-  }
-
-  @Test
-  public void testSerializerWriteRead() throws Exception {
-    doTestSerializationRoundTrip(createDownloadAction(uri1));
-    doTestSerializationRoundTrip(createRemoveAction(uri1));
-    doTestSerializationRoundTrip(
-        createDownloadAction(uri2, new StreamKey(0, 0, 0), new StreamKey(1, 1, 1)));
-  }
-
-  private static void assertNotEqual(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1).isNotEqualTo(action2);
-    assertThat(action2).isNotEqualTo(action1);
-  }
-
-  private static void assertEqual(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1).isEqualTo(action2);
-    assertThat(action2).isEqualTo(action1);
-  }
-
-  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream output = new DataOutputStream(out);
-    DownloadAction.serializeToStream(action, output);
-
-    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
-    DataInputStream input = new DataInputStream(in);
-    DownloadAction action2 =
-        DownloadAction.deserializeFromStream(
-            new DownloadAction.Deserializer[] {DashDownloadAction.DESERIALIZER}, input);
-
-    assertThat(action).isEqualTo(action2);
-  }
-
-  private static DownloadAction createDownloadAction(Uri uri, StreamKey... keys) {
-    ArrayList<StreamKey> keysList = new ArrayList<>();
-    Collections.addAll(keysList, keys);
-    return DashDownloadAction.createDownloadAction(uri, null, keysList);
-  }
-
-  private static DownloadAction createRemoveAction(Uri uri) {
-    return DashDownloadAction.createRemoveAction(uri, null);
-  }
-}
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
index a215347f15..71f7c9a187 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
@@ -22,7 +22,8 @@
 /** Data for DASH downloading tests. */
 /* package */ interface DashDownloadTestData {
 
-  Uri TEST_MPD_URI = Uri.parse("test.mpd");
+  String TEST_ID = "test.mpd";
+  Uri TEST_MPD_URI = Uri.parse(TEST_ID);
 
   byte[] TEST_MPD =
       ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
index a597d780e0..b3a6b8271b 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
@@ -25,14 +25,23 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.offline.DefaultDownloaderFactory;
 import com.google.android.exoplayer2.offline.DownloadException;
+import com.google.android.exoplayer2.offline.DownloadRequest;
+import com.google.android.exoplayer2.offline.Downloader;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.DownloaderFactory;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
 import com.google.android.exoplayer2.upstream.cache.SimpleCache;
 import com.google.android.exoplayer2.util.Util;
@@ -44,22 +53,24 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit tests for {@link DashDownloader}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class DashDownloaderTest {
 
   private SimpleCache cache;
   private File tempFolder;
+  private ProgressListener progressListener;
 
   @Before
   public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    tempFolder =
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
+    progressListener = new ProgressListener();
   }
 
   @After
@@ -67,6 +78,24 @@ public void tearDown() {
     Util.recursiveDelete(tempFolder);
   }
 
+  @Test
+  public void testCreateWithDefaultDownloaderFactory() {
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    DownloaderFactory factory = new DefaultDownloaderFactory(constructorHelper);
+
+    Downloader downloader =
+        factory.createDownloader(
+            new DownloadRequest(
+                "id",
+                DownloadRequest.TYPE_DASH,
+                Uri.parse("https://www.test.com/download"),
+                Collections.singletonList(new StreamKey(/* groupIndex= */ 0, /* trackIndex= */ 0)),
+                /* customCacheKey= */ null,
+                /* data= */ null));
+    assertThat(downloader).isInstanceOf(DashDownloader.class);
+  }
+
   @Test
   public void testDownloadRepresentation() throws Exception {
     FakeDataSet fakeDataSet =
@@ -78,7 +107,7 @@ public void testDownloadRepresentation() throws Exception {
             .setRandomData("audio_segment_3", 6);
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -97,7 +126,7 @@ public void testDownloadRepresentationInSmallParts() throws Exception {
             .setRandomData("audio_segment_3", 6);
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -116,7 +145,7 @@ public void testDownloadRepresentations() throws Exception {
 
     DashDownloader dashDownloader =
         getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -137,7 +166,7 @@ public void testDownloadAllRepresentations() throws Exception {
             .setRandomData("period_2_segment_3", 3);
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -159,7 +188,7 @@ public void testProgressiveDownload() throws Exception {
 
     DashDownloader dashDownloader =
         getDashDownloader(factory, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
 
     DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
     assertThat(openedDataSpecs.length).isEqualTo(8);
@@ -191,7 +220,7 @@ public void testProgressiveDownloadSeparatePeriods() throws Exception {
 
     DashDownloader dashDownloader =
         getDashDownloader(factory, new StreamKey(0, 0, 0), new StreamKey(1, 0, 0));
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
 
     DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
     assertThat(openedDataSpecs.length).isEqualTo(8);
@@ -221,12 +250,12 @@ public void testDownloadRepresentationFailure() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     try {
-      dashDownloader.download();
+      dashDownloader.download(progressListener);
       fail();
     } catch (IOException e) {
       // Expected.
     }
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -245,18 +274,17 @@ public void testCounters() throws Exception {
             .setRandomData("audio_segment_3", 6);
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
-    assertThat(dashDownloader.getDownloadedBytes()).isEqualTo(0);
 
     try {
-      dashDownloader.download();
+      dashDownloader.download(progressListener);
       fail();
     } catch (IOException e) {
       // Failure expected after downloading init data, segment 1 and 2 bytes in segment 2.
     }
-    assertThat(dashDownloader.getDownloadedBytes()).isEqualTo(10 + 4 + 2);
+    progressListener.assertBytesDownloaded(10 + 4 + 2);
 
-    dashDownloader.download();
-    assertThat(dashDownloader.getDownloadedBytes()).isEqualTo(10 + 4 + 5 + 6);
+    dashDownloader.download(progressListener);
+    progressListener.assertBytesDownloaded(10 + 4 + 5 + 6);
   }
 
   @Test
@@ -274,7 +302,7 @@ public void testRemove() throws Exception {
 
     DashDownloader dashDownloader =
         getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
-    dashDownloader.download();
+    dashDownloader.download(progressListener);
     dashDownloader.remove();
     assertCacheEmpty(cache);
   }
@@ -288,7 +316,7 @@ public void testRepresentationWithoutIndex() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     try {
-      dashDownloader.download();
+      dashDownloader.download(progressListener);
       fail();
     } catch (DownloadException e) {
       // Expected.
@@ -312,4 +340,17 @@ private DashDownloader getDashDownloader(Factory factory, StreamKey... keys) {
     return keysList;
   }
 
+  private static final class ProgressListener implements Downloader.ProgressListener {
+
+    private long bytesDownloaded;
+
+    @Override
+    public void onProgress(long contentLength, long bytesDownloaded, float percentDownloaded) {
+      this.bytesDownloaded = bytesDownloaded;
+    }
+
+    public void assertBytesDownloaded(long bytesDownloaded) {
+      assertThat(this.bytesDownloaded).isEqualTo(bytesDownloaded);
+    }
+  }
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadHelperTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadHelperTest.java
new file mode 100644
index 0000000000..0b7c06f813
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadHelperTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.offline;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test to verify creation of a DASH {@link DownloadHelper}. */
+@RunWith(AndroidJUnit4.class)
+public final class DownloadHelperTest {
+
+  @Test
+  public void staticDownloadHelperForDash_doesNotThrow() {
+    DownloadHelper.forDash(
+        Uri.parse("http://uri"),
+        new FakeDataSource.Factory(),
+        (handler, videoListener, audioListener, text, metadata, drm) -> new Renderer[0]);
+    DownloadHelper.forDash(
+        Uri.parse("http://uri"),
+        new FakeDataSource.Factory(),
+        (handler, videoListener, audioListener, text, metadata, drm) -> new Renderer[0],
+        /* drmSessionManager= */ null,
+        DownloadHelper.DEFAULT_TRACK_SELECTOR_PARAMETERS);
+  }
+}
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
index 88d4ed6a9d..35db882e2a 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.dash.offline;
 
+import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_ID;
 import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD;
 import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD_URI;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
@@ -22,14 +23,18 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.content.Context;
-import android.net.Uri;
 import android.os.ConditionVariable;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.offline.DownloadAction;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.offline.DefaultDownloadIndex;
+import com.google.android.exoplayer2.offline.DefaultDownloaderFactory;
 import com.google.android.exoplayer2.offline.DownloadManager;
+import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.scheduler.Requirements;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
+import com.google.android.exoplayer2.testutil.DummyMainThread.TestRunnable;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.RobolectricUtil;
@@ -48,12 +53,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 /** Tests {@link DownloadManager}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public class DownloadManagerDashTest {
 
@@ -66,13 +70,14 @@
   private StreamKey fakeStreamKey1;
   private StreamKey fakeStreamKey2;
   private TestDownloadManagerListener downloadManagerListener;
-  private File actionFile;
+  private DefaultDownloadIndex downloadIndex;
   private DummyMainThread dummyMainThread;
 
   @Before
   public void setUp() throws Exception {
+    ShadowLog.stream = System.out;
     dummyMainThread = new DummyMainThread();
-    Context context = RuntimeEnvironment.application;
+    Context context = ApplicationProvider.getApplicationContext();
     tempFolder = Util.createTempDirectory(context, "ExoPlayerTest");
     File cacheFolder = new File(tempFolder, "cache");
     cacheFolder.mkdir();
@@ -91,13 +96,13 @@ public void setUp() throws Exception {
 
     fakeStreamKey1 = new StreamKey(0, 0, 0);
     fakeStreamKey2 = new StreamKey(0, 1, 0);
-    actionFile = new File(tempFolder, "actionFile");
+    downloadIndex = new DefaultDownloadIndex(TestUtil.getTestDatabaseProvider());
     createDownloadManager();
   }
 
   @After
-  public void tearDown() throws Exception {
-    downloadManager.release();
+  public void tearDown() {
+    runOnMainThread(() -> downloadManager.release());
     Util.recursiveDelete(tempFolder);
     dummyMainThread.release();
   }
@@ -125,15 +130,14 @@ public void testSaveAndLoadActionFile() throws Throwable {
 
     // Run DM accessing code on UI/main thread as it should be. Also not to block handling of loaded
     // actions.
-    dummyMainThread.runOnMainThread(
+    runOnMainThread(
         () -> {
           // Setup an Action and immediately release the DM.
-          handleDownloadAction(fakeStreamKey1, fakeStreamKey2);
+          DownloadRequest request = getDownloadRequest(fakeStreamKey1, fakeStreamKey2);
+          downloadManager.addDownload(request);
           downloadManager.release();
         });
 
-    assertThat(actionFile.exists()).isTrue();
-    assertThat(actionFile.length()).isGreaterThan(0L);
     assertCacheEmpty(cache);
 
     // Revert fakeDataSet to normal.
@@ -147,29 +151,29 @@ public void testSaveAndLoadActionFile() throws Throwable {
   }
 
   @Test
-  public void testHandleDownloadAction() throws Throwable {
-    handleDownloadAction(fakeStreamKey1, fakeStreamKey2);
+  public void testHandleDownloadRequest() throws Throwable {
+    handleDownloadRequest(fakeStreamKey1, fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
     assertCachedData(cache, fakeDataSet);
   }
 
   @Test
-  public void testHandleMultipleDownloadAction() throws Throwable {
-    handleDownloadAction(fakeStreamKey1);
-    handleDownloadAction(fakeStreamKey2);
+  public void testHandleMultipleDownloadRequest() throws Throwable {
+    handleDownloadRequest(fakeStreamKey1);
+    handleDownloadRequest(fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
     assertCachedData(cache, fakeDataSet);
   }
 
   @Test
-  public void testHandleInterferingDownloadAction() throws Throwable {
+  public void testHandleInterferingDownloadRequest() throws Throwable {
     fakeDataSet
         .newData("audio_segment_2")
-        .appendReadAction(() -> handleDownloadAction(fakeStreamKey2))
+        .appendReadAction(() -> handleDownloadRequest(fakeStreamKey2))
         .appendReadData(TestUtil.buildTestData(5))
         .endData();
 
-    handleDownloadAction(fakeStreamKey1);
+    handleDownloadRequest(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
     assertCachedData(cache, fakeDataSet);
@@ -177,7 +181,7 @@ public void testHandleInterferingDownloadAction() throws Throwable {
 
   @Test
   public void testHandleRemoveAction() throws Throwable {
-    handleDownloadAction(fakeStreamKey1);
+    handleDownloadRequest(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
 
@@ -189,10 +193,9 @@ public void testHandleRemoveAction() throws Throwable {
   }
 
   // Disabled due to flakiness.
-  @Ignore
   @Test
   public void testHandleRemoveActionBeforeDownloadFinish() throws Throwable {
-    handleDownloadAction(fakeStreamKey1);
+    handleDownloadRequest(fakeStreamKey1);
     handleRemoveAction();
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
@@ -200,6 +203,7 @@ public void testHandleRemoveActionBeforeDownloadFinish() throws Throwable {
     assertCacheEmpty(cache);
   }
 
+  // Disabled due to flakiness [Internal: b/122290449].
   @Test
   public void testHandleInterferingRemoveAction() throws Throwable {
     final ConditionVariable downloadInProgressCondition = new ConditionVariable();
@@ -209,7 +213,7 @@ public void testHandleInterferingRemoveAction() throws Throwable {
         .appendReadData(TestUtil.buildTestData(5))
         .endData();
 
-    handleDownloadAction(fakeStreamKey1);
+    handleDownloadRequest(fakeStreamKey1);
 
     assertThat(downloadInProgressCondition.block(ASSERT_TRUE_TIMEOUT)).isTrue();
 
@@ -224,43 +228,47 @@ private void blockUntilTasksCompleteAndThrowAnyDownloadError() throws Throwable
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
-  private void handleDownloadAction(StreamKey... keys) {
-    downloadManager.handleAction(newAction(TEST_MPD_URI, false, null, keys));
+  private void handleDownloadRequest(StreamKey... keys) {
+    DownloadRequest request = getDownloadRequest(keys);
+    runOnMainThread(() -> downloadManager.addDownload(request));
+  }
+
+  private DownloadRequest getDownloadRequest(StreamKey... keys) {
+    ArrayList<StreamKey> keysList = new ArrayList<>();
+    Collections.addAll(keysList, keys);
+    return new DownloadRequest(
+        TEST_ID,
+        DownloadRequest.TYPE_DASH,
+        TEST_MPD_URI,
+        keysList,
+        /* customCacheKey= */ null,
+        null);
   }
 
   private void handleRemoveAction() {
-    downloadManager.handleAction(newAction(TEST_MPD_URI, true, null));
+    runOnMainThread(() -> downloadManager.removeDownload(TEST_ID));
   }
 
   private void createDownloadManager() {
-    dummyMainThread.runOnMainThread(
+    runOnMainThread(
         () -> {
           Factory fakeDataSourceFactory = new FakeDataSource.Factory().setFakeDataSet(fakeDataSet);
           downloadManager =
               new DownloadManager(
-                  new DownloaderConstructorHelper(cache, fakeDataSourceFactory),
-                  /* maxSimultaneousDownloads= */ 1,
-                  /* minRetryCount= */ 3,
-                  actionFile,
-                  DashDownloadAction.DESERIALIZER);
+                  ApplicationProvider.getApplicationContext(),
+                  downloadIndex,
+                  new DefaultDownloaderFactory(
+                      new DownloaderConstructorHelper(cache, fakeDataSourceFactory)));
+          downloadManager.setRequirements(new Requirements(0));
 
           downloadManagerListener =
-              new TestDownloadManagerListener(downloadManager, dummyMainThread);
-          downloadManager.addListener(downloadManagerListener);
-          downloadManager.startDownloads();
+              new TestDownloadManagerListener(
+                  downloadManager, dummyMainThread, /* timeout= */ 3000);
+          downloadManager.resumeDownloads();
         });
   }
 
-  private static DownloadAction newAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, StreamKey... keys) {
-    ArrayList<StreamKey> keysList = new ArrayList<>();
-    Collections.addAll(keysList, keys);
-    DownloadAction result;
-    if (isRemoveAction) {
-      result = DashDownloadAction.createRemoveAction(uri, data);
-    } else {
-      result = DashDownloadAction.createDownloadAction(uri, data, keysList);
-    }
-    return result;
+  private void runOnMainThread(TestRunnable r) {
+    dummyMainThread.runTestOnMainThread(r);
   }
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java
index 70a64f5524..5a9ce2d88e 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadServiceDashTest.java
@@ -15,17 +15,23 @@
  */
 package com.google.android.exoplayer2.source.dash.offline;
 
+import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_ID;
 import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD;
 import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD_URI;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
 
+import android.app.Notification;
 import android.content.Context;
 import android.content.Intent;
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.offline.DownloadAction;
+import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.offline.DefaultDownloadIndex;
+import com.google.android.exoplayer2.offline.DefaultDownloaderFactory;
+import com.google.android.exoplayer2.offline.Download;
 import com.google.android.exoplayer2.offline.DownloadManager;
+import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.offline.DownloadService;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
@@ -45,17 +51,16 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Unit tests for {@link DownloadService}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public class DownloadServiceDashTest {
 
@@ -73,7 +78,7 @@
   @Before
   public void setUp() throws IOException {
     dummyMainThread = new DummyMainThread();
-    context = RuntimeEnvironment.application;
+    context = ApplicationProvider.getApplicationContext();
     tempFolder = Util.createTempDirectory(context, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
 
@@ -105,26 +110,19 @@ public void setUp() throws IOException {
     fakeStreamKey1 = new StreamKey(0, 0, 0);
     fakeStreamKey2 = new StreamKey(0, 1, 0);
 
-    dummyMainThread.runOnMainThread(
+    dummyMainThread.runTestOnMainThread(
         () -> {
-          File actionFile;
-          try {
-            actionFile = Util.createTempFile(context, "ExoPlayerTest");
-          } catch (IOException e) {
-            throw new RuntimeException(e);
-          }
-          actionFile.delete();
+          DefaultDownloadIndex downloadIndex =
+              new DefaultDownloadIndex(TestUtil.getTestDatabaseProvider());
           final DownloadManager dashDownloadManager =
               new DownloadManager(
-                  new DownloaderConstructorHelper(cache, fakeDataSourceFactory),
-                  1,
-                  3,
-                  actionFile,
-                  DashDownloadAction.DESERIALIZER);
+                  ApplicationProvider.getApplicationContext(),
+                  downloadIndex,
+                  new DefaultDownloaderFactory(
+                      new DownloaderConstructorHelper(cache, fakeDataSourceFactory)));
           downloadManagerListener =
               new TestDownloadManagerListener(dashDownloadManager, dummyMainThread);
-          dashDownloadManager.addListener(downloadManagerListener);
-          dashDownloadManager.startDownloads();
+          dashDownloadManager.resumeDownloads();
 
           dashDownloadService =
               new DownloadService(DownloadService.FOREGROUND_NOTIFICATION_ID_NONE) {
@@ -138,6 +136,11 @@ protected DownloadManager getDownloadManager() {
                 protected Scheduler getScheduler() {
                   return null;
                 }
+
+                @Override
+                protected Notification getForegroundNotification(List<Download> downloads) {
+                  throw new UnsupportedOperationException();
+                }
               };
           dashDownloadService.onCreate();
         });
@@ -152,7 +155,7 @@ public void tearDown() {
 
   @Ignore // b/78877092
   @Test
-  public void testMultipleDownloadAction() throws Throwable {
+  public void testMultipleDownloadRequest() throws Throwable {
     downloadKeys(fakeStreamKey1);
     downloadKeys(fakeStreamKey2);
 
@@ -188,33 +191,34 @@ public void testRemoveBeforeDownloadComplete() throws Throwable {
     assertCacheEmpty(cache);
   }
 
-  private void removeAll() throws Throwable {
-    callDownloadServiceOnStart(newAction(TEST_MPD_URI, true, null));
-  }
-
-  private void downloadKeys(StreamKey... keys) {
-    callDownloadServiceOnStart(newAction(TEST_MPD_URI, false, null, keys));
-  }
-
-  private void callDownloadServiceOnStart(final DownloadAction action) {
+  private void removeAll() {
     dummyMainThread.runOnMainThread(
         () -> {
           Intent startIntent =
-              DownloadService.buildAddActionIntent(context, DownloadService.class, action, false);
+              DownloadService.buildRemoveDownloadIntent(
+                  context, DownloadService.class, TEST_ID, /* foreground= */ false);
           dashDownloadService.onStartCommand(startIntent, 0, 0);
         });
   }
 
-  private static DownloadAction newAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, StreamKey... keys) {
+  private void downloadKeys(StreamKey... keys) {
     ArrayList<StreamKey> keysList = new ArrayList<>();
     Collections.addAll(keysList, keys);
-    DownloadAction result;
-    if (isRemoveAction) {
-      result = DashDownloadAction.createRemoveAction(uri, data);
-    } else {
-      result = DashDownloadAction.createDownloadAction(uri, data, keysList);
-    }
-    return result;
+    DownloadRequest action =
+        new DownloadRequest(
+            TEST_ID,
+            DownloadRequest.TYPE_DASH,
+            TEST_MPD_URI,
+            keysList,
+            /* customCacheKey= */ null,
+            null);
+    dummyMainThread.runOnMainThread(
+        () -> {
+          Intent startIntent =
+              DownloadService.buildAddDownloadIntent(
+                  context, DownloadService.class, action, /* foreground= */ false);
+          dashDownloadService.onStartCommand(startIntent, 0, 0);
+        });
   }
+
 }
diff --git a/library/dash/src/test/resources/robolectric.properties b/library/dash/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/library/dash/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/library/hls/README.md b/library/hls/README.md
index 6f7e9d08d9..1dd1b7a62e 100644
--- a/library/hls/README.md
+++ b/library/hls/README.md
@@ -8,4 +8,4 @@ instantiate a `HlsMediaSource` and pass it to `ExoPlayer.prepare`.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.source.hls.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/hls/build.gradle b/library/hls/build.gradle
index af02544619..8e9696af70 100644
--- a/library/hls/build.gradle
+++ b/library/hls/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -26,7 +25,6 @@ android {
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
@@ -36,10 +34,12 @@ android {
         //    testCoverageEnabled = true
         // }
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     implementation project(modulePrefix + 'library-core')
     testImplementation project(modulePrefix + 'testutils-robolectric')
diff --git a/library/hls/proguard-rules.txt b/library/hls/proguard-rules.txt
deleted file mode 100644
index 3b8d1bb4ac..0000000000
--- a/library/hls/proguard-rules.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-# Proguard rules specific to the hls module.
-
-# Constructors accessed via reflection in SegmentDownloadAction
--dontnote com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction
--keepclassmembers class com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction {
-  static ** DESERIALIZER;
-}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
index 55a648a0b8..4fe76cdf81 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
index 8a403c3759..9fde54a705 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.net.Uri;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
-import android.util.Pair;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.Ac4Extractor;
 import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
 import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory;
 import com.google.android.exoplayer2.extractor.ts.TsExtractor;
@@ -44,6 +45,7 @@
   public static final String AAC_FILE_EXTENSION = ".aac";
   public static final String AC3_FILE_EXTENSION = ".ac3";
   public static final String EC3_FILE_EXTENSION = ".ec3";
+  public static final String AC4_FILE_EXTENSION = ".ac4";
   public static final String MP3_FILE_EXTENSION = ".mp3";
   public static final String MP4_FILE_EXTENSION = ".mp4";
   public static final String M4_FILE_EXTENSION_PREFIX = ".m4";
@@ -53,10 +55,15 @@
   public static final String WEBVTT_FILE_EXTENSION = ".webvtt";
 
   @DefaultTsPayloadReaderFactory.Flags private final int payloadReaderFactoryFlags;
+  private final boolean exposeCea608WhenMissingDeclarations;
 
-  /** Creates a factory for HLS segment extractors. */
+  /**
+   * Equivalent to {@link #DefaultHlsExtractorFactory(int, boolean) new
+   * DefaultHlsExtractorFactory(payloadReaderFactoryFlags = 0, exposeCea608WhenMissingDeclarations =
+   * true)}
+   */
   public DefaultHlsExtractorFactory() {
-    this(/* payloadReaderFactoryFlags= */ 0);
+    this(/* payloadReaderFactoryFlags= */ 0, /* exposeCea608WhenMissingDeclarations */ true);
   }
 
   /**
@@ -65,13 +72,18 @@ public DefaultHlsExtractorFactory() {
    * @param payloadReaderFactoryFlags Flags to add when constructing any {@link
    *     DefaultTsPayloadReaderFactory} instances. Other flags may be added on top of {@code
    *     payloadReaderFactoryFlags} when creating {@link DefaultTsPayloadReaderFactory}.
+   * @param exposeCea608WhenMissingDeclarations Whether created {@link TsExtractor} instances should
+   *     expose a CEA-608 track should the master playlist contain no Closed Captions declarations.
+   *     If the master playlist contains any Closed Captions declarations, this flag is ignored.
    */
-  public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
+  public DefaultHlsExtractorFactory(
+      int payloadReaderFactoryFlags, boolean exposeCea608WhenMissingDeclarations) {
     this.payloadReaderFactoryFlags = payloadReaderFactoryFlags;
+    this.exposeCea608WhenMissingDeclarations = exposeCea608WhenMissingDeclarations;
   }
 
   @Override
-  public Pair<Extractor, Boolean> createExtractor(
+  public Result createExtractor(
       Extractor previousExtractor,
       Uri uri,
       Format format,
@@ -84,21 +96,15 @@ public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
 
     if (previousExtractor != null) {
       // A extractor has already been successfully used. Return one of the same type.
-      if (previousExtractor instanceof TsExtractor
-          || previousExtractor instanceof FragmentedMp4Extractor) {
-        // TS and fMP4 extractors can be reused.
+      if (isReusable(previousExtractor)) {
         return buildResult(previousExtractor);
-      } else if (previousExtractor instanceof WebvttExtractor) {
-        return buildResult(new WebvttExtractor(format.language, timestampAdjuster));
-      } else if (previousExtractor instanceof AdtsExtractor) {
-        return buildResult(new AdtsExtractor());
-      } else if (previousExtractor instanceof Ac3Extractor) {
-        return buildResult(new Ac3Extractor());
-      } else if (previousExtractor instanceof Mp3Extractor) {
-        return buildResult(new Mp3Extractor());
       } else {
-        throw new IllegalArgumentException(
-            "Unexpected previousExtractor type: " + previousExtractor.getClass().getSimpleName());
+        Result result =
+            buildResultForSameExtractorType(previousExtractor, format, timestampAdjuster);
+        if (result == null) {
+          throw new IllegalArgumentException(
+              "Unexpected previousExtractor type: " + previousExtractor.getClass().getSimpleName());
+        }
       }
     }
 
@@ -135,6 +141,13 @@ public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
       }
     }
 
+    if (!(extractorByFileExtension instanceof Ac4Extractor)) {
+      Ac4Extractor ac4Extractor = new Ac4Extractor();
+      if (sniffQuietly(ac4Extractor, extractorInput)) {
+        return buildResult(ac4Extractor);
+      }
+    }
+
     if (!(extractorByFileExtension instanceof Mp3Extractor)) {
       Mp3Extractor mp3Extractor =
           new Mp3Extractor(/* flags= */ 0, /* forcedFirstSampleTimestampUs= */ 0);
@@ -145,12 +158,7 @@ public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
 
     if (!(extractorByFileExtension instanceof FragmentedMp4Extractor)) {
       FragmentedMp4Extractor fragmentedMp4Extractor =
-          new FragmentedMp4Extractor(
-              /* flags= */ 0,
-              timestampAdjuster,
-              /* sideloadedTrack= */ null,
-              drmInitData,
-              muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
+          createFragmentedMp4Extractor(timestampAdjuster, drmInitData, muxedCaptionFormats);
       if (sniffQuietly(fragmentedMp4Extractor, extractorInput)) {
         return buildResult(fragmentedMp4Extractor);
       }
@@ -159,7 +167,11 @@ public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
     if (!(extractorByFileExtension instanceof TsExtractor)) {
       TsExtractor tsExtractor =
           createTsExtractor(
-              payloadReaderFactoryFlags, format, muxedCaptionFormats, timestampAdjuster);
+              payloadReaderFactoryFlags,
+              exposeCea608WhenMissingDeclarations,
+              format,
+              muxedCaptionFormats,
+              timestampAdjuster);
       if (sniffQuietly(tsExtractor, extractorInput)) {
         return buildResult(tsExtractor);
       }
@@ -188,27 +200,29 @@ private Extractor createExtractorByFileExtension(
     } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
       return new Ac3Extractor();
+    } else if (lastPathSegment.endsWith(AC4_FILE_EXTENSION)) {
+      return new Ac4Extractor();
     } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
       return new Mp3Extractor(/* flags= */ 0, /* forcedFirstSampleTimestampUs= */ 0);
     } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
         || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)
         || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)
         || lastPathSegment.startsWith(CMF_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
-      return new FragmentedMp4Extractor(
-          /* flags= */ 0,
-          timestampAdjuster,
-          /* sideloadedTrack= */ null,
-          drmInitData,
-          muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
+      return createFragmentedMp4Extractor(timestampAdjuster, drmInitData, muxedCaptionFormats);
     } else {
       // For any other file extension, we assume TS format.
       return createTsExtractor(
-          payloadReaderFactoryFlags, format, muxedCaptionFormats, timestampAdjuster);
+          payloadReaderFactoryFlags,
+          exposeCea608WhenMissingDeclarations,
+          format,
+          muxedCaptionFormats,
+          timestampAdjuster);
     }
   }
 
   private static TsExtractor createTsExtractor(
       @DefaultTsPayloadReaderFactory.Flags int userProvidedPayloadReaderFactoryFlags,
+      boolean exposeCea608WhenMissingDeclarations,
       Format format,
       List<Format> muxedCaptionFormats,
       TimestampAdjuster timestampAdjuster) {
@@ -219,7 +233,7 @@ private static TsExtractor createTsExtractor(
     if (muxedCaptionFormats != null) {
       // The playlist declares closed caption renditions, we should ignore descriptors.
       payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
-    } else {
+    } else if (exposeCea608WhenMissingDeclarations) {
       // The playlist does not provide any closed caption information. We preemptively declare a
       // closed caption track on channel 0.
       muxedCaptionFormats =
@@ -229,6 +243,8 @@ private static TsExtractor createTsExtractor(
                   MimeTypes.APPLICATION_CEA608,
                   /* selectionFlags= */ 0,
                   /* language= */ null));
+    } else {
+      muxedCaptionFormats = Collections.emptyList();
     }
     String codecs = format.codecs;
     if (!TextUtils.isEmpty(codecs)) {
@@ -249,12 +265,43 @@ private static TsExtractor createTsExtractor(
         new DefaultTsPayloadReaderFactory(payloadReaderFactoryFlags, muxedCaptionFormats));
   }
 
-  private static Pair<Extractor, Boolean> buildResult(Extractor extractor) {
-    return new Pair<>(
+  private static FragmentedMp4Extractor createFragmentedMp4Extractor(
+      TimestampAdjuster timestampAdjuster,
+      DrmInitData drmInitData,
+      @Nullable List<Format> muxedCaptionFormats) {
+    return new FragmentedMp4Extractor(
+        /* flags= */ 0,
+        timestampAdjuster,
+        /* sideloadedTrack= */ null,
+        drmInitData,
+        muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
+  }
+
+  private static Result buildResultForSameExtractorType(
+      Extractor previousExtractor, Format format, TimestampAdjuster timestampAdjuster) {
+    if (previousExtractor instanceof WebvttExtractor) {
+      return buildResult(new WebvttExtractor(format.language, timestampAdjuster));
+    } else if (previousExtractor instanceof AdtsExtractor) {
+      return buildResult(new AdtsExtractor());
+    } else if (previousExtractor instanceof Ac3Extractor) {
+      return buildResult(new Ac3Extractor());
+    } else if (previousExtractor instanceof Ac4Extractor) {
+      return buildResult(new Ac4Extractor());
+    } else if (previousExtractor instanceof Mp3Extractor) {
+      return buildResult(new Mp3Extractor());
+    } else {
+      return null;
+    }
+  }
+
+  private static Result buildResult(Extractor extractor) {
+    return new Result(
         extractor,
         extractor instanceof AdtsExtractor
             || extractor instanceof Ac3Extractor
-            || extractor instanceof Mp3Extractor);
+            || extractor instanceof Ac4Extractor
+            || extractor instanceof Mp3Extractor,
+        isReusable(extractor));
   }
 
   private static boolean sniffQuietly(Extractor extractor, ExtractorInput input)
@@ -270,4 +317,8 @@ private static boolean sniffQuietly(Extractor extractor, ExtractorInput input)
     return result;
   }
 
+  private static boolean isReusable(Extractor previousExtractor) {
+    return previousExtractor instanceof TsExtractor
+        || previousExtractor instanceof FragmentedMp4Extractor;
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index c1396de3d6..261c9b531c 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -17,7 +17,7 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
@@ -27,7 +27,6 @@
 import com.google.android.exoplayer2.source.chunk.DataChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
@@ -36,13 +35,15 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.math.BigInteger;
 import java.util.Arrays;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Source of Hls (possibly adaptive) chunks.
@@ -68,10 +69,8 @@ public HlsChunkHolder() {
      */
     public boolean endOfStream;
 
-    /**
-     * Indicates that the chunk source is waiting for the referred playlist to be refreshed.
-     */
-    public HlsUrl playlist;
+    /** Indicates that the chunk source is waiting for the referred playlist to be refreshed. */
+    public Uri playlistUrl;
 
     /**
      * Clears the holder.
@@ -79,31 +78,34 @@ public HlsChunkHolder() {
     public void clear() {
       chunk = null;
       endOfStream = false;
-      playlist = null;
+      playlistUrl = null;
     }
 
   }
 
+  /**
+   * The maximum number of keys that the key cache can hold. This value must be 2 or greater in
+   * order to hold initialization segment and media segment keys simultaneously.
+   */
+  private static final int KEY_CACHE_SIZE = 4;
+
   private final HlsExtractorFactory extractorFactory;
   private final DataSource mediaDataSource;
   private final DataSource encryptionDataSource;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
-  private final HlsUrl[] variants;
+  private final Uri[] playlistUrls;
+  private final Format[] playlistFormats;
   private final HlsPlaylistTracker playlistTracker;
   private final TrackGroup trackGroup;
   private final List<Format> muxedCaptionFormats;
+  private final FullSegmentEncryptionKeyCache keyCache;
 
   private boolean isTimestampMaster;
   private byte[] scratchSpace;
   private IOException fatalError;
-  private HlsUrl expectedPlaylistUrl;
+  private Uri expectedPlaylistUrl;
   private boolean independentSegments;
 
-  private Uri encryptionKeyUri;
-  private byte[] encryptionKey;
-  private String encryptionIvString;
-  private byte[] encryptionIv;
-
   // Note: The track group in the selection is typically *not* equal to trackGroup. This is due to
   // the way in which HlsSampleStreamWrapper generates track groups. Use only index based methods
   // in TrackSelection to avoid unexpected behavior.
@@ -115,7 +117,9 @@ public void clear() {
    * @param extractorFactory An {@link HlsExtractorFactory} from which to obtain the extractors for
    *     media chunks.
    * @param playlistTracker The {@link HlsPlaylistTracker} from which to obtain media playlists.
-   * @param variants The available variants.
+   * @param playlistUrls The {@link Uri}s of the media playlists that can be adapted between by this
+   *     chunk source.
+   * @param playlistFormats The {@link Format Formats} corresponding to the media playlists.
    * @param dataSourceFactory An {@link HlsDataSourceFactory} to create {@link DataSource}s for the
    *     chunks.
    * @param mediaTransferListener The transfer listener which should be informed of any media data
@@ -129,29 +133,30 @@ public void clear() {
   public HlsChunkSource(
       HlsExtractorFactory extractorFactory,
       HlsPlaylistTracker playlistTracker,
-      HlsUrl[] variants,
+      Uri[] playlistUrls,
+      Format[] playlistFormats,
       HlsDataSourceFactory dataSourceFactory,
       @Nullable TransferListener mediaTransferListener,
       TimestampAdjusterProvider timestampAdjusterProvider,
       List<Format> muxedCaptionFormats) {
     this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
-    this.variants = variants;
+    this.playlistUrls = playlistUrls;
+    this.playlistFormats = playlistFormats;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
     this.muxedCaptionFormats = muxedCaptionFormats;
+    keyCache = new FullSegmentEncryptionKeyCache();
     liveEdgeInPeriodTimeUs = C.TIME_UNSET;
-    Format[] variantFormats = new Format[variants.length];
-    int[] initialTrackSelection = new int[variants.length];
-    for (int i = 0; i < variants.length; i++) {
-      variantFormats[i] = variants[i].format;
-      initialTrackSelection[i] = i;
-    }
     mediaDataSource = dataSourceFactory.createDataSource(C.DATA_TYPE_MEDIA);
     if (mediaTransferListener != null) {
       mediaDataSource.addTransferListener(mediaTransferListener);
     }
     encryptionDataSource = dataSourceFactory.createDataSource(C.DATA_TYPE_DRM);
-    trackGroup = new TrackGroup(variantFormats);
+    trackGroup = new TrackGroup(playlistFormats);
+    int[] initialTrackSelection = new int[playlistUrls.length];
+    for (int i = 0; i < playlistUrls.length; i++) {
+      initialTrackSelection[i] = i;
+    }
     trackSelection = new InitializationTrackSelection(trackGroup, initialTrackSelection);
   }
 
@@ -215,8 +220,8 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
    *
    * <p>If a chunk is available then {@link HlsChunkHolder#chunk} is set. If the end of the stream
    * has been reached then {@link HlsChunkHolder#endOfStream} is set. If a chunk is not available
-   * but the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
-   * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
+   * but the end of the stream has not been reached, {@link HlsChunkHolder#playlistUrl} is set to
+   * contain the {@link Uri} that refers to the playlist that needs refreshing.
    *
    * @param playbackPositionUs The current playback position relative to the period start in
    *     microseconds. If playback of the period to which this chunk source belongs has not yet
@@ -229,12 +234,11 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
   public void getNextChunk(
       long playbackPositionUs, long loadPositionUs, List<HlsMediaChunk> queue, HlsChunkHolder out) {
     HlsMediaChunk previous = queue.isEmpty() ? null : queue.get(queue.size() - 1);
-    int oldVariantIndex = previous == null ? C.INDEX_UNSET
-        : trackGroup.indexOf(previous.trackFormat);
+    int oldTrackIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
     long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
     if (previous != null && !independentSegments) {
-      // Unless segments are known to be independent, switching variant requires downloading
+      // Unless segments are known to be independent, switching tracks requires downloading
       // overlapping segments. Hence we subtract the previous segment's duration from the buffered
       // duration.
       // This may affect the live-streaming adaptive track selection logic, when we compare the
@@ -247,23 +251,23 @@ public void getNextChunk(
       }
     }
 
-    // Select the variant.
+    // Select the track.
     MediaChunkIterator[] mediaChunkIterators = createMediaChunkIterators(previous, loadPositionUs);
     trackSelection.updateSelectedTrack(
         playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs, queue, mediaChunkIterators);
-    int selectedVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
-
-    boolean switchingVariant = oldVariantIndex != selectedVariantIndex;
-    HlsUrl selectedUrl = variants[selectedVariantIndex];
-    if (!playlistTracker.isSnapshotValid(selectedUrl)) {
-      out.playlist = selectedUrl;
-      seenExpectedPlaylistError &= expectedPlaylistUrl == selectedUrl;
-      expectedPlaylistUrl = selectedUrl;
+    int selectedTrackIndex = trackSelection.getSelectedIndexInTrackGroup();
+
+    boolean switchingTrack = oldTrackIndex != selectedTrackIndex;
+    Uri selectedPlaylistUrl = playlistUrls[selectedTrackIndex];
+    if (!playlistTracker.isSnapshotValid(selectedPlaylistUrl)) {
+      out.playlistUrl = selectedPlaylistUrl;
+      seenExpectedPlaylistError &= selectedPlaylistUrl.equals(expectedPlaylistUrl);
+      expectedPlaylistUrl = selectedPlaylistUrl;
       // Retry when playlist is refreshed.
       return;
     }
     HlsMediaPlaylist mediaPlaylist =
-        playlistTracker.getPlaylistSnapshot(selectedUrl, /* isForPlayback= */ true);
+        playlistTracker.getPlaylistSnapshot(selectedPlaylistUrl, /* isForPlayback= */ true);
     independentSegments = mediaPlaylist.hasIndependentSegments;
 
     updateLiveEdgeTimeUs(mediaPlaylist);
@@ -273,31 +277,32 @@ public void getNextChunk(
         mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
     long chunkMediaSequence =
         getChunkMediaSequence(
-            previous, switchingVariant, mediaPlaylist, startOfPlaylistInPeriodUs, loadPositionUs);
-    if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-      if (previous != null && switchingVariant) {
+            previous, switchingTrack, mediaPlaylist, startOfPlaylistInPeriodUs, loadPositionUs);
+    if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null && switchingTrack) {
         // We try getting the next chunk without adapting in case that's the reason for falling
         // behind the live window.
-        selectedVariantIndex = oldVariantIndex;
-        selectedUrl = variants[selectedVariantIndex];
-        mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl, /* isForPlayback= */ true);
+        selectedTrackIndex = oldTrackIndex;
+        selectedPlaylistUrl = playlistUrls[selectedTrackIndex];
+        mediaPlaylist =
+            playlistTracker.getPlaylistSnapshot(selectedPlaylistUrl, /* isForPlayback= */ true);
         startOfPlaylistInPeriodUs =
             mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
         chunkMediaSequence = previous.getNextChunkIndex();
-      } else {
-        fatalError = new BehindLiveWindowException();
-        return;
-      }
     }
 
-    int chunkIndex = (int) (chunkMediaSequence - mediaPlaylist.mediaSequence);
-    if (chunkIndex >= mediaPlaylist.segments.size()) {
+    if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+      fatalError = new BehindLiveWindowException();
+      return;
+    }
+
+    int segmentIndexInPlaylist = (int) (chunkMediaSequence - mediaPlaylist.mediaSequence);
+    if (segmentIndexInPlaylist >= mediaPlaylist.segments.size()) {
       if (mediaPlaylist.hasEndTag) {
         out.endOfStream = true;
       } else /* Live */ {
-        out.playlist = selectedUrl;
-        seenExpectedPlaylistError &= expectedPlaylistUrl == selectedUrl;
-        expectedPlaylistUrl = selectedUrl;
+        out.playlistUrl = selectedPlaylistUrl;
+        seenExpectedPlaylistError &= selectedPlaylistUrl.equals(expectedPlaylistUrl);
+        expectedPlaylistUrl = selectedPlaylistUrl;
       }
       return;
     }
@@ -306,64 +311,37 @@ public void getNextChunk(
     expectedPlaylistUrl = null;
 
     // Handle encryption.
-    HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
-
-    // Check if the segment is completely encrypted using the identity key format.
-    if (segment.fullSegmentEncryptionKeyUri != null) {
-      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.fullSegmentEncryptionKeyUri);
-      if (!keyUri.equals(encryptionKeyUri)) {
-        // Encryption is specified and the key has changed.
-        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
-            trackSelection.getSelectionReason(), trackSelection.getSelectionData());
-        return;
-      }
-      if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
-        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey);
-      }
-    } else {
-      clearEncryptionData();
-    }
+    HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(segmentIndexInPlaylist);
 
-    DataSpec initDataSpec = null;
-    Segment initSegment = segment.initializationSegment;
-    if (initSegment != null) {
-      Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
-      initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset,
-          initSegment.byterangeLength, null);
+    // Check if the segment or its initialization segment are fully encrypted.
+    Uri initSegmentKeyUri = getFullEncryptionKeyUri(mediaPlaylist, segment.initializationSegment);
+    out.chunk = maybeCreateEncryptionChunkFor(initSegmentKeyUri, selectedTrackIndex);
+    if (out.chunk != null) {
+      return;
+    }
+    Uri mediaSegmentKeyUri = getFullEncryptionKeyUri(mediaPlaylist, segment);
+    out.chunk = maybeCreateEncryptionChunkFor(mediaSegmentKeyUri, selectedTrackIndex);
+    if (out.chunk != null) {
+      return;
     }
 
-    // Compute start time of the next chunk.
-    long segmentStartTimeInPeriodUs = startOfPlaylistInPeriodUs + segment.relativeStartTimeUs;
-    int discontinuitySequence = mediaPlaylist.discontinuitySequence
-        + segment.relativeDiscontinuitySequence;
-    TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-        discontinuitySequence);
-
-    // Configure the data source and spec for the chunk.
-    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
-    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
-        null);
     out.chunk =
-        new HlsMediaChunk(
+        HlsMediaChunk.createInstance(
             extractorFactory,
             mediaDataSource,
-            dataSpec,
-            initDataSpec,
-            selectedUrl,
+            playlistFormats[selectedTrackIndex],
+            startOfPlaylistInPeriodUs,
+            mediaPlaylist,
+            segmentIndexInPlaylist,
+            selectedPlaylistUrl,
             muxedCaptionFormats,
             trackSelection.getSelectionReason(),
             trackSelection.getSelectionData(),
-            segmentStartTimeInPeriodUs,
-            segmentStartTimeInPeriodUs + segment.durationUs,
-            chunkMediaSequence,
-            discontinuitySequence,
-            segment.hasGapTag,
             isTimestampMaster,
-            timestampAdjuster,
+            timestampAdjusterProvider,
             previous,
-            segment.drmInitData,
-            encryptionKey,
-            encryptionIv);
+            /* mediaSegmentKey= */ keyCache.get(mediaSegmentKeyUri),
+            /* initSegmentKey= */ keyCache.get(initSegmentKeyUri));
   }
 
   /**
@@ -376,8 +354,7 @@ public void onChunkLoadCompleted(Chunk chunk) {
     if (chunk instanceof EncryptionKeyChunk) {
       EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
       scratchSpace = encryptionKeyChunk.getDataHolder();
-      setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
-          encryptionKeyChunk.getResult());
+      keyCache.put(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.getResult());
     }
   }
 
@@ -398,13 +375,19 @@ public boolean maybeBlacklistTrack(Chunk chunk, long blacklistDurationMs) {
   /**
    * Called when a playlist load encounters an error.
    *
-   * @param url The url of the playlist whose load encountered an error.
+   * @param playlistUrl The {@link Uri} of the playlist whose load encountered an error.
    * @param blacklistDurationMs The duration for which the playlist should be blacklisted. Or {@link
    *     C#TIME_UNSET} if the playlist should not be blacklisted.
    * @return True if blacklisting did not encounter errors. False otherwise.
    */
-  public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
-    int trackGroupIndex = trackGroup.indexOf(url.format);
+  public boolean onPlaylistError(Uri playlistUrl, long blacklistDurationMs) {
+    int trackGroupIndex = C.INDEX_UNSET;
+    for (int i = 0; i < playlistUrls.length; i++) {
+      if (playlistUrls[i].equals(playlistUrl)) {
+        trackGroupIndex = i;
+        break;
+      }
+    }
     if (trackGroupIndex == C.INDEX_UNSET) {
       return true;
     }
@@ -412,7 +395,7 @@ public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
     if (trackSelectionIndex == C.INDEX_UNSET) {
       return true;
     }
-    seenExpectedPlaylistError |= expectedPlaylistUrl == url;
+    seenExpectedPlaylistError |= playlistUrl.equals(expectedPlaylistUrl);
     return blacklistDurationMs == C.TIME_UNSET
         || trackSelection.blacklist(trackSelectionIndex, blacklistDurationMs);
   }
@@ -426,24 +409,23 @@ public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
    */
   public MediaChunkIterator[] createMediaChunkIterators(
       @Nullable HlsMediaChunk previous, long loadPositionUs) {
-    int oldVariantIndex =
-        previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
+    int oldTrackIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
     MediaChunkIterator[] chunkIterators = new MediaChunkIterator[trackSelection.length()];
     for (int i = 0; i < chunkIterators.length; i++) {
-      int variantIndex = trackSelection.getIndexInTrackGroup(i);
-      HlsUrl variantUrl = variants[variantIndex];
-      if (!playlistTracker.isSnapshotValid(variantUrl)) {
+      int trackIndex = trackSelection.getIndexInTrackGroup(i);
+      Uri playlistUrl = playlistUrls[trackIndex];
+      if (!playlistTracker.isSnapshotValid(playlistUrl)) {
         chunkIterators[i] = MediaChunkIterator.EMPTY;
         continue;
       }
       HlsMediaPlaylist playlist =
-          playlistTracker.getPlaylistSnapshot(variantUrl, /* isForPlayback= */ false);
+          playlistTracker.getPlaylistSnapshot(playlistUrl, /* isForPlayback= */ false);
       long startOfPlaylistInPeriodUs =
           playlist.startTimeUs - playlistTracker.getInitialStartTimeUs();
-      boolean switchingVariant = variantIndex != oldVariantIndex;
+      boolean switchingTrack = trackIndex != oldTrackIndex;
       long chunkMediaSequence =
           getChunkMediaSequence(
-              previous, switchingVariant, playlist, startOfPlaylistInPeriodUs, loadPositionUs);
+              previous, switchingTrack, playlist, startOfPlaylistInPeriodUs, loadPositionUs);
       if (chunkMediaSequence < playlist.mediaSequence) {
         chunkIterators[i] = MediaChunkIterator.EMPTY;
         continue;
@@ -461,8 +443,8 @@ public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
    * Returns the media sequence number of the segment to load next in {@code mediaPlaylist}.
    *
    * @param previous The last (at least partially) loaded segment.
-   * @param switchingVariant Whether the segment to load is not preceded by a segment in the same
-   *     variant.
+   * @param switchingTrack Whether the segment to load is not preceded by a segment in the same
+   *     track.
    * @param mediaPlaylist The media playlist to which the segment to load belongs.
    * @param startOfPlaylistInPeriodUs The start of {@code mediaPlaylist} relative to the period
    *     start in microseconds.
@@ -471,11 +453,11 @@ public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
    */
   private long getChunkMediaSequence(
       @Nullable HlsMediaChunk previous,
-      boolean switchingVariant,
+      boolean switchingTrack,
       HlsMediaPlaylist mediaPlaylist,
       long startOfPlaylistInPeriodUs,
       long loadPositionUs) {
-    if (previous == null || switchingVariant) {
+    if (previous == null || switchingTrack) {
       long endOfPlaylistInPeriodUs = startOfPlaylistInPeriodUs + mediaPlaylist.durationUs;
       long targetPositionInPeriodUs =
           (previous == null || independentSegments) ? loadPositionUs : previous.startTimeUs;
@@ -510,38 +492,34 @@ private void updateLiveEdgeTimeUs(HlsMediaPlaylist mediaPlaylist) {
             : (mediaPlaylist.getEndTimeUs() - playlistTracker.getInitialStartTimeUs());
   }
 
-  private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
-      int trackSelectionReason, Object trackSelectionData) {
+  @Nullable
+  private Chunk maybeCreateEncryptionChunkFor(@Nullable Uri keyUri, int selectedTrackIndex) {
+    if (keyUri == null) {
+      return null;
+    }
+    if (keyCache.containsKey(keyUri)) {
+      // The key is present in the key cache. We re-insert it to prevent it from being evicted by
+      // the following key addition. Note that removal of the key is necessary to affect the
+      // eviction order.
+      keyCache.put(keyUri, keyCache.remove(keyUri));
+      return null;
+    }
     DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
-    return new EncryptionKeyChunk(encryptionDataSource, dataSpec, variants[variantIndex].format,
-        trackSelectionReason, trackSelectionData, scratchSpace, iv);
+    return new EncryptionKeyChunk(
+        encryptionDataSource,
+        dataSpec,
+        playlistFormats[selectedTrackIndex],
+        trackSelection.getSelectionReason(),
+        trackSelection.getSelectionData(),
+        scratchSpace);
   }
 
-  private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
-    String trimmedIv;
-    if (Util.toLowerInvariant(iv).startsWith("0x")) {
-      trimmedIv = iv.substring(2);
-    } else {
-      trimmedIv = iv;
+  @Nullable
+  private static Uri getFullEncryptionKeyUri(HlsMediaPlaylist playlist, @Nullable Segment segment) {
+    if (segment == null || segment.fullSegmentEncryptionKeyUri == null) {
+      return null;
     }
-
-    byte[] ivData = new BigInteger(trimmedIv, 16).toByteArray();
-    byte[] ivDataWithPadding = new byte[16];
-    int offset = ivData.length > 16 ? ivData.length - 16 : 0;
-    System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
-        + offset, ivData.length - offset);
-
-    encryptionKeyUri = keyUri;
-    encryptionKey = secretKey;
-    encryptionIvString = iv;
-    encryptionIv = ivDataWithPadding;
-  }
-
-  private void clearEncryptionData() {
-    encryptionKeyUri = null;
-    encryptionKey = null;
-    encryptionIvString = null;
-    encryptionIv = null;
+    return UriUtil.resolveToUri(playlist.baseUri, segment.fullSegmentEncryptionKeyUri);
   }
 
   // Private classes.
@@ -599,19 +577,21 @@ public Object getSelectionData() {
 
   private static final class EncryptionKeyChunk extends DataChunk {
 
-    public final String iv;
-
     private byte[] result;
 
-    public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-        int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
+    public EncryptionKeyChunk(
+        DataSource dataSource,
+        DataSpec dataSpec,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        byte[] scratchSpace) {
       super(dataSource, dataSpec, C.DATA_TYPE_DRM, trackFormat, trackSelectionReason,
           trackSelectionData, scratchSpace);
-      this.iv = iv;
     }
 
     @Override
-    protected void consume(byte[] data, int limit) throws IOException {
+    protected void consume(byte[] data, int limit) {
       result = Arrays.copyOf(data, limit);
     }
 
@@ -633,7 +613,7 @@ protected void consume(byte[] data, int limit) throws IOException {
      * @param playlist The {@link HlsMediaPlaylist} to wrap.
      * @param startOfPlaylistInPeriodUs The start time of the playlist in the period, in
      *     microseconds.
-     * @param chunkIndex The chunk index in the playlist at which the iterator will start.
+     * @param chunkIndex The index of the first available chunk in the playlist.
      */
     public HlsMediaPlaylistSegmentIterator(
         HlsMediaPlaylist playlist, long startOfPlaylistInPeriodUs, int chunkIndex) {
@@ -666,4 +646,35 @@ public long getChunkEndTimeUs() {
       return segmentStartTimeInPeriodUs + segment.durationUs;
     }
   }
+
+  /**
+   * LRU cache that holds up to {@link #KEY_CACHE_SIZE} full-segment-encryption keys. Which each
+   * addition, once the cache's size exceeds {@link #KEY_CACHE_SIZE}, the oldest item (according to
+   * insertion order) is removed.
+   */
+  private static final class FullSegmentEncryptionKeyCache extends LinkedHashMap<Uri, byte[]> {
+
+    public FullSegmentEncryptionKeyCache() {
+      super(
+          /* initialCapacity= */ KEY_CACHE_SIZE * 2, /* loadFactor= */ 1, /* accessOrder= */ false);
+    }
+
+    @Override
+    public byte[] get(Object keyUri) {
+      if (keyUri == null) {
+        return null;
+      }
+      return super.get(keyUri);
+    }
+
+    @Override
+    public byte[] put(Uri keyUri, byte[] key) {
+      return super.put(keyUri, Assertions.checkNotNull(key));
+    }
+
+    @Override
+    protected boolean removeEldestEntry(Map.Entry<Uri, byte[]> entry) {
+      return size() > KEY_CACHE_SIZE;
+    }
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
index eea64d4dc6..103d89188f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.net.Uri;
-import android.util.Pair;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -32,6 +31,33 @@
  */
 public interface HlsExtractorFactory {
 
+  /** Holds an {@link Extractor} and associated parameters. */
+  final class Result {
+
+    /** The created extractor; */
+    public final Extractor extractor;
+    /** Whether the segments for which {@link #extractor} is created are packed audio segments. */
+    public final boolean isPackedAudioExtractor;
+    /**
+     * Whether {@link #extractor} may be reused for following continuous (no immediately preceding
+     * discontinuities) segments of the same variant.
+     */
+    public final boolean isReusable;
+
+    /**
+     * Creates a result.
+     *
+     * @param extractor See {@link #extractor}.
+     * @param isPackedAudioExtractor See {@link #isPackedAudioExtractor}.
+     * @param isReusable See {@link #isReusable}.
+     */
+    public Result(Extractor extractor, boolean isPackedAudioExtractor, boolean isReusable) {
+      this.extractor = extractor;
+      this.isPackedAudioExtractor = isPackedAudioExtractor;
+      this.isReusable = isReusable;
+    }
+  }
+
   HlsExtractorFactory DEFAULT = new DefaultHlsExtractorFactory();
 
   /**
@@ -51,13 +77,11 @@
    * @param sniffingExtractorInput The first extractor input that will be passed to the returned
    *     extractor's {@link Extractor#read(ExtractorInput, PositionHolder)}. Must only be used to
    *     call {@link Extractor#sniff(ExtractorInput)}.
-   * @return A pair containing the {@link Extractor} and a boolean that indicates whether it is a
-   *     packed audio extractor. The first element may be {@code previousExtractor} if the factory
-   *     has determined it can be re-used.
+   * @return A {@link Result}.
    * @throws InterruptedException If the thread is interrupted while sniffing.
    * @throws IOException If an I/O error is encountered while sniffing.
    */
-  Pair<Extractor, Boolean> createExtractor(
+  Result createExtractor(
       Extractor previousExtractor,
       Uri uri,
       Format format,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 2995f8b0aa..01da98be68 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
-import android.util.Pair;
+import android.net.Uri;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
@@ -26,14 +27,16 @@
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
+import java.math.BigInteger;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -42,6 +45,129 @@
  */
 /* package */ final class HlsMediaChunk extends MediaChunk {
 
+  /**
+   * Creates a new instance.
+   *
+   * @param extractorFactory A {@link HlsExtractorFactory} from which the HLS media chunk extractor
+   *     is obtained.
+   * @param dataSource The source from which the data should be loaded.
+   * @param format The chunk format.
+   * @param startOfPlaylistInPeriodUs The position of the playlist in the period in microseconds.
+   * @param mediaPlaylist The media playlist from which this chunk was obtained.
+   * @param playlistUrl The url of the playlist from which this chunk was obtained.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
+   *     information is available in the master playlist.
+   * @param trackSelectionReason See {@link #trackSelectionReason}.
+   * @param trackSelectionData See {@link #trackSelectionData}.
+   * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
+   * @param timestampAdjusterProvider The provider from which to obtain the {@link
+   *     TimestampAdjuster}.
+   * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
+   * @param mediaSegmentKey The media segment decryption key, if fully encrypted. Null otherwise.
+   * @param initSegmentKey The initialization segment decryption key, if fully encrypted. Null
+   *     otherwise.
+   */
+  public static HlsMediaChunk createInstance(
+      HlsExtractorFactory extractorFactory,
+      DataSource dataSource,
+      Format format,
+      long startOfPlaylistInPeriodUs,
+      HlsMediaPlaylist mediaPlaylist,
+      int segmentIndexInPlaylist,
+      Uri playlistUrl,
+      @Nullable List<Format> muxedCaptionFormats,
+      int trackSelectionReason,
+      @Nullable Object trackSelectionData,
+      boolean isMasterTimestampSource,
+      TimestampAdjusterProvider timestampAdjusterProvider,
+      @Nullable HlsMediaChunk previousChunk,
+      @Nullable byte[] mediaSegmentKey,
+      @Nullable byte[] initSegmentKey) {
+    // Media segment.
+    HlsMediaPlaylist.Segment mediaSegment = mediaPlaylist.segments.get(segmentIndexInPlaylist);
+    DataSpec dataSpec =
+        new DataSpec(
+            UriUtil.resolveToUri(mediaPlaylist.baseUri, mediaSegment.url),
+            mediaSegment.byterangeOffset,
+            mediaSegment.byterangeLength,
+            /* key= */ null);
+    boolean mediaSegmentEncrypted = mediaSegmentKey != null;
+    byte[] mediaSegmentIv =
+        mediaSegmentEncrypted ? getEncryptionIvArray(mediaSegment.encryptionIV) : null;
+    DataSource mediaDataSource = buildDataSource(dataSource, mediaSegmentKey, mediaSegmentIv);
+
+    // Init segment.
+    HlsMediaPlaylist.Segment initSegment = mediaSegment.initializationSegment;
+    DataSpec initDataSpec = null;
+    boolean initSegmentEncrypted = false;
+    DataSource initDataSource = null;
+    if (initSegment != null) {
+      initSegmentEncrypted = initSegmentKey != null;
+      byte[] initSegmentIv =
+          initSegmentEncrypted ? getEncryptionIvArray(initSegment.encryptionIV) : null;
+      Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
+      initDataSpec =
+          new DataSpec(
+              initSegmentUri,
+              initSegment.byterangeOffset,
+              initSegment.byterangeLength,
+              /* key= */ null);
+      initDataSource = buildDataSource(dataSource, initSegmentKey, initSegmentIv);
+    }
+
+    long segmentStartTimeInPeriodUs = startOfPlaylistInPeriodUs + mediaSegment.relativeStartTimeUs;
+    long segmentEndTimeInPeriodUs = segmentStartTimeInPeriodUs + mediaSegment.durationUs;
+    int discontinuitySequenceNumber =
+        mediaPlaylist.discontinuitySequence + mediaSegment.relativeDiscontinuitySequence;
+
+    Extractor previousExtractor = null;
+    Id3Decoder id3Decoder;
+    ParsableByteArray scratchId3Data;
+    boolean shouldSpliceIn;
+    if (previousChunk != null) {
+      id3Decoder = previousChunk.id3Decoder;
+      scratchId3Data = previousChunk.scratchId3Data;
+      shouldSpliceIn =
+          !playlistUrl.equals(previousChunk.playlistUrl) || !previousChunk.loadCompleted;
+      previousExtractor =
+          previousChunk.isExtractorReusable
+                  && previousChunk.discontinuitySequenceNumber == discontinuitySequenceNumber
+                  && !shouldSpliceIn
+              ? previousChunk.extractor
+              : null;
+    } else {
+      id3Decoder = new Id3Decoder();
+      scratchId3Data = new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+      shouldSpliceIn = false;
+    }
+
+    return new HlsMediaChunk(
+        extractorFactory,
+        mediaDataSource,
+        dataSpec,
+        format,
+        mediaSegmentEncrypted,
+        initDataSource,
+        initDataSpec,
+        initSegmentEncrypted,
+        playlistUrl,
+        muxedCaptionFormats,
+        trackSelectionReason,
+        trackSelectionData,
+        segmentStartTimeInPeriodUs,
+        segmentEndTimeInPeriodUs,
+        /* chunkMediaSequence= */ mediaPlaylist.mediaSequence + segmentIndexInPlaylist,
+        discontinuitySequenceNumber,
+        mediaSegment.hasGapTag,
+        isMasterTimestampSource,
+        /* timestampAdjuster= */ timestampAdjusterProvider.getAdjuster(discontinuitySequenceNumber),
+        mediaSegment.drmInitData,
+        previousExtractor,
+        id3Decoder,
+        scratchId3Data,
+        shouldSpliceIn);
+  }
+
   public static final String PRIV_TIMESTAMP_FRAME_OWNER =
       "com.apple.streaming.transportStreamTimestamp";
 
@@ -57,65 +183,45 @@
    */
   public final int discontinuitySequenceNumber;
 
-  /**
-   * The url of the playlist from which this chunk was obtained.
-   */
-  public final HlsUrl hlsUrl;
+  /** The url of the playlist from which this chunk was obtained. */
+  public final Uri playlistUrl;
 
-  private final DataSource initDataSource;
-  private final DataSpec initDataSpec;
-  private final boolean isEncrypted;
+  @Nullable private final DataSource initDataSource;
+  @Nullable private final DataSpec initDataSpec;
   private final boolean isMasterTimestampSource;
   private final boolean hasGapTag;
   private final TimestampAdjuster timestampAdjuster;
   private final boolean shouldSpliceIn;
   private final HlsExtractorFactory extractorFactory;
-  private final List<Format> muxedCaptionFormats;
-  private final DrmInitData drmInitData;
-  private final Extractor previousExtractor;
+  @Nullable private final List<Format> muxedCaptionFormats;
+  @Nullable private final DrmInitData drmInitData;
+  @Nullable private final Extractor previousExtractor;
   private final Id3Decoder id3Decoder;
-  private final ParsableByteArray id3Data;
+  private final ParsableByteArray scratchId3Data;
+  private final boolean mediaSegmentEncrypted;
+  private final boolean initSegmentEncrypted;
 
   private Extractor extractor;
+  private boolean isExtractorReusable;
   private HlsSampleStreamWrapper output;
-  private int initSegmentBytesLoaded;
+  // nextLoadPosition refers to the init segment if initDataLoadRequired is true.
+  // Otherwise, nextLoadPosition refers to the media segment.
   private int nextLoadPosition;
-  private boolean initLoadCompleted;
+  private boolean initDataLoadRequired;
   private volatile boolean loadCanceled;
   private boolean loadCompleted;
 
-  /**
-   * @param extractorFactory A {@link HlsExtractorFactory} from which the HLS media chunk extractor
-   *     is obtained.
-   * @param dataSource The source from which the data should be loaded.
-   * @param dataSpec Defines the data to be loaded.
-   * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
-   * @param hlsUrl The url of the playlist from which this chunk was obtained.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
-   *     information is available in the master playlist.
-   * @param trackSelectionReason See {@link #trackSelectionReason}.
-   * @param trackSelectionData See {@link #trackSelectionData}.
-   * @param startTimeUs The start time of the chunk in microseconds.
-   * @param endTimeUs The end time of the chunk in microseconds.
-   * @param chunkMediaSequence The media sequence number of the chunk.
-   * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
-   * @param hasGapTag Whether the chunk is tagged with EXT-X-GAP.
-   * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
-   * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
-   * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
-   * @param drmInitData A {@link DrmInitData} to sideload to the extractor.
-   * @param fullSegmentEncryptionKey The key to decrypt the full segment, or null if the segment is
-   *     not fully encrypted.
-   * @param encryptionIv The AES initialization vector, or null if the segment is not fully
-   *     encrypted.
-   */
-  public HlsMediaChunk(
+  private HlsMediaChunk(
       HlsExtractorFactory extractorFactory,
-      DataSource dataSource,
+      DataSource mediaDataSource,
       DataSpec dataSpec,
-      DataSpec initDataSpec,
-      HlsUrl hlsUrl,
-      List<Format> muxedCaptionFormats,
+      Format format,
+      boolean mediaSegmentEncrypted,
+      DataSource initDataSource,
+      @Nullable DataSpec initDataSpec,
+      boolean initSegmentEncrypted,
+      Uri playlistUrl,
+      @Nullable List<Format> muxedCaptionFormats,
       int trackSelectionReason,
       Object trackSelectionData,
       long startTimeUs,
@@ -125,43 +231,37 @@ public HlsMediaChunk(
       boolean hasGapTag,
       boolean isMasterTimestampSource,
       TimestampAdjuster timestampAdjuster,
-      HlsMediaChunk previousChunk,
-      DrmInitData drmInitData,
-      byte[] fullSegmentEncryptionKey,
-      byte[] encryptionIv) {
+      @Nullable DrmInitData drmInitData,
+      @Nullable Extractor previousExtractor,
+      Id3Decoder id3Decoder,
+      ParsableByteArray scratchId3Data,
+      boolean shouldSpliceIn) {
     super(
-        buildDataSource(dataSource, fullSegmentEncryptionKey, encryptionIv),
+        mediaDataSource,
         dataSpec,
-        hlsUrl.format,
+        format,
         trackSelectionReason,
         trackSelectionData,
         startTimeUs,
         endTimeUs,
         chunkMediaSequence);
+    this.mediaSegmentEncrypted = mediaSegmentEncrypted;
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
+    this.initDataSource = initDataSource;
     this.initDataSpec = initDataSpec;
-    this.hlsUrl = hlsUrl;
+    this.initSegmentEncrypted = initSegmentEncrypted;
+    this.playlistUrl = playlistUrl;
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
-    this.isEncrypted = fullSegmentEncryptionKey != null;
     this.hasGapTag = hasGapTag;
     this.extractorFactory = extractorFactory;
     this.muxedCaptionFormats = muxedCaptionFormats;
     this.drmInitData = drmInitData;
-    Extractor previousExtractor = null;
-    if (previousChunk != null) {
-      id3Decoder = previousChunk.id3Decoder;
-      id3Data = previousChunk.id3Data;
-      shouldSpliceIn = previousChunk.hlsUrl != hlsUrl || !previousChunk.loadCompleted;
-      previousExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
-          || shouldSpliceIn ? null : previousChunk.extractor;
-    } else {
-      id3Decoder = new Id3Decoder();
-      id3Data = new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
-      shouldSpliceIn = false;
-    }
     this.previousExtractor = previousExtractor;
-    initDataSource = dataSource;
+    this.id3Decoder = id3Decoder;
+    this.scratchId3Data = scratchId3Data;
+    this.shouldSpliceIn = shouldSpliceIn;
+    initDataLoadRequired = initDataSpec != null;
     uid = uidSource.getAndIncrement();
   }
 
@@ -189,6 +289,12 @@ public void cancelLoad() {
 
   @Override
   public void load() throws IOException, InterruptedException {
+    if (extractor == null && previousExtractor != null) {
+      extractor = previousExtractor;
+      isExtractorReusable = true;
+      initDataLoadRequired = false;
+      output.init(uid, shouldSpliceIn, /* reusingExtractor= */ true);
+    }
     maybeLoadInitData();
     if (!loadCanceled) {
       if (!hasGapTag) {
@@ -201,47 +307,45 @@ public void load() throws IOException, InterruptedException {
   // Internal methods.
 
   private void maybeLoadInitData() throws IOException, InterruptedException {
-    if (initLoadCompleted || initDataSpec == null) {
-      // Note: The HLS spec forbids initialization segments for packed audio.
+    if (!initDataLoadRequired) {
       return;
     }
-    DataSpec initSegmentDataSpec = initDataSpec.subrange(initSegmentBytesLoaded);
-    try {
-      DefaultExtractorInput input = prepareExtraction(initDataSource, initSegmentDataSpec);
-      try {
-        int result = Extractor.RESULT_CONTINUE;
-        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
-        }
-      } finally {
-        initSegmentBytesLoaded = (int) (input.getPosition() - initDataSpec.absoluteStreamPosition);
-      }
-    } finally {
-      Util.closeQuietly(initDataSource);
-    }
-    initLoadCompleted = true;
+    feedDataToExtractor(initDataSource, initDataSpec, initSegmentEncrypted);
+    nextLoadPosition = 0;
+    initDataLoadRequired = false;
   }
 
   private void loadMedia() throws IOException, InterruptedException {
+    if (!isMasterTimestampSource) {
+      timestampAdjuster.waitUntilInitialized();
+    } else if (timestampAdjuster.getFirstSampleTimestampUs() == TimestampAdjuster.DO_NOT_OFFSET) {
+      // We're the master and we haven't set the desired first sample timestamp yet.
+      timestampAdjuster.setFirstSampleTimestampUs(startTimeUs);
+    }
+    feedDataToExtractor(dataSource, dataSpec, mediaSegmentEncrypted);
+  }
+
+  /**
+   * Attempts to feed the given {@code dataSpec} to {@code this.extractor}. Whenever the operation
+   * concludes (because of a thrown exception or because the operation finishes), the number of fed
+   * bytes is written to {@code nextLoadPosition}.
+   */
+  private void feedDataToExtractor(
+      DataSource dataSource, DataSpec dataSpec, boolean dataIsEncrypted)
+      throws IOException, InterruptedException {
     // If we previously fed part of this chunk to the extractor, we need to skip it this time. For
     // encrypted content we need to skip the data by reading it through the source, so as to ensure
     // correct decryption of the remainder of the chunk. For clear content, we can request the
     // remainder of the chunk directly.
     DataSpec loadDataSpec;
     boolean skipLoadedBytes;
-    if (isEncrypted) {
+    if (dataIsEncrypted) {
       loadDataSpec = dataSpec;
       skipLoadedBytes = nextLoadPosition != 0;
     } else {
       loadDataSpec = dataSpec.subrange(nextLoadPosition);
       skipLoadedBytes = false;
     }
-    if (!isMasterTimestampSource) {
-      timestampAdjuster.waitUntilInitialized();
-    } else if (timestampAdjuster.getFirstSampleTimestampUs() == TimestampAdjuster.DO_NOT_OFFSET) {
-      // We're the master and we haven't set the desired first sample timestamp yet.
-      timestampAdjuster.setFirstSampleTimestampUs(startTimeUs);
-    }
     try {
       ExtractorInput input = prepareExtraction(dataSource, loadDataSpec);
       if (skipLoadedBytes) {
@@ -250,7 +354,7 @@ private void loadMedia() throws IOException, InterruptedException {
       try {
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
+          result = extractor.read(input, /* seekPosition= */ null);
         }
       } finally {
         nextLoadPosition = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
@@ -271,7 +375,7 @@ private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec
       long id3Timestamp = peekId3PrivTimestamp(extractorInput);
       extractorInput.resetPeekPosition();
 
-      Pair<Extractor, Boolean> extractorData =
+      HlsExtractorFactory.Result result =
           extractorFactory.createExtractor(
               previousExtractor,
               dataSpec.uri,
@@ -281,21 +385,16 @@ private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec
               timestampAdjuster,
               dataSource.getResponseHeaders(),
               extractorInput);
-      extractor = extractorData.first;
-      boolean reusingExtractor = extractor == previousExtractor;
-      boolean isPackedAudioExtractor = extractorData.second;
-      if (isPackedAudioExtractor) {
+      extractor = result.extractor;
+      isExtractorReusable = result.isReusable;
+      if (result.isPackedAudioExtractor) {
         output.setSampleOffsetUs(
             id3Timestamp != C.TIME_UNSET
                 ? timestampAdjuster.adjustTsTimestamp(id3Timestamp)
                 : startTimeUs);
       }
-      initLoadCompleted = reusingExtractor && initDataSpec != null;
-
-      output.init(uid, shouldSpliceIn, reusingExtractor);
-      if (!reusingExtractor) {
-        extractor.init(output);
-      }
+      output.init(uid, shouldSpliceIn, /* reusingExtractor= */ false);
+      extractor.init(output);
     }
 
     return extractorInput;
@@ -314,26 +413,26 @@ private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec
   private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
     input.resetPeekPosition();
     try {
-      input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+      input.peekFully(scratchId3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
     } catch (EOFException e) {
       // The input isn't long enough for there to be any ID3 data.
       return C.TIME_UNSET;
     }
-    id3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
-    int id = id3Data.readUnsignedInt24();
+    scratchId3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
+    int id = scratchId3Data.readUnsignedInt24();
     if (id != Id3Decoder.ID3_TAG) {
       return C.TIME_UNSET;
     }
-    id3Data.skipBytes(3); // version(2), flags(1).
-    int id3Size = id3Data.readSynchSafeInt();
+    scratchId3Data.skipBytes(3); // version(2), flags(1).
+    int id3Size = scratchId3Data.readSynchSafeInt();
     int requiredCapacity = id3Size + Id3Decoder.ID3_HEADER_LENGTH;
-    if (requiredCapacity > id3Data.capacity()) {
-      byte[] data = id3Data.data;
-      id3Data.reset(requiredCapacity);
-      System.arraycopy(data, 0, id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+    if (requiredCapacity > scratchId3Data.capacity()) {
+      byte[] data = scratchId3Data.data;
+      scratchId3Data.reset(requiredCapacity);
+      System.arraycopy(data, 0, scratchId3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
     }
-    input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size);
-    Metadata metadata = id3Decoder.decode(id3Data.data, id3Size);
+    input.peekFully(scratchId3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size);
+    Metadata metadata = id3Decoder.decode(scratchId3Data.data, id3Size);
     if (metadata == null) {
       return C.TIME_UNSET;
     }
@@ -343,18 +442,39 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
       if (frame instanceof PrivFrame) {
         PrivFrame privFrame = (PrivFrame) frame;
         if (PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
-          System.arraycopy(privFrame.privateData, 0, id3Data.data, 0, 8 /* timestamp size */);
-          id3Data.reset(8);
+          System.arraycopy(
+              privFrame.privateData, 0, scratchId3Data.data, 0, 8 /* timestamp size */);
+          scratchId3Data.reset(8);
           // The top 31 bits should be zeros, but explicitly zero them to wrap in the case that the
           // streaming provider forgot. See: https://github.com/google/ExoPlayer/pull/3495.
-          return id3Data.readLong() & 0x1FFFFFFFFL;
+          return scratchId3Data.readLong() & 0x1FFFFFFFFL;
         }
       }
     }
     return C.TIME_UNSET;
   }
 
-  // Internal factory methods.
+  // Internal methods.
+
+  private static byte[] getEncryptionIvArray(String ivString) {
+    String trimmedIv;
+    if (Util.toLowerInvariant(ivString).startsWith("0x")) {
+      trimmedIv = ivString.substring(2);
+    } else {
+      trimmedIv = ivString;
+    }
+
+    byte[] ivData = new BigInteger(trimmedIv, /* radix= */ 16).toByteArray();
+    byte[] ivDataWithPadding = new byte[16];
+    int offset = ivData.length > 16 ? ivData.length - 16 : 0;
+    System.arraycopy(
+        ivData,
+        offset,
+        ivDataWithPadding,
+        ivDataWithPadding.length - ivData.length + offset,
+        ivData.length - offset);
+    return ivDataWithPadding;
+  }
 
   /**
    * If the segment is fully encrypted, returns an {@link Aes128DataSource} that wraps the original
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index da50d7cc93..ef233bb566 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -15,11 +15,15 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
-import android.support.annotation.Nullable;
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -28,7 +32,8 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Rendition;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Variant;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -42,8 +47,11 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * A {@link MediaPeriod} that loads an HLS stream.
@@ -62,12 +70,15 @@
   private final TimestampAdjusterProvider timestampAdjusterProvider;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
   private final boolean allowChunklessPreparation;
+  private final boolean useSessionKeys;
 
   private @Nullable Callback callback;
   private int pendingPrepareCount;
   private TrackGroupArray trackGroups;
   private HlsSampleStreamWrapper[] sampleStreamWrappers;
   private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
+  // Maps sample stream wrappers to variant/rendition index by matching array positions.
+  private int[][] manifestUrlIndicesPerWrapper;
   private SequenceableLoader compositeSequenceableLoader;
   private boolean notifiedReadingStarted;
 
@@ -86,6 +97,7 @@
    * @param compositeSequenceableLoaderFactory A factory to create composite {@link
    *     SequenceableLoader}s for when this media source loads data from multiple streams.
    * @param allowChunklessPreparation Whether chunkless preparation is allowed.
+   * @param useSessionKeys Whether to use #EXT-X-SESSION-KEY tags.
    */
   public HlsMediaPeriod(
       HlsExtractorFactory extractorFactory,
@@ -96,7 +108,8 @@ public HlsMediaPeriod(
       EventDispatcher eventDispatcher,
       Allocator allocator,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
-      boolean allowChunklessPreparation) {
+      boolean allowChunklessPreparation,
+      boolean useSessionKeys) {
     this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
     this.dataSourceFactory = dataSourceFactory;
@@ -106,12 +119,14 @@ public HlsMediaPeriod(
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     this.allowChunklessPreparation = allowChunklessPreparation;
+    this.useSessionKeys = useSessionKeys;
     compositeSequenceableLoader =
         compositeSequenceableLoaderFactory.createCompositeSequenceableLoader();
     streamWrapperIndices = new IdentityHashMap<>();
     timestampAdjusterProvider = new TimestampAdjusterProvider();
     sampleStreamWrappers = new HlsSampleStreamWrapper[0];
     enabledSampleStreamWrappers = new HlsSampleStreamWrapper[0];
+    manifestUrlIndicesPerWrapper = new int[0][];
     eventDispatcher.mediaPeriodCreated();
   }
 
@@ -143,6 +158,89 @@ public TrackGroupArray getTrackGroups() {
     return trackGroups;
   }
 
+  // TODO: When the master playlist does not de-duplicate variants by URL and allows Renditions with
+  // null URLs, this method must be updated to calculate stream keys that are compatible with those
+  // that may already be persisted for offline.
+  @Override
+  public List<StreamKey> getStreamKeys(List<TrackSelection> trackSelections) {
+    // See HlsMasterPlaylist.copy for interpretation of StreamKeys.
+    HlsMasterPlaylist masterPlaylist = Assertions.checkNotNull(playlistTracker.getMasterPlaylist());
+    boolean hasVariants = !masterPlaylist.variants.isEmpty();
+    int audioWrapperOffset = hasVariants ? 1 : 0;
+    // Subtitle sample stream wrappers are held last.
+    int subtitleWrapperOffset = sampleStreamWrappers.length - masterPlaylist.subtitles.size();
+
+    TrackGroupArray mainWrapperTrackGroups;
+    int mainWrapperPrimaryGroupIndex;
+    int[] mainWrapperVariantIndices;
+    if (hasVariants) {
+      HlsSampleStreamWrapper mainWrapper = sampleStreamWrappers[0];
+      mainWrapperVariantIndices = manifestUrlIndicesPerWrapper[0];
+      mainWrapperTrackGroups = mainWrapper.getTrackGroups();
+      mainWrapperPrimaryGroupIndex = mainWrapper.getPrimaryTrackGroupIndex();
+    } else {
+      mainWrapperVariantIndices = new int[0];
+      mainWrapperTrackGroups = TrackGroupArray.EMPTY;
+      mainWrapperPrimaryGroupIndex = 0;
+    }
+
+    List<StreamKey> streamKeys = new ArrayList<>();
+    boolean needsPrimaryTrackGroupSelection = false;
+    boolean hasPrimaryTrackGroupSelection = false;
+    for (TrackSelection trackSelection : trackSelections) {
+      TrackGroup trackSelectionGroup = trackSelection.getTrackGroup();
+      int mainWrapperTrackGroupIndex = mainWrapperTrackGroups.indexOf(trackSelectionGroup);
+      if (mainWrapperTrackGroupIndex != C.INDEX_UNSET) {
+        if (mainWrapperTrackGroupIndex == mainWrapperPrimaryGroupIndex) {
+          // Primary group in main wrapper.
+          hasPrimaryTrackGroupSelection = true;
+          for (int i = 0; i < trackSelection.length(); i++) {
+            int variantIndex = mainWrapperVariantIndices[trackSelection.getIndexInTrackGroup(i)];
+            streamKeys.add(new StreamKey(HlsMasterPlaylist.GROUP_INDEX_VARIANT, variantIndex));
+          }
+        } else {
+          // Embedded group in main wrapper.
+          needsPrimaryTrackGroupSelection = true;
+        }
+      } else {
+        // Audio or subtitle group.
+        for (int i = audioWrapperOffset; i < sampleStreamWrappers.length; i++) {
+          TrackGroupArray wrapperTrackGroups = sampleStreamWrappers[i].getTrackGroups();
+          int selectedTrackGroupIndex = wrapperTrackGroups.indexOf(trackSelectionGroup);
+          if (selectedTrackGroupIndex != C.INDEX_UNSET) {
+            int groupIndexType =
+                i < subtitleWrapperOffset
+                    ? HlsMasterPlaylist.GROUP_INDEX_AUDIO
+                    : HlsMasterPlaylist.GROUP_INDEX_SUBTITLE;
+            int[] selectedWrapperUrlIndices = manifestUrlIndicesPerWrapper[i];
+            for (int trackIndex = 0; trackIndex < trackSelection.length(); trackIndex++) {
+              int renditionIndex =
+                  selectedWrapperUrlIndices[trackSelection.getIndexInTrackGroup(trackIndex)];
+              streamKeys.add(new StreamKey(groupIndexType, renditionIndex));
+            }
+            break;
+          }
+        }
+      }
+    }
+    if (needsPrimaryTrackGroupSelection && !hasPrimaryTrackGroupSelection) {
+      // A track selection includes a variant-embedded track, but no variant is added yet. We use
+      // the valid variant with the lowest bitrate to reduce overhead.
+      int lowestBitrateIndex = mainWrapperVariantIndices[0];
+      int lowestBitrate = masterPlaylist.variants.get(mainWrapperVariantIndices[0]).format.bitrate;
+      for (int i = 1; i < mainWrapperVariantIndices.length; i++) {
+        int variantBitrate =
+            masterPlaylist.variants.get(mainWrapperVariantIndices[i]).format.bitrate;
+        if (variantBitrate < lowestBitrate) {
+          lowestBitrate = variantBitrate;
+          lowestBitrateIndex = mainWrapperVariantIndices[i];
+        }
+      }
+      streamKeys.add(new StreamKey(HlsMasterPlaylist.GROUP_INDEX_VARIANT, lowestBitrateIndex));
+    }
+    return streamKeys;
+  }
+
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
@@ -313,7 +411,7 @@ public void onPrepared() {
   }
 
   @Override
-  public void onPlaylistRefreshRequired(HlsUrl url) {
+  public void onPlaylistRefreshRequired(Uri url) {
     playlistTracker.refreshPlaylist(url);
   }
 
@@ -330,7 +428,7 @@ public void onPlaylistChanged() {
   }
 
   @Override
-  public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
+  public boolean onPlaylistError(Uri url, long blacklistDurationMs) {
     boolean noBlacklistingFailure = true;
     for (HlsSampleStreamWrapper streamWrapper : sampleStreamWrappers) {
       noBlacklistingFailure &= streamWrapper.onPlaylistError(url, blacklistDurationMs);
@@ -342,52 +440,66 @@ public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
   // Internal methods.
 
   private void buildAndPrepareSampleStreamWrappers(long positionUs) {
-    HlsMasterPlaylist masterPlaylist = playlistTracker.getMasterPlaylist();
-    List<HlsUrl> audioRenditions = masterPlaylist.audios;
-    List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
-
-    int wrapperCount = 1 /* variants */ + audioRenditions.size() + subtitleRenditions.size();
-    sampleStreamWrappers = new HlsSampleStreamWrapper[wrapperCount];
-    pendingPrepareCount = wrapperCount;
-
-    buildAndPrepareMainSampleStreamWrapper(masterPlaylist, positionUs);
-    int currentWrapperIndex = 1;
+    HlsMasterPlaylist masterPlaylist = Assertions.checkNotNull(playlistTracker.getMasterPlaylist());
+    Map<String, DrmInitData> overridingDrmInitData =
+        useSessionKeys
+            ? deriveOverridingDrmInitData(masterPlaylist.sessionKeyDrmInitData)
+            : Collections.emptyMap();
+
+    boolean hasVariants = !masterPlaylist.variants.isEmpty();
+    List<Rendition> audioRenditions = masterPlaylist.audios;
+    List<Rendition> subtitleRenditions = masterPlaylist.subtitles;
+
+    pendingPrepareCount = 0;
+    ArrayList<HlsSampleStreamWrapper> sampleStreamWrappers = new ArrayList<>();
+    ArrayList<int[]> manifestUrlIndicesPerWrapper = new ArrayList<>();
+
+    if (hasVariants) {
+      buildAndPrepareMainSampleStreamWrapper(
+          masterPlaylist,
+          positionUs,
+          sampleStreamWrappers,
+          manifestUrlIndicesPerWrapper,
+          overridingDrmInitData);
+    }
 
     // TODO: Build video stream wrappers here.
 
-    // Audio sample stream wrappers.
-    for (int i = 0; i < audioRenditions.size(); i++) {
-      HlsUrl audioRendition = audioRenditions.get(i);
-      HlsSampleStreamWrapper sampleStreamWrapper =
-          buildSampleStreamWrapper(
-              C.TRACK_TYPE_AUDIO,
-              new HlsUrl[] {audioRendition},
-              null,
-              Collections.emptyList(),
-              positionUs);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
-      Format renditionFormat = audioRendition.format;
-      if (allowChunklessPreparation && renditionFormat.codecs != null) {
-        sampleStreamWrapper.prepareWithMasterPlaylistInfo(
-            new TrackGroupArray(new TrackGroup(audioRendition.format)), 0, TrackGroupArray.EMPTY);
-      } else {
-        sampleStreamWrapper.continuePreparing();
-      }
-    }
+    buildAndPrepareAudioSampleStreamWrappers(
+        positionUs,
+        audioRenditions,
+        sampleStreamWrappers,
+        manifestUrlIndicesPerWrapper,
+        overridingDrmInitData);
 
     // Subtitle stream wrappers. We can always use master playlist information to prepare these.
     for (int i = 0; i < subtitleRenditions.size(); i++) {
-      HlsUrl url = subtitleRenditions.get(i);
+      Rendition subtitleRendition = subtitleRenditions.get(i);
       HlsSampleStreamWrapper sampleStreamWrapper =
           buildSampleStreamWrapper(
-              C.TRACK_TYPE_TEXT, new HlsUrl[] {url}, null, Collections.emptyList(), positionUs);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+              C.TRACK_TYPE_TEXT,
+              new Uri[] {subtitleRendition.url},
+              new Format[] {subtitleRendition.format},
+              null,
+              Collections.emptyList(),
+              overridingDrmInitData,
+              positionUs);
+      manifestUrlIndicesPerWrapper.add(new int[] {i});
+      sampleStreamWrappers.add(sampleStreamWrapper);
       sampleStreamWrapper.prepareWithMasterPlaylistInfo(
-          new TrackGroupArray(new TrackGroup(url.format)), 0, TrackGroupArray.EMPTY);
+          new TrackGroupArray(new TrackGroup(subtitleRendition.format)), 0, TrackGroupArray.EMPTY);
     }
 
+    this.sampleStreamWrappers = sampleStreamWrappers.toArray(new HlsSampleStreamWrapper[0]);
+    this.manifestUrlIndicesPerWrapper = manifestUrlIndicesPerWrapper.toArray(new int[0][]);
+    pendingPrepareCount = this.sampleStreamWrappers.length;
+    // Set timestamp master and trigger preparation (if not already prepared)
+    this.sampleStreamWrappers[0].setIsTimestampMaster(true);
+    for (HlsSampleStreamWrapper sampleStreamWrapper : this.sampleStreamWrappers) {
+      sampleStreamWrapper.continuePreparing();
+    }
     // All wrappers are enabled during preparation.
-    enabledSampleStreamWrappers = sampleStreamWrappers;
+    enabledSampleStreamWrappers = this.sampleStreamWrappers;
   }
 
   /**
@@ -413,47 +525,81 @@ private void buildAndPrepareSampleStreamWrappers(long positionUs) {
    * @param masterPlaylist The HLS master playlist.
    * @param positionUs If preparation requires any chunk downloads, the position in microseconds at
    *     which downloading should start. Ignored otherwise.
+   * @param sampleStreamWrappers List to which the built main sample stream wrapper should be added.
+   * @param manifestUrlIndicesPerWrapper List to which the selected variant indices should be added.
+   * @param overridingDrmInitData Overriding {@link DrmInitData}, keyed by protection scheme type
+   *     (i.e. {@link DrmInitData#schemeType}).
    */
   private void buildAndPrepareMainSampleStreamWrapper(
-      HlsMasterPlaylist masterPlaylist, long positionUs) {
-    List<HlsUrl> selectedVariants = new ArrayList<>(masterPlaylist.variants);
-    ArrayList<HlsUrl> definiteVideoVariants = new ArrayList<>();
-    ArrayList<HlsUrl> definiteAudioOnlyVariants = new ArrayList<>();
-    for (int i = 0; i < selectedVariants.size(); i++) {
-      HlsUrl variant = selectedVariants.get(i);
+      HlsMasterPlaylist masterPlaylist,
+      long positionUs,
+      List<HlsSampleStreamWrapper> sampleStreamWrappers,
+      List<int[]> manifestUrlIndicesPerWrapper,
+      Map<String, DrmInitData> overridingDrmInitData) {
+    int[] variantTypes = new int[masterPlaylist.variants.size()];
+    int videoVariantCount = 0;
+    int audioVariantCount = 0;
+    for (int i = 0; i < masterPlaylist.variants.size(); i++) {
+      Variant variant = masterPlaylist.variants.get(i);
       Format format = variant.format;
       if (format.height > 0 || Util.getCodecsOfType(format.codecs, C.TRACK_TYPE_VIDEO) != null) {
-        definiteVideoVariants.add(variant);
+        variantTypes[i] = C.TRACK_TYPE_VIDEO;
+        videoVariantCount++;
       } else if (Util.getCodecsOfType(format.codecs, C.TRACK_TYPE_AUDIO) != null) {
-        definiteAudioOnlyVariants.add(variant);
+        variantTypes[i] = C.TRACK_TYPE_AUDIO;
+        audioVariantCount++;
+      } else {
+        variantTypes[i] = C.TRACK_TYPE_UNKNOWN;
       }
     }
-    if (!definiteVideoVariants.isEmpty()) {
+    boolean useVideoVariantsOnly = false;
+    boolean useNonAudioVariantsOnly = false;
+    int selectedVariantsCount = variantTypes.length;
+    if (videoVariantCount > 0) {
       // We've identified some variants as definitely containing video. Assume variants within the
       // master playlist are marked consistently, and hence that we have the full set. Filter out
       // any other variants, which are likely to be audio only.
-      selectedVariants = definiteVideoVariants;
-    } else if (definiteAudioOnlyVariants.size() < selectedVariants.size()) {
+      useVideoVariantsOnly = true;
+      selectedVariantsCount = videoVariantCount;
+    } else if (audioVariantCount < variantTypes.length) {
       // We've identified some variants, but not all, as being audio only. Filter them out to leave
       // the remaining variants, which are likely to contain video.
-      selectedVariants.removeAll(definiteAudioOnlyVariants);
-    } else {
-      // Leave the enabled variants unchanged. They're likely either all video or all audio.
+      useNonAudioVariantsOnly = true;
+      selectedVariantsCount = variantTypes.length - audioVariantCount;
+    }
+    Uri[] selectedPlaylistUrls = new Uri[selectedVariantsCount];
+    Format[] selectedPlaylistFormats = new Format[selectedVariantsCount];
+    int[] selectedVariantIndices = new int[selectedVariantsCount];
+    int outIndex = 0;
+    for (int i = 0; i < masterPlaylist.variants.size(); i++) {
+      if ((!useVideoVariantsOnly || variantTypes[i] == C.TRACK_TYPE_VIDEO)
+          && (!useNonAudioVariantsOnly || variantTypes[i] != C.TRACK_TYPE_AUDIO)) {
+        Variant variant = masterPlaylist.variants.get(i);
+        selectedPlaylistUrls[outIndex] = variant.url;
+        selectedPlaylistFormats[outIndex] = variant.format;
+        selectedVariantIndices[outIndex++] = i;
+      }
     }
-    Assertions.checkArgument(!selectedVariants.isEmpty());
-    HlsUrl[] variants = selectedVariants.toArray(new HlsUrl[0]);
-    String codecs = variants[0].format.codecs;
-    HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
-        variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormats, positionUs);
-    sampleStreamWrappers[0] = sampleStreamWrapper;
+    String codecs = selectedPlaylistFormats[0].codecs;
+    HlsSampleStreamWrapper sampleStreamWrapper =
+        buildSampleStreamWrapper(
+            C.TRACK_TYPE_DEFAULT,
+            selectedPlaylistUrls,
+            selectedPlaylistFormats,
+            masterPlaylist.muxedAudioFormat,
+            masterPlaylist.muxedCaptionFormats,
+            overridingDrmInitData,
+            positionUs);
+    sampleStreamWrappers.add(sampleStreamWrapper);
+    manifestUrlIndicesPerWrapper.add(selectedVariantIndices);
     if (allowChunklessPreparation && codecs != null) {
       boolean variantsContainVideoCodecs = Util.getCodecsOfType(codecs, C.TRACK_TYPE_VIDEO) != null;
       boolean variantsContainAudioCodecs = Util.getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO) != null;
       List<TrackGroup> muxedTrackGroups = new ArrayList<>();
       if (variantsContainVideoCodecs) {
-        Format[] videoFormats = new Format[selectedVariants.size()];
+        Format[] videoFormats = new Format[selectedVariantsCount];
         for (int i = 0; i < videoFormats.length; i++) {
-          videoFormats[i] = deriveVideoFormat(variants[i].format);
+          videoFormats[i] = deriveVideoFormat(selectedPlaylistFormats[i]);
         }
         muxedTrackGroups.add(new TrackGroup(videoFormats));
 
@@ -462,7 +608,7 @@ private void buildAndPrepareMainSampleStreamWrapper(
           muxedTrackGroups.add(
               new TrackGroup(
                   deriveAudioFormat(
-                      variants[0].format,
+                      selectedPlaylistFormats[0],
                       masterPlaylist.muxedAudioFormat,
                       /* isPrimaryTrackInVariant= */ false)));
         }
@@ -474,12 +620,11 @@ private void buildAndPrepareMainSampleStreamWrapper(
         }
       } else if (variantsContainAudioCodecs) {
         // Variants only contain audio.
-        Format[] audioFormats = new Format[selectedVariants.size()];
+        Format[] audioFormats = new Format[selectedVariantsCount];
         for (int i = 0; i < audioFormats.length; i++) {
-          Format variantFormat = variants[i].format;
           audioFormats[i] =
               deriveAudioFormat(
-                  variantFormat,
+                  /* variantFormat= */ selectedPlaylistFormats[i],
                   masterPlaylist.muxedAudioFormat,
                   /* isPrimaryTrackInVariant= */ true);
         }
@@ -503,19 +648,80 @@ private void buildAndPrepareMainSampleStreamWrapper(
           new TrackGroupArray(muxedTrackGroups.toArray(new TrackGroup[0])),
           0,
           new TrackGroupArray(id3TrackGroup));
-    } else {
-      sampleStreamWrapper.setIsTimestampMaster(true);
-      sampleStreamWrapper.continuePreparing();
     }
   }
 
-  private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
-      Format muxedAudioFormat, List<Format> muxedCaptionFormats, long positionUs) {
+  private void buildAndPrepareAudioSampleStreamWrappers(
+      long positionUs,
+      List<Rendition> audioRenditions,
+      List<HlsSampleStreamWrapper> sampleStreamWrappers,
+      List<int[]> manifestUrlsIndicesPerWrapper,
+      Map<String, DrmInitData> overridingDrmInitData) {
+    ArrayList<Uri> scratchPlaylistUrls =
+        new ArrayList<>(/* initialCapacity= */ audioRenditions.size());
+    ArrayList<Format> scratchPlaylistFormats =
+        new ArrayList<>(/* initialCapacity= */ audioRenditions.size());
+    ArrayList<Integer> scratchIndicesList =
+        new ArrayList<>(/* initialCapacity= */ audioRenditions.size());
+    HashSet<String> alreadyGroupedNames = new HashSet<>();
+    for (int renditionByNameIndex = 0;
+        renditionByNameIndex < audioRenditions.size();
+        renditionByNameIndex++) {
+      String name = audioRenditions.get(renditionByNameIndex).name;
+      if (!alreadyGroupedNames.add(name)) {
+        // This name already has a corresponding group.
+        continue;
+      }
+
+      boolean renditionsHaveCodecs = true;
+      scratchPlaylistUrls.clear();
+      scratchPlaylistFormats.clear();
+      scratchIndicesList.clear();
+      // Group all renditions with matching name.
+      for (int renditionIndex = 0; renditionIndex < audioRenditions.size(); renditionIndex++) {
+        if (Util.areEqual(name, audioRenditions.get(renditionIndex).name)) {
+          Rendition rendition = audioRenditions.get(renditionIndex);
+          scratchIndicesList.add(renditionIndex);
+          scratchPlaylistUrls.add(rendition.url);
+          scratchPlaylistFormats.add(rendition.format);
+          renditionsHaveCodecs &= rendition.format.codecs != null;
+        }
+      }
+
+      HlsSampleStreamWrapper sampleStreamWrapper =
+          buildSampleStreamWrapper(
+              C.TRACK_TYPE_AUDIO,
+              scratchPlaylistUrls.toArray(new Uri[0]),
+              scratchPlaylistFormats.toArray(new Format[0]),
+              /* muxedAudioFormat= */ null,
+              /* muxedCaptionFormats= */ Collections.emptyList(),
+              overridingDrmInitData,
+              positionUs);
+      manifestUrlsIndicesPerWrapper.add(Util.toArray(scratchIndicesList));
+      sampleStreamWrappers.add(sampleStreamWrapper);
+
+      if (allowChunklessPreparation && renditionsHaveCodecs) {
+        Format[] renditionFormats = scratchPlaylistFormats.toArray(new Format[0]);
+        sampleStreamWrapper.prepareWithMasterPlaylistInfo(
+            new TrackGroupArray(new TrackGroup(renditionFormats)), 0, TrackGroupArray.EMPTY);
+      }
+    }
+  }
+
+  private HlsSampleStreamWrapper buildSampleStreamWrapper(
+      int trackType,
+      Uri[] playlistUrls,
+      Format[] playlistFormats,
+      Format muxedAudioFormat,
+      List<Format> muxedCaptionFormats,
+      Map<String, DrmInitData> overridingDrmInitData,
+      long positionUs) {
     HlsChunkSource defaultChunkSource =
         new HlsChunkSource(
             extractorFactory,
             playlistTracker,
-            variants,
+            playlistUrls,
+            playlistFormats,
             dataSourceFactory,
             mediaTransferListener,
             timestampAdjusterProvider,
@@ -524,6 +730,7 @@ private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[]
         trackType,
         /* callback= */ this,
         defaultChunkSource,
+        overridingDrmInitData,
         allocator,
         positionUs,
         muxedAudioFormat,
@@ -531,6 +738,32 @@ private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[]
         eventDispatcher);
   }
 
+  private static Map<String, DrmInitData> deriveOverridingDrmInitData(
+      List<DrmInitData> sessionKeyDrmInitData) {
+    ArrayList<DrmInitData> mutableSessionKeyDrmInitData = new ArrayList<>(sessionKeyDrmInitData);
+    HashMap<String, DrmInitData> drmInitDataBySchemeType = new HashMap<>();
+    for (int i = 0; i < mutableSessionKeyDrmInitData.size(); i++) {
+      DrmInitData drmInitData = sessionKeyDrmInitData.get(i);
+      String scheme = drmInitData.schemeType;
+      // Merge any subsequent drmInitData instances that have the same scheme type. This is valid
+      // due to the assumptions documented on HlsMediaSource.Builder.setUseSessionKeys, and is
+      // necessary to get data for different CDNs (e.g. Widevine and PlayReady) into a single
+      // drmInitData.
+      int j = i + 1;
+      while (j < mutableSessionKeyDrmInitData.size()) {
+        DrmInitData nextDrmInitData = mutableSessionKeyDrmInitData.get(j);
+        if (TextUtils.equals(nextDrmInitData.schemeType, scheme)) {
+          drmInitData = drmInitData.merge(nextDrmInitData);
+          mutableSessionKeyDrmInitData.remove(j);
+        } else {
+          j++;
+        }
+      }
+      drmInitDataBySchemeType.put(scheme, drmInitData);
+    }
+    return drmInitDataBySchemeType;
+  }
+
   private static Format deriveVideoFormat(Format variantFormat) {
     String codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_VIDEO);
     String sampleMimeType = MimeTypes.getMediaMimeType(codecs);
@@ -545,7 +778,8 @@ private static Format deriveVideoFormat(Format variantFormat) {
         variantFormat.height,
         variantFormat.frameRate,
         /* initializationData= */ null,
-        variantFormat.selectionFlags);
+        variantFormat.selectionFlags,
+        variantFormat.roleFlags);
   }
 
   private static Format deriveAudioFormat(
@@ -553,12 +787,14 @@ private static Format deriveAudioFormat(
     String codecs;
     int channelCount = Format.NO_VALUE;
     int selectionFlags = 0;
+    int roleFlags = 0;
     String language = null;
     String label = null;
     if (mediaTagFormat != null) {
       codecs = mediaTagFormat.codecs;
       channelCount = mediaTagFormat.channelCount;
       selectionFlags = mediaTagFormat.selectionFlags;
+      roleFlags = mediaTagFormat.roleFlags;
       language = mediaTagFormat.language;
       label = mediaTagFormat.label;
     } else {
@@ -566,7 +802,8 @@ private static Format deriveAudioFormat(
       if (isPrimaryTrackInVariant) {
         channelCount = variantFormat.channelCount;
         selectionFlags = variantFormat.selectionFlags;
-        language = variantFormat.label;
+        roleFlags = mediaTagFormat.roleFlags;
+        language = variantFormat.language;
         label = variantFormat.label;
       }
     }
@@ -583,6 +820,7 @@ private static Format deriveAudioFormat(
         /* sampleRate= */ Format.NO_VALUE,
         /* initializationData= */ null,
         selectionFlags,
+        roleFlags,
         language);
   }
 
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index a9b0c579ac..b6b874b293 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -17,11 +17,11 @@
 
 import android.net.Uri;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.BaseMediaSource;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.DefaultCompositeSequenceableLoaderFactory;
@@ -34,16 +34,14 @@
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistTracker;
+import com.google.android.exoplayer2.source.hls.playlist.FilteringHlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParserFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
-import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -64,12 +62,14 @@
 
     private HlsExtractorFactory extractorFactory;
     private HlsPlaylistParserFactory playlistParserFactory;
+    @Nullable private List<StreamKey> streamKeys;
     private HlsPlaylistTracker.Factory playlistTrackerFactory;
     private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
     private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private boolean allowChunklessPreparation;
+    private boolean useSessionKeys;
     private boolean isCreateCalled;
-    private @Nullable Object tag;
+    @Nullable private Object tag;
 
     /**
      * Creates a new factory for {@link HlsMediaSource}s.
@@ -164,8 +164,8 @@ public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
     }
 
     /**
-     * Sets the factory from which playlist parsers will be obtained. The default value is created
-     * by calling {@link DefaultHlsPlaylistParserFactory#DefaultHlsPlaylistParserFactory()}.
+     * Sets the factory from which playlist parsers will be obtained. The default value is a {@link
+     * DefaultHlsPlaylistParserFactory}.
      *
      * @param playlistParserFactory An {@link HlsPlaylistParserFactory}.
      * @return This factory, for convenience.
@@ -177,6 +177,19 @@ public Factory setPlaylistParserFactory(HlsPlaylistParserFactory playlistParserF
       return this;
     }
 
+    /**
+     * Sets a list of {@link StreamKey stream keys} by which the playlists are filtered.
+     *
+     * @param streamKeys A list of {@link StreamKey stream keys}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setStreamKeys(List<StreamKey> streamKeys) {
+      Assertions.checkState(!isCreateCalled);
+      this.streamKeys = streamKeys;
+      return this;
+    }
+
     /**
      * Sets the {@link HlsPlaylistTracker} factory. The default value is {@link
      * DefaultHlsPlaylistTracker#FACTORY}.
@@ -224,6 +237,20 @@ public Factory setAllowChunklessPreparation(boolean allowChunklessPreparation) {
       return this;
     }
 
+    /**
+     * Sets whether to use #EXT-X-SESSION-KEY tags provided in the master playlist. If enabled, it's
+     * assumed that any single session key declared in the master playlist can be used to obtain all
+     * of the keys required for playback. For media where this is not true, this option should not
+     * be enabled.
+     *
+     * @param useSessionKeys Whether to use #EXT-X-SESSION-KEY tags.
+     * @return This factory, for convenience.
+     */
+    public Factory setUseSessionKeys(boolean useSessionKeys) {
+      this.useSessionKeys = useSessionKeys;
+      return this;
+    }
+
     /**
      * Returns a new {@link HlsMediaSource} using the current parameters.
      *
@@ -232,6 +259,10 @@ public Factory setAllowChunklessPreparation(boolean allowChunklessPreparation) {
     @Override
     public HlsMediaSource createMediaSource(Uri playlistUri) {
       isCreateCalled = true;
+      if (streamKeys != null) {
+        playlistParserFactory =
+            new FilteringHlsPlaylistParserFactory(playlistParserFactory, streamKeys);
+      }
       return new HlsMediaSource(
           playlistUri,
           hlsDataSourceFactory,
@@ -241,6 +272,7 @@ public HlsMediaSource createMediaSource(Uri playlistUri) {
           playlistTrackerFactory.createTracker(
               hlsDataSourceFactory, loadErrorHandlingPolicy, playlistParserFactory),
           allowChunklessPreparation,
+          useSessionKeys,
           tag);
     }
 
@@ -273,104 +305,12 @@ public HlsMediaSource createMediaSource(
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final boolean allowChunklessPreparation;
+  private final boolean useSessionKeys;
   private final HlsPlaylistTracker playlistTracker;
   private final @Nullable Object tag;
 
   private @Nullable TransferListener mediaTransferListener;
 
-  /**
-   * @param manifestUri The {@link Uri} of the HLS manifest.
-   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
-   *     segments and keys.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A {@link MediaSourceEventListener}. May be null if delivery of events is
-   *     not required.
-   * @deprecated Use {@link Factory} instead.
-   */
-  @Deprecated
-  @SuppressWarnings("deprecation")
-  public HlsMediaSource(
-      Uri manifestUri,
-      DataSource.Factory dataSourceFactory,
-      Handler eventHandler,
-      MediaSourceEventListener eventListener) {
-    this(
-        manifestUri,
-        dataSourceFactory,
-        DefaultLoadErrorHandlingPolicy.DEFAULT_MIN_LOADABLE_RETRY_COUNT,
-        eventHandler,
-        eventListener);
-  }
-
-  /**
-   * @param manifestUri The {@link Uri} of the HLS manifest.
-   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
-   *     segments and keys.
-   * @param minLoadableRetryCount The minimum number of times loads must be retried before errors
-   *     are propagated.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A {@link MediaSourceEventListener}. May be null if delivery of events is
-   *     not required.
-   * @deprecated Use {@link Factory} instead.
-   */
-  @Deprecated
-  @SuppressWarnings("deprecation")
-  public HlsMediaSource(
-      Uri manifestUri,
-      DataSource.Factory dataSourceFactory,
-      int minLoadableRetryCount,
-      Handler eventHandler,
-      MediaSourceEventListener eventListener) {
-    this(
-        manifestUri,
-        new DefaultHlsDataSourceFactory(dataSourceFactory),
-        HlsExtractorFactory.DEFAULT,
-        minLoadableRetryCount,
-        eventHandler,
-        eventListener,
-        new HlsPlaylistParser());
-  }
-
-  /**
-   * @param manifestUri The {@link Uri} of the HLS manifest.
-   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
-   *     segments and keys.
-   * @param extractorFactory An {@link HlsExtractorFactory} for {@link Extractor}s for the segments.
-   * @param minLoadableRetryCount The minimum number of times loads must be retried before errors
-   *     are propagated.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A {@link MediaSourceEventListener}. May be null if delivery of events is
-   *     not required.
-   * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
-   * @deprecated Use {@link Factory} instead.
-   */
-  @Deprecated
-  @SuppressWarnings("deprecation")
-  public HlsMediaSource(
-      Uri manifestUri,
-      HlsDataSourceFactory dataSourceFactory,
-      HlsExtractorFactory extractorFactory,
-      int minLoadableRetryCount,
-      Handler eventHandler,
-      MediaSourceEventListener eventListener,
-      ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
-    this(
-        manifestUri,
-        dataSourceFactory,
-        extractorFactory,
-        new DefaultCompositeSequenceableLoaderFactory(),
-        new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
-        new DefaultHlsPlaylistTracker(
-            dataSourceFactory,
-            new DefaultLoadErrorHandlingPolicy(minLoadableRetryCount),
-            playlistParser),
-        /* allowChunklessPreparation= */ false,
-        /* tag= */ null);
-    if (eventHandler != null && eventListener != null) {
-      addEventListener(eventHandler, eventListener);
-    }
-  }
-
   private HlsMediaSource(
       Uri manifestUri,
       HlsDataSourceFactory dataSourceFactory,
@@ -379,6 +319,7 @@ private HlsMediaSource(
       LoadErrorHandlingPolicy loadErrorHandlingPolicy,
       HlsPlaylistTracker playlistTracker,
       boolean allowChunklessPreparation,
+      boolean useSessionKeys,
       @Nullable Object tag) {
     this.manifestUri = manifestUri;
     this.dataSourceFactory = dataSourceFactory;
@@ -387,6 +328,7 @@ private HlsMediaSource(
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.playlistTracker = playlistTracker;
     this.allowChunklessPreparation = allowChunklessPreparation;
+    this.useSessionKeys = useSessionKeys;
     this.tag = tag;
   }
 
@@ -397,10 +339,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     EventDispatcher eventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
     playlistTracker.start(manifestUri, eventDispatcher, /* listener= */ this);
@@ -412,7 +351,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     EventDispatcher eventDispatcher = createEventDispatcher(id);
     return new HlsMediaPeriod(
         extractorFactory,
@@ -423,7 +362,8 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
         eventDispatcher,
         allocator,
         compositeSequenceableLoaderFactory,
-        allowChunklessPreparation);
+        allowChunklessPreparation,
+        useSessionKeys);
   }
 
   @Override
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index f43d119018..cf879e91c6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -68,6 +68,10 @@ public void maybeThrowError() throws IOException {
 
   @Override
   public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean requireFormat) {
+    if (sampleQueueIndex == HlsSampleStreamWrapper.SAMPLE_QUEUE_INDEX_NO_MAPPING_NON_FATAL) {
+      buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+      return C.RESULT_BUFFER_READ;
+    }
     return hasValidSampleQueueIndex()
         ? sampleStreamWrapper.readData(sampleQueueIndex, formatHolder, buffer, requireFormat)
         : C.RESULT_NOTHING_READ;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 39598c4cd8..65039b9364 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
+import android.net.Uri;
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.SeekMap;
@@ -36,8 +38,6 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.Chunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
@@ -52,6 +52,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Loads {@link HlsMediaChunk}s obtained from a {@link HlsChunkSource}, and provides
@@ -67,6 +68,9 @@
 
     /**
      * Called when the wrapper has been prepared.
+     *
+     * <p>Note: This method will be called on a later handler loop than the one on which either
+     * {@link #prepareWithMasterPlaylistInfo} or {@link #continuePreparing} are invoked.
      */
     void onPrepared();
 
@@ -74,8 +78,7 @@
      * Called to schedule a {@link #continueLoading(long)} call when the playlist referred by the
      * given url changes.
      */
-    void onPlaylistRefreshRequired(HlsMasterPlaylist.HlsUrl playlistUrl);
-
+    void onPlaylistRefreshRequired(Uri playlistUrl);
   }
 
   private static final String TAG = "HlsSampleStreamWrapper";
@@ -99,6 +102,7 @@
   private final Runnable onTracksEndedRunnable;
   private final Handler handler;
   private final ArrayList<HlsSampleStream> hlsSampleStreams;
+  private final Map<String, DrmInitData> overridingDrmInitData;
 
   private SampleQueue[] sampleQueues;
   private int[] sampleQueueTrackIds;
@@ -141,6 +145,10 @@
    * @param trackType The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
    * @param callback A callback for the wrapper.
    * @param chunkSource A {@link HlsChunkSource} from which chunks to load are obtained.
+   * @param overridingDrmInitData Overriding {@link DrmInitData}, keyed by protection scheme type
+   *     (i.e. {@link DrmInitData#schemeType}). If the stream has {@link DrmInitData} and uses a
+   *     protection scheme type for which overriding {@link DrmInitData} is provided, then the
+   *     stream's {@link DrmInitData} will be overridden.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    * @param positionUs The position from which to start loading media.
    * @param muxedAudioFormat Optional muxed audio {@link Format} as defined by the master playlist.
@@ -151,6 +159,7 @@ public HlsSampleStreamWrapper(
       int trackType,
       Callback callback,
       HlsChunkSource chunkSource,
+      Map<String, DrmInitData> overridingDrmInitData,
       Allocator allocator,
       long positionUs,
       Format muxedAudioFormat,
@@ -159,6 +168,7 @@ public HlsSampleStreamWrapper(
     this.trackType = trackType;
     this.callback = callback;
     this.chunkSource = chunkSource;
+    this.overridingDrmInitData = overridingDrmInitData;
     this.allocator = allocator;
     this.muxedAudioFormat = muxedAudioFormat;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
@@ -203,7 +213,7 @@ public void prepareWithMasterPlaylistInfo(
     this.trackGroups = trackGroups;
     this.optionalTrackGroups = optionalTrackGroups;
     this.primaryTrackGroupIndex = primaryTrackGroupIndex;
-    callback.onPrepared();
+    handler.post(callback::onPrepared);
   }
 
   public void maybeThrowPrepareError() throws IOException {
@@ -214,6 +224,10 @@ public TrackGroupArray getTrackGroups() {
     return trackGroups;
   }
 
+  public int getPrimaryTrackGroupIndex() {
+    return primaryTrackGroupIndex;
+  }
+
   public int bindSampleQueueToSampleStream(int trackGroupIndex) {
     int sampleQueueIndex = trackGroupToSampleQueueIndex[trackGroupIndex];
     if (sampleQueueIndex == C.INDEX_UNSET) {
@@ -435,8 +449,8 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
     chunkSource.setIsTimestampMaster(isTimestampMaster);
   }
 
-  public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
-    return chunkSource.onPlaylistError(url, blacklistDurationMs);
+  public boolean onPlaylistError(Uri playlistUrl, long blacklistDurationMs) {
+    return chunkSource.onPlaylistError(playlistUrl, blacklistDurationMs);
   }
 
   // SampleStream implementation.
@@ -477,18 +491,28 @@ public int readData(int sampleQueueIndex, FormatHolder formatHolder, DecoderInpu
     int result =
         sampleQueues[sampleQueueIndex].read(
             formatHolder, buffer, requireFormat, loadingFinished, lastSeekPositionUs);
-    if (result == C.RESULT_FORMAT_READ && sampleQueueIndex == primarySampleQueueIndex) {
-      // Fill in primary sample format with information from the track format.
-      int chunkUid = sampleQueues[sampleQueueIndex].peekSourceId();
-      int chunkIndex = 0;
-      while (chunkIndex < mediaChunks.size() && mediaChunks.get(chunkIndex).uid != chunkUid) {
-        chunkIndex++;
+    if (result == C.RESULT_FORMAT_READ) {
+      Format format = formatHolder.format;
+      if (sampleQueueIndex == primarySampleQueueIndex) {
+        // Fill in primary sample format with information from the track format.
+        int chunkUid = sampleQueues[sampleQueueIndex].peekSourceId();
+        int chunkIndex = 0;
+        while (chunkIndex < mediaChunks.size() && mediaChunks.get(chunkIndex).uid != chunkUid) {
+          chunkIndex++;
+        }
+        Format trackFormat =
+            chunkIndex < mediaChunks.size()
+                ? mediaChunks.get(chunkIndex).trackFormat
+                : upstreamTrackFormat;
+        format = format.copyWithManifestFormatInfo(trackFormat);
+      }
+      if (format.drmInitData != null) {
+        DrmInitData drmInitData = overridingDrmInitData.get(format.drmInitData.schemeType);
+        if (drmInitData != null) {
+          format = format.copyWithDrmInitData(drmInitData);
+        }
       }
-      Format trackFormat =
-          chunkIndex < mediaChunks.size()
-              ? mediaChunks.get(chunkIndex).trackFormat
-              : upstreamTrackFormat;
-      formatHolder.format = formatHolder.format.copyWithManifestFormatInfo(trackFormat);
+      formatHolder.format = format;
     }
     return result;
   }
@@ -564,7 +588,7 @@ public boolean continueLoading(long positionUs) {
     chunkSource.getNextChunk(positionUs, loadPositionUs, chunkQueue, nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
-    HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
+    Uri playlistUrlToLoad = nextChunkHolder.playlistUrl;
     nextChunkHolder.clear();
 
     if (endOfStream) {
@@ -574,8 +598,8 @@ public boolean continueLoading(long positionUs) {
     }
 
     if (loadable == null) {
-      if (playlistToLoad != null) {
-        callback.onPlaylistRefreshRequired(playlistToLoad);
+      if (playlistUrlToLoad != null) {
+        callback.onPlaylistRefreshRequired(playlistUrlToLoad);
       }
       return false;
     }
@@ -1087,6 +1111,10 @@ private static Format deriveFormat(
       return sampleFormat;
     }
     int bitrate = propagateBitrate ? playlistFormat.bitrate : Format.NO_VALUE;
+    int channelCount =
+        playlistFormat.channelCount != Format.NO_VALUE
+            ? playlistFormat.channelCount
+            : sampleFormat.channelCount;
     int sampleTrackType = MimeTypes.getTrackType(sampleFormat.sampleMimeType);
     String codecs = Util.getCodecsOfType(playlistFormat.codecs, sampleTrackType);
     String mimeType = MimeTypes.getMediaMimeType(codecs);
@@ -1098,9 +1126,11 @@ private static Format deriveFormat(
         playlistFormat.label,
         mimeType,
         codecs,
+        playlistFormat.metadata,
         bitrate,
         playlistFormat.width,
         playlistFormat.height,
+        channelCount,
         playlistFormat.selectionFlags,
         playlistFormat.language);
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsTrackMetadataEntry.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsTrackMetadataEntry.java
new file mode 100644
index 0000000000..14268313eb
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsTrackMetadataEntry.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import android.text.TextUtils;
+import com.google.android.exoplayer2.metadata.Metadata;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/** Holds metadata associated to an HLS media track. */
+public final class HlsTrackMetadataEntry implements Metadata.Entry {
+
+  /** Holds attributes defined in an EXT-X-STREAM-INF tag. */
+  public static final class VariantInfo implements Parcelable {
+
+    /** The bitrate as declared by the EXT-X-STREAM-INF tag. */
+    public final long bitrate;
+
+    /**
+     * The VIDEO value as defined in the EXT-X-STREAM-INF tag, or null if the VIDEO attribute is not
+     * present.
+     */
+    @Nullable public final String videoGroupId;
+
+    /**
+     * The AUDIO value as defined in the EXT-X-STREAM-INF tag, or null if the AUDIO attribute is not
+     * present.
+     */
+    @Nullable public final String audioGroupId;
+
+    /**
+     * The SUBTITLES value as defined in the EXT-X-STREAM-INF tag, or null if the SUBTITLES
+     * attribute is not present.
+     */
+    @Nullable public final String subtitleGroupId;
+
+    /**
+     * The CLOSED-CAPTIONS value as defined in the EXT-X-STREAM-INF tag, or null if the
+     * CLOSED-CAPTIONS attribute is not present.
+     */
+    @Nullable public final String captionGroupId;
+
+    /**
+     * Creates an instance.
+     *
+     * @param bitrate See {@link #bitrate}.
+     * @param videoGroupId See {@link #videoGroupId}.
+     * @param audioGroupId See {@link #audioGroupId}.
+     * @param subtitleGroupId See {@link #subtitleGroupId}.
+     * @param captionGroupId See {@link #captionGroupId}.
+     */
+    public VariantInfo(
+        long bitrate,
+        @Nullable String videoGroupId,
+        @Nullable String audioGroupId,
+        @Nullable String subtitleGroupId,
+        @Nullable String captionGroupId) {
+      this.bitrate = bitrate;
+      this.videoGroupId = videoGroupId;
+      this.audioGroupId = audioGroupId;
+      this.subtitleGroupId = subtitleGroupId;
+      this.captionGroupId = captionGroupId;
+    }
+
+    /* package */ VariantInfo(Parcel in) {
+      bitrate = in.readLong();
+      videoGroupId = in.readString();
+      audioGroupId = in.readString();
+      subtitleGroupId = in.readString();
+      captionGroupId = in.readString();
+    }
+
+    @Override
+    public boolean equals(@Nullable Object other) {
+      if (this == other) {
+        return true;
+      }
+      if (other == null || getClass() != other.getClass()) {
+        return false;
+      }
+      VariantInfo that = (VariantInfo) other;
+      return bitrate == that.bitrate
+          && TextUtils.equals(videoGroupId, that.videoGroupId)
+          && TextUtils.equals(audioGroupId, that.audioGroupId)
+          && TextUtils.equals(subtitleGroupId, that.subtitleGroupId)
+          && TextUtils.equals(captionGroupId, that.captionGroupId);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = (int) (bitrate ^ (bitrate >>> 32));
+      result = 31 * result + (videoGroupId != null ? videoGroupId.hashCode() : 0);
+      result = 31 * result + (audioGroupId != null ? audioGroupId.hashCode() : 0);
+      result = 31 * result + (subtitleGroupId != null ? subtitleGroupId.hashCode() : 0);
+      result = 31 * result + (captionGroupId != null ? captionGroupId.hashCode() : 0);
+      return result;
+    }
+
+    // Parcelable implementation.
+
+    @Override
+    public int describeContents() {
+      return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+      dest.writeLong(bitrate);
+      dest.writeString(videoGroupId);
+      dest.writeString(audioGroupId);
+      dest.writeString(subtitleGroupId);
+      dest.writeString(captionGroupId);
+    }
+
+    public static final Parcelable.Creator<VariantInfo> CREATOR =
+        new Parcelable.Creator<VariantInfo>() {
+          @Override
+          public VariantInfo createFromParcel(Parcel in) {
+            return new VariantInfo(in);
+          }
+
+          @Override
+          public VariantInfo[] newArray(int size) {
+            return new VariantInfo[size];
+          }
+        };
+  }
+
+  /**
+   * The GROUP-ID value of this track, if the track is derived from an EXT-X-MEDIA tag. Null if the
+   * track is not derived from an EXT-X-MEDIA TAG.
+   */
+  @Nullable public final String groupId;
+  /**
+   * The NAME value of this track, if the track is derived from an EXT-X-MEDIA tag. Null if the
+   * track is not derived from an EXT-X-MEDIA TAG.
+   */
+  @Nullable public final String name;
+  /**
+   * The EXT-X-STREAM-INF tags attributes associated with this track. This field is non-applicable
+   * (and therefore empty) if this track is derived from an EXT-X-MEDIA tag.
+   */
+  public final List<VariantInfo> variantInfos;
+
+  /**
+   * Creates an instance.
+   *
+   * @param groupId See {@link #groupId}.
+   * @param name See {@link #name}.
+   * @param variantInfos See {@link #variantInfos}.
+   */
+  public HlsTrackMetadataEntry(
+      @Nullable String groupId, @Nullable String name, List<VariantInfo> variantInfos) {
+    this.groupId = groupId;
+    this.name = name;
+    this.variantInfos = Collections.unmodifiableList(new ArrayList<>(variantInfos));
+  }
+
+  /* package */ HlsTrackMetadataEntry(Parcel in) {
+    groupId = in.readString();
+    name = in.readString();
+    int variantInfoSize = in.readInt();
+    ArrayList<VariantInfo> variantInfos = new ArrayList<>(variantInfoSize);
+    for (int i = 0; i < variantInfoSize; i++) {
+      variantInfos.add(in.readParcelable(VariantInfo.class.getClassLoader()));
+    }
+    this.variantInfos = Collections.unmodifiableList(variantInfos);
+  }
+
+  @Override
+  public boolean equals(@Nullable Object other) {
+    if (this == other) {
+      return true;
+    }
+    if (other == null || getClass() != other.getClass()) {
+      return false;
+    }
+
+    HlsTrackMetadataEntry that = (HlsTrackMetadataEntry) other;
+    return TextUtils.equals(groupId, that.groupId)
+        && TextUtils.equals(name, that.name)
+        && variantInfos.equals(that.variantInfos);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = groupId != null ? groupId.hashCode() : 0;
+    result = 31 * result + (name != null ? name.hashCode() : 0);
+    result = 31 * result + variantInfos.hashCode();
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(groupId);
+    dest.writeString(name);
+    int variantInfosSize = variantInfos.size();
+    dest.writeInt(variantInfosSize);
+    for (int i = 0; i < variantInfosSize; i++) {
+      dest.writeParcelable(variantInfos.get(i), /* parcelableFlags= */ 0);
+    }
+  }
+
+  public static final Parcelable.Creator<HlsTrackMetadataEntry> CREATOR =
+      new Parcelable.Creator<HlsTrackMetadataEntry>() {
+        @Override
+        public HlsTrackMetadataEntry createFromParcel(Parcel in) {
+          return new HlsTrackMetadataEntry(in);
+        }
+
+        @Override
+        public HlsTrackMetadataEntry[] newArray(int size) {
+          return new HlsTrackMetadataEntry[size];
+        }
+      };
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java
index 9c9cb532a6..38b18da50b 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.TrackGroup;
 import java.io.IOException;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java
deleted file mode 100644
index c54a9a7dd3..0000000000
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadAction.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.offline.DownloadAction;
-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.SegmentDownloadAction;
-import com.google.android.exoplayer2.offline.StreamKey;
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-
-/** An action to download or remove downloaded HLS streams. */
-public final class HlsDownloadAction extends SegmentDownloadAction {
-
-  private static final String TYPE = "hls";
-  private static final int VERSION = 1;
-
-  public static final Deserializer DESERIALIZER =
-      new SegmentDownloadActionDeserializer(TYPE, VERSION) {
-
-        @Override
-        protected StreamKey readKey(int version, DataInputStream input) throws IOException {
-          if (version > 0) {
-            return super.readKey(version, input);
-          }
-          int renditionGroup = input.readInt();
-          int trackIndex = input.readInt();
-          return new StreamKey(renditionGroup, trackIndex);
-        }
-
-        @Override
-        protected DownloadAction createDownloadAction(
-            Uri uri, boolean isRemoveAction, byte[] data, List<StreamKey> keys) {
-          return new HlsDownloadAction(uri, isRemoveAction, data, keys);
-        }
-      };
-
-  /**
-   * Creates a HLS download action.
-   *
-   * @param uri The URI of the media to be downloaded.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded.
-   */
-  public static HlsDownloadAction createDownloadAction(
-      Uri uri, @Nullable byte[] data, List<StreamKey> keys) {
-    return new HlsDownloadAction(uri, /* isRemoveAction= */ false, data, keys);
-  }
-
-  /**
-   * Creates a HLS remove action.
-   *
-   * @param uri The URI of the media to be removed.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   */
-  public static HlsDownloadAction createRemoveAction(Uri uri, @Nullable byte[] data) {
-    return new HlsDownloadAction(uri, /* isRemoveAction= */ true, data, Collections.emptyList());
-  }
-
-  /**
-   * @param uri The HLS playlist URI.
-   * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
-   * @param data Optional custom data for this action.
-   * @param keys Keys of renditions to be downloaded. If empty, all renditions are downloaded. If
-   *     {@code removeAction} is true, {@code keys} must empty.
-   * @deprecated Use {@link #createDownloadAction(Uri, byte[], List)} or {@link
-   *     #createRemoveAction(Uri, byte[])}.
-   */
-  @Deprecated
-  public HlsDownloadAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<StreamKey> keys) {
-    super(TYPE, VERSION, uri, isRemoveAction, data, keys);
-  }
-
-  @Override
-  public HlsDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
-    return new HlsDownloader(uri, keys, constructorHelper);
-  }
-
-}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
deleted file mode 100644
index fcbe06993e..0000000000
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.offline.DownloadHelper;
-import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.offline.TrackKey;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.ParsingLoadable;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
-
-/** A {@link DownloadHelper} for HLS streams. */
-public final class HlsDownloadHelper extends DownloadHelper {
-
-  private final Uri uri;
-  private final DataSource.Factory manifestDataSourceFactory;
-
-  private @MonotonicNonNull HlsPlaylist playlist;
-  private int[] renditionGroups;
-
-  public HlsDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory) {
-    this.uri = uri;
-    this.manifestDataSourceFactory = manifestDataSourceFactory;
-  }
-
-  @Override
-  protected void prepareInternal() throws IOException {
-    DataSource dataSource = manifestDataSourceFactory.createDataSource();
-    playlist = ParsingLoadable.load(dataSource, new HlsPlaylistParser(), uri, C.DATA_TYPE_MANIFEST);
-  }
-
-  /** Returns the HLS playlist. Must not be called until after preparation completes. */
-  public HlsPlaylist getPlaylist() {
-    Assertions.checkNotNull(playlist);
-    return playlist;
-  }
-
-  @Override
-  public int getPeriodCount() {
-    Assertions.checkNotNull(playlist);
-    return 1;
-  }
-
-  @Override
-  public TrackGroupArray getTrackGroups(int periodIndex) {
-    Assertions.checkNotNull(playlist);
-    if (playlist instanceof HlsMediaPlaylist) {
-      renditionGroups = new int[0];
-      return TrackGroupArray.EMPTY;
-    }
-    // TODO: Generate track groups as in playback. Reverse the mapping in getDownloadAction.
-    HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
-    TrackGroup[] trackGroups = new TrackGroup[3];
-    renditionGroups = new int[3];
-    int trackGroupIndex = 0;
-    if (!masterPlaylist.variants.isEmpty()) {
-      renditionGroups[trackGroupIndex] = HlsMasterPlaylist.GROUP_INDEX_VARIANT;
-      trackGroups[trackGroupIndex++] = new TrackGroup(toFormats(masterPlaylist.variants));
-    }
-    if (!masterPlaylist.audios.isEmpty()) {
-      renditionGroups[trackGroupIndex] = HlsMasterPlaylist.GROUP_INDEX_AUDIO;
-      trackGroups[trackGroupIndex++] = new TrackGroup(toFormats(masterPlaylist.audios));
-    }
-    if (!masterPlaylist.subtitles.isEmpty()) {
-      renditionGroups[trackGroupIndex] = HlsMasterPlaylist.GROUP_INDEX_SUBTITLE;
-      trackGroups[trackGroupIndex++] = new TrackGroup(toFormats(masterPlaylist.subtitles));
-    }
-    return new TrackGroupArray(Arrays.copyOf(trackGroups, trackGroupIndex));
-  }
-
-  @Override
-  public HlsDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    Assertions.checkNotNull(renditionGroups);
-    return HlsDownloadAction.createDownloadAction(
-        uri, data, toStreamKeys(trackKeys, renditionGroups));
-  }
-
-  @Override
-  public HlsDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return HlsDownloadAction.createRemoveAction(uri, data);
-  }
-
-  private static Format[] toFormats(List<HlsMasterPlaylist.HlsUrl> hlsUrls) {
-    Format[] formats = new Format[hlsUrls.size()];
-    for (int i = 0; i < hlsUrls.size(); i++) {
-      formats[i] = hlsUrls.get(i).format;
-    }
-    return formats;
-  }
-
-  private static List<StreamKey> toStreamKeys(List<TrackKey> trackKeys, int[] groups) {
-    List<StreamKey> representationKeys = new ArrayList<>(trackKeys.size());
-    for (int i = 0; i < trackKeys.size(); i++) {
-      TrackKey trackKey = trackKeys.get(i);
-      representationKeys.add(new StreamKey(groups[trackKey.groupIndex], trackKey.trackIndex));
-    }
-    return representationKeys;
-  }
-}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
index 85f41df359..6e6d0afd49 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.offline.SegmentDownloader;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
@@ -40,7 +39,7 @@
  * <p>Example usage:
  *
  * <pre>{@code
- * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor());
+ * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor(), databaseProvider);
  * DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
  * DownloaderConstructorHelper constructorHelper =
  *     new DownloaderConstructorHelper(cache, factory);
@@ -51,7 +50,7 @@
  *         Collections.singletonList(new StreamKey(HlsMasterPlaylist.GROUP_INDEX_VARIANT, 0)),
  *         constructorHelper);
  * // Perform the download.
- * hlsDownloader.download();
+ * hlsDownloader.download(progressListener);
  * // Access downloaded data using CacheDataSource
  * CacheDataSource cacheDataSource =
  *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
@@ -71,35 +70,34 @@ public HlsDownloader(
   }
 
   @Override
-  protected HlsPlaylist getManifest(DataSource dataSource, Uri uri) throws IOException {
-    return loadManifest(dataSource, uri);
+  protected HlsPlaylist getManifest(DataSource dataSource, DataSpec dataSpec) throws IOException {
+    return loadManifest(dataSource, dataSpec);
   }
 
   @Override
   protected List<Segment> getSegments(
       DataSource dataSource, HlsPlaylist playlist, boolean allowIncompleteList) throws IOException {
-    ArrayList<Uri> mediaPlaylistUris = new ArrayList<>();
+    ArrayList<DataSpec> mediaPlaylistDataSpecs = new ArrayList<>();
     if (playlist instanceof HlsMasterPlaylist) {
       HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
-      addResolvedUris(masterPlaylist.baseUri, masterPlaylist.variants, mediaPlaylistUris);
-      addResolvedUris(masterPlaylist.baseUri, masterPlaylist.audios, mediaPlaylistUris);
-      addResolvedUris(masterPlaylist.baseUri, masterPlaylist.subtitles, mediaPlaylistUris);
+      addMediaPlaylistDataSpecs(masterPlaylist.mediaPlaylistUrls, mediaPlaylistDataSpecs);
     } else {
-      mediaPlaylistUris.add(Uri.parse(playlist.baseUri));
+      mediaPlaylistDataSpecs.add(
+          SegmentDownloader.getCompressibleDataSpec(Uri.parse(playlist.baseUri)));
     }
-    ArrayList<Segment> segments = new ArrayList<>();
 
+    ArrayList<Segment> segments = new ArrayList<>();
     HashSet<Uri> seenEncryptionKeyUris = new HashSet<>();
-    for (Uri mediaPlaylistUri : mediaPlaylistUris) {
+    for (DataSpec mediaPlaylistDataSpec : mediaPlaylistDataSpecs) {
+      segments.add(new Segment(/* startTimeUs= */ 0, mediaPlaylistDataSpec));
       HlsMediaPlaylist mediaPlaylist;
       try {
-        mediaPlaylist = (HlsMediaPlaylist) loadManifest(dataSource, mediaPlaylistUri);
-        segments.add(new Segment(mediaPlaylist.startTimeUs, new DataSpec(mediaPlaylistUri)));
+        mediaPlaylist = (HlsMediaPlaylist) loadManifest(dataSource, mediaPlaylistDataSpec);
       } catch (IOException e) {
         if (!allowIncompleteList) {
           throw e;
         }
-        segments.add(new Segment(0, new DataSpec(mediaPlaylistUri)));
+        // Generating an incomplete segment list is allowed. Advance to the next media playlist.
         continue;
       }
       HlsMediaPlaylist.Segment lastInitSegment = null;
@@ -109,39 +107,42 @@ protected HlsPlaylist getManifest(DataSource dataSource, Uri uri) throws IOExcep
         HlsMediaPlaylist.Segment initSegment = segment.initializationSegment;
         if (initSegment != null && initSegment != lastInitSegment) {
           lastInitSegment = initSegment;
-          addSegment(segments, mediaPlaylist, initSegment, seenEncryptionKeyUris);
+          addSegment(mediaPlaylist, initSegment, seenEncryptionKeyUris, segments);
         }
-        addSegment(segments, mediaPlaylist, segment, seenEncryptionKeyUris);
+        addSegment(mediaPlaylist, segment, seenEncryptionKeyUris, segments);
       }
     }
     return segments;
   }
 
-  private static HlsPlaylist loadManifest(DataSource dataSource, Uri uri) throws IOException {
-    return ParsingLoadable.load(dataSource, new HlsPlaylistParser(), uri, C.DATA_TYPE_MANIFEST);
+  private void addMediaPlaylistDataSpecs(List<Uri> mediaPlaylistUrls, List<DataSpec> out) {
+    for (int i = 0; i < mediaPlaylistUrls.size(); i++) {
+      out.add(SegmentDownloader.getCompressibleDataSpec(mediaPlaylistUrls.get(i)));
+    }
+  }
+
+  private static HlsPlaylist loadManifest(DataSource dataSource, DataSpec dataSpec)
+      throws IOException {
+    return ParsingLoadable.load(
+        dataSource, new HlsPlaylistParser(), dataSpec, C.DATA_TYPE_MANIFEST);
   }
 
-  private static void addSegment(
-      ArrayList<Segment> segments,
+  private void addSegment(
       HlsMediaPlaylist mediaPlaylist,
-      HlsMediaPlaylist.Segment hlsSegment,
-      HashSet<Uri> seenEncryptionKeyUris) {
-    long startTimeUs = mediaPlaylist.startTimeUs + hlsSegment.relativeStartTimeUs;
-    if (hlsSegment.fullSegmentEncryptionKeyUri != null) {
-      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri,
-          hlsSegment.fullSegmentEncryptionKeyUri);
+      HlsMediaPlaylist.Segment segment,
+      HashSet<Uri> seenEncryptionKeyUris,
+      ArrayList<Segment> out) {
+    String baseUri = mediaPlaylist.baseUri;
+    long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
+    if (segment.fullSegmentEncryptionKeyUri != null) {
+      Uri keyUri = UriUtil.resolveToUri(baseUri, segment.fullSegmentEncryptionKeyUri);
       if (seenEncryptionKeyUris.add(keyUri)) {
-        segments.add(new Segment(startTimeUs, new DataSpec(keyUri)));
+        out.add(new Segment(startTimeUs, SegmentDownloader.getCompressibleDataSpec(keyUri)));
       }
     }
-    Uri resolvedUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, hlsSegment.url);
-    segments.add(new Segment(startTimeUs,
-        new DataSpec(resolvedUri, hlsSegment.byterangeOffset, hlsSegment.byterangeLength, null)));
-  }
-
-  private static void addResolvedUris(String baseUri, List<HlsUrl> urls, List<Uri> out) {
-    for (int i = 0; i < urls.size(); i++) {
-      out.add(UriUtil.resolveToUri(baseUri, urls.get(i).url));
-    }
+    Uri segmentUri = UriUtil.resolveToUri(baseUri, segment.url);
+    DataSpec dataSpec =
+        new DataSpec(segmentUri, segment.byterangeOffset, segment.byterangeLength, /* key= */ null);
+    out.add(new Segment(startTimeUs, dataSpec));
   }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java
index 9058980c73..d185e2a3e8 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistParserFactory.java
@@ -15,40 +15,19 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
-import com.google.android.exoplayer2.offline.FilteringManifestParser;
-import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
-import java.util.Collections;
-import java.util.List;
 
 /** Default implementation for {@link HlsPlaylistParserFactory}. */
 public final class DefaultHlsPlaylistParserFactory implements HlsPlaylistParserFactory {
 
-  private final List<StreamKey> streamKeys;
-
-  /** Creates an instance that does not filter any parsing results. */
-  public DefaultHlsPlaylistParserFactory() {
-    this(Collections.emptyList());
-  }
-
-  /**
-   * Creates an instance that filters the parsing results using the given {@code streamKeys}.
-   *
-   * @param streamKeys See {@link
-   *     FilteringManifestParser#FilteringManifestParser(ParsingLoadable.Parser, List)}.
-   */
-  public DefaultHlsPlaylistParserFactory(List<StreamKey> streamKeys) {
-    this.streamKeys = streamKeys;
-  }
-
   @Override
   public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser() {
-    return new FilteringManifestParser<>(new HlsPlaylistParser(), streamKeys);
+    return new HlsPlaylistParser();
   }
 
   @Override
   public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser(
       HlsMasterPlaylist masterPlaylist) {
-    return new FilteringManifestParser<>(new HlsPlaylistParser(masterPlaylist), streamKeys);
+    return new HlsPlaylistParser(masterPlaylist);
   }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
index 4269b66d30..0064338ca8 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
@@ -18,12 +18,12 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.hls.HlsDataSourceFactory;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Variant;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
@@ -31,10 +31,9 @@
 import com.google.android.exoplayer2.upstream.Loader.LoadErrorAction;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.UriUtil;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.IdentityHashMap;
+import java.util.HashMap;
 import java.util.List;
 
 /** Default implementation for {@link HlsPlaylistTracker}. */
@@ -45,59 +44,69 @@
   public static final Factory FACTORY = DefaultHlsPlaylistTracker::new;
 
   /**
-   * Coefficient applied on the target duration of a playlist to determine the amount of time after
-   * which an unchanging playlist is considered stuck.
+   * Default coefficient applied on the target duration of a playlist to determine the amount of
+   * time after which an unchanging playlist is considered stuck.
    */
-  private static final double PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT = 3.5;
+  public static final double DEFAULT_PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT = 3.5;
 
   private final HlsDataSourceFactory dataSourceFactory;
   private final HlsPlaylistParserFactory playlistParserFactory;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
-  private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
+  private final HashMap<Uri, MediaPlaylistBundle> playlistBundles;
   private final List<PlaylistEventListener> listeners;
-
-  private @Nullable ParsingLoadable.Parser<HlsPlaylist> mediaPlaylistParser;
-  private @Nullable EventDispatcher eventDispatcher;
-  private @Nullable Loader initialPlaylistLoader;
-  private @Nullable Handler playlistRefreshHandler;
-  private @Nullable PrimaryPlaylistListener primaryPlaylistListener;
-  private @Nullable HlsMasterPlaylist masterPlaylist;
-  private @Nullable HlsUrl primaryHlsUrl;
-  private @Nullable HlsMediaPlaylist primaryUrlSnapshot;
+  private final double playlistStuckTargetDurationCoefficient;
+
+  @Nullable private ParsingLoadable.Parser<HlsPlaylist> mediaPlaylistParser;
+  @Nullable private EventDispatcher eventDispatcher;
+  @Nullable private Loader initialPlaylistLoader;
+  @Nullable private Handler playlistRefreshHandler;
+  @Nullable private PrimaryPlaylistListener primaryPlaylistListener;
+  @Nullable private HlsMasterPlaylist masterPlaylist;
+  @Nullable private Uri primaryMediaPlaylistUrl;
+  @Nullable private HlsMediaPlaylist primaryMediaPlaylistSnapshot;
   private boolean isLive;
   private long initialStartTimeUs;
 
   /**
+   * Creates an instance.
+   *
    * @param dataSourceFactory A factory for {@link DataSource} instances.
    * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
-   * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
-   * @deprecated Use {@link #DefaultHlsPlaylistTracker(HlsDataSourceFactory,
-   *     LoadErrorHandlingPolicy, HlsPlaylistParserFactory)} instead. Using this constructor
-   *     prevents support for attributes that are carried over from the master playlist to the media
-   *     playlists.
+   * @param playlistParserFactory An {@link HlsPlaylistParserFactory}.
    */
-  @Deprecated
   public DefaultHlsPlaylistTracker(
       HlsDataSourceFactory dataSourceFactory,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy,
-      ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
-    this(dataSourceFactory, loadErrorHandlingPolicy, createFixedFactory(playlistParser));
+      HlsPlaylistParserFactory playlistParserFactory) {
+    this(
+        dataSourceFactory,
+        loadErrorHandlingPolicy,
+        playlistParserFactory,
+        DEFAULT_PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT);
   }
 
   /**
+   * Creates an instance.
+   *
    * @param dataSourceFactory A factory for {@link DataSource} instances.
    * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
    * @param playlistParserFactory An {@link HlsPlaylistParserFactory}.
+   * @param playlistStuckTargetDurationCoefficient A coefficient to apply to the target duration of
+   *     media playlists in order to determine that a non-changing playlist is stuck. Once a
+   *     playlist is deemed stuck, a {@link PlaylistStuckException} is thrown via {@link
+   *     #maybeThrowPlaylistRefreshError(Uri)}.
    */
   public DefaultHlsPlaylistTracker(
       HlsDataSourceFactory dataSourceFactory,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy,
-      HlsPlaylistParserFactory playlistParserFactory) {
+      HlsPlaylistParserFactory playlistParserFactory,
+      double playlistStuckTargetDurationCoefficient) {
     this.dataSourceFactory = dataSourceFactory;
     this.playlistParserFactory = playlistParserFactory;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
+    this.playlistStuckTargetDurationCoefficient = playlistStuckTargetDurationCoefficient;
     listeners = new ArrayList<>();
-    playlistBundles = new IdentityHashMap<>();
+    playlistBundles = new HashMap<>();
     initialStartTimeUs = C.TIME_UNSET;
   }
 
@@ -132,8 +141,8 @@ public void start(
 
   @Override
   public void stop() {
-    primaryHlsUrl = null;
-    primaryUrlSnapshot = null;
+    primaryMediaPlaylistUrl = null;
+    primaryMediaPlaylistSnapshot = null;
     masterPlaylist = null;
     initialStartTimeUs = C.TIME_UNSET;
     initialPlaylistLoader.release();
@@ -162,7 +171,7 @@ public void removeListener(PlaylistEventListener listener) {
   }
 
   @Override
-  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url, boolean isForPlayback) {
+  public HlsMediaPlaylist getPlaylistSnapshot(Uri url, boolean isForPlayback) {
     HlsMediaPlaylist snapshot = playlistBundles.get(url).getPlaylistSnapshot();
     if (snapshot != null && isForPlayback) {
       maybeSetPrimaryUrl(url);
@@ -176,7 +185,7 @@ public long getInitialStartTimeUs() {
   }
 
   @Override
-  public boolean isSnapshotValid(HlsUrl url) {
+  public boolean isSnapshotValid(Uri url) {
     return playlistBundles.get(url).isSnapshotValid();
   }
 
@@ -185,18 +194,18 @@ public void maybeThrowPrimaryPlaylistRefreshError() throws IOException {
     if (initialPlaylistLoader != null) {
       initialPlaylistLoader.maybeThrowError();
     }
-    if (primaryHlsUrl != null) {
-      maybeThrowPlaylistRefreshError(primaryHlsUrl);
+    if (primaryMediaPlaylistUrl != null) {
+      maybeThrowPlaylistRefreshError(primaryMediaPlaylistUrl);
     }
   }
 
   @Override
-  public void maybeThrowPlaylistRefreshError(HlsUrl url) throws IOException {
+  public void maybeThrowPlaylistRefreshError(Uri url) throws IOException {
     playlistBundles.get(url).maybeThrowPlaylistRefreshError();
   }
 
   @Override
-  public void refreshPlaylist(HlsUrl url) {
+  public void refreshPlaylist(Uri url) {
     playlistBundles.get(url).loadPlaylist();
   }
 
@@ -220,13 +229,9 @@ public void onLoadCompleted(
     }
     this.masterPlaylist = masterPlaylist;
     mediaPlaylistParser = playlistParserFactory.createPlaylistParser(masterPlaylist);
-    primaryHlsUrl = masterPlaylist.variants.get(0);
-    ArrayList<HlsUrl> urls = new ArrayList<>();
-    urls.addAll(masterPlaylist.variants);
-    urls.addAll(masterPlaylist.audios);
-    urls.addAll(masterPlaylist.subtitles);
-    createBundles(urls);
-    MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
+    primaryMediaPlaylistUrl = masterPlaylist.variants.get(0).url;
+    createBundles(masterPlaylist.mediaPlaylistUrls);
+    MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryMediaPlaylistUrl);
     if (isMediaPlaylist) {
       // We don't need to load the playlist again. We can use the same result.
       primaryBundle.processLoadedPlaylist((HlsMediaPlaylist) result, loadDurationMs);
@@ -288,13 +293,13 @@ public LoadErrorAction onLoadError(
   // Internal methods.
 
   private boolean maybeSelectNewPrimaryUrl() {
-    List<HlsUrl> variants = masterPlaylist.variants;
+    List<Variant> variants = masterPlaylist.variants;
     int variantsSize = variants.size();
     long currentTimeMs = SystemClock.elapsedRealtime();
     for (int i = 0; i < variantsSize; i++) {
-      MediaPlaylistBundle bundle = playlistBundles.get(variants.get(i));
+      MediaPlaylistBundle bundle = playlistBundles.get(variants.get(i).url);
       if (currentTimeMs > bundle.blacklistUntilMs) {
-        primaryHlsUrl = bundle.playlistUrl;
+        primaryMediaPlaylistUrl = bundle.playlistUrl;
         bundle.loadPlaylist();
         return true;
       }
@@ -302,22 +307,33 @@ private boolean maybeSelectNewPrimaryUrl() {
     return false;
   }
 
-  private void maybeSetPrimaryUrl(HlsUrl url) {
-    if (url == primaryHlsUrl
-        || !masterPlaylist.variants.contains(url)
-        || (primaryUrlSnapshot != null && primaryUrlSnapshot.hasEndTag)) {
-      // Ignore if the primary url is unchanged, if the url is not a variant url, or if the last
-      // primary snapshot contains an end tag.
+  private void maybeSetPrimaryUrl(Uri url) {
+    if (url.equals(primaryMediaPlaylistUrl)
+        || !isVariantUrl(url)
+        || (primaryMediaPlaylistSnapshot != null && primaryMediaPlaylistSnapshot.hasEndTag)) {
+      // Ignore if the primary media playlist URL is unchanged, if the media playlist is not
+      // referenced directly by a variant, or it the last primary snapshot contains an end tag.
       return;
     }
-    primaryHlsUrl = url;
-    playlistBundles.get(primaryHlsUrl).loadPlaylist();
+    primaryMediaPlaylistUrl = url;
+    playlistBundles.get(primaryMediaPlaylistUrl).loadPlaylist();
+  }
+
+  /** Returns whether any of the variants in the master playlist have the specified playlist URL. */
+  private boolean isVariantUrl(Uri playlistUrl) {
+    List<Variant> variants = masterPlaylist.variants;
+    for (int i = 0; i < variants.size(); i++) {
+      if (playlistUrl.equals(variants.get(i).url)) {
+        return true;
+      }
+    }
+    return false;
   }
 
-  private void createBundles(List<HlsUrl> urls) {
+  private void createBundles(List<Uri> urls) {
     int listSize = urls.size();
     for (int i = 0; i < listSize; i++) {
-      HlsUrl url = urls.get(i);
+      Uri url = urls.get(i);
       MediaPlaylistBundle bundle = new MediaPlaylistBundle(url);
       playlistBundles.put(url, bundle);
     }
@@ -329,14 +345,14 @@ private void createBundles(List<HlsUrl> urls) {
    * @param url The url of the playlist.
    * @param newSnapshot The new snapshot.
    */
-  private void onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
-    if (url == primaryHlsUrl) {
-      if (primaryUrlSnapshot == null) {
+  private void onPlaylistUpdated(Uri url, HlsMediaPlaylist newSnapshot) {
+    if (url.equals(primaryMediaPlaylistUrl)) {
+      if (primaryMediaPlaylistSnapshot == null) {
         // This is the first primary url snapshot.
         isLive = !newSnapshot.hasEndTag;
         initialStartTimeUs = newSnapshot.startTimeUs;
       }
-      primaryUrlSnapshot = newSnapshot;
+      primaryMediaPlaylistSnapshot = newSnapshot;
       primaryPlaylistListener.onPrimaryPlaylistRefreshed(newSnapshot);
     }
     int listenersSize = listeners.size();
@@ -345,7 +361,7 @@ private void onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
     }
   }
 
-  private boolean notifyPlaylistError(HlsUrl playlistUrl, long blacklistDurationMs) {
+  private boolean notifyPlaylistError(Uri playlistUrl, long blacklistDurationMs) {
     int listenersSize = listeners.size();
     boolean anyBlacklistingFailed = false;
     for (int i = 0; i < listenersSize; i++) {
@@ -378,7 +394,7 @@ private long getLoadedPlaylistStartTimeUs(
       return loadedPlaylist.startTimeUs;
     }
     long primarySnapshotStartTimeUs =
-        primaryUrlSnapshot != null ? primaryUrlSnapshot.startTimeUs : 0;
+        primaryMediaPlaylistSnapshot != null ? primaryMediaPlaylistSnapshot.startTimeUs : 0;
     if (oldPlaylist == null) {
       return primarySnapshotStartTimeUs;
     }
@@ -401,7 +417,9 @@ private int getLoadedPlaylistDiscontinuitySequence(
     }
     // TODO: Improve cross-playlist discontinuity adjustment.
     int primaryUrlDiscontinuitySequence =
-        primaryUrlSnapshot != null ? primaryUrlSnapshot.discontinuitySequence : 0;
+        primaryMediaPlaylistSnapshot != null
+            ? primaryMediaPlaylistSnapshot.discontinuitySequence
+            : 0;
     if (oldPlaylist == null) {
       return primaryUrlDiscontinuitySequence;
     }
@@ -425,7 +443,7 @@ private static Segment getFirstOldOverlappingSegment(
   private final class MediaPlaylistBundle
       implements Loader.Callback<ParsingLoadable<HlsPlaylist>>, Runnable {
 
-    private final HlsUrl playlistUrl;
+    private final Uri playlistUrl;
     private final Loader mediaPlaylistLoader;
     private final ParsingLoadable<HlsPlaylist> mediaPlaylistLoadable;
 
@@ -437,13 +455,13 @@ private static Segment getFirstOldOverlappingSegment(
     private boolean loadPending;
     private IOException playlistError;
 
-    public MediaPlaylistBundle(HlsUrl playlistUrl) {
+    public MediaPlaylistBundle(Uri playlistUrl) {
       this.playlistUrl = playlistUrl;
       mediaPlaylistLoader = new Loader("DefaultHlsPlaylistTracker:MediaPlaylist");
       mediaPlaylistLoadable =
           new ParsingLoadable<>(
               dataSourceFactory.createDataSource(C.DATA_TYPE_MANIFEST),
-              UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url),
+              playlistUrl,
               C.DATA_TYPE_MANIFEST,
               mediaPlaylistParser);
     }
@@ -610,13 +628,13 @@ private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist, long loadDur
           // TODO: Allow customization of playlist resets handling.
           // The media sequence jumped backwards. The server has probably reset. We do not try
           // blacklisting in this case.
-          playlistError = new PlaylistResetException(playlistUrl.url);
+          playlistError = new PlaylistResetException(playlistUrl);
           notifyPlaylistError(playlistUrl, C.TIME_UNSET);
         } else if (currentTimeMs - lastSnapshotChangeMs
             > C.usToMs(playlistSnapshot.targetDurationUs)
-                * PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT) {
+                * playlistStuckTargetDurationCoefficient) {
           // TODO: Allow customization of stuck playlists handling.
-          playlistError = new PlaylistStuckException(playlistUrl.url);
+          playlistError = new PlaylistStuckException(playlistUrl);
           long blacklistDurationMs =
               loadErrorHandlingPolicy.getBlacklistDurationMsFor(
                   C.DATA_TYPE_MANIFEST, loadDurationMs, playlistError, /* errorCount= */ 1);
@@ -637,7 +655,7 @@ private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist, long loadDur
       // Schedule a load if this is the primary playlist and it doesn't have an end tag. Else the
       // next load will be scheduled when refreshPlaylist is called, or when this playlist becomes
       // the primary.
-      if (playlistUrl == primaryHlsUrl && !playlistSnapshot.hasEndTag) {
+      if (playlistUrl.equals(primaryMediaPlaylistUrl) && !playlistSnapshot.hasEndTag) {
         loadPlaylist();
       }
     }
@@ -651,29 +669,7 @@ private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist, long loadDur
      */
     private boolean blacklistPlaylist(long blacklistDurationMs) {
       blacklistUntilMs = SystemClock.elapsedRealtime() + blacklistDurationMs;
-      return primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
+      return playlistUrl.equals(primaryMediaPlaylistUrl) && !maybeSelectNewPrimaryUrl();
     }
   }
-
-  /**
-   * Creates a factory which always returns the given playlist parser.
-   *
-   * @param playlistParser The parser to return.
-   * @return A factory which always returns the given playlist parser.
-   */
-  private static HlsPlaylistParserFactory createFixedFactory(
-      ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
-    return new HlsPlaylistParserFactory() {
-      @Override
-      public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser() {
-        return playlistParser;
-      }
-
-      @Override
-      public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser(
-          HlsMasterPlaylist masterPlaylist) {
-        return playlistParser;
-      }
-    };
-  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/FilteringHlsPlaylistParserFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/FilteringHlsPlaylistParserFactory.java
new file mode 100644
index 0000000000..2d7ad5a78a
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/FilteringHlsPlaylistParserFactory.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import com.google.android.exoplayer2.offline.FilteringManifestParser;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import java.util.List;
+
+/**
+ * A {@link HlsPlaylistParserFactory} that includes only the streams identified by the given stream
+ * keys.
+ */
+public final class FilteringHlsPlaylistParserFactory implements HlsPlaylistParserFactory {
+
+  private final HlsPlaylistParserFactory hlsPlaylistParserFactory;
+  private final List<StreamKey> streamKeys;
+
+  /**
+   * @param hlsPlaylistParserFactory A factory for the parsers of the playlists which will be
+   *     filtered.
+   * @param streamKeys The stream keys. If null or empty then filtering will not occur.
+   */
+  public FilteringHlsPlaylistParserFactory(
+      HlsPlaylistParserFactory hlsPlaylistParserFactory, List<StreamKey> streamKeys) {
+    this.hlsPlaylistParserFactory = hlsPlaylistParserFactory;
+    this.streamKeys = streamKeys;
+  }
+
+  @Override
+  public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser() {
+    return new FilteringManifestParser<>(
+        hlsPlaylistParserFactory.createPlaylistParser(), streamKeys);
+  }
+
+  @Override
+  public ParsingLoadable.Parser<HlsPlaylist> createPlaylistParser(
+      HlsMasterPlaylist masterPlaylist) {
+    return new FilteringManifestParser<>(
+        hlsPlaylistParserFactory.createPlaylistParser(masterPlaylist), streamKeys);
+  }
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index bb01ade28d..0e86df8c2f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
+import android.net.Uri;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.ArrayList;
@@ -32,38 +35,72 @@
           /* baseUri= */ "",
           /* tags= */ Collections.emptyList(),
           /* variants= */ Collections.emptyList(),
+          /* videos= */ Collections.emptyList(),
           /* audios= */ Collections.emptyList(),
           /* subtitles= */ Collections.emptyList(),
+          /* closedCaptions= */ Collections.emptyList(),
           /* muxedAudioFormat= */ null,
           /* muxedCaptionFormats= */ Collections.emptyList(),
           /* hasIndependentSegments= */ false,
-          /* variableDefinitions= */ Collections.emptyMap());
+          /* variableDefinitions= */ Collections.emptyMap(),
+          /* sessionKeyDrmInitData= */ Collections.emptyList());
 
+  // These constants must not be changed because they are persisted in offline stream keys.
   public static final int GROUP_INDEX_VARIANT = 0;
   public static final int GROUP_INDEX_AUDIO = 1;
   public static final int GROUP_INDEX_SUBTITLE = 2;
 
-  /**
-   * Represents a url in an HLS master playlist.
-   */
-  public static final class HlsUrl {
+  /** A variant (i.e. an #EXT-X-STREAM-INF tag) in a master playlist. */
+  public static final class Variant {
+
+    /** The variant's url. */
+    public final Uri url;
+
+    /** Format information associated with this variant. */
+    public final Format format;
+
+    /** The video rendition group referenced by this variant, or {@code null}. */
+    @Nullable public final String videoGroupId;
+
+    /** The audio rendition group referenced by this variant, or {@code null}. */
+    @Nullable public final String audioGroupId;
+
+    /** The subtitle rendition group referenced by this variant, or {@code null}. */
+    @Nullable public final String subtitleGroupId;
+
+    /** The caption rendition group referenced by this variant, or {@code null}. */
+    @Nullable public final String captionGroupId;
 
     /**
-     * The http url from which the media playlist can be obtained.
-     */
-    public final String url;
-    /**
-     * Format information associated with the HLS url.
+     * @param url See {@link #url}.
+     * @param format See {@link #format}.
+     * @param videoGroupId See {@link #videoGroupId}.
+     * @param audioGroupId See {@link #audioGroupId}.
+     * @param subtitleGroupId See {@link #subtitleGroupId}.
+     * @param captionGroupId See {@link #captionGroupId}.
      */
-    public final Format format;
+    public Variant(
+        Uri url,
+        Format format,
+        @Nullable String videoGroupId,
+        @Nullable String audioGroupId,
+        @Nullable String subtitleGroupId,
+        @Nullable String captionGroupId) {
+      this.url = url;
+      this.format = format;
+      this.videoGroupId = videoGroupId;
+      this.audioGroupId = audioGroupId;
+      this.subtitleGroupId = subtitleGroupId;
+      this.captionGroupId = captionGroupId;
+    }
 
     /**
-     * Creates an HLS url from a given http url.
+     * Creates a variant for a given media playlist url.
      *
-     * @param url The url.
-     * @return An HLS url.
+     * @param url The media playlist url.
+     * @return The variant instance.
      */
-    public static HlsUrl createMediaPlaylistHlsUrl(String url) {
+    public static Variant createMediaPlaylistVariantUrl(Uri url) {
       Format format =
           Format.createContainerFormat(
               "0",
@@ -73,33 +110,65 @@ public static HlsUrl createMediaPlaylistHlsUrl(String url) {
               /* codecs= */ null,
               /* bitrate= */ Format.NO_VALUE,
               /* selectionFlags= */ 0,
+              /* roleFlags= */ 0,
               /* language= */ null);
-      return new HlsUrl(url, format);
+      return new Variant(
+          url,
+          format,
+          /* videoGroupId= */ null,
+          /* audioGroupId= */ null,
+          /* subtitleGroupId= */ null,
+          /* captionGroupId= */ null);
     }
 
+    /** Returns a copy of this instance with the given {@link Format}. */
+    public Variant copyWithFormat(Format format) {
+      return new Variant(url, format, videoGroupId, audioGroupId, subtitleGroupId, captionGroupId);
+    }
+  }
+
+  /** A rendition (i.e. an #EXT-X-MEDIA tag) in a master playlist. */
+  public static final class Rendition {
+
+    /** The rendition's url, or null if the tag does not have a URI attribute. */
+    @Nullable public final Uri url;
+
+    /** Format information associated with this rendition. */
+    public final Format format;
+
+    /** The group to which this rendition belongs. */
+    public final String groupId;
+
+    /** The name of the rendition. */
+    public final String name;
+
     /**
      * @param url See {@link #url}.
      * @param format See {@link #format}.
+     * @param groupId See {@link #groupId}.
+     * @param name See {@link #name}.
      */
-    public HlsUrl(String url, Format format) {
+    public Rendition(@Nullable Uri url, Format format, String groupId, String name) {
       this.url = url;
       this.format = format;
+      this.groupId = groupId;
+      this.name = name;
     }
 
   }
 
-  /**
-   * The list of variants declared by the playlist.
-   */
-  public final List<HlsUrl> variants;
-  /**
-   * The list of demuxed audios declared by the playlist.
-   */
-  public final List<HlsUrl> audios;
-  /**
-   * The list of subtitles declared by the playlist.
-   */
-  public final List<HlsUrl> subtitles;
+  /** All of the media playlist URLs referenced by the playlist. */
+  public final List<Uri> mediaPlaylistUrls;
+  /** The variants declared by the playlist. */
+  public final List<Variant> variants;
+  /** The video renditions declared by the playlist. */
+  public final List<Rendition> videos;
+  /** The audio renditions declared by the playlist. */
+  public final List<Rendition> audios;
+  /** The subtitle renditions declared by the playlist. */
+  public final List<Rendition> subtitles;
+  /** The closed caption renditions declared by the playlist. */
+  public final List<Rendition> closedCaptions;
 
   /**
    * The format of the audio muxed in the variants. May be null if the playlist does not declare any
@@ -114,36 +183,50 @@ public HlsUrl(String url, Format format) {
   public final List<Format> muxedCaptionFormats;
   /** Contains variable definitions, as defined by the #EXT-X-DEFINE tag. */
   public final Map<String, String> variableDefinitions;
+  /** DRM initialization data derived from #EXT-X-SESSION-KEY tags. */
+  public final List<DrmInitData> sessionKeyDrmInitData;
 
   /**
    * @param baseUri See {@link #baseUri}.
    * @param tags See {@link #tags}.
    * @param variants See {@link #variants}.
+   * @param videos See {@link #videos}.
    * @param audios See {@link #audios}.
    * @param subtitles See {@link #subtitles}.
+   * @param closedCaptions See {@link #closedCaptions}.
    * @param muxedAudioFormat See {@link #muxedAudioFormat}.
    * @param muxedCaptionFormats See {@link #muxedCaptionFormats}.
    * @param hasIndependentSegments See {@link #hasIndependentSegments}.
    * @param variableDefinitions See {@link #variableDefinitions}.
+   * @param sessionKeyDrmInitData See {@link #sessionKeyDrmInitData}.
    */
   public HlsMasterPlaylist(
       String baseUri,
       List<String> tags,
-      List<HlsUrl> variants,
-      List<HlsUrl> audios,
-      List<HlsUrl> subtitles,
+      List<Variant> variants,
+      List<Rendition> videos,
+      List<Rendition> audios,
+      List<Rendition> subtitles,
+      List<Rendition> closedCaptions,
       Format muxedAudioFormat,
       List<Format> muxedCaptionFormats,
       boolean hasIndependentSegments,
-      Map<String, String> variableDefinitions) {
+      Map<String, String> variableDefinitions,
+      List<DrmInitData> sessionKeyDrmInitData) {
     super(baseUri, tags, hasIndependentSegments);
+    this.mediaPlaylistUrls =
+        Collections.unmodifiableList(
+            getMediaPlaylistUrls(variants, videos, audios, subtitles, closedCaptions));
     this.variants = Collections.unmodifiableList(variants);
+    this.videos = Collections.unmodifiableList(videos);
     this.audios = Collections.unmodifiableList(audios);
     this.subtitles = Collections.unmodifiableList(subtitles);
+    this.closedCaptions = Collections.unmodifiableList(closedCaptions);
     this.muxedAudioFormat = muxedAudioFormat;
     this.muxedCaptionFormats = muxedCaptionFormats != null
         ? Collections.unmodifiableList(muxedCaptionFormats) : null;
     this.variableDefinitions = Collections.unmodifiableMap(variableDefinitions);
+    this.sessionKeyDrmInitData = Collections.unmodifiableList(sessionKeyDrmInitData);
   }
 
   @Override
@@ -151,13 +234,18 @@ public HlsMasterPlaylist copy(List<StreamKey> streamKeys) {
     return new HlsMasterPlaylist(
         baseUri,
         tags,
-        copyRenditionsList(variants, GROUP_INDEX_VARIANT, streamKeys),
-        copyRenditionsList(audios, GROUP_INDEX_AUDIO, streamKeys),
-        copyRenditionsList(subtitles, GROUP_INDEX_SUBTITLE, streamKeys),
+        copyStreams(variants, GROUP_INDEX_VARIANT, streamKeys),
+        // TODO: Allow stream keys to specify video renditions to be retained.
+        /* videos= */ Collections.emptyList(),
+        copyStreams(audios, GROUP_INDEX_AUDIO, streamKeys),
+        copyStreams(subtitles, GROUP_INDEX_SUBTITLE, streamKeys),
+        // TODO: Update to retain all closed captions.
+        /* closedCaptions= */ Collections.emptyList(),
         muxedAudioFormat,
         muxedCaptionFormats,
         hasIndependentSegments,
-        variableDefinitions);
+        variableDefinitions,
+        sessionKeyDrmInitData);
   }
 
   /**
@@ -167,34 +255,76 @@ public HlsMasterPlaylist copy(List<StreamKey> streamKeys) {
    * @return A master playlist with a single variant for the provided url.
    */
   public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUrl) {
-    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUrl));
-    List<HlsUrl> emptyList = Collections.emptyList();
+    List<Variant> variant =
+        Collections.singletonList(Variant.createMediaPlaylistVariantUrl(Uri.parse(variantUrl)));
     return new HlsMasterPlaylist(
-        null,
-        Collections.emptyList(),
+        /* baseUri= */ null,
+        /* tags= */ Collections.emptyList(),
         variant,
-        emptyList,
-        emptyList,
+        /* videos= */ Collections.emptyList(),
+        /* audios= */ Collections.emptyList(),
+        /* subtitles= */ Collections.emptyList(),
+        /* closedCaptions= */ Collections.emptyList(),
         /* muxedAudioFormat= */ null,
         /* muxedCaptionFormats= */ null,
         /* hasIndependentSegments= */ false,
-        /* variableDefinitions= */ Collections.emptyMap());
+        /* variableDefinitions= */ Collections.emptyMap(),
+        /* sessionKeyDrmInitData= */ Collections.emptyList());
+  }
+
+  private static List<Uri> getMediaPlaylistUrls(
+      List<Variant> variants,
+      List<Rendition> videos,
+      List<Rendition> audios,
+      List<Rendition> subtitles,
+      List<Rendition> closedCaptions) {
+    ArrayList<Uri> mediaPlaylistUrls = new ArrayList<>();
+    for (int i = 0; i < variants.size(); i++) {
+      Uri uri = variants.get(i).url;
+      if (!mediaPlaylistUrls.contains(uri)) {
+        mediaPlaylistUrls.add(uri);
+      }
+    }
+    addMediaPlaylistUrls(videos, mediaPlaylistUrls);
+    addMediaPlaylistUrls(audios, mediaPlaylistUrls);
+    addMediaPlaylistUrls(subtitles, mediaPlaylistUrls);
+    addMediaPlaylistUrls(closedCaptions, mediaPlaylistUrls);
+    return mediaPlaylistUrls;
   }
 
-  private static List<HlsUrl> copyRenditionsList(
-      List<HlsUrl> renditions, int groupIndex, List<StreamKey> streamKeys) {
-    List<HlsUrl> copiedRenditions = new ArrayList<>(streamKeys.size());
+  private static void addMediaPlaylistUrls(List<Rendition> renditions, List<Uri> out) {
     for (int i = 0; i < renditions.size(); i++) {
-      HlsUrl rendition = renditions.get(i);
+      Uri uri = renditions.get(i).url;
+      if (uri != null && !out.contains(uri)) {
+        out.add(uri);
+      }
+    }
+  }
+
+  private static <T> List<T> copyStreams(
+      List<T> streams, int groupIndex, List<StreamKey> streamKeys) {
+    List<T> copiedStreams = new ArrayList<>(streamKeys.size());
+    // TODO:
+    // 1. When variants with the same URL are not de-duplicated, duplicates must not increment
+    //    trackIndex so as to avoid breaking stream keys that have been persisted for offline. All
+    //    duplicates should be copied if the first variant is copied, or discarded otherwise.
+    // 2. When renditions with null URLs are permitted, they must not increment trackIndex so as to
+    //    avoid breaking stream keys that have been persisted for offline. All renitions with null
+    //    URLs should be copied. They may become unreachable if all variants that reference them are
+    //    removed, but this is OK.
+    // 3. Renditions with URLs matching copied variants should always themselves be copied, even if
+    //    the corresponding stream key is omitted. Else we're throwing away information for no gain.
+    for (int i = 0; i < streams.size(); i++) {
+      T stream = streams.get(i);
       for (int j = 0; j < streamKeys.size(); j++) {
         StreamKey streamKey = streamKeys.get(j);
         if (streamKey.groupIndex == groupIndex && streamKey.trackIndex == i) {
-          copiedRenditions.add(rendition);
+          copiedStreams.add(stream);
           break;
         }
       }
     }
-    return copiedRenditions;
+    return copiedStreams;
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 81d4e7a818..4411c9865e 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -15,9 +15,9 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.offline.StreamKey;
@@ -43,7 +43,7 @@
      * the media playlist does not define a media section for this segment. The same instance is
      * used for all segments that share an EXT-X-MAP tag.
      */
-    public final @Nullable Segment initializationSegment;
+    @Nullable public final Segment initializationSegment;
     /** The duration of the segment in microseconds, as defined by #EXTINF. */
     public final long durationUs;
     /** The human readable title of the segment. */
@@ -60,17 +60,17 @@
      * DRM initialization data for sample decryption, or null if the segment does not use CDM-DRM
      * protection.
      */
-    public final @Nullable DrmInitData drmInitData;
+    @Nullable public final DrmInitData drmInitData;
     /**
      * The encryption identity key uri as defined by #EXT-X-KEY, or null if the segment does not use
      * full segment encryption with identity key.
      */
-    public final @Nullable String fullSegmentEncryptionKeyUri;
+    @Nullable public final String fullSegmentEncryptionKeyUri;
     /**
      * The encryption initialization vector as defined by #EXT-X-KEY, or null if the segment is not
      * encrypted.
      */
-    public final @Nullable String encryptionIV;
+    @Nullable public final String encryptionIV;
     /**
      * The segment's byte range offset, as defined by #EXT-X-BYTERANGE.
      */
@@ -88,8 +88,15 @@
      * @param uri See {@link #url}.
      * @param byterangeOffset See {@link #byterangeOffset}.
      * @param byterangeLength See {@link #byterangeLength}.
+     * @param fullSegmentEncryptionKeyUri See {@link #fullSegmentEncryptionKeyUri}.
+     * @param encryptionIV See {@link #encryptionIV}.
      */
-    public Segment(String uri, long byterangeOffset, long byterangeLength) {
+    public Segment(
+        String uri,
+        long byterangeOffset,
+        long byterangeLength,
+        String fullSegmentEncryptionKeyUri,
+        String encryptionIV) {
       this(
           uri,
           /* initializationSegment= */ null,
@@ -98,8 +105,8 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
           /* relativeDiscontinuitySequence= */ -1,
           /* relativeStartTimeUs= */ C.TIME_UNSET,
           /* drmInitData= */ null,
-          /* fullSegmentEncryptionKeyUri= */ null,
-          /* encryptionIV= */ null,
+          fullSegmentEncryptionKeyUri,
+          encryptionIV,
           byterangeOffset,
           byterangeLength,
           /* hasGapTag= */ false);
@@ -215,7 +222,7 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * Contains the CDM protection schemes used by segments in this playlist. Does not contain any key
    * acquisition data. Null if none of the segments in the playlist is CDM-encrypted.
    */
-  public final @Nullable DrmInitData protectionSchemes;
+  @Nullable public final DrmInitData protectionSchemes;
   /**
    * The list of segments in the playlist.
    */
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 65f4796187..42b27f259f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -16,7 +16,8 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Base64;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -24,16 +25,22 @@
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
+import com.google.android.exoplayer2.source.hls.HlsTrackMetadataEntry;
+import com.google.android.exoplayer2.source.hls.HlsTrackMetadataEntry.VariantInfo;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Rendition;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Variant;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -72,6 +79,7 @@
   private static final String TAG_START = "#EXT-X-START";
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
+  private static final String TAG_SESSION_KEY = "#EXT-X-SESSION-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
   private static final String TAG_GAP = "#EXT-X-GAP";
 
@@ -99,8 +107,12 @@
 
   private static final Pattern REGEX_AVERAGE_BANDWIDTH =
       Pattern.compile("AVERAGE-BANDWIDTH=(\\d+)\\b");
+  private static final Pattern REGEX_VIDEO = Pattern.compile("VIDEO=\"(.+?)\"");
   private static final Pattern REGEX_AUDIO = Pattern.compile("AUDIO=\"(.+?)\"");
+  private static final Pattern REGEX_SUBTITLES = Pattern.compile("SUBTITLES=\"(.+?)\"");
+  private static final Pattern REGEX_CLOSED_CAPTIONS = Pattern.compile("CLOSED-CAPTIONS=\"(.+?)\"");
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("[^-]BANDWIDTH=(\\d+)\\b");
+  private static final Pattern REGEX_CHANNELS = Pattern.compile("CHANNELS=\"(.+?)\"");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
   private static final Pattern REGEX_FRAME_RATE = Pattern.compile("FRAME-RATE=([\\d\\.]+)\\b");
@@ -144,6 +156,7 @@
   private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
   private static final Pattern REGEX_NAME = Pattern.compile("NAME=\"(.+?)\"");
   private static final Pattern REGEX_GROUP_ID = Pattern.compile("GROUP-ID=\"(.+?)\"");
+  private static final Pattern REGEX_CHARACTERISTICS = Pattern.compile("CHARACTERISTICS=\"(.+?)\"");
   private static final Pattern REGEX_INSTREAM_ID =
       Pattern.compile("INSTREAM-ID=\"((?:CC|SERVICE)\\d+)\"");
   private static final Pattern REGEX_AUTOSELECT = compileBooleanAttrPattern("AUTOSELECT");
@@ -243,13 +256,15 @@ private static int skipIgnorableWhitespace(BufferedReader reader, boolean skipLi
 
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
-    HashSet<String> variantUrls = new HashSet<>();
-    HashMap<String, String> audioGroupIdToCodecs = new HashMap<>();
+    HashMap<Uri, ArrayList<VariantInfo>> urlToVariantInfos = new HashMap<>();
     HashMap<String, String> variableDefinitions = new HashMap<>();
-    ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
-    ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
-    ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
+    ArrayList<Variant> variants = new ArrayList<>();
+    ArrayList<Rendition> videos = new ArrayList<>();
+    ArrayList<Rendition> audios = new ArrayList<>();
+    ArrayList<Rendition> subtitles = new ArrayList<>();
+    ArrayList<Rendition> closedCaptions = new ArrayList<>();
     ArrayList<String> mediaTags = new ArrayList<>();
+    ArrayList<DrmInitData> sessionKeyDrmInitData = new ArrayList<>();
     ArrayList<String> tags = new ArrayList<>();
     Format muxedAudioFormat = null;
     List<Format> muxedCaptionFormats = null;
@@ -275,6 +290,15 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         // Media tags are parsed at the end to include codec information from #EXT-X-STREAM-INF
         // tags.
         mediaTags.add(line);
+      } else if (line.startsWith(TAG_SESSION_KEY)) {
+        String keyFormat =
+            parseOptionalStringAttr(line, REGEX_KEYFORMAT, KEYFORMAT_IDENTITY, variableDefinitions);
+        SchemeData schemeData = parseDrmSchemeData(line, keyFormat, variableDefinitions);
+        if (schemeData != null) {
+          String method = parseStringAttr(line, REGEX_METHOD, variableDefinitions);
+          String scheme = parseEncryptionScheme(method);
+          sessionKeyDrmInitData.add(new DrmInitData(scheme, schemeData));
+        }
       } else if (line.startsWith(TAG_STREAM_INF)) {
         noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
@@ -308,76 +332,153 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         if (frameRateString != null) {
           frameRate = Float.parseFloat(frameRateString);
         }
+        String videoGroupId = parseOptionalStringAttr(line, REGEX_VIDEO, variableDefinitions);
         String audioGroupId = parseOptionalStringAttr(line, REGEX_AUDIO, variableDefinitions);
-        if (audioGroupId != null && codecs != null) {
-          audioGroupIdToCodecs.put(audioGroupId, Util.getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO));
-        }
+        String subtitlesGroupId =
+            parseOptionalStringAttr(line, REGEX_SUBTITLES, variableDefinitions);
+        String closedCaptionsGroupId =
+            parseOptionalStringAttr(line, REGEX_CLOSED_CAPTIONS, variableDefinitions);
         line =
             replaceVariableReferences(
                 iterator.next(), variableDefinitions); // #EXT-X-STREAM-INF's URI.
-        if (variantUrls.add(line)) {
-          Format format =
-              Format.createVideoContainerFormat(
-                  /* id= */ Integer.toString(variants.size()),
-                  /* label= */ null,
-                  /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
-                  /* sampleMimeType= */ null,
-                  codecs,
-                  bitrate,
-                  width,
-                  height,
-                  frameRate,
-                  /* initializationData= */ null,
-                  /* selectionFlags= */ 0);
-          variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
+        Uri uri = UriUtil.resolveToUri(baseUri, line);
+        Format format =
+            Format.createVideoContainerFormat(
+                /* id= */ Integer.toString(variants.size()),
+                /* label= */ null,
+                /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+                /* sampleMimeType= */ null,
+                codecs,
+                bitrate,
+                width,
+                height,
+                frameRate,
+                /* initializationData= */ null,
+                /* selectionFlags= */ 0,
+                /* roleFlags= */ 0);
+        Variant variant =
+            new Variant(
+                uri, format, videoGroupId, audioGroupId, subtitlesGroupId, closedCaptionsGroupId);
+        variants.add(variant);
+        ArrayList<VariantInfo> variantInfosForUrl = urlToVariantInfos.get(uri);
+        if (variantInfosForUrl == null) {
+          variantInfosForUrl = new ArrayList<>();
+          urlToVariantInfos.put(uri, variantInfosForUrl);
         }
+        variantInfosForUrl.add(
+            new VariantInfo(
+                bitrate, videoGroupId, audioGroupId, subtitlesGroupId, closedCaptionsGroupId));
+      }
+    }
+
+    // TODO: Don't deduplicate variants by URL.
+    ArrayList<Variant> deduplicatedVariants = new ArrayList<>();
+    HashSet<Uri> urlsInDeduplicatedVariants = new HashSet<>();
+    for (int i = 0; i < variants.size(); i++) {
+      Variant variant = variants.get(i);
+      if (urlsInDeduplicatedVariants.add(variant.url)) {
+        Assertions.checkState(variant.format.metadata == null);
+        HlsTrackMetadataEntry hlsMetadataEntry =
+            new HlsTrackMetadataEntry(
+                /* groupId= */ null, /* name= */ null, urlToVariantInfos.get(variant.url));
+        deduplicatedVariants.add(
+            variant.copyWithFormat(
+                variant.format.copyWithMetadata(new Metadata(hlsMetadataEntry))));
       }
     }
 
     for (int i = 0; i < mediaTags.size(); i++) {
       line = mediaTags.get(i);
-      @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
-      String uri = parseOptionalStringAttr(line, REGEX_URI, variableDefinitions);
+      String groupId = parseStringAttr(line, REGEX_GROUP_ID, variableDefinitions);
       String name = parseStringAttr(line, REGEX_NAME, variableDefinitions);
+      String referenceUri = parseOptionalStringAttr(line, REGEX_URI, variableDefinitions);
+      Uri uri = referenceUri == null ? null : UriUtil.resolveToUri(baseUri, referenceUri);
       String language = parseOptionalStringAttr(line, REGEX_LANGUAGE, variableDefinitions);
-      String groupId = parseOptionalStringAttr(line, REGEX_GROUP_ID, variableDefinitions);
-      String id = groupId + ":" + name;
+      @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
+      @C.RoleFlags int roleFlags = parseRoleFlags(line, variableDefinitions);
+      String formatId = groupId + ":" + name;
       Format format;
+      Metadata metadata =
+          new Metadata(new HlsTrackMetadataEntry(groupId, name, Collections.emptyList()));
       switch (parseStringAttr(line, REGEX_TYPE, variableDefinitions)) {
-        case TYPE_AUDIO:
-          String codecs = audioGroupIdToCodecs.get(groupId);
+        case TYPE_VIDEO:
+          Variant variant = getVariantWithVideoGroup(variants, groupId);
+          String codecs = null;
+          int width = Format.NO_VALUE;
+          int height = Format.NO_VALUE;
+          float frameRate = Format.NO_VALUE;
+          if (variant != null) {
+            Format variantFormat = variant.format;
+            codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_VIDEO);
+            width = variantFormat.width;
+            height = variantFormat.height;
+            frameRate = variantFormat.frameRate;
+          }
           String sampleMimeType = codecs != null ? MimeTypes.getMediaMimeType(codecs) : null;
+          format =
+              Format.createVideoContainerFormat(
+                      /* id= */ formatId,
+                      /* label= */ name,
+                      /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+                      sampleMimeType,
+                      codecs,
+                      /* bitrate= */ Format.NO_VALUE,
+                      width,
+                      height,
+                      frameRate,
+                      /* initializationData= */ null,
+                      selectionFlags,
+                      roleFlags)
+                  .copyWithMetadata(metadata);
+          if (uri == null) {
+            // TODO: Remove this case and add a Rendition with a null uri to videos.
+          } else {
+            videos.add(new Rendition(uri, format, groupId, name));
+          }
+          break;
+        case TYPE_AUDIO:
+          variant = getVariantWithAudioGroup(variants, groupId);
+          codecs =
+              variant != null
+                  ? Util.getCodecsOfType(variant.format.codecs, C.TRACK_TYPE_AUDIO)
+                  : null;
+          sampleMimeType = codecs != null ? MimeTypes.getMediaMimeType(codecs) : null;
+          int channelCount = parseChannelsAttribute(line, variableDefinitions);
           format =
               Format.createAudioContainerFormat(
-                  /* id= */ id,
+                  /* id= */ formatId,
                   /* label= */ name,
                   /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                   sampleMimeType,
                   codecs,
                   /* bitrate= */ Format.NO_VALUE,
-                  /* channelCount= */ Format.NO_VALUE,
+                  channelCount,
                   /* sampleRate= */ Format.NO_VALUE,
                   /* initializationData= */ null,
                   selectionFlags,
+                  roleFlags,
                   language);
           if (uri == null) {
+            // TODO: Remove muxedAudioFormat and add a Rendition with a null uri to audios.
             muxedAudioFormat = format;
           } else {
-            audios.add(new HlsMasterPlaylist.HlsUrl(uri, format));
+            audios.add(new Rendition(uri, format.copyWithMetadata(metadata), groupId, name));
           }
           break;
         case TYPE_SUBTITLES:
           format =
               Format.createTextContainerFormat(
-                  /* id= */ id,
-                  /* label= */ name,
-                  /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
-                  /* sampleMimeType= */ MimeTypes.TEXT_VTT,
-                  /* codecs= */ null,
-                  /* bitrate= */ Format.NO_VALUE,
-                  selectionFlags,
-                  language);
-          subtitles.add(new HlsMasterPlaylist.HlsUrl(uri, format));
+                      /* id= */ formatId,
+                      /* label= */ name,
+                      /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+                      /* sampleMimeType= */ MimeTypes.TEXT_VTT,
+                      /* codecs= */ null,
+                      /* bitrate= */ Format.NO_VALUE,
+                      selectionFlags,
+                      roleFlags,
+                      language)
+                  .copyWithMetadata(metadata);
+          subtitles.add(new Rendition(uri, format, groupId, name));
           break;
         case TYPE_CLOSED_CAPTIONS:
           String instreamId = parseStringAttr(line, REGEX_INSTREAM_ID, variableDefinitions);
@@ -395,15 +496,17 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           }
           muxedCaptionFormats.add(
               Format.createTextContainerFormat(
-                  /* id= */ id,
+                  /* id= */ formatId,
                   /* label= */ name,
                   /* containerMimeType= */ null,
                   /* sampleMimeType= */ mimeType,
                   /* codecs= */ null,
                   /* bitrate= */ Format.NO_VALUE,
                   selectionFlags,
+                  roleFlags,
                   language,
                   accessibilityChannel));
+          // TODO: Remove muxedCaptionFormats and add a Rendition with a null uri to closedCaptions.
           break;
         default:
           // Do nothing.
@@ -414,31 +517,40 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     if (noClosedCaptions) {
       muxedCaptionFormats = Collections.emptyList();
     }
+
     return new HlsMasterPlaylist(
         baseUri,
         tags,
-        variants,
+        deduplicatedVariants,
+        videos,
         audios,
         subtitles,
+        closedCaptions,
         muxedAudioFormat,
         muxedCaptionFormats,
         hasIndependentSegmentsTag,
-        variableDefinitions);
+        variableDefinitions,
+        sessionKeyDrmInitData);
   }
 
-  @C.SelectionFlags
-  private static int parseSelectionFlags(String line) {
-    int flags = 0;
-    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {
-      flags |= C.SELECTION_FLAG_DEFAULT;
-    }
-    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {
-      flags |= C.SELECTION_FLAG_FORCED;
+  private static Variant getVariantWithAudioGroup(ArrayList<Variant> variants, String groupId) {
+    for (int i = 0; i < variants.size(); i++) {
+      Variant variant = variants.get(i);
+      if (groupId.equals(variant.audioGroupId)) {
+        return variant;
+      }
     }
-    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {
-      flags |= C.SELECTION_FLAG_AUTOSELECT;
+    return null;
+  }
+
+  private static Variant getVariantWithVideoGroup(ArrayList<Variant> variants, String groupId) {
+    for (int i = 0; i < variants.size(); i++) {
+      Variant variant = variants.get(i);
+      if (groupId.equals(variant.videoGroupId)) {
+        return variant;
+      }
     }
-    return flags;
+    return null;
   }
 
   private static HlsMediaPlaylist parseMediaPlaylist(
@@ -468,8 +580,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(
     boolean hasGapTag = false;
 
     DrmInitData playlistProtectionSchemes = null;
-    String encryptionKeyUri = null;
-    String encryptionIV = null;
+    String fullSegmentEncryptionKeyUri = null;
+    String fullSegmentEncryptionIV = null;
     TreeMap<String, SchemeData> currentSchemeDatas = new TreeMap<>();
     String encryptionScheme = null;
     DrmInitData cachedDrmInitData = null;
@@ -502,7 +614,19 @@ private static HlsMediaPlaylist parseMediaPlaylist(
             segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
           }
         }
-        initializationSegment = new Segment(uri, segmentByteRangeOffset, segmentByteRangeLength);
+        if (fullSegmentEncryptionKeyUri != null && fullSegmentEncryptionIV == null) {
+          // See RFC 8216, Section 4.3.2.5.
+          throw new ParserException(
+              "The encryption IV attribute must be present when an initialization segment is "
+                  + "encrypted with METHOD=AES-128.");
+        }
+        initializationSegment =
+            new Segment(
+                uri,
+                segmentByteRangeOffset,
+                segmentByteRangeLength,
+                fullSegmentEncryptionKeyUri,
+                fullSegmentEncryptionIV);
         segmentByteRangeOffset = 0;
         segmentByteRangeLength = C.LENGTH_UNSET;
       } else if (line.startsWith(TAG_TARGET_DURATION)) {
@@ -534,34 +658,26 @@ private static HlsMediaPlaylist parseMediaPlaylist(
         String method = parseStringAttr(line, REGEX_METHOD, variableDefinitions);
         String keyFormat =
             parseOptionalStringAttr(line, REGEX_KEYFORMAT, KEYFORMAT_IDENTITY, variableDefinitions);
-        encryptionKeyUri = null;
-        encryptionIV = null;
+        fullSegmentEncryptionKeyUri = null;
+        fullSegmentEncryptionIV = null;
         if (METHOD_NONE.equals(method)) {
           currentSchemeDatas.clear();
           cachedDrmInitData = null;
         } else /* !METHOD_NONE.equals(method) */ {
-          encryptionIV = parseOptionalStringAttr(line, REGEX_IV, variableDefinitions);
+          fullSegmentEncryptionIV = parseOptionalStringAttr(line, REGEX_IV, variableDefinitions);
           if (KEYFORMAT_IDENTITY.equals(keyFormat)) {
             if (METHOD_AES_128.equals(method)) {
               // The segment is fully encrypted using an identity key.
-              encryptionKeyUri = parseStringAttr(line, REGEX_URI, variableDefinitions);
+              fullSegmentEncryptionKeyUri = parseStringAttr(line, REGEX_URI, variableDefinitions);
             } else {
               // Do nothing. Samples are encrypted using an identity key, but this is not supported.
               // Hopefully, a traditional DRM alternative is also provided.
             }
           } else {
             if (encryptionScheme == null) {
-              encryptionScheme =
-                  METHOD_SAMPLE_AES_CENC.equals(method) || METHOD_SAMPLE_AES_CTR.equals(method)
-                      ? C.CENC_TYPE_cenc
-                      : C.CENC_TYPE_cbcs;
-            }
-            SchemeData schemeData;
-            if (KEYFORMAT_PLAYREADY.equals(keyFormat)) {
-              schemeData = parsePlayReadySchemeData(line, variableDefinitions);
-            } else {
-              schemeData = parseWidevineSchemeData(line, keyFormat, variableDefinitions);
+              encryptionScheme = parseEncryptionScheme(method);
             }
+            SchemeData schemeData = parseDrmSchemeData(line, keyFormat, variableDefinitions);
             if (schemeData != null) {
               cachedDrmInitData = null;
               currentSchemeDatas.put(keyFormat, schemeData);
@@ -594,10 +710,10 @@ private static HlsMediaPlaylist parseMediaPlaylist(
         hasEndTag = true;
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
-        if (encryptionKeyUri == null) {
+        if (fullSegmentEncryptionKeyUri == null) {
           segmentEncryptionIV = null;
-        } else if (encryptionIV != null) {
-          segmentEncryptionIV = encryptionIV;
+        } else if (fullSegmentEncryptionIV != null) {
+          segmentEncryptionIV = fullSegmentEncryptionIV;
         } else {
           segmentEncryptionIV = Long.toHexString(segmentMediaSequence);
         }
@@ -628,7 +744,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(
                 relativeDiscontinuitySequence,
                 segmentStartTimeUs,
                 cachedDrmInitData,
-                encryptionKeyUri,
+                fullSegmentEncryptionKeyUri,
                 segmentEncryptionIV,
                 segmentByteRangeOffset,
                 segmentByteRangeLength,
@@ -661,40 +777,81 @@ private static HlsMediaPlaylist parseMediaPlaylist(
         segments);
   }
 
-  private static @Nullable SchemeData parsePlayReadySchemeData(
-      String line, Map<String, String> variableDefinitions) throws ParserException {
-    String keyFormatVersions =
-        parseOptionalStringAttr(line, REGEX_KEYFORMATVERSIONS, "1", variableDefinitions);
-    if (!"1".equals(keyFormatVersions)) {
-      // Not supported.
-      return null;
+  @C.SelectionFlags
+  private static int parseSelectionFlags(String line) {
+    int flags = 0;
+    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {
+      flags |= C.SELECTION_FLAG_DEFAULT;
+    }
+    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {
+      flags |= C.SELECTION_FLAG_FORCED;
     }
-    String uriString = parseStringAttr(line, REGEX_URI, variableDefinitions);
-    byte[] data = Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT);
-    byte[] psshData = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID, data);
-    return new SchemeData(C.PLAYREADY_UUID, MimeTypes.VIDEO_MP4, psshData);
+    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {
+      flags |= C.SELECTION_FLAG_AUTOSELECT;
+    }
+    return flags;
+  }
+
+  @C.RoleFlags
+  private static int parseRoleFlags(String line, Map<String, String> variableDefinitions) {
+    String concatenatedCharacteristics =
+        parseOptionalStringAttr(line, REGEX_CHARACTERISTICS, variableDefinitions);
+    if (TextUtils.isEmpty(concatenatedCharacteristics)) {
+      return 0;
+    }
+    String[] characteristics = Util.split(concatenatedCharacteristics, ",");
+    @C.RoleFlags int roleFlags = 0;
+    if (Util.contains(characteristics, "public.accessibility.describes-video")) {
+      roleFlags |= C.ROLE_FLAG_DESCRIBES_VIDEO;
+    }
+    if (Util.contains(characteristics, "public.accessibility.transcribes-spoken-dialog")) {
+      roleFlags |= C.ROLE_FLAG_TRANSCRIBES_DIALOG;
+    }
+    if (Util.contains(characteristics, "public.accessibility.describes-music-and-sound")) {
+      roleFlags |= C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND;
+    }
+    if (Util.contains(characteristics, "public.easy-to-read")) {
+      roleFlags |= C.ROLE_FLAG_EASY_TO_READ;
+    }
+    return roleFlags;
+  }
+
+  private static int parseChannelsAttribute(String line, Map<String, String> variableDefinitions) {
+    String channelsString = parseOptionalStringAttr(line, REGEX_CHANNELS, variableDefinitions);
+    return channelsString != null
+        ? Integer.parseInt(Util.splitAtFirst(channelsString, "/")[0])
+        : Format.NO_VALUE;
   }
 
-  private static @Nullable SchemeData parseWidevineSchemeData(
+  @Nullable
+  private static SchemeData parseDrmSchemeData(
       String line, String keyFormat, Map<String, String> variableDefinitions)
       throws ParserException {
+    String keyFormatVersions =
+        parseOptionalStringAttr(line, REGEX_KEYFORMATVERSIONS, "1", variableDefinitions);
     if (KEYFORMAT_WIDEVINE_PSSH_BINARY.equals(keyFormat)) {
       String uriString = parseStringAttr(line, REGEX_URI, variableDefinitions);
       return new SchemeData(
           C.WIDEVINE_UUID,
           MimeTypes.VIDEO_MP4,
           Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT));
-    }
-    if (KEYFORMAT_WIDEVINE_PSSH_JSON.equals(keyFormat)) {
-      try {
-        return new SchemeData(C.WIDEVINE_UUID, "hls", line.getBytes(C.UTF8_NAME));
-      } catch (UnsupportedEncodingException e) {
-        throw new ParserException(e);
-      }
+    } else if (KEYFORMAT_WIDEVINE_PSSH_JSON.equals(keyFormat)) {
+      return new SchemeData(C.WIDEVINE_UUID, "hls", Util.getUtf8Bytes(line));
+    } else if (KEYFORMAT_PLAYREADY.equals(keyFormat) && "1".equals(keyFormatVersions)) {
+      String uriString = parseStringAttr(line, REGEX_URI, variableDefinitions);
+      byte[] data = Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT);
+      byte[] psshData = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID, data);
+      return new SchemeData(C.PLAYREADY_UUID, MimeTypes.VIDEO_MP4, psshData);
     }
     return null;
   }
 
+  private static String parseEncryptionScheme(String method) {
+    return METHOD_SAMPLE_AES_CENC.equals(method) || METHOD_SAMPLE_AES_CTR.equals(method)
+        ? C.CENC_TYPE_cenc
+        : C.CENC_TYPE_cbcs;
+  }
+
   private static int parseIntAttr(String line, Pattern pattern) throws ParserException {
     return Integer.parseInt(parseStringAttr(line, pattern, Collections.emptyMap()));
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index c73c9fa835..96c9660db0 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -16,11 +16,10 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.hls.HlsDataSourceFactory;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import java.io.IOException;
 
@@ -81,21 +80,21 @@ HlsPlaylistTracker createTracker(
      *     {@link C#TIME_UNSET} if the playlist should not be blacklisted.
      * @return True if blacklisting did not encounter errors. False otherwise.
      */
-    boolean onPlaylistError(HlsUrl url, long blacklistDurationMs);
+    boolean onPlaylistError(Uri url, long blacklistDurationMs);
   }
 
   /** Thrown when a playlist is considered to be stuck due to a server side error. */
   final class PlaylistStuckException extends IOException {
 
     /** The url of the stuck playlist. */
-    public final String url;
+    public final Uri url;
 
     /**
      * Creates an instance.
      *
      * @param url See {@link #url}.
      */
-    public PlaylistStuckException(String url) {
+    public PlaylistStuckException(Uri url) {
       this.url = url;
     }
   }
@@ -104,14 +103,14 @@ public PlaylistStuckException(String url) {
   final class PlaylistResetException extends IOException {
 
     /** The url of the reset playlist. */
-    public final String url;
+    public final Uri url;
 
     /**
      * Creates an instance.
      *
      * @param url See {@link #url}.
      */
-    public PlaylistResetException(String url) {
+    public PlaylistResetException(Uri url) {
       this.url = url;
     }
   }
@@ -164,16 +163,16 @@ void start(
 
   /**
    * Returns the most recent snapshot available of the playlist referenced by the provided {@link
-   * HlsUrl}.
+   * Uri}.
    *
-   * @param url The {@link HlsUrl} corresponding to the requested media playlist.
+   * @param url The {@link Uri} corresponding to the requested media playlist.
    * @param isForPlayback Whether the caller might use the snapshot to request media segments for
    *     playback. If true, the primary playlist may be updated to the one requested.
-   * @return The most recent snapshot of the playlist referenced by the provided {@link HlsUrl}. May
-   *     be null if no snapshot has been loaded yet.
+   * @return The most recent snapshot of the playlist referenced by the provided {@link Uri}. May be
+   *     null if no snapshot has been loaded yet.
    */
   @Nullable
-  HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url, boolean isForPlayback);
+  HlsMediaPlaylist getPlaylistSnapshot(Uri url, boolean isForPlayback);
 
   /**
    * Returns the start time of the first loaded primary playlist, or {@link C#TIME_UNSET} if no
@@ -182,15 +181,14 @@ void start(
   long getInitialStartTimeUs();
 
   /**
-   * Returns whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
-   * valid, meaning all the segments referenced by the playlist are expected to be available. If the
+   * Returns whether the snapshot of the playlist referenced by the provided {@link Uri} is valid,
+   * meaning all the segments referenced by the playlist are expected to be available. If the
    * playlist is not valid then some of the segments may no longer be available.
    *
-   * @param url The {@link HlsUrl}.
-   * @return Whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
-   *     valid.
+   * @param url The {@link Uri}.
+   * @return Whether the snapshot of the playlist referenced by the provided {@link Uri} is valid.
    */
-  boolean isSnapshotValid(HlsUrl url);
+  boolean isSnapshotValid(Uri url);
 
   /**
    * If the tracker is having trouble refreshing the master playlist or the primary playlist, this
@@ -201,13 +199,13 @@ void start(
   void maybeThrowPrimaryPlaylistRefreshError() throws IOException;
 
   /**
-   * If the playlist is having trouble refreshing the playlist referenced by the given {@link
-   * HlsUrl}, this method throws the underlying error.
+   * If the playlist is having trouble refreshing the playlist referenced by the given {@link Uri},
+   * this method throws the underlying error.
    *
-   * @param url The {@link HlsUrl}.
+   * @param url The {@link Uri}.
    * @throws IOException The underyling error.
    */
-  void maybeThrowPlaylistRefreshError(HlsUrl url) throws IOException;
+  void maybeThrowPlaylistRefreshError(Uri url) throws IOException;
 
   /**
    * Requests a playlist refresh and whitelists it.
@@ -215,9 +213,9 @@ void start(
    * <p>The playlist tracker may choose the delay the playlist refresh. The request is discarded if
    * a refresh was already pending.
    *
-   * @param url The {@link HlsUrl} of the playlist to be refreshed.
+   * @param url The {@link Uri} of the playlist to be refreshed.
    */
-  void refreshPlaylist(HlsUrl url);
+  void refreshPlaylist(Uri url);
 
   /**
    * Returns whether the tracked playlists describe a live stream.
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java
index defc838c6a..3eef5c36d2 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/Aes128DataSourceTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -28,10 +29,9 @@
 import javax.crypto.NoSuchPaddingException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Test for {@link Aes128DataSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class Aes128DataSourceTest {
 
   @Test
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
new file mode 100644
index 0000000000..5988391213
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Rendition;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.Variant;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
+import com.google.android.exoplayer2.testutil.MediaPeriodAsserts;
+import com.google.android.exoplayer2.testutil.MediaPeriodAsserts.FilterableManifestMediaPeriodFactory;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/** Unit test for {@link HlsMediaPeriod}. */
+@RunWith(AndroidJUnit4.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class HlsMediaPeriodTest {
+
+  @Test
+  public void getSteamKeys_isCompatibleWithHlsMasterPlaylistFilter() {
+    HlsMasterPlaylist testMasterPlaylist =
+        createMasterPlaylist(
+            /* variants= */ Arrays.asList(
+                createAudioOnlyVariant(/* bitrate= */ 10000),
+                createMuxedVideoAudioVariant(/* bitrate= */ 200000),
+                createAudioOnlyVariant(/* bitrate= */ 300000),
+                createMuxedVideoAudioVariant(/* bitrate= */ 400000),
+                createMuxedVideoAudioVariant(/* bitrate= */ 600000)),
+            /* audios= */ Arrays.asList(
+                createAudioRendition(/* language= */ "spa"),
+                createAudioRendition(/* language= */ "ger"),
+                createAudioRendition(/* language= */ "tur")),
+            /* subtitles= */ Arrays.asList(
+                createSubtitleRendition(/* language= */ "spa"),
+                createSubtitleRendition(/* language= */ "ger"),
+                createSubtitleRendition(/* language= */ "tur")),
+            /* muxedAudioFormat= */ createAudioFormat("eng"),
+            /* muxedCaptionFormats= */ Arrays.asList(
+                createSubtitleFormat("eng"), createSubtitleFormat("gsw")));
+    FilterableManifestMediaPeriodFactory<HlsPlaylist> mediaPeriodFactory =
+        (playlist, periodIndex) -> {
+          HlsDataSourceFactory mockDataSourceFactory = mock(HlsDataSourceFactory.class);
+          when(mockDataSourceFactory.createDataSource(anyInt())).thenReturn(mock(DataSource.class));
+          HlsPlaylistTracker mockPlaylistTracker = mock(HlsPlaylistTracker.class);
+          when(mockPlaylistTracker.getMasterPlaylist()).thenReturn((HlsMasterPlaylist) playlist);
+          return new HlsMediaPeriod(
+              mock(HlsExtractorFactory.class),
+              mockPlaylistTracker,
+              mockDataSourceFactory,
+              mock(TransferListener.class),
+              mock(LoadErrorHandlingPolicy.class),
+              new EventDispatcher()
+                  .withParameters(
+                      /* windowIndex= */ 0,
+                      /* mediaPeriodId= */ new MediaPeriodId(/* periodUid= */ new Object()),
+                      /* mediaTimeOffsetMs= */ 0),
+              mock(Allocator.class),
+              mock(CompositeSequenceableLoaderFactory.class),
+              /* allowChunklessPreparation =*/ true,
+              /* useSessionKeys= */ false);
+        };
+
+    MediaPeriodAsserts.assertGetStreamKeysAndManifestFilterIntegration(
+        mediaPeriodFactory, testMasterPlaylist);
+  }
+
+  private static HlsMasterPlaylist createMasterPlaylist(
+      List<Variant> variants,
+      List<Rendition> audios,
+      List<Rendition> subtitles,
+      Format muxedAudioFormat,
+      List<Format> muxedCaptionFormats) {
+    return new HlsMasterPlaylist(
+        "http://baseUri",
+        /* tags= */ Collections.emptyList(),
+        variants,
+        /* videos= */ Collections.emptyList(),
+        audios,
+        subtitles,
+        /* closedCaptions= */ Collections.emptyList(),
+        muxedAudioFormat,
+        muxedCaptionFormats,
+        /* hasIndependentSegments= */ true,
+        /* variableDefinitions= */ Collections.emptyMap(),
+        /* sessionKeyDrmInitData= */ Collections.emptyList());
+  }
+
+  private static Variant createMuxedVideoAudioVariant(int bitrate) {
+    return createVariant(
+        Format.createVideoContainerFormat(
+            /* id= */ null,
+            /* label= */ null,
+            /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+            /* sampleMimeType= */ null,
+            /* codecs= */ "avc1.100.41,mp4a.40.2",
+            bitrate,
+            /* width= */ Format.NO_VALUE,
+            /* height= */ Format.NO_VALUE,
+            /* frameRate= */ Format.NO_VALUE,
+            /* initializationData= */ null,
+            /* selectionFlags= */ 0,
+            /* roleFlags= */ 0));
+  }
+
+  private static Variant createAudioOnlyVariant(int bitrate) {
+    return createVariant(
+        Format.createVideoContainerFormat(
+            /* id= */ null,
+            /* label= */ null,
+            /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+            /* sampleMimeType= */ null,
+            /* codecs= */ "mp4a.40.2",
+            bitrate,
+            /* width= */ Format.NO_VALUE,
+            /* height= */ Format.NO_VALUE,
+            /* frameRate= */ Format.NO_VALUE,
+            /* initializationData= */ null,
+            /* selectionFlags= */ 0,
+            /* roleFlags= */ 0));
+  }
+
+  private static Rendition createAudioRendition(String language) {
+    return createRendition(createAudioFormat(language), "", "");
+  }
+
+  private static Rendition createSubtitleRendition(String language) {
+    return createRendition(createSubtitleFormat(language), "", "");
+  }
+
+  private static Variant createVariant(Format format) {
+    return new Variant(Uri.parse("https://variant"), format, null, null, null, null);
+  }
+
+  private static Rendition createRendition(Format format, String groupId, String name) {
+    return new Rendition(Uri.parse("https://rendition"), format, groupId, name);
+  }
+
+  private static Format createAudioFormat(String language) {
+    return Format.createAudioContainerFormat(
+        /* id= */ null,
+        /* label= */ null,
+        /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+        MimeTypes.getMediaMimeType("mp4a.40.2"),
+        /* codecs= */ "mp4a.40.2",
+        /* bitrate= */ Format.NO_VALUE,
+        /* channelCount= */ Format.NO_VALUE,
+        /* sampleRate= */ Format.NO_VALUE,
+        /* initializationData= */ null,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        language);
+  }
+
+  private static Format createSubtitleFormat(String language) {
+    return Format.createTextContainerFormat(
+        /* id= */ null,
+        /* label= */ null,
+        /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
+        /* sampleMimeType= */ MimeTypes.TEXT_VTT,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        language);
+  }
+}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java
index e3e2feed8b..4f7e26fce0 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/WebvttExtractorTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
@@ -24,10 +25,9 @@
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Tests for {@link WebvttExtractor}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class WebvttExtractorTest {
 
   @Test
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/DownloadHelperTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/DownloadHelperTest.java
new file mode 100644
index 0000000000..c7a8034ee7
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/DownloadHelperTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.offline;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test to verify creation of a HLS {@link DownloadHelper}. */
+@RunWith(AndroidJUnit4.class)
+public final class DownloadHelperTest {
+
+  @Test
+  public void staticDownloadHelperForHls_doesNotThrow() {
+    DownloadHelper.forHls(
+        Uri.parse("http://uri"),
+        new FakeDataSource.Factory(),
+        (handler, videoListener, audioListener, text, metadata, drm) -> new Renderer[0]);
+    DownloadHelper.forHls(
+        Uri.parse("http://uri"),
+        new FakeDataSource.Factory(),
+        (handler, videoListener, audioListener, text, metadata, drm) -> new Renderer[0],
+        /* drmSessionManager= */ null,
+        DownloadHelper.DEFAULT_TRACK_SELECTOR_PARAMETERS);
+  }
+}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadActionTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadActionTest.java
deleted file mode 100644
index 778ecadddd..0000000000
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadActionTest.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.offline;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.offline.DownloadAction;
-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-
-/** Unit tests for {@link HlsDownloadAction}. */
-@RunWith(RobolectricTestRunner.class)
-public class HlsDownloadActionTest {
-
-  private Uri uri1;
-  private Uri uri2;
-
-  @Before
-  public void setUp() {
-    uri1 = Uri.parse("http://test1.uri");
-    uri2 = Uri.parse("http://test2.uri");
-  }
-
-  @Test
-  public void testDownloadActionIsNotRemoveAction() {
-    DownloadAction action = createDownloadAction(uri1);
-    assertThat(action.isRemoveAction).isFalse();
-  }
-
-  @Test
-  public void testRemoveActionIsRemoveAction() {
-    DownloadAction action2 = createRemoveAction(uri1);
-    assertThat(action2.isRemoveAction).isTrue();
-  }
-
-  @Test
-  public void testCreateDownloader() {
-    MockitoAnnotations.initMocks(this);
-    DownloadAction action = createDownloadAction(uri1);
-    DownloaderConstructorHelper constructorHelper =
-        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
-    assertThat(action.createDownloader(constructorHelper)).isNotNull();
-  }
-
-  @Test
-  public void testSameUriDifferentAction_IsSameMedia() {
-    DownloadAction action1 = createRemoveAction(uri1);
-    DownloadAction action2 = createDownloadAction(uri1);
-    assertThat(action1.isSameMedia(action2)).isTrue();
-  }
-
-  @Test
-  public void testDifferentUriAndAction_IsNotSameMedia() {
-    DownloadAction action3 = createRemoveAction(uri2);
-    DownloadAction action4 = createDownloadAction(uri1);
-    assertThat(action3.isSameMedia(action4)).isFalse();
-  }
-
-  @SuppressWarnings("EqualsWithItself")
-  @Test
-  public void testEquals() {
-    DownloadAction action1 = createRemoveAction(uri1);
-    assertThat(action1.equals(action1)).isTrue();
-
-    DownloadAction action2 = createRemoveAction(uri1);
-    DownloadAction action3 = createRemoveAction(uri1);
-    assertEqual(action2, action3);
-
-    DownloadAction action4 = createRemoveAction(uri1);
-    DownloadAction action5 = createDownloadAction(uri1);
-    assertNotEqual(action4, action5);
-
-    DownloadAction action6 = createDownloadAction(uri1);
-    DownloadAction action7 = createDownloadAction(uri1, new StreamKey(0, 0));
-    assertNotEqual(action6, action7);
-
-    DownloadAction action8 = createDownloadAction(uri1, new StreamKey(1, 1));
-    DownloadAction action9 = createDownloadAction(uri1, new StreamKey(0, 0));
-    assertNotEqual(action8, action9);
-
-    DownloadAction action10 = createRemoveAction(uri1);
-    DownloadAction action11 = createRemoveAction(uri2);
-    assertNotEqual(action10, action11);
-
-    DownloadAction action12 = createDownloadAction(uri1, new StreamKey(0, 0), new StreamKey(1, 1));
-    DownloadAction action13 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
-    assertEqual(action12, action13);
-
-    DownloadAction action14 = createDownloadAction(uri1, new StreamKey(0, 0));
-    DownloadAction action15 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
-    assertNotEqual(action14, action15);
-
-    DownloadAction action16 = createDownloadAction(uri1);
-    DownloadAction action17 = createDownloadAction(uri1);
-    assertEqual(action16, action17);
-  }
-
-  @Test
-  public void testSerializerGetType() {
-    DownloadAction action = createDownloadAction(uri1);
-    assertThat(action.type).isNotNull();
-  }
-
-  @Test
-  public void testSerializerWriteRead() throws Exception {
-    doTestSerializationRoundTrip(createDownloadAction(uri1));
-    doTestSerializationRoundTrip(createRemoveAction(uri1));
-    doTestSerializationRoundTrip(
-        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
-  }
-
-  @Test
-  public void testSerializerVersion0() throws Exception {
-    doTestSerializationV0RoundTrip(createDownloadAction(uri1));
-    doTestSerializationV0RoundTrip(createRemoveAction(uri1));
-    doTestSerializationV0RoundTrip(
-        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
-  }
-
-  private static void assertNotEqual(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1).isNotEqualTo(action2);
-    assertThat(action2).isNotEqualTo(action1);
-  }
-
-  private static void assertEqual(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1).isEqualTo(action2);
-    assertThat(action2).isEqualTo(action1);
-  }
-
-  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream output = new DataOutputStream(out);
-    DownloadAction.serializeToStream(action, output);
-
-    assertEqual(action, deserializeActionFromStream(out));
-  }
-
-  private static void doTestSerializationV0RoundTrip(HlsDownloadAction action) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream output = new DataOutputStream(out);
-    DataOutputStream dataOutputStream = new DataOutputStream(output);
-    dataOutputStream.writeUTF(action.type);
-    dataOutputStream.writeInt(/* version */ 0);
-    dataOutputStream.writeUTF(action.uri.toString());
-    dataOutputStream.writeBoolean(action.isRemoveAction);
-    dataOutputStream.writeInt(action.data.length);
-    dataOutputStream.write(action.data);
-    dataOutputStream.writeInt(action.keys.size());
-    for (int i = 0; i < action.keys.size(); i++) {
-      StreamKey key = action.keys.get(i);
-      dataOutputStream.writeInt(key.groupIndex);
-      dataOutputStream.writeInt(key.trackIndex);
-    }
-    dataOutputStream.flush();
-
-    assertEqual(action, deserializeActionFromStream(out));
-  }
-
-  private static DownloadAction deserializeActionFromStream(ByteArrayOutputStream out)
-      throws IOException {
-    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
-    DataInputStream input = new DataInputStream(in);
-    return DownloadAction.deserializeFromStream(
-        new DownloadAction.Deserializer[] {HlsDownloadAction.DESERIALIZER}, input);
-  }
-
-  private static HlsDownloadAction createDownloadAction(Uri uri, StreamKey... keys) {
-    ArrayList<StreamKey> keysList = new ArrayList<>();
-    Collections.addAll(keysList, keys);
-    return HlsDownloadAction.createDownloadAction(uri, null, keysList);
-  }
-
-  private static HlsDownloadAction createRemoveAction(Uri uri) {
-    return HlsDownloadAction.createRemoveAction(uri, null);
-  }
-}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
index 825988994e..7d77a78316 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
@@ -35,37 +35,47 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.offline.DefaultDownloaderFactory;
+import com.google.android.exoplayer2.offline.DownloadRequest;
+import com.google.android.exoplayer2.offline.Downloader;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.DownloaderFactory;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
 import com.google.android.exoplayer2.upstream.cache.SimpleCache;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
+import org.mockito.Mockito;
 
 /** Unit tests for {@link HlsDownloader}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class HlsDownloaderTest {
 
   private SimpleCache cache;
   private File tempFolder;
+  private ProgressListener progressListener;
   private FakeDataSet fakeDataSet;
 
   @Before
   public void setUp() throws Exception {
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    tempFolder =
+        Util.createTempDirectory(ApplicationProvider.getApplicationContext(), "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
-
+    progressListener = new ProgressListener();
     fakeDataSet =
         new FakeDataSet()
             .setData(MASTER_PLAYLIST_URI, MASTER_PLAYLIST_DATA)
@@ -84,21 +94,38 @@ public void tearDown() {
     Util.recursiveDelete(tempFolder);
   }
 
+  @Test
+  public void testCreateWithDefaultDownloaderFactory() {
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    DownloaderFactory factory = new DefaultDownloaderFactory(constructorHelper);
+
+    Downloader downloader =
+        factory.createDownloader(
+            new DownloadRequest(
+                "id",
+                DownloadRequest.TYPE_HLS,
+                Uri.parse("https://www.test.com/download"),
+                Collections.singletonList(new StreamKey(/* groupIndex= */ 0, /* trackIndex= */ 0)),
+                /* customCacheKey= */ null,
+                /* data= */ null));
+    assertThat(downloader).isInstanceOf(HlsDownloader.class);
+  }
+
   @Test
   public void testCounterMethods() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(MASTER_PLAYLIST_URI, getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX));
-    downloader.download();
+    downloader.download(progressListener);
 
-    assertThat(downloader.getDownloadedBytes())
-        .isEqualTo(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12);
+    progressListener.assertBytesDownloaded(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12);
   }
 
   @Test
   public void testDownloadRepresentation() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(MASTER_PLAYLIST_URI, getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX));
-    downloader.download();
+    downloader.download(progressListener);
 
     assertCachedData(
         cache,
@@ -116,7 +143,7 @@ public void testDownloadMultipleRepresentations() throws Exception {
         getHlsDownloader(
             MASTER_PLAYLIST_URI,
             getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX, MASTER_MEDIA_PLAYLIST_2_INDEX));
-    downloader.download();
+    downloader.download(progressListener);
 
     assertCachedData(cache, fakeDataSet);
   }
@@ -135,7 +162,7 @@ public void testDownloadAllRepresentations() throws Exception {
         .setRandomData(MEDIA_PLAYLIST_3_DIR + "fileSequence2.ts", 15);
 
     HlsDownloader downloader = getHlsDownloader(MASTER_PLAYLIST_URI, getKeys());
-    downloader.download();
+    downloader.download(progressListener);
 
     assertCachedData(cache, fakeDataSet);
   }
@@ -146,7 +173,7 @@ public void testRemove() throws Exception {
         getHlsDownloader(
             MASTER_PLAYLIST_URI,
             getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX, MASTER_MEDIA_PLAYLIST_2_INDEX));
-    downloader.download();
+    downloader.download(progressListener);
     downloader.remove();
 
     assertCacheEmpty(cache);
@@ -155,7 +182,7 @@ public void testRemove() throws Exception {
   @Test
   public void testDownloadMediaPlaylist() throws Exception {
     HlsDownloader downloader = getHlsDownloader(MEDIA_PLAYLIST_1_URI, getKeys());
-    downloader.download();
+    downloader.download(progressListener);
 
     assertCachedData(
         cache,
@@ -178,7 +205,7 @@ public void testDownloadEncMediaPlaylist() throws Exception {
             .setRandomData("fileSequence2.ts", 12);
 
     HlsDownloader downloader = getHlsDownloader(ENC_MEDIA_PLAYLIST_URI, getKeys());
-    downloader.download();
+    downloader.download(progressListener);
     assertCachedData(cache, fakeDataSet);
   }
 
@@ -195,4 +222,18 @@ private HlsDownloader getHlsDownloader(String mediaPlaylistUri, List<StreamKey>
     }
     return streamKeys;
   }
+
+  private static final class ProgressListener implements Downloader.ProgressListener {
+
+    private long bytesDownloaded;
+
+    @Override
+    public void onProgress(long contentLength, long bytesDownloaded, float percentDownloaded) {
+      this.bytesDownloaded = bytesDownloaded;
+    }
+
+    public void assertBytesDownloaded(long bytesDownloaded) {
+      assertThat(this.bytesDownloaded).isEqualTo(bytesDownloaded);
+    }
+  }
 }
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index d03049efb3..095739271e 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -19,20 +19,24 @@
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.source.hls.HlsTrackMetadataEntry;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Test for {@link HlsMasterPlaylistParserTest}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class HlsMasterPlaylistParserTest {
 
   private static final String PLAYLIST_URI = "https://example.com/test.m3u8";
@@ -81,9 +85,21 @@
           + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
           + "http://example.com/low.m3u8\n";
 
+  private static final String PLAYLIST_WITH_CHANNELS_ATTRIBUTE =
+      " #EXTM3U \n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",CHANNELS=\"6\",NAME=\"Eng6\","
+          + "URI=\"something.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",CHANNELS=\"2/6\",NAME=\"Eng26\","
+          + "URI=\"something2.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",NAME=\"Eng\","
+          + "URI=\"something3.m3u8\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",AUDIO=\"audio\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n";
+
   private static final String PLAYLIST_WITHOUT_CC =
       " #EXTM3U \n"
-          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
+          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,GROUP-ID=\"cc1\","
           + "LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
           + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
           + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128,"
@@ -134,11 +150,55 @@
           + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"{$codecs}\"\n"
           + "http://example.com/{$tricky}\n";
 
+  private static final String PLAYLIST_WITH_MATCHING_STREAM_INF_URLS =
+      "#EXTM3U\n"
+          + "#EXT-X-VERSION:6\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=2227464,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud1\",SUBTITLES=\"sub1\"\n"
+          + "v5/prog_index.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=6453202,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud1\",SUBTITLES=\"sub1\"\n"
+          + "v8/prog_index.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=5054232,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud1\",SUBTITLES=\"sub1\"\n"
+          + "v7/prog_index.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=2448841,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud2\",SUBTITLES=\"sub1\"\n"
+          + "v5/prog_index.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=8399417,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud2\",SUBTITLES=\"sub1\"\n"
+          + "v9/prog_index.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=5275609,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud2\",SUBTITLES=\"sub1\"\n"
+          + "v7/prog_index.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=2256841,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud3\",SUBTITLES=\"sub1\"\n"
+          + "v5/prog_index.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=8207417,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud3\",SUBTITLES=\"sub1\"\n"
+          + "v9/prog_index.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=6482579,"
+          + "CLOSED-CAPTIONS=\"cc1\",AUDIO=\"aud3\",SUBTITLES=\"sub1\"\n"
+          + "v8/prog_index.m3u8\n"
+          + "\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aud1\",NAME=\"English\",URI=\"a1/index.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aud2\",NAME=\"English\",URI=\"a2/index.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aud3\",NAME=\"English\",URI=\"a3/index.m3u8\"\n"
+          + "\n"
+          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
+          + "GROUP-ID=\"cc1\",NAME=\"English\",INSTREAM-ID=\"CC1\"\n"
+          + "\n"
+          + "#EXT-X-MEDIA:TYPE=SUBTITLES,"
+          + "GROUP-ID=\"sub1\",NAME=\"English\",URI=\"s1/en/prog_index.m3u8\"\n";
+
   @Test
   public void testParseMasterPlaylist() throws IOException {
     HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_SIMPLE);
 
-    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+    List<HlsMasterPlaylist.Variant> variants = masterPlaylist.variants;
     assertThat(variants).hasSize(5);
     assertThat(masterPlaylist.muxedCaptionFormats).isNull();
 
@@ -146,32 +206,33 @@ public void testParseMasterPlaylist() throws IOException {
     assertThat(variants.get(0).format.codecs).isEqualTo("mp4a.40.2,avc1.66.30");
     assertThat(variants.get(0).format.width).isEqualTo(304);
     assertThat(variants.get(0).format.height).isEqualTo(128);
-    assertThat(variants.get(0).url).isEqualTo("http://example.com/low.m3u8");
+    assertThat(variants.get(0).url).isEqualTo(Uri.parse("http://example.com/low.m3u8"));
 
     assertThat(variants.get(1).format.bitrate).isEqualTo(1280000);
     assertThat(variants.get(1).format.codecs).isEqualTo("mp4a.40.2 , avc1.66.30 ");
-    assertThat(variants.get(1).url).isEqualTo("http://example.com/spaces_in_codecs.m3u8");
+    assertThat(variants.get(1).url)
+        .isEqualTo(Uri.parse("http://example.com/spaces_in_codecs.m3u8"));
 
     assertThat(variants.get(2).format.bitrate).isEqualTo(2560000);
     assertThat(variants.get(2).format.codecs).isNull();
     assertThat(variants.get(2).format.width).isEqualTo(384);
     assertThat(variants.get(2).format.height).isEqualTo(160);
     assertThat(variants.get(2).format.frameRate).isEqualTo(25.0f);
-    assertThat(variants.get(2).url).isEqualTo("http://example.com/mid.m3u8");
+    assertThat(variants.get(2).url).isEqualTo(Uri.parse("http://example.com/mid.m3u8"));
 
     assertThat(variants.get(3).format.bitrate).isEqualTo(7680000);
     assertThat(variants.get(3).format.codecs).isNull();
     assertThat(variants.get(3).format.width).isEqualTo(Format.NO_VALUE);
     assertThat(variants.get(3).format.height).isEqualTo(Format.NO_VALUE);
     assertThat(variants.get(3).format.frameRate).isEqualTo(29.997f);
-    assertThat(variants.get(3).url).isEqualTo("http://example.com/hi.m3u8");
+    assertThat(variants.get(3).url).isEqualTo(Uri.parse("http://example.com/hi.m3u8"));
 
     assertThat(variants.get(4).format.bitrate).isEqualTo(65000);
     assertThat(variants.get(4).format.codecs).isEqualTo("mp4a.40.5");
     assertThat(variants.get(4).format.width).isEqualTo(Format.NO_VALUE);
     assertThat(variants.get(4).format.height).isEqualTo(Format.NO_VALUE);
     assertThat(variants.get(4).format.frameRate).isEqualTo((float) Format.NO_VALUE);
-    assertThat(variants.get(4).url).isEqualTo("http://example.com/audio-only.m3u8");
+    assertThat(variants.get(4).url).isEqualTo(Uri.parse("http://example.com/audio-only.m3u8"));
   }
 
   @Test
@@ -179,7 +240,7 @@ public void testMasterPlaylistWithBandwdithAverage() throws IOException {
     HlsMasterPlaylist masterPlaylist =
         parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_AVG_BANDWIDTH);
 
-    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+    List<HlsMasterPlaylist.Variant> variants = masterPlaylist.variants;
 
     assertThat(variants.get(0).format.bitrate).isEqualTo(1280000);
     assertThat(variants.get(1).format.bitrate).isEqualTo(1270000);
@@ -202,7 +263,18 @@ public void testPlaylistWithClosedCaption() throws IOException {
     Format closedCaptionFormat = playlist.muxedCaptionFormats.get(0);
     assertThat(closedCaptionFormat.sampleMimeType).isEqualTo(MimeTypes.APPLICATION_CEA708);
     assertThat(closedCaptionFormat.accessibilityChannel).isEqualTo(4);
-    assertThat(closedCaptionFormat.language).isEqualTo("es");
+    assertThat(closedCaptionFormat.language).isEqualTo("spa");
+  }
+
+  @Test
+  public void testPlaylistWithChannelsAttribute() throws IOException {
+    HlsMasterPlaylist playlist =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_CHANNELS_ATTRIBUTE);
+    List<HlsMasterPlaylist.Rendition> audios = playlist.audios;
+    assertThat(audios).hasSize(3);
+    assertThat(audios.get(0).format.channelCount).isEqualTo(6);
+    assertThat(audios.get(1).format.channelCount).isEqualTo(2);
+    assertThat(audios.get(2).format.channelCount).isEqualTo(Format.NO_VALUE);
   }
 
   @Test
@@ -266,9 +338,65 @@ public void testIndependentSegments() throws IOException {
   public void testVariableSubstitution() throws IOException {
     HlsMasterPlaylist playlistWithSubstitutions =
         parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_VARIABLE_SUBSTITUTION);
-    HlsMasterPlaylist.HlsUrl variant = playlistWithSubstitutions.variants.get(0);
+    HlsMasterPlaylist.Variant variant = playlistWithSubstitutions.variants.get(0);
     assertThat(variant.format.codecs).isEqualTo("mp4a.40.5");
-    assertThat(variant.url).isEqualTo("http://example.com/This/{$nested}/reference/shouldnt/work");
+    assertThat(variant.url)
+        .isEqualTo(Uri.parse("http://example.com/This/{$nested}/reference/shouldnt/work"));
+  }
+
+  @Test
+  public void testHlsMetadata() throws IOException {
+    HlsMasterPlaylist playlist =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_MATCHING_STREAM_INF_URLS);
+    assertThat(playlist.variants).hasSize(4);
+    assertThat(playlist.variants.get(0).format.metadata)
+        .isEqualTo(
+            createExtXStreamInfMetadata(
+                createVariantInfo(/* bitrate= */ 2227464, /* audioGroupId= */ "aud1"),
+                createVariantInfo(/* bitrate= */ 2448841, /* audioGroupId= */ "aud2"),
+                createVariantInfo(/* bitrate= */ 2256841, /* audioGroupId= */ "aud3")));
+    assertThat(playlist.variants.get(1).format.metadata)
+        .isEqualTo(
+            createExtXStreamInfMetadata(
+                createVariantInfo(/* bitrate= */ 6453202, /* audioGroupId= */ "aud1"),
+                createVariantInfo(/* bitrate= */ 6482579, /* audioGroupId= */ "aud3")));
+    assertThat(playlist.variants.get(2).format.metadata)
+        .isEqualTo(
+            createExtXStreamInfMetadata(
+                createVariantInfo(/* bitrate= */ 5054232, /* audioGroupId= */ "aud1"),
+                createVariantInfo(/* bitrate= */ 5275609, /* audioGroupId= */ "aud2")));
+    assertThat(playlist.variants.get(3).format.metadata)
+        .isEqualTo(
+            createExtXStreamInfMetadata(
+                createVariantInfo(/* bitrate= */ 8399417, /* audioGroupId= */ "aud2"),
+                createVariantInfo(/* bitrate= */ 8207417, /* audioGroupId= */ "aud3")));
+
+    assertThat(playlist.audios).hasSize(3);
+    assertThat(playlist.audios.get(0).format.metadata)
+        .isEqualTo(createExtXMediaMetadata(/* groupId= */ "aud1", /* name= */ "English"));
+    assertThat(playlist.audios.get(1).format.metadata)
+        .isEqualTo(createExtXMediaMetadata(/* groupId= */ "aud2", /* name= */ "English"));
+    assertThat(playlist.audios.get(2).format.metadata)
+        .isEqualTo(createExtXMediaMetadata(/* groupId= */ "aud3", /* name= */ "English"));
+  }
+
+  private static Metadata createExtXStreamInfMetadata(HlsTrackMetadataEntry.VariantInfo... infos) {
+    return new Metadata(
+        new HlsTrackMetadataEntry(/* groupId= */ null, /* name= */ null, Arrays.asList(infos)));
+  }
+
+  private static Metadata createExtXMediaMetadata(String groupId, String name) {
+    return new Metadata(new HlsTrackMetadataEntry(groupId, name, Collections.emptyList()));
+  }
+
+  private static HlsTrackMetadataEntry.VariantInfo createVariantInfo(
+      long bitrate, String audioGroupId) {
+    return new HlsTrackMetadataEntry.VariantInfo(
+        bitrate,
+        /* videoGroupId= */ null,
+        audioGroupId,
+        /* subtitleGroupId= */ "sub1",
+        /* captionGroupId= */ "cc1");
   }
 
   private static HlsMasterPlaylist parseMasterPlaylist(String uri, String playlistString)
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
index e7bf3c6324..80cc6b23cd 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -16,9 +16,12 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.util.Util;
 import java.io.ByteArrayInputStream;
@@ -29,10 +32,9 @@
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Test for {@link HlsMediaPlaylistParserTest}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class HlsMediaPlaylistParserTest {
 
   @Test
@@ -365,6 +367,61 @@ public void testMapTag() throws IOException {
     assertThat(segments.get(3).initializationSegment.url).isEqualTo("init2.ts");
   }
 
+  @Test
+  public void testEncryptedMapTag() throws IOException {
+    Uri playlistUri = Uri.parse("https://example.com/test3.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:3\n"
+            + "#EXT-X-TARGETDURATION:5\n"
+            + "#EXT-X-MEDIA-SEQUENCE:10\n"
+            + "#EXT-X-KEY:METHOD=AES-128,"
+            + "URI=\"https://priv.example.com/key.php?r=2680\",IV=0x1566B\n"
+            + "#EXT-X-MAP:URI=\"init1.ts\""
+            + "#EXTINF:5.005,\n"
+            + "02/00/32.ts\n"
+            + "#EXT-X-KEY:METHOD=NONE\n"
+            + "#EXT-X-MAP:URI=\"init2.ts\""
+            + "#EXTINF:5.005,\n"
+            + "02/00/47.ts\n";
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
+    HlsMediaPlaylist playlist =
+        (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+
+    List<Segment> segments = playlist.segments;
+    Segment initSegment1 = segments.get(0).initializationSegment;
+    assertThat(initSegment1.fullSegmentEncryptionKeyUri)
+        .isEqualTo("https://priv.example.com/key.php?r=2680");
+    assertThat(initSegment1.encryptionIV).isEqualTo("0x1566B");
+    Segment initSegment2 = segments.get(1).initializationSegment;
+    assertThat(initSegment2.fullSegmentEncryptionKeyUri).isNull();
+    assertThat(initSegment2.encryptionIV).isNull();
+  }
+
+  @Test
+  public void testEncryptedMapTagWithNoIvFails() throws IOException {
+    Uri playlistUri = Uri.parse("https://example.com/test3.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:3\n"
+            + "#EXT-X-TARGETDURATION:5\n"
+            + "#EXT-X-MEDIA-SEQUENCE:10\n"
+            + "#EXT-X-KEY:METHOD=AES-128,"
+            + "URI=\"https://priv.example.com/key.php?r=2680\"\n"
+            + "#EXT-X-MAP:URI=\"init1.ts\""
+            + "#EXTINF:5.005,\n"
+            + "02/00/32.ts\n";
+    InputStream inputStream = new ByteArrayInputStream(Util.getUtf8Bytes(playlistString));
+
+    try {
+      new HlsPlaylistParser().parse(playlistUri, inputStream);
+      fail();
+    } catch (ParserException e) {
+      // Expected because the initialization segment does not have a defined initialization vector,
+      // although it is affected by an EXT-X-KEY tag.
+    }
+  }
+
   @Test
   public void testMasterPlaylistAttributeInheritance() throws IOException {
     Uri playlistUri = Uri.parse("https://example.com/test3.m3u8");
@@ -394,12 +451,15 @@ public void testMasterPlaylistAttributeInheritance() throws IOException {
             /* baseUri= */ "https://example.com/",
             /* tags= */ Collections.emptyList(),
             /* variants= */ Collections.emptyList(),
+            /* videos= */ Collections.emptyList(),
             /* audios= */ Collections.emptyList(),
             /* subtitles= */ Collections.emptyList(),
+            /* closedCaptions= */ Collections.emptyList(),
             /* muxedAudioFormat= */ null,
             /* muxedCaptionFormats= */ null,
             /* hasIndependentSegments= */ true,
-            /* variableDefinitions */ Collections.emptyMap());
+            /* variableDefinitions= */ Collections.emptyMap(),
+            /* sessionKeyDrmInitData= */ Collections.emptyList());
     HlsMediaPlaylist playlistWithInheritance =
         (HlsMediaPlaylist) new HlsPlaylistParser(masterPlaylist).parse(playlistUri, inputStream);
     assertThat(playlistWithInheritance.hasIndependentSegments).isTrue();
@@ -453,12 +513,15 @@ public void testInheritedVariableSubstitution() throws IOException {
             /* baseUri= */ "",
             /* tags= */ Collections.emptyList(),
             /* variants= */ Collections.emptyList(),
+            /* videos= */ Collections.emptyList(),
             /* audios= */ Collections.emptyList(),
             /* subtitles= */ Collections.emptyList(),
+            /* closedCaptions= */ Collections.emptyList(),
             /* muxedAudioFormat= */ null,
             /* muxedCaptionFormats= */ Collections.emptyList(),
             /* hasIndependentSegments= */ false,
-            variableDefinitions);
+            variableDefinitions,
+            /* sessionKeyDrmInitData= */ Collections.emptyList());
     HlsMediaPlaylist playlist =
         (HlsMediaPlaylist) new HlsPlaylistParser(masterPlaylist).parse(playlistUri, inputStream);
     for (int i = 1; i <= 4; i++) {
diff --git a/library/hls/src/test/resources/robolectric.properties b/library/hls/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/library/hls/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/library/smoothstreaming/README.md b/library/smoothstreaming/README.md
index 69265e8702..4fa24543d6 100644
--- a/library/smoothstreaming/README.md
+++ b/library/smoothstreaming/README.md
@@ -9,4 +9,4 @@ instantiate a `SsMediaSource` and pass it to `ExoPlayer.prepare`.
   `com.google.android.exoplayer2.source.smoothstreaming.*` belong to this
   module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/smoothstreaming/build.gradle b/library/smoothstreaming/build.gradle
index 2fce6b697c..a2e81fb304 100644
--- a/library/smoothstreaming/build.gradle
+++ b/library/smoothstreaming/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -26,7 +25,6 @@ android {
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
@@ -36,12 +34,14 @@ android {
         //    testCoverageEnabled = true
         // }
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/library/smoothstreaming/proguard-rules.txt b/library/smoothstreaming/proguard-rules.txt
deleted file mode 100644
index d14244d783..0000000000
--- a/library/smoothstreaming/proguard-rules.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-# Proguard rules specific to the smoothstreaming module.
-
-# Constructors accessed via reflection in SegmentDownloadAction
--dontnote com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction
--keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction {
-  static ** DESERIALIZER;
-}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index 9ac376efad..59e18195e2 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.smoothstreaming;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
@@ -61,14 +61,13 @@ public SsChunkSource createChunkSource(
         SsManifest manifest,
         int elementIndex,
         TrackSelection trackSelection,
-        TrackEncryptionBox[] trackEncryptionBoxes,
         @Nullable TransferListener transferListener) {
       DataSource dataSource = dataSourceFactory.createDataSource();
       if (transferListener != null) {
         dataSource.addTransferListener(transferListener);
       }
-      return new DefaultSsChunkSource(manifestLoaderErrorThrower, manifest, elementIndex,
-          trackSelection, dataSource, trackEncryptionBoxes);
+      return new DefaultSsChunkSource(
+          manifestLoaderErrorThrower, manifest, elementIndex, trackSelection, dataSource);
     }
 
   }
@@ -90,15 +89,13 @@ public SsChunkSource createChunkSource(
    * @param streamElementIndex The index of the stream element in the manifest.
    * @param trackSelection The track selection.
    * @param dataSource A {@link DataSource} suitable for loading the media data.
-   * @param trackEncryptionBoxes Track encryption boxes for the stream.
    */
   public DefaultSsChunkSource(
       LoaderErrorThrower manifestLoaderErrorThrower,
       SsManifest manifest,
       int streamElementIndex,
       TrackSelection trackSelection,
-      DataSource dataSource,
-      TrackEncryptionBox[] trackEncryptionBoxes) {
+      DataSource dataSource) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
     this.streamElementIndex = streamElementIndex;
@@ -110,6 +107,8 @@ public DefaultSsChunkSource(
     for (int i = 0; i < extractorWrappers.length; i++) {
       int manifestTrackIndex = trackSelection.getIndexInTrackGroup(i);
       Format format = streamElement.formats[manifestTrackIndex];
+      TrackEncryptionBox[] trackEncryptionBoxes =
+          format.drmInitData != null ? manifest.protectionElement.trackEncryptionBoxes : null;
       int nalUnitLengthFieldLength = streamElement.type == C.TRACK_TYPE_VIDEO ? 4 : 0;
       Track track = new Track(manifestTrackIndex, streamElement.type, streamElement.timescale,
           C.TIME_UNSET, manifest.durationUs, format, Track.TRANSFORMATION_NONE,
@@ -318,7 +317,7 @@ private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
      *
      * @param streamElement The {@link StreamElement} to wrap.
      * @param trackIndex The track index in the stream element.
-     * @param chunkIndex The chunk index at which the iterator will start.
+     * @param chunkIndex The index of the first available chunk.
      */
     public StreamElementIterator(StreamElement streamElement, int trackIndex, int chunkIndex) {
       super(/* fromIndex= */ chunkIndex, /* toIndex= */ streamElement.chunkCount - 1);
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
index f333a6f92c..b763a484b8 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
@@ -15,8 +15,7 @@
  */
 package com.google.android.exoplayer2.source.smoothstreaming;
 
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -38,7 +37,6 @@
      * @param manifest The initial manifest.
      * @param streamElementIndex The index of the corresponding stream element in the manifest.
      * @param trackSelection The track selection.
-     * @param trackEncryptionBoxes Track encryption boxes for the stream.
      * @param transferListener The transfer listener which should be informed of any data transfers.
      *     May be null if no listener is available.
      * @return The created {@link SsChunkSource}.
@@ -48,7 +46,6 @@ SsChunkSource createChunkSource(
         SsManifest manifest,
         int streamElementIndex,
         TrackSelection trackSelection,
-        TrackEncryptionBox[] trackEncryptionBoxes,
         @Nullable TransferListener transferListener);
   }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 14b54bc471..135ee4a58e 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -15,11 +15,10 @@
  */
 package com.google.android.exoplayer2.source.smoothstreaming;
 
-import android.support.annotation.Nullable;
-import android.util.Base64;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.SeekParameters;
-import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -29,7 +28,6 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.ChunkSampleStream;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
@@ -37,14 +35,11 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.List;
 
-/**
- * A SmoothStreaming {@link MediaPeriod}.
- */
-/* package */ final class SsMediaPeriod implements MediaPeriod,
-    SequenceableLoader.Callback<ChunkSampleStream<SsChunkSource>> {
-
-  private static final int INITIALIZATION_VECTOR_SIZE = 8;
+/** A SmoothStreaming {@link MediaPeriod}. */
+/* package */ final class SsMediaPeriod
+    implements MediaPeriod, SequenceableLoader.Callback<ChunkSampleStream<SsChunkSource>> {
 
   private final SsChunkSource.Factory chunkSourceFactory;
   private final @Nullable TransferListener transferListener;
@@ -53,7 +48,6 @@
   private final EventDispatcher eventDispatcher;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
-  private final TrackEncryptionBox[] trackEncryptionBoxes;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
 
   private @Nullable Callback callback;
@@ -71,6 +65,7 @@ public SsMediaPeriod(
       EventDispatcher eventDispatcher,
       LoaderErrorThrower manifestLoaderErrorThrower,
       Allocator allocator) {
+    this.manifest = manifest;
     this.chunkSourceFactory = chunkSourceFactory;
     this.transferListener = transferListener;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
@@ -78,18 +73,7 @@ public SsMediaPeriod(
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
-
     trackGroups = buildTrackGroups(manifest);
-    ProtectionElement protectionElement = manifest.protectionElement;
-    if (protectionElement != null) {
-      byte[] keyId = getProtectionElementKeyId(protectionElement.data);
-      // We assume pattern encryption does not apply.
-      trackEncryptionBoxes = new TrackEncryptionBox[] {
-          new TrackEncryptionBox(true, null, INITIALIZATION_VECTOR_SIZE, keyId, 0, 0, null)};
-    } else {
-      trackEncryptionBoxes = null;
-    }
-    this.manifest = manifest;
     sampleStreams = newSampleStreamArray(0);
     compositeSequenceableLoader =
         compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
@@ -112,6 +96,8 @@ public void release() {
     eventDispatcher.mediaPeriodReleased();
   }
 
+  // MediaPeriod implementation.
+
   @Override
   public void prepare(Callback callback, long positionUs) {
     this.callback = callback;
@@ -157,6 +143,19 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     return positionUs;
   }
 
+  @Override
+  public List<StreamKey> getStreamKeys(List<TrackSelection> trackSelections) {
+    List<StreamKey> streamKeys = new ArrayList<>();
+    for (int selectionIndex = 0; selectionIndex < trackSelections.size(); selectionIndex++) {
+      TrackSelection trackSelection = trackSelections.get(selectionIndex);
+      int streamElementIndex = trackGroups.indexOf(trackSelection.getTrackGroup());
+      for (int i = 0; i < trackSelection.length(); i++) {
+        streamKeys.add(new StreamKey(streamElementIndex, trackSelection.getIndexInTrackGroup(i)));
+      }
+    }
+    return streamKeys;
+  }
+
   @Override
   public void discardBuffer(long positionUs, boolean toKeyframe) {
     for (ChunkSampleStream<SsChunkSource> sampleStream : sampleStreams) {
@@ -211,7 +210,7 @@ public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParame
     return positionUs;
   }
 
-  // SequenceableLoader.Callback implementation
+  // SequenceableLoader.Callback implementation.
 
   @Override
   public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleStream) {
@@ -229,7 +228,6 @@ public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleSt
             manifest,
             streamElementIndex,
             selection,
-            trackEncryptionBoxes,
             transferListener);
     return new ChunkSampleStream<>(
         manifest.streamElements[streamElementIndex].type,
@@ -255,27 +253,4 @@ private static TrackGroupArray buildTrackGroups(SsManifest manifest) {
   private static ChunkSampleStream<SsChunkSource>[] newSampleStreamArray(int length) {
     return new ChunkSampleStream[length];
   }
-
-  private static byte[] getProtectionElementKeyId(byte[] initData) {
-    StringBuilder initDataStringBuilder = new StringBuilder();
-    for (int i = 0; i < initData.length; i += 2) {
-      initDataStringBuilder.append((char) initData[i]);
-    }
-    String initDataString = initDataStringBuilder.toString();
-    String keyIdString = initDataString.substring(
-        initDataString.indexOf("<KID>") + 5, initDataString.indexOf("</KID>"));
-    byte[] keyId = Base64.decode(keyIdString, Base64.DEFAULT);
-    swap(keyId, 0, 3);
-    swap(keyId, 1, 2);
-    swap(keyId, 4, 5);
-    swap(keyId, 6, 7);
-    return keyId;
-  }
-
-  private static void swap(byte[] data, int firstPosition, int secondPosition) {
-    byte temp = data[firstPosition];
-    data[firstPosition] = data[secondPosition];
-    data[secondPosition] = temp;
-  }
-
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index 103a52a55a..09820f092d 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -18,12 +18,12 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.offline.FilteringManifestParser;
+import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.BaseMediaSource;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.DefaultCompositeSequenceableLoaderFactory;
@@ -50,6 +50,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.List;
 
 /** A SmoothStreaming {@link MediaSource}. */
 public final class SsMediaSource extends BaseMediaSource
@@ -63,14 +64,15 @@
   public static final class Factory implements AdsMediaSource.MediaSourceFactory {
 
     private final SsChunkSource.Factory chunkSourceFactory;
-    private final @Nullable DataSource.Factory manifestDataSourceFactory;
+    @Nullable private final DataSource.Factory manifestDataSourceFactory;
 
-    private @Nullable ParsingLoadable.Parser<? extends SsManifest> manifestParser;
+    @Nullable private ParsingLoadable.Parser<? extends SsManifest> manifestParser;
+    @Nullable private List<StreamKey> streamKeys;
     private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
     private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private long livePresentationDelayMs;
     private boolean isCreateCalled;
-    private @Nullable Object tag;
+    @Nullable private Object tag;
 
     /**
      * Creates a new factory for {@link SsMediaSource}s.
@@ -178,6 +180,19 @@ public Factory setManifestParser(ParsingLoadable.Parser<? extends SsManifest> ma
       return this;
     }
 
+    /**
+     * Sets a list of {@link StreamKey stream keys} by which the manifest is filtered.
+     *
+     * @param streamKeys A list of {@link StreamKey stream keys}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setStreamKeys(List<StreamKey> streamKeys) {
+      Assertions.checkState(!isCreateCalled);
+      this.streamKeys = streamKeys;
+      return this;
+    }
+
     /**
      * Sets the factory to create composite {@link SequenceableLoader}s for when this media source
      * loads data from multiple streams (video, audio etc.). The default is an instance of {@link
@@ -208,6 +223,9 @@ public Factory setCompositeSequenceableLoaderFactory(
     public SsMediaSource createMediaSource(SsManifest manifest) {
       Assertions.checkArgument(!manifest.isLive);
       isCreateCalled = true;
+      if (streamKeys != null && !streamKeys.isEmpty()) {
+        manifest = manifest.copy(streamKeys);
+      }
       return new SsMediaSource(
           manifest,
           /* manifestUri= */ null,
@@ -248,6 +266,9 @@ public SsMediaSource createMediaSource(Uri manifestUri) {
       if (manifestParser == null) {
         manifestParser = new SsManifestParser();
       }
+      if (streamKeys != null) {
+        manifestParser = new FilteringManifestParser<>(manifestParser, streamKeys);
+      }
       return new SsMediaSource(
           /* manifest= */ null,
           Assertions.checkNotNull(manifestUri),
@@ -510,10 +531,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     if (sideloadedManifest) {
       manifestLoaderErrorThrower = new LoaderErrorThrower.Dummy();
@@ -533,7 +551,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     EventDispatcher eventDispatcher = createEventDispatcher(id);
     SsMediaPeriod period =
         new SsMediaPeriod(
@@ -609,7 +627,13 @@ public LoadErrorAction onLoadError(
       long loadDurationMs,
       IOException error,
       int errorCount) {
-    boolean isFatal = error instanceof ParserException;
+    long retryDelayMs =
+        loadErrorHandlingPolicy.getRetryDelayMsFor(
+            C.DATA_TYPE_MANIFEST, loadDurationMs, error, errorCount);
+    LoadErrorAction loadErrorAction =
+        retryDelayMs == C.TIME_UNSET
+            ? Loader.DONT_RETRY_FATAL
+            : Loader.createRetryAction(/* resetErrorCount= */ false, retryDelayMs);
     manifestEventDispatcher.loadError(
         loadable.dataSpec,
         loadable.getUri(),
@@ -619,8 +643,8 @@ public LoadErrorAction onLoadError(
         loadDurationMs,
         loadable.bytesLoaded(),
         error,
-        isFatal);
-    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
+        !loadErrorAction.isRetry());
+    return loadErrorAction;
   }
 
   // Internal methods
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
index 2c508f0fde..cfb772a86b 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.offline.FilterableManifest;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.util.Assertions;
@@ -41,10 +42,12 @@
 
     public final UUID uuid;
     public final byte[] data;
+    public final TrackEncryptionBox[] trackEncryptionBoxes;
 
-    public ProtectionElement(UUID uuid, byte[] data) {
+    public ProtectionElement(UUID uuid, byte[] data, TrackEncryptionBox[] trackEncryptionBoxes) {
       this.uuid = uuid;
       this.data = data;
+      this.trackEncryptionBoxes = trackEncryptionBoxes;
     }
   }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 3d5ade403a..66731660f5 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
+import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
@@ -397,9 +398,10 @@ public Object build() {
 
     public static final String TAG = "Protection";
     public static final String TAG_PROTECTION_HEADER = "ProtectionHeader";
-
     public static final String KEY_SYSTEM_ID = "SystemID";
 
+    private static final int INITIALIZATION_VECTOR_SIZE = 8;
+
     private boolean inProtectionHeader;
     private UUID uuid;
     private byte[] initData;
@@ -439,7 +441,44 @@ public void parseEndTag(XmlPullParser parser) {
 
     @Override
     public Object build() {
-      return new ProtectionElement(uuid, PsshAtomUtil.buildPsshAtom(uuid, initData));
+      return new ProtectionElement(
+          uuid, PsshAtomUtil.buildPsshAtom(uuid, initData), buildTrackEncryptionBoxes(initData));
+    }
+
+    private static TrackEncryptionBox[] buildTrackEncryptionBoxes(byte[] initData) {
+      return new TrackEncryptionBox[] {
+        new TrackEncryptionBox(
+            /* isEncrypted= */ true,
+            /* schemeType= */ null,
+            INITIALIZATION_VECTOR_SIZE,
+            getProtectionElementKeyId(initData),
+            /* defaultEncryptedBlocks= */ 0,
+            /* defaultClearBlocks= */ 0,
+            /* defaultInitializationVector= */ null)
+      };
+    }
+
+    private static byte[] getProtectionElementKeyId(byte[] initData) {
+      StringBuilder initDataStringBuilder = new StringBuilder();
+      for (int i = 0; i < initData.length; i += 2) {
+        initDataStringBuilder.append((char) initData[i]);
+      }
+      String initDataString = initDataStringBuilder.toString();
+      String keyIdString =
+          initDataString.substring(
+              initDataString.indexOf("<KID>") + 5, initDataString.indexOf("</KID>"));
+      byte[] keyId = Base64.decode(keyIdString, Base64.DEFAULT);
+      swap(keyId, 0, 3);
+      swap(keyId, 1, 2);
+      swap(keyId, 4, 5);
+      swap(keyId, 6, 7);
+      return keyId;
+    }
+
+    private static void swap(byte[] data, int firstPosition, int secondPosition) {
+      byte temp = data[firstPosition];
+      data[firstPosition] = data[secondPosition];
+      data[secondPosition] = temp;
     }
 
     private static String stripCurlyBraces(String uuidString) {
@@ -642,7 +681,8 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 height,
                 /* frameRate= */ Format.NO_VALUE,
                 codecSpecificData,
-                /* selectionFlags= */ 0);
+                /* selectionFlags= */ 0,
+                /* roleFlags= */ 0);
       } else if (type == C.TRACK_TYPE_AUDIO) {
         sampleMimeType = sampleMimeType == null ? MimeTypes.AUDIO_AAC : sampleMimeType;
         int channels = parseRequiredInt(parser, KEY_CHANNELS);
@@ -666,6 +706,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 samplingRate,
                 codecSpecificData,
                 /* selectionFlags= */ 0,
+                /* roleFlags= */ 0,
                 language);
       } else if (type == C.TRACK_TYPE_TEXT) {
         String language = (String) getNormalizedAttribute(KEY_LANGUAGE);
@@ -678,6 +719,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* codecs= */ null,
                 bitrate,
                 /* selectionFlags= */ 0,
+                /* roleFlags= */ 0,
                 language);
       } else {
         format =
@@ -689,6 +731,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* codecs= */ null,
                 bitrate,
                 /* selectionFlags= */ 0,
+                /* roleFlags= */ 0,
                 /* language= */ null);
       }
     }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java
index 4adf6acff7..b54b2abc74 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java
@@ -23,7 +23,9 @@
 
   /** Returns a fixed SmoothStreaming client manifest {@link Uri}. */
   public static Uri fixManifestUri(Uri manifestUri) {
-    if (Util.toLowerInvariant(manifestUri.getLastPathSegment()).matches("manifest(\\(.+\\))?")) {
+    String lastPathSegment = manifestUri.getLastPathSegment();
+    if (lastPathSegment != null
+        && Util.toLowerInvariant(lastPathSegment).matches("manifest(\\(.+\\))?")) {
       return manifestUri;
     }
     return Uri.withAppendedPath(manifestUri, "Manifest");
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java
deleted file mode 100644
index ad2196fd74..0000000000
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadAction.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.smoothstreaming.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.offline.DownloadAction;
-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.SegmentDownloadAction;
-import com.google.android.exoplayer2.offline.StreamKey;
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-
-/** An action to download or remove downloaded SmoothStreaming streams. */
-public final class SsDownloadAction extends SegmentDownloadAction {
-
-  private static final String TYPE = "ss";
-  private static final int VERSION = 1;
-
-  public static final Deserializer DESERIALIZER =
-      new SegmentDownloadActionDeserializer(TYPE, VERSION) {
-
-        @Override
-        protected StreamKey readKey(int version, DataInputStream input) throws IOException {
-          if (version > 0) {
-            return super.readKey(version, input);
-          }
-          int groupIndex = input.readInt();
-          int trackIndex = input.readInt();
-          return new StreamKey(groupIndex, trackIndex);
-        }
-
-        @Override
-        protected DownloadAction createDownloadAction(
-            Uri uri, boolean isRemoveAction, byte[] data, List<StreamKey> keys) {
-          return new SsDownloadAction(uri, isRemoveAction, data, keys);
-        }
-      };
-
-  /**
-   * Creates a SmoothStreaming download action.
-   *
-   * @param uri The URI of the media to be downloaded.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   * @param keys Keys of tracks to be downloaded. If empty, all tracks will be downloaded.
-   */
-  public static SsDownloadAction createDownloadAction(
-      Uri uri, @Nullable byte[] data, List<StreamKey> keys) {
-    return new SsDownloadAction(uri, /* isRemoveAction= */ false, data, keys);
-  }
-
-  /**
-   * Creates a SmoothStreaming remove action.
-   *
-   * @param uri The URI of the media to be removed.
-   * @param data Optional custom data for this action. If {@code null} an empty array will be used.
-   */
-  public static SsDownloadAction createRemoveAction(Uri uri, @Nullable byte[] data) {
-    return new SsDownloadAction(uri, /* isRemoveAction= */ true, data, Collections.emptyList());
-  }
-
-  /**
-   * @param uri The SmoothStreaming manifest URI.
-   * @param isRemoveAction Whether the data will be removed. If {@code false} it will be downloaded.
-   * @param data Optional custom data for this action.
-   * @param keys Keys of streams to be downloaded. If empty, all streams are downloaded. If {@code
-   *     removeAction} is true, {@code keys} must be empty.
-   * @deprecated Use {@link #createDownloadAction(Uri, byte[], List)} or {@link
-   *     #createRemoveAction(Uri, byte[])}.
-   */
-  @Deprecated
-  public SsDownloadAction(
-      Uri uri, boolean isRemoveAction, @Nullable byte[] data, List<StreamKey> keys) {
-    super(TYPE, VERSION, uri, isRemoveAction, data, keys);
-  }
-
-  @Override
-  public SsDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
-    return new SsDownloader(uri, keys, constructorHelper);
-  }
-
-}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
deleted file mode 100644
index 5125beff1c..0000000000
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.smoothstreaming.offline;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.offline.DownloadHelper;
-import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.offline.TrackKey;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.ParsingLoadable;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
-
-/** A {@link DownloadHelper} for SmoothStreaming streams. */
-public final class SsDownloadHelper extends DownloadHelper {
-
-  private final Uri uri;
-  private final DataSource.Factory manifestDataSourceFactory;
-
-  private @MonotonicNonNull SsManifest manifest;
-
-  public SsDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory) {
-    this.uri = uri;
-    this.manifestDataSourceFactory = manifestDataSourceFactory;
-  }
-
-  @Override
-  protected void prepareInternal() throws IOException {
-    DataSource dataSource = manifestDataSourceFactory.createDataSource();
-    manifest = ParsingLoadable.load(dataSource, new SsManifestParser(), uri, C.DATA_TYPE_MANIFEST);
-  }
-
-  /** Returns the SmoothStreaming manifest. Must not be called until after preparation completes. */
-  public SsManifest getManifest() {
-    Assertions.checkNotNull(manifest);
-    return manifest;
-  }
-
-  @Override
-  public int getPeriodCount() {
-    Assertions.checkNotNull(manifest);
-    return 1;
-  }
-
-  @Override
-  public TrackGroupArray getTrackGroups(int periodIndex) {
-    Assertions.checkNotNull(manifest);
-    SsManifest.StreamElement[] streamElements = manifest.streamElements;
-    TrackGroup[] trackGroups = new TrackGroup[streamElements.length];
-    for (int i = 0; i < streamElements.length; i++) {
-      trackGroups[i] = new TrackGroup(streamElements[i].formats);
-    }
-    return new TrackGroupArray(trackGroups);
-  }
-
-  @Override
-  public SsDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
-    return SsDownloadAction.createDownloadAction(uri, data, toStreamKeys(trackKeys));
-  }
-
-  @Override
-  public SsDownloadAction getRemoveAction(@Nullable byte[] data) {
-    return SsDownloadAction.createRemoveAction(uri, data);
-  }
-
-  private static List<StreamKey> toStreamKeys(List<TrackKey> trackKeys) {
-    List<StreamKey> representationKeys = new ArrayList<>(trackKeys.size());
-    for (int i = 0; i < trackKeys.size(); i++) {
-      TrackKey trackKey = trackKeys.get(i);
-      representationKeys.add(new StreamKey(trackKey.groupIndex, trackKey.trackIndex));
-    }
-    return representationKeys;
-  }
-}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
index 84ef251e5f..1331fe4617 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
@@ -37,7 +37,7 @@
  * <p>Example usage:
  *
  * <pre>{@code
- * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor());
+ * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor(), databaseProvider);
  * DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
  * DownloaderConstructorHelper constructorHelper =
  *     new DownloaderConstructorHelper(cache, factory);
@@ -48,7 +48,7 @@
  *         Collections.singletonList(new StreamKey(0, 0)),
  *         constructorHelper);
  * // Perform the download.
- * ssDownloader.download();
+ * ssDownloader.download(progressListener);
  * // Access downloaded data using CacheDataSource
  * CacheDataSource cacheDataSource =
  *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
@@ -68,8 +68,8 @@ public SsDownloader(
   }
 
   @Override
-  protected SsManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
-    return ParsingLoadable.load(dataSource, new SsManifestParser(), uri, C.DATA_TYPE_MANIFEST);
+  protected SsManifest getManifest(DataSource dataSource, DataSpec dataSpec) throws IOException {
+    return ParsingLoadable.load(dataSource, new SsManifestParser(), dataSpec, C.DATA_TYPE_MANIFEST);
   }
 
   @Override
diff --git a/library/smoothstreaming/src/test/assets/sample_ismc_1 b/library/smoothstreaming/src/test/assets/sample_ismc_1
index 25a37d65b4..1d279d0a67 100644
--- a/library/smoothstreaming/src/test/assets/sample_ismc_1
+++ b/library/smoothstreaming/src/test/assets/sample_ismc_1
@@ -3,7 +3,7 @@
     Duration="2300000000" TimeScale="10000000">
     <Protection>
         <ProtectionHeader SystemID="9A04F079-9840-4286-AB92-E65BE0885F95">
-            <!-- Base 64-Encoded data omitted for clarity -->
+            fgMAAAEAAQB0AzwAVwBSAE0ASABFAEEARABFAFIAIAB4AG0AbABuAHMAPQAiAGgAdAB0AHAAOgAvAC8AcwBjAGgAZQBtAGEAcwAuAG0AaQBjAHIAbwBzAG8AZgB0AC4AYwBvAG0ALwBEAFIATQAvADIAMAAwADcALwAwADMALwBQAGwAYQB5AFIAZQBhAGQAeQBIAGUAYQBkAGUAcgAiACAAdgBlAHIAcwBpAG8AbgA9ACIANAAuADAALgAwAC4AMAAiAD4APABEAEEAVABBAD4APABQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsARQBZAEwARQBOAD4AMQA2ADwALwBLAEUAWQBMAEUATgA+ADwAQQBMAEcASQBEAD4AQQBFAFMAQwBUAFIAPAAvAEEATABHAEkARAA+ADwALwBQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsASQBEAD4AQgBhAFUATQBPAEcAYwBzAGgAVQBDAEQAZAB3ADMANABZAGMAawBmAFoAQQA9AD0APAAvAEsASQBEAD4APABDAEgARQBDAEsAUwBVAE0APgBnADcATgBhAFIARABJAEkATwA5ADAAPQA8AC8AQwBIAEUAQwBLAFMAVQBNAD4APABMAEEAXwBVAFIATAA+AGgAdAB0AHAAcwA6AC8ALwBUAC0ATwBOAEwASQBOAEUALgBEAFUATQBNAFkALQBTAEUAUgBWAEUAUgAvAEEAcgB0AGUAbQBpAHMATABpAGMAZQBuAHMAZQBTAGUAcgB2AGUAcgAvAFAAbABhAHkAUgBlAGEAZAB5AE0AYQBuAGEAZwBlAHIALgBhAHMAbQB4ADwALwBMAEEAXwBVAFIATAA+ADwAQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwAQwBJAEQAPgAxADcANQA4ADIANgA8AC8AQwBJAEQAPgA8AEkASQBTAF8ARABSAE0AXwBWAEUAUgBTAEkATwBOAD4ANwAuADEALgAxADUANgA1AC4ANAA8AC8ASQBJAFMAXwBEAFIATQBfAFYARQBSAFMASQBPAE4APgA8AC8AQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwALwBEAEEAVABBAD4APAAvAFcAUgBNAEgARQBBAEQARQBSAD4A
         </ProtectionHeader>
     </Protection>
 
diff --git a/library/smoothstreaming/src/test/assets/sample_ismc_2 b/library/smoothstreaming/src/test/assets/sample_ismc_2
index 5875a18183..7f2a53036f 100644
--- a/library/smoothstreaming/src/test/assets/sample_ismc_2
+++ b/library/smoothstreaming/src/test/assets/sample_ismc_2
@@ -3,7 +3,7 @@
     Duration="2300000000" TimeScale="10000000">
     <Protection>
         <ProtectionHeader SystemID="{9A04F079-9840-4286-AB92-E65BE0885F95}">
-            <!-- Base 64-Encoded data omitted for clarity -->
+            fgMAAAEAAQB0AzwAVwBSAE0ASABFAEEARABFAFIAIAB4AG0AbABuAHMAPQAiAGgAdAB0AHAAOgAvAC8AcwBjAGgAZQBtAGEAcwAuAG0AaQBjAHIAbwBzAG8AZgB0AC4AYwBvAG0ALwBEAFIATQAvADIAMAAwADcALwAwADMALwBQAGwAYQB5AFIAZQBhAGQAeQBIAGUAYQBkAGUAcgAiACAAdgBlAHIAcwBpAG8AbgA9ACIANAAuADAALgAwAC4AMAAiAD4APABEAEEAVABBAD4APABQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsARQBZAEwARQBOAD4AMQA2ADwALwBLAEUAWQBMAEUATgA+ADwAQQBMAEcASQBEAD4AQQBFAFMAQwBUAFIAPAAvAEEATABHAEkARAA+ADwALwBQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsASQBEAD4AQgBhAFUATQBPAEcAYwBzAGgAVQBDAEQAZAB3ADMANABZAGMAawBmAFoAQQA9AD0APAAvAEsASQBEAD4APABDAEgARQBDAEsAUwBVAE0APgBnADcATgBhAFIARABJAEkATwA5ADAAPQA8AC8AQwBIAEUAQwBLAFMAVQBNAD4APABMAEEAXwBVAFIATAA+AGgAdAB0AHAAcwA6AC8ALwBUAC0ATwBOAEwASQBOAEUALgBEAFUATQBNAFkALQBTAEUAUgBWAEUAUgAvAEEAcgB0AGUAbQBpAHMATABpAGMAZQBuAHMAZQBTAGUAcgB2AGUAcgAvAFAAbABhAHkAUgBlAGEAZAB5AE0AYQBuAGEAZwBlAHIALgBhAHMAbQB4ADwALwBMAEEAXwBVAFIATAA+ADwAQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwAQwBJAEQAPgAxADcANQA4ADIANgA8AC8AQwBJAEQAPgA8AEkASQBTAF8ARABSAE0AXwBWAEUAUgBTAEkATwBOAD4ANwAuADEALgAxADUANgA1AC4ANAA8AC8ASQBJAFMAXwBEAFIATQBfAFYARQBSAFMASQBPAE4APgA8AC8AQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwALwBEAEEAVABBAD4APAAvAFcAUgBNAEgARQBBAEQARQBSAD4A
         </ProtectionHeader>
     </Protection>
 
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriodTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriodTest.java
new file mode 100644
index 0000000000..cb1dd2b700
--- /dev/null
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriodTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming;
+
+import static com.google.android.exoplayer2.source.smoothstreaming.SsTestUtils.createSsManifest;
+import static com.google.android.exoplayer2.source.smoothstreaming.SsTestUtils.createStreamElement;
+import static org.mockito.Mockito.mock;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
+import com.google.android.exoplayer2.testutil.MediaPeriodAsserts;
+import com.google.android.exoplayer2.testutil.MediaPeriodAsserts.FilterableManifestMediaPeriodFactory;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.MimeTypes;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link SsMediaPeriod}. */
+@RunWith(AndroidJUnit4.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public class SsMediaPeriodTest {
+
+  @Test
+  public void getSteamKeys_isCompatibleWithSsManifestFilter() {
+    SsManifest testManifest =
+        createSsManifest(
+            createStreamElement(
+                /* name= */ "video",
+                C.TRACK_TYPE_VIDEO,
+                createVideoFormat(/* bitrate= */ 200000),
+                createVideoFormat(/* bitrate= */ 400000),
+                createVideoFormat(/* bitrate= */ 800000)),
+            createStreamElement(
+                /* name= */ "audio",
+                C.TRACK_TYPE_AUDIO,
+                createAudioFormat(/* bitrate= */ 48000),
+                createAudioFormat(/* bitrate= */ 96000)),
+            createStreamElement(
+                /* name= */ "text", C.TRACK_TYPE_TEXT, createTextFormat(/* language= */ "eng")));
+    FilterableManifestMediaPeriodFactory<SsManifest> mediaPeriodFactory =
+        (manifest, periodIndex) ->
+            new SsMediaPeriod(
+                manifest,
+                mock(SsChunkSource.Factory.class),
+                mock(TransferListener.class),
+                mock(CompositeSequenceableLoaderFactory.class),
+                mock(LoadErrorHandlingPolicy.class),
+                new EventDispatcher()
+                    .withParameters(
+                        /* windowIndex= */ 0,
+                        /* mediaPeriodId= */ new MediaPeriodId(/* periodUid= */ new Object()),
+                        /* mediaTimeOffsetMs= */ 0),
+                mock(LoaderErrorThrower.class),
+                mock(Allocator.class));
+
+    MediaPeriodAsserts.assertGetStreamKeysAndManifestFilterIntegration(
+        mediaPeriodFactory, testManifest);
+  }
+
+  private static Format createVideoFormat(int bitrate) {
+    return Format.createContainerFormat(
+        /* id= */ null,
+        /* label= */ null,
+        MimeTypes.VIDEO_MP4,
+        MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        bitrate,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        /* language= */ null);
+  }
+
+  private static Format createAudioFormat(int bitrate) {
+    return Format.createContainerFormat(
+        /* id= */ null,
+        /* label= */ null,
+        MimeTypes.AUDIO_MP4,
+        MimeTypes.AUDIO_AAC,
+        /* codecs= */ null,
+        bitrate,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        /* language= */ null);
+  }
+
+  private static Format createTextFormat(String language) {
+    return Format.createContainerFormat(
+        /* id= */ null,
+        /* label= */ null,
+        MimeTypes.APPLICATION_MP4,
+        MimeTypes.TEXT_VTT,
+        /* codecs= */ null,
+        /* bitrate= */ Format.NO_VALUE,
+        /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
+        language);
+  }
+}
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/SsTestUtils.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/SsTestUtils.java
new file mode 100644
index 0000000000..1e770756bc
--- /dev/null
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/SsTestUtils.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
+import java.util.Collections;
+
+/** Util methods for SmoothStreaming tests. */
+public class SsTestUtils {
+
+  private static final int TEST_MAJOR_VERSION = 1;
+  private static final int TEST_MINOR_VERSION = 2;
+  private static final int TEST_TIMESCALE = 1000;
+  private static final int TEST_DURATION = 5000;
+  private static final int TEST_DVR_WINDOW_LENGTH = 0;
+  private static final int TEST_LOOKAHEAD_COUNT = 0;
+  private static final boolean TEST_IS_LIVE = false;
+  private static final String TEST_BASE_URI = "baseUri";
+  private static final String TEST_CHUNK_TEMPLATE = "chunkTemplate";
+  private static final String TEST_SUB_TYPE = "subType";
+  private static final int TEST_MAX_WIDTH = 1024;
+  private static final int TEST_MAX_HEIGHT = 768;
+  private static final String TEST_LANGUAGE = "eng";
+  private static final ProtectionElement TEST_PROTECTION_ELEMENT =
+      new ProtectionElement(C.WIDEVINE_UUID, new byte[0], new TrackEncryptionBox[0]);
+
+  private SsTestUtils() {}
+
+  /** Creates test manifest with the given stream elements. */
+  public static SsManifest createSsManifest(StreamElement... streamElements) {
+    return new SsManifest(
+        TEST_MAJOR_VERSION,
+        TEST_MINOR_VERSION,
+        TEST_TIMESCALE,
+        TEST_DURATION,
+        TEST_DVR_WINDOW_LENGTH,
+        TEST_LOOKAHEAD_COUNT,
+        TEST_IS_LIVE,
+        TEST_PROTECTION_ELEMENT,
+        streamElements);
+  }
+
+  /** Creates test video stream element with the given name, track type and formats. */
+  public static StreamElement createStreamElement(String name, int trackType, Format... formats) {
+    return new StreamElement(
+        TEST_BASE_URI,
+        TEST_CHUNK_TEMPLATE,
+        trackType,
+        TEST_SUB_TYPE,
+        TEST_TIMESCALE,
+        name,
+        TEST_MAX_WIDTH,
+        TEST_MAX_HEIGHT,
+        TEST_MAX_WIDTH,
+        TEST_MAX_HEIGHT,
+        TEST_LANGUAGE,
+        formats,
+        /* chunkStartTimes= */ Collections.emptyList(),
+        /* lastChunkDuration= */ 0);
+  }
+}
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
index 2ce9fec970..94be71e84e 100644
--- a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
@@ -16,15 +16,15 @@
 package com.google.android.exoplayer2.source.smoothstreaming.manifest;
 
 import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 /** Unit tests for {@link SsManifestParser}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class SsManifestParserTest {
 
   private static final String SAMPLE_ISMC_1 = "sample_ismc_1";
@@ -36,9 +36,9 @@ public void testParseSmoothStreamingManifest() throws IOException {
     SsManifestParser parser = new SsManifestParser();
     parser.parse(
         Uri.parse("https://example.com/test.ismc"),
-        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_ISMC_1));
+        TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_ISMC_1));
     parser.parse(
         Uri.parse("https://example.com/test.ismc"),
-        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_ISMC_2));
+        TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_ISMC_2));
   }
 }
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
index dc8d6754f5..427cd9b5da 100644
--- a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer2.source.smoothstreaming.manifest;
 
+import static com.google.android.exoplayer2.source.smoothstreaming.SsTestUtils.createSsManifest;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
+import com.google.android.exoplayer2.source.smoothstreaming.SsTestUtils;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.Arrays;
@@ -29,20 +31,17 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit tests for {@link SsManifest}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class SsManifestTest {
 
-  private static final ProtectionElement DUMMY_PROTECTION_ELEMENT =
-      new ProtectionElement(C.WIDEVINE_UUID, new byte[] {0, 1, 2});
-
   @Test
   public void testCopy() throws Exception {
     Format[][] formats = newFormats(2, 3);
     SsManifest sourceManifest =
-        newSsManifest(newStreamElement("1", formats[0]), newStreamElement("2", formats[1]));
+        createSsManifest(
+            createStreamElement("1", formats[0]), createStreamElement("2", formats[1]));
 
     List<StreamKey> keys =
         Arrays.asList(new StreamKey(0, 0), new StreamKey(0, 2), new StreamKey(1, 0));
@@ -52,9 +51,9 @@ public void testCopy() throws Exception {
     SsManifest copyManifest = sourceManifest.copy(keys);
 
     SsManifest expectedManifest =
-        newSsManifest(
-            newStreamElement("1", formats[0][0], formats[0][2]),
-            newStreamElement("2", formats[1][0]));
+        createSsManifest(
+            createStreamElement("1", formats[0][0], formats[0][2]),
+            createStreamElement("2", formats[1][0]));
     assertManifestEquals(expectedManifest, copyManifest);
   }
 
@@ -62,13 +61,14 @@ public void testCopy() throws Exception {
   public void testCopyRemoveStreamElement() throws Exception {
     Format[][] formats = newFormats(2, 3);
     SsManifest sourceManifest =
-        newSsManifest(newStreamElement("1", formats[0]), newStreamElement("2", formats[1]));
+        createSsManifest(
+            createStreamElement("1", formats[0]), createStreamElement("2", formats[1]));
 
     List<StreamKey> keys = Collections.singletonList(new StreamKey(1, 0));
 
     SsManifest copyManifest = sourceManifest.copy(keys);
 
-    SsManifest expectedManifest = newSsManifest(newStreamElement("2", formats[1][0]));
+    SsManifest expectedManifest = createSsManifest(createStreamElement("2", formats[1][0]));
     assertManifestEquals(expectedManifest, copyManifest);
   }
 
@@ -109,26 +109,8 @@ private static void assertManifestEquals(SsManifest expected, SsManifest actual)
     return formats;
   }
 
-  private static SsManifest newSsManifest(StreamElement... streamElements) {
-    return new SsManifest(1, 2, 1000, 5000, 0, 0, false, DUMMY_PROTECTION_ELEMENT, streamElements);
-  }
-
-  private static StreamElement newStreamElement(String name, Format... formats) {
-    return new StreamElement(
-        "baseUri",
-        "chunkTemplate",
-        C.TRACK_TYPE_VIDEO,
-        "subType",
-        1000,
-        name,
-        1024,
-        768,
-        1024,
-        768,
-        null,
-        formats,
-        Collections.emptyList(),
-        0);
+  private static StreamElement createStreamElement(String name, Format... formats) {
+    return SsTestUtils.createStreamElement(name, C.TRACK_TYPE_VIDEO, formats);
   }
 
   private static Format newFormat(String id) {
@@ -140,6 +122,7 @@ private static Format newFormat(String id) {
         /* codecs= */ null,
         /* bitrate= */ Format.NO_VALUE,
         /* selectionFlags= */ 0,
+        /* roleFlags= */ 0,
         /* language= */ null);
   }
 }
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/DownloadHelperTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/DownloadHelperTest.java
new file mode 100644
index 0000000000..4da08f7631
--- /dev/null
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/DownloadHelperTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.offline;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test to verify creation of a SmoothStreaming {@link DownloadHelper}. */
+@RunWith(AndroidJUnit4.class)
+public final class DownloadHelperTest {
+
+  @Test
+  public void staticDownloadHelperForSmoothStreaming_doesNotThrow() {
+    DownloadHelper.forSmoothStreaming(
+        Uri.parse("http://uri"),
+        new FakeDataSource.Factory(),
+        (handler, videoListener, audioListener, text, metadata, drm) -> new Renderer[0]);
+    DownloadHelper.forSmoothStreaming(
+        Uri.parse("http://uri"),
+        new FakeDataSource.Factory(),
+        (handler, videoListener, audioListener, text, metadata, drm) -> new Renderer[0],
+        /* drmSessionManager= */ null,
+        DownloadHelper.DEFAULT_TRACK_SELECTOR_PARAMETERS);
+  }
+}
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadActionTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadActionTest.java
deleted file mode 100644
index fea03902ec..0000000000
--- a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadActionTest.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.smoothstreaming.offline;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.offline.DownloadAction;
-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.offline.StreamKey;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-
-/** Unit tests for {@link SsDownloadAction}. */
-@RunWith(RobolectricTestRunner.class)
-public class SsDownloadActionTest {
-
-  private Uri uri1;
-  private Uri uri2;
-
-  @Before
-  public void setUp() {
-    uri1 = Uri.parse("http://test/1.uri");
-    uri2 = Uri.parse("http://test/2.uri");
-  }
-
-  @Test
-  public void testDownloadActionIsNotRemoveAction() {
-    DownloadAction action = createDownloadAction(uri1);
-    assertThat(action.isRemoveAction).isFalse();
-  }
-
-  @Test
-  public void testRemoveActionIsRemoveAction() {
-    DownloadAction action2 = createRemoveAction(uri1);
-    assertThat(action2.isRemoveAction).isTrue();
-  }
-
-  @Test
-  public void testCreateDownloader() {
-    MockitoAnnotations.initMocks(this);
-    DownloadAction action = createDownloadAction(uri1);
-    DownloaderConstructorHelper constructorHelper =
-        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
-    assertThat(action.createDownloader(constructorHelper)).isNotNull();
-  }
-
-  @Test
-  public void testSameUriDifferentAction_IsSameMedia() {
-    DownloadAction action1 = createRemoveAction(uri1);
-    DownloadAction action2 = createDownloadAction(uri1);
-    assertThat(action1.isSameMedia(action2)).isTrue();
-  }
-
-  @Test
-  public void testDifferentUriAndAction_IsNotSameMedia() {
-    DownloadAction action3 = createRemoveAction(uri2);
-    DownloadAction action4 = createDownloadAction(uri1);
-    assertThat(action3.isSameMedia(action4)).isFalse();
-  }
-
-  @SuppressWarnings("EqualsWithItself")
-  @Test
-  public void testEquals() {
-    DownloadAction action1 = createRemoveAction(uri1);
-    assertThat(action1.equals(action1)).isTrue();
-
-    DownloadAction action2 = createRemoveAction(uri1);
-    DownloadAction action3 = createRemoveAction(uri1);
-    assertEqual(action2, action3);
-
-    DownloadAction action4 = createRemoveAction(uri1);
-    DownloadAction action5 = createDownloadAction(uri1);
-    assertNotEqual(action4, action5);
-
-    DownloadAction action6 = createDownloadAction(uri1);
-    DownloadAction action7 = createDownloadAction(uri1, new StreamKey(0, 0));
-    assertNotEqual(action6, action7);
-
-    DownloadAction action8 = createDownloadAction(uri1, new StreamKey(1, 1));
-    DownloadAction action9 = createDownloadAction(uri1, new StreamKey(0, 0));
-    assertNotEqual(action8, action9);
-
-    DownloadAction action10 = createRemoveAction(uri1);
-    DownloadAction action11 = createRemoveAction(uri2);
-    assertNotEqual(action10, action11);
-
-    DownloadAction action12 = createDownloadAction(uri1, new StreamKey(0, 0), new StreamKey(1, 1));
-    DownloadAction action13 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
-    assertEqual(action12, action13);
-
-    DownloadAction action14 = createDownloadAction(uri1, new StreamKey(0, 0));
-    DownloadAction action15 = createDownloadAction(uri1, new StreamKey(1, 1), new StreamKey(0, 0));
-    assertNotEqual(action14, action15);
-
-    DownloadAction action16 = createDownloadAction(uri1);
-    DownloadAction action17 = createDownloadAction(uri1);
-    assertEqual(action16, action17);
-  }
-
-  @Test
-  public void testSerializerGetType() {
-    DownloadAction action = createDownloadAction(uri1);
-    assertThat(action.type).isNotNull();
-  }
-
-  @Test
-  public void testSerializerWriteRead() throws Exception {
-    doTestSerializationRoundTrip(createDownloadAction(uri1));
-    doTestSerializationRoundTrip(createRemoveAction(uri1));
-    doTestSerializationRoundTrip(
-        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
-  }
-
-  @Test
-  public void testSerializerVersion0() throws Exception {
-    doTestSerializationV0RoundTrip(createDownloadAction(uri1));
-    doTestSerializationV0RoundTrip(createRemoveAction(uri1));
-    doTestSerializationV0RoundTrip(
-        createDownloadAction(uri2, new StreamKey(0, 0), new StreamKey(1, 1)));
-  }
-
-  private static void assertNotEqual(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1).isNotEqualTo(action2);
-    assertThat(action2).isNotEqualTo(action1);
-  }
-
-  private static void assertEqual(DownloadAction action1, DownloadAction action2) {
-    assertThat(action1).isEqualTo(action2);
-    assertThat(action2).isEqualTo(action1);
-  }
-
-  private static void doTestSerializationRoundTrip(DownloadAction action) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream output = new DataOutputStream(out);
-    DownloadAction.serializeToStream(action, output);
-
-    assertEqual(action, deserializeActionFromStream(out));
-  }
-
-  private static void doTestSerializationV0RoundTrip(SsDownloadAction action) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream output = new DataOutputStream(out);
-    DataOutputStream dataOutputStream = new DataOutputStream(output);
-    dataOutputStream.writeUTF(action.type);
-    dataOutputStream.writeInt(/* version */ 0);
-    dataOutputStream.writeUTF(action.uri.toString());
-    dataOutputStream.writeBoolean(action.isRemoveAction);
-    dataOutputStream.writeInt(action.data.length);
-    dataOutputStream.write(action.data);
-    dataOutputStream.writeInt(action.keys.size());
-    for (int i = 0; i < action.keys.size(); i++) {
-      StreamKey key = action.keys.get(i);
-      dataOutputStream.writeInt(key.groupIndex);
-      dataOutputStream.writeInt(key.trackIndex);
-    }
-    dataOutputStream.flush();
-
-    assertEqual(action, deserializeActionFromStream(out));
-  }
-
-  private static DownloadAction deserializeActionFromStream(ByteArrayOutputStream out)
-      throws IOException {
-    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
-    DataInputStream input = new DataInputStream(in);
-    return DownloadAction.deserializeFromStream(
-        new DownloadAction.Deserializer[] {SsDownloadAction.DESERIALIZER}, input);
-  }
-
-  private static SsDownloadAction createDownloadAction(Uri uri, StreamKey... keys) {
-    ArrayList<StreamKey> keysList = new ArrayList<>();
-    Collections.addAll(keysList, keys);
-    return SsDownloadAction.createDownloadAction(uri, null, keysList);
-  }
-
-  private static SsDownloadAction createRemoveAction(Uri uri) {
-    return SsDownloadAction.createRemoveAction(uri, null);
-  }
-}
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloaderTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloaderTest.java
new file mode 100644
index 0000000000..5560a724c8
--- /dev/null
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloaderTest.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.offline;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.offline.DefaultDownloaderFactory;
+import com.google.android.exoplayer2.offline.DownloadRequest;
+import com.google.android.exoplayer2.offline.Downloader;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.DownloaderFactory;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+
+/** Unit tests for {@link SsDownloader}. */
+@RunWith(AndroidJUnit4.class)
+public final class SsDownloaderTest {
+
+  @Test
+  public void createWithDefaultDownloaderFactory() throws Exception {
+    DownloaderConstructorHelper constructorHelper =
+        new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
+    DownloaderFactory factory = new DefaultDownloaderFactory(constructorHelper);
+
+    Downloader downloader =
+        factory.createDownloader(
+            new DownloadRequest(
+                "id",
+                DownloadRequest.TYPE_SS,
+                Uri.parse("https://www.test.com/download"),
+                Collections.singletonList(new StreamKey(/* groupIndex= */ 0, /* trackIndex= */ 0)),
+                /* customCacheKey= */ null,
+                /* data= */ null));
+    assertThat(downloader).isInstanceOf(SsDownloader.class);
+  }
+}
diff --git a/library/smoothstreaming/src/test/resources/robolectric.properties b/library/smoothstreaming/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/library/smoothstreaming/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/library/ui/README.md b/library/ui/README.md
index 34e93e43af..341ea2fb16 100644
--- a/library/ui/README.md
+++ b/library/ui/README.md
@@ -7,4 +7,4 @@ Provides UI components and resources for use with ExoPlayer.
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ui.*`
   belong to this module.
 
-[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index 367f15f028..49446b25de 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -35,12 +34,14 @@ android {
         //    testCoverageEnabled = true
         // }
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-media-compat:' + supportLibraryVersion
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.media:media:1.0.0'
+    implementation 'androidx.annotation:annotation:1.0.2'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index 0d4c6a4038..d4a37ea4ef 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -17,7 +17,7 @@
 
 import android.content.Context;
 import android.content.res.TypedArray;
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 import java.lang.annotation.Documented;
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
index 8c7c507f92..da2081db31 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
@@ -137,23 +137,40 @@ protected String getPlayerStateString() {
   /** Returns a string containing video debugging information. */
   protected String getVideoString() {
     Format format = player.getVideoFormat();
-    if (format == null) {
+    DecoderCounters decoderCounters = player.getVideoDecoderCounters();
+    if (format == null || decoderCounters == null) {
       return "";
     }
-    return "\n" + format.sampleMimeType + "(id:" + format.id + " r:" + format.width + "x"
-        + format.height + getPixelAspectRatioString(format.pixelWidthHeightRatio)
-        + getDecoderCountersBufferCountString(player.getVideoDecoderCounters()) + ")";
+    return "\n"
+        + format.sampleMimeType
+        + "(id:"
+        + format.id
+        + " r:"
+        + format.width
+        + "x"
+        + format.height
+        + getPixelAspectRatioString(format.pixelWidthHeightRatio)
+        + getDecoderCountersBufferCountString(decoderCounters)
+        + ")";
   }
 
   /** Returns a string containing audio debugging information. */
   protected String getAudioString() {
     Format format = player.getAudioFormat();
-    if (format == null) {
+    DecoderCounters decoderCounters = player.getAudioDecoderCounters();
+    if (format == null || decoderCounters == null) {
       return "";
     }
-    return "\n" + format.sampleMimeType + "(id:" + format.id + " hz:" + format.sampleRate + " ch:"
+    return "\n"
+        + format.sampleMimeType
+        + "(id:"
+        + format.id
+        + " hz:"
+        + format.sampleRate
+        + " ch:"
         + format.channelCount
-        + getDecoderCountersBufferCountString(player.getAudioDecoderCounters()) + ")";
+        + getDecoderCountersBufferCountString(decoderCounters)
+        + ")";
   }
 
   private static String getDecoderCountersBufferCountString(DecoderCounters counters) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index 75c4f71b64..328b5d6a49 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -25,8 +25,8 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
-import android.support.annotation.ColorInt;
-import android.support.annotation.Nullable;
+import androidx.annotation.ColorInt;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import android.util.DisplayMetrics;
 import android.view.KeyEvent;
@@ -205,6 +205,7 @@
   private final CopyOnWriteArraySet<OnScrubListener> listeners;
   private final int[] locationOnScreen;
   private final Point touchPosition;
+  private final float density;
 
   private int keyCountIncrement;
   private long keyTimeIncrement;
@@ -242,13 +243,14 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     // Calculate the dimensions and paints for drawn elements.
     Resources res = context.getResources();
     DisplayMetrics displayMetrics = res.getDisplayMetrics();
-    fineScrubYThreshold = dpToPx(displayMetrics, FINE_SCRUB_Y_THRESHOLD_DP);
-    int defaultBarHeight = dpToPx(displayMetrics, DEFAULT_BAR_HEIGHT_DP);
-    int defaultTouchTargetHeight = dpToPx(displayMetrics, DEFAULT_TOUCH_TARGET_HEIGHT_DP);
-    int defaultAdMarkerWidth = dpToPx(displayMetrics, DEFAULT_AD_MARKER_WIDTH_DP);
-    int defaultScrubberEnabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
-    int defaultScrubberDisabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
-    int defaultScrubberDraggedSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
+    density = displayMetrics.density;
+    fineScrubYThreshold = dpToPx(density, FINE_SCRUB_Y_THRESHOLD_DP);
+    int defaultBarHeight = dpToPx(density, DEFAULT_BAR_HEIGHT_DP);
+    int defaultTouchTargetHeight = dpToPx(density, DEFAULT_TOUCH_TARGET_HEIGHT_DP);
+    int defaultAdMarkerWidth = dpToPx(density, DEFAULT_AD_MARKER_WIDTH_DP);
+    int defaultScrubberEnabledSize = dpToPx(density, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
+    int defaultScrubberDisabledSize = dpToPx(density, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
+    int defaultScrubberDraggedSize = dpToPx(density, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
     if (attrs != null) {
       TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
           0);
@@ -319,8 +321,8 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     keyTimeIncrement = C.TIME_UNSET;
     keyCountIncrement = DEFAULT_INCREMENT_COUNT;
     setFocusable(true);
-    if (Util.SDK_INT >= 16) {
-      maybeSetImportantForAccessibilityV16();
+    if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+      setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
     }
   }
 
@@ -431,11 +433,19 @@ public void setBufferedPosition(long bufferedPosition) {
   public void setDuration(long duration) {
     this.duration = duration;
     if (scrubbing && duration == C.TIME_UNSET) {
-      stopScrubbing(true);
+      stopScrubbing(/* canceled= */ true);
     }
     update();
   }
 
+  @Override
+  public long getPreferredUpdateDelay() {
+    int timeBarWidthDp = pxToDp(density, progressBar.width());
+    return timeBarWidthDp == 0 || duration == 0 || duration == C.TIME_UNSET
+        ? Long.MAX_VALUE
+        : duration / timeBarWidthDp;
+  }
+
   @Override
   public void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] playedAdGroups,
       int adGroupCount) {
@@ -453,7 +463,7 @@ public void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean
   public void setEnabled(boolean enabled) {
     super.setEnabled(enabled);
     if (scrubbing && !enabled) {
-      stopScrubbing(true);
+      stopScrubbing(/* canceled= */ true);
     }
   }
 
@@ -477,8 +487,7 @@ public boolean onTouchEvent(MotionEvent event) {
       case MotionEvent.ACTION_DOWN:
         if (isInSeekBar(x, y)) {
           positionScrubber(x);
-          startScrubbing();
-          scrubPosition = getScrubberPosition();
+          startScrubbing(getScrubberPosition());
           update();
           invalidate();
           return true;
@@ -493,10 +502,7 @@ public boolean onTouchEvent(MotionEvent event) {
             lastCoarseScrubXPosition = x;
             positionScrubber(x);
           }
-          scrubPosition = getScrubberPosition();
-          for (OnScrubListener listener : listeners) {
-            listener.onScrubMove(this, scrubPosition);
-          }
+          updateScrubbing(getScrubberPosition());
           update();
           invalidate();
           return true;
@@ -505,7 +511,7 @@ public boolean onTouchEvent(MotionEvent event) {
       case MotionEvent.ACTION_UP:
       case MotionEvent.ACTION_CANCEL:
         if (scrubbing) {
-          stopScrubbing(event.getAction() == MotionEvent.ACTION_CANCEL);
+          stopScrubbing(/* canceled= */ event.getAction() == MotionEvent.ACTION_CANCEL);
           return true;
         }
         break;
@@ -533,8 +539,7 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
         case KeyEvent.KEYCODE_DPAD_CENTER:
         case KeyEvent.KEYCODE_ENTER:
           if (scrubbing) {
-            removeCallbacks(stopScrubbingRunnable);
-            stopScrubbingRunnable.run();
+            stopScrubbing(/* canceled= */ false);
             return true;
           }
           break;
@@ -545,6 +550,15 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
     return super.onKeyDown(keyCode, event);
   }
 
+  @Override
+  protected void onFocusChanged(
+      boolean gainFocus, int direction, @Nullable Rect previouslyFocusedRect) {
+    super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
+    if (scrubbing && !gainFocus) {
+      stopScrubbing(/* canceled= */ false);
+    }
+  }
+
   @Override
   protected void drawableStateChanged() {
     super.drawableStateChanged();
@@ -611,13 +625,12 @@ public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
     if (Util.SDK_INT >= 21) {
       info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);
       info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);
-    } else if (Util.SDK_INT >= 16) {
+    } else {
       info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
       info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
     }
   }
 
-  @TargetApi(16)
   @Override
   public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
     if (super.performAccessibilityAction(action, args)) {
@@ -628,11 +641,11 @@ public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
     }
     if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
       if (scrubIncrementally(-getPositionIncrement())) {
-        stopScrubbing(false);
+        stopScrubbing(/* canceled= */ false);
       }
     } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
       if (scrubIncrementally(getPositionIncrement())) {
-        stopScrubbing(false);
+        stopScrubbing(/* canceled= */ false);
       }
     } else {
       return false;
@@ -643,14 +656,8 @@ public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
 
   // Internal methods.
 
-  @TargetApi(16)
-  private void maybeSetImportantForAccessibilityV16() {
-    if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
-      setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
-    }
-  }
-
-  private void startScrubbing() {
+  private void startScrubbing(long scrubPosition) {
+    this.scrubPosition = scrubPosition;
     scrubbing = true;
     setPressed(true);
     ViewParent parent = getParent();
@@ -658,11 +665,22 @@ private void startScrubbing() {
       parent.requestDisallowInterceptTouchEvent(true);
     }
     for (OnScrubListener listener : listeners) {
-      listener.onScrubStart(this, getScrubberPosition());
+      listener.onScrubStart(this, scrubPosition);
+    }
+  }
+
+  private void updateScrubbing(long scrubPosition) {
+    if (this.scrubPosition == scrubPosition) {
+      return;
+    }
+    this.scrubPosition = scrubPosition;
+    for (OnScrubListener listener : listeners) {
+      listener.onScrubMove(this, scrubPosition);
     }
   }
 
   private void stopScrubbing(boolean canceled) {
+    removeCallbacks(stopScrubbingRunnable);
     scrubbing = false;
     setPressed(false);
     ViewParent parent = getParent();
@@ -671,8 +689,32 @@ private void stopScrubbing(boolean canceled) {
     }
     invalidate();
     for (OnScrubListener listener : listeners) {
-      listener.onScrubStop(this, getScrubberPosition(), canceled);
+      listener.onScrubStop(this, scrubPosition, canceled);
+    }
+  }
+
+  /**
+   * Incrementally scrubs the position by {@code positionChange}.
+   *
+   * @param positionChange The change in the scrubber position, in milliseconds. May be negative.
+   * @return Returns whether the scrubber position changed.
+   */
+  private boolean scrubIncrementally(long positionChange) {
+    if (duration <= 0) {
+      return false;
+    }
+    long previousPosition = scrubbing ? scrubPosition : position;
+    long scrubPosition = Util.constrainValue(previousPosition + positionChange, 0, duration);
+    if (scrubPosition == previousPosition) {
+      return false;
     }
+    if (!scrubbing) {
+      startScrubbing(scrubPosition);
+    } else {
+      updateScrubbing(scrubPosition);
+    }
+    update();
+    return true;
   }
 
   private void update() {
@@ -791,31 +833,6 @@ private long getPositionIncrement() {
         ? (duration == C.TIME_UNSET ? 0 : (duration / keyCountIncrement)) : keyTimeIncrement;
   }
 
-  /**
-   * Incrementally scrubs the position by {@code positionChange}.
-   *
-   * @param positionChange The change in the scrubber position, in milliseconds. May be negative.
-   * @return Returns whether the scrubber position changed.
-   */
-  private boolean scrubIncrementally(long positionChange) {
-    if (duration <= 0) {
-      return false;
-    }
-    long scrubberPosition = getScrubberPosition();
-    scrubPosition = Util.constrainValue(scrubberPosition + positionChange, 0, duration);
-    if (scrubPosition == scrubberPosition) {
-      return false;
-    }
-    if (!scrubbing) {
-      startScrubbing();
-    }
-    for (OnScrubListener listener : listeners) {
-      listener.onScrubMove(this, scrubPosition);
-    }
-    update();
-    return true;
-  }
-
   private boolean setDrawableLayoutDirection(Drawable drawable) {
     return Util.SDK_INT >= 23 && setDrawableLayoutDirection(drawable, getLayoutDirection());
   }
@@ -840,7 +857,11 @@ public static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
     return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
   }
 
-  private static int dpToPx(DisplayMetrics displayMetrics, int dps) {
-    return (int) (dps * displayMetrics.density + 0.5f);
+  private static int dpToPx(float density, int dps) {
+    return (int) (dps * density + 0.5f);
+  }
+
+  private static int pxToDp(float density, int px) {
+    return (int) (px / density);
   }
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java
index 5d68387869..a3d20eadb7 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTrackNameProvider.java
@@ -39,15 +39,17 @@ public String getTrackName(Format format) {
     String trackName;
     int trackType = inferPrimaryTrackType(format);
     if (trackType == C.TRACK_TYPE_VIDEO) {
-      trackName = joinWithSeparator(buildResolutionString(format), buildBitrateString(format));
+      trackName =
+          joinWithSeparator(
+              buildRoleString(format), buildResolutionString(format), buildBitrateString(format));
     } else if (trackType == C.TRACK_TYPE_AUDIO) {
       trackName =
           joinWithSeparator(
-              buildLabelString(format),
+              buildLanguageOrLabelString(format),
               buildAudioChannelString(format),
               buildBitrateString(format));
     } else {
-      trackName = buildLabelString(format);
+      trackName = buildLanguageOrLabelString(format);
     }
     return trackName.length() == 0 ? resources.getString(R.string.exo_track_unknown) : trackName;
   }
@@ -87,20 +89,41 @@ private String buildAudioChannelString(Format format) {
     }
   }
 
+  private String buildLanguageOrLabelString(Format format) {
+    String languageAndRole =
+        joinWithSeparator(buildLanguageString(format), buildRoleString(format));
+    return TextUtils.isEmpty(languageAndRole) ? buildLabelString(format) : languageAndRole;
+  }
+
   private String buildLabelString(Format format) {
-    if (!TextUtils.isEmpty(format.label)) {
-      return format.label;
-    }
-    // Fall back to using the language.
-    String language = format.language;
-    return TextUtils.isEmpty(language) || C.LANGUAGE_UNDETERMINED.equals(language)
-        ? ""
-        : buildLanguageString(language);
+    return TextUtils.isEmpty(format.label) ? "" : format.label;
   }
 
-  private String buildLanguageString(String language) {
+  private String buildLanguageString(Format format) {
+    String language = format.language;
+    if (TextUtils.isEmpty(language) || C.LANGUAGE_UNDETERMINED.equals(language)) {
+      return "";
+    }
     Locale locale = Util.SDK_INT >= 21 ? Locale.forLanguageTag(language) : new Locale(language);
-    return locale.getDisplayLanguage();
+    return locale.getDisplayName();
+  }
+
+  private String buildRoleString(Format format) {
+    String roles = "";
+    if ((format.roleFlags & C.ROLE_FLAG_ALTERNATE) != 0) {
+      roles = resources.getString(R.string.exo_track_role_alternate);
+    }
+    if ((format.roleFlags & C.ROLE_FLAG_SUPPLEMENTARY) != 0) {
+      roles = joinWithSeparator(roles, resources.getString(R.string.exo_track_role_supplementary));
+    }
+    if ((format.roleFlags & C.ROLE_FLAG_COMMENTARY) != 0) {
+      roles = joinWithSeparator(roles, resources.getString(R.string.exo_track_role_commentary));
+    }
+    if ((format.roleFlags & (C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND)) != 0) {
+      roles =
+          joinWithSeparator(roles, resources.getString(R.string.exo_track_role_closed_captions));
+    }
+    return roles;
   }
 
   private String joinWithSeparator(String... items) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationHelper.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationHelper.java
new file mode 100644
index 0000000000..178cd44dd3
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationHelper.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui;
+
+import android.app.Notification;
+import android.app.PendingIntent;
+import android.content.Context;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringRes;
+import androidx.core.app.NotificationCompat;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.Download;
+import java.util.List;
+
+/** Helper for creating download notifications. */
+public final class DownloadNotificationHelper {
+
+  private static final @StringRes int NULL_STRING_ID = 0;
+
+  private final Context context;
+  private final NotificationCompat.Builder notificationBuilder;
+
+  /**
+   * @param context A context.
+   * @param channelId The id of the notification channel to use.
+   */
+  public DownloadNotificationHelper(Context context, String channelId) {
+    context = context.getApplicationContext();
+    this.context = context;
+    this.notificationBuilder = new NotificationCompat.Builder(context, channelId);
+  }
+
+  /**
+   * Returns a progress notification for the given downloads.
+   *
+   * @param smallIcon A small icon for the notification.
+   * @param contentIntent An optional content intent to send when the notification is clicked.
+   * @param message An optional message to display on the notification.
+   * @param downloads The downloads.
+   * @return The notification.
+   */
+  public Notification buildProgressNotification(
+      @DrawableRes int smallIcon,
+      @Nullable PendingIntent contentIntent,
+      @Nullable String message,
+      List<Download> downloads) {
+    float totalPercentage = 0;
+    int downloadTaskCount = 0;
+    boolean allDownloadPercentagesUnknown = true;
+    boolean haveDownloadedBytes = false;
+    boolean haveDownloadTasks = false;
+    boolean haveRemoveTasks = false;
+    for (int i = 0; i < downloads.size(); i++) {
+      Download download = downloads.get(i);
+      if (download.state == Download.STATE_REMOVING) {
+        haveRemoveTasks = true;
+        continue;
+      }
+      if (download.state != Download.STATE_RESTARTING
+          && download.state != Download.STATE_DOWNLOADING) {
+        continue;
+      }
+      haveDownloadTasks = true;
+      float downloadPercentage = download.getPercentDownloaded();
+      if (downloadPercentage != C.PERCENTAGE_UNSET) {
+        allDownloadPercentagesUnknown = false;
+        totalPercentage += downloadPercentage;
+      }
+      haveDownloadedBytes |= download.getBytesDownloaded() > 0;
+      downloadTaskCount++;
+    }
+
+    int titleStringId =
+        haveDownloadTasks
+            ? R.string.exo_download_downloading
+            : (haveRemoveTasks ? R.string.exo_download_removing : NULL_STRING_ID);
+    int progress = 0;
+    boolean indeterminate = true;
+    if (haveDownloadTasks) {
+      progress = (int) (totalPercentage / downloadTaskCount);
+      indeterminate = allDownloadPercentagesUnknown && haveDownloadedBytes;
+    }
+    return buildNotification(
+        smallIcon,
+        contentIntent,
+        message,
+        titleStringId,
+        /* maxProgress= */ 100,
+        progress,
+        indeterminate,
+        /* ongoing= */ true,
+        /* showWhen= */ false);
+  }
+
+  /**
+   * Returns a notification for a completed download.
+   *
+   * @param smallIcon A small icon for the notifications.
+   * @param contentIntent An optional content intent to send when the notification is clicked.
+   * @param message An optional message to display on the notification.
+   * @return The notification.
+   */
+  public Notification buildDownloadCompletedNotification(
+      @DrawableRes int smallIcon, @Nullable PendingIntent contentIntent, @Nullable String message) {
+    int titleStringId = R.string.exo_download_completed;
+    return buildEndStateNotification(smallIcon, contentIntent, message, titleStringId);
+  }
+
+  /**
+   * Returns a notification for a failed download.
+   *
+   * @param smallIcon A small icon for the notifications.
+   * @param contentIntent An optional content intent to send when the notification is clicked.
+   * @param message An optional message to display on the notification.
+   * @return The notification.
+   */
+  public Notification buildDownloadFailedNotification(
+      @DrawableRes int smallIcon, @Nullable PendingIntent contentIntent, @Nullable String message) {
+    @StringRes int titleStringId = R.string.exo_download_failed;
+    return buildEndStateNotification(smallIcon, contentIntent, message, titleStringId);
+  }
+
+  private Notification buildEndStateNotification(
+      @DrawableRes int smallIcon,
+      @Nullable PendingIntent contentIntent,
+      @Nullable String message,
+      @StringRes int titleStringId) {
+    return buildNotification(
+        smallIcon,
+        contentIntent,
+        message,
+        titleStringId,
+        /* maxProgress= */ 0,
+        /* currentProgress= */ 0,
+        /* indeterminateProgress= */ false,
+        /* ongoing= */ false,
+        /* showWhen= */ true);
+  }
+
+  private Notification buildNotification(
+      @DrawableRes int smallIcon,
+      @Nullable PendingIntent contentIntent,
+      @Nullable String message,
+      @StringRes int titleStringId,
+      int maxProgress,
+      int currentProgress,
+      boolean indeterminateProgress,
+      boolean ongoing,
+      boolean showWhen) {
+    notificationBuilder.setSmallIcon(smallIcon);
+    notificationBuilder.setContentTitle(
+        titleStringId == NULL_STRING_ID ? null : context.getResources().getString(titleStringId));
+    notificationBuilder.setContentIntent(contentIntent);
+    notificationBuilder.setStyle(
+        message == null ? null : new NotificationCompat.BigTextStyle().bigText(message));
+    notificationBuilder.setProgress(maxProgress, currentProgress, indeterminateProgress);
+    notificationBuilder.setOngoing(ongoing);
+    notificationBuilder.setShowWhen(showWhen);
+    return notificationBuilder.build();
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java
index 97832abfc7..223a97f69c 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DownloadNotificationUtil.java
@@ -18,30 +18,30 @@
 import android.app.Notification;
 import android.app.PendingIntent;
 import android.content.Context;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.Nullable;
-import android.support.annotation.StringRes;
-import android.support.v4.app.NotificationCompat;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.offline.Download;
+import com.google.android.exoplayer2.util.Util;
+import java.util.List;
 
-/** Helper for creating download notifications. */
+/**
+ * @deprecated Using this class can cause notifications to flicker on devices with {@link
+ *     Util#SDK_INT} &lt; 21. Use {@link DownloadNotificationHelper} instead.
+ */
+@Deprecated
 public final class DownloadNotificationUtil {
 
-  private static final @StringRes int NULL_STRING_ID = 0;
-
   private DownloadNotificationUtil() {}
 
   /**
-   * Returns a progress notification for the given task states.
+   * Returns a progress notification for the given downloads.
    *
    * @param context A context for accessing resources.
    * @param smallIcon A small icon for the notification.
-   * @param channelId The id of the notification channel to use. Only required for API level 26 and
-   *     above.
+   * @param channelId The id of the notification channel to use.
    * @param contentIntent An optional content intent to send when the notification is clicked.
    * @param message An optional message to display on the notification.
-   * @param taskStates The task states.
+   * @param downloads The downloads.
    * @return The notification.
    */
   public static Notification buildProgressNotification(
@@ -50,49 +50,9 @@ public static Notification buildProgressNotification(
       String channelId,
       @Nullable PendingIntent contentIntent,
       @Nullable String message,
-      TaskState[] taskStates) {
-    float totalPercentage = 0;
-    int downloadTaskCount = 0;
-    boolean allDownloadPercentagesUnknown = true;
-    boolean haveDownloadedBytes = false;
-    boolean haveDownloadTasks = false;
-    boolean haveRemoveTasks = false;
-    for (TaskState taskState : taskStates) {
-      if (taskState.state != TaskState.STATE_STARTED
-          && taskState.state != TaskState.STATE_COMPLETED) {
-        continue;
-      }
-      if (taskState.action.isRemoveAction) {
-        haveRemoveTasks = true;
-        continue;
-      }
-      haveDownloadTasks = true;
-      if (taskState.downloadPercentage != C.PERCENTAGE_UNSET) {
-        allDownloadPercentagesUnknown = false;
-        totalPercentage += taskState.downloadPercentage;
-      }
-      haveDownloadedBytes |= taskState.downloadedBytes > 0;
-      downloadTaskCount++;
-    }
-
-    int titleStringId =
-        haveDownloadTasks
-            ? R.string.exo_download_downloading
-            : (haveRemoveTasks ? R.string.exo_download_removing : NULL_STRING_ID);
-    NotificationCompat.Builder notificationBuilder =
-        newNotificationBuilder(
-            context, smallIcon, channelId, contentIntent, message, titleStringId);
-
-    int progress = 0;
-    boolean indeterminate = true;
-    if (haveDownloadTasks) {
-      progress = (int) (totalPercentage / downloadTaskCount);
-      indeterminate = allDownloadPercentagesUnknown && haveDownloadedBytes;
-    }
-    notificationBuilder.setProgress(/* max= */ 100, progress, indeterminate);
-    notificationBuilder.setOngoing(true);
-    notificationBuilder.setShowWhen(false);
-    return notificationBuilder.build();
+      List<Download> downloads) {
+    return new DownloadNotificationHelper(context, channelId)
+        .buildProgressNotification(smallIcon, contentIntent, message, downloads);
   }
 
   /**
@@ -100,8 +60,7 @@ public static Notification buildProgressNotification(
    *
    * @param context A context for accessing resources.
    * @param smallIcon A small icon for the notifications.
-   * @param channelId The id of the notification channel to use. Only required for API level 26 and
-   *     above.
+   * @param channelId The id of the notification channel to use.
    * @param contentIntent An optional content intent to send when the notification is clicked.
    * @param message An optional message to display on the notification.
    * @return The notification.
@@ -112,10 +71,8 @@ public static Notification buildDownloadCompletedNotification(
       String channelId,
       @Nullable PendingIntent contentIntent,
       @Nullable String message) {
-    int titleStringId = R.string.exo_download_completed;
-    return newNotificationBuilder(
-            context, smallIcon, channelId, contentIntent, message, titleStringId)
-        .build();
+    return new DownloadNotificationHelper(context, channelId)
+        .buildDownloadCompletedNotification(smallIcon, contentIntent, message);
   }
 
   /**
@@ -123,8 +80,7 @@ public static Notification buildDownloadCompletedNotification(
    *
    * @param context A context for accessing resources.
    * @param smallIcon A small icon for the notifications.
-   * @param channelId The id of the notification channel to use. Only required for API level 26 and
-   *     above.
+   * @param channelId The id of the notification channel to use.
    * @param contentIntent An optional content intent to send when the notification is clicked.
    * @param message An optional message to display on the notification.
    * @return The notification.
@@ -135,30 +91,7 @@ public static Notification buildDownloadFailedNotification(
       String channelId,
       @Nullable PendingIntent contentIntent,
       @Nullable String message) {
-    @StringRes int titleStringId = R.string.exo_download_failed;
-    return newNotificationBuilder(
-            context, smallIcon, channelId, contentIntent, message, titleStringId)
-        .build();
-  }
-
-  private static NotificationCompat.Builder newNotificationBuilder(
-      Context context,
-      @DrawableRes int smallIcon,
-      String channelId,
-      @Nullable PendingIntent contentIntent,
-      @Nullable String message,
-      @StringRes int titleStringId) {
-    NotificationCompat.Builder notificationBuilder =
-        new NotificationCompat.Builder(context, channelId).setSmallIcon(smallIcon);
-    if (titleStringId != NULL_STRING_ID) {
-      notificationBuilder.setContentTitle(context.getResources().getString(titleStringId));
-    }
-    if (contentIntent != null) {
-      notificationBuilder.setContentIntent(contentIntent);
-    }
-    if (message != null) {
-      notificationBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(message));
-    }
-    return notificationBuilder;
+    return new DownloadNotificationHelper(context, channelId)
+        .buildDownloadFailedNotification(smallIcon, contentIntent, message);
   }
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 5467538c0f..47d60e0233 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -17,7 +17,6 @@
 
 import android.content.Context;
 import android.util.AttributeSet;
-import com.google.android.exoplayer2.util.RepeatModeUtil;
 
 /** @deprecated Use {@link PlayerControlView}. */
 @Deprecated
@@ -27,13 +26,6 @@
   @Deprecated
   public interface ControlDispatcher extends com.google.android.exoplayer2.ControlDispatcher {}
 
-  /**
-   * @deprecated Use {@link com.google.android.exoplayer2.ui.PlayerControlView.VisibilityListener}.
-   */
-  @Deprecated
-  public interface VisibilityListener
-      extends com.google.android.exoplayer2.ui.PlayerControlView.VisibilityListener {}
-
   @Deprecated
   @SuppressWarnings("deprecation")
   private static final class DefaultControlDispatcher
@@ -43,20 +35,6 @@
   @SuppressWarnings("deprecation")
   public static final ControlDispatcher DEFAULT_CONTROL_DISPATCHER = new DefaultControlDispatcher();
 
-  /** The default fast forward increment, in milliseconds. */
-  public static final int DEFAULT_FAST_FORWARD_MS = PlayerControlView.DEFAULT_FAST_FORWARD_MS;
-  /** The default rewind increment, in milliseconds. */
-  public static final int DEFAULT_REWIND_MS = PlayerControlView.DEFAULT_REWIND_MS;
-  /** The default show timeout, in milliseconds. */
-  public static final int DEFAULT_SHOW_TIMEOUT_MS = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
-  /** The default repeat toggle modes. */
-  public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
-      PlayerControlView.DEFAULT_REPEAT_TOGGLE_MODES;
-
-  /** The maximum number of windows that can be shown in a multi-window time bar. */
-  public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR =
-      PlayerControlView.MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR;
-
   public PlaybackControlView(Context context) {
     super(context);
   }
@@ -73,5 +51,4 @@ public PlaybackControlView(
       Context context, AttributeSet attrs, int defStyleAttr, AttributeSet playbackAttrs) {
     super(context, attrs, defStyleAttr, playbackAttrs);
   }
-
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index 8ab4210465..a5deb808c1 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -22,7 +22,7 @@
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -85,6 +85,12 @@
  *         <li>Corresponding method: {@link #setShowShuffleButton(boolean)}
  *         <li>Default: false
  *       </ul>
+ *   <li><b>{@code time_bar_min_update_interval}</b> - Specifies the minimum interval between time
+ *       bar position updates.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setTimeBarMinUpdateInterval(int)}
+ *         <li>Default: {@link #DEFAULT_TIME_BAR_MIN_UPDATE_INTERVAL_MS}
+ *       </ul>
  *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout to be inflated. See
  *       below for more details.
  *       <ul>
@@ -136,6 +142,10 @@
  *       <ul>
  *         <li>Type: {@link View}
  *       </ul>
+ *   <li><b>{@code exo_vr}</b> - The VR mode button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
  *   <li><b>{@code exo_position}</b> - Text view displaying the current playback position.
  *       <ul>
  *         <li>Type: {@link TextView}
@@ -187,11 +197,14 @@
   /** The default repeat toggle modes. */
   public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
       RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE;
-
+  /** The default minimum interval between time bar position updates. */
+  public static final int DEFAULT_TIME_BAR_MIN_UPDATE_INTERVAL_MS = 200;
   /** The maximum number of windows that can be shown in a multi-window time bar. */
   public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR = 100;
 
   private static final long MAX_POSITION_FOR_SEEK_TO_PREVIOUS = 3000;
+  /** The maximum interval between time bar position updates. */
+  private static final int MAX_UPDATE_INTERVAL_MS = 1000;
 
   private final ComponentListener componentListener;
   private final View previousButton;
@@ -202,6 +215,7 @@
   private final View rewindButton;
   private final ImageView repeatToggleButton;
   private final View shuffleButton;
+  private final View vrButton;
   private final TextView durationView;
   private final TextView positionView;
   private final TimeBar timeBar;
@@ -219,10 +233,10 @@
   private final String repeatOneButtonContentDescription;
   private final String repeatAllButtonContentDescription;
 
-  private Player player;
+  @Nullable private Player player;
   private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
   private VisibilityListener visibilityListener;
-  private @Nullable PlaybackPreparer playbackPreparer;
+  @Nullable private PlaybackPreparer playbackPreparer;
 
   private boolean isAttachedToWindow;
   private boolean showMultiWindowTimeBar;
@@ -231,6 +245,7 @@
   private int rewindMs;
   private int fastForwardMs;
   private int showTimeoutMs;
+  private int timeBarMinUpdateIntervalMs;
   private @RepeatModeUtil.RepeatToggleModes int repeatToggleModes;
   private boolean showShuffleButton;
   private long hideAtMs;
@@ -238,6 +253,7 @@
   private boolean[] playedAdGroups;
   private long[] extraAdGroupTimesMs;
   private boolean[] extraPlayedAdGroups;
+  private long currentWindowOffset;
 
   public PlayerControlView(Context context) {
     this(context, null);
@@ -259,6 +275,7 @@ public PlayerControlView(
     fastForwardMs = DEFAULT_FAST_FORWARD_MS;
     showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
     repeatToggleModes = DEFAULT_REPEAT_TOGGLE_MODES;
+    timeBarMinUpdateIntervalMs = DEFAULT_TIME_BAR_MIN_UPDATE_INTERVAL_MS;
     hideAtMs = C.TIME_UNSET;
     showShuffleButton = false;
     if (playbackAttrs != null) {
@@ -276,6 +293,10 @@ public PlayerControlView(
         repeatToggleModes = getRepeatToggleModes(a, repeatToggleModes);
         showShuffleButton =
             a.getBoolean(R.styleable.PlayerControlView_show_shuffle_button, showShuffleButton);
+        setTimeBarMinUpdateInterval(
+            a.getInt(
+                R.styleable.PlayerControlView_time_bar_min_update_interval,
+                timeBarMinUpdateIntervalMs));
       } finally {
         a.recycle();
       }
@@ -334,6 +355,8 @@ public PlayerControlView(
     if (shuffleButton != null) {
       shuffleButton.setOnClickListener(componentListener);
     }
+    vrButton = findViewById(R.id.exo_vr);
+    setShowVrButton(false);
     Resources resources = context.getResources();
     repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off);
     repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one);
@@ -356,6 +379,7 @@ public PlayerControlView(
    * Returns the {@link Player} currently being controlled by this view, or null if no player is
    * set.
    */
+  @Nullable
   public Player getPlayer() {
     return player;
   }
@@ -394,7 +418,7 @@ public void setPlayer(@Nullable Player player) {
    */
   public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
     this.showMultiWindowTimeBar = showMultiWindowTimeBar;
-    updateTimeBarMode();
+    updateTimeline();
   }
 
   /**
@@ -404,8 +428,8 @@ public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
    *
    * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
    *     {@code null} to show no extra ad markers.
-   * @param extraPlayedAdGroups Whether each ad has been played, or {@code null} to show no extra ad
-   *     markers.
+   * @param extraPlayedAdGroups Whether each ad has been played. Must be the same length as {@code
+   *     extraAdGroupTimesMs}, or {@code null} if {@code extraAdGroupTimesMs} is {@code null}.
    */
   public void setExtraAdGroupMarkers(
       @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {
@@ -413,11 +437,12 @@ public void setExtraAdGroupMarkers(
       this.extraAdGroupTimesMs = new long[0];
       this.extraPlayedAdGroups = new boolean[0];
     } else {
+      extraPlayedAdGroups = Assertions.checkNotNull(extraPlayedAdGroups);
       Assertions.checkArgument(extraAdGroupTimesMs.length == extraPlayedAdGroups.length);
       this.extraAdGroupTimesMs = extraAdGroupTimesMs;
       this.extraPlayedAdGroups = extraPlayedAdGroups;
     }
-    updateProgress();
+    updateTimeline();
   }
 
   /**
@@ -547,6 +572,49 @@ public void setShowShuffleButton(boolean showShuffleButton) {
     updateShuffleButton();
   }
 
+  /** Returns whether the VR button is shown. */
+  public boolean getShowVrButton() {
+    return vrButton != null && vrButton.getVisibility() == VISIBLE;
+  }
+
+  /**
+   * Sets whether the VR button is shown.
+   *
+   * @param showVrButton Whether the VR button is shown.
+   */
+  public void setShowVrButton(boolean showVrButton) {
+    if (vrButton != null) {
+      vrButton.setVisibility(showVrButton ? VISIBLE : GONE);
+    }
+  }
+
+  /**
+   * Sets listener for the VR button.
+   *
+   * @param onClickListener Listener for the VR button, or null to clear the listener.
+   */
+  public void setVrButtonListener(@Nullable OnClickListener onClickListener) {
+    if (vrButton != null) {
+      vrButton.setOnClickListener(onClickListener);
+    }
+  }
+
+  /**
+   * Sets the minimum interval between time bar position updates.
+   *
+   * <p>Note that smaller intervals, e.g. 33ms, will result in a smooth movement but will use more
+   * CPU resources while the time bar is visible, whereas larger intervals, e.g. 200ms, will result
+   * in a step-wise update with less CPU usage.
+   *
+   * @param minUpdateIntervalMs The minimum interval between time bar position updates, in
+   *     milliseconds.
+   */
+  public void setTimeBarMinUpdateInterval(int minUpdateIntervalMs) {
+    // Do not accept values below 16ms (60fps) and larger than the maximum update interval.
+    timeBarMinUpdateIntervalMs =
+        Util.constrainValue(minUpdateIntervalMs, 16, MAX_UPDATE_INTERVAL_MS);
+  }
+
   /**
    * Shows the playback controls. If {@link #getShowTimeoutMs()} is positive then the controls will
    * be automatically hidden after this duration of time has elapsed without user input.
@@ -599,7 +667,7 @@ private void updateAll() {
     updateNavigation();
     updateRepeatModeButton();
     updateShuffleButton();
-    updateProgress();
+    updateTimeline();
   }
 
   private void updatePlayPauseButton() {
@@ -610,11 +678,11 @@ private void updatePlayPauseButton() {
     boolean playing = isPlaying();
     if (playButton != null) {
       requestPlayPauseFocus |= playing && playButton.isFocused();
-      playButton.setVisibility(playing ? View.GONE : View.VISIBLE);
+      playButton.setVisibility(playing ? GONE : VISIBLE);
     }
     if (pauseButton != null) {
       requestPlayPauseFocus |= !playing && pauseButton.isFocused();
-      pauseButton.setVisibility(!playing ? View.GONE : View.VISIBLE);
+      pauseButton.setVisibility(!playing ? GONE : VISIBLE);
     }
     if (requestPlayPauseFocus) {
       requestPlayPauseFocus();
@@ -625,24 +693,30 @@ private void updateNavigation() {
     if (!isVisible() || !isAttachedToWindow) {
       return;
     }
-    Timeline timeline = player != null ? player.getCurrentTimeline() : null;
-    boolean haveNonEmptyTimeline = timeline != null && !timeline.isEmpty();
-    boolean isSeekable = false;
+    boolean enableSeeking = false;
     boolean enablePrevious = false;
+    boolean enableRewind = false;
+    boolean enableFastForward = false;
     boolean enableNext = false;
-    if (haveNonEmptyTimeline && !player.isPlayingAd()) {
-      int windowIndex = player.getCurrentWindowIndex();
-      timeline.getWindow(windowIndex, window);
-      isSeekable = window.isSeekable;
-      enablePrevious = isSeekable || !window.isDynamic || player.hasPrevious();
-      enableNext = window.isDynamic || player.hasNext();
+    if (player != null) {
+      Timeline timeline = player.getCurrentTimeline();
+      if (!timeline.isEmpty() && !player.isPlayingAd()) {
+        timeline.getWindow(player.getCurrentWindowIndex(), window);
+        boolean isSeekable = window.isSeekable;
+        enableSeeking = isSeekable;
+        enablePrevious = isSeekable || !window.isDynamic || player.hasPrevious();
+        enableRewind = isSeekable && rewindMs > 0;
+        enableFastForward = isSeekable && fastForwardMs > 0;
+        enableNext = window.isDynamic || player.hasNext();
+      }
     }
+
     setButtonEnabled(enablePrevious, previousButton);
+    setButtonEnabled(enableRewind, rewindButton);
+    setButtonEnabled(enableFastForward, fastForwardButton);
     setButtonEnabled(enableNext, nextButton);
-    setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton);
-    setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton);
     if (timeBar != null) {
-      timeBar.setEnabled(isSeekable);
+      timeBar.setEnabled(enableSeeking);
     }
   }
 
@@ -651,7 +725,7 @@ private void updateRepeatModeButton() {
       return;
     }
     if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE) {
-      repeatToggleButton.setVisibility(View.GONE);
+      repeatToggleButton.setVisibility(GONE);
       return;
     }
     if (player == null) {
@@ -675,7 +749,7 @@ private void updateRepeatModeButton() {
       default:
         // Never happens.
     }
-    repeatToggleButton.setVisibility(View.VISIBLE);
+    repeatToggleButton.setVisibility(VISIBLE);
   }
 
   private void updateShuffleButton() {
@@ -683,22 +757,84 @@ private void updateShuffleButton() {
       return;
     }
     if (!showShuffleButton) {
-      shuffleButton.setVisibility(View.GONE);
+      shuffleButton.setVisibility(GONE);
     } else if (player == null) {
       setButtonEnabled(false, shuffleButton);
     } else {
       shuffleButton.setAlpha(player.getShuffleModeEnabled() ? 1f : 0.3f);
       shuffleButton.setEnabled(true);
-      shuffleButton.setVisibility(View.VISIBLE);
+      shuffleButton.setVisibility(VISIBLE);
     }
   }
 
-  private void updateTimeBarMode() {
+  private void updateTimeline() {
     if (player == null) {
       return;
     }
     multiWindowTimeBar =
         showMultiWindowTimeBar && canShowMultiWindowTimeBar(player.getCurrentTimeline(), window);
+    currentWindowOffset = 0;
+    long durationUs = 0;
+    int adGroupCount = 0;
+    Timeline timeline = player.getCurrentTimeline();
+    if (!timeline.isEmpty()) {
+      int currentWindowIndex = player.getCurrentWindowIndex();
+      int firstWindowIndex = multiWindowTimeBar ? 0 : currentWindowIndex;
+      int lastWindowIndex = multiWindowTimeBar ? timeline.getWindowCount() - 1 : currentWindowIndex;
+      for (int i = firstWindowIndex; i <= lastWindowIndex; i++) {
+        if (i == currentWindowIndex) {
+          currentWindowOffset = C.usToMs(durationUs);
+        }
+        timeline.getWindow(i, window);
+        if (window.durationUs == C.TIME_UNSET) {
+          Assertions.checkState(!multiWindowTimeBar);
+          break;
+        }
+        for (int j = window.firstPeriodIndex; j <= window.lastPeriodIndex; j++) {
+          timeline.getPeriod(j, period);
+          int periodAdGroupCount = period.getAdGroupCount();
+          for (int adGroupIndex = 0; adGroupIndex < periodAdGroupCount; adGroupIndex++) {
+            long adGroupTimeInPeriodUs = period.getAdGroupTimeUs(adGroupIndex);
+            if (adGroupTimeInPeriodUs == C.TIME_END_OF_SOURCE) {
+              if (period.durationUs == C.TIME_UNSET) {
+                // Don't show ad markers for postrolls in periods with unknown duration.
+                continue;
+              }
+              adGroupTimeInPeriodUs = period.durationUs;
+            }
+            long adGroupTimeInWindowUs = adGroupTimeInPeriodUs + period.getPositionInWindowUs();
+            if (adGroupTimeInWindowUs >= 0 && adGroupTimeInWindowUs <= window.durationUs) {
+              if (adGroupCount == adGroupTimesMs.length) {
+                int newLength = adGroupTimesMs.length == 0 ? 1 : adGroupTimesMs.length * 2;
+                adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, newLength);
+                playedAdGroups = Arrays.copyOf(playedAdGroups, newLength);
+              }
+              adGroupTimesMs[adGroupCount] = C.usToMs(durationUs + adGroupTimeInWindowUs);
+              playedAdGroups[adGroupCount] = period.hasPlayedAdGroup(adGroupIndex);
+              adGroupCount++;
+            }
+          }
+        }
+        durationUs += window.durationUs;
+      }
+    }
+    long durationMs = C.usToMs(durationUs);
+    if (durationView != null) {
+      durationView.setText(Util.getStringForTime(formatBuilder, formatter, durationMs));
+    }
+    if (timeBar != null) {
+      timeBar.setDuration(durationMs);
+      int extraAdGroupCount = extraAdGroupTimesMs.length;
+      int totalAdGroupCount = adGroupCount + extraAdGroupCount;
+      if (totalAdGroupCount > adGroupTimesMs.length) {
+        adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, totalAdGroupCount);
+        playedAdGroups = Arrays.copyOf(playedAdGroups, totalAdGroupCount);
+      }
+      System.arraycopy(extraAdGroupTimesMs, 0, adGroupTimesMs, adGroupCount, extraAdGroupCount);
+      System.arraycopy(extraPlayedAdGroups, 0, playedAdGroups, adGroupCount, extraAdGroupCount);
+      timeBar.setAdGroupTimesMs(adGroupTimesMs, playedAdGroups, totalAdGroupCount);
+    }
+    updateProgress();
   }
 
   private void updateProgress() {
@@ -708,71 +844,9 @@ private void updateProgress() {
 
     long position = 0;
     long bufferedPosition = 0;
-    long duration = 0;
     if (player != null) {
-      long currentWindowTimeBarOffsetMs = 0;
-      long durationUs = 0;
-      int adGroupCount = 0;
-      Timeline timeline = player.getCurrentTimeline();
-      if (!timeline.isEmpty()) {
-        int currentWindowIndex = player.getCurrentWindowIndex();
-        int firstWindowIndex = multiWindowTimeBar ? 0 : currentWindowIndex;
-        int lastWindowIndex =
-            multiWindowTimeBar ? timeline.getWindowCount() - 1 : currentWindowIndex;
-        for (int i = firstWindowIndex; i <= lastWindowIndex; i++) {
-          if (i == currentWindowIndex) {
-            currentWindowTimeBarOffsetMs = C.usToMs(durationUs);
-          }
-          timeline.getWindow(i, window);
-          if (window.durationUs == C.TIME_UNSET) {
-            Assertions.checkState(!multiWindowTimeBar);
-            break;
-          }
-          for (int j = window.firstPeriodIndex; j <= window.lastPeriodIndex; j++) {
-            timeline.getPeriod(j, period);
-            int periodAdGroupCount = period.getAdGroupCount();
-            for (int adGroupIndex = 0; adGroupIndex < periodAdGroupCount; adGroupIndex++) {
-              long adGroupTimeInPeriodUs = period.getAdGroupTimeUs(adGroupIndex);
-              if (adGroupTimeInPeriodUs == C.TIME_END_OF_SOURCE) {
-                if (period.durationUs == C.TIME_UNSET) {
-                  // Don't show ad markers for postrolls in periods with unknown duration.
-                  continue;
-                }
-                adGroupTimeInPeriodUs = period.durationUs;
-              }
-              long adGroupTimeInWindowUs = adGroupTimeInPeriodUs + period.getPositionInWindowUs();
-              if (adGroupTimeInWindowUs >= 0 && adGroupTimeInWindowUs <= window.durationUs) {
-                if (adGroupCount == adGroupTimesMs.length) {
-                  int newLength = adGroupTimesMs.length == 0 ? 1 : adGroupTimesMs.length * 2;
-                  adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, newLength);
-                  playedAdGroups = Arrays.copyOf(playedAdGroups, newLength);
-                }
-                adGroupTimesMs[adGroupCount] = C.usToMs(durationUs + adGroupTimeInWindowUs);
-                playedAdGroups[adGroupCount] = period.hasPlayedAdGroup(adGroupIndex);
-                adGroupCount++;
-              }
-            }
-          }
-          durationUs += window.durationUs;
-        }
-      }
-      duration = C.usToMs(durationUs);
-      position = currentWindowTimeBarOffsetMs + player.getContentPosition();
-      bufferedPosition = currentWindowTimeBarOffsetMs + player.getContentBufferedPosition();
-      if (timeBar != null) {
-        int extraAdGroupCount = extraAdGroupTimesMs.length;
-        int totalAdGroupCount = adGroupCount + extraAdGroupCount;
-        if (totalAdGroupCount > adGroupTimesMs.length) {
-          adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, totalAdGroupCount);
-          playedAdGroups = Arrays.copyOf(playedAdGroups, totalAdGroupCount);
-        }
-        System.arraycopy(extraAdGroupTimesMs, 0, adGroupTimesMs, adGroupCount, extraAdGroupCount);
-        System.arraycopy(extraPlayedAdGroups, 0, playedAdGroups, adGroupCount, extraAdGroupCount);
-        timeBar.setAdGroupTimesMs(adGroupTimesMs, playedAdGroups, totalAdGroupCount);
-      }
-    }
-    if (durationView != null) {
-      durationView.setText(Util.getStringForTime(formatBuilder, formatter, duration));
+      position = currentWindowOffset + player.getContentPosition();
+      bufferedPosition = currentWindowOffset + player.getContentBufferedPosition();
     }
     if (positionView != null && !scrubbing) {
       positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
@@ -780,33 +854,29 @@ private void updateProgress() {
     if (timeBar != null) {
       timeBar.setPosition(position);
       timeBar.setBufferedPosition(bufferedPosition);
-      timeBar.setDuration(duration);
     }
 
     // Cancel any pending updates and schedule a new one if necessary.
     removeCallbacks(updateProgressAction);
     int playbackState = player == null ? Player.STATE_IDLE : player.getPlaybackState();
-    if (playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED) {
-      long delayMs;
-      if (player.getPlayWhenReady() && playbackState == Player.STATE_READY) {
-        float playbackSpeed = player.getPlaybackParameters().speed;
-        if (playbackSpeed <= 0.1f) {
-          delayMs = 1000;
-        } else if (playbackSpeed <= 5f) {
-          long mediaTimeUpdatePeriodMs = 1000 / Math.max(1, Math.round(1 / playbackSpeed));
-          long mediaTimeDelayMs = mediaTimeUpdatePeriodMs - (position % mediaTimeUpdatePeriodMs);
-          if (mediaTimeDelayMs < (mediaTimeUpdatePeriodMs / 5)) {
-            mediaTimeDelayMs += mediaTimeUpdatePeriodMs;
-          }
-          delayMs =
-              playbackSpeed == 1 ? mediaTimeDelayMs : (long) (mediaTimeDelayMs / playbackSpeed);
-        } else {
-          delayMs = 200;
-        }
-      } else {
-        delayMs = 1000;
-      }
+    if (playbackState == Player.STATE_READY && player.getPlayWhenReady()) {
+      long mediaTimeDelayMs =
+          timeBar != null ? timeBar.getPreferredUpdateDelay() : MAX_UPDATE_INTERVAL_MS;
+
+      // Limit delay to the start of the next full second to ensure position display is smooth.
+      long mediaTimeUntilNextFullSecondMs = 1000 - position % 1000;
+      mediaTimeDelayMs = Math.min(mediaTimeDelayMs, mediaTimeUntilNextFullSecondMs);
+
+      // Calculate the delay until the next update in real time, taking playbackSpeed into account.
+      float playbackSpeed = player.getPlaybackParameters().speed;
+      long delayMs =
+          playbackSpeed > 0 ? (long) (mediaTimeDelayMs / playbackSpeed) : MAX_UPDATE_INTERVAL_MS;
+
+      // Constrain the delay to avoid too frequent / infrequent updates.
+      delayMs = Util.constrainValue(delayMs, timeBarMinUpdateIntervalMs, MAX_UPDATE_INTERVAL_MS);
       postDelayed(updateProgressAction, delayMs);
+    } else if (playbackState != Player.STATE_ENDED && playbackState != Player.STATE_IDLE) {
+      postDelayed(updateProgressAction, MAX_UPDATE_INTERVAL_MS);
     }
   }
 
@@ -828,7 +898,7 @@ private void setButtonEnabled(boolean enabled, View view) {
     view.setVisibility(VISIBLE);
   }
 
-  private void previous() {
+  private void previous(Player player) {
     Timeline timeline = player.getCurrentTimeline();
     if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
@@ -839,13 +909,13 @@ private void previous() {
     if (previousWindowIndex != C.INDEX_UNSET
         && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
             || (window.isDynamic && !window.isSeekable))) {
-      seekTo(previousWindowIndex, C.TIME_UNSET);
+      seekTo(player, previousWindowIndex, C.TIME_UNSET);
     } else {
-      seekTo(0);
+      seekTo(player, 0);
     }
   }
 
-  private void next() {
+  private void next(Player player) {
     Timeline timeline = player.getCurrentTimeline();
     if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
@@ -853,45 +923,38 @@ private void next() {
     int windowIndex = player.getCurrentWindowIndex();
     int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
-      seekTo(nextWindowIndex, C.TIME_UNSET);
+      seekTo(player, nextWindowIndex, C.TIME_UNSET);
     } else if (timeline.getWindow(windowIndex, window).isDynamic) {
-      seekTo(windowIndex, C.TIME_UNSET);
+      seekTo(player, windowIndex, C.TIME_UNSET);
     }
   }
 
-  private void rewind() {
-    if (rewindMs <= 0) {
-      return;
+  private void rewind(Player player) {
+    if (player.isCurrentWindowSeekable() && rewindMs > 0) {
+      seekTo(player, player.getCurrentPosition() - rewindMs);
     }
-    seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
   }
 
-  private void fastForward() {
-    if (fastForwardMs <= 0) {
-      return;
+  private void fastForward(Player player) {
+    if (player.isCurrentWindowSeekable() && fastForwardMs > 0) {
+      seekTo(player, player.getCurrentPosition() + fastForwardMs);
     }
-    long durationMs = player.getDuration();
-    long seekPositionMs = player.getCurrentPosition() + fastForwardMs;
-    if (durationMs != C.TIME_UNSET) {
-      seekPositionMs = Math.min(seekPositionMs, durationMs);
-    }
-    seekTo(seekPositionMs);
   }
 
-  private void seekTo(long positionMs) {
-    seekTo(player.getCurrentWindowIndex(), positionMs);
+  private void seekTo(Player player, long positionMs) {
+    seekTo(player, player.getCurrentWindowIndex(), positionMs);
   }
 
-  private void seekTo(int windowIndex, long positionMs) {
-    boolean dispatched = controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
-    if (!dispatched) {
-      // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
-      // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
-      updateProgress();
+  private boolean seekTo(Player player, int windowIndex, long positionMs) {
+    long durationMs = player.getDuration();
+    if (durationMs != C.TIME_UNSET) {
+      positionMs = Math.min(positionMs, durationMs);
     }
+    positionMs = Math.max(positionMs, 0);
+    return controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
   }
 
-  private void seekToTimeBarPosition(long positionMs) {
+  private void seekToTimeBarPosition(Player player, long positionMs) {
     int windowIndex;
     Timeline timeline = player.getCurrentTimeline();
     if (multiWindowTimeBar && !timeline.isEmpty()) {
@@ -912,7 +975,12 @@ private void seekToTimeBarPosition(long positionMs) {
     } else {
       windowIndex = player.getCurrentWindowIndex();
     }
-    seekTo(windowIndex, positionMs);
+    boolean dispatched = seekTo(player, windowIndex, positionMs);
+    if (!dispatched) {
+      // The seek wasn't dispatched then the progress bar scrubber will be in the wrong position.
+      // Trigger a progress update to snap it back.
+      updateProgress();
+    }
   }
 
   @Override
@@ -969,9 +1037,9 @@ public boolean dispatchMediaKeyEvent(KeyEvent event) {
     }
     if (event.getAction() == KeyEvent.ACTION_DOWN) {
       if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
-        fastForward();
+        fastForward(player);
       } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
-        rewind();
+        rewind(player);
       } else if (event.getRepeatCount() == 0) {
         switch (keyCode) {
           case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
@@ -984,10 +1052,10 @@ public boolean dispatchMediaKeyEvent(KeyEvent event) {
             controlDispatcher.dispatchSetPlayWhenReady(player, false);
             break;
           case KeyEvent.KEYCODE_MEDIA_NEXT:
-            next();
+            next(player);
             break;
           case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-            previous();
+            previous(player);
             break;
           default:
             break;
@@ -1041,6 +1109,9 @@ private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Win
     @Override
     public void onScrubStart(TimeBar timeBar, long position) {
       scrubbing = true;
+      if (positionView != null) {
+        positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
+      }
     }
 
     @Override
@@ -1054,7 +1125,7 @@ public void onScrubMove(TimeBar timeBar, long position) {
     public void onScrubStop(TimeBar timeBar, long position, boolean canceled) {
       scrubbing = false;
       if (!canceled && player != null) {
-        seekToTimeBarPosition(position);
+        seekToTimeBarPosition(player, position);
       }
     }
 
@@ -1079,45 +1150,46 @@ public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
     @Override
     public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
       updateNavigation();
-      updateProgress();
+      updateTimeline();
     }
 
     @Override
     public void onTimelineChanged(
         Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
       updateNavigation();
-      updateTimeBarMode();
-      updateProgress();
+      updateTimeline();
     }
 
     @Override
     public void onClick(View view) {
-      if (player != null) {
-        if (nextButton == view) {
-          next();
-        } else if (previousButton == view) {
-          previous();
-        } else if (fastForwardButton == view) {
-          fastForward();
-        } else if (rewindButton == view) {
-          rewind();
-        } else if (playButton == view) {
-          if (player.getPlaybackState() == Player.STATE_IDLE) {
-            if (playbackPreparer != null) {
-              playbackPreparer.preparePlayback();
-            }
-          } else if (player.getPlaybackState() == Player.STATE_ENDED) {
-            controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+      Player player = PlayerControlView.this.player;
+      if (player == null) {
+        return;
+      }
+      if (nextButton == view) {
+        next(player);
+      } else if (previousButton == view) {
+        previous(player);
+      } else if (fastForwardButton == view) {
+        fastForward(player);
+      } else if (rewindButton == view) {
+        rewind(player);
+      } else if (playButton == view) {
+        if (player.getPlaybackState() == Player.STATE_IDLE) {
+          if (playbackPreparer != null) {
+            playbackPreparer.preparePlayback();
           }
-          controlDispatcher.dispatchSetPlayWhenReady(player, true);
-        } else if (pauseButton == view) {
-          controlDispatcher.dispatchSetPlayWhenReady(player, false);
-        } else if (repeatToggleButton == view) {
-          controlDispatcher.dispatchSetRepeatMode(
-              player, RepeatModeUtil.getNextRepeatMode(player.getRepeatMode(), repeatToggleModes));
-        } else if (shuffleButton == view) {
-          controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
+        } else if (player.getPlaybackState() == Player.STATE_ENDED) {
+          controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
+        controlDispatcher.dispatchSetPlayWhenReady(player, true);
+      } else if (pauseButton == view) {
+        controlDispatcher.dispatchSetPlayWhenReady(player, false);
+      } else if (repeatToggleButton == view) {
+        controlDispatcher.dispatchSetRepeatMode(
+            player, RepeatModeUtil.getNextRepeatMode(player.getRepeatMode(), repeatToggleModes));
+      } else if (shuffleButton == view) {
+        controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
       }
     }
   }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index 47025d9bba..1dbd696b12 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -25,18 +25,19 @@
 import android.graphics.Color;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import android.support.annotation.StringRes;
-import android.support.v4.app.NotificationCompat;
-import android.support.v4.app.NotificationManagerCompat;
-import android.support.v4.media.app.NotificationCompat.MediaStyle;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringRes;
+import androidx.core.app.NotificationCompat;
+import androidx.core.app.NotificationManagerCompat;
+import androidx.media.app.NotificationCompat.MediaStyle;
 import android.support.v4.media.session.MediaSessionCompat;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ControlDispatcher;
 import com.google.android.exoplayer2.DefaultControlDispatcher;
 import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.util.Assertions;
@@ -46,6 +47,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -57,7 +59,7 @@
  * player state.
  *
  * <p>The notification is cancelled when {@code null} is passed to {@link #setPlayer(Player)} or
- * when an intent with action {@link #ACTION_STOP} is received.
+ * when the notification is dismissed by the user.
  *
  * <p>If the player is released it must be removed from the manager by calling {@code
  * setPlayer(null)} which will cancel the notification.
@@ -71,11 +73,23 @@
  *       are displayed.
  *       <ul>
  *         <li>Corresponding setter: {@link #setUseNavigationActions(boolean)}
+ *         <li>Default: {@code true}
  *       </ul>
- *   <li><b>{@code stopAction}</b> - Sets which stop action should be used. If set to null, the stop
- *       action is not displayed.
+ *   <li><b>{@code useNavigationActionsInCompactView}</b> - Sets whether the navigation previous and
+ *       next actions should are displayed in compact view (including the lock screen notification).
+ *       <ul>
+ *         <li>Corresponding setter: {@link #setUseNavigationActionsInCompactView(boolean)}
+ *         <li>Default: {@code false}
+ *       </ul>
+ *   <li><b>{@code usePlayPauseActions}</b> - Sets whether the play and pause actions are displayed.
  *       <ul>
- *         <li>Corresponding setter: {@link #setStopAction(String)}}
+ *         <li>Corresponding setter: {@link #setUsePlayPauseActions(boolean)}
+ *         <li>Default: {@code true}
+ *       </ul>
+ *   <li><b>{@code useStopAction}</b> - Sets whether the stop action is displayed.
+ *       <ul>
+ *         <li>Corresponding setter: {@link #setUseStopAction(boolean)}
+ *         <li>Default: {@code false}
  *       </ul>
  *   <li><b>{@code rewindIncrementMs}</b> - Sets the rewind increment. If set to zero the rewind
  *       action is not displayed.
@@ -86,7 +100,7 @@
  *   <li><b>{@code fastForwardIncrementMs}</b> - Sets the fast forward increment. If set to zero the
  *       fast forward action is not included in the notification.
  *       <ul>
- *         <li>Corresponding setter: {@link #setFastForwardIncrementMs(long)}}
+ *         <li>Corresponding setter: {@link #setFastForwardIncrementMs(long)}
  *         <li>Default: {@link #DEFAULT_FAST_FORWARD_MS} (5000)
  *       </ul>
  * </ul>
@@ -125,6 +139,18 @@
     @Nullable
     String getCurrentContentText(Player player);
 
+    /**
+     * Gets the content sub text for the current media item.
+     *
+     * <p>See {@link NotificationCompat.Builder#setSubText(CharSequence)}.
+     *
+     * @param player The {@link Player} for which a notification is being built.
+     */
+    @Nullable
+    default String getCurrentSubText(Player player) {
+      return null;
+    }
+
     /**
      * Gets the large icon for the current media item.
      *
@@ -182,7 +208,7 @@
     void onCustomAction(Player player, String action, Intent intent);
   }
 
-  /** A listener for start and cancellation of the notification. */
+  /** A listener for changes to the notification. */
   public interface NotificationListener {
 
     /**
@@ -190,15 +216,41 @@
      *
      * @param notificationId The id with which the notification has been posted.
      * @param notification The {@link Notification}.
+     * @deprecated Use {@link #onNotificationPosted(int, Notification, boolean)} instead.
      */
-    void onNotificationStarted(int notificationId, Notification notification);
+    @Deprecated
+    default void onNotificationStarted(int notificationId, Notification notification) {}
 
     /**
      * Called after the notification has been cancelled.
      *
      * @param notificationId The id of the notification which has been cancelled.
+     * @deprecated Use {@link #onNotificationCancelled(int, boolean)}.
      */
-    void onNotificationCancelled(int notificationId);
+    @Deprecated
+    default void onNotificationCancelled(int notificationId) {}
+
+    /**
+     * Called after the notification has been cancelled.
+     *
+     * @param notificationId The id of the notification which has been cancelled.
+     * @param dismissedByUser {@code true} if the notification is cancelled because the user
+     *     dismissed the notification.
+     */
+    default void onNotificationCancelled(int notificationId, boolean dismissedByUser) {}
+
+    /**
+     * Called each time after the notification has been posted.
+     *
+     * <p>For a service, the {@code ongoing} flag can be used as an indicator as to whether it
+     * should be in the foreground.
+     *
+     * @param notificationId The id of the notification which has been posted.
+     * @param notification The {@link Notification}.
+     * @param ongoing Whether the notification is ongoing.
+     */
+    default void onNotificationPosted(
+        int notificationId, Notification notification, boolean ongoing) {}
   }
 
   /** Receives a {@link Bitmap}. */
@@ -222,7 +274,7 @@ public void onBitmap(final Bitmap bitmap) {
               if (player != null
                   && notificationTag == currentNotificationTag
                   && isNotificationStarted) {
-                updateNotification(bitmap);
+                startOrUpdateNotification(bitmap);
               }
             });
       }
@@ -241,10 +293,15 @@ public void onBitmap(final Bitmap bitmap) {
   public static final String ACTION_FAST_FORWARD = "com.google.android.exoplayer.ffwd";
   /** The action which rewinds. */
   public static final String ACTION_REWIND = "com.google.android.exoplayer.rewind";
-  /** The action which cancels the notification and stops playback. */
+  /** The action which stops playback. */
   public static final String ACTION_STOP = "com.google.android.exoplayer.stop";
   /** The extra key of the instance id of the player notification manager. */
   public static final String EXTRA_INSTANCE_ID = "INSTANCE_ID";
+  /**
+   * The action which is executed when the notification is dismissed. It cancels the notification
+   * and calls {@link NotificationListener#onNotificationCancelled(int, boolean)}.
+   */
+  private static final String ACTION_DISMISS = "com.google.android.exoplayer.dismiss";
 
   /**
    * Visibility of notification on the lock screen. One of {@link
@@ -290,7 +347,7 @@ public void onBitmap(final Bitmap bitmap) {
   private final String channelId;
   private final int notificationId;
   private final MediaDescriptionAdapter mediaDescriptionAdapter;
-  private final @Nullable CustomActionReceiver customActionReceiver;
+  @Nullable private final CustomActionReceiver customActionReceiver;
   private final Handler mainHandler;
   private final NotificationManagerCompat notificationManager;
   private final IntentFilter intentFilter;
@@ -298,28 +355,32 @@ public void onBitmap(final Bitmap bitmap) {
   private final NotificationBroadcastReceiver notificationBroadcastReceiver;
   private final Map<String, NotificationCompat.Action> playbackActions;
   private final Map<String, NotificationCompat.Action> customActions;
+  private final PendingIntent dismissPendingIntent;
   private final int instanceId;
+  private final Timeline.Window window;
 
-  private @Nullable Player player;
+  @Nullable private NotificationCompat.Builder builder;
+  @Nullable private ArrayList<NotificationCompat.Action> builderActions;
+  @Nullable private Player player;
+  @Nullable private PlaybackPreparer playbackPreparer;
   private ControlDispatcher controlDispatcher;
   private boolean isNotificationStarted;
   private int currentNotificationTag;
-  private @Nullable NotificationListener notificationListener;
-  private @Nullable MediaSessionCompat.Token mediaSessionToken;
+  @Nullable private NotificationListener notificationListener;
+  @Nullable private MediaSessionCompat.Token mediaSessionToken;
   private boolean useNavigationActions;
+  private boolean useNavigationActionsInCompactView;
   private boolean usePlayPauseActions;
-  private @Nullable String stopAction;
-  private @Nullable PendingIntent stopPendingIntent;
+  private boolean useStopAction;
   private long fastForwardMs;
   private long rewindMs;
   private int badgeIconType;
   private boolean colorized;
   private int defaults;
   private int color;
-  private @DrawableRes int smallIconResourceId;
+  @DrawableRes private int smallIconResourceId;
   private int visibility;
-  private @Priority int priority;
-  private boolean ongoing;
+  @Priority private int priority;
   private boolean useChronometer;
   private boolean wasPlayWhenReady;
   private int lastPlaybackState;
@@ -328,6 +389,12 @@ public void onBitmap(final Bitmap bitmap) {
    * Creates a notification manager and a low-priority notification channel with the specified
    * {@code channelId} and {@code channelName}.
    *
+   * <p>If the player notification manager is intended to be used within a foreground service,
+   * {@link #createWithNotificationChannel(Context, String, int, int, MediaDescriptionAdapter,
+   * NotificationListener)} should be used to which a {@link NotificationListener} can be passed.
+   * This way you'll receive the notification to put the service into the foreground by calling
+   * {@link android.app.Service#startForeground(int, Notification)}.
+   *
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
    * @param channelName A string resource identifier for the user visible name of the channel. The
@@ -347,10 +414,40 @@ public static PlayerNotificationManager createWithNotificationChannel(
         context, channelId, notificationId, mediaDescriptionAdapter);
   }
 
+  /**
+   * Creates a notification manager and a low-priority notification channel with the specified
+   * {@code channelId} and {@code channelName}. The {@link NotificationListener} passed as the last
+   * parameter will be notified when the notification is created and cancelled.
+   *
+   * @param context The {@link Context}.
+   * @param channelId The id of the notification channel.
+   * @param channelName A string resource identifier for the user visible name of the channel. The
+   *     recommended maximum length is 40 characters; the value may be truncated if it is too long.
+   * @param notificationId The id of the notification.
+   * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
+   * @param notificationListener The {@link NotificationListener}.
+   */
+  public static PlayerNotificationManager createWithNotificationChannel(
+      Context context,
+      String channelId,
+      @StringRes int channelName,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter,
+      @Nullable NotificationListener notificationListener) {
+    NotificationUtil.createNotificationChannel(
+        context, channelId, channelName, NotificationUtil.IMPORTANCE_LOW);
+    return new PlayerNotificationManager(
+        context, channelId, notificationId, mediaDescriptionAdapter, notificationListener);
+  }
+
   /**
    * Creates a notification manager using the specified notification {@code channelId}. The caller
    * is responsible for creating the notification channel.
    *
+   * <p>When used within a service, consider using {@link #PlayerNotificationManager(Context,
+   * String, int, MediaDescriptionAdapter, NotificationListener)} to which a {@link
+   * NotificationListener} can be passed.
+   *
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
    * @param notificationId The id of the notification.
@@ -366,13 +463,43 @@ public PlayerNotificationManager(
         channelId,
         notificationId,
         mediaDescriptionAdapter,
-        /* customActionReceiver= */ null);
+        /* notificationListener= */ null,
+        /* customActionReceiver */ null);
+  }
+
+  /**
+   * Creates a notification manager using the specified notification {@code channelId} and {@link
+   * NotificationListener}. The caller is responsible for creating the notification channel.
+   *
+   * @param context The {@link Context}.
+   * @param channelId The id of the notification channel.
+   * @param notificationId The id of the notification.
+   * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
+   * @param notificationListener The {@link NotificationListener}.
+   */
+  public PlayerNotificationManager(
+      Context context,
+      String channelId,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter,
+      @Nullable NotificationListener notificationListener) {
+    this(
+        context,
+        channelId,
+        notificationId,
+        mediaDescriptionAdapter,
+        notificationListener,
+        /* customActionReceiver*/ null);
   }
 
   /**
    * Creates a notification manager using the specified notification {@code channelId} and {@link
    * CustomActionReceiver}. The caller is responsible for creating the notification channel.
    *
+   * <p>When used within a service, consider using {@link #PlayerNotificationManager(Context,
+   * String, int, MediaDescriptionAdapter, NotificationListener, CustomActionReceiver)} to which a
+   * {@link NotificationListener} can be passed.
+   *
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
    * @param notificationId The id of the notification.
@@ -385,12 +512,43 @@ public PlayerNotificationManager(
       int notificationId,
       MediaDescriptionAdapter mediaDescriptionAdapter,
       @Nullable CustomActionReceiver customActionReceiver) {
-    this.context = context.getApplicationContext();
+    this(
+        context,
+        channelId,
+        notificationId,
+        mediaDescriptionAdapter,
+        /* notificationListener */ null,
+        customActionReceiver);
+  }
+
+  /**
+   * Creates a notification manager using the specified notification {@code channelId}, {@link
+   * NotificationListener} and {@link CustomActionReceiver}. The caller is responsible for creating
+   * the notification channel.
+   *
+   * @param context The {@link Context}.
+   * @param channelId The id of the notification channel.
+   * @param notificationId The id of the notification.
+   * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
+   * @param notificationListener The {@link NotificationListener}.
+   * @param customActionReceiver The {@link CustomActionReceiver}.
+   */
+  public PlayerNotificationManager(
+      Context context,
+      String channelId,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter,
+      @Nullable NotificationListener notificationListener,
+      @Nullable CustomActionReceiver customActionReceiver) {
+    context = context.getApplicationContext();
+    this.context = context;
     this.channelId = channelId;
     this.notificationId = notificationId;
     this.mediaDescriptionAdapter = mediaDescriptionAdapter;
+    this.notificationListener = notificationListener;
     this.customActionReceiver = customActionReceiver;
-    this.controlDispatcher = new DefaultControlDispatcher();
+    controlDispatcher = new DefaultControlDispatcher();
+    window = new Timeline.Window();
     instanceId = instanceIdCounter++;
     mainHandler = new Handler(Looper.getMainLooper());
     notificationManager = NotificationManagerCompat.from(context);
@@ -399,7 +557,6 @@ public PlayerNotificationManager(
     intentFilter = new IntentFilter();
     useNavigationActions = true;
     usePlayPauseActions = true;
-    ongoing = true;
     colorized = true;
     useChronometer = true;
     color = Color.TRANSPARENT;
@@ -408,7 +565,6 @@ public PlayerNotificationManager(
     priority = NotificationCompat.PRIORITY_LOW;
     fastForwardMs = DEFAULT_FAST_FORWARD_MS;
     rewindMs = DEFAULT_REWIND_MS;
-    stopAction = ACTION_STOP;
     badgeIconType = NotificationCompat.BADGE_ICON_SMALL;
     visibility = NotificationCompat.VISIBILITY_PUBLIC;
 
@@ -424,7 +580,8 @@ public PlayerNotificationManager(
     for (String action : customActions.keySet()) {
       intentFilter.addAction(action);
     }
-    stopPendingIntent = Assertions.checkNotNull(playbackActions.get(ACTION_STOP)).actionIntent;
+    dismissPendingIntent = createBroadcastIntent(ACTION_DISMISS, context, instanceId);
+    intentFilter.addAction(ACTION_DISMISS);
   }
 
   /**
@@ -451,7 +608,7 @@ public final void setPlayer(@Nullable Player player) {
     if (this.player != null) {
       this.player.removeListener(playerListener);
       if (player == null) {
-        stopNotification();
+        stopNotification(/* dismissedByUser= */ false);
       }
     }
     this.player = player;
@@ -459,12 +616,19 @@ public final void setPlayer(@Nullable Player player) {
       wasPlayWhenReady = player.getPlayWhenReady();
       lastPlaybackState = player.getPlaybackState();
       player.addListener(playerListener);
-      if (lastPlaybackState != Player.STATE_IDLE) {
-        startOrUpdateNotification();
-      }
+      startOrUpdateNotification();
     }
   }
 
+  /**
+   * Sets the {@link PlaybackPreparer}.
+   *
+   * @param playbackPreparer The {@link PlaybackPreparer}.
+   */
+  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
+    this.playbackPreparer = playbackPreparer;
+  }
+
   /**
    * Sets the {@link ControlDispatcher}.
    *
@@ -479,8 +643,14 @@ public final void setControlDispatcher(ControlDispatcher controlDispatcher) {
   /**
    * Sets the {@link NotificationListener}.
    *
+   * <p>Please note that you should call this method before you call {@link #setPlayer(Player)} or
+   * you may not get the {@link NotificationListener#onNotificationStarted(int, Notification)}
+   * called on your listener.
+   *
    * @param notificationListener The {@link NotificationListener}.
+   * @deprecated Pass the notification listener to the constructor instead.
    */
+  @Deprecated
   public final void setNotificationListener(NotificationListener notificationListener) {
     this.notificationListener = notificationListener;
   }
@@ -525,6 +695,23 @@ public final void setUseNavigationActions(boolean useNavigationActions) {
     }
   }
 
+  /**
+   * Sets whether navigation actions should be displayed in compact view.
+   *
+   * <p>If {@link #useNavigationActions} is set to {@code false} navigation actions are displayed
+   * neither in compact nor in full view mode of the notification.
+   *
+   * @param useNavigationActionsInCompactView Whether the navigation actions should be displayed in
+   *     compact view.
+   */
+  public final void setUseNavigationActionsInCompactView(
+      boolean useNavigationActionsInCompactView) {
+    if (this.useNavigationActionsInCompactView != useNavigationActionsInCompactView) {
+      this.useNavigationActionsInCompactView = useNavigationActionsInCompactView;
+      invalidate();
+    }
+  }
+
   /**
    * Sets whether the play and pause actions should be used.
    *
@@ -538,24 +725,15 @@ public final void setUsePlayPauseActions(boolean usePlayPauseActions) {
   }
 
   /**
-   * Sets the name of the action to be used as stop action to cancel the notification. If {@code
-   * null} is passed the stop action is not displayed.
+   * Sets whether the stop action should be used.
    *
-   * @param stopAction The name of the stop action which must be {@link #ACTION_STOP} or an action
-   *     provided by the {@link CustomActionReceiver}. {@code null} to omit the stop action.
+   * @param useStopAction Whether to use the stop action.
    */
-  public final void setStopAction(@Nullable String stopAction) {
-    if (Util.areEqual(stopAction, this.stopAction)) {
+  public final void setUseStopAction(boolean useStopAction) {
+    if (this.useStopAction == useStopAction) {
       return;
     }
-    this.stopAction = stopAction;
-    if (ACTION_STOP.equals(stopAction)) {
-      stopPendingIntent = Assertions.checkNotNull(playbackActions.get(ACTION_STOP)).actionIntent;
-    } else if (stopAction != null) {
-      stopPendingIntent = Assertions.checkNotNull(customActions.get(stopAction)).actionIntent;
-    } else {
-      stopPendingIntent = null;
-    }
+    this.useStopAction = useStopAction;
     invalidate();
   }
 
@@ -637,22 +815,6 @@ public final void setColor(int color) {
     }
   }
 
-  /**
-   * Sets whether the notification should be ongoing. If {@code false} the user can dismiss the
-   * notification by swiping. If in addition the stop action is enabled dismissing the notification
-   * triggers the stop action.
-   *
-   * <p>See {@link NotificationCompat.Builder#setOngoing(boolean)}.
-   *
-   * @param ongoing Whether {@code true} the notification is ongoing and not dismissible.
-   */
-  public final void setOngoing(boolean ongoing) {
-    if (this.ongoing != ongoing) {
-      this.ongoing = ongoing;
-      invalidate();
-    }
-  }
-
   /**
    * Sets the priority of the notification required for API 25 and lower.
    *
@@ -738,36 +900,49 @@ public final void setVisibility(@Visibility int visibility) {
   /** Forces an update of the notification if already started. */
   public void invalidate() {
     if (isNotificationStarted && player != null) {
-      updateNotification(null);
+      startOrUpdateNotification();
     }
   }
 
-  @RequiresNonNull("player")
-  private Notification updateNotification(@Nullable Bitmap bitmap) {
-    Notification notification = createNotification(player, bitmap);
-    notificationManager.notify(notificationId, notification);
-    return notification;
+  @Nullable
+  private Notification startOrUpdateNotification() {
+    Assertions.checkNotNull(this.player);
+    return startOrUpdateNotification(/* bitmap= */ null);
   }
 
-  private void startOrUpdateNotification() {
-    if (player != null) {
-      Notification notification = updateNotification(null);
-      if (!isNotificationStarted) {
-        isNotificationStarted = true;
-        context.registerReceiver(notificationBroadcastReceiver, intentFilter);
-        if (notificationListener != null) {
-          notificationListener.onNotificationStarted(notificationId, notification);
-        }
+  @RequiresNonNull("player")
+  @Nullable
+  private Notification startOrUpdateNotification(@Nullable Bitmap bitmap) {
+    Player player = this.player;
+    boolean ongoing = getOngoing(player);
+    builder = createNotification(player, builder, ongoing, bitmap);
+    if (builder == null) {
+      stopNotification(/* dismissedByUser= */ false);
+      return null;
+    }
+    Notification notification = builder.build();
+    notificationManager.notify(notificationId, notification);
+    if (!isNotificationStarted) {
+      isNotificationStarted = true;
+      context.registerReceiver(notificationBroadcastReceiver, intentFilter);
+      if (notificationListener != null) {
+        notificationListener.onNotificationStarted(notificationId, notification);
       }
     }
+    NotificationListener listener = notificationListener;
+    if (listener != null) {
+      listener.onNotificationPosted(notificationId, notification, ongoing);
+    }
+    return notification;
   }
 
-  private void stopNotification() {
+  private void stopNotification(boolean dismissedByUser) {
     if (isNotificationStarted) {
-      notificationManager.cancel(notificationId);
       isNotificationStarted = false;
+      notificationManager.cancel(notificationId);
       context.unregisterReceiver(notificationBroadcastReceiver);
       if (notificationListener != null) {
+        notificationListener.onNotificationCancelled(notificationId, dismissedByUser);
         notificationListener.onNotificationCancelled(notificationId);
       }
     }
@@ -777,12 +952,27 @@ private void stopNotification() {
    * Creates the notification given the current player state.
    *
    * @param player The player for which state to build a notification.
+   * @param builder The builder used to build the last notification, or {@code null}. Re-using the
+   *     builder when possible can prevent notification flicker when {@code Util#SDK_INT} &lt; 21.
+   * @param ongoing Whether the notification should be ongoing.
    * @param largeIcon The large icon to be used.
-   * @return The {@link Notification} which has been built.
+   * @return The {@link NotificationCompat.Builder} on which to call {@link
+   *     NotificationCompat.Builder#build()} to obtain the notification, or {@code null} if no
+   *     notification should be displayed.
    */
-  protected Notification createNotification(Player player, @Nullable Bitmap largeIcon) {
-    NotificationCompat.Builder builder = new NotificationCompat.Builder(context, channelId);
+  @Nullable
+  protected NotificationCompat.Builder createNotification(
+      Player player,
+      @Nullable NotificationCompat.Builder builder,
+      boolean ongoing,
+      @Nullable Bitmap largeIcon) {
+    if (player.getPlaybackState() == Player.STATE_IDLE) {
+      builderActions = null;
+      return null;
+    }
+
     List<String> actionNames = getActions(player);
+    ArrayList<NotificationCompat.Action> actions = new ArrayList<>(actionNames.size());
     for (int i = 0; i < actionNames.size(); i++) {
       String actionName = actionNames.get(i);
       NotificationCompat.Action action =
@@ -790,23 +980,31 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
               ? playbackActions.get(actionName)
               : customActions.get(actionName);
       if (action != null) {
-        builder.addAction(action);
+        actions.add(action);
+      }
+    }
+
+    if (builder == null || !actions.equals(builderActions)) {
+      builder = new NotificationCompat.Builder(context, channelId);
+      builderActions = actions;
+      for (int i = 0; i < actions.size(); i++) {
+        builder.addAction(actions.get(i));
       }
     }
-    // Create a media style notification.
+
     MediaStyle mediaStyle = new MediaStyle();
     if (mediaSessionToken != null) {
       mediaStyle.setMediaSession(mediaSessionToken);
     }
     mediaStyle.setShowActionsInCompactView(getActionIndicesForCompactView(actionNames, player));
-    // Configure stop action (eg. when user dismisses the notification when !isOngoing).
-    boolean useStopAction = stopAction != null;
-    mediaStyle.setShowCancelButton(useStopAction);
-    if (useStopAction && stopPendingIntent != null) {
-      builder.setDeleteIntent(stopPendingIntent);
-      mediaStyle.setCancelButtonIntent(stopPendingIntent);
-    }
+    // Configure dismiss action prior to API 21 ('x' button).
+    mediaStyle.setShowCancelButton(!ongoing);
+    mediaStyle.setCancelButtonIntent(dismissPendingIntent);
     builder.setStyle(mediaStyle);
+
+    // Set intent which is sent if the user selects 'clear all'
+    builder.setDeleteIntent(dismissPendingIntent);
+
     // Set notification properties from getters.
     builder
         .setBadgeIconType(badgeIconType)
@@ -817,7 +1015,10 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
         .setVisibility(visibility)
         .setPriority(priority)
         .setDefaults(defaults);
-    if (useChronometer
+
+    // Changing "showWhen" causes notification flicker if SDK_INT < 21.
+    if (Util.SDK_INT >= 21
+        && useChronometer
         && !player.isPlayingAd()
         && !player.isCurrentWindowDynamic()
         && player.getPlayWhenReady()
@@ -829,22 +1030,20 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
     } else {
       builder.setShowWhen(false).setUsesChronometer(false);
     }
+
     // Set media specific notification properties from MediaDescriptionAdapter.
     builder.setContentTitle(mediaDescriptionAdapter.getCurrentContentTitle(player));
     builder.setContentText(mediaDescriptionAdapter.getCurrentContentText(player));
+    builder.setSubText(mediaDescriptionAdapter.getCurrentSubText(player));
     if (largeIcon == null) {
       largeIcon =
           mediaDescriptionAdapter.getCurrentLargeIcon(
               player, new BitmapCallback(++currentNotificationTag));
     }
-    if (largeIcon != null) {
-      builder.setLargeIcon(largeIcon);
-    }
-    PendingIntent contentIntent = mediaDescriptionAdapter.createCurrentContentIntent(player);
-    if (contentIntent != null) {
-      builder.setContentIntent(contentIntent);
-    }
-    return builder.build();
+    setLargeIcon(builder, largeIcon);
+    builder.setContentIntent(mediaDescriptionAdapter.createCurrentContentIntent(player));
+
+    return builder;
   }
 
   /**
@@ -867,36 +1066,44 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
    * action name is ignored.
    */
   protected List<String> getActions(Player player) {
-    boolean isPlayingAd = player.isPlayingAd();
+    boolean enablePrevious = false;
+    boolean enableRewind = false;
+    boolean enableFastForward = false;
+    boolean enableNext = false;
+    Timeline timeline = player.getCurrentTimeline();
+    if (!timeline.isEmpty() && !player.isPlayingAd()) {
+      timeline.getWindow(player.getCurrentWindowIndex(), window);
+      enablePrevious = window.isSeekable || !window.isDynamic || player.hasPrevious();
+      enableRewind = rewindMs > 0;
+      enableFastForward = fastForwardMs > 0;
+      enableNext = window.isDynamic || player.hasNext();
+    }
+
     List<String> stringActions = new ArrayList<>();
-    if (!isPlayingAd) {
-      if (useNavigationActions) {
-        stringActions.add(ACTION_PREVIOUS);
-      }
-      if (rewindMs > 0) {
-        stringActions.add(ACTION_REWIND);
-      }
+    if (useNavigationActions && enablePrevious) {
+      stringActions.add(ACTION_PREVIOUS);
+    }
+    if (enableRewind) {
+      stringActions.add(ACTION_REWIND);
     }
     if (usePlayPauseActions) {
-      if (player.getPlayWhenReady()) {
+      if (isPlaying(player)) {
         stringActions.add(ACTION_PAUSE);
       } else {
         stringActions.add(ACTION_PLAY);
       }
     }
-    if (!isPlayingAd) {
-      if (fastForwardMs > 0) {
-        stringActions.add(ACTION_FAST_FORWARD);
-      }
-      if (useNavigationActions && player.getNextWindowIndex() != C.INDEX_UNSET) {
-        stringActions.add(ACTION_NEXT);
-      }
+    if (enableFastForward) {
+      stringActions.add(ACTION_FAST_FORWARD);
+    }
+    if (useNavigationActions && enableNext) {
+      stringActions.add(ACTION_NEXT);
     }
     if (customActionReceiver != null) {
       stringActions.addAll(customActionReceiver.getCustomActions(player));
     }
-    if (ACTION_STOP.equals(stopAction)) {
-      stringActions.add(stopAction);
+    if (useStopAction) {
+      stringActions.add(ACTION_STOP);
     }
     return stringActions;
   }
@@ -908,14 +1115,101 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
    * first parameter.
    *
    * @param actionNames The names of the actions included in the notification.
-   * @param player The player for which state to build a notification.
+   * @param player The player for which a notification is being built.
    */
+  @SuppressWarnings("unused")
   protected int[] getActionIndicesForCompactView(List<String> actionNames, Player player) {
     int pauseActionIndex = actionNames.indexOf(ACTION_PAUSE);
     int playActionIndex = actionNames.indexOf(ACTION_PLAY);
-    return pauseActionIndex != -1
-        ? new int[] {pauseActionIndex}
-        : (playActionIndex != -1 ? new int[] {playActionIndex} : new int[0]);
+    int skipPreviousActionIndex =
+        useNavigationActionsInCompactView ? actionNames.indexOf(ACTION_PREVIOUS) : -1;
+    int skipNextActionIndex =
+        useNavigationActionsInCompactView ? actionNames.indexOf(ACTION_NEXT) : -1;
+
+    int[] actionIndices = new int[3];
+    int actionCounter = 0;
+    if (skipPreviousActionIndex != -1) {
+      actionIndices[actionCounter++] = skipPreviousActionIndex;
+    }
+    boolean playWhenReady = player.getPlayWhenReady();
+    if (pauseActionIndex != -1 && playWhenReady) {
+      actionIndices[actionCounter++] = pauseActionIndex;
+    } else if (playActionIndex != -1 && !playWhenReady) {
+      actionIndices[actionCounter++] = playActionIndex;
+    }
+    if (skipNextActionIndex != -1) {
+      actionIndices[actionCounter++] = skipNextActionIndex;
+    }
+    return Arrays.copyOf(actionIndices, actionCounter);
+  }
+
+  /** Returns whether the generated notification should be ongoing. */
+  protected boolean getOngoing(Player player) {
+    int playbackState = player.getPlaybackState();
+    return (playbackState == Player.STATE_BUFFERING || playbackState == Player.STATE_READY)
+        && player.getPlayWhenReady();
+  }
+
+  private void previous(Player player) {
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty() || player.isPlayingAd()) {
+      return;
+    }
+    int windowIndex = player.getCurrentWindowIndex();
+    timeline.getWindow(windowIndex, window);
+    int previousWindowIndex = player.getPreviousWindowIndex();
+    if (previousWindowIndex != C.INDEX_UNSET
+        && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
+            || (window.isDynamic && !window.isSeekable))) {
+      seekTo(player, previousWindowIndex, C.TIME_UNSET);
+    } else {
+      seekTo(player, 0);
+    }
+  }
+
+  private void next(Player player) {
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty() || player.isPlayingAd()) {
+      return;
+    }
+    int windowIndex = player.getCurrentWindowIndex();
+    int nextWindowIndex = player.getNextWindowIndex();
+    if (nextWindowIndex != C.INDEX_UNSET) {
+      seekTo(player, nextWindowIndex, C.TIME_UNSET);
+    } else if (timeline.getWindow(windowIndex, window).isDynamic) {
+      seekTo(player, windowIndex, C.TIME_UNSET);
+    }
+  }
+
+  private void rewind(Player player) {
+    if (player.isCurrentWindowSeekable() && rewindMs > 0) {
+      seekTo(player, Math.max(player.getCurrentPosition() - rewindMs, 0));
+    }
+  }
+
+  private void fastForward(Player player) {
+    if (player.isCurrentWindowSeekable() && fastForwardMs > 0) {
+      seekTo(player, player.getCurrentPosition() + fastForwardMs);
+    }
+  }
+
+  private void seekTo(Player player, long positionMs) {
+    seekTo(player, player.getCurrentWindowIndex(), positionMs);
+  }
+
+  private void seekTo(Player player, int windowIndex, long positionMs) {
+    long duration = player.getDuration();
+    if (duration != C.TIME_UNSET) {
+      positionMs = Math.min(positionMs, duration);
+    }
+    positionMs = Math.max(positionMs, 0);
+    controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
+  }
+
+  private boolean isPlaying(Player player) {
+    return player.getPlaybackState() != Player.STATE_ENDED
+        && player.getPlaybackState() != Player.STATE_IDLE
+        && player.getPlayWhenReady();
   }
 
   private static Map<String, NotificationCompat.Action> createPlaybackActions(
@@ -971,34 +1265,32 @@ private static PendingIntent createBroadcastIntent(
     Intent intent = new Intent(action).setPackage(context.getPackageName());
     intent.putExtra(EXTRA_INSTANCE_ID, instanceId);
     return PendingIntent.getBroadcast(
-        context, instanceId, intent, PendingIntent.FLAG_CANCEL_CURRENT);
+        context, instanceId, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+  }
+
+  @SuppressWarnings("nullness:argument.type.incompatible")
+  private static void setLargeIcon(NotificationCompat.Builder builder, @Nullable Bitmap largeIcon) {
+    builder.setLargeIcon(largeIcon);
   }
 
   private class PlayerListener implements Player.EventListener {
 
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      if ((wasPlayWhenReady != playWhenReady && playbackState != Player.STATE_IDLE)
-          || lastPlaybackState != playbackState) {
+      if (wasPlayWhenReady != playWhenReady || lastPlaybackState != playbackState) {
         startOrUpdateNotification();
+        wasPlayWhenReady = playWhenReady;
+        lastPlaybackState = playbackState;
       }
-      wasPlayWhenReady = playWhenReady;
-      lastPlaybackState = playbackState;
     }
 
     @Override
     public void onTimelineChanged(Timeline timeline, @Nullable Object manifest, int reason) {
-      if (player == null || player.getPlaybackState() == Player.STATE_IDLE) {
-        return;
-      }
       startOrUpdateNotification();
     }
 
     @Override
     public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      if (player == null || player.getPlaybackState() == Player.STATE_IDLE) {
-        return;
-      }
       startOrUpdateNotification();
     }
 
@@ -1009,22 +1301,12 @@ public void onPositionDiscontinuity(int reason) {
 
     @Override
     public void onRepeatModeChanged(int repeatMode) {
-      if (player == null || player.getPlaybackState() == Player.STATE_IDLE) {
-        return;
-      }
       startOrUpdateNotification();
     }
   }
 
   private class NotificationBroadcastReceiver extends BroadcastReceiver {
 
-    private final Timeline.Window window;
-
-    /** Creates the broadcast receiver. */
-    public NotificationBroadcastReceiver() {
-      window = new Timeline.Window();
-    }
-
     @Override
     public void onReceive(Context context, Intent intent) {
       Player player = PlayerNotificationManager.this.player;
@@ -1034,31 +1316,32 @@ public void onReceive(Context context, Intent intent) {
         return;
       }
       String action = intent.getAction();
-      if (ACTION_PLAY.equals(action) || ACTION_PAUSE.equals(action)) {
-        controlDispatcher.dispatchSetPlayWhenReady(player, ACTION_PLAY.equals(action));
-      } else if (ACTION_FAST_FORWARD.equals(action) || ACTION_REWIND.equals(action)) {
-        long increment = ACTION_FAST_FORWARD.equals(action) ? fastForwardMs : -rewindMs;
-        controlDispatcher.dispatchSeekTo(
-            player, player.getCurrentWindowIndex(), player.getCurrentPosition() + increment);
-      } else if (ACTION_NEXT.equals(action)) {
-        int nextWindowIndex = player.getNextWindowIndex();
-        if (nextWindowIndex != C.INDEX_UNSET) {
-          controlDispatcher.dispatchSeekTo(player, nextWindowIndex, C.TIME_UNSET);
-        }
-      } else if (ACTION_PREVIOUS.equals(action)) {
-        player.getCurrentTimeline().getWindow(player.getCurrentWindowIndex(), window);
-        int previousWindowIndex = player.getPreviousWindowIndex();
-        if (previousWindowIndex != C.INDEX_UNSET
-            && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
-                || (window.isDynamic && !window.isSeekable))) {
-          controlDispatcher.dispatchSeekTo(player, previousWindowIndex, C.TIME_UNSET);
-        } else {
+      if (ACTION_PLAY.equals(action)) {
+        if (player.getPlaybackState() == Player.STATE_IDLE) {
+          if (playbackPreparer != null) {
+            playbackPreparer.preparePlayback();
+          }
+        } else if (player.getPlaybackState() == Player.STATE_ENDED) {
           controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
+        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ true);
+      } else if (ACTION_PAUSE.equals(action)) {
+        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ false);
+      } else if (ACTION_PREVIOUS.equals(action)) {
+        previous(player);
+      } else if (ACTION_REWIND.equals(action)) {
+        rewind(player);
+      } else if (ACTION_FAST_FORWARD.equals(action)) {
+        fastForward(player);
+      } else if (ACTION_NEXT.equals(action)) {
+        next(player);
       } else if (ACTION_STOP.equals(action)) {
-        controlDispatcher.dispatchStop(player, true);
-        stopNotification();
-      } else if (customActionReceiver != null && customActions.containsKey(action)) {
+        controlDispatcher.dispatchStop(player, /* reset= */ true);
+      } else if (ACTION_DISMISS.equals(action)) {
+        stopNotification(/* dismissedByUser= */ true);
+      } else if (action != null
+          && customActionReceiver != null
+          && customActions.containsKey(action)) {
         customActionReceiver.onCustomAction(player, action, intent);
       }
     }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 88eabfed07..93461c1b24 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -28,9 +28,9 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import android.support.v4.content.ContextCompat;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.core.content.ContextCompat;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -54,6 +54,7 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -69,6 +70,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -221,6 +223,11 @@
  *       <ul>
  *         <li>Type: {@link PlayerControlView}
  *       </ul>
+ *   <li><b>{@code exo_ad_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
+ *       is used to show ad UI (if applicable).
+ *       <ul>
+ *         <li>Type: {@link FrameLayout}
+ *       </ul>
  *   <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
  *       the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
  *       <ul>
@@ -239,7 +246,7 @@
  * PlayerView. This will cause the specified layout to be inflated instead of {@code
  * exo_player_view.xml} for only the instance on which the attribute is set.
  */
-public class PlayerView extends FrameLayout {
+public class PlayerView extends FrameLayout implements AdsLoader.AdViewProvider {
 
   // LINT.IfChange
   /**
@@ -278,9 +285,10 @@
   private final SubtitleView subtitleView;
   @Nullable private final View bufferingView;
   @Nullable private final TextView errorMessageView;
-  private final PlayerControlView controller;
+  @Nullable private final PlayerControlView controller;
   private final ComponentListener componentListener;
-  private final FrameLayout overlayFrameLayout;
+  @Nullable private final FrameLayout adOverlayFrameLayout;
+  @Nullable private final FrameLayout overlayFrameLayout;
 
   private Player player;
   private boolean useController;
@@ -317,6 +325,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       errorMessageView = null;
       controller = null;
       componentListener = null;
+      adOverlayFrameLayout = null;
       overlayFrameLayout = null;
       ImageView logo = new ImageView(context);
       if (Util.SDK_INT >= 23) {
@@ -395,7 +404,6 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
           surfaceView = new TextureView(context);
           break;
         case SURFACE_TYPE_MONO360_VIEW:
-          Assertions.checkState(Util.SDK_INT >= 15);
           SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
           sphericalSurfaceView.setSurfaceListener(componentListener);
           sphericalSurfaceView.setSingleTapListener(componentListener);
@@ -411,6 +419,9 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       surfaceView = null;
     }
 
+    // Ad overlay frame layout.
+    adOverlayFrameLayout = findViewById(R.id.exo_ad_overlay);
+
     // Overlay frame layout.
     overlayFrameLayout = findViewById(R.id.exo_overlay);
 
@@ -679,8 +690,9 @@ public void setShutterBackgroundColor(int color) {
   /**
    * Sets whether the currently displayed video frame or media artwork is kept visible when the
    * player is reset. A player reset is defined to mean the player being re-prepared with different
-   * media, {@link Player#stop(boolean)} being called with {@code reset=true}, or the player being
-   * replaced or cleared by calling {@link #setPlayer(Player)}.
+   * media, the player transitioning to unprepared media, {@link Player#stop(boolean)} being called
+   * with {@code reset=true}, or the player being replaced or cleared by calling {@link
+   * #setPlayer(Player)}.
    *
    * <p>If enabled, the currently displayed video frame or media artwork will be kept visible until
    * the player set on the view has been successfully prepared with new media and loaded enough of
@@ -757,10 +769,6 @@ public void setCustomErrorMessage(@Nullable CharSequence message) {
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
     if (player != null && player.isPlayingAd()) {
-      // Focus any overlay UI now, in case it's provided by a WebView whose contents may update
-      // dynamically. This is needed to make the "Skip ad" button focused on Android TV when using
-      // IMA [Internal: b/62371030].
-      overlayFrameLayout.requestFocus();
       return super.dispatchKeyEvent(event);
     }
     boolean isDpadWhenControlHidden =
@@ -1015,6 +1023,7 @@ public View getVideoSurfaceView() {
    * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
    *     the overlay is not present.
    */
+  @Nullable
   public FrameLayout getOverlayFrameLayout() {
     return overlayFrameLayout;
   }
@@ -1034,6 +1043,12 @@ public boolean onTouchEvent(MotionEvent ev) {
     if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
       return false;
     }
+    return performClick();
+  }
+
+  @Override
+  public boolean performClick() {
+    super.performClick();
     return toggleControllerVisibility();
   }
 
@@ -1092,6 +1107,28 @@ protected void onContentAspectRatioChanged(
     }
   }
 
+  // AdsLoader.AdViewProvider implementation.
+
+  @Override
+  public ViewGroup getAdViewGroup() {
+    return Assertions.checkNotNull(
+        adOverlayFrameLayout, "exo_ad_overlay must be present for ad playback");
+  }
+
+  @Override
+  public View[] getAdOverlayViews() {
+    ArrayList<View> overlayViews = new ArrayList<>();
+    if (overlayFrameLayout != null) {
+      overlayViews.add(overlayFrameLayout);
+    }
+    if (controller != null) {
+      overlayViews.add(controller);
+    }
+    return overlayViews.toArray(new View[0]);
+  }
+
+  // Internal methods.
+
   private boolean toggleControllerVisibility() {
     if (!useController || player == null) {
       return false;
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index 55745a7cb5..955fab14c9 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -15,17 +15,15 @@
  */
 package com.google.android.exoplayer2.ui;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 
 /** @deprecated Use {@link PlayerView}. */
 @Deprecated
-@TargetApi(16)
 public final class SimpleExoPlayerView extends PlayerView {
 
   public SimpleExoPlayerView(Context context) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 50a923bced..5d99eda109 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -19,7 +19,7 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Canvas;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.view.View;
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java
index 866921c2f9..d62f2494d5 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.ui;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.View;
 
 /**
@@ -84,6 +84,14 @@
    */
   void setDuration(long duration);
 
+  /**
+   * Returns the preferred delay in milliseconds of media time after which the time bar position
+   * should be updated.
+   *
+   * @return Preferred delay, in milliseconds of media time.
+   */
+  long getPreferredUpdateDelay();
+
   /**
    * Sets the times of ad groups and whether each ad group has been played.
    *
@@ -106,7 +114,7 @@ void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] play
      * Called when the user starts moving the scrubber.
      *
      * @param timeBar The time bar.
-     * @param position The position of the scrubber, in milliseconds.
+     * @param position The scrub position in milliseconds.
      */
     void onScrubStart(TimeBar timeBar, long position);
 
@@ -114,7 +122,7 @@ void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] play
      * Called when the user moves the scrubber.
      *
      * @param timeBar The time bar.
-     * @param position The position of the scrubber, in milliseconds.
+     * @param position The scrub position in milliseconds.
      */
     void onScrubMove(TimeBar timeBar, long position);
 
@@ -122,11 +130,10 @@ void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] play
      * Called when the user stops moving the scrubber.
      *
      * @param timeBar The time bar.
-     * @param position The position of the scrubber, in milliseconds.
+     * @param position The scrub position in milliseconds.
      * @param canceled Whether scrubbing was canceled.
      */
     void onScrubStop(TimeBar timeBar, long position, boolean canceled);
-
   }
 
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionDialogBuilder.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionDialogBuilder.java
new file mode 100644
index 0000000000..0df3fff5fe
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionDialogBuilder.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import androidx.annotation.Nullable;
+import android.view.LayoutInflater;
+import android.view.View;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
+import com.google.android.exoplayer2.trackselection.TrackSelectionUtil;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.Collections;
+import java.util.List;
+
+/** Builder for a dialog with a {@link TrackSelectionView}. */
+public final class TrackSelectionDialogBuilder {
+
+  /** Callback which is invoked when a track selection has been made. */
+  public interface DialogCallback {
+
+    /**
+     * Called when tracks are selected.
+     *
+     * @param isDisabled Whether the renderer is disabled.
+     * @param overrides List of selected track selection overrides for the renderer.
+     */
+    void onTracksSelected(boolean isDisabled, List<SelectionOverride> overrides);
+  }
+
+  private final Context context;
+  private final CharSequence title;
+  private final MappedTrackInfo mappedTrackInfo;
+  private final int rendererIndex;
+  private final DialogCallback callback;
+
+  private boolean allowAdaptiveSelections;
+  private boolean allowMultipleOverrides;
+  private boolean showDisableOption;
+  @Nullable private TrackNameProvider trackNameProvider;
+  private boolean isDisabled;
+  private List<SelectionOverride> overrides;
+
+  /**
+   * Creates a builder for a track selection dialog.
+   *
+   * @param context The context of the dialog.
+   * @param title The title of the dialog.
+   * @param mappedTrackInfo The {@link MappedTrackInfo} containing the track information.
+   * @param rendererIndex The renderer index in the {@code mappedTrackInfo} for which the track
+   *     selection is shown.
+   * @param callback The {@link DialogCallback} invoked when a track selection has been made.
+   */
+  public TrackSelectionDialogBuilder(
+      Context context,
+      CharSequence title,
+      MappedTrackInfo mappedTrackInfo,
+      int rendererIndex,
+      DialogCallback callback) {
+    this.context = context;
+    this.title = title;
+    this.mappedTrackInfo = mappedTrackInfo;
+    this.rendererIndex = rendererIndex;
+    this.callback = callback;
+    overrides = Collections.emptyList();
+  }
+
+  /**
+   * Creates a builder for a track selection dialog which automatically updates a {@link
+   * DefaultTrackSelector}.
+   *
+   * @param context The context of the dialog.
+   * @param title The title of the dialog.
+   * @param trackSelector A {@link DefaultTrackSelector} whose current selection is used to set up
+   *     the dialog and which is updated when new tracks are selected in the dialog.
+   * @param rendererIndex The renderer index in the {@code trackSelector} for which the track
+   *     selection is shown.
+   */
+  public TrackSelectionDialogBuilder(
+      Context context, CharSequence title, DefaultTrackSelector trackSelector, int rendererIndex) {
+    this.context = context;
+    this.title = title;
+    this.mappedTrackInfo = Assertions.checkNotNull(trackSelector.getCurrentMappedTrackInfo());
+    this.rendererIndex = rendererIndex;
+
+    TrackGroupArray rendererTrackGroups = mappedTrackInfo.getTrackGroups(rendererIndex);
+    DefaultTrackSelector.Parameters selectionParameters = trackSelector.getParameters();
+    isDisabled = selectionParameters.getRendererDisabled(rendererIndex);
+    SelectionOverride override =
+        selectionParameters.getSelectionOverride(rendererIndex, rendererTrackGroups);
+    overrides = override == null ? Collections.emptyList() : Collections.singletonList(override);
+
+    this.callback =
+        (newIsDisabled, newOverrides) ->
+            trackSelector.setParameters(
+                TrackSelectionUtil.updateParametersWithOverride(
+                    selectionParameters,
+                    rendererIndex,
+                    rendererTrackGroups,
+                    newIsDisabled,
+                    newOverrides.isEmpty() ? null : newOverrides.get(0)));
+  }
+
+  /**
+   * Sets whether the selection is initially shown as disabled.
+   *
+   * @param isDisabled Whether the selection is initially shown as disabled.
+   * @return This builder, for convenience.
+   */
+  public TrackSelectionDialogBuilder setIsDisabled(boolean isDisabled) {
+    this.isDisabled = isDisabled;
+    return this;
+  }
+
+  /**
+   * Sets the initial selection override to show.
+   *
+   * @param override The initial override to show, or null for no override.
+   * @return This builder, for convenience.
+   */
+  public TrackSelectionDialogBuilder setOverride(@Nullable SelectionOverride override) {
+    return setOverrides(
+        override == null ? Collections.emptyList() : Collections.singletonList(override));
+  }
+
+  /**
+   * Sets the list of initial selection overrides to show.
+   *
+   * <p>Note that only the first override will be used unless {@link
+   * #setAllowMultipleOverrides(boolean)} is set to {@code true}.
+   *
+   * @param overrides The list of initial overrides to show. There must be at most one override for
+   *     each track group.
+   * @return This builder, for convenience.
+   */
+  public TrackSelectionDialogBuilder setOverrides(List<SelectionOverride> overrides) {
+    this.overrides = overrides;
+    return this;
+  }
+
+  /**
+   * Sets whether adaptive selections (consisting of more than one track) can be made.
+   *
+   * <p>For the selection view to enable adaptive selection it is necessary both for this feature to
+   * be enabled, and for the target renderer to support adaptation between the available tracks.
+   *
+   * @param allowAdaptiveSelections Whether adaptive selection is enabled.
+   * @return This builder, for convenience.
+   */
+  public TrackSelectionDialogBuilder setAllowAdaptiveSelections(boolean allowAdaptiveSelections) {
+    this.allowAdaptiveSelections = allowAdaptiveSelections;
+    return this;
+  }
+
+  /**
+   * Sets whether multiple overrides can be set and selected, i.e. tracks from multiple track groups
+   * can be selected.
+   *
+   * @param allowMultipleOverrides Whether multiple track selection overrides are allowed.
+   * @return This builder, for convenience.
+   */
+  public TrackSelectionDialogBuilder setAllowMultipleOverrides(boolean allowMultipleOverrides) {
+    this.allowMultipleOverrides = allowMultipleOverrides;
+    return this;
+  }
+
+  /**
+   * Sets whether an option is available for disabling the renderer.
+   *
+   * @param showDisableOption Whether the disable option is shown.
+   * @return This builder, for convenience.
+   */
+  public TrackSelectionDialogBuilder setShowDisableOption(boolean showDisableOption) {
+    this.showDisableOption = showDisableOption;
+    return this;
+  }
+
+  /**
+   * Sets the {@link TrackNameProvider} used to generate the user visible name of each track and
+   * updates the view with track names queried from the specified provider.
+   *
+   * @param trackNameProvider The {@link TrackNameProvider} to use, or null to use the default.
+   */
+  public TrackSelectionDialogBuilder setTrackNameProvider(
+      @Nullable TrackNameProvider trackNameProvider) {
+    this.trackNameProvider = trackNameProvider;
+    return this;
+  }
+
+  /** Builds the dialog. */
+  public AlertDialog build() {
+    AlertDialog.Builder builder = new AlertDialog.Builder(context);
+
+    // Inflate with the builder's context to ensure the correct style is used.
+    LayoutInflater dialogInflater = LayoutInflater.from(builder.getContext());
+    View dialogView = dialogInflater.inflate(R.layout.exo_track_selection_dialog, /* root= */ null);
+
+    TrackSelectionView selectionView = dialogView.findViewById(R.id.exo_track_selection_view);
+    selectionView.setAllowMultipleOverrides(allowMultipleOverrides);
+    selectionView.setAllowAdaptiveSelections(allowAdaptiveSelections);
+    selectionView.setShowDisableOption(showDisableOption);
+    if (trackNameProvider != null) {
+      selectionView.setTrackNameProvider(trackNameProvider);
+    }
+    selectionView.init(mappedTrackInfo, rendererIndex, isDisabled, overrides, /* listener= */ null);
+    Dialog.OnClickListener okClickListener =
+        (dialog, which) ->
+            callback.onTracksSelected(selectionView.getIsDisabled(), selectionView.getOverrides());
+
+    return builder
+        .setTitle(title)
+        .setView(dialogView)
+        .setPositiveButton(android.R.string.ok, okClickListener)
+        .setNegativeButton(android.R.string.cancel, null)
+        .create();
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java
index 3f09ac2427..c55cf31149 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TrackSelectionView.java
@@ -15,15 +15,13 @@
  */
 package com.google.android.exoplayer2.ui;
 
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
 import android.content.Context;
 import android.content.res.TypedArray;
-import android.support.annotation.AttrRes;
-import android.support.annotation.Nullable;
+import androidx.annotation.AttrRes;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import android.util.Pair;
+import android.util.SparseArray;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.CheckedTextView;
@@ -33,76 +31,70 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.util.Assertions;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /** A view for making track selections. */
 public class TrackSelectionView extends LinearLayout {
 
+  /** Listener for changes to the selected tracks. */
+  public interface TrackSelectionListener {
+
+    /**
+     * Called when the selected tracks changed.
+     *
+     * @param isDisabled Whether the renderer is disabled.
+     * @param overrides List of selected track selection overrides for the renderer.
+     */
+    void onTrackSelectionChanged(boolean isDisabled, List<SelectionOverride> overrides);
+  }
+
   private final int selectableItemBackgroundResourceId;
   private final LayoutInflater inflater;
   private final CheckedTextView disableView;
   private final CheckedTextView defaultView;
   private final ComponentListener componentListener;
+  private final SparseArray<SelectionOverride> overrides;
 
   private boolean allowAdaptiveSelections;
+  private boolean allowMultipleOverrides;
 
   private TrackNameProvider trackNameProvider;
   private CheckedTextView[][] trackViews;
 
-  private DefaultTrackSelector trackSelector;
+  @MonotonicNonNull private MappedTrackInfo mappedTrackInfo;
   private int rendererIndex;
   private TrackGroupArray trackGroups;
   private boolean isDisabled;
-  private @Nullable SelectionOverride override;
-
-  /**
-   * Gets a pair consisting of a dialog and the {@link TrackSelectionView} that will be shown by it.
-   *
-   * @param activity The parent activity.
-   * @param title The dialog's title.
-   * @param trackSelector The track selector.
-   * @param rendererIndex The index of the renderer.
-   * @return The dialog and the {@link TrackSelectionView} that will be shown by it.
-   */
-  public static Pair<AlertDialog, TrackSelectionView> getDialog(
-      Activity activity,
-      CharSequence title,
-      DefaultTrackSelector trackSelector,
-      int rendererIndex) {
-    AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-
-    // Inflate with the builder's context to ensure the correct style is used.
-    LayoutInflater dialogInflater = LayoutInflater.from(builder.getContext());
-    View dialogView = dialogInflater.inflate(R.layout.exo_track_selection_dialog, null);
-
-    final TrackSelectionView selectionView = dialogView.findViewById(R.id.exo_track_selection_view);
-    selectionView.init(trackSelector, rendererIndex);
-    Dialog.OnClickListener okClickListener = (dialog, which) -> selectionView.applySelection();
-
-    AlertDialog dialog =
-        builder
-            .setTitle(title)
-            .setView(dialogView)
-            .setPositiveButton(android.R.string.ok, okClickListener)
-            .setNegativeButton(android.R.string.cancel, null)
-            .create();
-    return Pair.create(dialog, selectionView);
-  }
+  @Nullable private TrackSelectionListener listener;
 
+  /** Creates a track selection view. */
   public TrackSelectionView(Context context) {
     this(context, null);
   }
 
+  /** Creates a track selection view. */
   public TrackSelectionView(Context context, @Nullable AttributeSet attrs) {
     this(context, attrs, 0);
   }
 
+  /** Creates a track selection view. */
   @SuppressWarnings("nullness")
   public TrackSelectionView(
       Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) {
     super(context, attrs, defStyleAttr);
+    setOrientation(LinearLayout.VERTICAL);
+
+    overrides = new SparseArray<>();
+
+    // Don't save view hierarchy as it needs to be reinitialized with a call to init.
+    setSaveFromParentEnabled(false);
+
     TypedArray attributeArray =
         context
             .getTheme()
@@ -113,6 +105,7 @@ public TrackSelectionView(
     inflater = LayoutInflater.from(context);
     componentListener = new ComponentListener();
     trackNameProvider = new DefaultTrackNameProvider(getResources());
+    trackGroups = TrackGroupArray.EMPTY;
 
     // View for disabling the renderer.
     disableView =
@@ -155,6 +148,24 @@ public void setAllowAdaptiveSelections(boolean allowAdaptiveSelections) {
     }
   }
 
+  /**
+   * Sets whether tracks from multiple track groups can be selected. This results in multiple {@link
+   * SelectionOverride SelectionOverrides} to be returned by {@link #getOverrides()}.
+   *
+   * @param allowMultipleOverrides Whether multiple track selection overrides can be selected.
+   */
+  public void setAllowMultipleOverrides(boolean allowMultipleOverrides) {
+    if (this.allowMultipleOverrides != allowMultipleOverrides) {
+      this.allowMultipleOverrides = allowMultipleOverrides;
+      if (!allowMultipleOverrides && overrides.size() > 1) {
+        for (int i = overrides.size() - 1; i > 0; i--) {
+          overrides.remove(i);
+        }
+      }
+      updateViews();
+    }
+  }
+
   /**
    * Sets whether an option is available for disabling the renderer.
    *
@@ -176,18 +187,52 @@ public void setTrackNameProvider(TrackNameProvider trackNameProvider) {
   }
 
   /**
-   * Initialize the view to select tracks for a specified renderer using a {@link
-   * DefaultTrackSelector}.
+   * Initialize the view to select tracks for a specified renderer using {@link MappedTrackInfo} and
+   * a set of {@link DefaultTrackSelector.Parameters}.
    *
-   * @param trackSelector The {@link DefaultTrackSelector}.
+   * @param mappedTrackInfo The {@link MappedTrackInfo}.
    * @param rendererIndex The index of the renderer.
+   * @param isDisabled Whether the renderer should be initially shown as disabled.
+   * @param overrides List of initial overrides to be shown for this renderer. There must be at most
+   *     one override for each track group. If {@link #setAllowMultipleOverrides(boolean)} hasn't
+   *     been set to {@code true}, only the first override is used.
+   * @param listener An optional listener for track selection updates.
    */
-  public void init(DefaultTrackSelector trackSelector, int rendererIndex) {
-    this.trackSelector = trackSelector;
+  public void init(
+      MappedTrackInfo mappedTrackInfo,
+      int rendererIndex,
+      boolean isDisabled,
+      List<SelectionOverride> overrides,
+      @Nullable TrackSelectionListener listener) {
+    this.mappedTrackInfo = mappedTrackInfo;
     this.rendererIndex = rendererIndex;
+    this.isDisabled = isDisabled;
+    this.listener = listener;
+    int maxOverrides = allowMultipleOverrides ? overrides.size() : Math.min(overrides.size(), 1);
+    for (int i = 0; i < maxOverrides; i++) {
+      SelectionOverride override = overrides.get(i);
+      this.overrides.put(override.groupIndex, override);
+    }
     updateViews();
   }
 
+  /** Returns whether the renderer is disabled. */
+  public boolean getIsDisabled() {
+    return isDisabled;
+  }
+
+  /**
+   * Returns the list of selected track selection overrides. There will be at most one override for
+   * each track group.
+   */
+  public List<SelectionOverride> getOverrides() {
+    List<SelectionOverride> overrideList = new ArrayList<>(overrides.size());
+    for (int i = 0; i < overrides.size(); i++) {
+      overrideList.add(overrides.valueAt(i));
+    }
+    return overrideList;
+  }
+
   // Private methods.
 
   private void updateViews() {
@@ -196,9 +241,7 @@ private void updateViews() {
       removeViewAt(i);
     }
 
-    MappingTrackSelector.MappedTrackInfo trackInfo =
-        trackSelector == null ? null : trackSelector.getCurrentMappedTrackInfo();
-    if (trackSelector == null || trackInfo == null) {
+    if (mappedTrackInfo == null) {
       // The view is not initialized.
       disableView.setEnabled(false);
       defaultView.setEnabled(false);
@@ -207,35 +250,28 @@ private void updateViews() {
     disableView.setEnabled(true);
     defaultView.setEnabled(true);
 
-    trackGroups = trackInfo.getTrackGroups(rendererIndex);
-
-    DefaultTrackSelector.Parameters parameters = trackSelector.getParameters();
-    isDisabled = parameters.getRendererDisabled(rendererIndex);
-    override = parameters.getSelectionOverride(rendererIndex, trackGroups);
+    trackGroups = mappedTrackInfo.getTrackGroups(rendererIndex);
 
     // Add per-track views.
     trackViews = new CheckedTextView[trackGroups.length][];
+    boolean enableMultipleChoiceForMultipleOverrides = shouldEnableMultiGroupSelection();
     for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
       TrackGroup group = trackGroups.get(groupIndex);
-      boolean enableAdaptiveSelections =
-          allowAdaptiveSelections
-              && trackGroups.get(groupIndex).length > 1
-              && trackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false)
-                  != RendererCapabilities.ADAPTIVE_NOT_SUPPORTED;
+      boolean enableMultipleChoiceForAdaptiveSelections = shouldEnableAdaptiveSelection(groupIndex);
       trackViews[groupIndex] = new CheckedTextView[group.length];
       for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
         if (trackIndex == 0) {
           addView(inflater.inflate(R.layout.exo_list_divider, this, false));
         }
         int trackViewLayoutId =
-            enableAdaptiveSelections
+            enableMultipleChoiceForAdaptiveSelections || enableMultipleChoiceForMultipleOverrides
                 ? android.R.layout.simple_list_item_multiple_choice
                 : android.R.layout.simple_list_item_single_choice;
         CheckedTextView trackView =
             (CheckedTextView) inflater.inflate(trackViewLayoutId, this, false);
         trackView.setBackgroundResource(selectableItemBackgroundResourceId);
         trackView.setText(trackNameProvider.getTrackName(group.getFormat(trackIndex)));
-        if (trackInfo.getTrackSupport(rendererIndex, groupIndex, trackIndex)
+        if (mappedTrackInfo.getTrackSupport(rendererIndex, groupIndex, trackIndex)
             == RendererCapabilities.FORMAT_HANDLED) {
           trackView.setFocusable(true);
           trackView.setTag(Pair.create(groupIndex, trackIndex));
@@ -254,26 +290,15 @@ private void updateViews() {
 
   private void updateViewStates() {
     disableView.setChecked(isDisabled);
-    defaultView.setChecked(!isDisabled && override == null);
+    defaultView.setChecked(!isDisabled && overrides.size() == 0);
     for (int i = 0; i < trackViews.length; i++) {
+      SelectionOverride override = overrides.get(i);
       for (int j = 0; j < trackViews[i].length; j++) {
-        trackViews[i][j].setChecked(
-            override != null && override.groupIndex == i && override.containsTrack(j));
+        trackViews[i][j].setChecked(override != null && override.containsTrack(j));
       }
     }
   }
 
-  private void applySelection() {
-    DefaultTrackSelector.ParametersBuilder parametersBuilder = trackSelector.buildUponParameters();
-    parametersBuilder.setRendererDisabled(rendererIndex, isDisabled);
-    if (override != null) {
-      parametersBuilder.setSelectionOverride(rendererIndex, trackGroups, override);
-    } else {
-      parametersBuilder.clearSelectionOverrides(rendererIndex);
-    }
-    trackSelector.setParameters(parametersBuilder);
-  }
-
   private void onClick(View view) {
     if (view == disableView) {
       onDisableViewClicked();
@@ -283,16 +308,19 @@ private void onClick(View view) {
       onTrackViewClicked(view);
     }
     updateViewStates();
+    if (listener != null) {
+      listener.onTrackSelectionChanged(getIsDisabled(), getOverrides());
+    }
   }
 
   private void onDisableViewClicked() {
     isDisabled = true;
-    override = null;
+    overrides.clear();
   }
 
   private void onDefaultViewClicked() {
     isDisabled = false;
-    override = null;
+    overrides.clear();
   }
 
   private void onTrackViewClicked(View view) {
@@ -301,30 +329,56 @@ private void onTrackViewClicked(View view) {
     Pair<Integer, Integer> tag = (Pair<Integer, Integer>) view.getTag();
     int groupIndex = tag.first;
     int trackIndex = tag.second;
-    if (override == null || override.groupIndex != groupIndex || !allowAdaptiveSelections) {
-      // A new override is being started.
-      override = new SelectionOverride(groupIndex, trackIndex);
+    SelectionOverride override = overrides.get(groupIndex);
+    Assertions.checkNotNull(mappedTrackInfo);
+    if (override == null) {
+      // Start new override.
+      if (!allowMultipleOverrides && overrides.size() > 0) {
+        // Removed other overrides if we don't allow multiple overrides.
+        overrides.clear();
+      }
+      overrides.put(groupIndex, new SelectionOverride(groupIndex, trackIndex));
     } else {
       // An existing override is being modified.
       int overrideLength = override.length;
       int[] overrideTracks = override.tracks;
-      if (((CheckedTextView) view).isChecked()) {
+      boolean isCurrentlySelected = ((CheckedTextView) view).isChecked();
+      boolean isAdaptiveAllowed = shouldEnableAdaptiveSelection(groupIndex);
+      boolean isUsingCheckBox = isAdaptiveAllowed || shouldEnableMultiGroupSelection();
+      if (isCurrentlySelected && isUsingCheckBox) {
         // Remove the track from the override.
         if (overrideLength == 1) {
           // The last track is being removed, so the override becomes empty.
-          override = null;
-          isDisabled = true;
+          overrides.remove(groupIndex);
         } else {
           int[] tracks = getTracksRemoving(overrideTracks, trackIndex);
-          override = new SelectionOverride(groupIndex, tracks);
+          overrides.put(groupIndex, new SelectionOverride(groupIndex, tracks));
+        }
+      } else if (!isCurrentlySelected) {
+        if (isAdaptiveAllowed) {
+          // Add new track to adaptive override.
+          int[] tracks = getTracksAdding(overrideTracks, trackIndex);
+          overrides.put(groupIndex, new SelectionOverride(groupIndex, tracks));
+        } else {
+          // Replace existing track in override.
+          overrides.put(groupIndex, new SelectionOverride(groupIndex, trackIndex));
         }
-      } else {
-        int[] tracks = getTracksAdding(overrideTracks, trackIndex);
-        override = new SelectionOverride(groupIndex, tracks);
       }
     }
   }
 
+  @RequiresNonNull("mappedTrackInfo")
+  private boolean shouldEnableAdaptiveSelection(int groupIndex) {
+    return allowAdaptiveSelections
+        && trackGroups.get(groupIndex).length > 1
+        && mappedTrackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false)
+            != RendererCapabilities.ADAPTIVE_NOT_SUPPORTED;
+  }
+
+  private boolean shouldEnableMultiGroupSelection() {
+    return allowMultipleOverrides && trackGroups.length > 1;
+  }
+
   private static int[] getTracksAdding(int[] tracks, int addedTrack) {
     tracks = Arrays.copyOf(tracks, tracks.length + 1);
     tracks[tracks.length - 1] = addedTrack;
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/CanvasRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/CanvasRenderer.java
new file mode 100644
index 0000000000..3d7e57bbd2
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/CanvasRenderer.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.ui.spherical;
+
+import static com.google.android.exoplayer2.util.GlUtil.checkGlError;
+
+import android.graphics.Canvas;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.SurfaceTexture;
+import android.opengl.GLES11Ext;
+import android.opengl.GLES20;
+import androidx.annotation.Nullable;
+import android.view.Surface;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.GlUtil;
+import java.nio.FloatBuffer;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+/**
+ * Renders a canvas on a quad.
+ *
+ * <p>A CanvasRenderer can be created on any thread, but {@link #init()} needs to be called on the
+ * GL thread before it can be rendered.
+ */
+public final class CanvasRenderer {
+
+  private static final float WIDTH_UNIT = 0.8f;
+  private static final float DISTANCE_UNIT = 1f;
+  private static final float X_UNIT = -WIDTH_UNIT / 2;
+  private static final float Y_UNIT = -0.3f;
+
+  // Standard vertex shader that passes through the texture data.
+  private static final String[] VERTEX_SHADER_CODE = {
+    "uniform mat4 uMvpMatrix;",
+    // 3D position data.
+    "attribute vec3 aPosition;",
+    // 2D UV vertices.
+    "attribute vec2 aTexCoords;",
+    "varying vec2 vTexCoords;",
+
+    // Standard transformation.
+    "void main() {",
+    "  gl_Position = uMvpMatrix * vec4(aPosition, 1);",
+    "  vTexCoords = aTexCoords;",
+    "}"
+  };
+
+  private static final String[] FRAGMENT_SHADER_CODE = {
+    // This is required since the texture data is GL_TEXTURE_EXTERNAL_OES.
+    "#extension GL_OES_EGL_image_external : require",
+    "precision mediump float;",
+    "uniform samplerExternalOES uTexture;",
+    "varying vec2 vTexCoords;",
+    "void main() {",
+    "  gl_FragColor = texture2D(uTexture, vTexCoords);",
+    "}"
+  };
+
+  // The quad has 2 triangles built from 4 total vertices. Each vertex has 3 position and 2 texture
+  // coordinates.
+  private static final int POSITION_COORDS_PER_VERTEX = 3;
+  private static final int TEXTURE_COORDS_PER_VERTEX = 2;
+  private static final int COORDS_PER_VERTEX =
+      POSITION_COORDS_PER_VERTEX + TEXTURE_COORDS_PER_VERTEX;
+  private static final int VERTEX_STRIDE_BYTES = COORDS_PER_VERTEX * C.BYTES_PER_FLOAT;
+  private static final int VERTEX_COUNT = 4;
+  private static final float HALF_PI = (float) (Math.PI / 2);
+
+  private final FloatBuffer vertexBuffer;
+  private final AtomicBoolean surfaceDirty;
+
+  private int width;
+  private int height;
+  private float heightUnit;
+
+  // Program-related GL items. These are only valid if program != 0.
+  private int program = 0;
+  private int mvpMatrixHandle;
+  private int positionHandle;
+  private int textureCoordsHandle;
+  private int textureHandle;
+  private int textureId;
+
+  // Components used to manage the Canvas that the View is rendered to. These are only valid after
+  // GL initialization. The client of this class acquires a Canvas from the Surface, writes to it
+  // and posts it. This marks the Surface as dirty. The GL code then updates the SurfaceTexture
+  // when rendering only if it is dirty.
+  @MonotonicNonNull private SurfaceTexture displaySurfaceTexture;
+  @MonotonicNonNull private Surface displaySurface;
+
+  public CanvasRenderer() {
+    vertexBuffer = GlUtil.createBuffer(COORDS_PER_VERTEX * VERTEX_COUNT);
+    surfaceDirty = new AtomicBoolean();
+  }
+
+  public void setSize(int width, int height) {
+    this.width = width;
+    this.height = height;
+    heightUnit = WIDTH_UNIT * height / width;
+
+    float[] vertexData = new float[COORDS_PER_VERTEX * VERTEX_COUNT];
+    int vertexDataIndex = 0;
+    for (int y = 0; y < 2; y++) {
+      for (int x = 0; x < 2; x++) {
+        vertexData[vertexDataIndex++] = X_UNIT + (WIDTH_UNIT * x);
+        vertexData[vertexDataIndex++] = Y_UNIT + (heightUnit * y);
+        vertexData[vertexDataIndex++] = -DISTANCE_UNIT;
+        vertexData[vertexDataIndex++] = x;
+        vertexData[vertexDataIndex++] = 1 - y;
+      }
+    }
+    vertexBuffer.position(0);
+    vertexBuffer.put(vertexData);
+  }
+
+  /**
+   * Calls {@link Surface#lockCanvas(Rect)}.
+   *
+   * @return {@link Canvas} for the View to render to or {@code null} if {@link #init()} has not yet
+   *     been called.
+   */
+  @Nullable
+  public Canvas lockCanvas() {
+    return displaySurface == null ? null : displaySurface.lockCanvas(/* inOutDirty= */ null);
+  }
+
+  /**
+   * Calls {@link Surface#unlockCanvasAndPost(Canvas)} and marks the SurfaceTexture as dirty.
+   *
+   * @param canvas the canvas returned from {@link #lockCanvas()}
+   */
+  public void unlockCanvasAndPost(@Nullable Canvas canvas) {
+    if (canvas == null || displaySurface == null) {
+      // glInit() hasn't run yet.
+      return;
+    }
+    displaySurface.unlockCanvasAndPost(canvas);
+  }
+
+  /** Finishes constructing this object on the GL Thread. */
+  public void init() {
+    if (program != 0) {
+      return;
+    }
+
+    // Create the program.
+    program = GlUtil.compileProgram(VERTEX_SHADER_CODE, FRAGMENT_SHADER_CODE);
+    mvpMatrixHandle = GLES20.glGetUniformLocation(program, "uMvpMatrix");
+    positionHandle = GLES20.glGetAttribLocation(program, "aPosition");
+    textureCoordsHandle = GLES20.glGetAttribLocation(program, "aTexCoords");
+    textureHandle = GLES20.glGetUniformLocation(program, "uTexture");
+    textureId = GlUtil.createExternalTexture();
+    checkGlError();
+
+    // Create the underlying SurfaceTexture with the appropriate size.
+    displaySurfaceTexture = new SurfaceTexture(textureId);
+    displaySurfaceTexture.setOnFrameAvailableListener(surfaceTexture -> surfaceDirty.set(true));
+    displaySurfaceTexture.setDefaultBufferSize(width, height);
+    displaySurface = new Surface(displaySurfaceTexture);
+  }
+
+  /**
+   * Renders the quad.
+   *
+   * @param viewProjectionMatrix Array of floats containing the quad's 4x4 perspective matrix in the
+   *     {@link android.opengl.Matrix} format.
+   */
+  public void draw(float[] viewProjectionMatrix) {
+    if (displaySurfaceTexture == null) {
+      return;
+    }
+
+    GLES20.glUseProgram(program);
+    checkGlError();
+
+    GLES20.glEnableVertexAttribArray(positionHandle);
+    GLES20.glEnableVertexAttribArray(textureCoordsHandle);
+    checkGlError();
+
+    GLES20.glUniformMatrix4fv(mvpMatrixHandle, 1, false, viewProjectionMatrix, 0);
+    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId);
+    GLES20.glUniform1i(textureHandle, 0);
+    checkGlError();
+
+    // Load position data.
+    vertexBuffer.position(0);
+    GLES20.glVertexAttribPointer(
+        positionHandle,
+        POSITION_COORDS_PER_VERTEX,
+        GLES20.GL_FLOAT,
+        false,
+        VERTEX_STRIDE_BYTES,
+        vertexBuffer);
+    checkGlError();
+
+    // Load texture data.
+    vertexBuffer.position(POSITION_COORDS_PER_VERTEX);
+    GLES20.glVertexAttribPointer(
+        textureCoordsHandle,
+        TEXTURE_COORDS_PER_VERTEX,
+        GLES20.GL_FLOAT,
+        false,
+        VERTEX_STRIDE_BYTES,
+        vertexBuffer);
+    checkGlError();
+
+    if (surfaceDirty.compareAndSet(true, false)) {
+      // If the Surface has been written to, get the new data onto the SurfaceTexture.
+      displaySurfaceTexture.updateTexImage();
+    }
+
+    // Render.
+    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, VERTEX_COUNT);
+    checkGlError();
+
+    GLES20.glDisableVertexAttribArray(positionHandle);
+    GLES20.glDisableVertexAttribArray(textureCoordsHandle);
+  }
+
+  /** Frees GL resources. */
+  public void shutdown() {
+    if (program != 0) {
+      GLES20.glDeleteProgram(program);
+      GLES20.glDeleteTextures(1, new int[] {textureId}, 0);
+    }
+
+    if (displaySurfaceTexture != null) {
+      displaySurfaceTexture.release();
+    }
+    if (displaySurface != null) {
+      displaySurface.release();
+    }
+  }
+
+  /**
+   * Translates an orientation into pixel coordinates on the canvas.
+   *
+   * <p>This is a minimal hit detection system that works for this quad because it has no model
+   * matrix. All the math is based on the fact that its size and distance are hard-coded into this
+   * class. For a more complex 3D mesh, a general bounding box and ray collision system would be
+   * required.
+   *
+   * @param yaw Yaw of the orientation in radians.
+   * @param pitch Pitch of the orientation in radians.
+   * @return A {@link PointF} which contains the translated coordinate, or null if the point is
+   *     outside of the quad's bounds.
+   */
+  @Nullable
+  public PointF translateClick(float yaw, float pitch) {
+    return internalTranslateClick(
+        yaw, pitch, X_UNIT, Y_UNIT, WIDTH_UNIT, heightUnit, width, height);
+  }
+
+  @Nullable
+  /* package */ static PointF internalTranslateClick(
+      float yaw,
+      float pitch,
+      float xUnit,
+      float yUnit,
+      float widthUnit,
+      float heightUnit,
+      int widthPixel,
+      int heightPixel) {
+    if (yaw >= HALF_PI || yaw <= -HALF_PI || pitch >= HALF_PI || pitch <= -HALF_PI) {
+      return null;
+    }
+    double clickXUnit = Math.tan(yaw) * DISTANCE_UNIT - xUnit;
+    double clickYUnit = Math.tan(pitch) * DISTANCE_UNIT - yUnit;
+    if (clickXUnit < 0 || clickXUnit > widthUnit || clickYUnit < 0 || clickYUnit > heightUnit) {
+      return null;
+    }
+    // Convert from the polar coordinates of the controller to the rectangular coordinates of the
+    // View. Note the negative yaw and pitch used to generate Android-compliant x and y coordinates.
+    float clickXPixel = (float) (widthPixel - clickXUnit * widthPixel / widthUnit);
+    float clickYPixel = (float) (heightPixel - clickYUnit * heightPixel / heightUnit);
+    return new PointF(clickXPixel, clickYPixel);
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlViewGroup.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlViewGroup.java
new file mode 100644
index 0000000000..9ff6fcaf1f
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/GlViewGroup.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.ui.spherical;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.PointF;
+import android.graphics.PorterDuff;
+import android.os.SystemClock;
+import androidx.annotation.AnyThread;
+import androidx.annotation.UiThread;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import com.google.android.exoplayer2.util.Assertions;
+
+/** This View uses standard Android APIs to render its child Views to a texture. */
+public final class GlViewGroup extends FrameLayout {
+
+  private final CanvasRenderer canvasRenderer;
+
+  /**
+   * @param context The Context the view is running in, through which it can access the current
+   *     theme, resources, etc.
+   * @param layoutId ID for an XML layout resource to load (e.g., * <code>R.layout.main_page</code>)
+   */
+  public GlViewGroup(Context context, int layoutId) {
+    super(context);
+    this.canvasRenderer = new CanvasRenderer();
+
+    LayoutInflater.from(context).inflate(layoutId, this);
+
+    measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+    int width = getMeasuredWidth();
+    int height = getMeasuredHeight();
+    Assertions.checkState(width > 0 && height > 0);
+    canvasRenderer.setSize(width, height);
+    setLayoutParams(new FrameLayout.LayoutParams(width, height));
+  }
+
+  /** Returns whether the view is currently visible. */
+  @UiThread
+  public boolean isVisible() {
+    int childCount = getChildCount();
+    for (int i = 0; i < childCount; i++) {
+      if (getChildAt(i).getVisibility() == VISIBLE) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @Override
+  public void dispatchDraw(Canvas notUsed) {
+    Canvas glCanvas = canvasRenderer.lockCanvas();
+    if (glCanvas == null) {
+      // This happens if Android tries to draw this View before GL initialization completes. We need
+      // to retry until the draw call happens after GL invalidation.
+      postInvalidate();
+      return;
+    }
+
+    // Clear the canvas first.
+    glCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+    // Have Android render the child views.
+    super.dispatchDraw(glCanvas);
+    // Commit the changes.
+    canvasRenderer.unlockCanvasAndPost(glCanvas);
+  }
+
+  /**
+   * Simulates a click on the view.
+   *
+   * @param action Click action.
+   * @param yaw Yaw of the click's orientation in radians.
+   * @param pitch Pitch of the click's orientation in radians.
+   * @return Whether the click was simulated. If false then the view is not visible or the click was
+   *     outside of its bounds.
+   */
+  @UiThread
+  public boolean simulateClick(int action, float yaw, float pitch) {
+    if (!isVisible()) {
+      return false;
+    }
+    PointF point = canvasRenderer.translateClick(yaw, pitch);
+    if (point == null) {
+      return false;
+    }
+    long now = SystemClock.uptimeMillis();
+    MotionEvent event = MotionEvent.obtain(now, now, action, point.x, point.y, /* metaState= */ 1);
+    dispatchTouchEvent(event);
+    return true;
+  }
+
+  @AnyThread
+  public CanvasRenderer getRenderer() {
+    return canvasRenderer;
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/OrientationListener.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/OrientationListener.java
new file mode 100644
index 0000000000..80de418199
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/OrientationListener.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.opengl.Matrix;
+import androidx.annotation.BinderThread;
+import android.view.Display;
+import android.view.Surface;
+import com.google.android.exoplayer2.video.spherical.FrameRotationQueue;
+
+/**
+ * Listens for orientation sensor events, converts event data to rotation matrix and roll value, and
+ * notifies its own listeners.
+ */
+/* package */ final class OrientationListener implements SensorEventListener {
+  /** A listener for orientation changes. */
+  public interface Listener {
+    /**
+     * Called on device orientation change.
+     *
+     * @param deviceOrientationMatrix A 4x4 matrix defining device orientation.
+     * @param deviceRoll Device roll value, in radians. The range of values is -&pi;/2 to &pi;/2.
+     */
+    void onOrientationChange(float[] deviceOrientationMatrix, float deviceRoll);
+  }
+
+  private final float[] deviceOrientationMatrix4x4 = new float[16];
+  private final float[] tempMatrix4x4 = new float[16];
+  private final float[] recenterMatrix4x4 = new float[16];
+  private final float[] angles = new float[3];
+  private final Display display;
+  private final Listener[] listeners;
+  private boolean recenterMatrixComputed;
+
+  public OrientationListener(Display display, Listener... listeners) {
+    this.display = display;
+    this.listeners = listeners;
+  }
+
+  @Override
+  @BinderThread
+  public void onSensorChanged(SensorEvent event) {
+    SensorManager.getRotationMatrixFromVector(deviceOrientationMatrix4x4, event.values);
+    rotateAroundZ(deviceOrientationMatrix4x4, display.getRotation());
+    float roll = extractRoll(deviceOrientationMatrix4x4);
+    // Rotation vector sensor assumes Y is parallel to the ground.
+    rotateYtoSky(deviceOrientationMatrix4x4);
+    recenter(deviceOrientationMatrix4x4);
+    notifyListeners(deviceOrientationMatrix4x4, roll);
+  }
+
+  @Override
+  public void onAccuracyChanged(Sensor sensor, int accuracy) {
+    // Do nothing.
+  }
+
+  private void notifyListeners(float[] deviceOrientationMatrix, float roll) {
+    for (Listener listener : listeners) {
+      listener.onOrientationChange(deviceOrientationMatrix, roll);
+    }
+  }
+
+  private void recenter(float[] matrix) {
+    if (!recenterMatrixComputed) {
+      FrameRotationQueue.computeRecenterMatrix(recenterMatrix4x4, matrix);
+      recenterMatrixComputed = true;
+    }
+    System.arraycopy(matrix, 0, tempMatrix4x4, 0, tempMatrix4x4.length);
+    Matrix.multiplyMM(matrix, 0, tempMatrix4x4, 0, recenterMatrix4x4, 0);
+  }
+
+  private float extractRoll(float[] matrix) {
+    // Remapping is required since we need the calculated roll of the phone to be independent of the
+    // phone's pitch & yaw.
+    SensorManager.remapCoordinateSystem(
+        matrix, SensorManager.AXIS_X, SensorManager.AXIS_MINUS_Z, tempMatrix4x4);
+    SensorManager.getOrientation(tempMatrix4x4, angles);
+    return angles[2];
+  }
+
+  private void rotateAroundZ(float[] matrix, int rotation) {
+    int xAxis;
+    int yAxis;
+    switch (rotation) {
+      case Surface.ROTATION_270:
+        xAxis = SensorManager.AXIS_MINUS_Y;
+        yAxis = SensorManager.AXIS_X;
+        break;
+      case Surface.ROTATION_180:
+        xAxis = SensorManager.AXIS_MINUS_X;
+        yAxis = SensorManager.AXIS_MINUS_Y;
+        break;
+      case Surface.ROTATION_90:
+        xAxis = SensorManager.AXIS_Y;
+        yAxis = SensorManager.AXIS_MINUS_X;
+        break;
+      case Surface.ROTATION_0:
+        return;
+      default:
+        throw new IllegalStateException();
+    }
+    System.arraycopy(matrix, 0, tempMatrix4x4, 0, tempMatrix4x4.length);
+    SensorManager.remapCoordinateSystem(tempMatrix4x4, xAxis, yAxis, matrix);
+  }
+
+  private static void rotateYtoSky(float[] matrix) {
+    Matrix.rotateM(matrix, 0, 90, 1, 0, 0);
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/PointerRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/PointerRenderer.java
new file mode 100644
index 0000000000..fa7118a0fb
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/PointerRenderer.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.ui.spherical;
+
+import static com.google.android.exoplayer2.util.GlUtil.checkGlError;
+
+import android.opengl.GLES20;
+import android.opengl.Matrix;
+import com.google.android.exoplayer2.util.GlUtil;
+import java.nio.FloatBuffer;
+
+/** Renders a pointer. */
+public final class PointerRenderer {
+  // The pointer quad is 2 * SIZE units.
+  private static final float SIZE = .01f;
+  private static final float DISTANCE = 1;
+
+  // Standard vertex shader.
+  private static final String[] VERTEX_SHADER_CODE =
+      new String[] {
+        "uniform mat4 uMvpMatrix;",
+        "attribute vec3 aPosition;",
+        "varying vec2 vCoords;",
+
+        // Pass through normalized vertex coordinates.
+        "void main() {",
+        "  gl_Position = uMvpMatrix * vec4(aPosition, 1);",
+        "  vCoords = aPosition.xy / vec2(" + SIZE + ", " + SIZE + ");",
+        "}"
+      };
+
+  // Procedurally render a ring on the quad between the specified radii.
+  private static final String[] FRAGMENT_SHADER_CODE =
+      new String[] {
+        "precision mediump float;",
+        "varying vec2 vCoords;",
+
+        // Simple ring shader that is white between the radii and transparent elsewhere.
+        "void main() {",
+        "  float r = length(vCoords);",
+        // Blend the edges of the ring at .55 +/- .05 and .85 +/- .05.
+        "  float alpha = smoothstep(0.5, 0.6, r) * (1.0 - smoothstep(0.8, 0.9, r));",
+        "  if (alpha == 0.0) {",
+        "    discard;",
+        "  } else {",
+        "    gl_FragColor = vec4(alpha);",
+        "  }",
+        "}"
+      };
+
+  // Simple quad mesh.
+  private static final int COORDS_PER_VERTEX = 3;
+  private static final float[] VERTEX_DATA = {
+    -SIZE, -SIZE, -DISTANCE, SIZE, -SIZE, -DISTANCE, -SIZE, SIZE, -DISTANCE, SIZE, SIZE, -DISTANCE,
+  };
+  private final FloatBuffer vertexBuffer;
+
+  // The pointer doesn't have a real modelMatrix. Its distance is baked into the mesh and it
+  // uses a rotation matrix when rendered.
+  private final float[] modelViewProjectionMatrix;
+  // This is accessed on the binder & GL Threads.
+  private final float[] controllerOrientationMatrix;
+
+  // Program-related GL items. These are only valid if program != 0.
+  private int program = 0;
+  private int mvpMatrixHandle;
+  private int positionHandle;
+
+  public PointerRenderer() {
+    vertexBuffer = GlUtil.createBuffer(VERTEX_DATA);
+    modelViewProjectionMatrix = new float[16];
+    controllerOrientationMatrix = new float[16];
+    Matrix.setIdentityM(controllerOrientationMatrix, 0);
+  }
+
+  /** Finishes initialization of this object on the GL thread. */
+  public void init() {
+    if (program != 0) {
+      return;
+    }
+
+    program = GlUtil.compileProgram(VERTEX_SHADER_CODE, FRAGMENT_SHADER_CODE);
+    mvpMatrixHandle = GLES20.glGetUniformLocation(program, "uMvpMatrix");
+    positionHandle = GLES20.glGetAttribLocation(program, "aPosition");
+    checkGlError();
+  }
+
+  /**
+   * Renders the pointer.
+   *
+   * @param viewProjectionMatrix Scene's view projection matrix.
+   */
+  public void draw(float[] viewProjectionMatrix) {
+    // Configure shader.
+    GLES20.glUseProgram(program);
+    checkGlError();
+
+    synchronized (controllerOrientationMatrix) {
+      Matrix.multiplyMM(
+          modelViewProjectionMatrix, 0, viewProjectionMatrix, 0, controllerOrientationMatrix, 0);
+    }
+    GLES20.glUniformMatrix4fv(mvpMatrixHandle, 1, false, modelViewProjectionMatrix, 0);
+    checkGlError();
+
+    // Render quad.
+    GLES20.glEnableVertexAttribArray(positionHandle);
+    checkGlError();
+
+    GLES20.glVertexAttribPointer(
+        positionHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, /* stride= */ 0, vertexBuffer);
+    checkGlError();
+
+    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, VERTEX_DATA.length / COORDS_PER_VERTEX);
+    checkGlError();
+
+    GLES20.glDisableVertexAttribArray(positionHandle);
+  }
+
+  /** Frees GL resources. */
+  public void shutdown() {
+    if (program != 0) {
+      GLES20.glDeleteProgram(program);
+    }
+  }
+
+  /** Updates the pointer's position with the latest Controller pose. */
+  public void setControllerOrientation(float[] rotationMatrix) {
+    synchronized (controllerOrientationMatrix) {
+      System.arraycopy(rotationMatrix, 0, controllerOrientationMatrix, 0, rotationMatrix.length);
+    }
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java
index a52a25d085..f24bcce3ce 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/ProjectionRenderer.java
@@ -15,12 +15,12 @@
  */
 package com.google.android.exoplayer2.ui.spherical;
 
-import static com.google.android.exoplayer2.ui.spherical.GlUtil.checkGlError;
+import static com.google.android.exoplayer2.util.GlUtil.checkGlError;
 
-import android.annotation.TargetApi;
 import android.opengl.GLES11Ext;
 import android.opengl.GLES20;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.GlUtil;
 import com.google.android.exoplayer2.video.spherical.Projection;
 import java.nio.FloatBuffer;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -29,20 +29,7 @@
  * Utility class to render spherical meshes for video or images. Call {@link #init()} on the GL
  * thread when ready.
  */
-@TargetApi(15)
-/*package*/ final class ProjectionRenderer {
-
-  /** Defines the constants identifying the current eye type. */
-  /*package*/ interface EyeType {
-    /** Single eye in monocular rendering. */
-    int MONOCULAR = 0;
-
-    /** The left eye in stereo rendering. */
-    int LEFT = 1;
-
-    /** The right eye in stereo rendering. */
-    int RIGHT = 2;
-  }
+/* package */ final class ProjectionRenderer {
 
   /**
    * Returns whether {@code projection} is supported. At least it should have left mesh and there
@@ -147,10 +134,11 @@ public void setProjection(Projection projection) {
    *
    * @param textureId GL_TEXTURE_EXTERNAL_OES used for this mesh.
    * @param mvpMatrix The Model View Projection matrix.
-   * @param eyeType An {@link EyeType} value.
+   * @param rightEye Whether the right eye view should be drawn. If {@code false}, the left eye view
+   *     is drawn.
    */
-  /* package */ void draw(int textureId, float[] mvpMatrix, int eyeType) {
-    MeshData meshData = eyeType == EyeType.RIGHT ? rightMeshData : leftMeshData;
+  /* package */ void draw(int textureId, float[] mvpMatrix, boolean rightEye) {
+    MeshData meshData = rightEye ? rightMeshData : leftMeshData;
     if (meshData == null) {
       return;
     }
@@ -165,9 +153,9 @@ public void setProjection(Projection projection) {
 
     float[] texMatrix;
     if (stereoMode == C.STEREO_MODE_TOP_BOTTOM) {
-      texMatrix = eyeType == EyeType.RIGHT ? TEX_MATRIX_BOTTOM : TEX_MATRIX_TOP;
+      texMatrix = rightEye ? TEX_MATRIX_BOTTOM : TEX_MATRIX_TOP;
     } else if (stereoMode == C.STEREO_MODE_LEFT_RIGHT) {
-      texMatrix = eyeType == EyeType.RIGHT ? TEX_MATRIX_RIGHT : TEX_MATRIX_LEFT;
+      texMatrix = rightEye ? TEX_MATRIX_RIGHT : TEX_MATRIX_LEFT;
     } else {
       texMatrix = TEX_MATRIX_WHOLE;
     }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
index a8d4abcf07..2889351f19 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
@@ -15,16 +15,16 @@
  */
 package com.google.android.exoplayer2.ui.spherical;
 
-import static com.google.android.exoplayer2.ui.spherical.GlUtil.checkGlError;
+import static com.google.android.exoplayer2.util.GlUtil.checkGlError;
 
 import android.graphics.SurfaceTexture;
 import android.opengl.GLES20;
 import android.opengl.Matrix;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.ui.spherical.ProjectionRenderer.EyeType;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.GlUtil;
 import com.google.android.exoplayer2.util.TimedValueQueue;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
@@ -36,7 +36,7 @@
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /** Renders a GL Scene. */
-/*package*/ class SceneRenderer implements VideoFrameMetadataListener, CameraMotionListener {
+public final class SceneRenderer implements VideoFrameMetadataListener, CameraMotionListener {
 
   private final AtomicBoolean frameAvailable;
   private final AtomicBoolean resetRotationAtNextFrame;
@@ -102,9 +102,10 @@ public SurfaceTexture init() {
    * Draws the scene with a given eye pose and type.
    *
    * @param viewProjectionMatrix 16 element GL matrix.
-   * @param eyeType An {@link EyeType} value
+   * @param rightEye Whether the right eye view should be drawn. If {@code false}, the left eye view
+   *     is drawn.
    */
-  public void drawFrame(float[] viewProjectionMatrix, int eyeType) {
+  public void drawFrame(float[] viewProjectionMatrix, boolean rightEye) {
     // glClear isn't strictly necessary when rendering fully spherical panoramas, but it can improve
     // performance on tiled renderers by causing the GPU to discard previous data.
     GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
@@ -127,7 +128,12 @@ public void drawFrame(float[] viewProjectionMatrix, int eyeType) {
       }
     }
     Matrix.multiplyMM(tempMatrix, 0, viewProjectionMatrix, 0, rotationMatrix, 0);
-    projectionRenderer.draw(textureId, tempMatrix, eyeType);
+    projectionRenderer.draw(textureId, tempMatrix, rightEye);
+  }
+
+  /** Cleans up the GL resources. */
+  public void shutdown() {
+    projectionRenderer.shutdown();
   }
 
   // Methods called on playback thread.
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
index 7b58f54ac2..1029a28323 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
@@ -15,30 +15,27 @@
  */
 package com.google.android.exoplayer2.ui.spherical;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.PointF;
 import android.graphics.SurfaceTexture;
 import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
 import android.hardware.SensorManager;
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
 import android.opengl.Matrix;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.AnyThread;
-import android.support.annotation.BinderThread;
-import android.support.annotation.Nullable;
-import android.support.annotation.UiThread;
+import androidx.annotation.AnyThread;
+import androidx.annotation.BinderThread;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.annotation.VisibleForTesting;
 import android.util.AttributeSet;
 import android.view.Display;
 import android.view.Surface;
 import android.view.WindowManager;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.ui.spherical.ProjectionRenderer.EyeType;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import javax.microedition.khronos.egl.EGLConfig;
@@ -54,7 +51,6 @@
  * apply the touch and sensor rotations in the correct order or the user's touch manipulations won't
  * match what they expect.
  */
-@TargetApi(15)
 public final class SphericalSurfaceView extends GLSurfaceView {
 
   /**
@@ -79,11 +75,11 @@
   // TODO Calculate this depending on surface size and field of view.
   private static final float PX_PER_DEGREES = 25;
 
-  /*package*/ static final float UPRIGHT_ROLL = (float) Math.PI;
+  /* package */ static final float UPRIGHT_ROLL = (float) Math.PI;
 
   private final SensorManager sensorManager;
   private final @Nullable Sensor orientationSensor;
-  private final PhoneOrientationListener phoneOrientationListener;
+  private final OrientationListener orientationListener;
   private final Renderer renderer;
   private final Handler mainHandler;
   private final TouchTracker touchTracker;
@@ -123,7 +119,7 @@ public SphericalSurfaceView(Context context, @Nullable AttributeSet attributeSet
     touchTracker = new TouchTracker(context, renderer, PX_PER_DEGREES);
     WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
     Display display = Assertions.checkNotNull(windowManager).getDefaultDisplay();
-    phoneOrientationListener = new PhoneOrientationListener(display, touchTracker, renderer);
+    orientationListener = new OrientationListener(display, touchTracker, renderer);
 
     setEGLContextClientVersion(2);
     setRenderer(renderer);
@@ -179,14 +175,14 @@ public void onResume() {
     super.onResume();
     if (orientationSensor != null) {
       sensorManager.registerListener(
-          phoneOrientationListener, orientationSensor, SensorManager.SENSOR_DELAY_FASTEST);
+          orientationListener, orientationSensor, SensorManager.SENSOR_DELAY_FASTEST);
     }
   }
 
   @Override
   public void onPause() {
     if (orientationSensor != null) {
-      sensorManager.unregisterListener(phoneOrientationListener);
+      sensorManager.unregisterListener(orientationListener);
     }
     super.onPause();
   }
@@ -235,82 +231,13 @@ private static void releaseSurface(
     }
   }
 
-  /** Detects sensor events and saves them as a matrix. */
-  private static class PhoneOrientationListener implements SensorEventListener {
-    private final float[] phoneInWorldSpaceMatrix = new float[16];
-    private final float[] remappedPhoneMatrix = new float[16];
-    private final float[] angles = new float[3];
-    private final Display display;
-    private final TouchTracker touchTracker;
-    private final Renderer renderer;
-
-    public PhoneOrientationListener(Display display, TouchTracker touchTracker, Renderer renderer) {
-      this.display = display;
-      this.touchTracker = touchTracker;
-      this.renderer = renderer;
-    }
-
-    @Override
-    @BinderThread
-    public void onSensorChanged(SensorEvent event) {
-      SensorManager.getRotationMatrixFromVector(remappedPhoneMatrix, event.values);
-
-      // If we're not in upright portrait mode, remap the axes of the coordinate system according to
-      // the display rotation.
-      int xAxis;
-      int yAxis;
-      switch (display.getRotation()) {
-        case Surface.ROTATION_270:
-          xAxis = SensorManager.AXIS_MINUS_Y;
-          yAxis = SensorManager.AXIS_X;
-          break;
-        case Surface.ROTATION_180:
-          xAxis = SensorManager.AXIS_MINUS_X;
-          yAxis = SensorManager.AXIS_MINUS_Y;
-          break;
-        case Surface.ROTATION_90:
-          xAxis = SensorManager.AXIS_Y;
-          yAxis = SensorManager.AXIS_MINUS_X;
-          break;
-        case Surface.ROTATION_0:
-        default:
-          xAxis = SensorManager.AXIS_X;
-          yAxis = SensorManager.AXIS_Y;
-          break;
-      }
-      SensorManager.remapCoordinateSystem(
-          remappedPhoneMatrix, xAxis, yAxis, phoneInWorldSpaceMatrix);
-
-      // Extract the phone's roll and pass it on to touchTracker & renderer. Remapping is required
-      // since we need the calculated roll of the phone to be independent of the phone's pitch &
-      // yaw. Any operation that decomposes rotation to Euler angles needs to be performed
-      // carefully.
-      SensorManager.remapCoordinateSystem(
-          phoneInWorldSpaceMatrix,
-          SensorManager.AXIS_X,
-          SensorManager.AXIS_MINUS_Z,
-          remappedPhoneMatrix);
-      SensorManager.getOrientation(remappedPhoneMatrix, angles);
-      float roll = angles[2];
-      touchTracker.setRoll(roll);
-
-      // Rotate from Android coordinates to OpenGL coordinates. Android's coordinate system
-      // assumes Y points North and Z points to the sky. OpenGL has Y pointing up and Z pointing
-      // toward the user.
-      Matrix.rotateM(phoneInWorldSpaceMatrix, 0, 90, 1, 0, 0);
-      renderer.setDeviceOrientation(phoneInWorldSpaceMatrix, roll);
-    }
-
-    @Override
-    public void onAccuracyChanged(Sensor sensor, int accuracy) {}
-  }
-
   /**
    * Standard GL Renderer implementation. The notable code is the matrix multiplication in
    * onDrawFrame and updatePitchMatrix.
    */
-  // @VisibleForTesting
-  /*package*/ class Renderer implements GLSurfaceView.Renderer, TouchTracker.Listener {
+  @VisibleForTesting
+  /* package */ class Renderer
+      implements GLSurfaceView.Renderer, TouchTracker.Listener, OrientationListener.Listener {
     private final SceneRenderer scene;
     private final float[] projectionMatrix = new float[16];
 
@@ -364,12 +291,13 @@ public void onDrawFrame(GL10 gl) {
       }
 
       Matrix.multiplyMM(viewProjectionMatrix, 0, projectionMatrix, 0, viewMatrix, 0);
-      scene.drawFrame(viewProjectionMatrix, EyeType.MONOCULAR);
+      scene.drawFrame(viewProjectionMatrix, /* rightEye= */ false);
     }
 
     /** Adjusts the GL camera's rotation based on device rotation. Runs on the sensor thread. */
+    @Override
     @BinderThread
-    public synchronized void setDeviceOrientation(float[] matrix, float deviceRoll) {
+    public synchronized void onOrientationChange(float[] matrix, float deviceRoll) {
       System.arraycopy(matrix, 0, deviceOrientationMatrix, 0, deviceOrientationMatrix.length);
       this.deviceRoll = -deviceRoll;
       updatePitchMatrix();
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
index c0373c9ca1..142f2fc668 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
@@ -17,8 +17,8 @@
 
 import android.content.Context;
 import android.graphics.PointF;
-import android.support.annotation.BinderThread;
-import android.support.annotation.Nullable;
+import androidx.annotation.BinderThread;
+import androidx.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
@@ -45,7 +45,7 @@
  * Mesh as the user moves their finger. However, that requires quaternion interpolation.
  */
 /* package */ class TouchTracker extends GestureDetector.SimpleOnGestureListener
-    implements View.OnTouchListener {
+    implements View.OnTouchListener, OrientationListener.Listener {
 
   /* package */ interface Listener {
     void onScrollChange(PointF scrollOffsetDegrees);
@@ -53,7 +53,7 @@
 
   // Touch input won't change the pitch beyond +/- 45 degrees. This reduces awkward situations
   // where the touch-based pitch and gyro-based pitch interact badly near the poles.
-  /*package*/ static final float MAX_PITCH_DEGREES = 45;
+  /* package */ static final float MAX_PITCH_DEGREES = 45;
 
   // With every touch event, update the accumulated degrees offset by the new pixel amount.
   private final PointF previousTouchPointPx = new PointF();
@@ -131,8 +131,9 @@ public boolean onSingleTapUp(MotionEvent e) {
     return false;
   }
 
+  @Override
   @BinderThread
-  public void setRoll(float roll) {
+  public void onOrientationChange(float[] deviceOrientationMatrix, float roll) {
     // We compensate for roll by rotating in the opposite direction.
     this.roll = -roll;
   }
diff --git a/library/ui/src/main/res/drawable-hdpi/exo_icon_vr.png b/library/ui/src/main/res/drawable-hdpi/exo_icon_vr.png
new file mode 100644
index 0000000000..90948eb44f
Binary files /dev/null and b/library/ui/src/main/res/drawable-hdpi/exo_icon_vr.png differ
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_icon_vr.png b/library/ui/src/main/res/drawable-ldpi/exo_icon_vr.png
new file mode 100644
index 0000000000..6e21960ed6
Binary files /dev/null and b/library/ui/src/main/res/drawable-ldpi/exo_icon_vr.png differ
diff --git a/library/ui/src/main/res/drawable-mdpi/exo_icon_vr.png b/library/ui/src/main/res/drawable-mdpi/exo_icon_vr.png
new file mode 100644
index 0000000000..02063a79a9
Binary files /dev/null and b/library/ui/src/main/res/drawable-mdpi/exo_icon_vr.png differ
diff --git a/library/ui/src/main/res/drawable-xhdpi/exo_icon_vr.png b/library/ui/src/main/res/drawable-xhdpi/exo_icon_vr.png
new file mode 100644
index 0000000000..ff243ef56a
Binary files /dev/null and b/library/ui/src/main/res/drawable-xhdpi/exo_icon_vr.png differ
diff --git a/library/ui/src/main/res/drawable-xxhdpi/exo_icon_vr.png b/library/ui/src/main/res/drawable-xxhdpi/exo_icon_vr.png
new file mode 100644
index 0000000000..7c0338842d
Binary files /dev/null and b/library/ui/src/main/res/drawable-xxhdpi/exo_icon_vr.png differ
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index 534655f2f4..ed2fb8e2b2 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -54,6 +54,9 @@
     <ImageButton android:id="@id/exo_next"
       style="@style/ExoMediaButton.Next"/>
 
+    <ImageButton android:id="@id/exo_vr"
+      style="@style/ExoMediaButton.VR"/>
+
   </LinearLayout>
 
   <LinearLayout
diff --git a/library/ui/src/main/res/layout/exo_simple_player_view.xml b/library/ui/src/main/res/layout/exo_simple_player_view.xml
index 167ac96222..65dea9271e 100644
--- a/library/ui/src/main/res/layout/exo_simple_player_view.xml
+++ b/library/ui/src/main/res/layout/exo_simple_player_view.xml
@@ -52,6 +52,10 @@
 
   </com.google.android.exoplayer2.ui.AspectRatioFrameLayout>
 
+  <FrameLayout android:id="@id/exo_ad_overlay"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"/>
+
   <FrameLayout android:id="@id/exo_overlay"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
diff --git a/library/ui/src/main/res/layout/exo_track_selection_dialog.xml b/library/ui/src/main/res/layout/exo_track_selection_dialog.xml
index 2ad8e2ea9b..07f59c3a59 100644
--- a/library/ui/src/main/res/layout/exo_track_selection_dialog.xml
+++ b/library/ui/src/main/res/layout/exo_track_selection_dialog.xml
@@ -18,7 +18,6 @@
     android:layout_height="match_parent">
 
   <com.google.android.exoplayer2.ui.TrackSelectionView android:id="@+id/exo_track_selection_view"
-      android:orientation="vertical"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"/>
 
diff --git a/library/ui/src/main/res/values-af/strings.xml b/library/ui/src/main/res/values-af/strings.xml
index 4d525836a0..8a983c543a 100644
--- a/library/ui/src/main/res/values-af/strings.xml
+++ b/library/ui/src/main/res/values-af/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Herhaal alles</string>
   <string name="exo_controls_shuffle_description">Skommel</string>
   <string name="exo_controls_fullscreen_description">Volskermmodus</string>
+  <string name="exo_controls_vr_description">VR-modus</string>
   <string name="exo_download_description">Aflaai</string>
   <string name="exo_download_notification_channel_name">Aflaaie</string>
   <string name="exo_download_downloading">Laai tans af</string>
@@ -20,7 +21,7 @@
   <string name="exo_download_removing">Verwyder tans aflaaie</string>
   <string name="exo_track_selection_title_video">Video</string>
   <string name="exo_track_selection_title_audio">Oudio</string>
-  <string name="exo_track_selection_title_text">SMS</string>
+  <string name="exo_track_selection_title_text">Teks</string>
   <string name="exo_track_selection_none">Geen</string>
   <string name="exo_track_selection_auto">Outo</string>
   <string name="exo_track_unknown">Onbekend</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Omringklank</string>
   <string name="exo_track_surround_5_point_1">5.1-omringklank</string>
   <string name="exo_track_surround_7_point_1">7.1-omringklank</string>
+  <string name="exo_track_role_alternate">Afwisselend</string>
+  <string name="exo_track_role_supplementary">Aanvullend</string>
+  <string name="exo_track_role_commentary">Kommentaar</string>
+  <string name="exo_track_role_closed_captions">Onderskrifte</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-am/strings.xml b/library/ui/src/main/res/values-am/strings.xml
index 08c7a3180a..f56a6c06bf 100644
--- a/library/ui/src/main/res/values-am/strings.xml
+++ b/library/ui/src/main/res/values-am/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">ሁሉንም ድገም</string>
   <string name="exo_controls_shuffle_description">በውዝ</string>
   <string name="exo_controls_fullscreen_description">የሙሉ ማያ ሁነታ</string>
+  <string name="exo_controls_vr_description">የቪአር ሁነታ</string>
   <string name="exo_download_description">አውርድ</string>
   <string name="exo_download_notification_channel_name">የወረዱ</string>
   <string name="exo_download_downloading">በማውረድ ላይ</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">የዙሪያ ድምፅ</string>
   <string name="exo_track_surround_5_point_1">5.1 የዙሪያ ድምፅ</string>
   <string name="exo_track_surround_7_point_1">7.1 የዙሪያ ድምፅ</string>
+  <string name="exo_track_role_alternate">ተለዋጭ</string>
+  <string name="exo_track_role_supplementary">ተጨማሪ</string>
+  <string name="exo_track_role_commentary">ጥናታዊ</string>
+  <string name="exo_track_role_closed_captions">የተዘጉ የመግለጫ ጽሑፎች</string>
   <string name="exo_track_bitrate">%1$.2f ሜብስ</string>
   <string name="exo_item_list">%1$s፣ %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ar/strings.xml b/library/ui/src/main/res/values-ar/strings.xml
index f79a1cf5db..91063e1a54 100644
--- a/library/ui/src/main/res/values-ar/strings.xml
+++ b/library/ui/src/main/res/values-ar/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">تكرار الكل</string>
   <string name="exo_controls_shuffle_description">ترتيب عشوائي</string>
   <string name="exo_controls_fullscreen_description">وضع ملء الشاشة</string>
+  <string name="exo_controls_vr_description">وضع VR</string>
   <string name="exo_download_description">تنزيل</string>
   <string name="exo_download_notification_channel_name">التنزيلات</string>
   <string name="exo_download_downloading">جارٍ التنزيل.</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">صوت مجسّم</string>
   <string name="exo_track_surround_5_point_1">صوت مجسّم 5.1</string>
   <string name="exo_track_surround_7_point_1">صوت مجسّم 7.1</string>
+  <string name="exo_track_role_alternate">بديل</string>
+  <string name="exo_track_role_supplementary">تكميلي</string>
+  <string name="exo_track_role_commentary">التعليقات</string>
+  <string name="exo_track_role_closed_captions">الترجمة والشرح</string>
   <string name="exo_track_bitrate">%1$.2f ميغابت في الثانية</string>
   <string name="exo_item_list">%1$s، %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-az/strings.xml b/library/ui/src/main/res/values-az/strings.xml
index 4191095b4d..0f5fbe3f4d 100644
--- a/library/ui/src/main/res/values-az/strings.xml
+++ b/library/ui/src/main/res/values-az/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Hamısı təkrarlansın</string>
   <string name="exo_controls_shuffle_description">Qarışdırın</string>
   <string name="exo_controls_fullscreen_description">Tam ekran rejimi</string>
+  <string name="exo_controls_vr_description">VR rejimi</string>
   <string name="exo_download_description">Endirin</string>
   <string name="exo_download_notification_channel_name">Endirmələr</string>
   <string name="exo_download_downloading">Endirilir</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Yüksək səs</string>
   <string name="exo_track_surround_5_point_1">5.1 yüksək səs</string>
   <string name="exo_track_surround_7_point_1">7.1 yüksək səs</string>
+  <string name="exo_track_role_alternate">Alternativ</string>
+  <string name="exo_track_role_supplementary">Əlavə</string>
+  <string name="exo_track_role_commentary">Şərh</string>
+  <string name="exo_track_role_closed_captions">Nüsxəni alan</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-b+sr+Latn/strings.xml b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
index 6acedb205f..16300747f7 100644
--- a/library/ui/src/main/res/values-b+sr+Latn/strings.xml
+++ b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ponovi sve</string>
   <string name="exo_controls_shuffle_description">Pusti nasumično</string>
   <string name="exo_controls_fullscreen_description">Režim celog ekrana</string>
+  <string name="exo_controls_vr_description">VR režim</string>
   <string name="exo_download_description">Preuzmi</string>
   <string name="exo_download_notification_channel_name">Preuzimanja</string>
   <string name="exo_download_downloading">Preuzima se</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Zvučni sistem</string>
   <string name="exo_track_surround_5_point_1">Zvučni sistem 5.1</string>
   <string name="exo_track_surround_7_point_1">Zvučni sistem 7.1</string>
+  <string name="exo_track_role_alternate">Alternativno</string>
+  <string name="exo_track_role_supplementary">Dodatno</string>
+  <string name="exo_track_role_commentary">Komentar</string>
+  <string name="exo_track_role_closed_captions">Titl</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-be/strings.xml b/library/ui/src/main/res/values-be/strings.xml
index 63704e66ca..6a33be2a8f 100644
--- a/library/ui/src/main/res/values-be/strings.xml
+++ b/library/ui/src/main/res/values-be/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Паўтарыць усе</string>
   <string name="exo_controls_shuffle_description">Перамяшаць</string>
   <string name="exo_controls_fullscreen_description">Поўнаэкранны рэжым</string>
+  <string name="exo_controls_vr_description">VR-рэжым</string>
   <string name="exo_download_description">Спампаваць</string>
   <string name="exo_download_notification_channel_name">Спампоўкі</string>
   <string name="exo_download_downloading">Спампоўваецца</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Аб\'ёмны гук</string>
   <string name="exo_track_surround_5_point_1">Аб\'ёмны гук 5.1</string>
   <string name="exo_track_surround_7_point_1">Аб\'ёмны гук 7.1</string>
+  <string name="exo_track_role_alternate">Альтэрнатыўны запіс</string>
+  <string name="exo_track_role_supplementary">Дадатковы запіс</string>
+  <string name="exo_track_role_commentary">Каментарыі</string>
+  <string name="exo_track_role_closed_captions">Цітры</string>
   <string name="exo_track_bitrate">%1$.2f Мбіт/с</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bg/strings.xml b/library/ui/src/main/res/values-bg/strings.xml
index 74bc85313d..511a5e4f19 100644
--- a/library/ui/src/main/res/values-bg/strings.xml
+++ b/library/ui/src/main/res/values-bg/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Повтаряне на всички</string>
   <string name="exo_controls_shuffle_description">Разбъркване</string>
   <string name="exo_controls_fullscreen_description">Режим на цял екран</string>
+  <string name="exo_controls_vr_description">режим за VR</string>
   <string name="exo_download_description">Изтегляне</string>
   <string name="exo_download_notification_channel_name">Изтегляния</string>
   <string name="exo_download_downloading">Изтегля се</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Обемен звук</string>
   <string name="exo_track_surround_5_point_1">5,1-канален обемен звук</string>
   <string name="exo_track_surround_7_point_1">7,1-канален обемен звук</string>
+  <string name="exo_track_role_alternate">Алтернативен запис</string>
+  <string name="exo_track_role_supplementary">Допълнителен запис</string>
+  <string name="exo_track_role_commentary">Коментар</string>
+  <string name="exo_track_role_closed_captions">Субтитри</string>
   <string name="exo_track_bitrate">%1$.2f Мб/сек</string>
   <string name="exo_item_list">%1$s – %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bn/strings.xml b/library/ui/src/main/res/values-bn/strings.xml
index 4e3b00113f..cca445feca 100644
--- a/library/ui/src/main/res/values-bn/strings.xml
+++ b/library/ui/src/main/res/values-bn/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">সবগুলি আইটেম আবার চালান</string>
   <string name="exo_controls_shuffle_description">শাফেল করুন</string>
   <string name="exo_controls_fullscreen_description">পূর্ণ স্ক্রিন মোড</string>
+  <string name="exo_controls_vr_description">ভিআর মোড</string>
   <string name="exo_download_description">ডাউনলোড করুন</string>
   <string name="exo_download_notification_channel_name">ডাউনলোড</string>
   <string name="exo_download_downloading">ডাউনলোড হচ্ছে</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">সারাউন্ড সাউন্ড</string>
   <string name="exo_track_surround_5_point_1">5.1 সারাউন্ড সাউন্ড</string>
   <string name="exo_track_surround_7_point_1">7.1 সারাউন্ড সাউন্ড</string>
+  <string name="exo_track_role_alternate">বিকল্প</string>
+  <string name="exo_track_role_supplementary">অতিরিক্ত</string>
+  <string name="exo_track_role_commentary">ধারাভাষ্য</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f এমবিপিএস</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bs/strings.xml b/library/ui/src/main/res/values-bs/strings.xml
index be2f6459f5..24fb7b2b3b 100644
--- a/library/ui/src/main/res/values-bs/strings.xml
+++ b/library/ui/src/main/res/values-bs/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ponovi sve</string>
   <string name="exo_controls_shuffle_description">Izmiješaj</string>
   <string name="exo_controls_fullscreen_description">Način rada preko cijelog ekrana</string>
+  <string name="exo_controls_vr_description">VR način rada</string>
   <string name="exo_download_description">Preuzmi</string>
   <string name="exo_download_notification_channel_name">Preuzimanja</string>
   <string name="exo_download_downloading">Preuzimanje</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Prostorno ozvučenje</string>
   <string name="exo_track_surround_5_point_1">Prostorno ozvučenje 5.1</string>
   <string name="exo_track_surround_7_point_1">Prostorno ozvučenje 7.1</string>
+  <string name="exo_track_role_alternate">Alternativni zapis</string>
+  <string name="exo_track_role_supplementary">Dodatni zapis</string>
+  <string name="exo_track_role_commentary">Komentari</string>
+  <string name="exo_track_role_closed_captions">Titlovi</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ca/strings.xml b/library/ui/src/main/res/values-ca/strings.xml
index 10bf259418..3b48eab3b8 100644
--- a/library/ui/src/main/res/values-ca/strings.xml
+++ b/library/ui/src/main/res/values-ca/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repeteix tot</string>
   <string name="exo_controls_shuffle_description">Reprodueix aleatòriament</string>
   <string name="exo_controls_fullscreen_description">Mode de pantalla completa</string>
+  <string name="exo_controls_vr_description">Mode RV</string>
   <string name="exo_download_description">Baixa</string>
   <string name="exo_download_notification_channel_name">Baixades</string>
   <string name="exo_download_downloading">S\'està baixant</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">So envoltant</string>
   <string name="exo_track_surround_5_point_1">So envoltant 5.1</string>
   <string name="exo_track_surround_7_point_1">So envoltant 7.1</string>
+  <string name="exo_track_role_alternate">Alternativa</string>
+  <string name="exo_track_role_supplementary">Complementària</string>
+  <string name="exo_track_role_commentary">Comentaris</string>
+  <string name="exo_track_role_closed_captions">Subtítols</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-cs/strings.xml b/library/ui/src/main/res/values-cs/strings.xml
index c910fd3483..1568074f9f 100644
--- a/library/ui/src/main/res/values-cs/strings.xml
+++ b/library/ui/src/main/res/values-cs/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Opakovat vše</string>
   <string name="exo_controls_shuffle_description">Náhodně</string>
   <string name="exo_controls_fullscreen_description">Režim celé obrazovky</string>
+  <string name="exo_controls_vr_description">Režim VR</string>
   <string name="exo_download_description">Stáhnout</string>
   <string name="exo_download_notification_channel_name">Stahování</string>
   <string name="exo_download_downloading">Stahování</string>
@@ -20,7 +21,7 @@
   <string name="exo_download_removing">Odstraňování staženého obsahu</string>
   <string name="exo_track_selection_title_video">Videa</string>
   <string name="exo_track_selection_title_audio">Zvuk</string>
-  <string name="exo_track_selection_title_text">SMS</string>
+  <string name="exo_track_selection_title_text">Text</string>
   <string name="exo_track_selection_none">Žádné</string>
   <string name="exo_track_selection_auto">Automaticky</string>
   <string name="exo_track_unknown">Neznámé</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Prostorový zvuk</string>
   <string name="exo_track_surround_5_point_1">Prostorový zvuk 5.1</string>
   <string name="exo_track_surround_7_point_1">Prostorový zvuk 7.1</string>
+  <string name="exo_track_role_alternate">Alternativní</string>
+  <string name="exo_track_role_supplementary">Dodatkové</string>
+  <string name="exo_track_role_commentary">Komentář</string>
+  <string name="exo_track_role_closed_captions">Titulky</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-da/strings.xml b/library/ui/src/main/res/values-da/strings.xml
index 6a25bbf395..19b0f09446 100644
--- a/library/ui/src/main/res/values-da/strings.xml
+++ b/library/ui/src/main/res/values-da/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Gentag alle</string>
   <string name="exo_controls_shuffle_description">Bland</string>
   <string name="exo_controls_fullscreen_description">Fuld skærm</string>
+  <string name="exo_controls_vr_description">VR-tilstand</string>
   <string name="exo_download_description">Download</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Downloader</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surroundsound</string>
   <string name="exo_track_surround_5_point_1">5.1 surround sound</string>
   <string name="exo_track_surround_7_point_1">7.1 surroundsound</string>
+  <string name="exo_track_role_alternate">Alternativt spor</string>
+  <string name="exo_track_role_supplementary">Supplerende spor</string>
+  <string name="exo_track_role_commentary">Kommentarspor</string>
+  <string name="exo_track_role_closed_captions">Undertekster</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-de/strings.xml b/library/ui/src/main/res/values-de/strings.xml
index 6ac92acf9d..1bb620dd2b 100644
--- a/library/ui/src/main/res/values-de/strings.xml
+++ b/library/ui/src/main/res/values-de/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Alle wiederholen</string>
   <string name="exo_controls_shuffle_description">Zufallsmix</string>
   <string name="exo_controls_fullscreen_description">Vollbildmodus</string>
+  <string name="exo_controls_vr_description">VR-Modus</string>
   <string name="exo_download_description">Herunterladen</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Wird heruntergeladen</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround-Sound</string>
   <string name="exo_track_surround_5_point_1">5.1-Surround-Sound</string>
   <string name="exo_track_surround_7_point_1">7.1-Surround-Sound</string>
+  <string name="exo_track_role_alternate">Alternativer Track</string>
+  <string name="exo_track_role_supplementary">Zusatzinhalte</string>
+  <string name="exo_track_role_commentary">Kommentare</string>
+  <string name="exo_track_role_closed_captions">Untertitel</string>
   <string name="exo_track_bitrate">%1$.2f Mbit/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-el/strings.xml b/library/ui/src/main/res/values-el/strings.xml
index 699650d31e..1ddbe4a5fa 100644
--- a/library/ui/src/main/res/values-el/strings.xml
+++ b/library/ui/src/main/res/values-el/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Επανάληψη όλων</string>
   <string name="exo_controls_shuffle_description">Τυχαία αναπαραγωγή</string>
   <string name="exo_controls_fullscreen_description">Λειτουργία πλήρους οθόνης</string>
+  <string name="exo_controls_vr_description">Λειτουργία VR mode</string>
   <string name="exo_download_description">Λήψη</string>
   <string name="exo_download_notification_channel_name">Λήψεις</string>
   <string name="exo_download_downloading">Λήψη</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Περιφερειακός ήχος</string>
   <string name="exo_track_surround_5_point_1">Περιφερειακός ήχος 5.1</string>
   <string name="exo_track_surround_7_point_1">Περιφερειακός ήχος 7.1</string>
+  <string name="exo_track_role_alternate">Εναλλακτικό</string>
+  <string name="exo_track_role_supplementary">Συμπληρωματικό</string>
+  <string name="exo_track_role_commentary">Σχολιασμός</string>
+  <string name="exo_track_role_closed_captions">Υπότιτλοι</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rAU/strings.xml b/library/ui/src/main/res/values-en-rAU/strings.xml
index 2356f0cd94..cf25e2ada0 100644
--- a/library/ui/src/main/res/values-en-rAU/strings.xml
+++ b/library/ui/src/main/res/values-en-rAU/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repeat all</string>
   <string name="exo_controls_shuffle_description">Shuffle</string>
   <string name="exo_controls_fullscreen_description">Full-screen mode</string>
+  <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">Download</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Downloading</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround sound</string>
   <string name="exo_track_surround_5_point_1">5.1 surround sound</string>
   <string name="exo_track_surround_7_point_1">7.1 surround sound</string>
+  <string name="exo_track_role_alternate">Alternative</string>
+  <string name="exo_track_role_supplementary">Supplementary</string>
+  <string name="exo_track_role_commentary">Commentary</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rGB/strings.xml b/library/ui/src/main/res/values-en-rGB/strings.xml
index 2356f0cd94..cf25e2ada0 100644
--- a/library/ui/src/main/res/values-en-rGB/strings.xml
+++ b/library/ui/src/main/res/values-en-rGB/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repeat all</string>
   <string name="exo_controls_shuffle_description">Shuffle</string>
   <string name="exo_controls_fullscreen_description">Full-screen mode</string>
+  <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">Download</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Downloading</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround sound</string>
   <string name="exo_track_surround_5_point_1">5.1 surround sound</string>
   <string name="exo_track_surround_7_point_1">7.1 surround sound</string>
+  <string name="exo_track_role_alternate">Alternative</string>
+  <string name="exo_track_role_supplementary">Supplementary</string>
+  <string name="exo_track_role_commentary">Commentary</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rIN/strings.xml b/library/ui/src/main/res/values-en-rIN/strings.xml
index 2356f0cd94..cf25e2ada0 100644
--- a/library/ui/src/main/res/values-en-rIN/strings.xml
+++ b/library/ui/src/main/res/values-en-rIN/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repeat all</string>
   <string name="exo_controls_shuffle_description">Shuffle</string>
   <string name="exo_controls_fullscreen_description">Full-screen mode</string>
+  <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">Download</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Downloading</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround sound</string>
   <string name="exo_track_surround_5_point_1">5.1 surround sound</string>
   <string name="exo_track_surround_7_point_1">7.1 surround sound</string>
+  <string name="exo_track_role_alternate">Alternative</string>
+  <string name="exo_track_role_supplementary">Supplementary</string>
+  <string name="exo_track_role_commentary">Commentary</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-es-rUS/strings.xml b/library/ui/src/main/res/values-es-rUS/strings.xml
index b7d8facf17..ceeb0b8497 100644
--- a/library/ui/src/main/res/values-es-rUS/strings.xml
+++ b/library/ui/src/main/res/values-es-rUS/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repetir todo</string>
   <string name="exo_controls_shuffle_description">Reproducir aleatoriamente</string>
   <string name="exo_controls_fullscreen_description">Modo de pantalla completa</string>
+  <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Descargar</string>
   <string name="exo_download_notification_channel_name">Descargas</string>
   <string name="exo_download_downloading">Descargando</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Sonido envolvente</string>
   <string name="exo_track_surround_5_point_1">Sonido envolvente 5.1</string>
   <string name="exo_track_surround_7_point_1">Sonido envolvente 7.1</string>
+  <string name="exo_track_role_alternate">Alternativa</string>
+  <string name="exo_track_role_supplementary">Complementaria</string>
+  <string name="exo_track_role_commentary">Comentarios</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-es/strings.xml b/library/ui/src/main/res/values-es/strings.xml
index 7a48245abb..0118da57be 100644
--- a/library/ui/src/main/res/values-es/strings.xml
+++ b/library/ui/src/main/res/values-es/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repetir todo</string>
   <string name="exo_controls_shuffle_description">Reproducir aleatoriamente</string>
   <string name="exo_controls_fullscreen_description">Modo de pantalla completa</string>
+  <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Descargar</string>
   <string name="exo_download_notification_channel_name">Descargas</string>
   <string name="exo_download_downloading">Descargando</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Sonido envolvente</string>
   <string name="exo_track_surround_5_point_1">Sonido envolvente 5.1</string>
   <string name="exo_track_surround_7_point_1">Sonido envolvente 7.1</string>
+  <string name="exo_track_role_alternate">Alternativa</string>
+  <string name="exo_track_role_supplementary">Complementaria</string>
+  <string name="exo_track_role_commentary">Comentarios</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-et/strings.xml b/library/ui/src/main/res/values-et/strings.xml
index 0ed5389da7..99ca9548ed 100644
--- a/library/ui/src/main/res/values-et/strings.xml
+++ b/library/ui/src/main/res/values-et/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Korda kõiki</string>
   <string name="exo_controls_shuffle_description">Esita juhuslikus järjekorras</string>
   <string name="exo_controls_fullscreen_description">Täisekraani režiim</string>
+  <string name="exo_controls_vr_description">VR-režiim</string>
   <string name="exo_download_description">Allalaadimine</string>
   <string name="exo_download_notification_channel_name">Allalaadimised</string>
   <string name="exo_download_downloading">Allalaadimine</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Ruumiline heli</string>
   <string name="exo_track_surround_5_point_1">Ruumiline heli 5.1</string>
   <string name="exo_track_surround_7_point_1">Ruumiline heli 7.1</string>
+  <string name="exo_track_role_alternate">Alternatiiv</string>
+  <string name="exo_track_role_supplementary">Lisalugu</string>
+  <string name="exo_track_role_commentary">Kommentaar</string>
+  <string name="exo_track_role_closed_captions">Subtiitrid</string>
   <string name="exo_track_bitrate">%1$.2f Mbit/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-eu/strings.xml b/library/ui/src/main/res/values-eu/strings.xml
index 31ec286cfb..4d992fee0f 100644
--- a/library/ui/src/main/res/values-eu/strings.xml
+++ b/library/ui/src/main/res/values-eu/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Errepikatu guztiak</string>
   <string name="exo_controls_shuffle_description">Erreproduzitu ausaz</string>
   <string name="exo_controls_fullscreen_description">Pantaila osoko modua</string>
+  <string name="exo_controls_vr_description">EB modua</string>
   <string name="exo_download_description">Deskargak</string>
   <string name="exo_download_notification_channel_name">Deskargak</string>
   <string name="exo_download_downloading">Deskargatzen</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Soinu inguratzailea</string>
   <string name="exo_track_surround_5_point_1">5.1 soinu inguratzailea</string>
   <string name="exo_track_surround_7_point_1">7.1 soinu inguratzailea</string>
+  <string name="exo_track_role_alternate">Ordezkoa</string>
+  <string name="exo_track_role_supplementary">Osagarria</string>
+  <string name="exo_track_role_commentary">Iruzkinak</string>
+  <string name="exo_track_role_closed_captions">Azpitituluak</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fa/strings.xml b/library/ui/src/main/res/values-fa/strings.xml
index 9b0853cee5..fed94b5569 100644
--- a/library/ui/src/main/res/values-fa/strings.xml
+++ b/library/ui/src/main/res/values-fa/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">تکرار همه</string>
   <string name="exo_controls_shuffle_description">درهم</string>
   <string name="exo_controls_fullscreen_description">حالت تمام‌صفحه</string>
+  <string name="exo_controls_vr_description">حالت واقعیت مجازی</string>
   <string name="exo_download_description">بارگیری</string>
   <string name="exo_download_notification_channel_name">بارگیری‌ها</string>
   <string name="exo_download_downloading">درحال بارگیری</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">صدای فراگیر</string>
   <string name="exo_track_surround_5_point_1">صدای فراگیر ۵.۱</string>
   <string name="exo_track_surround_7_point_1">صدای فراگیر ۷٫۱</string>
+  <string name="exo_track_role_alternate">بدیل</string>
+  <string name="exo_track_role_supplementary">تکمیلی</string>
+  <string name="exo_track_role_commentary">شرح و نقد</string>
+  <string name="exo_track_role_closed_captions">زیرنویس ناشنوایان</string>
   <string name="exo_track_bitrate">%1$.2f مگابیت در ثانیه</string>
   <string name="exo_item_list">%1$s،‏ %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fi/strings.xml b/library/ui/src/main/res/values-fi/strings.xml
index d9b33f0977..0dc2f9d346 100644
--- a/library/ui/src/main/res/values-fi/strings.xml
+++ b/library/ui/src/main/res/values-fi/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Toista kaikki uudelleen</string>
   <string name="exo_controls_shuffle_description">Satunnaistoisto</string>
   <string name="exo_controls_fullscreen_description">Koko näytön tila</string>
+  <string name="exo_controls_vr_description">VR-tila</string>
   <string name="exo_download_description">Lataa</string>
   <string name="exo_download_notification_channel_name">Lataukset</string>
   <string name="exo_download_downloading">Ladataan</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround-ääni</string>
   <string name="exo_track_surround_5_point_1">5.1-surround-ääni</string>
   <string name="exo_track_surround_7_point_1">7.1-surround-ääni</string>
+  <string name="exo_track_role_alternate">Vaihtoehtoinen</string>
+  <string name="exo_track_role_supplementary">Lisämateriaali</string>
+  <string name="exo_track_role_commentary">Kommenttiraita</string>
+  <string name="exo_track_role_closed_captions">Tekstitykset</string>
   <string name="exo_track_bitrate">%1$.2f Mt/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fr-rCA/strings.xml b/library/ui/src/main/res/values-fr-rCA/strings.xml
index b68fab04ed..0f3534924f 100644
--- a/library/ui/src/main/res/values-fr-rCA/strings.xml
+++ b/library/ui/src/main/res/values-fr-rCA/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Tout lire en boucle</string>
   <string name="exo_controls_shuffle_description">Lecture aléatoire</string>
   <string name="exo_controls_fullscreen_description">Mode Plein écran</string>
+  <string name="exo_controls_vr_description">Mode RV</string>
   <string name="exo_download_description">Télécharger</string>
   <string name="exo_download_notification_channel_name">Téléchargements</string>
   <string name="exo_download_downloading">Téléchargement en cours…</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Son ambiophonique</string>
   <string name="exo_track_surround_5_point_1">Son ambiophonique 5.1</string>
   <string name="exo_track_surround_7_point_1">Son ambiophonique 7.1</string>
+  <string name="exo_track_role_alternate">Autre version</string>
+  <string name="exo_track_role_supplementary">Supplémentaire</string>
+  <string name="exo_track_role_commentary">Commentaires</string>
+  <string name="exo_track_role_closed_captions">Sous-titres codés</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fr/strings.xml b/library/ui/src/main/res/values-fr/strings.xml
index 48c19e30d9..46c07f531e 100644
--- a/library/ui/src/main/res/values-fr/strings.xml
+++ b/library/ui/src/main/res/values-fr/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Tout lire en boucle</string>
   <string name="exo_controls_shuffle_description">Aléatoire</string>
   <string name="exo_controls_fullscreen_description">Mode plein écran</string>
+  <string name="exo_controls_vr_description">Mode RV</string>
   <string name="exo_download_description">Télécharger</string>
   <string name="exo_download_notification_channel_name">Téléchargements</string>
   <string name="exo_download_downloading">Téléchargement…</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Son surround</string>
   <string name="exo_track_surround_5_point_1">Son surround 5.1</string>
   <string name="exo_track_surround_7_point_1">Son surround 7.1</string>
+  <string name="exo_track_role_alternate">Piste alternative</string>
+  <string name="exo_track_role_supplementary">Piste supplémentaire</string>
+  <string name="exo_track_role_commentary">Commentaires</string>
+  <string name="exo_track_role_closed_captions">Sous-titres</string>
   <string name="exo_track_bitrate">%1$.2f Mbit/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-gl/strings.xml b/library/ui/src/main/res/values-gl/strings.xml
index e41b1d1445..e6689353f1 100644
--- a/library/ui/src/main/res/values-gl/strings.xml
+++ b/library/ui/src/main/res/values-gl/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repetir todas as pistas</string>
   <string name="exo_controls_shuffle_description">Reprodución aleatoria</string>
   <string name="exo_controls_fullscreen_description">Modo de pantalla completa</string>
+  <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Descargar</string>
   <string name="exo_download_notification_channel_name">Descargas</string>
   <string name="exo_download_downloading">Descargando</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Son envolvente</string>
   <string name="exo_track_surround_5_point_1">Son envolvente 5.1</string>
   <string name="exo_track_surround_7_point_1">Son envolvente 7.1</string>
+  <string name="exo_track_role_alternate">Alternativa</string>
+  <string name="exo_track_role_supplementary">Complementaria</string>
+  <string name="exo_track_role_commentary">Comentarios</string>
+  <string name="exo_track_role_closed_captions">Subtítulos</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-gu/strings.xml b/library/ui/src/main/res/values-gu/strings.xml
index 5d8dd31cc5..488eb39f6a 100644
--- a/library/ui/src/main/res/values-gu/strings.xml
+++ b/library/ui/src/main/res/values-gu/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">બધાને રિપીટ કરો</string>
   <string name="exo_controls_shuffle_description">શફલ કરો</string>
   <string name="exo_controls_fullscreen_description">પૂર્ણસ્ક્રીન મોડ</string>
+  <string name="exo_controls_vr_description">VR મોડ</string>
   <string name="exo_download_description">ડાઉનલોડ કરો</string>
   <string name="exo_download_notification_channel_name">ડાઉનલોડ</string>
   <string name="exo_download_downloading">ડાઉનલોડ કરી રહ્યાં છીએ</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">સરાઉન્ડ સાઉન્ડ</string>
   <string name="exo_track_surround_5_point_1">5.1 સરાઉન્ડ સાઉન્ડ</string>
   <string name="exo_track_surround_7_point_1">7.1 સરાઉન્ડ સાઉન્ડ</string>
+  <string name="exo_track_role_alternate">વૈકલ્પિક</string>
+  <string name="exo_track_role_supplementary">પૂરક</string>
+  <string name="exo_track_role_commentary">કોમેન્ટ્રી</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hi/strings.xml b/library/ui/src/main/res/values-hi/strings.xml
index 9df542ef52..8ba92054ff 100644
--- a/library/ui/src/main/res/values-hi/strings.xml
+++ b/library/ui/src/main/res/values-hi/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">सभी को दोहराएं</string>
   <string name="exo_controls_shuffle_description">शफ़ल करें</string>
   <string name="exo_controls_fullscreen_description">फ़ुलस्क्रीन मोड</string>
+  <string name="exo_controls_vr_description">VR मोड</string>
   <string name="exo_download_description">डाउनलोड करें</string>
   <string name="exo_download_notification_channel_name">डाउनलोड की गई मीडिया फ़ाइलें</string>
   <string name="exo_download_downloading">डाउनलोड हो रहा है</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">सराउंड साउंड</string>
   <string name="exo_track_surround_5_point_1">5.1 सराउंड साउंड</string>
   <string name="exo_track_surround_7_point_1">7.1 सराउंड साउंड</string>
+  <string name="exo_track_role_alternate">विकल्प</string>
+  <string name="exo_track_role_supplementary">सप्लिमेंट्री</string>
+  <string name="exo_track_role_commentary">कमेंट्री</string>
+  <string name="exo_track_role_closed_captions">सबटाइटल</string>
   <string name="exo_track_bitrate">%1$.2f एमबीपीएस</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hr/strings.xml b/library/ui/src/main/res/values-hr/strings.xml
index 7d5de9b189..4fa1942986 100644
--- a/library/ui/src/main/res/values-hr/strings.xml
+++ b/library/ui/src/main/res/values-hr/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ponovi sve</string>
   <string name="exo_controls_shuffle_description">Reproduciraj nasumično</string>
   <string name="exo_controls_fullscreen_description">Prikaz na cijelom zaslonu</string>
+  <string name="exo_controls_vr_description">VR način</string>
   <string name="exo_download_description">Preuzmi</string>
   <string name="exo_download_notification_channel_name">Preuzimanja</string>
   <string name="exo_download_downloading">Preuzimanje</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Okružujući zvuk</string>
   <string name="exo_track_surround_5_point_1">5.1-kanalni okružujući zvuk</string>
   <string name="exo_track_surround_7_point_1">7.1-kanalni okružujući zvuk</string>
+  <string name="exo_track_role_alternate">Alternativna verzija</string>
+  <string name="exo_track_role_supplementary">Dopunska verzija</string>
+  <string name="exo_track_role_commentary">Verzija s komentarima</string>
+  <string name="exo_track_role_closed_captions">Verzija s titlovima</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hu/strings.xml b/library/ui/src/main/res/values-hu/strings.xml
index bb7d5950e6..baf77650e0 100644
--- a/library/ui/src/main/res/values-hu/strings.xml
+++ b/library/ui/src/main/res/values-hu/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Összes szám ismétlése</string>
   <string name="exo_controls_shuffle_description">Keverés</string>
   <string name="exo_controls_fullscreen_description">Teljes képernyős mód</string>
+  <string name="exo_controls_vr_description">VR-mód</string>
   <string name="exo_download_description">Letöltés</string>
   <string name="exo_download_notification_channel_name">Letöltések</string>
   <string name="exo_download_downloading">Letöltés folyamatban</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Térhatású hangzás</string>
   <string name="exo_track_surround_5_point_1">5.1-es térhatású hangzás</string>
   <string name="exo_track_surround_7_point_1">7.1-es térhatású hangzás</string>
+  <string name="exo_track_role_alternate">Alternatív</string>
+  <string name="exo_track_role_supplementary">Kiegészítő</string>
+  <string name="exo_track_role_commentary">Kommentár</string>
+  <string name="exo_track_role_closed_captions">Felirat</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hy/strings.xml b/library/ui/src/main/res/values-hy/strings.xml
index 38468b892d..04a2aeb140 100644
--- a/library/ui/src/main/res/values-hy/strings.xml
+++ b/library/ui/src/main/res/values-hy/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Կրկնել բոլորը</string>
   <string name="exo_controls_shuffle_description">Խառնել</string>
   <string name="exo_controls_fullscreen_description">Լիաէկրան ռեժիմ</string>
+  <string name="exo_controls_vr_description">VR ռեժիմ</string>
   <string name="exo_download_description">Ներբեռնել</string>
   <string name="exo_download_notification_channel_name">Ներբեռնումներ</string>
   <string name="exo_download_downloading">Ներբեռնում</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Ծավալային ձայն</string>
   <string name="exo_track_surround_5_point_1">5․1 ծավալային ձայն</string>
   <string name="exo_track_surround_7_point_1">7․1 ծավալային ձայն</string>
-  <string name="exo_track_bitrate">%1$.2f մբ/վ</string>
+  <string name="exo_track_role_alternate">Այլընտրանքային</string>
+  <string name="exo_track_role_supplementary">Լրացուցիչ</string>
+  <string name="exo_track_role_commentary">Մեկնաբանություններ</string>
+  <string name="exo_track_role_closed_captions">Ենթագրեր</string>
+  <string name="exo_track_bitrate">%1$.2f Մբիթ/վ</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-in/strings.xml b/library/ui/src/main/res/values-in/strings.xml
index 6cbd6a703a..7410576e81 100644
--- a/library/ui/src/main/res/values-in/strings.xml
+++ b/library/ui/src/main/res/values-in/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ulangi semua</string>
   <string name="exo_controls_shuffle_description">Acak</string>
   <string name="exo_controls_fullscreen_description">Mode layar penuh</string>
+  <string name="exo_controls_vr_description">Mode VR</string>
   <string name="exo_download_description">Download</string>
   <string name="exo_download_notification_channel_name">Download</string>
   <string name="exo_download_downloading">Mendownload</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Suara surround</string>
   <string name="exo_track_surround_5_point_1">5.1 surround sound</string>
   <string name="exo_track_surround_7_point_1">7.1 surround sound</string>
+  <string name="exo_track_role_alternate">Alternatif</string>
+  <string name="exo_track_role_supplementary">Tambahan</string>
+  <string name="exo_track_role_commentary">Komentar</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-is/strings.xml b/library/ui/src/main/res/values-is/strings.xml
index cb5f40ef51..bdb27a6648 100644
--- a/library/ui/src/main/res/values-is/strings.xml
+++ b/library/ui/src/main/res/values-is/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Endurtaka allt</string>
   <string name="exo_controls_shuffle_description">Stokka</string>
   <string name="exo_controls_fullscreen_description">Allur skjárinn</string>
+  <string name="exo_controls_vr_description">sýndarveruleikastilling</string>
   <string name="exo_download_description">Sækja</string>
   <string name="exo_download_notification_channel_name">Niðurhal</string>
   <string name="exo_download_downloading">Sækir</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Víðóma hljóð</string>
   <string name="exo_track_surround_5_point_1">5.1 víðóma hljóð</string>
   <string name="exo_track_surround_7_point_1">7.1 víðóma hljóð</string>
+  <string name="exo_track_role_alternate">Annað</string>
+  <string name="exo_track_role_supplementary">Auka</string>
+  <string name="exo_track_role_commentary">Lýsingar</string>
+  <string name="exo_track_role_closed_captions">Skjátextar</string>
   <string name="exo_track_bitrate">%1$.2f Mb/sek.</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-it/strings.xml b/library/ui/src/main/res/values-it/strings.xml
index 7e058b4a49..ffa05821e9 100644
--- a/library/ui/src/main/res/values-it/strings.xml
+++ b/library/ui/src/main/res/values-it/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ripeti tutto</string>
   <string name="exo_controls_shuffle_description">Riproduzione casuale</string>
   <string name="exo_controls_fullscreen_description">Modalità a schermo intero</string>
+  <string name="exo_controls_vr_description">Modalità VR</string>
   <string name="exo_download_description">Scarica</string>
   <string name="exo_download_notification_channel_name">Download</string>
   <string name="exo_download_downloading">Download…</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Audio surround</string>
   <string name="exo_track_surround_5_point_1">Audio surround 5.1</string>
   <string name="exo_track_surround_7_point_1">Audio surround 7.1</string>
+  <string name="exo_track_role_alternate">Versione alternativa</string>
+  <string name="exo_track_role_supplementary">Contenuti supplementari</string>
+  <string name="exo_track_role_commentary">Commenti</string>
+  <string name="exo_track_role_closed_captions">Sottotitoli</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-iw/strings.xml b/library/ui/src/main/res/values-iw/strings.xml
index 9aec8e5834..695196c5be 100644
--- a/library/ui/src/main/res/values-iw/strings.xml
+++ b/library/ui/src/main/res/values-iw/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">חזור על הכול</string>
   <string name="exo_controls_shuffle_description">ערבוב</string>
   <string name="exo_controls_fullscreen_description">מצב מסך מלא</string>
+  <string name="exo_controls_vr_description">מצב VR</string>
   <string name="exo_download_description">הורדה</string>
   <string name="exo_download_notification_channel_name">הורדות</string>
   <string name="exo_download_downloading">ההורדה מתבצעת</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">סראונד</string>
   <string name="exo_track_surround_5_point_1">סראונד 5.1</string>
   <string name="exo_track_surround_7_point_1">סראונד 7.1</string>
+  <string name="exo_track_role_alternate">חלופי</string>
+  <string name="exo_track_role_supplementary">משלים</string>
+  <string name="exo_track_role_commentary">פרשנות</string>
+  <string name="exo_track_role_closed_captions">כתוביות</string>
   <string name="exo_track_bitrate">%1$.2f מגה סיביות לשנייה</string>
   <string name="exo_item_list">%1$s‏, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ja/strings.xml b/library/ui/src/main/res/values-ja/strings.xml
index 86f204e572..b4158736a8 100644
--- a/library/ui/src/main/res/values-ja/strings.xml
+++ b/library/ui/src/main/res/values-ja/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">全曲をリピート</string>
   <string name="exo_controls_shuffle_description">シャッフル</string>
   <string name="exo_controls_fullscreen_description">全画面モード</string>
+  <string name="exo_controls_vr_description">VR モード</string>
   <string name="exo_download_description">ダウンロード</string>
   <string name="exo_download_notification_channel_name">ダウンロード</string>
   <string name="exo_download_downloading">ダウンロードしています</string>
@@ -20,7 +21,7 @@
   <string name="exo_download_removing">ダウンロードを削除しています</string>
   <string name="exo_track_selection_title_video">動画</string>
   <string name="exo_track_selection_title_audio">音声</string>
-  <string name="exo_track_selection_title_text">SMS</string>
+  <string name="exo_track_selection_title_text">文字</string>
   <string name="exo_track_selection_none">なし</string>
   <string name="exo_track_selection_auto">自動</string>
   <string name="exo_track_unknown">不明</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">サラウンド サウンド</string>
   <string name="exo_track_surround_5_point_1">5.1 サラウンド サウンド</string>
   <string name="exo_track_surround_7_point_1">7.1 サラウンド サウンド</string>
+  <string name="exo_track_role_alternate">代替</string>
+  <string name="exo_track_role_supplementary">補足</string>
+  <string name="exo_track_role_commentary">解説</string>
+  <string name="exo_track_role_closed_captions">字幕</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s、%2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ka/strings.xml b/library/ui/src/main/res/values-ka/strings.xml
index 5b8c08065e..13ceaaf51f 100644
--- a/library/ui/src/main/res/values-ka/strings.xml
+++ b/library/ui/src/main/res/values-ka/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">ყველას გამეორება</string>
   <string name="exo_controls_shuffle_description">არეულად დაკვრა</string>
   <string name="exo_controls_fullscreen_description">სრულეკრანიანი რეჟიმი</string>
+  <string name="exo_controls_vr_description">VR რეჟიმი</string>
   <string name="exo_download_description">ჩამოტვირთვა</string>
   <string name="exo_download_notification_channel_name">ჩამოტვირთვები</string>
   <string name="exo_download_downloading">მიმდინარეობს ჩამოტვირთვა</string>
@@ -20,7 +21,7 @@
   <string name="exo_download_removing">მიმდინარეობს ჩამოტვირთვების ამოშლა</string>
   <string name="exo_track_selection_title_video">ვიდეო</string>
   <string name="exo_track_selection_title_audio">აუდიო</string>
-  <string name="exo_track_selection_title_text">SMS</string>
+  <string name="exo_track_selection_title_text">ტექსტი</string>
   <string name="exo_track_selection_none">არცერთი</string>
   <string name="exo_track_selection_auto">ავტომატური</string>
   <string name="exo_track_unknown">უცნობი</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">მოცულობითი ხმა</string>
   <string name="exo_track_surround_5_point_1">5.1 მოცულობითი ხმა</string>
   <string name="exo_track_surround_7_point_1">7.1 მოცულობითი ხმა</string>
+  <string name="exo_track_role_alternate">ალტერნატიული</string>
+  <string name="exo_track_role_supplementary">დამატებითი</string>
+  <string name="exo_track_role_commentary">კომენტარი</string>
+  <string name="exo_track_role_closed_captions">დახურული სუბტიტრები</string>
   <string name="exo_track_bitrate">%1$.2f მბიტ/წმ</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-kk/strings.xml b/library/ui/src/main/res/values-kk/strings.xml
index 3842263348..92119d1fe5 100644
--- a/library/ui/src/main/res/values-kk/strings.xml
+++ b/library/ui/src/main/res/values-kk/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Барлығын қайталау</string>
   <string name="exo_controls_shuffle_description">Араластыру</string>
   <string name="exo_controls_fullscreen_description">Толық экран режимі</string>
+  <string name="exo_controls_vr_description">VR режимі</string>
   <string name="exo_download_description">Жүктеп алу</string>
   <string name="exo_download_notification_channel_name">Жүктеп алынғандар</string>
   <string name="exo_download_downloading">Жүктеп алынуда</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Көлемді дыбыс</string>
   <string name="exo_track_surround_5_point_1">5.1 көлемді дыбыс жүйесі</string>
   <string name="exo_track_surround_7_point_1">7.1 көлемді дыбыс жүйесі</string>
+  <string name="exo_track_role_alternate">Балама</string>
+  <string name="exo_track_role_supplementary">Қосымша</string>
+  <string name="exo_track_role_commentary">Түсіндірме</string>
+  <string name="exo_track_role_closed_captions">Субтитр</string>
   <string name="exo_track_bitrate">%1$.2f МБ/сек</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-km/strings.xml b/library/ui/src/main/res/values-km/strings.xml
index 89d73605a5..62728de026 100644
--- a/library/ui/src/main/res/values-km/strings.xml
+++ b/library/ui/src/main/res/values-km/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">លេង​ឡើងវិញ​ទាំងអស់</string>
   <string name="exo_controls_shuffle_description">ច្របល់</string>
   <string name="exo_controls_fullscreen_description">មុខងារពេញ​អេក្រង់</string>
+  <string name="exo_controls_vr_description">មុខងារ VR</string>
   <string name="exo_download_description">ទាញយក</string>
   <string name="exo_download_notification_channel_name">ទាញយក</string>
   <string name="exo_download_downloading">កំពុង​ទាញ​យក</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">សំឡេង​រងំ</string>
   <string name="exo_track_surround_5_point_1">សំឡេង​រងំ​ខ្នាត 5.1</string>
   <string name="exo_track_surround_7_point_1">សំឡេង​រងំ​ខ្នាត 7.1</string>
+  <string name="exo_track_role_alternate">ជំនួស</string>
+  <string name="exo_track_role_supplementary">បំពេញបន្ថែម</string>
+  <string name="exo_track_role_commentary">ការអត្ថាធិប្បាយ</string>
+  <string name="exo_track_role_closed_captions">អក្សររត់</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-kn/strings.xml b/library/ui/src/main/res/values-kn/strings.xml
index 65d65b1d23..6e6bfcb165 100644
--- a/library/ui/src/main/res/values-kn/strings.xml
+++ b/library/ui/src/main/res/values-kn/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">ಎಲ್ಲವನ್ನು ಪುನರಾವರ್ತಿಸಿ</string>
   <string name="exo_controls_shuffle_description">ಶಫಲ್‌</string>
   <string name="exo_controls_fullscreen_description">ಪೂರ್ಣ ಪರದೆ ಮೋಡ್</string>
+  <string name="exo_controls_vr_description">VR ಮೋಡ್</string>
   <string name="exo_download_description">ಡೌನ್‌ಲೋಡ್‌</string>
   <string name="exo_download_notification_channel_name">ಡೌನ್‌ಲೋಡ್‌ಗಳು</string>
   <string name="exo_download_downloading">ಡೌನ್‌ಲೋಡ್ ಮಾಡಲಾಗುತ್ತಿದೆ</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">ಸರೌಂಡ್ ಶಬ್ದ</string>
   <string name="exo_track_surround_5_point_1">5.1 ಸರೌಂಡ್ ಶಬ್ದ</string>
   <string name="exo_track_surround_7_point_1">7.1 ಸರೌಂಡ್ ಶಬ್ದ</string>
+  <string name="exo_track_role_alternate">ಪರ್ಯಾಯ</string>
+  <string name="exo_track_role_supplementary">ಪೂರಕ</string>
+  <string name="exo_track_role_commentary">ವ್ಯಾಖ್ಯಾನ</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ko/strings.xml b/library/ui/src/main/res/values-ko/strings.xml
index 7714203e5e..230660ad6a 100644
--- a/library/ui/src/main/res/values-ko/strings.xml
+++ b/library/ui/src/main/res/values-ko/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">모두 반복</string>
   <string name="exo_controls_shuffle_description">셔플</string>
   <string name="exo_controls_fullscreen_description">전체화면 모드</string>
+  <string name="exo_controls_vr_description">가상 현실 모드</string>
   <string name="exo_download_description">다운로드</string>
   <string name="exo_download_notification_channel_name">다운로드</string>
   <string name="exo_download_downloading">다운로드 중</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">서라운드 사운드</string>
   <string name="exo_track_surround_5_point_1">5.1 서라운드 사운드</string>
   <string name="exo_track_surround_7_point_1">7.1 서라운드 사운드</string>
+  <string name="exo_track_role_alternate">대체</string>
+  <string name="exo_track_role_supplementary">추가</string>
+  <string name="exo_track_role_commentary">논평</string>
+  <string name="exo_track_role_closed_captions">자막</string>
   <string name="exo_track_bitrate">%1$.2fMbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ky/strings.xml b/library/ui/src/main/res/values-ky/strings.xml
index 20a4739a2b..57b8bbb5f5 100644
--- a/library/ui/src/main/res/values-ky/strings.xml
+++ b/library/ui/src/main/res/values-ky/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Баарын кайталоо</string>
   <string name="exo_controls_shuffle_description">Аралаштыруу</string>
   <string name="exo_controls_fullscreen_description">Толук экран режими</string>
+  <string name="exo_controls_vr_description">VR режими</string>
   <string name="exo_download_description">Жүктөп алуу</string>
   <string name="exo_download_notification_channel_name">Жүктөлүп алынгандар</string>
   <string name="exo_download_downloading">Жүктөлүп алынууда</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Көлөмдүү добуш</string>
   <string name="exo_track_surround_5_point_1">5.1 көлөмдүү добуш</string>
   <string name="exo_track_surround_7_point_1">7.1 көлөмдүү добуш</string>
+  <string name="exo_track_role_alternate">Альтернативдүү трек</string>
+  <string name="exo_track_role_supplementary">Кошумча трек</string>
+  <string name="exo_track_role_commentary">Пикир</string>
+  <string name="exo_track_role_closed_captions">Коштомо жазуулар</string>
   <string name="exo_track_bitrate">%1$.2f Мб/сек.</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lo/strings.xml b/library/ui/src/main/res/values-lo/strings.xml
index 3de5962a42..d7996610b2 100644
--- a/library/ui/src/main/res/values-lo/strings.xml
+++ b/library/ui/src/main/res/values-lo/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">ຫຼິ້ນຊ້ຳທັງໝົດ</string>
   <string name="exo_controls_shuffle_description">ຫຼີ້ນແບບສຸ່ມ</string>
   <string name="exo_controls_fullscreen_description">ໂໝດເຕັມຈໍ</string>
+  <string name="exo_controls_vr_description">ໂໝດ VR</string>
   <string name="exo_download_description">ດາວໂຫລດ</string>
   <string name="exo_download_notification_channel_name">ດາວໂຫລດ</string>
   <string name="exo_download_downloading">ກຳລັງດາວໂຫລດ</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">ສຽງຮອບທິດທາງ</string>
   <string name="exo_track_surround_5_point_1">ສຽງຮອບທິດທາງ 5.1</string>
   <string name="exo_track_surround_7_point_1">ສຽງຮອບທິດທາງ 7.1</string>
+  <string name="exo_track_role_alternate">ສຳຮອງ</string>
+  <string name="exo_track_role_supplementary">ສ່ວນເສີມ</string>
+  <string name="exo_track_role_commentary">ຄຳເຫັນ</string>
+  <string name="exo_track_role_closed_captions">ຄຳບັນຍາຍ</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lt/strings.xml b/library/ui/src/main/res/values-lt/strings.xml
index eaf26aafb6..3e9a63dc99 100644
--- a/library/ui/src/main/res/values-lt/strings.xml
+++ b/library/ui/src/main/res/values-lt/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Kartoti viską</string>
   <string name="exo_controls_shuffle_description">Maišyti</string>
   <string name="exo_controls_fullscreen_description">Viso ekrano režimas</string>
+  <string name="exo_controls_vr_description">VR režimas</string>
   <string name="exo_download_description">Atsisiųsti</string>
   <string name="exo_download_notification_channel_name">Atsisiuntimai</string>
   <string name="exo_download_downloading">Atsisiunčiama</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Erdvinis garsas</string>
   <string name="exo_track_surround_5_point_1">5.1 erdvinis garsas</string>
   <string name="exo_track_surround_7_point_1">7.1 erdvinis garsas</string>
+  <string name="exo_track_role_alternate">Alternatyvus</string>
+  <string name="exo_track_role_supplementary">Papildomas</string>
+  <string name="exo_track_role_commentary">Komentaras</string>
+  <string name="exo_track_role_closed_captions">Subtitrai</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lv/strings.xml b/library/ui/src/main/res/values-lv/strings.xml
index 708a2143c7..59b541808a 100644
--- a/library/ui/src/main/res/values-lv/strings.xml
+++ b/library/ui/src/main/res/values-lv/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Atkārtot visu</string>
   <string name="exo_controls_shuffle_description">Atskaņot jauktā secībā</string>
   <string name="exo_controls_fullscreen_description">Pilnekrāna režīms</string>
+  <string name="exo_controls_vr_description">VR režīms</string>
   <string name="exo_download_description">Lejupielādēt</string>
   <string name="exo_download_notification_channel_name">Lejupielādes</string>
   <string name="exo_download_downloading">Notiek lejupielāde</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Ieskaujošā skaņa</string>
   <string name="exo_track_surround_5_point_1">5.1 ieskaujošā skaņa</string>
   <string name="exo_track_surround_7_point_1">7.1 ieskaujošā skaņa</string>
+  <string name="exo_track_role_alternate">Cits</string>
+  <string name="exo_track_role_supplementary">Papildu</string>
+  <string name="exo_track_role_commentary">Komentāri</string>
+  <string name="exo_track_role_closed_captions">Slēgtie paraksti</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-mk/strings.xml b/library/ui/src/main/res/values-mk/strings.xml
index 3e6ae777cc..08a54d7240 100644
--- a/library/ui/src/main/res/values-mk/strings.xml
+++ b/library/ui/src/main/res/values-mk/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Повтори ги сите</string>
   <string name="exo_controls_shuffle_description">Измешај</string>
   <string name="exo_controls_fullscreen_description">Режим на цел екран</string>
+  <string name="exo_controls_vr_description">Режим на VR</string>
   <string name="exo_download_description">Преземи</string>
   <string name="exo_download_notification_channel_name">Преземања</string>
   <string name="exo_download_downloading">Се презема</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Опкружувачки звук</string>
   <string name="exo_track_surround_5_point_1">5.1 опкружувачки звук</string>
   <string name="exo_track_surround_7_point_1">7.1 опкружувачки звук</string>
+  <string name="exo_track_role_alternate">Алтернативна</string>
+  <string name="exo_track_role_supplementary">Дополнителна</string>
+  <string name="exo_track_role_commentary">Коментар</string>
+  <string name="exo_track_role_closed_captions">Титлови</string>
   <string name="exo_track_bitrate">%1$.2f Mб/с</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ml/strings.xml b/library/ui/src/main/res/values-ml/strings.xml
index acd3828fe2..6e79db0903 100644
--- a/library/ui/src/main/res/values-ml/strings.xml
+++ b/library/ui/src/main/res/values-ml/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">എല്ലാം ആവർത്തിക്കുക</string>
   <string name="exo_controls_shuffle_description">ഇടകലര്‍ത്തുക</string>
   <string name="exo_controls_fullscreen_description">പൂർണ്ണ സ്‌ക്രീൻ മോഡ്</string>
+  <string name="exo_controls_vr_description">VR മോഡ്</string>
   <string name="exo_download_description">ഡൗൺലോഡ്</string>
   <string name="exo_download_notification_channel_name">ഡൗൺലോഡുകൾ</string>
   <string name="exo_download_downloading">ഡൗൺലോഡ് ചെയ്യുന്നു</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">സറൗണ്ട് സൗണ്ട്</string>
   <string name="exo_track_surround_5_point_1">5.1 സറൗണ്ട് സൗണ്ട്</string>
   <string name="exo_track_surround_7_point_1">7.1 സറൗണ്ട് സൗണ്ട്</string>
+  <string name="exo_track_role_alternate">ഇതര ട്രാക്ക്</string>
+  <string name="exo_track_role_supplementary">സപ്ലിമെന്ററി</string>
+  <string name="exo_track_role_commentary">വിവരണം</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-mn/strings.xml b/library/ui/src/main/res/values-mn/strings.xml
index 328827f87f..383d102520 100644
--- a/library/ui/src/main/res/values-mn/strings.xml
+++ b/library/ui/src/main/res/values-mn/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Бүгдийг нь дахин тоглуулах</string>
   <string name="exo_controls_shuffle_description">Холих</string>
   <string name="exo_controls_fullscreen_description">Бүтэн дэлгэцийн горим</string>
+  <string name="exo_controls_vr_description">VR горим</string>
   <string name="exo_download_description">Татах</string>
   <string name="exo_download_notification_channel_name">Татaлт</string>
   <string name="exo_download_downloading">Татаж байна</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Орчин тойрны дуу</string>
   <string name="exo_track_surround_5_point_1">5.1 орчин тойрны дуу</string>
   <string name="exo_track_surround_7_point_1">7.1 орчин тойрны дуу</string>
+  <string name="exo_track_role_alternate">Хувилбар</string>
+  <string name="exo_track_role_supplementary">Нэмэлт</string>
+  <string name="exo_track_role_commentary">Тайлбар</string>
+  <string name="exo_track_role_closed_captions">Хаалттай тайлбар</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-mr/strings.xml b/library/ui/src/main/res/values-mr/strings.xml
index 753e6ba8d8..a0900ab851 100644
--- a/library/ui/src/main/res/values-mr/strings.xml
+++ b/library/ui/src/main/res/values-mr/strings.xml
@@ -11,7 +11,8 @@
   <string name="exo_controls_repeat_one_description">एक रीपीट करा</string>
   <string name="exo_controls_repeat_all_description">सर्व रीपीट करा</string>
   <string name="exo_controls_shuffle_description">शफल करा</string>
-  <string name="exo_controls_fullscreen_description">पूर्ण स्क्रीन मोड</string>
+  <string name="exo_controls_fullscreen_description">फुल स्क्रीन मोड</string>
+  <string name="exo_controls_vr_description">VR मोड</string>
   <string name="exo_download_description">डाउनलोड करा</string>
   <string name="exo_download_notification_channel_name">डाउनलोड</string>
   <string name="exo_download_downloading">डाउनलोड होत आहे</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">सराउंड साउंड</string>
   <string name="exo_track_surround_5_point_1">५.१ सराउंड साउंड</string>
   <string name="exo_track_surround_7_point_1">७.१ सराउंड साउंड</string>
+  <string name="exo_track_role_alternate">पर्यायी</string>
+  <string name="exo_track_role_supplementary">साहाय्यक</string>
+  <string name="exo_track_role_commentary">समालोचन</string>
+  <string name="exo_track_role_closed_captions">सबटायटल</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ms/strings.xml b/library/ui/src/main/res/values-ms/strings.xml
index c4a437da3b..6dab5be8de 100644
--- a/library/ui/src/main/res/values-ms/strings.xml
+++ b/library/ui/src/main/res/values-ms/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ulang semua</string>
   <string name="exo_controls_shuffle_description">Rombak</string>
   <string name="exo_controls_fullscreen_description">Mod skrin penuh</string>
+  <string name="exo_controls_vr_description">Mod VR</string>
   <string name="exo_download_description">Muat turun</string>
   <string name="exo_download_notification_channel_name">Muat turun</string>
   <string name="exo_download_downloading">Memuat turun</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Bunyi keliling</string>
   <string name="exo_track_surround_5_point_1">Bunyi keliling 5.1</string>
   <string name="exo_track_surround_7_point_1">Bunyi keliling 7.1</string>
+  <string name="exo_track_role_alternate">Alternatif</string>
+  <string name="exo_track_role_supplementary">Tambahan</string>
+  <string name="exo_track_role_commentary">Ulasan</string>
+  <string name="exo_track_role_closed_captions">SK</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-my/strings.xml b/library/ui/src/main/res/values-my/strings.xml
index 497ff50416..b30b76d516 100644
--- a/library/ui/src/main/res/values-my/strings.xml
+++ b/library/ui/src/main/res/values-my/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">အားလုံး ပြန်ကျော့ရန်</string>
   <string name="exo_controls_shuffle_description">ရောသမမွှေ</string>
   <string name="exo_controls_fullscreen_description">မျက်နှာပြင်အပြည့် မုဒ်</string>
+  <string name="exo_controls_vr_description">VR မုဒ်</string>
   <string name="exo_download_description">ဒေါင်းလုဒ် လုပ်ရန်</string>
   <string name="exo_download_notification_channel_name">ဒေါင်းလုဒ်များ</string>
   <string name="exo_download_downloading">ဒေါင်းလုဒ်လုပ်နေသည်</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">ပတ်လည် အသံစနစ်</string>
   <string name="exo_track_surround_5_point_1">5.1 ပတ်လည် အသံစနစ်</string>
   <string name="exo_track_surround_7_point_1">7.1 ပတ်လည် အသံစနစ်</string>
+  <string name="exo_track_role_alternate">အရန်</string>
+  <string name="exo_track_role_supplementary">နောက်ဆက်တွဲ</string>
+  <string name="exo_track_role_commentary">ထင်မြင်သုံးသပ်ချက်</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s၊ %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-nb/strings.xml b/library/ui/src/main/res/values-nb/strings.xml
index 7e48146084..f2847dd829 100644
--- a/library/ui/src/main/res/values-nb/strings.xml
+++ b/library/ui/src/main/res/values-nb/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Gjenta alle</string>
   <string name="exo_controls_shuffle_description">Tilfeldig rekkefølge</string>
   <string name="exo_controls_fullscreen_description">Fullskjermmodus</string>
+  <string name="exo_controls_vr_description">VR-modus</string>
   <string name="exo_download_description">Last ned</string>
   <string name="exo_download_notification_channel_name">Nedlastinger</string>
   <string name="exo_download_downloading">Laster ned</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround-lyd</string>
   <string name="exo_track_surround_5_point_1">5.1 surround-lyd</string>
   <string name="exo_track_surround_7_point_1">7.1 surround-lyd</string>
+  <string name="exo_track_role_alternate">Alternativt spor</string>
+  <string name="exo_track_role_supplementary">Tilleggsspor</string>
+  <string name="exo_track_role_commentary">Kommentarer</string>
+  <string name="exo_track_role_closed_captions">Teksting</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ne/strings.xml b/library/ui/src/main/res/values-ne/strings.xml
index 5011998b87..ff56480df1 100644
--- a/library/ui/src/main/res/values-ne/strings.xml
+++ b/library/ui/src/main/res/values-ne/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">सबै दोहोर्‍याउनुहोस्</string>
   <string name="exo_controls_shuffle_description">मिसाउनुहोस्</string>
   <string name="exo_controls_fullscreen_description">पूर्ण स्क्रिन मोड</string>
+  <string name="exo_controls_vr_description">VR मोड</string>
   <string name="exo_download_description">डाउनलोड गर्नुहोस्</string>
   <string name="exo_download_notification_channel_name">डाउनलोडहरू</string>
   <string name="exo_download_downloading">डाउनलोड गरिँदै छ</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">सराउन्ड साउन्ड</string>
   <string name="exo_track_surround_5_point_1">5.1 सराउन्ड साउन्ड</string>
   <string name="exo_track_surround_7_point_1">7.1 सराउन्ड साउन्ड</string>
+  <string name="exo_track_role_alternate">वैकल्पिक</string>
+  <string name="exo_track_role_supplementary">पूरक</string>
+  <string name="exo_track_role_commentary">टिप्पणी</string>
+  <string name="exo_track_role_closed_captions">उपशीर्षकहरू</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-nl/strings.xml b/library/ui/src/main/res/values-nl/strings.xml
index 1a2880ae1f..3fbf113f1e 100644
--- a/library/ui/src/main/res/values-nl/strings.xml
+++ b/library/ui/src/main/res/values-nl/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Alles herhalen</string>
   <string name="exo_controls_shuffle_description">Shuffle</string>
   <string name="exo_controls_fullscreen_description">Modus \'Volledig scherm\'</string>
+  <string name="exo_controls_vr_description">VR-modus</string>
   <string name="exo_download_description">Downloaden</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Downloaden</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround sound</string>
   <string name="exo_track_surround_5_point_1">5.1 surroundgeluid</string>
   <string name="exo_track_surround_7_point_1">7.1 surroundgeluid</string>
+  <string name="exo_track_role_alternate">Alternatief</string>
+  <string name="exo_track_role_supplementary">Aanvullend</string>
+  <string name="exo_track_role_commentary">Commentaar</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pa/strings.xml b/library/ui/src/main/res/values-pa/strings.xml
index effc9250ed..9f25759878 100644
--- a/library/ui/src/main/res/values-pa/strings.xml
+++ b/library/ui/src/main/res/values-pa/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">ਸਾਰਿਆਂ ਨੂੰ ਦੁਹਰਾਓ</string>
   <string name="exo_controls_shuffle_description">ਬੇਤਰਤੀਬ ਕਰੋ</string>
   <string name="exo_controls_fullscreen_description">ਪੂਰੀ-ਸਕ੍ਰੀਨ ਮੋਡ</string>
+  <string name="exo_controls_vr_description">VR ਮੋਡ</string>
   <string name="exo_download_description">ਡਾਊਨਲੋਡ ਕਰੋ</string>
   <string name="exo_download_notification_channel_name">ਡਾਊਨਲੋਡ</string>
   <string name="exo_download_downloading">ਡਾਊਨਲੋਡ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">ਸਰਾਊਂਡ ਸਾਊਂਡ</string>
   <string name="exo_track_surround_5_point_1">5.1 ਸਰਾਊਂਡ ਸਾਊਂਡ</string>
   <string name="exo_track_surround_7_point_1">7.1 ਸਰਾਊਂਡ ਸਾਊਂਡ</string>
+  <string name="exo_track_role_alternate">ਵਟਾਵਾਂ</string>
+  <string name="exo_track_role_supplementary">ਪੂਰਕ</string>
+  <string name="exo_track_role_commentary">ਕਮੈਂਟਰੀ</string>
+  <string name="exo_track_role_closed_captions">ਬੰਦ ਸੁੁਰਖੀਆਂ</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pl/strings.xml b/library/ui/src/main/res/values-pl/strings.xml
index 312481fa2b..8df3b62b0c 100644
--- a/library/ui/src/main/res/values-pl/strings.xml
+++ b/library/ui/src/main/res/values-pl/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Powtórz wszystkie</string>
   <string name="exo_controls_shuffle_description">Odtwarzanie losowe</string>
   <string name="exo_controls_fullscreen_description">Tryb pełnoekranowy</string>
+  <string name="exo_controls_vr_description">Tryb VR</string>
   <string name="exo_download_description">Pobierz</string>
   <string name="exo_download_notification_channel_name">Pobieranie</string>
   <string name="exo_download_downloading">Pobieram</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Dźwięk przestrzenny</string>
   <string name="exo_track_surround_5_point_1">System dźwięku przestrzennego 5.1</string>
   <string name="exo_track_surround_7_point_1">System dźwięku przestrzennego 7.1</string>
+  <string name="exo_track_role_alternate">Wersja alternatywna</string>
+  <string name="exo_track_role_supplementary">Materiały dodatkowe</string>
+  <string name="exo_track_role_commentary">Komentarz</string>
+  <string name="exo_track_role_closed_captions">Napisy</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt-rPT/strings.xml b/library/ui/src/main/res/values-pt-rPT/strings.xml
index 52eb01e219..188e18f6b5 100644
--- a/library/ui/src/main/res/values-pt-rPT/strings.xml
+++ b/library/ui/src/main/res/values-pt-rPT/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repetir tudo</string>
   <string name="exo_controls_shuffle_description">Reproduzir aleatoriamente</string>
   <string name="exo_controls_fullscreen_description">Modo de ecrã inteiro</string>
+  <string name="exo_controls_vr_description">Modo de RV</string>
   <string name="exo_download_description">Transferir</string>
   <string name="exo_download_notification_channel_name">Transferências</string>
   <string name="exo_download_downloading">A transferir…</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Som surround</string>
   <string name="exo_track_surround_5_point_1">Som surround 5.1</string>
   <string name="exo_track_surround_7_point_1">Som surround 7.1</string>
+  <string name="exo_track_role_alternate">Alternativa</string>
+  <string name="exo_track_role_supplementary">Suplementar</string>
+  <string name="exo_track_role_commentary">Comentário</string>
+  <string name="exo_track_role_closed_captions">Legendas</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt/strings.xml b/library/ui/src/main/res/values-pt/strings.xml
index 6ea00fed8d..9e83387a76 100644
--- a/library/ui/src/main/res/values-pt/strings.xml
+++ b/library/ui/src/main/res/values-pt/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repetir tudo</string>
   <string name="exo_controls_shuffle_description">Aleatório</string>
   <string name="exo_controls_fullscreen_description">Modo de tela cheia</string>
+  <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Fazer o download</string>
   <string name="exo_download_notification_channel_name">Downloads</string>
   <string name="exo_download_downloading">Fazendo o download</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Sistema surround</string>
   <string name="exo_track_surround_5_point_1">Sistema surround 5.1</string>
   <string name="exo_track_surround_7_point_1">Sistema surround 7.1</string>
+  <string name="exo_track_role_alternate">Alternativa</string>
+  <string name="exo_track_role_supplementary">Complementar</string>
+  <string name="exo_track_role_commentary">Comentários</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ro/strings.xml b/library/ui/src/main/res/values-ro/strings.xml
index 4ea18d4a58..9bb8cfc8ee 100644
--- a/library/ui/src/main/res/values-ro/strings.xml
+++ b/library/ui/src/main/res/values-ro/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Repetați-le pe toate</string>
   <string name="exo_controls_shuffle_description">Redați aleatoriu</string>
   <string name="exo_controls_fullscreen_description">Modul Ecran complet</string>
+  <string name="exo_controls_vr_description">Mod RV</string>
   <string name="exo_download_description">Descărcați</string>
   <string name="exo_download_notification_channel_name">Descărcări</string>
   <string name="exo_download_downloading">Se descarcă</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Sunet surround</string>
   <string name="exo_track_surround_5_point_1">Sunet surround 5.1</string>
   <string name="exo_track_surround_7_point_1">Sunet surround 7.1</string>
+  <string name="exo_track_role_alternate">Alternativ</string>
+  <string name="exo_track_role_supplementary">Suplimentar</string>
+  <string name="exo_track_role_commentary">Comentarii</string>
+  <string name="exo_track_role_closed_captions">Subtitrări</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ru/strings.xml b/library/ui/src/main/res/values-ru/strings.xml
index 14c8badf99..e66a282da4 100644
--- a/library/ui/src/main/res/values-ru/strings.xml
+++ b/library/ui/src/main/res/values-ru/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Повторять все</string>
   <string name="exo_controls_shuffle_description">Перемешать</string>
   <string name="exo_controls_fullscreen_description">Полноэкранный режим</string>
+  <string name="exo_controls_vr_description">VR-режим</string>
   <string name="exo_download_description">Скачать</string>
   <string name="exo_download_notification_channel_name">Скачивания</string>
   <string name="exo_download_downloading">Скачивание…</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Объемный звук</string>
   <string name="exo_track_surround_5_point_1">Система объемного звука 5.1</string>
   <string name="exo_track_surround_7_point_1">Система объемного звука 7.1</string>
+  <string name="exo_track_role_alternate">Другая запись</string>
+  <string name="exo_track_role_supplementary">Дополнительные материалы</string>
+  <string name="exo_track_role_commentary">Комментарии</string>
+  <string name="exo_track_role_closed_captions">Субтитры</string>
   <string name="exo_track_bitrate">%1$.2f Мбит/сек</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-si/strings.xml b/library/ui/src/main/res/values-si/strings.xml
index 92ae038c4b..b6bfb1848f 100644
--- a/library/ui/src/main/res/values-si/strings.xml
+++ b/library/ui/src/main/res/values-si/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">සියල්ල පුනරාවර්තනය කරන්න</string>
   <string name="exo_controls_shuffle_description">කලවම් කරන්න</string>
   <string name="exo_controls_fullscreen_description">සම්පූර්ණ තිර ප්‍රකාරය</string>
+  <string name="exo_controls_vr_description">VR ප්‍රකාරය</string>
   <string name="exo_download_description">බාගන්න</string>
   <string name="exo_download_notification_channel_name">බාගැනීම්</string>
   <string name="exo_download_downloading">බාගනිමින්</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">අවට ශබ්දය</string>
   <string name="exo_track_surround_5_point_1">5.1 අවට ශබ්දය</string>
   <string name="exo_track_surround_7_point_1">7.1 අවට ශබ්දය</string>
+  <string name="exo_track_role_alternate">විකල්ප</string>
+  <string name="exo_track_role_supplementary">පරිපූරක</string>
+  <string name="exo_track_role_commentary">වර්ණනා</string>
+  <string name="exo_track_role_closed_captions">සිරස්තල</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sk/strings.xml b/library/ui/src/main/res/values-sk/strings.xml
index f4f997b207..6d5ddaea28 100644
--- a/library/ui/src/main/res/values-sk/strings.xml
+++ b/library/ui/src/main/res/values-sk/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Opakovať všetko</string>
   <string name="exo_controls_shuffle_description">Náhodne prehrávať</string>
   <string name="exo_controls_fullscreen_description">Režim celej obrazovky</string>
+  <string name="exo_controls_vr_description">režim VR</string>
   <string name="exo_download_description">Stiahnuť</string>
   <string name="exo_download_notification_channel_name">Stiahnuté</string>
   <string name="exo_download_downloading">Sťahuje sa</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Priestorový zvuk</string>
   <string name="exo_track_surround_5_point_1">Priestorový zvuk 5.1</string>
   <string name="exo_track_surround_7_point_1">Priestorový zvuk 7.1</string>
+  <string name="exo_track_role_alternate">Alternatívna stopa</string>
+  <string name="exo_track_role_supplementary">Doplnková stopa</string>
+  <string name="exo_track_role_commentary">Komentár</string>
+  <string name="exo_track_role_closed_captions">Skryté titulky</string>
   <string name="exo_track_bitrate">%1$.2f MB/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sl/strings.xml b/library/ui/src/main/res/values-sl/strings.xml
index 83d332103e..1e3adff704 100644
--- a/library/ui/src/main/res/values-sl/strings.xml
+++ b/library/ui/src/main/res/values-sl/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ponavljanje vseh</string>
   <string name="exo_controls_shuffle_description">Naključno predvajanje</string>
   <string name="exo_controls_fullscreen_description">Celozaslonski način</string>
+  <string name="exo_controls_vr_description">Način VR</string>
   <string name="exo_download_description">Prenos</string>
   <string name="exo_download_notification_channel_name">Prenosi</string>
   <string name="exo_download_downloading">Prenašanje</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Prostorski zvok</string>
   <string name="exo_track_surround_5_point_1">Prostorski zvok 5.1</string>
   <string name="exo_track_surround_7_point_1">Prostorski zvok 7.1</string>
+  <string name="exo_track_role_alternate">Dodatni posnetek</string>
+  <string name="exo_track_role_supplementary">Dodatek</string>
+  <string name="exo_track_role_commentary">Komentar</string>
+  <string name="exo_track_role_closed_captions">Podnapisi</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sq/strings.xml b/library/ui/src/main/res/values-sq/strings.xml
index c46524762d..d5b8903ed7 100644
--- a/library/ui/src/main/res/values-sq/strings.xml
+++ b/library/ui/src/main/res/values-sq/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Përsërit të gjitha</string>
   <string name="exo_controls_shuffle_description">Përziej</string>
   <string name="exo_controls_fullscreen_description">Modaliteti me ekran të plotë</string>
+  <string name="exo_controls_vr_description">Modaliteti RV</string>
   <string name="exo_download_description">Shkarko</string>
   <string name="exo_download_notification_channel_name">Shkarkimet</string>
   <string name="exo_download_downloading">Po shkarkohet</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Tingulli rrethues</string>
   <string name="exo_track_surround_5_point_1">Tingull rrethues 5.1</string>
   <string name="exo_track_surround_7_point_1">Tingull rrethues 7.1</string>
+  <string name="exo_track_role_alternate">Alternative</string>
+  <string name="exo_track_role_supplementary">Plotësuese</string>
+  <string name="exo_track_role_commentary">Komente</string>
+  <string name="exo_track_role_closed_captions">Titrat</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sr/strings.xml b/library/ui/src/main/res/values-sr/strings.xml
index 394ab8d36e..b45fd8ab03 100644
--- a/library/ui/src/main/res/values-sr/strings.xml
+++ b/library/ui/src/main/res/values-sr/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Понови све</string>
   <string name="exo_controls_shuffle_description">Пусти насумично</string>
   <string name="exo_controls_fullscreen_description">Режим целог екрана</string>
+  <string name="exo_controls_vr_description">ВР режим</string>
   <string name="exo_download_description">Преузми</string>
   <string name="exo_download_notification_channel_name">Преузимања</string>
   <string name="exo_download_downloading">Преузима се</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Звучни систем</string>
   <string name="exo_track_surround_5_point_1">Звучни систем 5.1</string>
   <string name="exo_track_surround_7_point_1">Звучни систем 7.1</string>
+  <string name="exo_track_role_alternate">Алтернативно</string>
+  <string name="exo_track_role_supplementary">Додатно</string>
+  <string name="exo_track_role_commentary">Коментар</string>
+  <string name="exo_track_role_closed_captions">Титл</string>
   <string name="exo_track_bitrate">%1$.2f Mb/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sv/strings.xml b/library/ui/src/main/res/values-sv/strings.xml
index 38daddb507..7af95a4632 100644
--- a/library/ui/src/main/res/values-sv/strings.xml
+++ b/library/ui/src/main/res/values-sv/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Upprepa alla</string>
   <string name="exo_controls_shuffle_description">Blanda spår</string>
   <string name="exo_controls_fullscreen_description">Helskärmsläge</string>
+  <string name="exo_controls_vr_description">VR-läge</string>
   <string name="exo_download_description">Ladda ned</string>
   <string name="exo_download_notification_channel_name">Nedladdningar</string>
   <string name="exo_download_downloading">Laddar ned</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surroundljud</string>
   <string name="exo_track_surround_5_point_1">5.1-kanaligt surroundljud</string>
   <string name="exo_track_surround_7_point_1">7.1-kanaligt surroundljud</string>
+  <string name="exo_track_role_alternate">Alternativ</string>
+  <string name="exo_track_role_supplementary">Tillägg</string>
+  <string name="exo_track_role_commentary">Kommentar</string>
+  <string name="exo_track_role_closed_captions">Undertexter</string>
   <string name="exo_track_bitrate">%1$.2f Mbit/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sw/strings.xml b/library/ui/src/main/res/values-sw/strings.xml
index 2c7268626f..1cdd325278 100644
--- a/library/ui/src/main/res/values-sw/strings.xml
+++ b/library/ui/src/main/res/values-sw/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Rudia zote</string>
   <string name="exo_controls_shuffle_description">Changanya</string>
   <string name="exo_controls_fullscreen_description">Hali ya skrini nzima</string>
+  <string name="exo_controls_vr_description">Hali ya Uhalisia Pepe</string>
   <string name="exo_download_description">Pakua</string>
   <string name="exo_download_notification_channel_name">Vipakuliwa</string>
   <string name="exo_download_downloading">Inapakua</string>
@@ -20,7 +21,7 @@
   <string name="exo_download_removing">Inaondoa vipakuliwa</string>
   <string name="exo_track_selection_title_video">Video</string>
   <string name="exo_track_selection_title_audio">Sauti</string>
-  <string name="exo_track_selection_title_text">SMS</string>
+  <string name="exo_track_selection_title_text">Maandishi</string>
   <string name="exo_track_selection_none">Hamna</string>
   <string name="exo_track_selection_auto">Otomatiki</string>
   <string name="exo_track_unknown">Haijulikani</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Sauti ya mzunguko</string>
   <string name="exo_track_surround_5_point_1">Sauti ya mzunguko ya 5.1</string>
   <string name="exo_track_surround_7_point_1">Sauti ya mzunguko ya 7.1</string>
+  <string name="exo_track_role_alternate">Mbadala</string>
+  <string name="exo_track_role_supplementary">Wa ziada</string>
+  <string name="exo_track_role_commentary">Uchambuzi</string>
+  <string name="exo_track_role_closed_captions">Manukuu</string>
   <string name="exo_track_bitrate">Mbps %1$.2f</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ta/strings.xml b/library/ui/src/main/res/values-ta/strings.xml
index 14a0203e06..2b2b9e13d6 100644
--- a/library/ui/src/main/res/values-ta/strings.xml
+++ b/library/ui/src/main/res/values-ta/strings.xml
@@ -10,8 +10,9 @@
   <string name="exo_controls_repeat_off_description">எதையும் மீண்டும் இயக்காதே</string>
   <string name="exo_controls_repeat_one_description">இதை மட்டும் மீண்டும் இயக்கு</string>
   <string name="exo_controls_repeat_all_description">அனைத்தையும் மீண்டும் இயக்கு</string>
-  <string name="exo_controls_shuffle_description">கலைத்துப் போடு</string>
+  <string name="exo_controls_shuffle_description">வரிசை மாற்றி இயக்கு</string>
   <string name="exo_controls_fullscreen_description">முழுத்திரைப் பயன்முறை</string>
+  <string name="exo_controls_vr_description">VR பயன்முறை</string>
   <string name="exo_download_description">பதிவிறக்கும் பட்டன்</string>
   <string name="exo_download_notification_channel_name">பதிவிறக்கங்கள்</string>
   <string name="exo_download_downloading">பதிவிறக்குகிறது</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">சரவுண்ட் சவுண்ட்</string>
   <string name="exo_track_surround_5_point_1">5.1 சரவுண்ட் சவுண்ட்</string>
   <string name="exo_track_surround_7_point_1">7.1 சரவுண்ட் சவுண்ட்</string>
+  <string name="exo_track_role_alternate">மாற்று டிராக்</string>
+  <string name="exo_track_role_supplementary">துணை டிராக்</string>
+  <string name="exo_track_role_commentary">வர்ணனை</string>
+  <string name="exo_track_role_closed_captions">வசனம்</string>
   <string name="exo_track_bitrate">%1$.2f மெ.பை./வி</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-te/strings.xml b/library/ui/src/main/res/values-te/strings.xml
index 7e3f32a039..ea344b0345 100644
--- a/library/ui/src/main/res/values-te/strings.xml
+++ b/library/ui/src/main/res/values-te/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">అన్నింటినీ పునరావృతం చేయండి</string>
   <string name="exo_controls_shuffle_description">షఫుల్ చేయండి</string>
   <string name="exo_controls_fullscreen_description">పూర్తి స్క్రీన్ మోడ్</string>
+  <string name="exo_controls_vr_description">వర్చువల్ రియాలిటీ మోడ్</string>
   <string name="exo_download_description">డౌన్‌లోడ్ చేయి</string>
   <string name="exo_download_notification_channel_name">డౌన్‌లోడ్‌లు</string>
   <string name="exo_download_downloading">డౌన్‌లోడ్ చేస్తోంది</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">సరౌండ్ ధ్వని</string>
   <string name="exo_track_surround_5_point_1">5.1 సరౌండ్ ధ్వని</string>
   <string name="exo_track_surround_7_point_1">7.1 సరౌండ్ ధ్వని</string>
+  <string name="exo_track_role_alternate">ప్రత్యామ్నాయం</string>
+  <string name="exo_track_role_supplementary">అనుబంధితం</string>
+  <string name="exo_track_role_commentary">వ్యాఖ్యానం</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-th/strings.xml b/library/ui/src/main/res/values-th/strings.xml
index 85c4f8cf92..3cd933ccf1 100644
--- a/library/ui/src/main/res/values-th/strings.xml
+++ b/library/ui/src/main/res/values-th/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">เล่นซ้ำทั้งหมด</string>
   <string name="exo_controls_shuffle_description">สุ่ม</string>
   <string name="exo_controls_fullscreen_description">โหมดเต็มหน้าจอ</string>
+  <string name="exo_controls_vr_description">โหมด VR</string>
   <string name="exo_download_description">ดาวน์โหลด</string>
   <string name="exo_download_notification_channel_name">ดาวน์โหลด</string>
   <string name="exo_download_downloading">กำลังดาวน์โหลด</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">เสียงเซอร์ราวด์</string>
   <string name="exo_track_surround_5_point_1">ระบบเสียง 5.1 เซอร์ราวด์</string>
   <string name="exo_track_surround_7_point_1">7.1 เสียงเซอร์ราวด์</string>
+  <string name="exo_track_role_alternate">อื่นๆ</string>
+  <string name="exo_track_role_supplementary">แทร็กเสริม</string>
+  <string name="exo_track_role_commentary">ความคิดเห็น</string>
+  <string name="exo_track_role_closed_captions">คำบรรยาย</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-tl/strings.xml b/library/ui/src/main/res/values-tl/strings.xml
index dfad2c1b08..21852c5011 100644
--- a/library/ui/src/main/res/values-tl/strings.xml
+++ b/library/ui/src/main/res/values-tl/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Ulitin lahat</string>
   <string name="exo_controls_shuffle_description">I-shuffle</string>
   <string name="exo_controls_fullscreen_description">Fullscreen mode</string>
+  <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">I-download</string>
   <string name="exo_download_notification_channel_name">Mga Download</string>
   <string name="exo_download_downloading">Nagda-download</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround sound</string>
   <string name="exo_track_surround_5_point_1">5.1 na surround sound</string>
   <string name="exo_track_surround_7_point_1">7.1 na surround sound</string>
+  <string name="exo_track_role_alternate">Alternatibo</string>
+  <string name="exo_track_role_supplementary">Karagdagan</string>
+  <string name="exo_track_role_commentary">Komentaryo</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-tr/strings.xml b/library/ui/src/main/res/values-tr/strings.xml
index cacb60c5a5..2fbf36514f 100644
--- a/library/ui/src/main/res/values-tr/strings.xml
+++ b/library/ui/src/main/res/values-tr/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Tümünü tekrarla</string>
   <string name="exo_controls_shuffle_description">Karıştır</string>
   <string name="exo_controls_fullscreen_description">Tam ekran modu</string>
+  <string name="exo_controls_vr_description">VR modu</string>
   <string name="exo_download_description">İndir</string>
   <string name="exo_download_notification_channel_name">İndirilenler</string>
   <string name="exo_download_downloading">İndiriliyor</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Surround ses</string>
   <string name="exo_track_surround_5_point_1">5.1 surround ses</string>
   <string name="exo_track_surround_7_point_1">7.1 surround ses</string>
+  <string name="exo_track_role_alternate">Alternatif</string>
+  <string name="exo_track_role_supplementary">Ek kanal</string>
+  <string name="exo_track_role_commentary">Anlatım</string>
+  <string name="exo_track_role_closed_captions">Altyazı</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-uk/strings.xml b/library/ui/src/main/res/values-uk/strings.xml
index ecf6c8745e..5d338b61af 100644
--- a/library/ui/src/main/res/values-uk/strings.xml
+++ b/library/ui/src/main/res/values-uk/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Повторити всі</string>
   <string name="exo_controls_shuffle_description">Перемішати</string>
   <string name="exo_controls_fullscreen_description">Повноекранний режим</string>
+  <string name="exo_controls_vr_description">Режим віртуальної реальності</string>
   <string name="exo_download_description">Завантажити</string>
   <string name="exo_download_notification_channel_name">Завантаження</string>
   <string name="exo_download_downloading">Завантажується</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Об’ємний звук</string>
   <string name="exo_track_surround_5_point_1">Об’ємний звук у форматі 5.1</string>
   <string name="exo_track_surround_7_point_1">Об’ємний звук у форматі 7.1</string>
+  <string name="exo_track_role_alternate">Альтернативна</string>
+  <string name="exo_track_role_supplementary">Додаткова</string>
+  <string name="exo_track_role_commentary">Коментарі</string>
+  <string name="exo_track_role_closed_captions">Субтитри</string>
   <string name="exo_track_bitrate">%1$.2f Мбіт/с</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ur/strings.xml b/library/ui/src/main/res/values-ur/strings.xml
index fbc18fa347..aa98b0728e 100644
--- a/library/ui/src/main/res/values-ur/strings.xml
+++ b/library/ui/src/main/res/values-ur/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">سبھی کو دہرائیں</string>
   <string name="exo_controls_shuffle_description">شفل کریں</string>
   <string name="exo_controls_fullscreen_description">پوری اسکرین والی وضع</string>
+  <string name="exo_controls_vr_description">VR موڈ</string>
   <string name="exo_download_description">ڈاؤن لوڈ کریں</string>
   <string name="exo_download_notification_channel_name">ڈاؤن لوڈز</string>
   <string name="exo_download_downloading">ڈاؤن لوڈ ہو رہا ہے</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">محیط آواز</string>
   <string name="exo_track_surround_5_point_1">5.1 محیط آواز</string>
   <string name="exo_track_surround_7_point_1">7.1 محیط آواز</string>
+  <string name="exo_track_role_alternate">متبادل</string>
+  <string name="exo_track_role_supplementary">اضافی</string>
+  <string name="exo_track_role_commentary">تبصرہ</string>
+  <string name="exo_track_role_closed_captions">سب ٹائٹلز</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s، %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-uz/strings.xml b/library/ui/src/main/res/values-uz/strings.xml
index 5c9a05d259..2dcf5a518d 100644
--- a/library/ui/src/main/res/values-uz/strings.xml
+++ b/library/ui/src/main/res/values-uz/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Hammasini takrorlash</string>
   <string name="exo_controls_shuffle_description">Aralash</string>
   <string name="exo_controls_fullscreen_description">Butun ekran rejimi</string>
+  <string name="exo_controls_vr_description">VR rejimi</string>
   <string name="exo_download_description">Yuklab olish</string>
   <string name="exo_download_notification_channel_name">Yuklanmalar</string>
   <string name="exo_download_downloading">Yuklab olinmoqda</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Qamrovli ovoz</string>
   <string name="exo_track_surround_5_point_1">5.1 qamrovli ovoz</string>
   <string name="exo_track_surround_7_point_1">7.1 qamrovli ovoz</string>
+  <string name="exo_track_role_alternate">Muqobil</string>
+  <string name="exo_track_role_supplementary">Qoʻshimcha</string>
+  <string name="exo_track_role_commentary">Sharh</string>
+  <string name="exo_track_role_closed_captions">Taglavhalar</string>
   <string name="exo_track_bitrate">%1$.2f Mbit/s</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-vi/strings.xml b/library/ui/src/main/res/values-vi/strings.xml
index 65c9cb52a3..1cdb249ef0 100644
--- a/library/ui/src/main/res/values-vi/strings.xml
+++ b/library/ui/src/main/res/values-vi/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Lặp lại tất cả</string>
   <string name="exo_controls_shuffle_description">Phát ngẫu nhiên</string>
   <string name="exo_controls_fullscreen_description">Chế độ toàn màn hình</string>
+  <string name="exo_controls_vr_description">Chế độ thực tế ảo</string>
   <string name="exo_download_description">Tải xuống</string>
   <string name="exo_download_notification_channel_name">Tài nguyên đã tải xuống</string>
   <string name="exo_download_downloading">Đang tải xuống</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Âm thanh vòm</string>
   <string name="exo_track_surround_5_point_1">Âm thanh vòm 5.1</string>
   <string name="exo_track_surround_7_point_1">Âm thanh vòm 7.1</string>
+  <string name="exo_track_role_alternate">Thay thế</string>
+  <string name="exo_track_role_supplementary">Bổ sung</string>
+  <string name="exo_track_role_commentary">Bình luận</string>
+  <string name="exo_track_role_closed_captions">Phụ đề</string>
   <string name="exo_track_bitrate">%1$.2f Mb/giây</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rCN/strings.xml b/library/ui/src/main/res/values-zh-rCN/strings.xml
index e75697621c..fe21669ea4 100644
--- a/library/ui/src/main/res/values-zh-rCN/strings.xml
+++ b/library/ui/src/main/res/values-zh-rCN/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">全部重复播放</string>
   <string name="exo_controls_shuffle_description">随机播放</string>
   <string name="exo_controls_fullscreen_description">全屏模式</string>
+  <string name="exo_controls_vr_description">VR 模式</string>
   <string name="exo_download_description">下载</string>
   <string name="exo_download_notification_channel_name">下载内容</string>
   <string name="exo_download_downloading">正在下载</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">环绕声</string>
   <string name="exo_track_surround_5_point_1">5.1 环绕声</string>
   <string name="exo_track_surround_7_point_1">7.1 环绕声</string>
+  <string name="exo_track_role_alternate">替用轨</string>
+  <string name="exo_track_role_supplementary">补充轨</string>
+  <string name="exo_track_role_commentary">旁白</string>
+  <string name="exo_track_role_closed_captions">字幕</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s，%2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rHK/strings.xml b/library/ui/src/main/res/values-zh-rHK/strings.xml
index e65831ad9f..56e0a1a53b 100644
--- a/library/ui/src/main/res/values-zh-rHK/strings.xml
+++ b/library/ui/src/main/res/values-zh-rHK/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">全部重複播放</string>
   <string name="exo_controls_shuffle_description">隨機播放</string>
   <string name="exo_controls_fullscreen_description">全螢幕模式</string>
+  <string name="exo_controls_vr_description">虛擬現實模式</string>
   <string name="exo_download_description">下載</string>
   <string name="exo_download_notification_channel_name">下載內容</string>
   <string name="exo_download_downloading">正在下載</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">環迴立體聲</string>
   <string name="exo_track_surround_5_point_1">5.1 環迴立體聲</string>
   <string name="exo_track_surround_7_point_1">7.1 環迴立體聲</string>
+  <string name="exo_track_role_alternate">其他</string>
+  <string name="exo_track_role_supplementary">附加</string>
+  <string name="exo_track_role_commentary">評論</string>
+  <string name="exo_track_role_closed_captions">字幕</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s、%2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rTW/strings.xml b/library/ui/src/main/res/values-zh-rTW/strings.xml
index b817f189fb..7b29f7924e 100644
--- a/library/ui/src/main/res/values-zh-rTW/strings.xml
+++ b/library/ui/src/main/res/values-zh-rTW/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">重複播放所有項目</string>
   <string name="exo_controls_shuffle_description">隨機播放</string>
   <string name="exo_controls_fullscreen_description">全螢幕模式</string>
+  <string name="exo_controls_vr_description">虛擬實境模式</string>
   <string name="exo_download_description">下載</string>
   <string name="exo_download_notification_channel_name">下載</string>
   <string name="exo_download_downloading">下載中</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">環繞音效</string>
   <string name="exo_track_surround_5_point_1">5.1 環繞音效</string>
   <string name="exo_track_surround_7_point_1">7.1 環繞音效</string>
+  <string name="exo_track_role_alternate">替用軌</string>
+  <string name="exo_track_role_supplementary">補充軌</string>
+  <string name="exo_track_role_commentary">旁白</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s、%2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zu/strings.xml b/library/ui/src/main/res/values-zu/strings.xml
index 0b78b7d1fa..83cf9b2e97 100644
--- a/library/ui/src/main/res/values-zu/strings.xml
+++ b/library/ui/src/main/res/values-zu/strings.xml
@@ -12,6 +12,7 @@
   <string name="exo_controls_repeat_all_description">Phinda konke</string>
   <string name="exo_controls_shuffle_description">Shova</string>
   <string name="exo_controls_fullscreen_description">Imodi yesikrini esigcwele</string>
+  <string name="exo_controls_vr_description">Inqubo ye-VR</string>
   <string name="exo_download_description">Landa</string>
   <string name="exo_download_notification_channel_name">Ukulandwa</string>
   <string name="exo_download_downloading">Iyalanda</string>
@@ -30,6 +31,10 @@
   <string name="exo_track_surround">Umsindo ozungelezile</string>
   <string name="exo_track_surround_5_point_1">Umsindo ozungelezile ongu-5.1</string>
   <string name="exo_track_surround_7_point_1">Umsindo ozungelezile ongu-7.1</string>
+  <string name="exo_track_role_alternate">Okunye</string>
+  <string name="exo_track_role_supplementary">Okungeziwe</string>
+  <string name="exo_track_role_commentary">Abahlaziyi</string>
+  <string name="exo_track_role_closed_captions">CC</string>
   <string name="exo_track_bitrate">%1$.2f Mbps</string>
   <string name="exo_item_list">%1$s, %2$s</string>
 </resources>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index c13622f182..f4a7976ebd 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -42,6 +42,7 @@
     <flag name="all" value="2"/>
   </attr>
   <attr name="show_shuffle_button" format="boolean"/>
+  <attr name="time_bar_min_update_interval" format="integer"/>
 
   <declare-styleable name="PlayerView">
     <attr name="use_artwork" format="boolean"/>
@@ -66,6 +67,7 @@
     <attr name="fastforward_increment"/>
     <attr name="repeat_toggle_modes"/>
     <attr name="show_shuffle_button"/>
+    <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
   </declare-styleable>
 
@@ -79,6 +81,7 @@
     <attr name="fastforward_increment"/>
     <attr name="repeat_toggle_modes"/>
     <attr name="show_shuffle_button"/>
+    <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
   </declare-styleable>
 
diff --git a/library/ui/src/main/res/values/ids.xml b/library/ui/src/main/res/values/ids.xml
index 184e51ac58..e57301f946 100644
--- a/library/ui/src/main/res/values/ids.xml
+++ b/library/ui/src/main/res/values/ids.xml
@@ -21,6 +21,7 @@
   <item name="exo_artwork" type="id"/>
   <item name="exo_controller_placeholder" type="id"/>
   <item name="exo_controller" type="id"/>
+  <item name="exo_ad_overlay" type="id"/>
   <item name="exo_overlay" type="id"/>
   <item name="exo_play" type="id"/>
   <item name="exo_pause" type="id"/>
@@ -35,5 +36,6 @@
   <item name="exo_progress" type="id"/>
   <item name="exo_buffering" type="id"/>
   <item name="exo_error_message" type="id"/>
+  <item name="exo_vr" type="id"/>
 
 </resources>
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index d3befa2f43..bbb4aca8d5 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -38,6 +38,8 @@
   <string name="exo_controls_shuffle_description">Shuffle</string>
   <!-- Description for a media control button that toggles whether a video playback is fullscreen. [CHAR LIMIT=30] -->
   <string name="exo_controls_fullscreen_description">Fullscreen mode</string>
+  <!-- Description for a media control button that toggles whether a video playback is in VR mode. [CHAR LIMIT=30] -->
+  <string name="exo_controls_vr_description">VR mode</string>
   <!-- Description for a button that downloads a piece of media content onto the device. [CHAR LIMIT=20] -->
   <string name="exo_download_description">Download</string>
   <!-- Default name for a notification channel corresponding to media downloads. [CHAR LIMIT=40] -->
@@ -74,6 +76,14 @@
   <string name="exo_track_surround_5_point_1">5.1 surround sound</string>
   <!-- Describes a 7.1 (https://en.wikipedia.org/wiki/7.1_surround_sound) audio track. [CHAR LIMIT=40] -->
   <string name="exo_track_surround_7_point_1">7.1 surround sound</string>
+  <!-- Describes an alternate track, e.g. a video recorded from a different viewpoint. [CHAR LIMIT=40] -->
+  <string name="exo_track_role_alternate">Alternate</string>
+  <!-- Describes a supplementary track. [CHAR LIMIT=40] -->
+  <string name="exo_track_role_supplementary">Supplementary</string>
+  <!-- Describes a track containing commentary. [CHAR LIMIT=40] -->
+  <string name="exo_track_role_commentary">Commentary</string>
+  <!-- Describes a track with closed captions. [CHAR LIMIT=40] -->
+  <string name="exo_track_role_closed_captions">CC</string>
   <!-- Describes the bitrate of a media track in Megabits (https://en.wikipedia.org/wiki/Megabit) per second. [CHAR LIMIT=20] -->
   <string name="exo_track_bitrate"><xliff:g id="bitrate" example="5.2">%1$.2f</xliff:g> Mbps</string>
   <!-- Defines a way of appending an item to a list of items. For example appending "banana" to "apple, pear" to get "apple, pear, banana". Note: the command separator will appear between all consecutive list items, so do not use an equivalent of 'and'. [CHAR LIMIT=40] -->
diff --git a/library/ui/src/main/res/values/styles.xml b/library/ui/src/main/res/values/styles.xml
index b57cbeaddf..89d7a2fc8e 100644
--- a/library/ui/src/main/res/values/styles.xml
+++ b/library/ui/src/main/res/values/styles.xml
@@ -56,4 +56,9 @@
     <item name="android:contentDescription">@string/exo_controls_shuffle_description</item>
   </style>
 
+  <style name="ExoMediaButton.VR">
+    <item name="android:src">@drawable/exo_icon_vr</item>
+    <item name="android:contentDescription">@string/exo_controls_vr_description</item>
+  </style>
+
 </resources>
diff --git a/library/ui/src/test/AndroidManifest.xml b/library/ui/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..1a749dc82c
--- /dev/null
+++ b/library/ui/src/test/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest package="com.google.android.exoplayer2.source.ui.test" />
diff --git a/library/ui/src/test/java/com/google/android/exoplayer2/ui/spherical/CanvasRendererTest.java b/library/ui/src/test/java/com/google/android/exoplayer2/ui/spherical/CanvasRendererTest.java
new file mode 100644
index 0000000000..098f4157ef
--- /dev/null
+++ b/library/ui/src/test/java/com/google/android/exoplayer2/ui/spherical/CanvasRendererTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.graphics.PointF;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests for {@link CanvasRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public class CanvasRendererTest {
+
+  private static final float JUST_BELOW_45_DEGREES = (float) (Math.PI / 4 - 1.0E-08);
+  private static final float JUST_ABOVE_45_DEGREES = (float) (Math.PI / 4 + 1.0E-08);
+  private static final float TOLERANCE = .00001f;
+
+  @Test
+  public void testClicksOnCanvas() {
+    assertClick(translateClick(JUST_BELOW_45_DEGREES, JUST_BELOW_45_DEGREES), 0, 0);
+    assertClick(translateClick(JUST_BELOW_45_DEGREES, -JUST_BELOW_45_DEGREES), 0, 100);
+    assertClick(translateClick(0, 0), 50, 50);
+    assertClick(translateClick(-JUST_BELOW_45_DEGREES, JUST_BELOW_45_DEGREES), 100, 0);
+    assertClick(translateClick(-JUST_BELOW_45_DEGREES, -JUST_BELOW_45_DEGREES), 100, 100);
+  }
+
+  @Test
+  public void testClicksNotOnCanvas() {
+    assertThat(translateClick(JUST_ABOVE_45_DEGREES, JUST_ABOVE_45_DEGREES)).isNull();
+    assertThat(translateClick(JUST_ABOVE_45_DEGREES, -JUST_ABOVE_45_DEGREES)).isNull();
+    assertThat(translateClick(-JUST_ABOVE_45_DEGREES, JUST_ABOVE_45_DEGREES)).isNull();
+    assertThat(translateClick(-JUST_ABOVE_45_DEGREES, -JUST_ABOVE_45_DEGREES)).isNull();
+    assertThat(translateClick((float) (Math.PI / 2), 0)).isNull();
+    assertThat(translateClick(0, (float) Math.PI)).isNull();
+  }
+
+  private static PointF translateClick(float yaw, float pitch) {
+    return CanvasRenderer.internalTranslateClick(
+        yaw,
+        pitch,
+        /* xUnit= */ -1,
+        /* yUnit= */ -1,
+        /* widthUnit= */ 2,
+        /* heightUnit= */ 2,
+        /* widthPixel= */ 100,
+        /* heightPixel= */ 100);
+  }
+
+  private static void assertClick(@Nullable PointF actual, float expectedX, float expectedY) {
+    assertThat(actual).isNotNull();
+    assertThat(actual.x).isWithin(TOLERANCE).of(expectedX);
+    assertThat(actual.y).isWithin(TOLERANCE).of(expectedY);
+  }
+}
diff --git a/library/ui/src/test/java/com/google/android/exoplayer2/ui/spherical/TouchTrackerTest.java b/library/ui/src/test/java/com/google/android/exoplayer2/ui/spherical/TouchTrackerTest.java
new file mode 100644
index 0000000000..6212a74f30
--- /dev/null
+++ b/library/ui/src/test/java/com/google/android/exoplayer2/ui/spherical/TouchTrackerTest.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui.spherical;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.view.MotionEvent;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests for {@link TouchTracker}. */
+@RunWith(AndroidJUnit4.class)
+public class TouchTrackerTest {
+  private static final float EPSILON = 0.00001f;
+  private static final int SWIPE_PX = 100;
+  private static final float PX_PER_DEGREES = 25;
+
+  private TouchTracker tracker;
+  private float yaw;
+  private float pitch;
+  private float[] dummyMatrix;
+
+  private static void swipe(TouchTracker tracker, float x0, float y0, float x1, float y1) {
+    tracker.onTouch(null, MotionEvent.obtain(0, 0, MotionEvent.ACTION_DOWN, x0, y0, 0));
+    tracker.onTouch(null, MotionEvent.obtain(0, 0, MotionEvent.ACTION_MOVE, x1, y1, 0));
+    tracker.onTouch(null, MotionEvent.obtain(0, 0, MotionEvent.ACTION_UP, x1, y1, 0));
+  }
+
+  @Before
+  public void setUp() {
+    Context context = ApplicationProvider.getApplicationContext();
+    tracker =
+        new TouchTracker(
+            context,
+            scrollOffsetDegrees -> {
+              pitch = scrollOffsetDegrees.y;
+              yaw = scrollOffsetDegrees.x;
+            },
+            PX_PER_DEGREES);
+    dummyMatrix = new float[16];
+    tracker.onOrientationChange(dummyMatrix, 0);
+  }
+
+  @Test
+  public void testTap() {
+    // Tap is a noop.
+    swipe(tracker, 0, 0, 0, 0);
+    assertThat(yaw).isWithin(EPSILON).of(0);
+    assertThat(pitch).isWithin(EPSILON).of(0);
+  }
+
+  @Test
+  public void testBasicYaw() {
+    swipe(tracker, 0, 0, SWIPE_PX, 0);
+    assertThat(yaw).isWithin(EPSILON).of(-SWIPE_PX / PX_PER_DEGREES);
+    assertThat(pitch).isWithin(EPSILON).of(0);
+  }
+
+  @Test
+  public void testBigYaw() {
+    swipe(tracker, 0, 0, -10 * SWIPE_PX, 0);
+    assertThat(yaw).isEqualTo(10 * SWIPE_PX / PX_PER_DEGREES);
+    assertThat(pitch).isWithin(EPSILON).of(0);
+  }
+
+  @Test
+  public void testYawUnaffectedByPitch() {
+    swipe(tracker, 0, 0, 0, SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(0);
+
+    swipe(tracker, 0, 0, SWIPE_PX, SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(-SWIPE_PX / PX_PER_DEGREES);
+  }
+
+  @Test
+  public void testBasicPitch() {
+    swipe(tracker, 0, 0, 0, SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(0);
+    assertThat(pitch).isWithin(EPSILON).of(SWIPE_PX / PX_PER_DEGREES);
+  }
+
+  @Test
+  public void testPitchClipped() {
+    // Big reverse pitch should be clipped.
+    swipe(tracker, 0, 0, 0, -20 * SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(0);
+    assertThat(pitch).isEqualTo(-TouchTracker.MAX_PITCH_DEGREES);
+
+    // Big forward pitch should be clipped.
+    swipe(tracker, 0, 0, 0, 50 * SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(0);
+    assertThat(pitch).isEqualTo(TouchTracker.MAX_PITCH_DEGREES);
+  }
+
+  @Test
+  public void testWithRoll90() {
+    tracker.onOrientationChange(dummyMatrix, (float) Math.toRadians(90));
+
+    // Y-axis should now control yaw.
+    swipe(tracker, 0, 0, 0, 2 * SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(-2 * SWIPE_PX / PX_PER_DEGREES);
+
+    // X-axis should now control reverse pitch.
+    swipe(tracker, 0, 0, -3 * SWIPE_PX, 0);
+    assertThat(pitch).isWithin(EPSILON).of(3 * SWIPE_PX / PX_PER_DEGREES);
+  }
+
+  @Test
+  public void testWithRoll180() {
+    tracker.onOrientationChange(dummyMatrix, (float) Math.toRadians(180));
+
+    // X-axis should now control reverse yaw.
+    swipe(tracker, 0, 0, -2 * SWIPE_PX, 0);
+    assertThat(yaw).isWithin(EPSILON).of(-2 * SWIPE_PX / PX_PER_DEGREES);
+
+    // Y-axis should now control reverse pitch.
+    swipe(tracker, 0, 0, 0, -3 * SWIPE_PX);
+    assertThat(pitch).isWithin(EPSILON).of(3 * SWIPE_PX / PX_PER_DEGREES);
+  }
+
+  @Test
+  public void testWithRoll270() {
+    tracker.onOrientationChange(dummyMatrix, (float) Math.toRadians(270));
+
+    // Y-axis should now control reverse yaw.
+    swipe(tracker, 0, 0, 0, -2 * SWIPE_PX);
+    assertThat(yaw).isWithin(EPSILON).of(-2 * SWIPE_PX / PX_PER_DEGREES);
+
+    // X-axis should now control pitch.
+    swipe(tracker, 0, 0, 3 * SWIPE_PX, 0);
+    assertThat(pitch).isWithin(EPSILON).of(3 * SWIPE_PX / PX_PER_DEGREES);
+  }
+}
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index fe16d3b2c7..dd5cfa64a7 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -28,12 +27,14 @@ android {
         targetSdkVersion project.ext.targetSdkVersion
         testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
-    androidTestImplementation 'androidx.test:rules:' + testRunnerVersion
-    androidTestImplementation 'androidx.test:runner:' + testRunnerVersion
-    androidTestImplementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    androidTestImplementation 'androidx.test:rules:' + androidXTestVersion
+    androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
+    androidTestImplementation 'androidx.annotation:annotation:1.0.2'
     androidTestImplementation project(modulePrefix + 'library-core')
     androidTestImplementation project(modulePrefix + 'library-dash')
     androidTestImplementation project(modulePrefix + 'library-hls')
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
index 4165a42568..be71884846 100644
--- a/playbacktests/src/androidTest/AndroidManifest.xml
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -21,6 +21,7 @@
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
+  <uses-sdk/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
index 1832e16a98..a01ab3a250 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
@@ -15,10 +15,8 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import static androidx.test.InstrumentationRegistry.getInstrumentation;
-
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.rule.ActivityTestRule;
-import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.testutil.ActionSchedule;
 import com.google.android.exoplayer2.testutil.HostActivity;
@@ -52,7 +50,7 @@
   @Before
   public void setUp() {
     testRunner =
-        new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation())
+        new DashTestRunner(TAG, testRule.getActivity())
             .setWidevineInfo(MimeTypes.VIDEO_H264, false)
             .setActionSchedule(ACTION_SCHEDULE_WITH_SEEKS)
             .setAudioVideoFormats(ID_AUDIO, IDS_VIDEO)
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
index 0dd05e7fd3..f5af2472c9 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
@@ -15,12 +15,11 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import static androidx.test.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.rule.ActivityTestRule;
-import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.dash.DashUtil;
@@ -64,7 +63,7 @@
   @Before
   public void setUp() throws Exception {
     testRunner =
-        new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation())
+        new DashTestRunner(TAG, testRule.getActivity())
             .setManifestUrl(DashTestData.H264_MANIFEST)
             .setFullPlaybackNoSeeking(true)
             .setCanIncludeAdditionalVideoFormats(false)
@@ -89,12 +88,8 @@ public void tearDown() {
 
   @Test
   public void testDownload() throws Exception {
-    if (Util.SDK_INT < 16) {
-      return; // Pass.
-    }
-
     DashDownloader dashDownloader = downloadContent();
-    dashDownloader.download();
+    dashDownloader.download(/* progressListener= */ null);
 
     testRunner
         .setStreamName("test_h264_fixed_download")
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
index 9a54ffd07c..598138126b 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
@@ -15,11 +15,10 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import static androidx.test.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.rule.ActivityTestRule;
-import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
@@ -91,7 +90,7 @@
 
   @Before
   public void setUp() {
-    testRunner = new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation());
+    testRunner = new DashTestRunner(TAG, testRule.getActivity());
   }
 
   @After
@@ -103,10 +102,6 @@ public void tearDown() {
 
   @Test
   public void testH264Fixed() {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
     testRunner
         .setStreamName("test_h264_fixed")
         .setManifestUrl(DashTestData.H264_MANIFEST)
@@ -118,7 +113,7 @@ public void testH264Fixed() {
 
   @Test
   public void testH264Adaptive() throws DecoderQueryException {
-    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
+    if (shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
     }
@@ -134,7 +129,7 @@ public void testH264Adaptive() throws DecoderQueryException {
 
   @Test
   public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
-    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
+    if (shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
     }
@@ -152,7 +147,7 @@ public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
 
   @Test
   public void testH264AdaptiveWithRendererDisabling() throws DecoderQueryException {
-    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
+    if (shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
     }
@@ -633,11 +628,9 @@ public void testWidevine29FpsH264FixedV23() throws DecoderQueryException {
 
   @Test
   public void testDecoderInfoH264() throws DecoderQueryException {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
-    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H264, false);
+    MediaCodecInfo decoderInfo =
+        MediaCodecUtil.getDecoderInfo(
+            MimeTypes.VIDEO_H264, /* secure= */ false, /* tunneling= */ false);
     assertThat(decoderInfo).isNotNull();
     assertThat(Util.SDK_INT < 21 || decoderInfo.adaptive).isTrue();
   }
@@ -648,7 +641,11 @@ public void testDecoderInfoH265V24() throws DecoderQueryException {
       // Pass.
       return;
     }
-    assertThat(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H265, false).adaptive).isTrue();
+    assertThat(
+            MediaCodecUtil.getDecoderInfo(
+                    MimeTypes.VIDEO_H265, /* secure= */ false, /* tunneling= */ false)
+                .adaptive)
+        .isTrue();
   }
 
   @Test
@@ -657,13 +654,18 @@ public void testDecoderInfoVP9V24() throws DecoderQueryException {
       // Pass.
       return;
     }
-    assertThat(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_VP9, false).adaptive).isTrue();
+    assertThat(
+            MediaCodecUtil.getDecoderInfo(
+                    MimeTypes.VIDEO_VP9, /* secure= */ false, /* tunneling= */ false)
+                .adaptive)
+        .isTrue();
   }
 
   // Internal.
 
   private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQueryException {
-    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false);
+    MediaCodecInfo decoderInfo =
+        MediaCodecUtil.getDecoderInfo(mimeType, /* secure= */ false, /* tunneling= */ false);
     return decoderInfo == null || !decoderInfo.adaptive;
   }
 
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
index 1a43a70f25..b2a49a31fe 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -18,7 +18,6 @@
 import static com.google.android.exoplayer2.C.WIDEVINE_UUID;
 
 import android.annotation.TargetApi;
-import android.app.Instrumentation;
 import android.media.MediaDrm;
 import android.media.UnsupportedSchemeException;
 import android.net.Uri;
@@ -50,7 +49,6 @@
 import com.google.android.exoplayer2.testutil.HostActivity.HostedTest;
 import com.google.android.exoplayer2.testutil.MetricsLogger;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.FixedTrackSelection;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.RandomTrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -73,9 +71,6 @@
 
   private static final long TEST_TIMEOUT_MS = 5 * 60 * 1000;
 
-  private static final String REPORT_NAME = "GtsExoPlayerTestCases";
-  private static final String REPORT_OBJECT_NAME = "playbacktest";
-
   // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
   // if the device advertises support for them.
   private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 24;
@@ -93,7 +88,6 @@
 
   private final String tag;
   private final HostActivity activity;
-  private final Instrumentation instrumentation;
 
   private String streamName;
   private boolean fullPlaybackNoSeeking;
@@ -112,7 +106,8 @@ public static boolean isL1WidevineAvailable(String mimeType) {
     if (Util.SDK_INT >= 18) {
       try {
         // Force L3 if secure decoder is not available.
-        if (MediaCodecUtil.getDecoderInfo(mimeType, true) == null) {
+        if (MediaCodecUtil.getDecoderInfo(mimeType, /* secure= */ true, /* tunneling= */ false)
+            == null) {
           return false;
         }
         MediaDrm mediaDrm = MediaDrmBuilder.build();
@@ -126,10 +121,9 @@ public static boolean isL1WidevineAvailable(String mimeType) {
     return false;
   }
 
-  public DashTestRunner(String tag, HostActivity activity, Instrumentation instrumentation) {
+  public DashTestRunner(String tag, HostActivity activity) {
     this.tag = tag;
     this.activity = activity;
-    this.instrumentation = instrumentation;
   }
 
   public DashTestRunner setStreamName(String streamName) {
@@ -183,20 +177,18 @@ public DashTestRunner setDataSourceFactory(DataSource.Factory dataSourceFactory)
   }
 
   public void run() {
-    DashHostedTest test = createDashHostedTest(canIncludeAdditionalVideoFormats, false,
-        instrumentation);
+    DashHostedTest test = createDashHostedTest(canIncludeAdditionalVideoFormats, false);
     activity.runTest(test, TEST_TIMEOUT_MS);
     // Retry test exactly once if adaptive test fails due to excessive dropped buffers when
     // playing non-CDD required formats (b/28220076).
     if (test.needsCddLimitedRetry) {
-      activity.runTest(createDashHostedTest(false, true, instrumentation), TEST_TIMEOUT_MS);
+      activity.runTest(createDashHostedTest(false, true), TEST_TIMEOUT_MS);
     }
   }
 
-  private DashHostedTest createDashHostedTest(boolean canIncludeAdditionalVideoFormats,
-      boolean isCddLimitedRetry, Instrumentation instrumentation) {
-    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(instrumentation, tag,
-        REPORT_NAME, REPORT_OBJECT_NAME);
+  private DashHostedTest createDashHostedTest(
+      boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry) {
+    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(tag);
     return new DashHostedTest(tag, streamName, manifestUrl, metricsLogger, fullPlaybackNoSeeking,
         audioFormat, canIncludeAdditionalVideoFormats, isCddLimitedRetry, actionSchedule,
         offlineLicenseKeySetId, widevineLicenseUrl, useL1Widevine, dataSourceFactory,
@@ -206,7 +198,6 @@ private DashHostedTest createDashHostedTest(boolean canIncludeAdditionalVideoFor
   /**
    * A {@link HostedTest} for DASH playback tests.
    */
-  @TargetApi(16)
   private static final class DashHostedTest extends ExoHostedTest {
 
     private final String streamName;
@@ -323,7 +314,7 @@ protected MediaSource buildSource(HostActivity host, String userAgent) {
     }
 
     @Override
-    protected void logMetrics(DecoderCounters audioCounters, DecoderCounters videoCounters) {
+    protected void onTestFinished(DecoderCounters audioCounters, DecoderCounters videoCounters) {
       metricsLogger.logMetric(MetricsLogger.KEY_TEST_NAME, streamName);
       metricsLogger.logMetric(MetricsLogger.KEY_IS_CDD_LIMITED_RETRY, isCddLimitedRetry);
       metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
@@ -335,10 +326,7 @@ protected void logMetrics(DecoderCounters audioCounters, DecoderCounters videoCo
       metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
           videoCounters.renderedOutputBufferCount);
       metricsLogger.close();
-    }
 
-    @Override
-    protected void assertPassed(DecoderCounters audioCounters, DecoderCounters videoCounters) {
       if (fullPlaybackNoSeeking) {
         // We shouldn't have skipped any output buffers.
         DecoderCountersUtil
@@ -372,7 +360,6 @@ protected void assertPassed(DecoderCounters audioCounters, DecoderCounters video
         }
       }
     }
-
   }
 
   private static final class DashTestTrackSelector extends DefaultTrackSelector {
@@ -386,6 +373,7 @@ protected void assertPassed(DecoderCounters audioCounters, DecoderCounters video
 
     private DashTestTrackSelector(String tag, String audioFormatId, String[] videoFormatIds,
         boolean canIncludeAdditionalVideoFormats) {
+      super(new RandomTrackSelection.Factory(/* seed= */ 0));
       this.tag = tag;
       this.audioFormatId = audioFormatId;
       this.videoFormatIds = videoFormatIds;
@@ -393,7 +381,7 @@ private DashTestTrackSelector(String tag, String audioFormatId, String[] videoFo
     }
 
     @Override
-    protected TrackSelection[] selectAllTracks(
+    protected TrackSelection.Definition[] selectAllTracks(
         MappedTrackInfo mappedTrackInfo,
         int[][][] rendererFormatSupports,
         int[] rendererMixedMimeTypeAdaptationSupports,
@@ -407,22 +395,22 @@ private DashTestTrackSelector(String tag, String audioFormatId, String[] videoFo
       TrackGroupArray audioTrackGroups = mappedTrackInfo.getTrackGroups(AUDIO_RENDERER_INDEX);
       Assertions.checkState(videoTrackGroups.length == 1);
       Assertions.checkState(audioTrackGroups.length == 1);
-      TrackSelection[] selections = new TrackSelection[mappedTrackInfo.getRendererCount()];
-      selections[VIDEO_RENDERER_INDEX] =
-          new RandomTrackSelection(
+      TrackSelection.Definition[] definitions =
+          new TrackSelection.Definition[mappedTrackInfo.getRendererCount()];
+      definitions[VIDEO_RENDERER_INDEX] =
+          new TrackSelection.Definition(
               videoTrackGroups.get(0),
               getVideoTrackIndices(
                   videoTrackGroups.get(0),
                   rendererFormatSupports[VIDEO_RENDERER_INDEX][0],
                   videoFormatIds,
-                  canIncludeAdditionalVideoFormats),
-              0 /* seed */);
-      selections[AUDIO_RENDERER_INDEX] =
-          new FixedTrackSelection(
+                  canIncludeAdditionalVideoFormats));
+      definitions[AUDIO_RENDERER_INDEX] =
+          new TrackSelection.Definition(
               audioTrackGroups.get(0), getTrackIndex(audioTrackGroups.get(0), audioFormatId));
       includedAdditionalVideoFormats =
-          selections[VIDEO_RENDERER_INDEX].length() > videoFormatIds.length;
-      return selections;
+          definitions[VIDEO_RENDERER_INDEX].tracks.length > videoFormatIds.length;
+      return definitions;
     }
 
     private int[] getVideoTrackIndices(
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
index 7beaafd143..efc6c011cc 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import static androidx.test.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
@@ -23,8 +22,8 @@
 import android.media.MediaDrm.MediaDrmStateException;
 import android.net.Uri;
 import android.util.Pair;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.rule.ActivityTestRule;
-import androidx.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
@@ -62,7 +61,7 @@
   @Before
   public void setUp() throws Exception {
     testRunner =
-        new DashTestRunner(TAG, testRule.getActivity(), getInstrumentation())
+        new DashTestRunner(TAG, testRule.getActivity())
             .setStreamName("test_widevine_h264_fixed_offline")
             .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
             .setWidevineInfo(MimeTypes.VIDEO_H264, true)
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java
index b9c513fe72..d256db8c30 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/EnumerateDecodersTest.java
@@ -15,13 +15,12 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import static androidx.test.InstrumentationRegistry.getInstrumentation;
 
 import android.media.MediaCodecInfo.AudioCapabilities;
 import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCodecInfo.VideoCapabilities;
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
@@ -41,16 +40,11 @@
 
   private static final String TAG = "EnumerateDecodersTest";
 
-  private static final String REPORT_NAME = "GtsExoPlayerTestCases";
-  private static final String REPORT_OBJECT_NAME = "enumeratedecoderstest";
-
   private MetricsLogger metricsLogger;
 
   @Before
   public void setUp() {
-    metricsLogger =
-        MetricsLogger.Factory.createDefault(
-            getInstrumentation(), TAG, REPORT_NAME, REPORT_OBJECT_NAME);
+    metricsLogger = MetricsLogger.Factory.createDefault(TAG);
   }
 
   @Test
@@ -88,12 +82,16 @@ public void testEnumerateDecoders() throws Exception {
   }
 
   private void enumerateDecoders(String mimeType) throws DecoderQueryException {
-    logDecoderInfos(mimeType, /* secure= */ false);
-    logDecoderInfos(mimeType, /* secure= */ true);
+    logDecoderInfos(mimeType, /* secure= */ false, /* tunneling= */ false);
+    logDecoderInfos(mimeType, /* secure= */ true, /* tunneling= */ false);
+    logDecoderInfos(mimeType, /* secure= */ false, /* tunneling= */ true);
+    logDecoderInfos(mimeType, /* secure= */ true, /* tunneling= */ true);
   }
 
-  private void logDecoderInfos(String mimeType, boolean secure) throws DecoderQueryException {
-    List<MediaCodecInfo> mediaCodecInfos = MediaCodecUtil.getDecoderInfos(mimeType, secure);
+  private void logDecoderInfos(String mimeType, boolean secure, boolean tunneling)
+      throws DecoderQueryException {
+    List<MediaCodecInfo> mediaCodecInfos =
+        MediaCodecUtil.getDecoderInfos(mimeType, secure, tunneling);
     for (MediaCodecInfo mediaCodecInfo : mediaCodecInfos) {
       CodecCapabilities capabilities = Assertions.checkNotNull(mediaCodecInfo.capabilities);
       metricsLogger.logMetric(
diff --git a/testutils/build.gradle b/testutils/build.gradle
index 2ef377ba5d..bdc26d5c19 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -34,12 +33,15 @@ android {
         // See: https://github.com/junit-team/junit4/pull/1187.
         disable 'InvalidPackage'
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
     api 'org.mockito:mockito-core:' + mockitoVersion
-    api 'com.google.truth:truth:' + truthVersion
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    api 'androidx.test.ext:junit:' + androidXTestVersion
+    api 'androidx.test.ext:truth:' + androidXTestVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
     implementation project(modulePrefix + 'library-core')
     implementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
     annotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index c988c0c172..f1fdfc42aa 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index 71f5fdeae1..7f688cacf7 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
index 627b5b72f3..70059114db 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
@@ -20,6 +20,7 @@
 import android.media.MediaCodec;
 import android.media.MediaCrypto;
 import android.os.Handler;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -37,23 +38,37 @@
 
 /**
  * A debug extension of {@link DefaultRenderersFactory}. Provides a video renderer that performs
- * video buffer timestamp assertions.
+ * video buffer timestamp assertions, and modifies the default value for {@link
+ * #setAllowedVideoJoiningTimeMs(long)} to be {@code 0}.
  */
-@TargetApi(16)
 public class DebugRenderersFactory extends DefaultRenderersFactory {
 
   public DebugRenderersFactory(Context context) {
-    super(context, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF, 0);
+    super(context);
+    setAllowedVideoJoiningTimeMs(0);
   }
 
   @Override
-  protected void buildVideoRenderers(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, long allowedVideoJoiningTimeMs,
-      Handler eventHandler, VideoRendererEventListener eventListener,
-      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
-    out.add(new DebugMediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
-        allowedVideoJoiningTimeMs, drmSessionManager, eventHandler, eventListener,
-        MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+  protected void buildVideoRenderers(
+      Context context,
+      @ExtensionRendererMode int extensionRendererMode,
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
+      long allowedVideoJoiningTimeMs,
+      ArrayList<Renderer> out) {
+    out.add(
+        new DebugMediaCodecVideoRenderer(
+            context,
+            mediaCodecSelector,
+            allowedVideoJoiningTimeMs,
+            drmSessionManager,
+            playClearSamplesWithoutKeys,
+            eventHandler,
+            eventListener,
+            MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
   }
 
   /**
@@ -72,12 +87,24 @@ protected void buildVideoRenderers(Context context,
     private int minimumInsertIndex;
     private boolean skipToPositionBeforeRenderingFirstFrame;
 
-    public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-        long allowedJoiningTimeMs, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-        Handler eventHandler, VideoRendererEventListener eventListener,
+    public DebugMediaCodecVideoRenderer(
+        Context context,
+        MediaCodecSelector mediaCodecSelector,
+        long allowedJoiningTimeMs,
+        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+        boolean playClearSamplesWithoutKeys,
+        Handler eventHandler,
+        VideoRendererEventListener eventListener,
         int maxDroppedFrameCountToNotify) {
-      super(context, mediaCodecSelector, allowedJoiningTimeMs, drmSessionManager, false,
-          eventHandler, eventListener, maxDroppedFrameCountToNotify);
+      super(
+          context,
+          mediaCodecSelector,
+          allowedJoiningTimeMs,
+          drmSessionManager,
+          playClearSamplesWithoutKeys,
+          eventHandler,
+          eventListener,
+          maxDroppedFrameCountToNotify);
     }
 
     @Override
@@ -105,9 +132,12 @@ protected void releaseCodec() {
     }
 
     @Override
-    protected void flushCodec() throws ExoPlaybackException {
-      super.flushCodec();
-      clearTimestamps();
+    protected boolean flushOrReleaseCodec() {
+      try {
+        return super.flushOrReleaseCodec();
+      } finally {
+        clearTimestamps();
+      }
     }
 
     @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
index 858d287196..63a761a5cf 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DummyMainThread.java
@@ -21,10 +21,17 @@
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
+import com.google.android.exoplayer2.util.Util;
+import java.util.concurrent.atomic.AtomicReference;
 
 /** Helper class to simulate main/UI thread in tests. */
 public final class DummyMainThread {
 
+  /** {@link Runnable} variant which can throw a checked exception. */
+  public interface TestRunnable {
+    void run() throws Exception;
+  }
+
   /** Default timeout value used for {@link #runOnMainThread(Runnable)}. */
   public static final int TIMEOUT_MS = 10000;
 
@@ -51,20 +58,53 @@ public void runOnMainThread(final Runnable runnable) {
    * Runs the provided {@link Runnable} on the main thread, blocking until execution completes or
    * until timeout milliseconds have passed.
    *
-   * @param timeoutMs the maximum time to wait in milliseconds.
+   * @param timeoutMs The maximum time to wait in milliseconds.
    * @param runnable The {@link Runnable} to run.
    */
   public void runOnMainThread(int timeoutMs, final Runnable runnable) {
+    runTestOnMainThread(timeoutMs, runnable::run);
+  }
+
+  /**
+   * Runs the provided {@link TestRunnable} on the main thread, blocking until execution completes
+   * or until {@link #TIMEOUT_MS} milliseconds have passed.
+   *
+   * @param runnable The {@link TestRunnable} to run.
+   */
+  public void runTestOnMainThread(final TestRunnable runnable) {
+    runTestOnMainThread(TIMEOUT_MS, runnable);
+  }
+
+  /**
+   * Runs the provided {@link TestRunnable} on the main thread, blocking until execution completes
+   * or until timeout milliseconds have passed.
+   *
+   * @param timeoutMs The maximum time to wait in milliseconds.
+   * @param runnable The {@link TestRunnable} to run.
+   */
+  public void runTestOnMainThread(int timeoutMs, final TestRunnable runnable) {
     if (Looper.myLooper() == handler.getLooper()) {
-      runnable.run();
+      try {
+        runnable.run();
+      } catch (Exception e) {
+        Util.sneakyThrow(e);
+      }
     } else {
-      final ConditionVariable finishedCondition = new ConditionVariable();
+      ConditionVariable finishedCondition = new ConditionVariable();
+      AtomicReference<Throwable> thrown = new AtomicReference<>();
       handler.post(
           () -> {
-            runnable.run();
+            try {
+              runnable.run();
+            } catch (Throwable t) {
+              thrown.set(t);
+            }
             finishedCondition.open();
           });
       assertThat(finishedCondition.block(timeoutMs)).isTrue();
+      if (thrown.get() != null) {
+        Util.sneakyThrow(thrown.get());
+      }
     }
   }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
index ad59ca7152..74c0d4bb43 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
@@ -74,7 +74,6 @@
   private SimpleExoPlayer player;
   private Surface surface;
   private ExoPlaybackException playerError;
-  private AnalyticsListener analyticsListener;
   private boolean playerWasPrepared;
 
   private boolean playing;
@@ -127,14 +126,6 @@ public final void setSchedule(ActionSchedule schedule) {
     }
   }
 
-  /** Sets an {@link AnalyticsListener} to listen for events during the test. */
-  public final void setAnalyticsListener(AnalyticsListener analyticsListener) {
-    this.analyticsListener = analyticsListener;
-    if (player != null) {
-      player.addAnalyticsListener(analyticsListener);
-    }
-  }
-
   // HostedTest implementation
 
   @Override
@@ -145,19 +136,16 @@ public final void onStart(HostActivity host, Surface surface) {
     String userAgent = "ExoPlayerPlaybackTests";
     DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = buildDrmSessionManager(userAgent);
     player = buildExoPlayer(host, surface, trackSelector, drmSessionManager);
-    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent)));
+    player.setPlayWhenReady(true);
     player.addAnalyticsListener(this);
     player.addAnalyticsListener(new EventLogger(trackSelector, tag));
-    if (analyticsListener != null) {
-      player.addAnalyticsListener(analyticsListener);
-    }
-    player.setPlayWhenReady(true);
-    actionHandler = Clock.DEFAULT.createHandler(Looper.myLooper(), /* callback= */ null);
     // Schedule any pending actions.
+    actionHandler = Clock.DEFAULT.createHandler(Looper.myLooper(), /* callback= */ null);
     if (pendingSchedule != null) {
       pendingSchedule.start(player, trackSelector, surface, actionHandler, /* callback= */ null);
       pendingSchedule = null;
     }
+    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent)));
   }
 
   @Override
@@ -172,10 +160,10 @@ public final boolean forceStop() {
 
   @Override
   public final void onFinished() {
+    onTestFinished(audioDecoderCounters, videoDecoderCounters);
     if (failOnPlayerError && playerError != null) {
       throw new Error(playerError);
     }
-    logMetrics(audioDecoderCounters, videoDecoderCounters);
     if (expectedPlayingTimeMs != EXPECTED_PLAYING_TIME_UNSET) {
       long playingTimeToAssertMs = expectedPlayingTimeMs == EXPECTED_PLAYING_TIME_MEDIA_DURATION_MS
           ? sourceDurationMs : expectedPlayingTimeMs;
@@ -189,8 +177,6 @@ public final void onFinished() {
                   && totalPlayingTimeMs <= maxAllowedActualPlayingTimeMs)
           .isTrue();
     }
-    // Make any additional assertions.
-    assertPassed(audioDecoderCounters, videoDecoderCounters);
   }
 
   // AnalyticsListener
@@ -251,12 +237,10 @@ private boolean stopTest() {
     return null;
   }
 
-  @SuppressWarnings("unused")
   protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
     return new DefaultTrackSelector(new AdaptiveTrackSelection.Factory());
   }
 
-  @SuppressWarnings("unused")
   protected SimpleExoPlayer buildExoPlayer(
       HostActivity host,
       Surface surface,
@@ -274,20 +258,13 @@ protected SimpleExoPlayer buildExoPlayer(
     return player;
   }
 
-  @SuppressWarnings("unused")
   protected abstract MediaSource buildSource(HostActivity host, String userAgent);
 
-  @SuppressWarnings("unused")
   protected void onPlayerErrorInternal(ExoPlaybackException error) {
     // Do nothing. Interested subclasses may override.
   }
 
-  protected void logMetrics(DecoderCounters audioCounters, DecoderCounters videoCounters) {
-    // Do nothing. Subclasses may override to log metrics.
+  protected void onTestFinished(DecoderCounters audioCounters, DecoderCounters videoCounters) {
+    // Do nothing. Subclasses may override to add clean-up and assertions.
   }
-
-  protected void assertPassed(DecoderCounters audioCounters, DecoderCounters videoCounters) {
-    // Do nothing. Subclasses may override to add additional assertions.
-  }
-
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
index b613f7f364..517f1ce2e7 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
@@ -20,7 +20,7 @@
 import android.content.Context;
 import android.os.HandlerThread;
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -287,7 +287,7 @@ public ExoPlayerTestRunner build(Context context) {
         trackSelector = new DefaultTrackSelector();
       }
       if (bandwidthMeter == null) {
-        bandwidthMeter = new DefaultBandwidthMeter.Builder().build();
+        bandwidthMeter = new DefaultBandwidthMeter.Builder(context).build();
       }
       if (renderersFactory == null) {
         if (renderers == null) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
index 1e4811aadf..3937dabcaf 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.content.Context;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -27,7 +28,6 @@
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
-import java.lang.reflect.Field;
 import java.util.Arrays;
 
 /**
@@ -35,22 +35,6 @@
  */
 public final class ExtractorAsserts {
 
-  private static Context robolectricContext;
-
-  static {
-    try {
-      Class<?> runtimeEnvironmentClass = Class.forName("org.robolectric.RuntimeEnvironment");
-      Field applicationField = runtimeEnvironmentClass.getDeclaredField("application");
-      robolectricContext = (Context) applicationField.get(null);
-    } catch (ClassNotFoundException e) {
-      // Keep Robolectric context at null if not found.
-    } catch (NoSuchFieldException e) {
-      // Keep Robolectric context at null if not found.
-    } catch (IllegalAccessException e) {
-      // Keep Robolectric context at null if not found.
-    }
-  }
-
   /**
    * A factory for {@link Extractor} instances.
    */
@@ -85,8 +69,8 @@ public static void assertBehavior(ExtractorFactory factory, String file)
     extractor.seek(0, 0);
     extractor.release();
     // Assert output.
-    byte[] fileData = TestUtil.getByteArray(robolectricContext, file);
-    assertOutput(factory, file, fileData, robolectricContext);
+    byte[] fileData = TestUtil.getByteArray(ApplicationProvider.getApplicationContext(), file);
+    assertOutput(factory, file, fileData, ApplicationProvider.getApplicationContext());
   }
 
   /**
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
index f8bf950ef2..1e3b3bf82b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
index 089528bfde..5a158a3659 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.source.MediaSource;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
index b5db0dc489..54c700933a 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.SeekParameters;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java
index e77e0714e7..77ae19f083 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
index f2739f2b4d..d524d381fa 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
@@ -20,7 +20,7 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.source.MediaPeriod;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
index 1f0c0c1a40..b89acae6c8 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
@@ -20,9 +20,8 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
@@ -96,10 +95,7 @@ public Object getTag() {
   }
 
   @Override
-  public synchronized void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public synchronized void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     assertThat(preparedSource).isFalse();
     transferListener = mediaTransferListener;
     preparedSource = true;
@@ -116,7 +112,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     assertThat(preparedSource).isTrue();
     assertThat(releasedSource).isFalse();
     int periodIndex = timeline.getIndexOfPeriod(id.periodUid);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
index 8b653f6642..a60c1c9c6d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 257b66a3d0..73e8ac4f3e 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -80,6 +80,7 @@
   }
 
   private static final String TAG = "HostActivity";
+  private static final String LOCK_TAG = "ExoPlayerTestUtil:" + TAG;
   private static final long START_TIMEOUT_MS = 5000;
 
   private WakeLock wakeLock;
@@ -99,7 +100,7 @@
    *     is exceeded then the test will fail.
    */
   public void runTest(HostedTest hostedTest, long timeoutMs) {
-    runTest(hostedTest, timeoutMs, true);
+    runTest(hostedTest, timeoutMs, /* failOnTimeoutOrForceStop= */ true);
   }
 
   /**
@@ -107,9 +108,11 @@ public void runTest(HostedTest hostedTest, long timeoutMs) {
    *
    * @param hostedTest The test to execute.
    * @param timeoutMs The number of milliseconds to wait for the test to finish.
-   * @param failOnTimeout Whether the test fails when the timeout is exceeded.
+   * @param failOnTimeoutOrForceStop Whether the test fails when a timeout is exceeded or the test
+   *     is stopped forcefully.
    */
-  public void runTest(final HostedTest hostedTest, long timeoutMs, boolean failOnTimeout) {
+  public void runTest(
+      final HostedTest hostedTest, long timeoutMs, boolean failOnTimeoutOrForceStop) {
     Assertions.checkArgument(timeoutMs > 0);
     Assertions.checkState(Thread.currentThread() != getMainLooper().getThread());
     Assertions.checkState(this.hostedTest == null);
@@ -128,7 +131,9 @@ public void runTest(final HostedTest hostedTest, long timeoutMs, boolean failOnT
       String message =
           "Test failed to start. Display may be turned off or keyguard may be present.";
       Log.e(TAG, message);
-      fail(message);
+      if (failOnTimeoutOrForceStop) {
+        fail(message);
+      }
     }
 
     if (hostedTest.blockUntilStopped(timeoutMs)) {
@@ -140,13 +145,15 @@ public void runTest(final HostedTest hostedTest, long timeoutMs, boolean failOnT
         String message = "Test force stopped. Activity may have been paused whilst "
             + "test was in progress.";
         Log.e(TAG, message);
-        fail(message);
+        if (failOnTimeoutOrForceStop) {
+          fail(message);
+        }
       }
     } else {
       runOnUiThread(hostedTest::forceStop);
       String message = "Test timed out after " + timeoutMs + " ms.";
       Log.e(TAG, message);
-      if (failOnTimeout) {
+      if (failOnTimeoutOrForceStop) {
         fail(message);
       }
     }
@@ -169,10 +176,10 @@ public void onCreate(Bundle savedInstanceState) {
   public void onStart() {
     Context appContext = getApplicationContext();
     WifiManager wifiManager = (WifiManager) appContext.getSystemService(Context.WIFI_SERVICE);
-    wifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, TAG);
+    wifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, LOCK_TAG);
     wifiLock.acquire();
     PowerManager powerManager = (PowerManager) appContext.getSystemService(Context.POWER_SERVICE);
-    wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
+    wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOCK_TAG);
     wakeLock.acquire();
     super.onStart();
   }
@@ -234,5 +241,4 @@ private void maybeStopHostedTest() {
       forcedStopped = hostedTest.forceStop();
     }
   }
-
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/MetricsLogger.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/MetricsLogger.java
index 64d1944927..9edccadcab 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/MetricsLogger.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/MetricsLogger.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.app.Instrumentation;
-
 /**
  * Metric Logging interface for ExoPlayer playback tests.
  */
@@ -76,13 +74,9 @@ private Factory() {}
     /**
      * Obtains a new instance of {@link MetricsLogger}.
      *
-     * @param instrumentation The test instrumentation.
      * @param tag The tag to be used for logcat logs.
-     * @param reportName The name of the report log.
-     * @param streamName The name of the stream of metrics.
      */
-    public static MetricsLogger createDefault(Instrumentation instrumentation, String tag,
-        String reportName, String streamName) {
+    public static MetricsLogger createDefault(String tag) {
       return new LogcatMetricsLogger(tag);
     }
   }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 3351e2db8d..facfa0d7e4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -19,11 +19,15 @@
 import static org.junit.Assert.fail;
 
 import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.Color;
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.database.DatabaseProvider;
+import com.google.android.exoplayer2.database.DefaultDatabaseProvider;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -155,6 +159,23 @@ public static Bitmap readBitmapFromFile(Context context, String fileName) throws
     return BitmapFactory.decodeStream(getInputStream(context, fileName));
   }
 
+  public static DatabaseProvider getTestDatabaseProvider() {
+    // Provides an in-memory database.
+    return new DefaultDatabaseProvider(
+        new SQLiteOpenHelper(
+            /* context= */ null, /* name= */ null, /* factory= */ null, /* version= */ 1) {
+          @Override
+          public void onCreate(SQLiteDatabase db) {
+            // Do nothing.
+          }
+
+          @Override
+          public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            // Do nothing.
+          }
+        });
+  }
+
   /**
    * Asserts that data read from a {@link DataSource} matches {@code expected}.
    *
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java
index 7fd84f6287..714c77f8d3 100644
--- a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -27,10 +28,9 @@
 import java.util.Random;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link FakeAdaptiveDataSet}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class FakeAdaptiveDataSetTest {
 
   private static final Format[] TEST_FORMATS = {
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
index 90e70e4538..65b0efa72a 100644
--- a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
@@ -19,17 +19,17 @@
 
 import android.os.ConditionVariable;
 import android.os.HandlerThread;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.HandlerWrapper;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 /** Unit test for {@link FakeClock}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 @Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
 public final class FakeClockTest {
 
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
index 99469295bb..0f7aabffc1 100644
--- a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
@@ -18,15 +18,15 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData.Segment;
 import java.io.IOException;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link FakeDataSet} */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class FakeDataSetTest {
 
   @Test
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java
index c88aba4e08..9af0c6e1ca 100644
--- a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java
@@ -19,6 +19,7 @@
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.IOException;
@@ -26,10 +27,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
 /** Unit test for {@link FakeDataSource}. */
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public final class FakeDataSourceTest {
 
   private static final String URI_STRING = "test://test.test";
diff --git a/testutils/src/test/resources/robolectric.properties b/testutils/src/test/resources/robolectric.properties
deleted file mode 100644
index 2f3210368e..0000000000
--- a/testutils/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-manifest=src/test/AndroidManifest.xml
diff --git a/testutils_robolectric/build.gradle b/testutils_robolectric/build.gradle
index 2d3317934b..a3859a9e48 100644
--- a/testutils_robolectric/build.gradle
+++ b/testutils_robolectric/build.gradle
@@ -16,7 +16,6 @@ apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
-    buildToolsVersion project.ext.buildToolsVersion
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -33,11 +32,14 @@ android {
         // which is not part of Android.
         disable 'InvalidPackage'
     }
+
+    testOptions.unitTests.includeAndroidResources = true
 }
 
 dependencies {
+    api 'androidx.test:core:' + androidXTestVersion
     api 'org.robolectric:robolectric:' + robolectricVersion
     api project(modulePrefix + 'testutils')
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'androidx.annotation:annotation:1.0.2'
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
index 6d3b15ac7a..664532d3ff 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
@@ -21,11 +21,12 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 
@@ -76,25 +77,13 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri...
     assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
   }
 
-  /**
-   * Asserts that the cache contains the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    for (Uri uri : uris) {
-      assertDataCached(cache, uri, fakeDataSet.getData(uri).getData());
-    }
-  }
-
   /**
    * Asserts that the cache contains the given data for {@code uriString}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
   public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    DataSpec dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+    DataSpec dataSpec = new DataSpec(uri);
     assertDataCached(cache, dataSpec, expected);
   }
 
@@ -117,13 +106,24 @@ public static void assertDataCached(Cache cache, DataSpec dataSpec, byte[] expec
     }
   }
 
-  /** Asserts that there is no cache content for the given {@code uriStrings}. */
-  public static void assertDataNotCached(Cache cache, String... uriStrings) {
-    for (String uriString : uriStrings) {
-      assertWithMessage("There is cached data for '" + uriString + "',")
-          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString))).isEmpty())
-          .isTrue();
+  /**
+   * Asserts that the read data from {@code dataSource} specified by {@code dataSpec} is equal to
+   * {@code expected} or not.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
+  public static void assertReadData(DataSource dataSource, DataSpec dataSpec, byte[] expected)
+      throws IOException {
+    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
+    byte[] bytes = null;
+    try {
+      bytes = Util.toByteArray(inputStream);
+    } catch (IOException e) {
+      // Ignore
+    } finally {
+      inputStream.close();
     }
+    assertThat(bytes).isEqualTo(expected);
   }
 
   /** Asserts that the cache is empty. */
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/DefaultRenderersFactoryAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/DefaultRenderersFactoryAsserts.java
new file mode 100644
index 0000000000..3720b8a0b3
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/DefaultRenderersFactoryAsserts.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.android.exoplayer2.DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF;
+import static com.google.android.exoplayer2.DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON;
+import static com.google.android.exoplayer2.DefaultRenderersFactory.EXTENSION_RENDERER_MODE_PREFER;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Handler;
+import android.os.Looper;
+import androidx.test.core.app.ApplicationProvider;
+import com.google.android.exoplayer2.DefaultRenderersFactory;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.util.List;
+
+/** Assertions for {@link DefaultRenderersFactory}. */
+public final class DefaultRenderersFactoryAsserts {
+
+  /**
+   * Asserts that an extension renderer of type {@code clazz} is not instantiated for {@link
+   * DefaultRenderersFactory#EXTENSION_RENDERER_MODE_OFF}, and that it's instantiated in the correct
+   * position relative to other renderers of the same type for {@link
+   * DefaultRenderersFactory#EXTENSION_RENDERER_MODE_ON} and {@link
+   * DefaultRenderersFactory#EXTENSION_RENDERER_MODE_PREFER}, assuming no other extension renderers
+   * can be loaded.
+   *
+   * @param clazz The extension renderer class.
+   * @param type The type of the renderer.
+   */
+  public static void assertExtensionRendererCreated(Class<? extends Renderer> clazz, int type) {
+    // In EXTENSION_RENDERER_MODE_OFF the renderer should not be created.
+    Renderer[] renderers = createRenderers(EXTENSION_RENDERER_MODE_OFF);
+    for (Renderer renderer : renderers) {
+      assertThat(renderer).isNotInstanceOf(clazz);
+    }
+
+    // In EXTENSION_RENDERER_MODE_ON the renderer should be created and last of its type.
+    renderers = createRenderers(EXTENSION_RENDERER_MODE_ON);
+    boolean found = false;
+    for (Renderer renderer : renderers) {
+      if (!found) {
+        if (clazz.isInstance(renderer)) {
+          found = true;
+        }
+      } else {
+        assertThat(renderer.getTrackType()).isNotEqualTo(type);
+      }
+    }
+    assertThat(found).isTrue();
+
+    // In EXTENSION_RENDERER_MODE_PREFER the renderer should be created and first of its type.
+    renderers = createRenderers(EXTENSION_RENDERER_MODE_PREFER);
+    found = false;
+    for (Renderer renderer : renderers) {
+      if (!found) {
+        if (clazz.isInstance(renderer)) {
+          found = true;
+        } else {
+          assertThat(renderer.getTrackType()).isNotEqualTo(type);
+        }
+      } else {
+        assertThat(renderer).isNotInstanceOf(clazz);
+      }
+    }
+    assertThat(found).isTrue();
+  }
+
+  private static Renderer[] createRenderers(
+      @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode) {
+    DefaultRenderersFactory factory =
+        new DefaultRenderersFactory(ApplicationProvider.getApplicationContext())
+            .setExtensionRendererMode(extensionRendererMode);
+    return factory.createRenderers(
+        new Handler(Looper.getMainLooper()),
+        new VideoRendererEventListener() {},
+        new AudioRendererEventListener() {},
+        (List<Cue> cues) -> {},
+        (Metadata metadata) -> {},
+        /* drmSessionManager= */ null);
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
new file mode 100644
index 0000000000..6669504c07
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSource;
+import java.io.IOException;
+
+/** Fake {@link MediaChunk}. */
+public final class FakeMediaChunk extends MediaChunk {
+
+  private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT", null);
+
+  public FakeMediaChunk(Format trackFormat, long startTimeUs, long endTimeUs) {
+    this(new DataSpec(Uri.EMPTY), trackFormat, startTimeUs, endTimeUs);
+  }
+
+  public FakeMediaChunk(DataSpec dataSpec, Format trackFormat, long startTimeUs, long endTimeUs) {
+    super(
+        DATA_SOURCE,
+        dataSpec,
+        trackFormat,
+        C.SELECTION_REASON_ADAPTIVE,
+        /* trackSelectionData= */ null,
+        startTimeUs,
+        endTimeUs,
+        /* chunkIndex= */ 0);
+  }
+
+  @Override
+  public void cancelLoad() {
+    // Do nothing.
+  }
+
+  @Override
+  public void load() throws IOException, InterruptedException {
+    // Do nothing.
+  }
+
+  @Override
+  public boolean isLoadCompleted() {
+    return true;
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunkIterator.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunkIterator.java
new file mode 100644
index 0000000000..6dce2b5428
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunkIterator.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.testutil;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.chunk.BaseMediaChunkIterator;
+import com.google.android.exoplayer2.upstream.DataSpec;
+
+/** Fake {@link com.google.android.exoplayer2.source.chunk.MediaChunkIterator}. */
+public final class FakeMediaChunkIterator extends BaseMediaChunkIterator {
+
+  private final long[] chunkTimeBoundariesSec;
+  private final long[] chunkLengths;
+
+  /**
+   * Creates a fake {@link com.google.android.exoplayer2.source.chunk.MediaChunkIterator}.
+   *
+   * @param chunkTimeBoundariesSec An array containing the time boundaries where one chunk ends and
+   *     the next one starts. The first value is the start time of the first chunk and the last
+   *     value is the end time of the last chunk. The array should be of length (chunk-count + 1).
+   * @param chunkLengths An array which contains the length of each chunk, should be of length
+   *     (chunk-count).
+   */
+  public FakeMediaChunkIterator(long[] chunkTimeBoundariesSec, long[] chunkLengths) {
+    super(/* fromIndex= */ 0, /* toIndex= */ chunkTimeBoundariesSec.length - 2);
+    this.chunkTimeBoundariesSec = chunkTimeBoundariesSec;
+    this.chunkLengths = chunkLengths;
+  }
+
+  @Override
+  public DataSpec getDataSpec() {
+    checkInBounds();
+    return new DataSpec(
+        Uri.EMPTY,
+        /* absoluteStreamPosition= */ 0,
+        chunkLengths[(int) getCurrentIndex()],
+        /* key= */ null);
+  }
+
+  @Override
+  public long getChunkStartTimeUs() {
+    checkInBounds();
+    return chunkTimeBoundariesSec[(int) getCurrentIndex()] * C.MICROS_PER_SECOND;
+  }
+
+  @Override
+  public long getChunkEndTimeUs() {
+    checkInBounds();
+    return chunkTimeBoundariesSec[(int) getCurrentIndex() + 1] * C.MICROS_PER_SECOND;
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
index d3eca63461..ac39ba8de6 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
@@ -15,21 +15,19 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.support.annotation.NonNull;
-import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import java.util.ArrayList;
 import java.util.List;
 
 /** A fake {@link MappingTrackSelector} that returns {@link FakeTrackSelection}s. */
 public class FakeTrackSelector extends DefaultTrackSelector {
 
-  private final List<FakeTrackSelection> trackSelections = new ArrayList<>();
-  private final boolean mayReuseTrackSelection;
+  private final FakeTrackSelectionFactory fakeTrackSelectionFactory;
 
   public FakeTrackSelector() {
     this(false);
@@ -41,43 +39,69 @@ public FakeTrackSelector() {
    *     using the same {@link TrackGroup}.
    */
   public FakeTrackSelector(boolean mayReuseTrackSelection) {
-    this.mayReuseTrackSelection = mayReuseTrackSelection;
+    this(new FakeTrackSelectionFactory(mayReuseTrackSelection));
+  }
+
+  private FakeTrackSelector(FakeTrackSelectionFactory fakeTrackSelectionFactory) {
+    super(fakeTrackSelectionFactory);
+    this.fakeTrackSelectionFactory = fakeTrackSelectionFactory;
   }
 
   @Override
-  protected TrackSelection[] selectAllTracks(
+  protected TrackSelection.Definition[] selectAllTracks(
       MappedTrackInfo mappedTrackInfo,
       int[][][] rendererFormatSupports,
       int[] rendererMixedMimeTypeAdaptationSupports,
-      Parameters params)
-      throws ExoPlaybackException {
+      Parameters params) {
     int rendererCount = mappedTrackInfo.getRendererCount();
-    TrackSelection[] selections = new TrackSelection[rendererCount];
+    TrackSelection.Definition[] definitions = new TrackSelection.Definition[rendererCount];
     for (int i = 0; i < rendererCount; i++) {
       TrackGroupArray trackGroupArray = mappedTrackInfo.getTrackGroups(i);
       boolean hasTracks = trackGroupArray.length > 0;
-      selections[i] = hasTracks ? reuseOrCreateTrackSelection(trackGroupArray.get(0)) : null;
+      definitions[i] = hasTracks ? new TrackSelection.Definition(trackGroupArray.get(0)) : null;
     }
-    return selections;
+    return definitions;
   }
 
-  @NonNull
-  private FakeTrackSelection reuseOrCreateTrackSelection(TrackGroup trackGroup) {
-    if (mayReuseTrackSelection) {
-      for (FakeTrackSelection trackSelection : trackSelections) {
-        if (trackSelection.getTrackGroup().equals(trackGroup)) {
-          return trackSelection;
+  /** Returns list of all {@link FakeTrackSelection}s that this track selector has made so far. */
+  public List<FakeTrackSelection> getAllTrackSelections() {
+    return fakeTrackSelectionFactory.trackSelections;
+  }
+
+  private static class FakeTrackSelectionFactory implements TrackSelection.Factory {
+
+    private final List<FakeTrackSelection> trackSelections;
+    private final boolean mayReuseTrackSelection;
+
+    public FakeTrackSelectionFactory(boolean mayReuseTrackSelection) {
+      this.mayReuseTrackSelection = mayReuseTrackSelection;
+      trackSelections = new ArrayList<>();
+    }
+
+    @Override
+    public TrackSelection[] createTrackSelections(
+        TrackSelection.Definition[] definitions, BandwidthMeter bandwidthMeter) {
+      TrackSelection[] selections = new TrackSelection[definitions.length];
+      for (int i = 0; i < definitions.length; i++) {
+        TrackSelection.Definition definition = definitions[i];
+        if (definition != null) {
+          selections[i] = createTrackSelection(definition.group);
         }
       }
+      return selections;
     }
-    FakeTrackSelection trackSelection = new FakeTrackSelection(trackGroup);
-    trackSelections.add(trackSelection);
-    return trackSelection;
-  }
 
-  /** Returns list of all {@link FakeTrackSelection}s that this track selector has made so far. */
-  public List<FakeTrackSelection> getAllTrackSelections() {
-    return trackSelections;
+    private TrackSelection createTrackSelection(TrackGroup trackGroup) {
+      if (mayReuseTrackSelection) {
+        for (FakeTrackSelection trackSelection : trackSelections) {
+          if (trackSelection.getTrackGroup().equals(trackGroup)) {
+            return trackSelection;
+          }
+        }
+      }
+      FakeTrackSelection trackSelection = new FakeTrackSelection(trackGroup);
+      trackSelections.add(trackSelection);
+      return trackSelection;
+    }
   }
-
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaPeriodAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaPeriodAsserts.java
new file mode 100644
index 0000000000..681f166837
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaPeriodAsserts.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.offline.FilterableManifest;
+import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaPeriod.Callback;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.util.ConditionVariable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+/** Assertion methods for {@link MediaPeriod}. */
+public final class MediaPeriodAsserts {
+
+  /**
+   * Interface to create media periods for testing based on a {@link FilterableManifest}.
+   *
+   * @param <T> The type of {@link FilterableManifest}.
+   */
+  public interface FilterableManifestMediaPeriodFactory<T extends FilterableManifest<T>> {
+
+    /** Returns media period based on the provided filterable manifest. */
+    MediaPeriod createMediaPeriod(T manifest, int periodIndex);
+  }
+
+  private MediaPeriodAsserts() {}
+
+  /**
+   * Asserts that the values returns by {@link MediaPeriod#getStreamKeys(List)} are compatible with
+   * a {@link FilterableManifest} using these stream keys.
+   *
+   * @param mediaPeriodFactory A factory to create a {@link MediaPeriod} based on a manifest.
+   * @param manifest The manifest which is to be tested.
+   */
+  public static <T extends FilterableManifest<T>>
+      void assertGetStreamKeysAndManifestFilterIntegration(
+          FilterableManifestMediaPeriodFactory<T> mediaPeriodFactory, T manifest) {
+    assertGetStreamKeysAndManifestFilterIntegration(
+        mediaPeriodFactory, manifest, /* periodIndex= */ 0, /* ignoredMimeType= */ null);
+  }
+
+  /**
+   * Asserts that the values returns by {@link MediaPeriod#getStreamKeys(List)} are compatible with
+   * a {@link FilterableManifest} using these stream keys.
+   *
+   * @param mediaPeriodFactory A factory to create a {@link MediaPeriod} based on a manifest.
+   * @param manifest The manifest which is to be tested.
+   * @param periodIndex The index of period in the manifest.
+   * @param ignoredMimeType Optional mime type whose existence in the filtered track groups is not
+   *     asserted.
+   */
+  public static <T extends FilterableManifest<T>>
+      void assertGetStreamKeysAndManifestFilterIntegration(
+          FilterableManifestMediaPeriodFactory<T> mediaPeriodFactory,
+          T manifest,
+          int periodIndex,
+          @Nullable String ignoredMimeType) {
+    MediaPeriod mediaPeriod = mediaPeriodFactory.createMediaPeriod(manifest, periodIndex);
+    TrackGroupArray trackGroupArray = getTrackGroups(mediaPeriod);
+
+    // Create test vector of query test selections:
+    //  - One selection with one track per group, two tracks or all tracks.
+    //  - Two selections with tracks from multiple groups, or tracks from a single group.
+    //  - Multiple selections with tracks from all groups.
+    List<List<TrackSelection>> testSelections = new ArrayList<>();
+    for (int i = 0; i < trackGroupArray.length; i++) {
+      TrackGroup trackGroup = trackGroupArray.get(i);
+      for (int j = 0; j < trackGroup.length; j++) {
+        testSelections.add(Collections.singletonList(new TestTrackSelection(trackGroup, j)));
+      }
+      if (trackGroup.length > 1) {
+        testSelections.add(Collections.singletonList(new TestTrackSelection(trackGroup, 0, 1)));
+        testSelections.add(
+            Arrays.asList(
+                new TrackSelection[] {
+                  new TestTrackSelection(trackGroup, 0), new TestTrackSelection(trackGroup, 1)
+                }));
+      }
+      if (trackGroup.length > 2) {
+        int[] allTracks = new int[trackGroup.length];
+        for (int j = 0; j < trackGroup.length; j++) {
+          allTracks[j] = j;
+        }
+        testSelections.add(
+            Collections.singletonList(new TestTrackSelection(trackGroup, allTracks)));
+      }
+    }
+    if (trackGroupArray.length > 1) {
+      for (int i = 0; i < trackGroupArray.length - 1; i++) {
+        for (int j = i + 1; j < trackGroupArray.length; j++) {
+          testSelections.add(
+              Arrays.asList(
+                  new TrackSelection[] {
+                    new TestTrackSelection(trackGroupArray.get(i), 0),
+                    new TestTrackSelection(trackGroupArray.get(j), 0)
+                  }));
+        }
+      }
+    }
+    if (trackGroupArray.length > 2) {
+      List<TrackSelection> selectionsFromAllGroups = new ArrayList<>();
+      for (int i = 0; i < trackGroupArray.length; i++) {
+        selectionsFromAllGroups.add(new TestTrackSelection(trackGroupArray.get(i), 0));
+      }
+      testSelections.add(selectionsFromAllGroups);
+    }
+
+    // Verify for each case that stream keys can be used to create filtered tracks which still
+    // contain at least all requested formats.
+    for (List<TrackSelection> testSelection : testSelections) {
+      List<StreamKey> streamKeys = mediaPeriod.getStreamKeys(testSelection);
+      if (streamKeys.isEmpty()) {
+        // Manifests won't be filtered if stream key is empty.
+        continue;
+      }
+      T filteredManifest = manifest.copy(streamKeys);
+      // The filtered manifest should only have one period left.
+      MediaPeriod filteredMediaPeriod =
+          mediaPeriodFactory.createMediaPeriod(filteredManifest, /* periodIndex= */ 0);
+      TrackGroupArray filteredTrackGroupArray = getTrackGroups(filteredMediaPeriod);
+      for (TrackSelection trackSelection : testSelection) {
+        if (ignoredMimeType != null
+            && ignoredMimeType.equals(trackSelection.getFormat(0).sampleMimeType)) {
+          continue;
+        }
+        Format[] expectedFormats = new Format[trackSelection.length()];
+        for (int k = 0; k < trackSelection.length(); k++) {
+          expectedFormats[k] = trackSelection.getFormat(k);
+        }
+        assertOneTrackGroupContainsFormats(filteredTrackGroupArray, expectedFormats);
+      }
+    }
+  }
+
+  private static void assertOneTrackGroupContainsFormats(
+      TrackGroupArray trackGroupArray, Format[] formats) {
+    boolean foundSubset = false;
+    for (int i = 0; i < trackGroupArray.length; i++) {
+      if (containsFormats(trackGroupArray.get(i), formats)) {
+        foundSubset = true;
+        break;
+      }
+    }
+    assertThat(foundSubset).isTrue();
+  }
+
+  private static boolean containsFormats(TrackGroup trackGroup, Format[] formats) {
+    HashSet<Format> allFormats = new HashSet<>();
+    for (int i = 0; i < trackGroup.length; i++) {
+      allFormats.add(trackGroup.getFormat(i));
+    }
+    for (int i = 0; i < formats.length; i++) {
+      if (!allFormats.remove(formats[i])) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private static TrackGroupArray getTrackGroups(MediaPeriod mediaPeriod) {
+    AtomicReference<TrackGroupArray> trackGroupArray = new AtomicReference<>(null);
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    ConditionVariable preparedCondition = new ConditionVariable();
+    dummyMainThread.runOnMainThread(
+        () -> {
+          mediaPeriod.prepare(
+              new Callback() {
+                @Override
+                public void onPrepared(MediaPeriod mediaPeriod) {
+                  trackGroupArray.set(mediaPeriod.getTrackGroups());
+                  preparedCondition.open();
+                }
+
+                @Override
+                public void onContinueLoadingRequested(MediaPeriod source) {
+                  // Ignore.
+                }
+              },
+              /* positionUs= */ 0);
+        });
+    try {
+      preparedCondition.block();
+    } catch (InterruptedException e) {
+      // Ignore.
+    }
+    dummyMainThread.release();
+    return trackGroupArray.get();
+  }
+
+  private static final class TestTrackSelection extends BaseTrackSelection {
+
+    public TestTrackSelection(TrackGroup trackGroup, int... tracks) {
+      super(trackGroup, tracks);
+    }
+
+    @Override
+    public int getSelectedIndex() {
+      return 0;
+    }
+
+    @Override
+    public int getSelectionReason() {
+      return C.SELECTION_REASON_UNKNOWN;
+    }
+
+    @Nullable
+    @Override
+    public Object getSelectionData() {
+      return null;
+    }
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
index 70e7669dfb..0873dbd145 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
@@ -17,17 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
-import static org.junit.Assert.fail;
 
 import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-import android.os.Message;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Pair;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.PlayerMessage;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -54,7 +50,6 @@
 
   public static final int TIMEOUT_MS = 10000;
 
-  private final StubExoPlayer player;
   private final MediaSource mediaSource;
   private final MediaSourceListener mediaSourceListener;
   private final HandlerThread playbackThread;
@@ -79,7 +74,6 @@ public MediaSourceTestRunner(MediaSource mediaSource, Allocator allocator) {
     playbackThread.start();
     Looper playbackLooper = playbackThread.getLooper();
     playbackHandler = new Handler(playbackLooper);
-    player = new EventHandlingExoPlayer(playbackLooper);
     mediaSourceListener = new MediaSourceListener();
     timelines = new LinkedBlockingDeque<>();
     completedLoads = new CopyOnWriteArrayList<>();
@@ -121,11 +115,7 @@ public Timeline prepareSource() throws IOException {
     final IOException[] prepareError = new IOException[1];
     runOnPlaybackThread(
         () -> {
-          mediaSource.prepareSource(
-              player,
-              /* isTopLevelSource= */ true,
-              mediaSourceListener,
-              /* mediaTransferListener= */ null);
+          mediaSource.prepareSource(mediaSourceListener, /* mediaTransferListener= */ null);
           try {
             // TODO: This only catches errors that are set synchronously in prepareSource. To
             // capture async errors we'll need to poll maybeThrowSourceInfoRefreshError until the
@@ -142,15 +132,28 @@ public Timeline prepareSource() throws IOException {
   }
 
   /**
-   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator)} on the playback
-   * thread, asserting that a non-null {@link MediaPeriod} is returned.
+   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator, long)} with a zero
+   * start position on the playback thread, asserting that a non-null {@link MediaPeriod} is
+   * returned.
    *
    * @param periodId The id of the period to create.
    * @return The created {@link MediaPeriod}.
    */
   public MediaPeriod createPeriod(final MediaPeriodId periodId) {
+    return createPeriod(periodId, /* startPositionUs= */ 0);
+  }
+
+  /**
+   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator, long)} on the
+   * playback thread, asserting that a non-null {@link MediaPeriod} is returned.
+   *
+   * @param periodId The id of the period to create.
+   * @return The created {@link MediaPeriod}.
+   */
+  public MediaPeriod createPeriod(final MediaPeriodId periodId, long startPositionUs) {
     final MediaPeriod[] holder = new MediaPeriod[1];
-    runOnPlaybackThread(() -> holder[0] = mediaSource.createPeriod(periodId, allocator));
+    runOnPlaybackThread(
+        () -> holder[0] = mediaSource.createPeriod(periodId, allocator, startPositionUs));
     assertThat(holder[0]).isNotNull();
     return holder[0];
   }
@@ -417,43 +420,4 @@ public void onDownstreamFormatChanged(
       Assertions.checkState(Looper.myLooper() == playbackThread.getLooper());
     }
   }
-
-  private static class EventHandlingExoPlayer extends StubExoPlayer
-      implements Handler.Callback, PlayerMessage.Sender {
-
-    private final Handler handler;
-
-    public EventHandlingExoPlayer(Looper looper) {
-      this.handler = new Handler(looper, this);
-    }
-
-    @Override
-    public Looper getApplicationLooper() {
-      return handler.getLooper();
-    }
-
-    @Override
-    public PlayerMessage createMessage(PlayerMessage.Target target) {
-      return new PlayerMessage(
-          /* sender= */ this, target, Timeline.EMPTY, /* defaultWindowIndex= */ 0, handler);
-    }
-
-    @Override
-    public void sendMessage(PlayerMessage message) {
-      handler.obtainMessage(0, message).sendToTarget();
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public boolean handleMessage(Message msg) {
-      PlayerMessage message = (PlayerMessage) msg.obj;
-      try {
-        message.getTarget().handleMessage(message.getType(), message.getPayload());
-        message.markAsProcessed(/* isDelivered= */ true);
-      } catch (ExoPlaybackException e) {
-        fail("Unexpected ExoPlaybackException.");
-      }
-      return true;
-    }
-  }
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
index dc7781fd90..ad1fa6bb29 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
@@ -22,8 +22,8 @@
 import android.os.Looper;
 import android.os.Message;
 import android.os.MessageQueue;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.PriorityBlockingQueue;
@@ -37,6 +37,7 @@
 public final class RobolectricUtil {
 
   private static final AtomicLong sequenceNumberGenerator = new AtomicLong(0);
+  private static final int ANY_MESSAGE = Integer.MIN_VALUE;
 
   private RobolectricUtil() {}
 
@@ -110,7 +111,8 @@ private void doLoop() {
             boolean isRemoved = false;
             for (RemovedMessage removedMessage : removedMessages) {
               if (removedMessage.handler == target
-                  && removedMessage.what == pendingMessage.message.what
+                  && (removedMessage.what == ANY_MESSAGE
+                      || removedMessage.what == pendingMessage.message.what)
                   && (removedMessage.object == null
                       || removedMessage.object == pendingMessage.message.obj)
                   && pendingMessage.sequenceNumber < removedMessage.sequenceNumber) {
@@ -163,7 +165,7 @@ public CustomMessageQueue() {
     public boolean enqueueMessage(Message msg, long when) {
       Looper looper = ShadowLooper.getLooperForThread(looperThread);
       if (shadowOf(looper) instanceof CustomLooper
-          && shadowOf(looper) != ShadowLooper.getShadowMainLooper()) {
+          && shadowOf(looper) != shadowOf(Looper.getMainLooper())) {
         ((CustomLooper) shadowOf(looper)).addPendingMessage(msg, when);
       } else {
         super.enqueueMessage(msg, when);
@@ -175,10 +177,19 @@ public boolean enqueueMessage(Message msg, long when) {
     public void removeMessages(Handler handler, int what, Object object) {
       Looper looper = ShadowLooper.getLooperForThread(looperThread);
       if (shadowOf(looper) instanceof CustomLooper
-          && shadowOf(looper) != ShadowLooper.getShadowMainLooper()) {
+          && shadowOf(looper) != shadowOf(Looper.getMainLooper())) {
         ((CustomLooper) shadowOf(looper)).removeMessages(handler, what, object);
       }
     }
+
+    @Implementation
+    public void removeCallbacksAndMessages(Handler handler, Object object) {
+      Looper looper = ShadowLooper.getLooperForThread(looperThread);
+      if (shadowOf(looper) instanceof CustomLooper
+          && shadowOf(looper) != shadowOf(Looper.getMainLooper())) {
+        ((CustomLooper) shadowOf(looper)).removeMessages(handler, ANY_MESSAGE, object);
+      }
+    }
   }
 
   private static final class PendingMessage implements Comparable<PendingMessage> {
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
index 724ed366bc..a0d8c7f9d8 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
@@ -272,4 +272,9 @@ public long getContentPosition() {
   public long getContentBufferedPosition() {
     throw new UnsupportedOperationException();
   }
+
+  @Override
+  public void setForegroundMode(boolean foregroundMode) {
+    throw new UnsupportedOperationException();
+  }
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java
index 7e0ffc1772..4c334992b5 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TestDownloadManagerListener.java
@@ -16,8 +16,11 @@
 package com.google.android.exoplayer2.testutil;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
-import com.google.android.exoplayer2.offline.DownloadAction;
+import android.os.ConditionVariable;
+import com.google.android.exoplayer2.offline.Download;
+import com.google.android.exoplayer2.offline.Download.State;
 import com.google.android.exoplayer2.offline.DownloadManager;
 import java.util.HashMap;
 import java.util.concurrent.ArrayBlockingQueue;
@@ -28,41 +31,59 @@
 public final class TestDownloadManagerListener implements DownloadManager.Listener {
 
   private static final int TIMEOUT = 1000;
+  private static final int INITIALIZATION_TIMEOUT = 10000;
+  private static final int STATE_REMOVED = -1;
 
   private final DownloadManager downloadManager;
   private final DummyMainThread dummyMainThread;
-  private final HashMap<DownloadAction, ArrayBlockingQueue<Integer>> actionStates;
+  private final HashMap<String, ArrayBlockingQueue<Integer>> downloadStates;
+  private final ConditionVariable initializedCondition;
+  private final int timeout;
 
   private CountDownLatch downloadFinishedCondition;
-  private Throwable downloadError;
+  @Download.FailureReason private int failureReason;
 
   public TestDownloadManagerListener(
       DownloadManager downloadManager, DummyMainThread dummyMainThread) {
-    this.downloadManager = downloadManager;
-    this.dummyMainThread = dummyMainThread;
-    actionStates = new HashMap<>();
+    this(downloadManager, dummyMainThread, TIMEOUT);
   }
 
-  public int pollStateChange(DownloadAction action, long timeoutMs) throws InterruptedException {
-    return getStateQueue(action).poll(timeoutMs, TimeUnit.MILLISECONDS);
+  public TestDownloadManagerListener(
+      DownloadManager downloadManager, DummyMainThread dummyMainThread, int timeout) {
+    this.downloadManager = downloadManager;
+    this.dummyMainThread = dummyMainThread;
+    this.timeout = timeout;
+    downloadStates = new HashMap<>();
+    initializedCondition = new ConditionVariable();
+    downloadManager.addListener(this);
   }
 
-  public void clearDownloadError() {
-    this.downloadError = null;
+  public Integer pollStateChange(String taskId, long timeoutMs) throws InterruptedException {
+    return getStateQueue(taskId).poll(timeoutMs, TimeUnit.MILLISECONDS);
   }
 
   @Override
   public void onInitialized(DownloadManager downloadManager) {
-    // Do nothing.
+    initializedCondition.open();
+  }
+
+  public void waitUntilInitialized() {
+    if (!downloadManager.isInitialized()) {
+      assertThat(initializedCondition.block(INITIALIZATION_TIMEOUT)).isTrue();
+    }
   }
 
   @Override
-  public void onTaskStateChanged(
-      DownloadManager downloadManager, DownloadManager.TaskState taskState) {
-    if (taskState.state == DownloadManager.TaskState.STATE_FAILED && downloadError == null) {
-      downloadError = taskState.error;
+  public void onDownloadChanged(DownloadManager downloadManager, Download download) {
+    if (download.state == Download.STATE_FAILED) {
+      failureReason = download.failureReason;
     }
-    getStateQueue(taskState.action).add(taskState.state);
+    getStateQueue(download.request.id).add(download.state);
+  }
+
+  @Override
+  public void onDownloadRemoved(DownloadManager downloadManager, Download download) {
+    getStateQueue(download.request.id).add(STATE_REMOVED);
   }
 
   @Override
@@ -77,6 +98,14 @@ public synchronized void onIdle(DownloadManager downloadManager) {
    * error.
    */
   public void blockUntilTasksCompleteAndThrowAnyDownloadError() throws Throwable {
+    blockUntilTasksComplete();
+    if (failureReason != Download.FAILURE_REASON_NONE) {
+      throw new Exception("Failure reason: " + failureReason);
+    }
+  }
+
+  /** Blocks until all remove and download tasks are complete. Task errors are ignored. */
+  public void blockUntilTasksComplete() throws InterruptedException {
     synchronized (this) {
       downloadFinishedCondition = new CountDownLatch(1);
     }
@@ -86,18 +115,41 @@ public void blockUntilTasksCompleteAndThrowAnyDownloadError() throws Throwable {
             downloadFinishedCondition.countDown();
           }
         });
-    assertThat(downloadFinishedCondition.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
-    if (downloadError != null) {
-      throw new Exception(downloadError);
+    assertThat(downloadFinishedCondition.await(timeout, TimeUnit.MILLISECONDS)).isTrue();
+  }
+
+  private ArrayBlockingQueue<Integer> getStateQueue(String taskId) {
+    synchronized (downloadStates) {
+      if (!downloadStates.containsKey(taskId)) {
+        downloadStates.put(taskId, new ArrayBlockingQueue<>(10));
+      }
+      return downloadStates.get(taskId);
     }
   }
 
-  private ArrayBlockingQueue<Integer> getStateQueue(DownloadAction action) {
-    synchronized (actionStates) {
-      if (!actionStates.containsKey(action)) {
-        actionStates.put(action, new ArrayBlockingQueue<>(10));
+  public void assertRemoved(String taskId, int timeoutMs) {
+    assertStateInternal(taskId, STATE_REMOVED, timeoutMs);
+  }
+
+  public void assertState(String taskId, @State int expectedState, int timeoutMs) {
+    assertStateInternal(taskId, expectedState, timeoutMs);
+  }
+
+  private void assertStateInternal(String taskId, int expectedState, int timeoutMs) {
+    while (true) {
+      Integer state = null;
+      try {
+        state = pollStateChange(taskId, timeoutMs);
+      } catch (InterruptedException e) {
+        fail(e.getMessage());
+      }
+      if (state != null) {
+        if (expectedState == state) {
+          return;
+        }
+      } else {
+        fail("Didn't receive expected state: " + expectedState);
       }
-      return actionStates.get(action);
     }
   }
 }
