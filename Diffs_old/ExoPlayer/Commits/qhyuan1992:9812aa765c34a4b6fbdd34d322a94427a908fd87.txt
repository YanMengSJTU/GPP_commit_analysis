diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index e490354bfb..d8c4753202 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -41,7 +41,7 @@
   public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
   public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
   public static final int WORKAROUND_DETECT_ACCESS_UNITS = 8;
-  public static final int WORKAROUND_MAP_BY_TYPE = 16;
+  public static final int WORKAROUND_HLS_MODE = 16;
 
   private static final String TAG = "TsExtractor";
 
@@ -191,18 +191,22 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     tsScratch.skipBits(2); // transport_scrambling_control
     boolean adaptationFieldExists = tsScratch.readBit();
     boolean payloadExists = tsScratch.readBit();
+
+    // Discontinuity check.
     boolean discontinuityFound = false;
     int continuityCounter = tsScratch.readBits(4);
-    int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
-    continuityCounters.put(pid, continuityCounter);
-    if (previousCounter == continuityCounter) {
-      if (payloadExists) {
-        // Duplicate packet found.
-        tsPacketBuffer.setPosition(endOfPacket);
-        return RESULT_CONTINUE;
+    if ((workaroundFlags & WORKAROUND_HLS_MODE) == 0) {
+      int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+      continuityCounters.put(pid, continuityCounter);
+      if (previousCounter == continuityCounter) {
+        if (payloadExists) {
+          // Duplicate packet found.
+          tsPacketBuffer.setPosition(endOfPacket);
+          return RESULT_CONTINUE;
+        }
+      } else if (continuityCounter != (previousCounter + 1) % 16) {
+        discontinuityFound = true;
       }
-    } else if (continuityCounter != (previousCounter + 1) % 16) {
-      discontinuityFound = true;
     }
 
     // Skip the adaptation field.
@@ -410,7 +414,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       // Skip the descriptors.
       sectionData.skipBytes(programInfoLength);
 
-      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 && id3Reader == null) {
+      if ((workaroundFlags & WORKAROUND_HLS_MODE) != 0 && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See b/20261500.
         id3Reader = new Id3Reader(output.track(TS_STREAM_TYPE_ID3));
@@ -432,7 +436,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           sectionData.skipBytes(esInfoLength);
         }
         remainingEntriesLength -= esInfoLength + 5;
-        int trackId = (workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 ? streamType : elementaryPid;
+        int trackId = (workaroundFlags & WORKAROUND_HLS_MODE) != 0 ? streamType : elementaryPid;
         if (trackIds.get(trackId)) {
           continue;
         }
@@ -473,7 +477,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
                 new SeiReader(output.track(nextEmbeddedTrackId++)));
             break;
           case TS_STREAM_TYPE_ID3:
-            if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
+            if ((workaroundFlags & WORKAROUND_HLS_MODE) != 0) {
               pesPayloadReader = id3Reader;
             } else {
               pesPayloadReader = new Id3Reader(output.track(nextEmbeddedTrackId++));
@@ -490,7 +494,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
               new PesReader(pesPayloadReader, ptsTimestampAdjuster));
         }
       }
-      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
+      if ((workaroundFlags & WORKAROUND_HLS_MODE) != 0) {
        if (!tracksEnded) {
          output.endTracks();
        }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 135ee378b0..025a6d14e2 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -513,8 +513,8 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
         // The master source has yet to instantiate an adjuster for the discontinuity sequence.
         return;
       }
-      // This flag ensures the change of pid between streams does not affect the sample queues.
-      int workaroundFlags = TsExtractor.WORKAROUND_MAP_BY_TYPE;
+      // Enable HLS workarounds for the extractor.
+      int workaroundFlags = TsExtractor.WORKAROUND_HLS_MODE;
       String codecs = format.codecs;
       if (!TextUtils.isEmpty(codecs)) {
         // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
