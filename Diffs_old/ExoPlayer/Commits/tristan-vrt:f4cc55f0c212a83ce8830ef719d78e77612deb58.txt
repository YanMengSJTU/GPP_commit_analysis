diff --git a/.github/ISSUE_TEMPLATE/bug.md b/.github/ISSUE_TEMPLATE/bug.md
index a4996278bd..c0980df440 100644
--- a/.github/ISSUE_TEMPLATE/bug.md
+++ b/.github/ISSUE_TEMPLATE/bug.md
@@ -36,16 +36,17 @@ or a small sample app that you’re able to share as source code on GitHub.
 Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
 media that reproduces the issue. If you don't wish to post it publicly, please
 submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
-in the format "Issue #1234". Provide all the metadata we'd need to play the
-content like drm license urls or similar. If the content is accessible only in
-certain countries or regions, please say so.
+in the format "Issue #1234", where "#1234" should be replaced with your issue
+number. Provide all the metadata we'd need to play the content like drm license
+urls or similar. If the content is accessible only in certain countries or
+regions, please say so.
 
 ### [REQUIRED] A full bug report captured from the device
 Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
 log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
 bug report to dev.exoplayer@gmail.com using a subject in the format
-"Issue #1234".
+"Issue #1234", where "#1234" should be replaced with your issue number.
 
 ### [REQUIRED] Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
diff --git a/.github/ISSUE_TEMPLATE/content_not_playing.md b/.github/ISSUE_TEMPLATE/content_not_playing.md
index ff29f3a7d1..c8d4668a6a 100644
--- a/.github/ISSUE_TEMPLATE/content_not_playing.md
+++ b/.github/ISSUE_TEMPLATE/content_not_playing.md
@@ -33,9 +33,10 @@ and you expect to play, like 5.1 audio track, text tracks or drm systems.
 Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
 media that reproduces the issue. If you don't wish to post it publicly, please
 submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
-in the format "Issue #1234". Provide all the metadata we'd need to play the
-content like drm license urls or similar. If the content is accessible only in
-certain countries or regions, please say so.
+in the format "Issue #1234", where "#1234" should be replaced with your issue
+number. Provide all the metadata we'd need to play the content like drm license
+urls or similar. If the content is accessible only in certain countries or
+regions, please say so.
 
 ### [REQUIRED] Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
@@ -44,6 +45,13 @@ Specify the absolute version number. Avoid using terms such as "latest".
 Specify the devices and versions of Android on which you expect the content to
 play. If possible, please test on multiple devices and Android versions.
 
+### [REQUIRED] A full bug report captured from the device
+Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
+log snippet is NOT sufficient. Please attach the captured bug report as a file.
+If you don't wish to post it publicly, please submit the issue, then email the
+bug report to dev.exoplayer@gmail.com using a subject in the format
+"Issue #1234", where "#1234" should be replaced with your issue number.
+
 <!-- DO NOT DELETE
 validate_template=true
 template_path=.github/ISSUE_TEMPLATE/content_not_playing.md
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
index a68e4e70e1..b5f40884d8 100644
--- a/.github/ISSUE_TEMPLATE/question.md
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -32,6 +32,23 @@ important for us to know this so that we can improve our documentation.
 ### [REQUIRED] Question
 Describe your question in detail.
 
+### A full bug report captured from the device
+In case your question refers to a problem you are seeing in your app, capture a
+full bug report using "adb bugreport". Please attach the captured bug report as
+a file. If you don't wish to post it publicly, please submit the issue, then
+email the bug report to dev.exoplayer@gmail.com using a subject in the format
+"Issue #1234", where "#1234" should be replaced with your issue number.
+
+### Link to test content
+In case your question is related to a piece of media, which you are trying to
+play, please provide a JSON snippet for the demo app’s media.exolist.json file,
+or a link to media that reproduces the issue. If you don't wish to post it
+publicly, please submit the issue, then email the link to
+dev.exoplayer@gmail.com using a subject in the format "Issue #1234", where
+"#1234" should be replaced with your issue number. Provide all the metadata we'd
+need to play the content like drm license urls or similar. If the content is
+accessible only in certain countries or regions, please say so.
+
 <!-- DO NOT DELETE
 validate_template=true
 template_path=.github/ISSUE_TEMPLATE/question.md
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 9e7a992e11..3169dac565 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,6 +1,151 @@
 # Release notes #
 
-### 2.10.1 ###
+### 2.10.5 (2019-09-20) ###
+
+* Add `Player.isPlaying` and `EventListener.onIsPlayingChanged` to check whether
+  the playback position is advancing. This helps to determine if playback is
+  suppressed due to audio focus loss. Also add
+  `Player.getPlaybackSuppressedReason` to determine the reason of the
+  suppression ([#6203](https://github.com/google/ExoPlayer/issues/6203)).
+* Track selection
+  * Add `allowAudioMixedChannelCountAdaptiveness` parameter to
+    `DefaultTrackSelector` to allow adaptive selections of audio tracks with
+    different channel counts.
+  * Improve text selection logic to always prefer the better language matches
+    over other selection parameters.
+  * Fix audio selection issue where languages are compared by bitrate
+    ([#6335](https://github.com/google/ExoPlayer/issues/6335)).
+* Performance
+  * Increase maximum video buffer size from 13MB to 32MB. The previous default
+    was too small for high quality streams.
+  * Reset `DefaultBandwidthMeter` to initial values on network change.
+  * Bypass sniffing in `ProgressiveMediaPeriod` in case a single extractor is
+    provided ([#6325](https://github.com/google/ExoPlayer/issues/6325)).
+* Metadata
+  * Support EMSG V1 boxes in FMP4.
+  * Support unwrapping of nested metadata (e.g. ID3 and SCTE-35 in EMSG).
+* Add `HttpDataSource.getResponseCode` to provide the status code associated
+  with the most recent HTTP response.
+* Fix transitions between packed audio and non-packed audio segments in HLS
+  ([#6444](https://github.com/google/ExoPlayer/issues/6444)).
+* Fix issue where a request would be retried after encountering an error, even
+  though the `LoadErrorHandlingPolicy` classified the error as fatal.
+* Fix initialization data handling for FLAC in MP4
+  ([#6396](https://github.com/google/ExoPlayer/issues/6396),
+  [#6397](https://github.com/google/ExoPlayer/issues/6397)).
+* Fix decoder selection for E-AC3 JOC streams
+  ([#6398](https://github.com/google/ExoPlayer/issues/6398)).
+* Fix `PlayerNotificationManager` to show play icon rather than pause icon when
+  playback is ended ([#6324](https://github.com/google/ExoPlayer/issues/6324)).
+* RTMP extension: Upgrade LibRtmp-Client-for-Android to fix RTMP playback issues
+  ([#4200](https://github.com/google/ExoPlayer/issues/4200),
+  [#4249](https://github.com/google/ExoPlayer/issues/4249),
+  [#4319](https://github.com/google/ExoPlayer/issues/4319),
+  [#4337](https://github.com/google/ExoPlayer/issues/4337)).
+* IMA extension: Fix crash in `ImaAdsLoader.onTimelineChanged`
+  ([#5831](https://github.com/google/ExoPlayer/issues/5831)).
+
+### 2.10.4 (2019-07-26) ###
+
+* Offline: Add `Scheduler` implementation that uses `WorkManager`.
+* Add ability to specify a description when creating notification channels via
+  ExoPlayer library classes.
+* Switch normalized BCP-47 language codes to use 2-letter ISO 639-1 language
+  tags instead of 3-letter ISO 639-2 language tags.
+* Ensure the `SilenceMediaSource` position is in range
+  ([#6229](https://github.com/google/ExoPlayer/issues/6229)).
+* WAV: Calculate correct duration for clipped streams
+  ([#6241](https://github.com/google/ExoPlayer/issues/6241)).
+* MP3: Use CBR header bitrate, not calculated bitrate. This reverts a change
+  from 2.9.3 ([#6238](https://github.com/google/ExoPlayer/issues/6238)).
+* Flac extension: Parse `VORBIS_COMMENT` and `PICTURE` metadata
+  ([#5527](https://github.com/google/ExoPlayer/issues/5527)).
+* Fix issue where initial seek positions get ignored when playing a preroll ad
+  ([#6201](https://github.com/google/ExoPlayer/issues/6201)).
+* Fix issue where invalid language tags were normalized to "und" instead of
+  keeping the original
+  ([#6153](https://github.com/google/ExoPlayer/issues/6153)).
+* Fix `DataSchemeDataSource` re-opening and range requests
+  ([#6192](https://github.com/google/ExoPlayer/issues/6192)).
+* Fix Flac and ALAC playback on some LG devices
+  ([#5938](https://github.com/google/ExoPlayer/issues/5938)).
+* Fix issue when calling `performClick` on `PlayerView` without
+  `PlayerControlView`
+  ([#6260](https://github.com/google/ExoPlayer/issues/6260)).
+* Fix issue where playback speeds are not used in adaptive track selections
+  after manual selection changes for other renderers
+  ([#6256](https://github.com/google/ExoPlayer/issues/6256)).
+
+### 2.10.3 (2019-07-09) ###
+
+* Display last frame when seeking to end of stream
+  ([#2568](https://github.com/google/ExoPlayer/issues/2568)).
+* Audio:
+  * Fix an issue where not all audio was played out when the configuration
+    for the underlying track was changing (e.g., at some period transitions).
+  * Fix an issue where playback speed was applied inaccurately in playlists
+    ([#6117](https://github.com/google/ExoPlayer/issues/6117)).
+* UI: Fix `PlayerView` incorrectly consuming touch events if no controller is
+  attached ([#6109](https://github.com/google/ExoPlayer/issues/6109)).
+* CEA608: Fix repetition of special North American characters
+  ([#6133](https://github.com/google/ExoPlayer/issues/6133)).
+* FLV: Fix bug that caused playback of some live streams to not start
+  ([#6111](https://github.com/google/ExoPlayer/issues/6111)).
+* SmoothStreaming: Parse text stream `Subtype` into `Format.roleFlags`.
+* MediaSession extension: Fix `MediaSessionConnector.play()` not resuming
+  playback ([#6093](https://github.com/google/ExoPlayer/issues/6093)).
+
+### 2.10.2 (2019-06-03) ###
+
+* Add `ResolvingDataSource` for just-in-time resolution of `DataSpec`s
+  ([#5779](https://github.com/google/ExoPlayer/issues/5779)).
+* Add `SilenceMediaSource` that can be used to play silence of a given
+  duration ([#5735](https://github.com/google/ExoPlayer/issues/5735)).
+* Offline:
+  * Prevent unexpected `DownloadHelper.Callback.onPrepared` callbacks after
+    preparation of a `DownloadHelper` fails
+    ([#5915](https://github.com/google/ExoPlayer/issues/5915)).
+  * Fix `CacheUtil.cache()` downloading too much data
+    ([#5927](https://github.com/google/ExoPlayer/issues/5927)).
+  * Fix misreporting cached bytes when caching is paused
+    ([#5573](https://github.com/google/ExoPlayer/issues/5573)).
+* UI:
+  * Allow setting `DefaultTimeBar` attributes on `PlayerView` and
+    `PlayerControlView`.
+  * Change playback controls toggle from touch down to touch up events
+    ([#5784](https://github.com/google/ExoPlayer/issues/5784)).
+  * Fix issue where playback controls were not kept visible on key presses
+    ([#5963](https://github.com/google/ExoPlayer/issues/5963)).
+* Subtitles:
+  * CEA-608: Handle XDS and TEXT modes
+    ([#5807](https://github.com/google/ExoPlayer/pull/5807)).
+  * TTML: Fix bitmap rendering
+    ([#5633](https://github.com/google/ExoPlayer/pull/5633)).
+* IMA: Fix ad pod index offset calculation without preroll
+  ([#5928](https://github.com/google/ExoPlayer/issues/5928)).
+* Add a `playWhenReady` flag to MediaSessionConnector.PlaybackPreparer methods
+  to indicate whether a controller sent a play or only a prepare command. This
+  allows to take advantage of decoder reuse with the MediaSessionConnector
+  ([#5891](https://github.com/google/ExoPlayer/issues/5891)).
+* Add `ProgressUpdateListener` to `PlayerControlView`
+  ([#5834](https://github.com/google/ExoPlayer/issues/5834)).
+* Add support for auto-detecting UDP streams in `DefaultDataSource`
+  ([#6036](https://github.com/google/ExoPlayer/pull/6036)).
+* Allow enabling decoder fallback with `DefaultRenderersFactory`
+  ([#5942](https://github.com/google/ExoPlayer/issues/5942)).
+* Gracefully handle revoked `ACCESS_NETWORK_STATE` permission
+  ([#6019](https://github.com/google/ExoPlayer/issues/6019)).
+* Fix decoding problems when seeking back after seeking beyond a mid-roll ad
+  ([#6009](https://github.com/google/ExoPlayer/issues/6009)).
+* Fix application of `maxAudioBitrate` for adaptive audio track groups
+  ([#6006](https://github.com/google/ExoPlayer/issues/6006)).
+* Fix bug caused by parallel adaptive track selection using `Format`s without
+  bitrate information
+  ([#5971](https://github.com/google/ExoPlayer/issues/5971)).
+* Fix bug in `CastPlayer.getCurrentWindowIndex()`
+  ([#5955](https://github.com/google/ExoPlayer/issues/5955)).
+
+### 2.10.1 (2019-05-16) ###
 
 * Offline: Add option to remove all downloads.
 * HLS: Fix `NullPointerException` when using HLS chunkless preparation
@@ -12,7 +157,7 @@
 * Add a workaround for a decoder failure on ZTE Axon7 mini devices when playing
   48kHz audio ([#5821](https://github.com/google/ExoPlayer/issues/5821)).
 
-### 2.10.0 ###
+### 2.10.0 (2019-04-15) ###
 
 * Core library:
   * Improve decoder re-use between playbacks
@@ -25,6 +170,8 @@
     `ExtractorsFactory` instances must now be passed via the
     `ProgressiveMediaSource.Factory` constructor, and `setExtractorsFactory` is
     deprecated.
+  * Make the default minimum buffer size equal the maximum buffer size for video
+    playbacks ([#2083](https://github.com/google/ExoPlayer/issues/2083)).
   * Move `PriorityTaskManager` from `DefaultLoadControl` to `SimpleExoPlayer`.
   * Add new `ExoPlaybackException` types for remote exceptions and out-of-memory
     errors.
@@ -100,7 +247,7 @@
     ([#5547](https://github.com/google/ExoPlayer/issues/5547)).
 * DRM:
   * Fix black flicker when keys rotate in DRM protected content
-  ([#3561](https://github.com/google/ExoPlayer/issues/3561)).
+    ([#3561](https://github.com/google/ExoPlayer/issues/3561)).
   * Work around lack of LA_URL attribute in PlayReady key request init data.
 * CEA-608: Improved conformance to the specification
   ([#3860](https://github.com/google/ExoPlayer/issues/3860)).
@@ -130,13 +277,11 @@
     order when in shuffle mode.
   * Allow handling of custom commands via `registerCustomCommandReceiver`.
   * Add ability to include an extras `Bundle` when reporting a custom error.
-* LoadControl: Set minimum buffer for playbacks with video equal to maximum
-  buffer ([#2083](https://github.com/google/ExoPlayer/issues/2083)).
 * Log warnings when extension native libraries can't be used, to help with
   diagnosing playback failures
   ([#5788](https://github.com/google/ExoPlayer/issues/5788)).
 
-### 2.9.6 ###
+### 2.9.6 (2019-02-19) ###
 
 * Remove `player` and `isTopLevelSource` parameters from `MediaSource.prepare`.
 * IMA extension:
@@ -159,7 +304,7 @@
   may cause problems for some devices and/or non-interlaced content
   ([#5003](https://github.com/google/ExoPlayer/issues/5003)).
 
-### 2.9.5 ###
+### 2.9.5 (2019-01-31) ###
 
 * HLS: Parse `CHANNELS` attribute from `EXT-X-MEDIA` tag.
 * ConcatenatingMediaSource:
@@ -176,7 +321,7 @@
 * MP3: Wider fix for issue where streams would play twice on some Samsung
   devices ([#4519](https://github.com/google/ExoPlayer/issues/4519)).
 
-### 2.9.4 ###
+### 2.9.4 (2019-01-15) ###
 
 * IMA extension: Clear ads loader listeners on release
   ([#4114](https://github.com/google/ExoPlayer/issues/4114)).
@@ -205,7 +350,7 @@
 * Fix issue where uneven track durations in MP4 streams can cause OOM problems
   ([#3670](https://github.com/google/ExoPlayer/issues/3670)).
 
-### 2.9.3 ###
+### 2.9.3 (2018-12-20) ###
 
 * Captions: Support PNG subtitles in SMPTE-TT
   ([#1583](https://github.com/google/ExoPlayer/issues/1583)).
@@ -224,7 +369,7 @@
 * Workaround for MiTV (dangal) issue when swapping output surface
   ([#5169](https://github.com/google/ExoPlayer/issues/5169)).
 
-### 2.9.2 ###
+### 2.9.2 (2018-11-28) ###
 
 * HLS:
   * Fix issue causing unnecessary media playlist requests when playing live
@@ -251,7 +396,7 @@
   ([#5162](https://github.com/google/ExoPlayer/issues/5162)).
 * Fix UUID passed to `MediaCrypto` when using `C.CLEARKEY_UUID` before API 27.
 
-### 2.9.1 ###
+### 2.9.1 (2018-11-01) ###
 
 * Add convenience methods `Player.next`, `Player.previous`, `Player.hasNext`
   and `Player.hasPrevious`
@@ -303,7 +448,7 @@
 * Swap recommended order for google() and jcenter() in gradle config
   ([#4997](https://github.com/google/ExoPlayer/issues/4997)).
 
-### 2.9.0 ###
+### 2.9.0 (2018-09-06) ###
 
 * Turn on Java 8 compiler support for the ExoPlayer library. Apps may need to
   add `compileOptions { targetCompatibility JavaVersion.VERSION_1_8 }` to their
@@ -465,13 +610,13 @@
 * Cronet extension: Now distributed via jCenter.
 * FFmpeg extension: Support mu-law and A-law PCM.
 
-### 2.8.4 ###
+### 2.8.4 (2018-08-17) ###
 
 * IMA extension: Improve handling of consecutive empty ad groups
   ([#4030](https://github.com/google/ExoPlayer/issues/4030)),
   ([#4280](https://github.com/google/ExoPlayer/issues/4280)).
 
-### 2.8.3 ###
+### 2.8.3 (2018-07-23) ###
 
 * IMA extension:
   * Fix behavior when creating/releasing the player then releasing
@@ -514,7 +659,7 @@
   ([#4611](https://github.com/google/ExoPlayer/issues/4611)).
 * Improved compatibility with FireOS devices.
 
-### 2.8.2 ###
+### 2.8.2 (2018-06-06) ###
 
 * IMA extension: Don't advertise support for video/mpeg ad media, as we don't
   have an extractor for this
@@ -541,7 +686,7 @@
 * Allow apps to register custom MIME types
   ([#4264](https://github.com/google/ExoPlayer/issues/4264)).
 
-### 2.8.1 ###
+### 2.8.1 (2018-05-22) ###
 
 * HLS:
   * Fix playback of livestreams with EXT-X-PROGRAM-DATE-TIME tags
@@ -574,7 +719,7 @@
     * Support TTML font size using % correctly (as percentage of document cell
       resolution).
 
-### 2.8.0 ###
+### 2.8.0 (2018-05-03) ###
 
 * Downloading:
   * Add `DownloadService`, `DownloadManager` and related classes
@@ -688,12 +833,12 @@
   `BaseRenderer.onStreamChanged`.
 * Added dependencies on checkerframework annotations for static code analysis.
 
-### 2.7.3 ###
+### 2.7.3 (2018-04-04) ###
 
 * Fix ProGuard configuration for Cast, IMA and OkHttp extensions.
 * Update OkHttp extension to depend on OkHttp 3.10.0.
 
-### 2.7.2 ###
+### 2.7.2 (2018-03-29) ###
 
 * Gradle: Upgrade Gradle version from 4.1 to 4.4 so it can work with Android
   Studio 3.1 ([#3708](https://github.com/google/ExoPlayer/issues/3708)).
@@ -707,7 +852,7 @@
 * MediaSession extension: Omit fast forward and rewind actions when media is not
   seekable ([#4001](https://github.com/google/ExoPlayer/issues/4001)).
 
-### 2.7.1 ###
+### 2.7.1 (2018-03-09) ###
 
 * Gradle: Replaced 'compile' (deprecated) with 'implementation' and
   'api'. This may lead to build breakage for applications upgrading from
@@ -727,7 +872,7 @@
 * Video: Force rendering a frame periodically in `MediaCodecVideoRenderer` and
   `LibvpxVideoRenderer`, even if it is late.
 
-### 2.7.0 ###
+### 2.7.0 (2018-02-19) ###
 
 * Player interface:
   * Add optional parameter to `stop` to reset the player when stopping.
@@ -853,7 +998,7 @@
   ([#3340](https://github.com/google/ExoPlayer/issues/3340)).
 * Demo app: Add ability to download not DRM protected content.
 
-### 2.6.1 ###
+### 2.6.1 (2017-12-15) ###
 
 * Add factories to `ExtractorMediaSource`, `HlsMediaSource`, `SsMediaSource`,
   `DashMediaSource` and `SingleSampleMediaSource`.
@@ -897,7 +1042,7 @@
 * Prevent period transitions when seeking to the end of a period when paused
   ([#2439](https://github.com/google/ExoPlayer/issues/2439)).
 
-### 2.6.0 ###
+### 2.6.0 (2017-11-03) ###
 
 * Removed "r" prefix from versions. This release is "2.6.0", not "r2.6.0".
 * New `Player.DefaultEventListener` abstract class can be extended to avoid
@@ -967,7 +1112,7 @@
 * Unit tests moved to Robolectric.
 * Misc bugfixes.
 
-### r2.5.4 ###
+### r2.5.4 (2017-10-19) ###
 
 * Remove unnecessary media playlist fetches during playback of live HLS streams.
 * Add the ability to inject a HLS playlist parser through `HlsMediaSource`.
@@ -985,7 +1130,7 @@
   `FrameworkMediaCrypto` and by making `DefaultDashChunkSource.getNextChunk`
   non-final.
 
-### r2.5.3 ###
+### r2.5.3 (2017-09-20) ###
 
 * IMA extension: Support skipping of skippable ads on AndroidTV and other
   non-touch devices ([#3258](https://github.com/google/ExoPlayer/issues/3258)).
@@ -1000,7 +1145,7 @@
 * Caching: Force use of BouncyCastle on JellyBean to fix decryption issue
   ([#2755](https://github.com/google/ExoPlayer/issues/2755)).
 
-### r2.5.2 ###
+### r2.5.2 (2017-09-11) ###
 
 * IMA extension: Fix issue where ad playback could end prematurely for some
   content types ([#3180](https://github.com/google/ExoPlayer/issues/3180)).
@@ -1026,14 +1171,14 @@
 * Workaround for SimpleExoPlayerView's surface not being hidden properly
   ([#3160](https://github.com/google/ExoPlayer/issues/3160)).
 
-### r2.5.1 ###
+### r2.5.1 (2017-08-08) ###
 
 * Fix an issue that could cause the reported playback position to stop advancing
   in some cases.
 * Fix an issue where a Surface could be released whilst still in use by the
   player.
 
-### r2.5.0 ###
+### r2.5.0 (2017-08-07) ###
 
 * IMA extension: Wraps the Google Interactive Media Ads (IMA) SDK to provide an
   easy and seamless way of incorporating display ads into ExoPlayer playbacks.
@@ -1087,7 +1232,7 @@
   media playbacks ([#2900](https://github.com/google/ExoPlayer/issues/2900)).
 * Misc bugfixes.
 
-### r2.4.4 ###
+### r2.4.4 (2017-07-19) ###
 
 * HLS/MPEG-TS: Some initial optimizations of MPEG-TS extractor performance
   ([#3040](https://github.com/google/ExoPlayer/issues/3040)).
@@ -1098,7 +1243,7 @@
 * Video: Fix video dimension reporting on some devices
   ([#3007](https://github.com/google/ExoPlayer/issues/3007)).
 
-### r2.4.3 ###
+### r2.4.3 (2017-06-30) ###
 
 * Audio: Workaround custom audio decoders misreporting their maximum supported
   channel counts ([#2940](https://github.com/google/ExoPlayer/issues/2940)).
@@ -1116,7 +1261,7 @@
   ([#2977](https://github.com/google/ExoPlayer/pull/2977)).
 * Misc bugfixes.
 
-### r2.4.2 ###
+### r2.4.2 (2017-06-06) ###
 
 * Stability: Work around Nexus 10 reboot when playing certain content
   ([#2806](https://github.com/google/ExoPlayer/issues/2806)).
@@ -1130,7 +1275,7 @@
   ([#2871](https://github.com/google/ExoPlayer/issues/2871)).
 * Misc bugfixes.
 
-### r2.4.1 ###
+### r2.4.1 (2017-05-23) ###
 
 * Stability: Avoid OutOfMemoryError in extractors when parsing malformed media
   ([#2780](https://github.com/google/ExoPlayer/issues/2780)).
@@ -1153,7 +1298,7 @@
   ([#2824](https://github.com/google/ExoPlayer/issues/2824)).
 * Misc bugfixes.
 
-### r2.4.0 ###
+### r2.4.0 (2017-04-25) ###
 
 * New modular library structure. You can read more about depending on individual
   library modules
@@ -1186,7 +1331,7 @@
 * FLAC extension: Enabled 64 bit targets.
 * Misc bugfixes.
 
-### r2.3.1 ###
+### r2.3.1 (2017-03-23) ###
 
 * Fix NPE enabling WebVTT subtitles in DASH streams
   ([#2596](https://github.com/google/ExoPlayer/issues/2596)).
@@ -1195,7 +1340,7 @@
 * Minor fix for CEA-708 decoder
   ([#2595](https://github.com/google/ExoPlayer/issues/2595)).
 
-### r2.3.0 ###
+### r2.3.0 (2017-03-16) ###
 
 * GVR extension: Wraps the Google VR Audio SDK to provide spatial audio
   rendering. You can read more about the GVR extension
@@ -1242,7 +1387,7 @@
   ([#2427](https://github.com/google/ExoPlayer/issues/2427)).
 * Misc bugfixes.
 
-### r2.2.0 ###
+### r2.2.0 (2017-01-30) ###
 
 * Demo app: Automatic recovery from BehindLiveWindowException, plus improved
   handling of pausing and resuming live streams
@@ -1305,7 +1450,7 @@
   [#2264](https://github.com/google/ExoPlayer/issues/2264) and
   [#2290](https://github.com/google/ExoPlayer/issues/2290).
 
-### r2.1.1 ###
+### r2.1.1 (2016-12-20) ###
 
 * Fix some subtitle types (e.g. WebVTT) being displayed out of sync
   ([#2208](https://github.com/google/ExoPlayer/issues/2208)).
@@ -1315,7 +1460,7 @@
 * Fix issue where playbacks could get stuck in the initial buffering state if
   over 1MB of data needs to be read to initialize the playback.
 
-### r2.1.0 ###
+### r2.1.0 (2016-12-14) ###
 
 * HLS: Support for seeking in live streams
   ([#87](https://github.com/google/ExoPlayer/issues/87)).
@@ -1369,12 +1514,12 @@
   ([#2145](https://github.com/google/ExoPlayer/issues/2145)).
 * Misc bugfixes.
 
-### r2.0.4 ###
+### r2.0.4 (2016-10-20) ###
 
 * Fix crash on Jellybean devices when using playback controls
   ([#1965](https://github.com/google/ExoPlayer/issues/1965)).
 
-### r2.0.3 ###
+### r2.0.3 (2016-10-17) ###
 
 * Fixed NullPointerException in ExtractorMediaSource
   ([#1914](https://github.com/google/ExoPlayer/issues/1914)).
@@ -1391,7 +1536,7 @@
 * Improvements to Cronet network stack extension.
 * Misc bug fixes.
 
-### r2.0.2 ###
+### r2.0.2 (2016-10-06) ###
 
 * Fixes for MergingMediaSource and sideloaded subtitles.
   ([#1882](https://github.com/google/ExoPlayer/issues/1882),
@@ -1402,7 +1547,7 @@
 * Initial support for fragmented MP4 in HLS.
 * Misc bug fixes and minor features.
 
-### r2.0.1 ###
+### r2.0.1 (2016-09-30) ###
 
 * Fix playback of short duration content
   ([#1837](https://github.com/google/ExoPlayer/issues/1837)).
@@ -1411,7 +1556,7 @@
 * Fix live stream buffering (out of memory) issue
   ([#1825](https://github.com/google/ExoPlayer/issues/1825)).
 
-### r2.0.0 ###
+### r2.0.0 (2016-09-14) ###
 
 ExoPlayer 2.x is a major iteration of the library. It includes significant API
 and architectural changes, new features and many bug fixes. You can read about
diff --git a/build.gradle b/build.gradle
index 4761a1fbe0..1d0b459bf5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -21,14 +21,6 @@ buildscript {
         classpath 'com.novoda:bintray-release:0.9'
         classpath 'com.google.android.gms:strict-version-matcher-plugin:1.1.0'
     }
-    // Workaround for the following test coverage issue. Remove when fixed:
-    // https://code.google.com/p/android/issues/detail?id=226070
-    configurations.all {
-        resolutionStrategy {
-            force 'org.jacoco:org.jacoco.report:0.7.4.201502262128'
-            force 'org.jacoco:org.jacoco.core:0.7.4.201502262128'
-        }
-    }
 }
 allprojects {
     repositories {
@@ -36,7 +28,7 @@ allprojects {
         jcenter()
     }
     project.ext {
-        exoplayerPublishEnabled = true
+        exoplayerPublishEnabled = false
     }
     if (it.hasProperty('externalBuildDir')) {
         if (!new File(externalBuildDir).isAbsolute()) {
@@ -44,6 +36,7 @@ allprojects {
         }
         buildDir = "${externalBuildDir}/${project.name}"
     }
+    group = 'com.google.android.exoplayer'
 }
 
 apply from: 'javadoc_combined.gradle'
diff --git a/constants.gradle b/constants.gradle
index b2ee322ee6..5334adcb39 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.10.1'
-    releaseVersionCode = 2010001
+    releaseVersion = '2.10.5'
+    releaseVersionCode = 2010005
     minSdkVersion = 16
     targetSdkVersion = 28
     compileSdkVersion = 28
diff --git a/core_settings.gradle b/core_settings.gradle
index 4d90fa962a..38889e1a21 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -38,6 +38,7 @@ include modulePrefix + 'extension-vp9'
 include modulePrefix + 'extension-rtmp'
 include modulePrefix + 'extension-leanback'
 include modulePrefix + 'extension-jobdispatcher'
+include modulePrefix + 'extension-workmanager'
 
 project(modulePrefix + 'library').projectDir = new File(rootDir, 'library/all')
 project(modulePrefix + 'library-core').projectDir = new File(rootDir, 'library/core')
@@ -60,3 +61,4 @@ project(modulePrefix + 'extension-vp9').projectDir = new File(rootDir, 'extensio
 project(modulePrefix + 'extension-rtmp').projectDir = new File(rootDir, 'extensions/rtmp')
 project(modulePrefix + 'extension-leanback').projectDir = new File(rootDir, 'extensions/leanback')
 project(modulePrefix + 'extension-jobdispatcher').projectDir = new File(rootDir, 'extensions/jobdispatcher')
+project(modulePrefix + 'extension-workmanager').projectDir = new File(rootDir, 'extensions/workmanager')
diff --git a/demos/cast/build.gradle b/demos/cast/build.gradle
index c951dccc5a..85e60f2796 100644
--- a/demos/cast/build.gradle
+++ b/demos/cast/build.gradle
@@ -47,17 +47,6 @@ android {
         // The demo app isn't indexed and doesn't have translations.
         disable 'GoogleAppIndexingWarning','MissingTranslation'
     }
-
-    flavorDimensions "receiver"
-
-    productFlavors {
-        defaultCast {
-            dimension "receiver"
-            manifestPlaceholders =
-                    [castOptionsProvider: "com.google.android.exoplayer2VRT.ext.cast.DefaultCastOptionsProvider"]
-        }
-    }
-
 }
 
 dependencies {
diff --git a/demos/cast/src/main/AndroidManifest.xml b/demos/cast/src/main/AndroidManifest.xml
index 619b9c9c2a..81b6e7cbf5 100644
--- a/demos/cast/src/main/AndroidManifest.xml
+++ b/demos/cast/src/main/AndroidManifest.xml
@@ -25,7 +25,7 @@
       android:largeHeap="true" android:allowBackup="false">
 
     <meta-data android:name="com.google.android.gms.cast.framework.OPTIONS_PROVIDER_CLASS_NAME"
-        android:value="${castOptionsProvider}" />
+        android:value="com.google.android.exoplayer2VRT.ext.cast.DefaultCastOptionsProvider"/>
 
     <activity android:name=".MainActivity"
         android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2VRT/castdemo/DefaultReceiverPlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2VRT/castdemo/DefaultReceiverPlayerManager.java
index 1ac5e2df45..8e5eca29b9 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2VRT/castdemo/DefaultReceiverPlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2VRT/castdemo/DefaultReceiverPlayerManager.java
@@ -66,7 +66,6 @@
   private final Listener listener;
   private final ConcatenatingMediaSource concatenatingMediaSource;
 
-  private boolean castMediaQueueCreationPending;
   private int currentItemIndex;
   private Player currentPlayer;
 
@@ -268,9 +267,6 @@ public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
   public void onTimelineChanged(
       Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
     updateCurrentItemIndex();
-    if (currentPlayer == castPlayer && timeline.isEmpty()) {
-      castMediaQueueCreationPending = true;
-    }
   }
 
   // CastPlayer.SessionAvailabilityListener implementation.
@@ -332,7 +328,6 @@ private void setCurrentPlayer(Player currentPlayer) {
     this.currentPlayer = currentPlayer;
 
     // Media queue management.
-    castMediaQueueCreationPending = currentPlayer == castPlayer;
     if (currentPlayer == exoPlayer) {
       exoPlayer.prepare(concatenatingMediaSource);
     }
@@ -352,12 +347,11 @@ private void setCurrentPlayer(Player currentPlayer) {
    */
   private void setCurrentItem(int itemIndex, long positionMs, boolean playWhenReady) {
     maybeSetCurrentItemAndNotify(itemIndex);
-    if (castMediaQueueCreationPending) {
+    if (currentPlayer == castPlayer && castPlayer.getCurrentTimeline().isEmpty()) {
       MediaQueueItem[] items = new MediaQueueItem[mediaQueue.size()];
       for (int i = 0; i < items.length; i++) {
         items[i] = buildMediaQueueItem(mediaQueue.get(i));
       }
-      castMediaQueueCreationPending = false;
       castPlayer.loadItems(items, itemIndex, positionMs, Player.REPEAT_MODE_OFF);
     } else {
       currentPlayer.seekTo(itemIndex, positionMs);
diff --git a/demos/ima/build.gradle b/demos/ima/build.gradle
index 33161b4121..124555d9b5 100644
--- a/demos/ima/build.gradle
+++ b/demos/ima/build.gradle
@@ -53,7 +53,7 @@ dependencies {
     implementation project(modulePrefix + 'library-hls')
     implementation project(modulePrefix + 'library-smoothstreaming')
     implementation project(modulePrefix + 'extension-ima')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
 }
 
 apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index 7089d4d731..06c5d1ffb7 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -62,7 +62,7 @@ android {
 }
 
 dependencies {
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'androidx.legacy:legacy-support-core-ui:1.0.0'
     implementation 'androidx.fragment:fragment:1.0.0'
     implementation 'com.google.android.material:material:1.0.0'
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/DemoDownloadService.java b/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/DemoDownloadService.java
index 19ffcf97a8..f0a1db8d5d 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/DemoDownloadService.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/DemoDownloadService.java
@@ -41,7 +41,8 @@ public DemoDownloadService() {
         FOREGROUND_NOTIFICATION_ID,
         DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL,
         CHANNEL_ID,
-        R.string.exo_download_notification_channel_name);
+        R.string.exo_download_notification_channel_name,
+        /* channelDescriptionResourceId= */ 0);
     nextNotificationId = FOREGROUND_NOTIFICATION_ID + 1;
   }
 
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/TrackSelectionDialog.java b/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/TrackSelectionDialog.java
index 37e04bd2c6..7c76b1438a 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/TrackSelectionDialog.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2VRT/demo/TrackSelectionDialog.java
@@ -306,7 +306,7 @@ public CharSequence getPageTitle(int position) {
     }
   }
 
-  /** Fragment to show a track seleciton in tab of the track selection dialog. */
+  /** Fragment to show a track selection in tab of the track selection dialog. */
   public static final class TrackSelectionViewFragment extends Fragment
       implements TrackSelectionView.TrackSelectionListener {
 
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index 4dc463ff81..68a7494a3f 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -31,8 +31,8 @@ android {
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:16.1.2'
-    implementation 'androidx.annotation:annotation:1.0.2'
+    api 'com.google.android.gms:play-services-cast-framework:17.0.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/CastPlayer.java
index 18a6708be8..05b5d2c085 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/CastPlayer.java
@@ -45,8 +45,11 @@
 import com.google.android.gms.cast.framework.media.RemoteMediaClient.MediaChannelResult;
 import com.google.android.gms.common.api.PendingResult;
 import com.google.android.gms.common.api.ResultCallback;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * {@link Player} implementation that communicates with a Cast receiver app.
@@ -80,17 +83,18 @@
   private final CastTimelineTracker timelineTracker;
   private final Timeline.Period period;
 
-  private RemoteMediaClient remoteMediaClient;
-
   // Result callbacks.
   private final StatusListener statusListener;
   private final SeekResultCallback seekResultCallback;
 
-  // Listeners.
-  private final CopyOnWriteArraySet<EventListener> listeners;
-  private SessionAvailabilityListener sessionAvailabilityListener;
+  // Listeners and notification.
+  private final CopyOnWriteArrayList<ListenerHolder> listeners;
+  private final ArrayList<ListenerNotificationTask> notificationsBatch;
+  private final ArrayDeque<ListenerNotificationTask> ongoingNotificationsTasks;
+  @Nullable private SessionAvailabilityListener sessionAvailabilityListener;
 
   // Internal state.
+  @Nullable private RemoteMediaClient remoteMediaClient;
   private CastTimeline currentTimeline;
   private TrackGroupArray currentTrackGroups;
   private TrackSelectionArray currentTrackSelection;
@@ -113,7 +117,9 @@ public CastPlayer(CastContext castContext) {
     period = new Timeline.Period();
     statusListener = new StatusListener();
     seekResultCallback = new SeekResultCallback();
-    listeners = new CopyOnWriteArraySet<>();
+    listeners = new CopyOnWriteArrayList<>();
+    notificationsBatch = new ArrayList<>();
+    ongoingNotificationsTasks = new ArrayDeque<>();
 
     SessionManager sessionManager = castContext.getSessionManager();
     sessionManager.addSessionManagerListener(statusListener, CastSession.class);
@@ -141,6 +147,7 @@ public CastPlayer(CastContext castContext) {
    *     starts at position 0.
    * @return The Cast {@code PendingResult}, or null if no session is available.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> loadItem(MediaQueueItem item, long positionMs) {
     return loadItems(new MediaQueueItem[] {item}, 0, positionMs, REPEAT_MODE_OFF);
   }
@@ -156,8 +163,9 @@ public CastPlayer(CastContext castContext) {
    * @param repeatMode The repeat mode for the created media queue.
    * @return The Cast {@code PendingResult}, or null if no session is available.
    */
-  public PendingResult<MediaChannelResult> loadItems(MediaQueueItem[] items, int startIndex,
-      long positionMs, @RepeatMode int repeatMode) {
+  @Nullable
+  public PendingResult<MediaChannelResult> loadItems(
+      MediaQueueItem[] items, int startIndex, long positionMs, @RepeatMode int repeatMode) {
     if (remoteMediaClient != null) {
       positionMs = positionMs != C.TIME_UNSET ? positionMs : 0;
       waitingForInitialTimeline = true;
@@ -173,6 +181,7 @@ public CastPlayer(CastContext castContext) {
    * @param items The items to append.
    * @return The Cast {@code PendingResult}, or null if no media queue exists.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> addItems(MediaQueueItem... items) {
     return addItems(MediaQueueItem.INVALID_ITEM_ID, items);
   }
@@ -187,6 +196,7 @@ public CastPlayer(CastContext castContext) {
    * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
    *     periodId} exist.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> addItems(int periodId, MediaQueueItem... items) {
     if (getMediaStatus() != null && (periodId == MediaQueueItem.INVALID_ITEM_ID
         || currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET)) {
@@ -204,6 +214,7 @@ public CastPlayer(CastContext castContext) {
    * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
    *     periodId} exist.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> removeItem(int periodId) {
     if (getMediaStatus() != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET) {
       return remoteMediaClient.queueRemoveItem(periodId, null);
@@ -222,6 +233,7 @@ public CastPlayer(CastContext castContext) {
    * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
    *     periodId} exist.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> moveItem(int periodId, int newIndex) {
     Assertions.checkArgument(newIndex >= 0 && newIndex < currentTimeline.getPeriodCount());
     if (getMediaStatus() != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET) {
@@ -239,6 +251,7 @@ public CastPlayer(CastContext castContext) {
    * @return The item that corresponds to the period with the given id, or null if no media queue or
    *     period with id {@code periodId} exist.
    */
+  @Nullable
   public MediaQueueItem getItem(int periodId) {
     MediaStatus mediaStatus = getMediaStatus();
     return mediaStatus != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET
@@ -257,9 +270,9 @@ public boolean isCastSessionAvailable() {
   /**
    * Sets a listener for updates on the cast session availability.
    *
-   * @param listener The {@link SessionAvailabilityListener}.
+   * @param listener The {@link SessionAvailabilityListener}, or null to clear the listener.
    */
-  public void setSessionAvailabilityListener(SessionAvailabilityListener listener) {
+  public void setSessionAvailabilityListener(@Nullable SessionAvailabilityListener listener) {
     sessionAvailabilityListener = listener;
   }
 
@@ -296,12 +309,17 @@ public Looper getApplicationLooper() {
 
   @Override
   public void addListener(EventListener listener) {
-    listeners.add(listener);
+    listeners.addIfAbsent(new ListenerHolder(listener));
   }
 
   @Override
   public void removeListener(EventListener listener) {
-    listeners.remove(listener);
+    for (ListenerHolder listenerHolder : listeners) {
+      if (listenerHolder.listener.equals(listener)) {
+        listenerHolder.release();
+        listeners.remove(listenerHolder);
+      }
+    }
   }
 
   @Override
@@ -310,6 +328,13 @@ public int getPlaybackState() {
   }
 
   @Override
+  @PlaybackSuppressionReason
+  public int getPlaybackSuppressionReason() {
+    return Player.PLAYBACK_SUPPRESSION_REASON_NONE;
+  }
+
+  @Override
+  @Nullable
   public ExoPlaybackException getPlaybackError() {
     return null;
   }
@@ -347,14 +372,13 @@ public void seekTo(int windowIndex, long positionMs) {
       pendingSeekCount++;
       pendingSeekWindowIndex = windowIndex;
       pendingSeekPositionMs = positionMs;
-      for (EventListener listener : listeners) {
-        listener.onPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPositionDiscontinuity(DISCONTINUITY_REASON_SEEK)));
     } else if (pendingSeekCount == 0) {
-      for (EventListener listener : listeners) {
-        listener.onSeekProcessed();
-      }
+      notificationsBatch.add(new ListenerNotificationTask(EventListener::onSeekProcessed));
     }
+    flushNotifications();
   }
 
   @Override
@@ -518,42 +542,58 @@ public long getContentBufferedPosition() {
 
   // Internal methods.
 
-  public void updateInternalState() {
+  private void updateInternalState() {
     if (remoteMediaClient == null) {
       // There is no session. We leave the state of the player as it is now.
       return;
     }
 
+    boolean wasPlaying = playbackState == Player.STATE_READY && playWhenReady;
     int playbackState = fetchPlaybackState(remoteMediaClient);
     boolean playWhenReady = !remoteMediaClient.isPaused();
     if (this.playbackState != playbackState
         || this.playWhenReady != playWhenReady) {
       this.playbackState = playbackState;
       this.playWhenReady = playWhenReady;
-      for (EventListener listener : listeners) {
-        listener.onPlayerStateChanged(this.playWhenReady, this.playbackState);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPlayerStateChanged(this.playWhenReady, this.playbackState)));
+    }
+    boolean isPlaying = playbackState == Player.STATE_READY && playWhenReady;
+    if (wasPlaying != isPlaying) {
+      notificationsBatch.add(
+          new ListenerNotificationTask(listener -> listener.onIsPlayingChanged(isPlaying)));
     }
     @RepeatMode int repeatMode = fetchRepeatMode(remoteMediaClient);
     if (this.repeatMode != repeatMode) {
       this.repeatMode = repeatMode;
-      for (EventListener listener : listeners) {
-        listener.onRepeatModeChanged(repeatMode);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(listener -> listener.onRepeatModeChanged(this.repeatMode)));
+    }
+    maybeUpdateTimelineAndNotify();
+
+    int currentWindowIndex = C.INDEX_UNSET;
+    MediaQueueItem currentItem = remoteMediaClient.getCurrentItem();
+    if (currentItem != null) {
+      currentWindowIndex = currentTimeline.getIndexOfPeriod(currentItem.getItemId());
+    }
+    if (currentWindowIndex == C.INDEX_UNSET) {
+      // The timeline is empty. Fall back to index 0, which is what ExoPlayer would do.
+      currentWindowIndex = 0;
     }
-    int currentWindowIndex = fetchCurrentWindowIndex(getMediaStatus());
     if (this.currentWindowIndex != currentWindowIndex && pendingSeekCount == 0) {
       this.currentWindowIndex = currentWindowIndex;
-      for (EventListener listener : listeners) {
-        listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener ->
+                  listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION)));
     }
     if (updateTracksAndSelections()) {
-      for (EventListener listener : listeners) {
-        listener.onTracksChanged(currentTrackGroups, currentTrackSelection);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onTracksChanged(currentTrackGroups, currentTrackSelection)));
     }
-    maybeUpdateTimelineAndNotify();
+    flushNotifications();
   }
 
   private void maybeUpdateTimelineAndNotify() {
@@ -561,9 +601,10 @@ private void maybeUpdateTimelineAndNotify() {
       @Player.TimelineChangeReason int reason = waitingForInitialTimeline
           ? Player.TIMELINE_CHANGE_REASON_PREPARED : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
       waitingForInitialTimeline = false;
-      for (EventListener listener : listeners) {
-        listener.onTimelineChanged(currentTimeline, null, reason);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener ->
+                  listener.onTimelineChanged(currentTimeline, /* manifest= */ null, reason)));
     }
   }
 
@@ -653,7 +694,8 @@ private void setRemoteMediaClient(@Nullable RemoteMediaClient remoteMediaClient)
     }
   }
 
-  private @Nullable MediaStatus getMediaStatus() {
+  @Nullable
+  private MediaStatus getMediaStatus() {
     return remoteMediaClient != null ? remoteMediaClient.getMediaStatus() : null;
   }
 
@@ -701,16 +743,6 @@ private static int fetchRepeatMode(RemoteMediaClient remoteMediaClient) {
     }
   }
 
-  /**
-   * Retrieves the current item index from {@code mediaStatus} and maps it into a window index. If
-   * there is no media session, returns 0.
-   */
-  private static int fetchCurrentWindowIndex(@Nullable MediaStatus mediaStatus) {
-    Integer currentItemId = mediaStatus != null
-        ? mediaStatus.getIndexById(mediaStatus.getCurrentItemId()) : null;
-    return currentItemId != null ? currentItemId : 0;
-  }
-
   private static boolean isTrackActive(long id, long[] activeTrackIds) {
     for (long activeTrackId : activeTrackIds) {
       if (activeTrackId == id) {
@@ -826,7 +858,23 @@ public void onSessionResuming(CastSession castSession, String s) {
 
   }
 
-  // Result callbacks hooks.
+  // Internal methods.
+
+  private void flushNotifications() {
+    boolean recursiveNotification = !ongoingNotificationsTasks.isEmpty();
+    ongoingNotificationsTasks.addAll(notificationsBatch);
+    notificationsBatch.clear();
+    if (recursiveNotification) {
+      // This will be handled once the current notification task is finished.
+      return;
+    }
+    while (!ongoingNotificationsTasks.isEmpty()) {
+      ongoingNotificationsTasks.peekFirst().execute();
+      ongoingNotificationsTasks.removeFirst();
+    }
+  }
+
+  // Internal classes.
 
   private final class SeekResultCallback implements ResultCallback<MediaChannelResult> {
 
@@ -840,9 +888,25 @@ public void onResult(@NonNull MediaChannelResult result) {
       if (--pendingSeekCount == 0) {
         pendingSeekWindowIndex = C.INDEX_UNSET;
         pendingSeekPositionMs = C.TIME_UNSET;
-        for (EventListener listener : listeners) {
-          listener.onSeekProcessed();
-        }
+        notificationsBatch.add(new ListenerNotificationTask(EventListener::onSeekProcessed));
+        flushNotifications();
+      }
+    }
+  }
+
+  private final class ListenerNotificationTask {
+
+    private final Iterator<ListenerHolder> listenersSnapshot;
+    private final ListenerInvocation listenerInvocation;
+
+    private ListenerNotificationTask(ListenerInvocation listenerInvocation) {
+      this.listenersSnapshot = listeners.iterator();
+      this.listenerInvocation = listenerInvocation;
+    }
+
+    public void execute() {
+      while (listenersSnapshot.hasNext()) {
+        listenersSnapshot.next().invoke(listenerInvocation);
       }
     }
   }
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/DefaultCastOptionsProvider.java b/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/DefaultCastOptionsProvider.java
index 0f17a6525f..1f731a8479 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/DefaultCastOptionsProvider.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2VRT/ext/cast/DefaultCastOptionsProvider.java
@@ -20,6 +20,7 @@
 import com.google.android.gms.cast.framework.CastOptions;
 import com.google.android.gms.cast.framework.OptionsProvider;
 import com.google.android.gms.cast.framework.SessionProvider;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -36,7 +37,7 @@ public CastOptions getCastOptions(Context context) {
 
   @Override
   public List<SessionProvider> getAdditionalSessionProviders(Context context) {
-    return null;
+    return Collections.emptyList();
   }
 
 }
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 76972a3530..b2dd6bc889 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -31,9 +31,9 @@ android {
 }
 
 dependencies {
-    api 'org.chromium.net:cronet-embedded:73.3683.76'
+    api 'org.chromium.net:cronet-embedded:75.3770.101'
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'library')
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2VRT/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2VRT/ext/cronet/CronetDataSource.java
index a360b12d41..842776a455 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2VRT/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2VRT/ext/cronet/CronetDataSource.java
@@ -299,6 +299,13 @@ public void clearAllRequestProperties() {
     requestProperties.clear();
   }
 
+  @Override
+  public int getResponseCode() {
+    return responseInfo == null || responseInfo.getHttpStatusCode() <= 0
+        ? -1
+        : responseInfo.getHttpStatusCode();
+  }
+
   @Override
   public Map<String, List<String>> getResponseHeaders() {
     return responseInfo == null ? Collections.emptyMap() : responseInfo.getAllHeaders();
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index ffecdcd16f..15952b1860 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -38,7 +38,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2VRT/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2VRT/ext/ffmpeg/FfmpegDecoder.java
index 000f703a2b..5a19d46fa9 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2VRT/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2VRT/ext/ffmpeg/FfmpegDecoder.java
@@ -172,28 +172,49 @@ public int getSampleRate() {
   private static @Nullable byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
-      case MimeTypes.AUDIO_ALAC:
       case MimeTypes.AUDIO_OPUS:
         return initializationData.get(0);
+      case MimeTypes.AUDIO_ALAC:
+        return getAlacExtraData(initializationData);
       case MimeTypes.AUDIO_VORBIS:
-        byte[] header0 = initializationData.get(0);
-        byte[] header1 = initializationData.get(1);
-        byte[] extraData = new byte[header0.length + header1.length + 6];
-        extraData[0] = (byte) (header0.length >> 8);
-        extraData[1] = (byte) (header0.length & 0xFF);
-        System.arraycopy(header0, 0, extraData, 2, header0.length);
-        extraData[header0.length + 2] = 0;
-        extraData[header0.length + 3] = 0;
-        extraData[header0.length + 4] =  (byte) (header1.length >> 8);
-        extraData[header0.length + 5] = (byte) (header1.length & 0xFF);
-        System.arraycopy(header1, 0, extraData, header0.length + 6, header1.length);
-        return extraData;
+        return getVorbisExtraData(initializationData);
       default:
         // Other codecs do not require extra data.
         return null;
     }
   }
 
+  private static byte[] getAlacExtraData(List<byte[]> initializationData) {
+    // FFmpeg's ALAC decoder expects an ALAC atom, which contains the ALAC "magic cookie", as extra
+    // data. initializationData[0] contains only the magic cookie, and so we need to package it into
+    // an ALAC atom. See:
+    // https://ffmpeg.org/doxygen/0.6/alac_8c.html
+    // https://github.com/macosforge/alac/blob/master/ALACMagicCookieDescription.txt
+    byte[] magicCookie = initializationData.get(0);
+    int alacAtomLength = 12 + magicCookie.length;
+    ByteBuffer alacAtom = ByteBuffer.allocate(alacAtomLength);
+    alacAtom.putInt(alacAtomLength);
+    alacAtom.putInt(0x616c6163); // type=alac
+    alacAtom.putInt(0); // version=0, flags=0
+    alacAtom.put(magicCookie, /* offset= */ 0, magicCookie.length);
+    return alacAtom.array();
+  }
+
+  private static byte[] getVorbisExtraData(List<byte[]> initializationData) {
+    byte[] header0 = initializationData.get(0);
+    byte[] header1 = initializationData.get(1);
+    byte[] extraData = new byte[header0.length + header1.length + 6];
+    extraData[0] = (byte) (header0.length >> 8);
+    extraData[1] = (byte) (header0.length & 0xFF);
+    System.arraycopy(header0, 0, extraData, 2, header0.length);
+    extraData[header0.length + 2] = 0;
+    extraData[header0.length + 3] = 0;
+    extraData[header0.length + 4] = (byte) (header1.length >> 8);
+    extraData[header0.length + 5] = (byte) (header1.length & 0xFF);
+    System.arraycopy(header1, 0, extraData, header0.length + 6, header1.length);
+    return extraData;
+  }
+
   private native long ffmpegInitialize(
       String codecName,
       @Nullable byte[] extraData,
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index 06a5888404..c67de27697 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -39,7 +39,8 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     androidTestImplementation project(modulePrefix + 'testutils')
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
diff --git a/extensions/flac/proguard-rules.txt b/extensions/flac/proguard-rules.txt
index a1eaa37911..435e2cc4b7 100644
--- a/extensions/flac/proguard-rules.txt
+++ b/extensions/flac/proguard-rules.txt
@@ -9,6 +9,9 @@
 -keep class com.google.android.exoplayer2VRT.ext.flac.FlacDecoderJni {
     *;
 }
--keep class com.google.android.exoplayer2VRT.util.FlacStreamInfo {
+-keep class com.google.android.exoplayer2VRT.util.FlacStreamMetadata {
+    *;
+}
+-keep class com.google.android.exoplayer2VRT.metadata.flac.PictureFrame {
     *;
 }
diff --git a/extensions/flac/src/androidTest/AndroidManifest.xml b/extensions/flac/src/androidTest/AndroidManifest.xml
index 15a2fe11b6..7f6d7d1ed8 100644
--- a/extensions/flac/src/androidTest/AndroidManifest.xml
+++ b/extensions/flac/src/androidTest/AndroidManifest.xml
@@ -21,7 +21,7 @@
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-sdk/>
 
-  <application android:debuggable="true"
+  <application
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
     <uses-library android:name="android.test.runner"/>
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeekerTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeekerTest.java
index 021feded61..192a8a6403 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeekerTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeekerTest.java
@@ -52,7 +52,10 @@ public void testGetSeekMap_returnsSeekMapWithCorrectDuration()
 
     FlacBinarySearchSeeker seeker =
         new FlacBinarySearchSeeker(
-            decoderJni.decodeMetadata(), /* firstFramePosition= */ 0, data.length, decoderJni);
+            decoderJni.decodeStreamMetadata(),
+            /* firstFramePosition= */ 0,
+            data.length,
+            decoderJni);
 
     SeekMap seekMap = seeker.getSeekMap();
     assertThat(seekMap).isNotNull();
@@ -70,7 +73,10 @@ public void testSetSeekTargetUs_returnsSeekPending()
     decoderJni.setData(input);
     FlacBinarySearchSeeker seeker =
         new FlacBinarySearchSeeker(
-            decoderJni.decodeMetadata(), /* firstFramePosition= */ 0, data.length, decoderJni);
+            decoderJni.decodeStreamMetadata(),
+            /* firstFramePosition= */ 0,
+            data.length,
+            decoderJni);
 
     seeker.setSeekTargetUs(/* timeUs= */ 1000);
     assertThat(seeker.isSeeking()).isTrue();
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractorTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractorTest.java
index 373449ef02..af74e4cbab 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractorTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractorTest.java
@@ -28,7 +28,7 @@
 public class FlacExtractorTest {
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     if (!FlacLibrary.isAvailable()) {
       fail("Flac library not available.");
     }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeeker.java b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeeker.java
index 657ea30b37..901d33cb03 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeeker.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacBinarySearchSeeker.java
@@ -19,7 +19,7 @@
 import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
 import com.google.android.exoplayer2VRT.extractor.SeekMap;
 import com.google.android.exoplayer2VRT.util.Assertions;
-import com.google.android.exoplayer2VRT.util.FlacStreamInfo;
+import com.google.android.exoplayer2VRT.util.FlacStreamMetadata;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
@@ -34,20 +34,20 @@
   private final FlacDecoderJni decoderJni;
 
   public FlacBinarySearchSeeker(
-      FlacStreamInfo streamInfo,
+      FlacStreamMetadata streamMetadata,
       long firstFramePosition,
       long inputLength,
       FlacDecoderJni decoderJni) {
     super(
-        new FlacSeekTimestampConverter(streamInfo),
+        new FlacSeekTimestampConverter(streamMetadata),
         new FlacTimestampSeeker(decoderJni),
-        streamInfo.durationUs(),
+        streamMetadata.durationUs(),
         /* floorTimePosition= */ 0,
-        /* ceilingTimePosition= */ streamInfo.totalSamples,
+        /* ceilingTimePosition= */ streamMetadata.totalSamples,
         /* floorBytePosition= */ firstFramePosition,
         /* ceilingBytePosition= */ inputLength,
-        /* approxBytesPerFrame= */ streamInfo.getApproxBytesPerFrame(),
-        /* minimumSearchRange= */ Math.max(1, streamInfo.minFrameSize));
+        /* approxBytesPerFrame= */ streamMetadata.getApproxBytesPerFrame(),
+        /* minimumSearchRange= */ Math.max(1, streamMetadata.minFrameSize));
     this.decoderJni = Assertions.checkNotNull(decoderJni);
   }
 
@@ -112,15 +112,15 @@ public TimestampSearchResult searchForTimestamp(
    * the timestamp for a stream seek time position.
    */
   private static final class FlacSeekTimestampConverter implements SeekTimestampConverter {
-    private final FlacStreamInfo streamInfo;
+    private final FlacStreamMetadata streamMetadata;
 
-    public FlacSeekTimestampConverter(FlacStreamInfo streamInfo) {
-      this.streamInfo = streamInfo;
+    public FlacSeekTimestampConverter(FlacStreamMetadata streamMetadata) {
+      this.streamMetadata = streamMetadata;
     }
 
     @Override
     public long timeUsToTargetTime(long timeUs) {
-      return Assertions.checkNotNull(streamInfo).getSampleIndex(timeUs);
+      return Assertions.checkNotNull(streamMetadata).getSampleIndex(timeUs);
     }
   }
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoder.java
index c5ff26c5d8..b322e50e2b 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoder.java
@@ -15,11 +15,13 @@
  */
 package com.google.android.exoplayer2VRT.ext.flac;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.Format;
+import com.google.android.exoplayer2VRT.ParserException;
 import com.google.android.exoplayer2VRT.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2VRT.decoder.SimpleDecoder;
 import com.google.android.exoplayer2VRT.decoder.SimpleOutputBuffer;
-import com.google.android.exoplayer2VRT.util.FlacStreamInfo;
+import com.google.android.exoplayer2VRT.util.FlacStreamMetadata;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
@@ -56,21 +58,20 @@ public FlacDecoder(
     }
     decoderJni = new FlacDecoderJni();
     decoderJni.setData(ByteBuffer.wrap(initializationData.get(0)));
-    FlacStreamInfo streamInfo;
+    FlacStreamMetadata streamMetadata;
     try {
-      streamInfo = decoderJni.decodeMetadata();
+      streamMetadata = decoderJni.decodeStreamMetadata();
+    } catch (ParserException e) {
+      throw new FlacDecoderException("Failed to decode StreamInfo", e);
     } catch (IOException | InterruptedException e) {
       // Never happens.
       throw new IllegalStateException(e);
     }
-    if (streamInfo == null) {
-      throw new FlacDecoderException("Metadata decoding failed");
-    }
 
     int initialInputBufferSize =
-        maxInputBufferSize != Format.NO_VALUE ? maxInputBufferSize : streamInfo.maxFrameSize;
+        maxInputBufferSize != Format.NO_VALUE ? maxInputBufferSize : streamMetadata.maxFrameSize;
     setInitialInputBufferSize(initialInputBufferSize);
-    maxOutputBufferSize = streamInfo.maxDecodedFrameSize();
+    maxOutputBufferSize = streamMetadata.maxDecodedFrameSize();
   }
 
   @Override
@@ -94,6 +95,7 @@ protected FlacDecoderException createUnexpectedDecodeException(Throwable error)
   }
 
   @Override
+  @Nullable
   protected FlacDecoderException decode(
       DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoderJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoderJni.java
index 0c67d1e611..13e276b008 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoderJni.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacDecoderJni.java
@@ -15,13 +15,16 @@
  */
 package com.google.android.exoplayer2VRT.ext.flac;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.C;
+import com.google.android.exoplayer2VRT.ParserException;
 import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
-import com.google.android.exoplayer2VRT.util.FlacStreamInfo;
+import com.google.android.exoplayer2VRT.util.FlacStreamMetadata;
+import com.google.android.exoplayer2VRT.util.Util;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
+/**exoplayer2VRT
  * JNI wrapper for the libflac Flac decoder.
  */
 /* package */ final class FlacDecoderJni {
@@ -37,14 +40,14 @@ public FlacFrameDecodeException(String message, int errorCode) {
     }
   }
 
-  private static final int TEMP_BUFFER_SIZE = 8192; // The same buffer size which libflac has
+  private static final int TEMP_BUFFER_SIZE = 8192; // The same buffer size as libflac.
 
   private final long nativeDecoderContext;
 
-  private ByteBuffer byteBufferData;
-  private ExtractorInput extractorInput;
+  @Nullable private ByteBuffer byteBufferData;
+  @Nullable private ExtractorInput extractorInput;
+  @Nullable private byte[] tempBuffer;
   private boolean endOfExtractorInput;
-  private byte[] tempBuffer;
 
   public FlacDecoderJni() throws FlacDecoderException {
     if (!FlacLibrary.isAvailable()) {
@@ -57,67 +60,79 @@ public FlacDecoderJni() throws FlacDecoderException {
   }
 
   /**
-   * Sets data to be parsed by libflac.
-   * @param byteBufferData Source {@link ByteBuffer}
+   * Sets the data to be parsed.
+   *
+   * @param byteBufferData Source {@link ByteBuffer}.
    */
   public void setData(ByteBuffer byteBufferData) {
     this.byteBufferData = byteBufferData;
     this.extractorInput = null;
-    this.tempBuffer = null;
   }
 
   /**
-   * Sets data to be parsed by libflac.
-   * @param extractorInput Source {@link ExtractorInput}
+   * Sets the data to be parsed.
+   *
+   * @param extractorInput Source {@link ExtractorInput}.
    */
   public void setData(ExtractorInput extractorInput) {
     this.byteBufferData = null;
     this.extractorInput = extractorInput;
+    endOfExtractorInput = false;
     if (tempBuffer == null) {
-      this.tempBuffer = new byte[TEMP_BUFFER_SIZE];
+      tempBuffer = new byte[TEMP_BUFFER_SIZE];
     }
-    endOfExtractorInput = false;
   }
 
+  /**
+   * Returns whether the end of the data to be parsed has been reached, or true if no data was set.
+   */
   public boolean isEndOfData() {
     if (byteBufferData != null) {
       return byteBufferData.remaining() == 0;
     } else if (extractorInput != null) {
       return endOfExtractorInput;
+    } else {
+      return true;
     }
-    return true;
+  }
+
+  /** Clears the data to be parsed. */
+  public void clearData() {
+    byteBufferData = null;
+    extractorInput = null;
   }
 
   /**
    * Reads up to {@code length} bytes from the data source.
-   * <p>
-   * This method blocks until at least one byte of data can be read, the end of the input is
+   *
+   * <p>This method blocks until at least one byte of data can be read, the end of the input is
    * detected or an exception is thrown.
-   * <p>
-   * This method is called from the native code.
    *
    * @param target A target {@link ByteBuffer} into which data should be written.
-   * @return Returns the number of bytes read, or -1 on failure. It's not an error if this returns
-   * zero; it just means all the data read from the source.
+   * @return Returns the number of bytes read, or -1 on failure. If all of the data has already been
+   *     read from the source, then 0 is returned.
    */
+  @SuppressWarnings("unused") // Called from native code.
   public int read(ByteBuffer target) throws IOException, InterruptedException {
     int byteCount = target.remaining();
     if (byteBufferData != null) {
       byteCount = Math.min(byteCount, byteBufferData.remaining());
       int originalLimit = byteBufferData.limit();
       byteBufferData.limit(byteBufferData.position() + byteCount);
-
       target.put(byteBufferData);
-
       byteBufferData.limit(originalLimit);
     } else if (extractorInput != null) {
+      ExtractorInput extractorInput = this.extractorInput;
+      byte[] tempBuffer = Util.castNonNull(this.tempBuffer);
       byteCount = Math.min(byteCount, TEMP_BUFFER_SIZE);
-      int read = readFromExtractorInput(0, byteCount);
+      int read = readFromExtractorInput(extractorInput, tempBuffer, /* offset= */ 0, byteCount);
       if (read < 4) {
         // Reading less than 4 bytes, most of the time, happens because of getting the bytes left in
         // the buffer of the input. Do another read to reduce the number of calls to this method
         // from the native code.
-        read += readFromExtractorInput(read, byteCount - read);
+        read +=
+            readFromExtractorInput(
+                extractorInput, tempBuffer, read, /* length= */ byteCount - read);
       }
       byteCount = read;
       target.put(tempBuffer, 0, byteCount);
@@ -127,9 +142,13 @@ public int read(ByteBuffer target) throws IOException, InterruptedException {
     return byteCount;
   }
 
-  /** Decodes and consumes the StreamInfo section from the FLAC stream. */
-  public FlacStreamInfo decodeMetadata() throws IOException, InterruptedException {
-    return flacDecodeMetadata(nativeDecoderContext);
+  /** Decodes and consumes the metadata from the FLAC stream. */
+  public FlacStreamMetadata decodeStreamMetadata() throws IOException, InterruptedException {
+    FlacStreamMetadata streamMetadata = flacDecodeMetadata(nativeDecoderContext);
+    if (streamMetadata == null) {
+      throw new ParserException("Failed to decode stream metadata");
+    }
+    return streamMetadata;
   }
 
   /**
@@ -234,7 +253,8 @@ public void release() {
     flacRelease(nativeDecoderContext);
   }
 
-  private int readFromExtractorInput(int offset, int length)
+  private int readFromExtractorInput(
+      ExtractorInput extractorInput, byte[] tempBuffer, int offset, int length)
       throws IOException, InterruptedException {
     int read = extractorInput.read(tempBuffer, offset, length);
     if (read == C.RESULT_END_OF_INPUT) {
@@ -246,7 +266,7 @@ private int readFromExtractorInput(int offset, int length)
 
   private native long flacInit();
 
-  private native FlacStreamInfo flacDecodeMetadata(long context)
+  private native FlacStreamMetadata flacDecodeMetadata(long context)
       throws IOException, InterruptedException;
 
   private native int flacDecodeToBuffer(long context, ByteBuffer outputBuffer)
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractor.java
index e6dca30330..41fe44333f 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2VRT/ext/flac/FlacExtractor.java
@@ -21,7 +21,7 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.Format;
-import com.google.android.exoplayer2VRT.extractor.BinarySearchSeeker;
+import com.google.android.exoplayer2VRT.extractor.BinarySearchSeeker.OutputFrameHolder;
 import com.google.android.exoplayer2VRT.extractor.Extractor;
 import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
 import com.google.android.exoplayer2VRT.extractor.ExtractorOutput;
@@ -33,7 +33,8 @@
 import com.google.android.exoplayer2VRT.extractor.TrackOutput;
 import com.google.android.exoplayer2VRT.metadata.Metadata;
 import com.google.android.exoplayer2VRT.metadata.id3.Id3Decoder;
-import com.google.android.exoplayer2VRT.util.FlacStreamInfo;
+import com.google.android.exoplayer2VRT.util.Assertions;
+import com.google.android.exoplayer2VRT.util.FlacStreamMetadata;
 import com.google.android.exoplayer2VRT.util.MimeTypes;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
 import java.io.IOException;
@@ -42,6 +43,9 @@
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * Facilitates the extraction of data from the FLAC container format.
@@ -74,23 +78,20 @@
    */
   private static final byte[] FLAC_SIGNATURE = {'f', 'L', 'a', 'C', 0, 0, 0, 0x22};
 
+  private final ParsableByteArray outputBuffer;
   private final Id3Peeker id3Peeker;
-  private final boolean isId3MetadataDisabled;
+  private final boolean id3MetadataDisabled;
 
-  private FlacDecoderJni decoderJni;
+  @Nullable private FlacDecoderJni decoderJni;
+  private @MonotonicNonNull ExtractorOutput extractorOutput;
+  private @MonotonicNonNull TrackOutput trackOutput;
 
-  private ExtractorOutput extractorOutput;
-  private TrackOutput trackOutput;
+  private boolean streamMetadataDecoded;
+  private @MonotonicNonNull FlacStreamMetadata streamMetadata;
+  private @MonotonicNonNull OutputFrameHolder outputFrameHolder;
 
-  private ParsableByteArray outputBuffer;
-  private ByteBuffer outputByteBuffer;
-  private BinarySearchSeeker.OutputFrameHolder outputFrameHolder;
-  private FlacStreamInfo streamInfo;
-
-  private Metadata id3Metadata;
-  private @Nullable FlacBinarySearchSeeker flacBinarySearchSeeker;
-
-  private boolean readPastStreamInfo;
+  @Nullable private Metadata id3Metadata;
+  @Nullable private FlacBinarySearchSeeker binarySearchSeeker;
 
   /** Constructs an instance with flags = 0. */
   public FlacExtractor() {
@@ -103,8 +104,9 @@ public FlacExtractor() {
    * @param flags Flags that control the extractor's behavior.
    */
   public FlacExtractor(int flags) {
+    outputBuffer = new ParsableByteArray();
     id3Peeker = new Id3Peeker();
-    isId3MetadataDisabled = (flags & FLAG_DISABLE_ID3_METADATA) != 0;
+    id3MetadataDisabled = (flags & FLAG_DISABLE_ID3_METADATA) != 0;
   }
 
   @Override
@@ -130,48 +132,53 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public int read(final ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    if (input.getPosition() == 0 && !isId3MetadataDisabled && id3Metadata == null) {
+    if (input.getPosition() == 0 && !id3MetadataDisabled && id3Metadata == null) {
       id3Metadata = peekId3Data(input);
     }
 
-    decoderJni.setData(input);
-    readPastStreamInfo(input);
+    FlacDecoderJni decoderJni = initDecoderJni(input);
+    try {
+      decodeStreamMetadata(input);
 
-    if (flacBinarySearchSeeker != null && flacBinarySearchSeeker.isSeeking()) {
-      return handlePendingSeek(input, seekPosition);
-    }
+      if (binarySearchSeeker != null && binarySearchSeeker.isSeeking()) {
+        return handlePendingSeek(input, seekPosition, outputBuffer, outputFrameHolder, trackOutput);
+      }
 
-    long lastDecodePosition = decoderJni.getDecodePosition();
-    try {
-      decoderJni.decodeSampleWithBacktrackPosition(outputByteBuffer, lastDecodePosition);
-    } catch (FlacDecoderJni.FlacFrameDecodeException e) {
-      throw new IOException("Cannot read frame at position " + lastDecodePosition, e);
-    }
-    int outputSize = outputByteBuffer.limit();
-    if (outputSize == 0) {
-      return RESULT_END_OF_INPUT;
-    }
+      ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
+      long lastDecodePosition = decoderJni.getDecodePosition();
+      try {
+        decoderJni.decodeSampleWithBacktrackPosition(outputByteBuffer, lastDecodePosition);
+      } catch (FlacDecoderJni.FlacFrameDecodeException e) {
+        throw new IOException("Cannot read frame at position " + lastDecodePosition, e);
+      }
+      int outputSize = outputByteBuffer.limit();
+      if (outputSize == 0) {
+        return RESULT_END_OF_INPUT;
+      }
 
-    writeLastSampleToOutput(outputSize, decoderJni.getLastFrameTimestamp());
-    return decoderJni.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
+      outputSample(outputBuffer, outputSize, decoderJni.getLastFrameTimestamp(), trackOutput);
+      return decoderJni.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
+    } finally {
+      decoderJni.clearData();
+    }
   }
 
   @Override
   public void seek(long position, long timeUs) {
     if (position == 0) {
-      readPastStreamInfo = false;
+      streamMetadataDecoded = false;
     }
     if (decoderJni != null) {
       decoderJni.reset(position);
     }
-    if (flacBinarySearchSeeker != null) {
-      flacBinarySearchSeeker.setSeekTargetUs(timeUs);
+    if (binarySearchSeeker != null) {
+      binarySearchSeeker.setSeekTargetUs(timeUs);
     }
   }
 
   @Override
   public void release() {
-    flacBinarySearchSeeker = null;
+    binarySearchSeeker = null;
     if (decoderJni != null) {
       decoderJni.release();
       decoderJni = null;
@@ -179,123 +186,141 @@ public void release() {
   }
 
   /**
-   * Peeks ID3 tag data (if present) at the beginning of the input.
+   * Peeks ID3 tag data at the beginning of the input.
    *
-   * @return The first ID3 tag decoded into a {@link Metadata} object. May be null if ID3 tag is not
-   *     present in the input.
+   * @return The first ID3 tag {@link Metadata}, or null if an ID3 tag is not present in the input.
    */
   @Nullable
   private Metadata peekId3Data(ExtractorInput input) throws IOException, InterruptedException {
     input.resetPeekPosition();
     Id3Decoder.FramePredicate id3FramePredicate =
-        isId3MetadataDisabled ? Id3Decoder.NO_FRAMES_PREDICATE : null;
+        id3MetadataDisabled ? Id3Decoder.NO_FRAMES_PREDICATE : null;
     return id3Peeker.peekId3Data(input, id3FramePredicate);
   }
 
-  /**
-   * Peeks from the beginning of the input to see if {@link #FLAC_SIGNATURE} is present.
-   *
-   * @return Whether the input begins with {@link #FLAC_SIGNATURE}.
-   */
-  private boolean peekFlacSignature(ExtractorInput input) throws IOException, InterruptedException {
-    byte[] header = new byte[FLAC_SIGNATURE.length];
-    input.peekFully(header, 0, FLAC_SIGNATURE.length);
-    return Arrays.equals(header, FLAC_SIGNATURE);
+  @EnsuresNonNull({"decoderJni", "extractorOutput", "trackOutput"}) // Ensures initialized.
+  @SuppressWarnings({"contracts.postcondition.not.satisfied"})
+  private FlacDecoderJni initDecoderJni(ExtractorInput input) {
+    FlacDecoderJni decoderJni = Assertions.checkNotNull(this.decoderJni);
+    decoderJni.setData(input);
+    return decoderJni;
   }
 
-  private void readPastStreamInfo(ExtractorInput input) throws InterruptedException, IOException {
-    if (readPastStreamInfo) {
+  @RequiresNonNull({"decoderJni", "extractorOutput", "trackOutput"}) // Requires initialized.
+  @EnsuresNonNull({"streamMetadata", "outputFrameHolder"}) // Ensures stream metadata decoded.
+  @SuppressWarnings({"contracts.postcondition.not.satisfied"})
+  private void decodeStreamMetadata(ExtractorInput input) throws InterruptedException, IOException {
+    if (streamMetadataDecoded) {
       return;
     }
 
-    FlacStreamInfo streamInfo = decodeStreamInfo(input);
-    readPastStreamInfo = true;
-    if (this.streamInfo == null) {
-      updateFlacStreamInfo(input, streamInfo);
+    FlacStreamMetadata streamMetadata;
+    try {
+      streamMetadata = decoderJni.decodeStreamMetadata();
+    } catch (IOException e) {
+      decoderJni.reset(/* newPosition= */ 0);
+      input.setRetryPosition(/* position= */ 0, e);
+      throw e;
     }
-  }
 
-  private void updateFlacStreamInfo(ExtractorInput input, FlacStreamInfo streamInfo) {
-    this.streamInfo = streamInfo;
-    outputSeekMap(input, streamInfo);
-    outputFormat(streamInfo);
-    outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
-    outputByteBuffer = ByteBuffer.wrap(outputBuffer.data);
-    outputFrameHolder = new BinarySearchSeeker.OutputFrameHolder(outputByteBuffer);
+    streamMetadataDecoded = true;
+    if (this.streamMetadata == null) {
+      this.streamMetadata = streamMetadata;
+      binarySearchSeeker =
+          outputSeekMap(decoderJni, streamMetadata, input.getLength(), extractorOutput);
+      Metadata metadata = id3MetadataDisabled ? null : id3Metadata;
+      if (streamMetadata.metadata != null) {
+        metadata = streamMetadata.metadata.copyWithAppendedEntriesFrom(metadata);
+      }
+      outputFormat(streamMetadata, metadata, trackOutput);
+      outputBuffer.reset(streamMetadata.maxDecodedFrameSize());
+      outputFrameHolder = new OutputFrameHolder(ByteBuffer.wrap(outputBuffer.data));
+    }
   }
 
-  private FlacStreamInfo decodeStreamInfo(ExtractorInput input)
+  @RequiresNonNull("binarySearchSeeker")
+  private int handlePendingSeek(
+      ExtractorInput input,
+      PositionHolder seekPosition,
+      ParsableByteArray outputBuffer,
+      OutputFrameHolder outputFrameHolder,
+      TrackOutput trackOutput)
       throws InterruptedException, IOException {
-    try {
-      FlacStreamInfo streamInfo = decoderJni.decodeMetadata();
-      if (streamInfo == null) {
-        throw new IOException("Metadata decoding failed");
-      }
-      return streamInfo;
-    } catch (IOException e) {
-      decoderJni.reset(0);
-      input.setRetryPosition(0, e);
-      throw e;
+    int seekResult = binarySearchSeeker.handlePendingSeek(input, seekPosition, outputFrameHolder);
+    ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
+    if (seekResult == RESULT_CONTINUE && outputByteBuffer.limit() > 0) {
+      outputSample(outputBuffer, outputByteBuffer.limit(), outputFrameHolder.timeUs, trackOutput);
     }
+    return seekResult;
   }
 
-  private void outputSeekMap(ExtractorInput input, FlacStreamInfo streamInfo) {
-    boolean hasSeekTable = decoderJni.getSeekPosition(0) != -1;
-    SeekMap seekMap =
-        hasSeekTable
-            ? new FlacSeekMap(streamInfo.durationUs(), decoderJni)
-            : getSeekMapForNonSeekTableFlac(input, streamInfo);
-    extractorOutput.seekMap(seekMap);
+  /**
+   * Peeks from the beginning of the input to see if {@link #FLAC_SIGNATURE} is present.
+   *
+   * @return Whether the input begins with {@link #FLAC_SIGNATURE}.
+   */
+  private static boolean peekFlacSignature(ExtractorInput input)
+      throws IOException, InterruptedException {
+    byte[] header = new byte[FLAC_SIGNATURE.length];
+    input.peekFully(header, /* offset= */ 0, FLAC_SIGNATURE.length);
+    return Arrays.equals(header, FLAC_SIGNATURE);
   }
 
-  private SeekMap getSeekMapForNonSeekTableFlac(ExtractorInput input, FlacStreamInfo streamInfo) {
-    long inputLength = input.getLength();
-    if (inputLength != C.LENGTH_UNSET) {
+  /**
+   * Outputs a {@link SeekMap} and returns a {@link FlacBinarySearchSeeker} if one is required to
+   * handle seeks.
+   */
+  @Nullable
+  private static FlacBinarySearchSeeker outputSeekMap(
+      FlacDecoderJni decoderJni,
+      FlacStreamMetadata streamMetadata,
+      long streamLength,
+      ExtractorOutput output) {
+    boolean hasSeekTable = decoderJni.getSeekPosition(/* timeUs= */ 0) != -1;
+    FlacBinarySearchSeeker binarySearchSeeker = null;
+    SeekMap seekMap;
+    if (hasSeekTable) {
+      seekMap = new FlacSeekMap(streamMetadata.durationUs(), decoderJni);
+    } else if (streamLength != C.LENGTH_UNSET) {
       long firstFramePosition = decoderJni.getDecodePosition();
-      flacBinarySearchSeeker =
-          new FlacBinarySearchSeeker(streamInfo, firstFramePosition, inputLength, decoderJni);
-      return flacBinarySearchSeeker.getSeekMap();
-    } else { // can't seek at all, because there's no SeekTable and the input length is unknown.
-      return new SeekMap.Unseekable(streamInfo.durationUs());
+      binarySearchSeeker =
+          new FlacBinarySearchSeeker(streamMetadata, firstFramePosition, streamLength, decoderJni);
+      seekMap = binarySearchSeeker.getSeekMap();
+    } else {
+      seekMap = new SeekMap.Unseekable(streamMetadata.durationUs());
     }
+    output.seekMap(seekMap);
+    return binarySearchSeeker;
   }
 
-  private void outputFormat(FlacStreamInfo streamInfo) {
+  private static void outputFormat(
+      FlacStreamMetadata streamMetadata, @Nullable Metadata metadata, TrackOutput output) {
     Format mediaFormat =
         Format.createAudioSampleFormat(
             /* id= */ null,
             MimeTypes.AUDIO_RAW,
             /* codecs= */ null,
-            streamInfo.bitRate(),
-            streamInfo.maxDecodedFrameSize(),
-            streamInfo.channels,
-            streamInfo.sampleRate,
-            getPcmEncoding(streamInfo.bitsPerSample),
+            streamMetadata.bitRate(),
+            streamMetadata.maxDecodedFrameSize(),
+            streamMetadata.channels,
+            streamMetadata.sampleRate,
+            getPcmEncoding(streamMetadata.bitsPerSample),
             /* encoderDelay= */ 0,
             /* encoderPadding= */ 0,
             /* initializationData= */ null,
             /* drmInitData= */ null,
             /* selectionFlags= */ 0,
             /* language= */ null,
-            isId3MetadataDisabled ? null : id3Metadata);
-    trackOutput.format(mediaFormat);
-  }
-
-  private int handlePendingSeek(ExtractorInput input, PositionHolder seekPosition)
-      throws InterruptedException, IOException {
-    int seekResult =
-        flacBinarySearchSeeker.handlePendingSeek(input, seekPosition, outputFrameHolder);
-    ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
-    if (seekResult == RESULT_CONTINUE && outputByteBuffer.limit() > 0) {
-      writeLastSampleToOutput(outputByteBuffer.limit(), outputFrameHolder.timeUs);
-    }
-    return seekResult;
+            metadata);
+    output.format(mediaFormat);
   }
 
-  private void writeLastSampleToOutput(int size, long lastSampleTimestamp) {
-    outputBuffer.setPosition(0);
-    trackOutput.sampleData(outputBuffer, size);
-    trackOutput.sampleMetadata(lastSampleTimestamp, C.BUFFER_FLAG_KEY_FRAME, size, 0, null);
+  private static void outputSample(
+      ParsableByteArray sampleData, int size, long timeUs, TrackOutput output) {
+    sampleData.setPosition(0);
+    output.sampleData(sampleData, size);
+    output.sampleMetadata(
+        timeUs, C.BUFFER_FLAG_KEY_FRAME, size, /* offset= */ 0, /* encryptionData= */ null);
   }
 
   /** A {@link SeekMap} implementation using a SeekTable within the Flac stream. */
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index 298719d48d..d60a7cead2 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -14,9 +14,12 @@
  * limitations under the License.
  */
 
-#include <jni.h>
 #include <android/log.h>
+#include <jni.h>
+
 #include <cstdlib>
+#include <cstring>
+
 #include "include/flac_parser.h"
 
 #define LOG_TAG "flac_jni"
@@ -95,19 +98,68 @@ DECODER_FUNC(jobject, flacDecodeMetadata, jlong jContext) {
     return NULL;
   }
 
+  jclass arrayListClass = env->FindClass("java/util/ArrayList");
+  jmethodID arrayListConstructor =
+      env->GetMethodID(arrayListClass, "<init>", "()V");
+  jobject commentList = env->NewObject(arrayListClass, arrayListConstructor);
+  jmethodID arrayListAddMethod =
+      env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
+
+  if (context->parser->areVorbisCommentsValid()) {
+    std::vector<std::string> vorbisComments =
+        context->parser->getVorbisComments();
+    for (std::vector<std::string>::const_iterator vorbisComment =
+             vorbisComments.begin();
+         vorbisComment != vorbisComments.end(); ++vorbisComment) {
+      jstring commentString = env->NewStringUTF((*vorbisComment).c_str());
+      env->CallBooleanMethod(commentList, arrayListAddMethod, commentString);
+      env->DeleteLocalRef(commentString);
+    }
+  }
+
+  jobject pictureFrames = env->NewObject(arrayListClass, arrayListConstructor);
+  bool picturesValid = context->parser->arePicturesValid();
+  if (picturesValid) {
+    std::vector<FlacPicture> pictures = context->parser->getPictures();
+    jclass pictureFrameClass = env->FindClass(
+        "com/google/android/exoplayer2/metadata/flac/PictureFrame");
+    jmethodID pictureFrameConstructor =
+        env->GetMethodID(pictureFrameClass, "<init>",
+                         "(ILjava/lang/String;Ljava/lang/String;IIII[B)V");
+    for (std::vector<FlacPicture>::const_iterator picture = pictures.begin();
+         picture != pictures.end(); ++picture) {
+      jstring mimeType = env->NewStringUTF(picture->mimeType.c_str());
+      jstring description = env->NewStringUTF(picture->description.c_str());
+      jbyteArray pictureData = env->NewByteArray(picture->data.size());
+      env->SetByteArrayRegion(pictureData, 0, picture->data.size(),
+                              (signed char *)&picture->data[0]);
+      jobject pictureFrame = env->NewObject(
+          pictureFrameClass, pictureFrameConstructor, picture->type, mimeType,
+          description, picture->width, picture->height, picture->depth,
+          picture->colors, pictureData);
+      env->CallBooleanMethod(pictureFrames, arrayListAddMethod, pictureFrame);
+      env->DeleteLocalRef(mimeType);
+      env->DeleteLocalRef(description);
+      env->DeleteLocalRef(pictureData);
+    }
+  }
+
   const FLAC__StreamMetadata_StreamInfo &streamInfo =
       context->parser->getStreamInfo();
 
-  jclass cls = env->FindClass(
+  jclass flacStreamMetadataClass = env->FindClass(
       "com/google/android/exoplayer2/util/"
-      "FlacStreamInfo");
-  jmethodID constructor = env->GetMethodID(cls, "<init>", "(IIIIIIIJ)V");
-
-  return env->NewObject(cls, constructor, streamInfo.min_blocksize,
-                        streamInfo.max_blocksize, streamInfo.min_framesize,
-                        streamInfo.max_framesize, streamInfo.sample_rate,
-                        streamInfo.channels, streamInfo.bits_per_sample,
-                        streamInfo.total_samples);
+      "FlacStreamMetadata");
+  jmethodID flacStreamMetadataConstructor =
+      env->GetMethodID(flacStreamMetadataClass, "<init>",
+                       "(IIIIIIIJLjava/util/List;Ljava/util/List;)V");
+
+  return env->NewObject(flacStreamMetadataClass, flacStreamMetadataConstructor,
+                        streamInfo.min_blocksize, streamInfo.max_blocksize,
+                        streamInfo.min_framesize, streamInfo.max_framesize,
+                        streamInfo.sample_rate, streamInfo.channels,
+                        streamInfo.bits_per_sample, streamInfo.total_samples,
+                        commentList, pictureFrames);
 }
 
 DECODER_FUNC(jint, flacDecodeToBuffer, jlong jContext, jobject jOutputBuffer) {
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index 83d3367415..830f3e2178 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -172,6 +172,43 @@ void FLACParser::metadataCallback(const FLAC__StreamMetadata *metadata) {
     case FLAC__METADATA_TYPE_SEEKTABLE:
       mSeekTable = &metadata->data.seek_table;
       break;
+    case FLAC__METADATA_TYPE_VORBIS_COMMENT:
+      if (!mVorbisCommentsValid) {
+        FLAC__StreamMetadata_VorbisComment vorbisComment =
+            metadata->data.vorbis_comment;
+        for (FLAC__uint32 i = 0; i < vorbisComment.num_comments; ++i) {
+          FLAC__StreamMetadata_VorbisComment_Entry vorbisCommentEntry =
+              vorbisComment.comments[i];
+          if (vorbisCommentEntry.entry != NULL) {
+            std::string comment(
+                reinterpret_cast<char *>(vorbisCommentEntry.entry),
+                vorbisCommentEntry.length);
+            mVorbisComments.push_back(comment);
+          }
+        }
+        mVorbisCommentsValid = true;
+      } else {
+        ALOGE("FLACParser::metadataCallback unexpected VORBISCOMMENT");
+      }
+      break;
+    case FLAC__METADATA_TYPE_PICTURE: {
+      const FLAC__StreamMetadata_Picture *parsedPicture =
+          &metadata->data.picture;
+      FlacPicture picture;
+      picture.mimeType.assign(std::string(parsedPicture->mime_type));
+      picture.description.assign(
+          std::string((char *)parsedPicture->description));
+      picture.data.assign(parsedPicture->data,
+                          parsedPicture->data + parsedPicture->data_length);
+      picture.width = parsedPicture->width;
+      picture.height = parsedPicture->height;
+      picture.depth = parsedPicture->depth;
+      picture.colors = parsedPicture->colors;
+      picture.type = parsedPicture->type;
+      mPictures.push_back(picture);
+      mPicturesValid = true;
+      break;
+    }
     default:
       ALOGE("FLACParser::metadataCallback unexpected type %u", metadata->type);
       break;
@@ -233,6 +270,8 @@ FLACParser::FLACParser(DataSource *source)
       mCurrentPos(0LL),
       mEOF(false),
       mStreamInfoValid(false),
+      mVorbisCommentsValid(false),
+      mPicturesValid(false),
       mWriteRequested(false),
       mWriteCompleted(false),
       mWriteBuffer(NULL),
@@ -266,6 +305,10 @@ bool FLACParser::init() {
                                             FLAC__METADATA_TYPE_STREAMINFO);
   FLAC__stream_decoder_set_metadata_respond(mDecoder,
                                             FLAC__METADATA_TYPE_SEEKTABLE);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_VORBIS_COMMENT);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_PICTURE);
   FLAC__StreamDecoderInitStatus initStatus;
   initStatus = FLAC__stream_decoder_init_stream(
       mDecoder, read_callback, seek_callback, tell_callback, length_callback,
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
index cea7fbe33b..14ba9e8725 100644
--- a/extensions/flac/src/main/jni/include/flac_parser.h
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -19,6 +19,10 @@
 
 #include <stdint.h>
 
+#include <cstdlib>
+#include <string>
+#include <vector>
+
 // libFLAC parser
 #include "FLAC/stream_decoder.h"
 
@@ -26,6 +30,17 @@
 
 typedef int status_t;
 
+struct FlacPicture {
+  int type;
+  std::string mimeType;
+  std::string description;
+  FLAC__uint32 width;
+  FLAC__uint32 height;
+  FLAC__uint32 depth;
+  FLAC__uint32 colors;
+  std::vector<char> data;
+};
+
 class FLACParser {
  public:
   FLACParser(DataSource *source);
@@ -44,6 +59,14 @@ class FLACParser {
     return mStreamInfo;
   }
 
+  bool areVorbisCommentsValid() const { return mVorbisCommentsValid; }
+
+  std::vector<std::string> getVorbisComments() { return mVorbisComments; }
+
+  bool arePicturesValid() const { return mPicturesValid; }
+
+  const std::vector<FlacPicture> &getPictures() const { return mPictures; }
+
   int64_t getLastFrameTimestamp() const {
     return (1000000LL * mWriteHeader.number.sample_number) / getSampleRate();
   }
@@ -71,6 +94,10 @@ class FLACParser {
       mEOF = false;
       if (newPosition == 0) {
         mStreamInfoValid = false;
+        mVorbisCommentsValid = false;
+        mPicturesValid = false;
+        mVorbisComments.clear();
+        mPictures.clear();
         FLAC__stream_decoder_reset(mDecoder);
       } else {
         FLAC__stream_decoder_flush(mDecoder);
@@ -116,6 +143,14 @@ class FLACParser {
   const FLAC__StreamMetadata_SeekTable *mSeekTable;
   uint64_t firstFrameOffset;
 
+  // cached when the VORBIS_COMMENT metadata is parsed by libFLAC
+  std::vector<std::string> mVorbisComments;
+  bool mVorbisCommentsValid;
+
+  // cached when the PICTURE metadata is parsed by libFLAC
+  std::vector<FlacPicture> mPictures;
+  bool mPicturesValid;
+
   // cached when a decoded PCM block is "written" by libFLAC parser
   bool mWriteRequested;
   bool mWriteCompleted;
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index 50acd6c040..1031d6f4b7 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -33,7 +33,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     api 'com.google.vr:sdk-base:1.190.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
 }
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index a91bbbd981..f51c4f954f 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -32,8 +32,9 @@ android {
 }
 
 dependencies {
-    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.11.2'
+    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.11.3'
     implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'com.google.android.gms:play-services-ads-identifier:16.0.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoader.java
index 6bdf5e4bfb..5e2e39a9f4 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoader.java
@@ -327,6 +327,7 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private final AdDisplayContainer adDisplayContainer;
   private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
+  private boolean wasSetPlayerCalled;
   @Nullable private Player nextPlayer;
   private Object pendingAdRequestContext;
   private List<String> supportedMimeTypes;
@@ -337,6 +338,7 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private int lastVolumePercentage;
 
   private AdsManager adsManager;
+  private boolean initializedAdsManager;
   private AdLoadException pendingAdLoadError;
   private Timeline timeline;
   private long contentDurationMs;
@@ -483,6 +485,7 @@ private ImaAdsLoader(
     pendingContentPositionMs = C.TIME_UNSET;
     adGroupIndex = C.INDEX_UNSET;
     contentDurationMs = C.TIME_UNSET;
+    timeline = Timeline.EMPTY;
   }
 
   /**
@@ -558,6 +561,7 @@ public void setPlayer(@Nullable Player player) {
     Assertions.checkState(
         player == null || player.getApplicationLooper() == Looper.getMainLooper());
     nextPlayer = player;
+    wasSetPlayerCalled = true;
   }
 
   @Override
@@ -585,9 +589,12 @@ public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
 
   @Override
   public void start(EventListener eventListener, AdViewProvider adViewProvider) {
-    Assertions.checkNotNull(
-        nextPlayer, "Set player using adsLoader.setPlayer before preparing the player.");
+    Assertions.checkState(
+        wasSetPlayerCalled, "Set player using adsLoader.setPlayer before preparing the player.");
     player = nextPlayer;
+    if (player == null) {
+      return;
+    }
     this.eventListener = eventListener;
     lastVolumePercentage = 0;
     lastAdProgress = null;
@@ -607,8 +614,8 @@ public void start(EventListener eventListener, AdViewProvider adViewProvider) {
         adsManager.resume();
       }
     } else if (adsManager != null) {
-      // Ads have loaded but the ads manager is not initialized.
-      startAdPlayback();
+      adPlaybackState = new AdPlaybackState(getAdGroupTimesUs(adsManager.getAdCuePoints()));
+      updateAdPlaybackState();
     } else {
       // Ads haven't loaded yet, so request them.
       requestAds(adViewGroup);
@@ -617,6 +624,9 @@ public void start(EventListener eventListener, AdViewProvider adViewProvider) {
 
   @Override
   public void stop() {
+    if (player == null) {
+      return;
+    }
     if (adsManager != null && imaPausedContent) {
       adPlaybackState =
           adPlaybackState.withAdResumePositionUs(
@@ -679,7 +689,8 @@ public void onAdsManagerLoaded(AdsManagerLoadedEvent adsManagerLoadedEvent) {
     if (player != null) {
       // If a player is attached already, start playback immediately.
       try {
-        startAdPlayback();
+        adPlaybackState = new AdPlaybackState(getAdGroupTimesUs(adsManager.getAdCuePoints()));
+        updateAdPlaybackState();
       } catch (Exception e) {
         maybeNotifyInternalError("onAdsManagerLoaded", e);
       }
@@ -959,7 +970,11 @@ public void onTimelineChanged(
     if (contentDurationUs != C.TIME_UNSET) {
       adPlaybackState = adPlaybackState.withContentDurationUs(contentDurationUs);
     }
-    updateImaStateForPlayerState();
+    if (!initializedAdsManager && adsManager != null) {
+      initializedAdsManager = true;
+      initializeAdsManager();
+    }
+    onPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
   }
 
   @Override
@@ -1014,7 +1029,7 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
           }
         }
         updateAdPlaybackState();
-      } else {
+      } else if (!timeline.isEmpty()) {
         long positionMs = player.getCurrentPosition();
         timeline.getPeriod(0, period);
         int newAdGroupIndex = period.getAdGroupIndexForPositionUs(C.msToUs(positionMs));
@@ -1026,14 +1041,13 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
           }
         }
       }
-    } else {
-      updateImaStateForPlayerState();
     }
+    updateImaStateForPlayerState();
   }
 
   // Internal methods.
 
-  private void startAdPlayback() {
+  private void initializeAdsManager() {
     AdsRenderingSettings adsRenderingSettings = imaFactory.createAdsRenderingSettings();
     adsRenderingSettings.setEnablePreloading(ENABLE_PRELOADING);
     adsRenderingSettings.setMimeTypes(supportedMimeTypes);
@@ -1048,19 +1062,13 @@ private void startAdPlayback() {
       adsRenderingSettings.setUiElements(adUiElements);
     }
 
-    // Set up the ad playback state, skipping ads based on the start position as required.
+    // Skip ads based on the start position as required.
     long[] adGroupTimesUs = getAdGroupTimesUs(adsManager.getAdCuePoints());
-    adPlaybackState = new AdPlaybackState(adGroupTimesUs);
-    long contentPositionMs = player.getCurrentPosition();
+    long contentPositionMs = player.getContentPosition();
     int adGroupIndexForPosition =
         adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
-    if (adGroupIndexForPosition == 0) {
-      podIndexOffset = 0;
-    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
-      // There is no preroll and midroll pod indices start at 1.
-      podIndexOffset = -1;
-    } else /* adGroupIndexForPosition > 0 */ {
-      // Skip ad groups before the one at or immediately before the playback position.
+    if (adGroupIndexForPosition > 0 && adGroupIndexForPosition != C.INDEX_UNSET) {
+      // Skip any ad groups before the one at or immediately before the playback position.
       for (int i = 0; i < adGroupIndexForPosition; i++) {
         adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
       }
@@ -1070,9 +1078,18 @@ private void startAdPlayback() {
       long adGroupBeforeTimeUs = adGroupTimesUs[adGroupIndexForPosition - 1];
       double midpointTimeUs = (adGroupForPositionTimeUs + adGroupBeforeTimeUs) / 2d;
       adsRenderingSettings.setPlayAdsAfterTime(midpointTimeUs / C.MICROS_PER_SECOND);
+    }
 
-      // We're removing one or more ads, which means that the earliest ad (if any) will be a
-      // midroll/postroll. Midroll pod indices start at 1.
+    // IMA indexes any remaining midroll ad pods from 1. A preroll (if present) has index 0.
+    // Store an index offset as we want to index all ads (including skipped ones) from 0.
+    if (adGroupIndexForPosition == 0 && adGroupTimesUs[0] == 0) {
+      // We are playing a preroll.
+      podIndexOffset = 0;
+    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
+      // There's no ad to play which means there's no preroll.
+      podIndexOffset = -1;
+    } else {
+      // We are playing a midroll and any ads before it were skipped.
       podIndexOffset = adGroupIndexForPosition - 1;
     }
 
@@ -1081,7 +1098,6 @@ private void startAdPlayback() {
       pendingContentPositionMs = contentPositionMs;
     }
 
-    // Start ad playback.
     adsManager.init(adsRenderingSettings);
     updateAdPlaybackState();
     if (DEBUG) {
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoaderTest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoaderTest.java
index 08a3a9db68..ded505c0f4 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoaderTest.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2VRT/ext/ima/ImaAdsLoaderTest.java
@@ -143,7 +143,8 @@ public void testStart_updatesAdPlaybackState() {
     assertThat(adsLoaderListener.adPlaybackState)
         .isEqualTo(
             new AdPlaybackState(/* adGroupTimesUs= */ 0)
-                .withAdDurationsUs(PREROLL_ADS_DURATIONS_US));
+                .withAdDurationsUs(PREROLL_ADS_DURATIONS_US)
+                .withContentDurationUs(CONTENT_DURATION_US));
   }
 
   @Test
diff --git a/extensions/jobdispatcher/README.md b/extensions/jobdispatcher/README.md
index f70125ba38..a6f0c3966a 100644
--- a/extensions/jobdispatcher/README.md
+++ b/extensions/jobdispatcher/README.md
@@ -1,7 +1,11 @@
 # ExoPlayer Firebase JobDispatcher extension #
 
+**DEPRECATED - Please use [WorkManager extension][] or [PlatformScheduler][] instead.**
+
 This extension provides a Scheduler implementation which uses [Firebase JobDispatcher][].
 
+[WorkManager extension]: https://github.com/google/ExoPlayer/blob/release-v2/extensions/workmanager/README.md
+[PlatformScheduler]: https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
 [Firebase JobDispatcher]: https://github.com/firebase/firebase-jobdispatcher-android
 
 ## Getting the extension ##
@@ -20,4 +24,3 @@ locally. Instructions for doing this can be found in ExoPlayer's
 [top level README][].
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
-
diff --git a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2VRT/ext/jobdispatcher/JobDispatcherScheduler.java b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2VRT/ext/jobdispatcher/JobDispatcherScheduler.java
index 2229ecd95f..37f583d143 100644
--- a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2VRT/ext/jobdispatcher/JobDispatcherScheduler.java
+++ b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2VRT/ext/jobdispatcher/JobDispatcherScheduler.java
@@ -54,7 +54,10 @@
  *
  * @see <a
  *     href="https://developers.google.com/android/reference/com/google/android/gms/common/GoogleApiAvailability#isGooglePlayServicesAvailable(android.content.Context)">GoogleApiAvailability</a>
+ * @deprecated Use com.google.android.exoplayer2VRT.ext.workmanager.WorkManagerScheduler or {@link
+ *     com.google.android.exoplayer2VRT.scheduler.PlatformScheduler}.
  */
+@Deprecated
 public final class JobDispatcherScheduler implements Scheduler {
 
   private static final boolean DEBUG = false;
diff --git a/extensions/leanback/build.gradle b/extensions/leanback/build.gradle
index c6f5a216ce..ecaa78e25b 100644
--- a/extensions/leanback/build.gradle
+++ b/extensions/leanback/build.gradle
@@ -32,7 +32,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'androidx.leanback:leanback:1.0.0'
 }
 
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2VRT/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2VRT/ext/mediasession/MediaSessionConnector.java
index 5c580f4f0e..f570f7a51b 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2VRT/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2VRT/ext/mediasession/MediaSessionConnector.java
@@ -131,6 +131,15 @@
   /** The default rewind increment, in milliseconds. */
   public static final int DEFAULT_REWIND_MS = 5000;
 
+  /**
+   * The name of the {@link PlaybackStateCompat} float extra with the value of {@link
+   * PlaybackParameters#speed}.
+   */
+  public static final String EXTRAS_SPEED = "EXO_SPEED";
+  /**
+   * The name of the {@link PlaybackStateCompat} float extra with the value of {@link
+   * PlaybackParameters#pitch}.
+   */
   public static final String EXTRAS_PITCH = "EXO_PITCH";
 
   private static final long BASE_PLAYBACK_ACTIONS =
@@ -172,7 +181,7 @@ boolean onCommand(
         ResultReceiver cb);
   }
 
-  /** Interface to which playback preparation actions are delegated. */
+  /** Interface to which playback preparation and play actions are delegated. */
   public interface PlaybackPreparer extends CommandReceiver {
 
     long ACTIONS =
@@ -197,14 +206,36 @@ boolean onCommand(
      * @return The bitmask of the supported media actions.
      */
     long getSupportedPrepareActions();
-    /** See {@link MediaSessionCompat.Callback#onPrepare()}. */
-    void onPrepare();
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}. */
-    void onPrepareFromMediaId(String mediaId, Bundle extras);
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}. */
-    void onPrepareFromSearch(String query, Bundle extras);
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}. */
-    void onPrepareFromUri(Uri uri, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepare()}.
+     *
+     * @param playWhenReady Whether playback should be started after preparation.
+     */
+    void onPrepare(boolean playWhenReady);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}.
+     *
+     * @param mediaId The media id of the media item to be prepared.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromMediaId(String mediaId, boolean playWhenReady, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}.
+     *
+     * @param query The search query.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromSearch(String query, boolean playWhenReady, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}.
+     *
+     * @param uri The {@link Uri} of the media item to be prepared.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromUri(Uri uri, boolean playWhenReady, Bundle extras);
   }
 
   /**
@@ -355,6 +386,13 @@ void onCustomAction(
     /**
      * Gets the {@link MediaMetadataCompat} to be published to the session.
      *
+     * <p>An app may need to load metadata resources like artwork bitmaps asynchronously. In such a
+     * case the app should return a {@link MediaMetadataCompat} object that does not contain these
+     * resources as a placeholder. The app should start an asynchronous operation to download the
+     * bitmap and put it into a cache. Finally, the app should call {@link
+     * #invalidateMediaSessionMetadata()}. This causes this callback to be called again and the app
+     * can now return a {@link MediaMetadataCompat} object with all the resources included.
+     *
      * @param player The player connected to the media session.
      * @return The {@link MediaMetadataCompat} to be published to the session.
      */
@@ -655,7 +693,13 @@ public final void invalidateMediaSessionMetadata() {
   public final void invalidateMediaSessionPlaybackState() {
     PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
     if (player == null) {
-      builder.setActions(buildPrepareActions()).setState(PlaybackStateCompat.STATE_NONE, 0, 0, 0);
+      builder
+          .setActions(buildPrepareActions())
+          .setState(
+              PlaybackStateCompat.STATE_NONE,
+              /* position= */ 0,
+              /* playbackSpeed= */ 0,
+              /* updateTime= */ SystemClock.elapsedRealtime());
       mediaSession.setPlaybackState(builder.build());
       return;
     }
@@ -670,15 +714,13 @@ public final void invalidateMediaSessionPlaybackState() {
     }
     customActionMap = Collections.unmodifiableMap(currentActions);
 
-    int playbackState = player.getPlaybackState();
     Bundle extras = new Bundle();
-    ExoPlaybackException playbackError =
-        playbackState == Player.STATE_IDLE ? player.getPlaybackError() : null;
+    @Nullable ExoPlaybackException playbackError = player.getPlaybackError();
     boolean reportError = playbackError != null || customError != null;
     int sessionPlaybackState =
         reportError
             ? PlaybackStateCompat.STATE_ERROR
-            : mapPlaybackState(player.getPlaybackState(), player.getPlayWhenReady());
+            : getMediaSessionPlaybackState(player.getPlaybackState(), player.getPlayWhenReady());
     if (customError != null) {
       builder.setErrorMessage(customError.first, customError.second);
       if (customErrorExtras != null) {
@@ -692,7 +734,10 @@ public final void invalidateMediaSessionPlaybackState() {
         queueNavigator != null
             ? queueNavigator.getActiveQueueItemId(player)
             : MediaSessionCompat.QueueItem.UNKNOWN_ID;
-    extras.putFloat(EXTRAS_PITCH, player.getPlaybackParameters().pitch);
+    PlaybackParameters playbackParameters = player.getPlaybackParameters();
+    extras.putFloat(EXTRAS_SPEED, playbackParameters.speed);
+    extras.putFloat(EXTRAS_PITCH, playbackParameters.pitch);
+    float sessionPlaybackSpeed = player.isPlaying() ? playbackParameters.speed : 0f;
     builder
         .setActions(buildPrepareActions() | buildPlaybackActions(player))
         .setActiveQueueItemId(activeQueueItemId)
@@ -700,8 +745,8 @@ public final void invalidateMediaSessionPlaybackState() {
         .setState(
             sessionPlaybackState,
             player.getCurrentPosition(),
-            player.getPlaybackParameters().speed,
-            SystemClock.elapsedRealtime())
+            sessionPlaybackSpeed,
+            /* updateTime= */ SystemClock.elapsedRealtime())
         .setExtras(extras);
     mediaSession.setPlaybackState(builder.build());
   }
@@ -794,19 +839,6 @@ private long buildPlaybackActions(Player player) {
     return actions;
   }
 
-  private int mapPlaybackState(int exoPlayerPlaybackState, boolean playWhenReady) {
-    switch (exoPlayerPlaybackState) {
-      case Player.STATE_BUFFERING:
-        return PlaybackStateCompat.STATE_BUFFERING;
-      case Player.STATE_READY:
-        return playWhenReady ? PlaybackStateCompat.STATE_PLAYING : PlaybackStateCompat.STATE_PAUSED;
-      case Player.STATE_ENDED:
-        return PlaybackStateCompat.STATE_STOPPED;
-      default:
-        return PlaybackStateCompat.STATE_NONE;
-    }
-  }
-
   private boolean canDispatchPlaybackAction(long action) {
     return player != null && (enabledPlaybackActions & action) != 0;
   }
@@ -834,13 +866,6 @@ private boolean canDispatchMediaButtonEvent() {
     return player != null && mediaButtonEventHandler != null;
   }
 
-  private void stopPlayerForPrepare(boolean playWhenReady) {
-    if (player != null) {
-      player.stop();
-      player.setPlayWhenReady(playWhenReady);
-    }
-  }
-
   private void rewind(Player player) {
     if (player.isCurrentWindowSeekable() && rewindMs > 0) {
       seekTo(player, player.getCurrentPosition() - rewindMs);
@@ -866,6 +891,20 @@ private void seekTo(Player player, int windowIndex, long positionMs) {
     controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
   }
 
+  private static int getMediaSessionPlaybackState(
+      int exoPlayerPlaybackState, boolean playWhenReady) {
+    switch (exoPlayerPlaybackState) {
+      case Player.STATE_BUFFERING:
+        return PlaybackStateCompat.STATE_BUFFERING;
+      case Player.STATE_READY:
+        return playWhenReady ? PlaybackStateCompat.STATE_PLAYING : PlaybackStateCompat.STATE_PAUSED;
+      case Player.STATE_ENDED:
+        return PlaybackStateCompat.STATE_STOPPED;
+      default:
+        return PlaybackStateCompat.STATE_NONE;
+    }
+  }
+
   /**
    * Provides a default {@link MediaMetadataCompat} with properties and extras taken from the {@link
    * MediaDescriptionCompat} of the {@link MediaSessionCompat.QueueItem} of the active queue item.
@@ -899,7 +938,9 @@ public MediaMetadataCompat getMetadata(Player player) {
       }
       builder.putLong(
           MediaMetadataCompat.METADATA_KEY_DURATION,
-          player.getDuration() == C.TIME_UNSET ? -1 : player.getDuration());
+          player.isCurrentWindowDynamic() || player.getDuration() == C.TIME_UNSET
+              ? -1
+              : player.getDuration());
       long activeQueueItemId = mediaController.getPlaybackState().getActiveQueueItemId();
       if (activeQueueItemId != MediaSessionCompat.QueueItem.UNKNOWN_ID) {
         List<MediaSessionCompat.QueueItem> queue = mediaController.getQueue();
@@ -998,6 +1039,11 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       invalidateMediaSessionPlaybackState();
     }
 
+    @Override
+    public void onIsPlayingChanged(boolean isPlaying) {
+      invalidateMediaSessionPlaybackState();
+    }
+
     @Override
     public void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
       mediaSession.setRepeatMode(
@@ -1047,12 +1093,13 @@ public void onPlay() {
       if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_PLAY)) {
         if (player.getPlaybackState() == Player.STATE_IDLE) {
           if (playbackPreparer != null) {
-            playbackPreparer.onPrepare();
+            playbackPreparer.onPrepare(/* playWhenReady= */ true);
           }
         } else if (player.getPlaybackState() == Player.STATE_ENDED) {
           controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
-        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ true);
+        controlDispatcher.dispatchSetPlayWhenReady(
+            Assertions.checkNotNull(player), /* playWhenReady= */ true);
       }
     }
 
@@ -1182,56 +1229,49 @@ public void onCommand(String command, Bundle extras, ResultReceiver cb) {
     @Override
     public void onPrepare() {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepare();
+        playbackPreparer.onPrepare(/* playWhenReady= */ false);
       }
     }
 
     @Override
     public void onPrepareFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromMediaId(mediaId, extras);
+        playbackPreparer.onPrepareFromMediaId(mediaId, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPrepareFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_SEARCH)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromSearch(query, extras);
+        playbackPreparer.onPrepareFromSearch(query, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPrepareFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_URI)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromUri(uri, extras);
+        playbackPreparer.onPrepareFromUri(uri, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPlayFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromMediaId(mediaId, extras);
+        playbackPreparer.onPrepareFromMediaId(mediaId, /* playWhenReady= */ true, extras);
       }
     }
 
     @Override
     public void onPlayFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_SEARCH)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromSearch(query, extras);
+        playbackPreparer.onPrepareFromSearch(query, /* playWhenReady= */ true, extras);
       }
     }
 
     @Override
     public void onPlayFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_URI)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromUri(uri, extras);
+        playbackPreparer.onPrepareFromUri(uri, /* playWhenReady= */ true, extras);
       }
     }
 
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index db2e073c8a..2395aedd46 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -33,9 +33,9 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    api 'com.squareup.okhttp3:okhttp:3.12.1'
+    api 'com.squareup.okhttp3:okhttp:3.12.5'
 }
 
 ext {
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2VRT/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2VRT/ext/okhttp/OkHttpDataSource.java
index 0e31111aac..f2008f8482 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2VRT/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2VRT/ext/okhttp/OkHttpDataSource.java
@@ -133,6 +133,11 @@ public OkHttpDataSource(
     return response == null ? null : Uri.parse(response.request().url().toString());
   }
 
+  @Override
+  public int getResponseCode() {
+    return response == null ? -1 : response.code();
+  }
+
   @Override
   public Map<String, List<String>> getResponseHeaders() {
     return response == null ? Collections.emptyMap() : response.headers().toMultimap();
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 56acbdb7d3..28f7b05465 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -39,6 +39,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
diff --git a/extensions/opus/src/androidTest/AndroidManifest.xml b/extensions/opus/src/androidTest/AndroidManifest.xml
index 036964f8ae..e6a15f6838 100644
--- a/extensions/opus/src/androidTest/AndroidManifest.xml
+++ b/extensions/opus/src/androidTest/AndroidManifest.xml
@@ -21,7 +21,7 @@
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-sdk/>
 
-  <application android:debuggable="true"
+  <application
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
     <uses-library android:name="android.test.runner"/>
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusDecoder.java
index 8718a50f65..6f5b5501f9 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2VRT.ext.opus;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.decoder.CryptoInfo;
 import com.google.android.exoplayer2VRT.decoder.DecoderInputBuffer;
@@ -150,6 +151,7 @@ protected OpusDecoderException createUnexpectedDecodeException(Throwable error)
   }
 
   @Override
+  @Nullable
   protected OpusDecoderException decode(
       DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusLibrary.java b/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusLibrary.java
index 0e52e9ba55..e5b22babb2 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusLibrary.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2VRT/ext/opus/OpusLibrary.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2VRT.ext.opus;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2VRT.util.LibraryLoader;
 
@@ -49,9 +50,8 @@ public static boolean isAvailable() {
     return LOADER.isAvailable();
   }
 
-  /**
-   * Returns the version of the underlying library if available, or null otherwise.
-   */
+  /** Returns the version of the underlying library if available, or null otherwise. */
+  @Nullable
   public static String getVersion() {
     return isAvailable() ? opusGetVersion() : null;
   }
diff --git a/extensions/rtmp/build.gradle b/extensions/rtmp/build.gradle
index ca734c3657..ba63843043 100644
--- a/extensions/rtmp/build.gradle
+++ b/extensions/rtmp/build.gradle
@@ -32,8 +32,8 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'net.butterflytv.utils:rtmp-client:3.0.1'
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'net.butterflytv.utils:rtmp-client:3.1.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 77e83c90b0..eb42152eb6 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -29,6 +29,7 @@ VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 ```
 
 * Download the [Android NDK][] and set its location in an environment variable.
+  The build configuration has been tested with Android NDK r19c.
 
 ```
 NDK_PATH="<path to Android NDK>"
@@ -54,7 +55,7 @@ git checkout tags/v1.8.0 -b v1.8.0
 
 ```
 cd ${VP9_EXT_PATH}/jni && \
-./generate_libvpx_android_configs.sh "${NDK_PATH}"
+./generate_libvpx_android_configs.sh
 ```
 
 * Build the JNI native libraries from the command line:
@@ -66,7 +67,6 @@ ${NDK_PATH}/ndk-build APP_ABI=all -j4
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
 [Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
-[#3520]: https://github.com/google/ExoPlayer/issues/3520
 
 ## Notes ##
 
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 02b68b831d..92450f0381 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -39,7 +39,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
diff --git a/extensions/vp9/src/androidTest/AndroidManifest.xml b/extensions/vp9/src/androidTest/AndroidManifest.xml
index e93677bf78..9a60fefe0e 100644
--- a/extensions/vp9/src/androidTest/AndroidManifest.xml
+++ b/extensions/vp9/src/androidTest/AndroidManifest.xml
@@ -21,7 +21,7 @@
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-sdk/>
 
-  <application android:debuggable="true"
+  <application
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
     <uses-library android:name="android.test.runner"/>
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/LibvpxVideoRenderer.java
index 586912461d..571e09431a 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/LibvpxVideoRenderer.java
@@ -844,7 +844,7 @@ private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackExcepti
       pendingFormat = null;
     }
     inputBuffer.flip();
-    inputBuffer.colorInfo = formatHolder.format.colorInfo;
+    inputBuffer.colorInfo = format.colorInfo;
     onQueueInputBuffer(inputBuffer);
     decoder.queueInputBuffer(inputBuffer);
     buffersInCodecCount++;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxDecoder.java
index 9c1510a30a..633597b596 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2VRT.ext.vp9;
 
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.decoder.CryptoInfo;
@@ -120,8 +121,9 @@ protected VpxDecoderException createUnexpectedDecodeException(Throwable error) {
   }
 
   @Override
-  protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer,
-      boolean reset) {
+  @Nullable
+  protected VpxDecoderException decode(
+      VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer, boolean reset) {
     ByteBuffer inputData = inputBuffer.data;
     int inputSize = inputData.limit();
     CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxLibrary.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxLibrary.java
index f37e56bcaf..3cc395200b 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxLibrary.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxLibrary.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2VRT.ext.vp9;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2VRT.util.LibraryLoader;
 
@@ -49,9 +50,8 @@ public static boolean isAvailable() {
     return LOADER.isAvailable();
   }
 
-  /**
-   * Returns the version of the underlying library if available, or null otherwise.
-   */
+  /** Returns the version of the underlying library if available, or null otherwise. */
+  @Nullable
   public static String getVersion() {
     return isAvailable() ? vpxGetVersion() : null;
   }
@@ -60,6 +60,7 @@ public static String getVersion() {
    * Returns the configuration string with which the underlying library was built if available, or
    * null otherwise.
    */
+  @Nullable
   public static String getBuildConfig() {
     return isAvailable() ? vpxGetBuildConfig() : null;
   }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxOutputBuffer.java
index c2bf8cfe4c..c4829592e6 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2VRT/ext/vp9/VpxOutputBuffer.java
@@ -60,8 +60,8 @@ public void release() {
    * Initializes the buffer.
    *
    * @param timeUs The presentation timestamp for the buffer, in microseconds.
-   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE} and {@link
-   *     VpxDecoder#OUTPUT_MODE_YUV}.
+   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE}, {@link
+   *     VpxDecoder#OUTPUT_MODE_YUV} and {@link VpxDecoder#OUTPUT_MODE_SURFACE_YUV}.
    */
   public void init(long timeUs, int mode) {
     this.timeUs = timeUs;
@@ -110,6 +110,15 @@ public boolean initForYuvFrame(int width, int height, int yStride, int uvStride,
     return true;
   }
 
+  /**
+   * Configures the buffer for the given frame dimensions when passing actual frame data via {@link
+   * #decoderPrivate}. Called via JNI after decoding completes.
+   */
+  public void initForPrivateFrame(int width, int height) {
+    this.width = width;
+    this.height = height;
+  }
+
   private void initData(int size) {
     if (data == null || data.capacity() < size) {
       data = ByteBuffer.allocateDirect(size);
diff --git a/extensions/vp9/src/main/jni/Application.mk b/extensions/vp9/src/main/jni/Application.mk
index 59bf5f8f87..ed28f07acb 100644
--- a/extensions/vp9/src/main/jni/Application.mk
+++ b/extensions/vp9/src/main/jni/Application.mk
@@ -15,6 +15,6 @@
 #
 
 APP_OPTIM := release
-APP_STL := gnustl_static
+APP_STL := c++_static
 APP_CPPFLAGS := -frtti
-APP_PLATFORM := android-9
+APP_PLATFORM := android-16
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
index eab6862555..18f1dd5c69 100755
--- a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -20,46 +20,33 @@
 
 set -e
 
-if [ $# -ne 1 ]; then
-  echo "Usage: ${0} <path_to_android_ndk>"
+if [ $# -ne 0 ]; then
+  echo "Usage: ${0}"
   exit
 fi
 
-ndk="${1}"
-shift 1
-
 # configuration parameters common to all architectures
 common_params="--disable-examples --disable-docs --enable-realtime-only"
 common_params+=" --disable-vp8 --disable-vp9-encoder --disable-webm-io"
 common_params+=" --disable-libyuv --disable-runtime-cpu-detect"
+common_params+=" --enable-external-build"
 
 # configuration parameters for various architectures
 arch[0]="armeabi-v7a"
-config[0]="--target=armv7-android-gcc --sdk-path=$ndk --enable-neon"
-config[0]+=" --enable-neon-asm"
+config[0]="--target=armv7-android-gcc --enable-neon --enable-neon-asm"
 
-arch[1]="armeabi"
-config[1]="--target=armv7-android-gcc --sdk-path=$ndk --disable-neon"
-config[1]+=" --disable-neon-asm"
+arch[1]="x86"
+config[1]="--force-target=x86-android-gcc --disable-sse2"
+config[1]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
+config[1]+=" --disable-avx2 --enable-pic"
 
-arch[2]="mips"
-config[2]="--force-target=mips32-android-gcc --sdk-path=$ndk"
+arch[2]="arm64-v8a"
+config[2]="--force-target=armv8-android-gcc --enable-neon"
 
-arch[3]="x86"
-config[3]="--force-target=x86-android-gcc --sdk-path=$ndk --disable-sse2"
+arch[3]="x86_64"
+config[3]="--force-target=x86_64-android-gcc --disable-sse2"
 config[3]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
-config[3]+=" --disable-avx2 --enable-pic"
-
-arch[4]="arm64-v8a"
-config[4]="--force-target=armv8-android-gcc --sdk-path=$ndk --enable-neon"
-
-arch[5]="x86_64"
-config[5]="--force-target=x86_64-android-gcc --sdk-path=$ndk --disable-sse2"
-config[5]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
-config[5]+=" --disable-avx2 --enable-pic --disable-neon --disable-neon-asm"
-
-arch[6]="mips64"
-config[6]="--force-target=mips64-android-gcc --sdk-path=$ndk"
+config[3]+=" --disable-avx2 --enable-pic --disable-neon --disable-neon-asm"
 
 limit=$((${#arch[@]} - 1))
 
@@ -102,10 +89,7 @@ for i in $(seq 0 ${limit}); do
   # configure and make
   echo "build_android_configs: "
   echo "configure ${config[${i}]} ${common_params}"
-  ../../libvpx/configure ${config[${i}]} ${common_params} --extra-cflags=" \
-    -isystem $ndk/sysroot/usr/include/arm-linux-androideabi \
-    -isystem $ndk/sysroot/usr/include \
-    "
+  ../../libvpx/configure ${config[${i}]} ${common_params}
   rm -f libvpx_srcs.txt
   for f in ${allowed_files}; do
     # the build system supports multiple different configurations. avoid
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 82c023afbc..9fc8b09a18 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -60,6 +60,7 @@
 
 // JNI references for VpxOutputBuffer class.
 static jmethodID initForYuvFrame;
+static jmethodID initForPrivateFrame;
 static jfieldID dataField;
 static jfieldID outputModeField;
 static jfieldID decoderPrivateField;
@@ -481,6 +482,8 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
       "com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
                                      "(IIIII)Z");
+  initForPrivateFrame =
+      env->GetMethodID(outputBufferClass, "initForPrivateFrame", "(II)V");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
@@ -602,6 +605,10 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     }
     jfb->d_w = img->d_w;
     jfb->d_h = img->d_h;
+    env->CallVoidMethod(jOutputBuffer, initForPrivateFrame, img->d_w, img->d_h);
+    if (env->ExceptionCheck()) {
+      return -1;
+    }
     env->SetIntField(jOutputBuffer, decoderPrivateField,
                      id + kDecoderPrivateBase);
   }
diff --git a/extensions/workmanager/README.md b/extensions/workmanager/README.md
new file mode 100644
index 0000000000..bd2dbc71ad
--- /dev/null
+++ b/extensions/workmanager/README.md
@@ -0,0 +1,22 @@
+# ExoPlayer WorkManager extension
+
+This extension provides a Scheduler implementation which uses [WorkManager][].
+
+[WorkManager]: https://developer.android.com/topic/libraries/architecture/workmanager.html
+
+## Getting the extension
+
+The easiest way to use the extension is to add it as a gradle dependency:
+
+```gradle
+implementation 'com.google.android.exoplayer:extension-workmanager:2.X.X'
+```
+
+where `2.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
+
+Alternatively, you can clone the ExoPlayer repository and depend on the module
+locally. Instructions for doing this can be found in ExoPlayer's
+[top level README][].
+
+[top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
diff --git a/extensions/workmanager/build.gradle b/extensions/workmanager/build.gradle
new file mode 100644
index 0000000000..ea7564316f
--- /dev/null
+++ b/extensions/workmanager/build.gradle
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    testOptions.unitTests.includeAndroidResources = true
+}
+
+dependencies {
+    implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.work:work-runtime:2.1.0'
+}
+
+ext {
+    javadocTitle = 'WorkManager extension'
+}
+apply from: '../../javadoc_library.gradle'
+
+ext {
+    releaseArtifact = 'extension-workmanager'
+    releaseDescription = 'WorkManager extension for ExoPlayer.'
+}
+apply from: '../../publish.gradle'
diff --git a/extensions/workmanager/src/main/AndroidManifest.xml b/extensions/workmanager/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..571045acf1
--- /dev/null
+++ b/extensions/workmanager/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest package="com.google.android.exoplayer2VRT.ext.workmanager"/>
diff --git a/extensions/workmanager/src/main/java/com/google/android/exoplayer2VRT/ext/workmanager/WorkManagerScheduler.java b/extensions/workmanager/src/main/java/com/google/android/exoplayer2VRT/ext/workmanager/WorkManagerScheduler.java
new file mode 100644
index 0000000000..483f64c78b
--- /dev/null
+++ b/extensions/workmanager/src/main/java/com/google/android/exoplayer2VRT/ext/workmanager/WorkManagerScheduler.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.ext.workmanager;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.Intent;
+import androidx.work.Constraints;
+import androidx.work.Data;
+import androidx.work.ExistingWorkPolicy;
+import androidx.work.NetworkType;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkManager;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+import com.google.android.exoplayer2VRT.scheduler.Requirements;
+import com.google.android.exoplayer2VRT.scheduler.Scheduler;
+import com.google.android.exoplayer2VRT.util.Assertions;
+import com.google.android.exoplayer2VRT.util.Log;
+import com.google.android.exoplayer2VRT.util.Util;
+
+/** A {@link Scheduler} that uses {@link WorkManager}. */
+public final class WorkManagerScheduler implements Scheduler {
+
+  private static final boolean DEBUG = false;
+  private static final String TAG = "WorkManagerScheduler";
+  private static final String KEY_SERVICE_ACTION = "service_action";
+  private static final String KEY_SERVICE_PACKAGE = "service_package";
+  private static final String KEY_REQUIREMENTS = "requirements";
+
+  private final String workName;
+
+  /**
+   * @param workName A name for work scheduled by this instance. If the same name was used by a
+   *     previous instance, anything scheduled by the previous instance will be canceled by this
+   *     instance if {@link #schedule(Requirements, String, String)} or {@link #cancel()} are
+   *     called.
+   */
+  public WorkManagerScheduler(String workName) {
+    this.workName = workName;
+  }
+
+  @Override
+  public boolean schedule(Requirements requirements, String servicePackage, String serviceAction) {
+    Constraints constraints = buildConstraints(requirements);
+    Data inputData = buildInputData(requirements, servicePackage, serviceAction);
+    OneTimeWorkRequest workRequest = buildWorkRequest(constraints, inputData);
+    logd("Scheduling work: " + workName);
+    WorkManager.getInstance().enqueueUniqueWork(workName, ExistingWorkPolicy.REPLACE, workRequest);
+    return true;
+  }
+
+  @Override
+  public boolean cancel() {
+    logd("Canceling work: " + workName);
+    WorkManager.getInstance().cancelUniqueWork(workName);
+    return true;
+  }
+
+  private static Constraints buildConstraints(Requirements requirements) {
+    Constraints.Builder builder = new Constraints.Builder();
+
+    if (requirements.isUnmeteredNetworkRequired()) {
+      builder.setRequiredNetworkType(NetworkType.UNMETERED);
+    } else if (requirements.isNetworkRequired()) {
+      builder.setRequiredNetworkType(NetworkType.CONNECTED);
+    } else {
+      builder.setRequiredNetworkType(NetworkType.NOT_REQUIRED);
+    }
+
+    if (requirements.isChargingRequired()) {
+      builder.setRequiresCharging(true);
+    }
+
+    if (requirements.isIdleRequired() && Util.SDK_INT >= 23) {
+      setRequiresDeviceIdle(builder);
+    }
+
+    return builder.build();
+  }
+
+  @TargetApi(23)
+  private static void setRequiresDeviceIdle(Constraints.Builder builder) {
+    builder.setRequiresDeviceIdle(true);
+  }
+
+  private static Data buildInputData(
+      Requirements requirements, String servicePackage, String serviceAction) {
+    Data.Builder builder = new Data.Builder();
+
+    builder.putInt(KEY_REQUIREMENTS, requirements.getRequirements());
+    builder.putString(KEY_SERVICE_PACKAGE, servicePackage);
+    builder.putString(KEY_SERVICE_ACTION, serviceAction);
+
+    return builder.build();
+  }
+
+  private static OneTimeWorkRequest buildWorkRequest(Constraints constraints, Data inputData) {
+    OneTimeWorkRequest.Builder builder = new OneTimeWorkRequest.Builder(SchedulerWorker.class);
+
+    builder.setConstraints(constraints);
+    builder.setInputData(inputData);
+
+    return builder.build();
+  }
+
+  private static void logd(String message) {
+    if (DEBUG) {
+      Log.d(TAG, message);
+    }
+  }
+
+  /** A {@link Worker} that starts the target service if the requirements are met. */
+  // This class needs to be public so that WorkManager can instantiate it.
+  public static final class SchedulerWorker extends Worker {
+
+    private final WorkerParameters workerParams;
+    private final Context context;
+
+    public SchedulerWorker(Context context, WorkerParameters workerParams) {
+      super(context, workerParams);
+      this.workerParams = workerParams;
+      this.context = context;
+    }
+
+    @Override
+    public Result doWork() {
+      logd("SchedulerWorker is started");
+      Data inputData = workerParams.getInputData();
+      Assertions.checkNotNull(inputData, "Work started without input data.");
+      Requirements requirements = new Requirements(inputData.getInt(KEY_REQUIREMENTS, 0));
+      if (requirements.checkRequirements(context)) {
+        logd("Requirements are met");
+        String serviceAction = inputData.getString(KEY_SERVICE_ACTION);
+        String servicePackage = inputData.getString(KEY_SERVICE_PACKAGE);
+        Assertions.checkNotNull(serviceAction, "Service action missing.");
+        Assertions.checkNotNull(servicePackage, "Service package missing.");
+        Intent intent = new Intent(serviceAction).setPackage(servicePackage);
+        logd("Starting service action: " + serviceAction + " package: " + servicePackage);
+        Util.startForegroundService(context, intent);
+        return Result.success();
+      } else {
+        logd("Requirements are not met");
+        return Result.retry();
+      }
+    }
+  }
+}
diff --git a/issues/player-accessed-on-wrong-thread.md b/issues/player-accessed-on-wrong-thread.md
new file mode 100644
index 0000000000..d4f1e74f45
--- /dev/null
+++ b/issues/player-accessed-on-wrong-thread.md
@@ -0,0 +1,5 @@
+---
+permalink: /issues/player-accessed-on-wrong-thread
+redirect_to:
+  - https://exoplayer.dev/troubleshooting.html#what-do-player-is-accessed-on-the-wrong-thread-warnings-mean
+---
diff --git a/library/core/build.gradle b/library/core/build.gradle
index 68ff8cc977..e633e12057 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -58,7 +58,7 @@ android {
 }
 
 dependencies {
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersion
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
diff --git a/library/core/src/androidTest/AndroidManifest.xml b/library/core/src/androidTest/AndroidManifest.xml
index 799db3f3b9..a8f3aadf68 100644
--- a/library/core/src/androidTest/AndroidManifest.xml
+++ b/library/core/src/androidTest/AndroidManifest.xml
@@ -21,7 +21,7 @@
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-sdk/>
 
-  <application android:debuggable="true"
+  <application
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
     <uses-library android:name="android.test.runner"/>
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/BasePlayer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/BasePlayer.java
index 4ba9a9c473..7d9316574c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/BasePlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/BasePlayer.java
@@ -27,6 +27,13 @@ public BasePlayer() {
     window = new Timeline.Window();
   }
 
+  @Override
+  public final boolean isPlaying() {
+    return getPlaybackState() == Player.STATE_READY
+        && getPlayWhenReady()
+        && getPlaybackSuppressionReason() == PLAYBACK_SUPPRESSION_REASON_NONE;
+  }
+
   @Override
   public final void seekToDefaultPosition() {
     seekToDefaultPosition(getCurrentWindowIndex());
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/C.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/C.java
index 35b0a2ebba..998f1ac0ee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/C.java
@@ -71,9 +71,10 @@ private C() {}
   /** Represents an unset or unknown percentage. */
   public static final int PERCENTAGE_UNSET = -1;
 
-  /**
-   * The number of microseconds in one second.
-   */
+  /** The number of milliseconds in one second. */
+  public static final long MILLIS_PER_SECOND = 1000L;
+
+  /** The number of microseconds in one second. */
   public static final long MICROS_PER_SECOND = 1000000L;
 
   /**
@@ -146,8 +147,8 @@ private C() {}
    * {@link #ENCODING_INVALID}, {@link #ENCODING_PCM_8BIT}, {@link #ENCODING_PCM_16BIT}, {@link
    * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
    * #ENCODING_PCM_MU_LAW}, {@link #ENCODING_PCM_A_LAW}, {@link #ENCODING_AC3}, {@link
-   * #ENCODING_E_AC3}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or
-   * {@link #ENCODING_DOLBY_TRUEHD}.
+   * #ENCODING_E_AC3}, {@link #ENCODING_E_AC3_JOC}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS},
+   * {@link #ENCODING_DTS_HD} or {@link #ENCODING_DOLBY_TRUEHD}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -163,6 +164,7 @@ private C() {}
     ENCODING_PCM_A_LAW,
     ENCODING_AC3,
     ENCODING_E_AC3,
+    ENCODING_E_AC3_JOC,
     ENCODING_AC4,
     ENCODING_DTS,
     ENCODING_DTS_HD,
@@ -210,6 +212,8 @@ private C() {}
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
   /** @see AudioFormat#ENCODING_E_AC3 */
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+  /** @see AudioFormat#ENCODING_E_AC3_JOC */
+  public static final int ENCODING_E_AC3_JOC = AudioFormat.ENCODING_E_AC3_JOC;
   /** @see AudioFormat#ENCODING_AC4 */
   public static final int ENCODING_AC4 = AudioFormat.ENCODING_AC4;
   /** @see AudioFormat#ENCODING_DTS */
@@ -667,25 +671,6 @@ private C() {}
   /** A default size in bytes for an individual allocation that forms part of a larger buffer. */
   public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
 
-  /** A default size in bytes for a video buffer. */
-  public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for an audio buffer. */
-  public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a text buffer. */
-  public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a metadata buffer. */
-  public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a camera motion buffer. */
-  public static final int DEFAULT_CAMERA_MOTION_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a muxed buffer (e.g. containing video, audio and text). */
-  public static final int DEFAULT_MUXED_BUFFER_SIZE =
-      DEFAULT_VIDEO_BUFFER_SIZE + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
-
   /** "cenc" scheme type name as defined in ISO/IEC 23001-7:2016. */
   @SuppressWarnings("ConstantField")
   public static final String CENC_TYPE_cenc = "cenc";
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultLoadControl.java
index 7043d8549a..11096b6870 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultLoadControl.java
@@ -67,6 +67,25 @@
   /** The default for whether the back buffer is retained from the previous keyframe. */
   public static final boolean DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME = false;
 
+  /** A default size in bytes for a video buffer. */
+  public static final int DEFAULT_VIDEO_BUFFER_SIZE = 500 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for an audio buffer. */
+  public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a text buffer. */
+  public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a metadata buffer. */
+  public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a camera motion buffer. */
+  public static final int DEFAULT_CAMERA_MOTION_BUFFER_SIZE = 2 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a muxed buffer (e.g. containing video, audio and text). */
+  public static final int DEFAULT_MUXED_BUFFER_SIZE =
+      DEFAULT_VIDEO_BUFFER_SIZE + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
+
   /** Builder for {@link DefaultLoadControl}. */
   public static final class Builder {
 
@@ -404,7 +423,7 @@ protected int calculateTargetBufferSize(
     int targetBufferSize = 0;
     for (int i = 0; i < renderers.length; i++) {
       if (trackSelectionArray.get(i) != null) {
-        targetBufferSize += Util.getDefaultBufferSize(renderers[i].getTrackType());
+        targetBufferSize += getDefaultBufferSize(renderers[i].getTrackType());
       }
     }
     return targetBufferSize;
@@ -418,6 +437,27 @@ private void reset(boolean resetAllocator) {
     }
   }
 
+  private static int getDefaultBufferSize(int trackType) {
+    switch (trackType) {
+      case C.TRACK_TYPE_DEFAULT:
+        return DEFAULT_MUXED_BUFFER_SIZE;
+      case C.TRACK_TYPE_AUDIO:
+        return DEFAULT_AUDIO_BUFFER_SIZE;
+      case C.TRACK_TYPE_VIDEO:
+        return DEFAULT_VIDEO_BUFFER_SIZE;
+      case C.TRACK_TYPE_TEXT:
+        return DEFAULT_TEXT_BUFFER_SIZE;
+      case C.TRACK_TYPE_METADATA:
+        return DEFAULT_METADATA_BUFFER_SIZE;
+      case C.TRACK_TYPE_CAMERA_MOTION:
+        return DEFAULT_CAMERA_MOTION_BUFFER_SIZE;
+      case C.TRACK_TYPE_NONE:
+        return 0;
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   private static boolean hasVideo(Renderer[] renderers, TrackSelectionArray trackSelectionArray) {
     for (int i = 0; i < renderers.length; i++) {
       if (renderers[i].getTrackType() == C.TRACK_TYPE_VIDEO && trackSelectionArray.get(i) != null) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultRenderersFactory.java
index 677ee303c8..79ba392617 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/DefaultRenderersFactory.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2VRT.audio.AudioCapabilities;
 import com.google.android.exoplayer2VRT.audio.AudioProcessor;
 import com.google.android.exoplayer2VRT.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2VRT.audio.DefaultAudioSink;
 import com.google.android.exoplayer2VRT.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2VRT.drm.DrmSessionManager;
 import com.google.android.exoplayer2VRT.drm.FrameworkMediaCrypto;
@@ -90,6 +91,7 @@
   @ExtensionRendererMode private int extensionRendererMode;
   private long allowedVideoJoiningTimeMs;
   private boolean playClearSamplesWithoutKeys;
+  private boolean enableDecoderFallback;
   private MediaCodecSelector mediaCodecSelector;
 
   /** @param context A {@link Context}. */
@@ -202,6 +204,19 @@ public DefaultRenderersFactory setPlayClearSamplesWithoutKeys(
     return this;
   }
 
+  /**
+   * Sets whether to enable fallback to lower-priority decoders if decoder initialization fails.
+   * This may result in using a decoder that is less efficient or slower than the primary decoder.
+   *
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setEnableDecoderFallback(boolean enableDecoderFallback) {
+    this.enableDecoderFallback = enableDecoderFallback;
+    return this;
+  }
+
   /**
    * Sets a {@link MediaCodecSelector} for use by {@link MediaCodec} based renderers.
    *
@@ -248,6 +263,7 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         eventHandler,
         videoRendererEventListener,
         allowedVideoJoiningTimeMs,
@@ -258,6 +274,7 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         buildAudioProcessors(),
         eventHandler,
         audioRendererEventListener,
@@ -282,6 +299,9 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
    * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
    *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
    *     the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
    * @param eventHandler A handler associated with the main thread's looper.
    * @param eventListener An event listener.
    * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
@@ -294,6 +314,7 @@ protected void buildVideoRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
       long allowedVideoJoiningTimeMs,
@@ -305,6 +326,7 @@ protected void buildVideoRenderers(
             allowedVideoJoiningTimeMs,
             drmSessionManager,
             playClearSamplesWithoutKeys,
+            enableDecoderFallback,
             eventHandler,
             eventListener,
             MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
@@ -356,6 +378,9 @@ protected void buildVideoRenderers(
    * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
    *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
    *     the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
    * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
    *     before output. May be empty.
    * @param eventHandler A handler to use when invoking event listeners and outputs.
@@ -368,6 +393,7 @@ protected void buildAudioRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       AudioProcessor[] audioProcessors,
       Handler eventHandler,
       AudioRendererEventListener eventListener,
@@ -378,10 +404,10 @@ protected void buildAudioRenderers(
             mediaCodecSelector,
             drmSessionManager,
             playClearSamplesWithoutKeys,
+            enableDecoderFallback,
             eventHandler,
             eventListener,
-            AudioCapabilities.getCapabilities(context),
-            audioProcessors));
+            new DefaultAudioSink(AudioCapabilities.getCapabilities(context), audioProcessors)));
 
     if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
       return;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImpl.java
index a82bcd6d1c..cccbfb585e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImpl.java
@@ -64,8 +64,8 @@
 
   private MediaSource mediaSource;
   private boolean playWhenReady;
-  private boolean internalPlayWhenReady;
-  private @RepeatMode int repeatMode;
+  @PlaybackSuppressionReason private int playbackSuppressionReason;
+  @RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
   private int pendingOperationAcks;
   private boolean hasPendingPrepare;
@@ -119,6 +119,7 @@ public ExoPlayerImpl(
     period = new Timeline.Period();
     playbackParameters = PlaybackParameters.DEFAULT;
     seekParameters = SeekParameters.DEFAULT;
+    playbackSuppressionReason = PLAYBACK_SUPPRESSION_REASON_NONE;
     eventHandler =
         new Handler(looper) {
           @Override
@@ -197,8 +198,14 @@ public int getPlaybackState() {
     return playbackInfo.playbackState;
   }
 
+  @PlaybackSuppressionReason
+  public int getPlaybackSuppressionReason() {
+    return playbackSuppressionReason;
+  }
+
   @Override
-  public @Nullable ExoPlaybackException getPlaybackError() {
+  @Nullable
+  public ExoPlaybackException getPlaybackError() {
     return playbackError;
   }
 
@@ -239,19 +246,35 @@ public void prepare(MediaSource mediaSource, boolean resetPosition, boolean rese
 
   @Override
   public void setPlayWhenReady(boolean playWhenReady) {
-    setPlayWhenReady(playWhenReady, /* suppressPlayback= */ false);
+    setPlayWhenReady(playWhenReady, PLAYBACK_SUPPRESSION_REASON_NONE);
   }
 
-  public void setPlayWhenReady(boolean playWhenReady, boolean suppressPlayback) {
-    boolean internalPlayWhenReady = playWhenReady && !suppressPlayback;
-    if (this.internalPlayWhenReady != internalPlayWhenReady) {
-      this.internalPlayWhenReady = internalPlayWhenReady;
+  public void setPlayWhenReady(
+      boolean playWhenReady, @PlaybackSuppressionReason int playbackSuppressionReason) {
+    boolean oldIsPlaying = isPlaying();
+    boolean oldInternalPlayWhenReady =
+        this.playWhenReady && this.playbackSuppressionReason == PLAYBACK_SUPPRESSION_REASON_NONE;
+    boolean internalPlayWhenReady =
+        playWhenReady && playbackSuppressionReason == PLAYBACK_SUPPRESSION_REASON_NONE;
+    if (oldInternalPlayWhenReady != internalPlayWhenReady) {
       internalPlayer.setPlayWhenReady(internalPlayWhenReady);
     }
-    if (this.playWhenReady != playWhenReady) {
-      this.playWhenReady = playWhenReady;
+    boolean playWhenReadyChanged = this.playWhenReady != playWhenReady;
+    this.playWhenReady = playWhenReady;
+    this.playbackSuppressionReason = playbackSuppressionReason;
+    boolean isPlaying = isPlaying();
+    boolean isPlayingChanged = oldIsPlaying != isPlaying;
+    if (playWhenReadyChanged || isPlayingChanged) {
       int playbackState = playbackInfo.playbackState;
-      notifyListeners(listener -> listener.onPlayerStateChanged(playWhenReady, playbackState));
+      notifyListeners(
+          listener -> {
+            if (playWhenReadyChanged) {
+              listener.onPlayerStateChanged(playWhenReady, playbackState);
+            }
+            if (isPlayingChanged) {
+              listener.onIsPlayingChanged(isPlaying);
+            }
+          });
     }
   }
 
@@ -510,7 +533,7 @@ public long getBufferedPosition() {
 
   @Override
   public long getTotalBufferedDuration() {
-    return Math.max(0, C.usToMs(playbackInfo.totalBufferedDurationUs));
+    return C.usToMs(playbackInfo.totalBufferedDurationUs);
   }
 
   @Override
@@ -532,7 +555,9 @@ public int getCurrentAdIndexInAdGroup() {
   public long getContentPosition() {
     if (isPlayingAd()) {
       playbackInfo.timeline.getPeriodByUid(playbackInfo.periodId.periodUid, period);
-      return period.getPositionInWindowMs() + C.usToMs(playbackInfo.contentPositionUs);
+      return playbackInfo.contentPositionUs == C.TIME_UNSET
+          ? playbackInfo.timeline.getWindow(getCurrentWindowIndex(), window).getDefaultPositionMs()
+          : period.getPositionInWindowMs() + C.usToMs(playbackInfo.contentPositionUs);
     } else {
       return getCurrentPosition();
     }
@@ -695,9 +720,11 @@ private void updatePlaybackInfo(
       @Player.DiscontinuityReason int positionDiscontinuityReason,
       @Player.TimelineChangeReason int timelineChangeReason,
       boolean seekProcessed) {
+    boolean previousIsPlaying = isPlaying();
     // Assign playback info immediately such that all getters return the right values.
     PlaybackInfo previousPlaybackInfo = this.playbackInfo;
     this.playbackInfo = playbackInfo;
+    boolean isPlaying = isPlaying();
     notifyListeners(
         new PlaybackInfoUpdate(
             playbackInfo,
@@ -708,7 +735,8 @@ private void updatePlaybackInfo(
             positionDiscontinuityReason,
             timelineChangeReason,
             seekProcessed,
-            playWhenReady));
+            playWhenReady,
+            /* isPlayingChanged= */ previousIsPlaying != isPlaying));
   }
 
   private void notifyListeners(ListenerInvocation listenerInvocation) {
@@ -753,6 +781,7 @@ private boolean shouldMaskPosition() {
     private final boolean isLoadingChanged;
     private final boolean trackSelectorResultChanged;
     private final boolean playWhenReady;
+    private final boolean isPlayingChanged;
 
     public PlaybackInfoUpdate(
         PlaybackInfo playbackInfo,
@@ -760,10 +789,11 @@ public PlaybackInfoUpdate(
         CopyOnWriteArrayList<ListenerHolder> listeners,
         TrackSelector trackSelector,
         boolean positionDiscontinuity,
-        @Player.DiscontinuityReason int positionDiscontinuityReason,
-        @Player.TimelineChangeReason int timelineChangeReason,
+        @DiscontinuityReason int positionDiscontinuityReason,
+        @TimelineChangeReason int timelineChangeReason,
         boolean seekProcessed,
-        boolean playWhenReady) {
+        boolean playWhenReady,
+        boolean isPlayingChanged) {
       this.playbackInfo = playbackInfo;
       this.listenerSnapshot = new CopyOnWriteArrayList<>(listeners);
       this.trackSelector = trackSelector;
@@ -772,6 +802,7 @@ public PlaybackInfoUpdate(
       this.timelineChangeReason = timelineChangeReason;
       this.seekProcessed = seekProcessed;
       this.playWhenReady = playWhenReady;
+      this.isPlayingChanged = isPlayingChanged;
       playbackStateChanged = previousPlaybackInfo.playbackState != playbackInfo.playbackState;
       timelineOrManifestChanged =
           previousPlaybackInfo.timeline != playbackInfo.timeline
@@ -811,6 +842,12 @@ public void run() {
             listenerSnapshot,
             listener -> listener.onPlayerStateChanged(playWhenReady, playbackInfo.playbackState));
       }
+      if (isPlayingChanged) {
+        invokeAll(
+            listenerSnapshot,
+            listener ->
+                listener.onIsPlayingChanged(playbackInfo.playbackState == Player.STATE_READY));
+      }
       if (seekProcessed) {
         invokeAll(listenerSnapshot, EventListener::onSeekProcessed);
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImplInternal.java
index 91752a0a60..dc83a4db3d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerImplInternal.java
@@ -729,13 +729,20 @@ private long seekToPeriodPosition(
       newPlayingPeriodHolder = queue.advancePlayingPeriod();
     }
 
-    // Disable all the renderers if the period being played is changing, or if forced.
-    if (oldPlayingPeriodHolder != newPlayingPeriodHolder || forceDisableRenderers) {
+    // Disable all renderers if the period being played is changing, if the seek results in negative
+    // renderer timestamps, or if forced.
+    if (forceDisableRenderers
+        || oldPlayingPeriodHolder != newPlayingPeriodHolder
+        || (newPlayingPeriodHolder != null
+            && newPlayingPeriodHolder.toRendererTime(periodPositionUs) < 0)) {
       for (Renderer renderer : enabledRenderers) {
         disableRenderer(renderer);
       }
       enabledRenderers = new Renderer[0];
       oldPlayingPeriodHolder = null;
+      if (newPlayingPeriodHolder != null) {
+        newPlayingPeriodHolder.setRendererOffset(/* rendererPositionOffsetUs= */ 0);
+      }
     }
 
     // Update the holders.
@@ -1297,8 +1304,11 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       Pair<Object, Long> defaultPosition =
           getPeriodPosition(
               timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
-      newContentPositionUs = defaultPosition.second;
-      newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, newContentPositionUs);
+      newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, defaultPosition.second);
+      if (!newPeriodId.isAd()) {
+        // Keep unset start position if we need to play an ad first.
+        newContentPositionUs = defaultPosition.second;
+      }
     } else if (timeline.getIndexOfPeriod(newPeriodId.periodUid) == C.INDEX_UNSET) {
       // The current period isn't in the new timeline. Attempt to resolve a subsequent period whose
       // window we can restart from.
@@ -1314,9 +1324,16 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
               timeline, timeline.getPeriodByUid(newPeriodUid, period).windowIndex, C.TIME_UNSET);
       newContentPositionUs = defaultPosition.second;
       newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, newContentPositionUs);
-    } else if (newPeriodId.isAd()) {
-      // Recheck if the current ad still needs to be played.
-      newPeriodId = queue.resolveMediaPeriodIdForAds(newPeriodId.periodUid, newContentPositionUs);
+    } else {
+      // Recheck if the current ad still needs to be played or if we need to start playing an ad.
+      newPeriodId =
+          queue.resolveMediaPeriodIdForAds(playbackInfo.periodId.periodUid, newContentPositionUs);
+      if (!playbackInfo.periodId.isAd() && !newPeriodId.isAd()) {
+        // Drop update if we keep playing the same content (MediaPeriod.periodUid are identical) and
+        // only MediaPeriodId.nextAdGroupIndex may have changed. This postpones a potential
+        // discontinuity until we reach the former next ad group position.
+        newPeriodId = playbackInfo.periodId;
+      }
     }
 
     if (playbackInfo.periodId.equals(newPeriodId) && oldContentPositionUs == newContentPositionUs) {
@@ -1798,9 +1815,12 @@ private long getTotalBufferedDurationUs() {
 
   private long getTotalBufferedDurationUs(long bufferedPositionInLoadingPeriodUs) {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    return loadingPeriodHolder == null
-        ? 0
-        : bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    if (loadingPeriodHolder == null) {
+      return 0;
+    }
+    long totalBufferedDurationUs =
+        bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    return Math.max(0, totalBufferedDurationUs);
   }
 
   private void updateLoadControlTrackSelection(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerLibraryInfo.java
index 21c482f4cb..791c717aca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.10.1";
+  public static final String VERSION = "2.10.5";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.1";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.5";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2010001;
+  public static final int VERSION_INT = 2010005;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2VRT.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/Format.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/Format.java
index 48e8f6e028..08cfa08d43 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/Format.java
@@ -168,6 +168,10 @@
 
   // Video.
 
+  /**
+   * @deprecated Use {@link #createVideoContainerFormat(String, String, String, String, String,
+   *     Metadata, int, int, int, float, List, int, int)} instead.
+   */
   @Deprecated
   public static Format createVideoContainerFormat(
       @Nullable String id,
@@ -186,6 +190,7 @@ public static Format createVideoContainerFormat(
         containerMimeType,
         sampleMimeType,
         codecs,
+        /* metadata= */ null,
         bitrate,
         width,
         height,
@@ -201,6 +206,7 @@ public static Format createVideoContainerFormat(
       @Nullable String containerMimeType,
       String sampleMimeType,
       String codecs,
+      @Nullable Metadata metadata,
       int bitrate,
       int width,
       int height,
@@ -215,7 +221,7 @@ public static Format createVideoContainerFormat(
         roleFlags,
         bitrate,
         codecs,
-        /* metadata= */ null,
+        metadata,
         containerMimeType,
         sampleMimeType,
         /* maxInputSize= */ NO_VALUE,
@@ -345,6 +351,10 @@ public static Format createVideoSampleFormat(
 
   // Audio.
 
+  /**
+   * @deprecated Use {@link #createAudioContainerFormat(String, String, String, String, String,
+   *     Metadata, int, int, int, List, int, int, String)} instead.
+   */
   @Deprecated
   public static Format createAudioContainerFormat(
       @Nullable String id,
@@ -363,6 +373,7 @@ public static Format createAudioContainerFormat(
         containerMimeType,
         sampleMimeType,
         codecs,
+        /* metadata= */ null,
         bitrate,
         channelCount,
         sampleRate,
@@ -378,6 +389,7 @@ public static Format createAudioContainerFormat(
       @Nullable String containerMimeType,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
+      @Nullable Metadata metadata,
       int bitrate,
       int channelCount,
       int sampleRate,
@@ -392,7 +404,7 @@ public static Format createAudioContainerFormat(
         roleFlags,
         bitrate,
         codecs,
-        /* metadata= */ null,
+        metadata,
         containerMimeType,
         sampleMimeType,
         /* maxInputSize= */ NO_VALUE,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodHolder.java
index 01b8bf5a08..f0531e9b68 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodHolder.java
@@ -67,8 +67,7 @@
    * Creates a new holder with information required to play it as part of a timeline.
    *
    * @param rendererCapabilities The renderer capabilities.
-   * @param rendererPositionOffsetUs The time offset of the start of the media period to provide to
-   *     renderers.
+   * @param rendererPositionOffsetUs The renderer time of the start of the period, in microseconds.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
    * @param mediaSource The media source that produced the media period.
@@ -82,7 +81,7 @@ public MediaPeriodHolder(
       MediaSource mediaSource,
       MediaPeriodInfo info) {
     this.rendererCapabilities = rendererCapabilities;
-    this.rendererPositionOffsetUs = rendererPositionOffsetUs - info.startPositionUs;
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs;
     this.trackSelector = trackSelector;
     this.mediaSource = mediaSource;
     this.uid = info.id.periodUid;
@@ -115,6 +114,15 @@ public long getRendererOffset() {
     return rendererPositionOffsetUs;
   }
 
+  /**
+   * Sets the renderer time of the start of the period, in microseconds.
+   *
+   * @param rendererPositionOffsetUs The new renderer position offset, in microseconds.
+   */
+  public void setRendererOffset(long rendererPositionOffsetUs) {
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs;
+  }
+
   /** Returns start position of period in renderer time. */
   public long getStartPositionRendererTime() {
     return info.startPositionUs + rendererPositionOffsetUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodInfo.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodInfo.java
index faa14367f0..c1d6fe2b2e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodInfo.java
@@ -29,7 +29,8 @@
   public final long startPositionUs;
   /**
    * If this is an ad, the position to play in the next content media period. {@link C#TIME_UNSET}
-   * otherwise.
+   * if this is not an ad or the next content media period should be played from its default
+   * position.
    */
   public final long contentPositionUs;
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodQueue.java
index c437a7b342..a6c36b02d8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/MediaPeriodQueue.java
@@ -144,8 +144,10 @@ public MediaPeriod enqueueNextMediaPeriod(
       MediaPeriodInfo info) {
     long rendererPositionOffsetUs =
         loading == null
-            ? info.startPositionUs
-            : (loading.getRendererOffset() + loading.info.durationUs);
+            ? (info.id.isAd() && info.contentPositionUs != C.TIME_UNSET
+                ? info.contentPositionUs
+                : 0)
+            : (loading.getRendererOffset() + loading.info.durationUs - info.startPositionUs);
     MediaPeriodHolder newPeriodHolder =
         new MediaPeriodHolder(
             rendererCapabilities,
@@ -560,6 +562,7 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
       }
 
       long startPositionUs;
+      long contentPositionUs;
       int nextWindowIndex =
           timeline.getPeriod(nextPeriodIndex, period, /* setIds= */ true).windowIndex;
       Object nextPeriodUid = period.uid;
@@ -568,6 +571,7 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
         // We're starting to buffer a new window. When playback transitions to this window we'll
         // want it to be from its default start position, so project the default start position
         // forward by the duration of the buffer, and start buffering from this point.
+        contentPositionUs = C.TIME_UNSET;
         Pair<Object, Long> defaultPosition =
             timeline.getPeriodPosition(
                 window,
@@ -587,12 +591,13 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
           windowSequenceNumber = nextWindowSequenceNumber++;
         }
       } else {
+        // We're starting to buffer a new period within the same window.
         startPositionUs = 0;
+        contentPositionUs = 0;
       }
       MediaPeriodId periodId =
           resolveMediaPeriodIdForAds(nextPeriodUid, startPositionUs, windowSequenceNumber);
-      return getMediaPeriodInfo(
-          periodId, /* contentPositionUs= */ startPositionUs, startPositionUs);
+      return getMediaPeriodInfo(periodId, contentPositionUs, startPositionUs);
     }
 
     MediaPeriodId currentPeriodId = mediaPeriodInfo.id;
@@ -616,13 +621,11 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
                 mediaPeriodInfo.contentPositionUs,
                 currentPeriodId.windowSequenceNumber);
       } else {
-        // Play content from the ad group position. As a special case, if we're transitioning from a
-        // preroll ad group to content and there are no other ad groups, project the start position
-        // forward as if this were a transition to a new window. No attempt is made to handle
-        // midrolls in live streams, as it's unclear what content position should play after an ad
-        // (server-side dynamic ad insertion is more appropriate for this use case).
+        // Play content from the ad group position.
         long startPositionUs = mediaPeriodInfo.contentPositionUs;
-        if (period.getAdGroupCount() == 1 && period.getAdGroupTimeUs(0) == 0) {
+        if (startPositionUs == C.TIME_UNSET) {
+          // If we're transitioning from an ad group to content starting from its default position,
+          // project the start position forward as if this were a transition to a new window.
           Pair<Object, Long> defaultPosition =
               timeline.getPeriodPosition(
                   window,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/PlaybackInfo.java
index 20b0ec3b2e..b08657d0b7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/PlaybackInfo.java
@@ -48,7 +48,8 @@
   /**
    * If {@link #periodId} refers to an ad, the position of the suspended content relative to the
    * start of the associated period in the {@link #timeline}, in microseconds. {@link C#TIME_UNSET}
-   * if {@link #periodId} does not refer to an ad.
+   * if {@link #periodId} does not refer to an ad or if the suspended content should be played from
+   * its default position.
    */
   public final long contentPositionUs;
   /** The current playback state. One of the {@link Player}.STATE_ constants. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/Player.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/Player.java
index 97ce059773..c5d5d7717d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/Player.java
@@ -365,6 +365,13 @@ default void onLoadingChanged(boolean isLoading) {}
      */
     default void onPlayerStateChanged(boolean playWhenReady, int playbackState) {}
 
+    /**
+     * Called when the value of {@link #isPlaying()} changes.
+     *
+     * @param isPlaying Whether the player is playing.
+     */
+    default void onIsPlayingChanged(boolean isPlaying) {}
+
     /**
      * Called when the value of {@link #getRepeatMode()} changes.
      *
@@ -462,6 +469,20 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    */
   int STATE_ENDED = 4;
 
+  /**
+   * Reason why playback is suppressed even if {@link #getPlaybackState()} is {@link #STATE_READY}
+   * and {@link #getPlayWhenReady()} is {@code true}. One of {@link
+   * #PLAYBACK_SUPPRESSION_REASON_NONE} or {@link #PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({PLAYBACK_SUPPRESSION_REASON_NONE, PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS})
+  @interface PlaybackSuppressionReason {}
+  /** Playback is not suppressed. */
+  int PLAYBACK_SUPPRESSION_REASON_NONE = 0;
+  /** Playback is suppressed because audio focus is lost or can't be acquired. */
+  int PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS = 1;
+
   /**
    * Repeat modes for playback. One of {@link #REPEAT_MODE_OFF}, {@link #REPEAT_MODE_ONE} or {@link
    * #REPEAT_MODE_ALL}.
@@ -587,12 +608,42 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    */
   int getPlaybackState();
 
+  /**
+   * Returns reason why playback is suppressed even if {@link #getPlaybackState()} is {@link
+   * #STATE_READY} and {@link #getPlayWhenReady()} is {@code true}.
+   *
+   * <p>Note that {@link #PLAYBACK_SUPPRESSION_REASON_NONE} indicates that playback is not
+   * suppressed.
+   *
+   * @return The current {@link PlaybackSuppressionReason}.
+   */
+  @PlaybackSuppressionReason
+  int getPlaybackSuppressionReason();
+
+  /**
+   * Returns whether the player is playing, i.e. {@link #getContentPosition()} is advancing.
+   *
+   * <p>If {@code false}, then at least one of the following is true:
+   *
+   * <ul>
+   *   <li>The {@link #getPlaybackState() playback state} is not {@link #STATE_READY ready}.
+   *   <li>There is no {@link #getPlayWhenReady() intention to play}.
+   *   <li>Playback is {@link #getPlaybackSuppressionReason() suppressed for other reasons}.
+   * </ul>
+   *
+   * @return Whether the player is playing.
+   */
+  boolean isPlaying();
+
   /**
    * Returns the error that caused playback to fail. This is the same error that will have been
    * reported via {@link Player.EventListener#onPlayerError(ExoPlaybackException)} at the time of
    * failure. It can be queried using this method until {@code stop(true)} is called or the player
    * is re-prepared.
    *
+   * <p>Note that this method will always return {@code null} if {@link #getPlaybackState()} is not
+   * {@link #STATE_IDLE}.
+   *
    * @return The error, or {@code null}.
    */
   @Nullable
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/SimpleExoPlayer.java
index 9f693750f9..58b47c4641 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/SimpleExoPlayer.java
@@ -878,8 +878,15 @@ public int getPlaybackState() {
     return player.getPlaybackState();
   }
 
+  @PlaybackSuppressionReason
+  public int getPlaybackSuppressionReason() {
+    verifyApplicationThread();
+    return player.getPlaybackSuppressionReason();
+  }
+
   @Override
-  public @Nullable ExoPlaybackException getPlaybackError() {
+  @Nullable
+  public ExoPlaybackException getPlaybackError() {
     verifyApplicationThread();
     return player.getPlaybackError();
   }
@@ -1221,9 +1228,13 @@ private void sendVolumeToRenderers() {
 
   private void updatePlayWhenReady(
       boolean playWhenReady, @AudioFocusManager.PlayerCommand int playerCommand) {
+    int playbackSuppressionReason =
+        playerCommand == AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY
+            ? Player.PLAYBACK_SUPPRESSION_REASON_NONE
+            : Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS;
     player.setPlayWhenReady(
         playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY,
-        playerCommand != AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY);
+        playbackSuppressionReason);
   }
 
   private void verifyApplicationThread() {
@@ -1231,8 +1242,7 @@ private void verifyApplicationThread() {
       Log.w(
           TAG,
           "Player is accessed on the wrong thread. See "
-              + "https://exoplayer.dev/troubleshooting.html#"
-              + "what-do-player-is-accessed-on-the-wrong-thread-warnings-mean",
+              + "https://exoplayer.dev/issues/player-accessed-on-wrong-thread",
           hasNotifiedFullWrongThreadWarning ? null : new IllegalStateException());
       hasNotifiedFullWrongThreadWarning = true;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSink.java
index 818f401b47..94b71e85b6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSink.java
@@ -37,7 +37,6 @@
 import java.nio.ByteOrder;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 
 /**
@@ -122,7 +121,15 @@ private InvalidAudioTrackTimestampException(String message) {
      * audioProcessors} applied before silence skipping and playback parameters.
      */
     public DefaultAudioProcessorChain(AudioProcessor... audioProcessors) {
-      this.audioProcessors = Arrays.copyOf(audioProcessors, audioProcessors.length + 2);
+      // The passed-in type may be more specialized than AudioProcessor[], so allocate a new array
+      // rather than using Arrays.copyOf.
+      this.audioProcessors = new AudioProcessor[audioProcessors.length + 2];
+      System.arraycopy(
+          /* src= */ audioProcessors,
+          /* srcPos= */ 0,
+          /* dest= */ this.audioProcessors,
+          /* destPos= */ 0,
+          /* length= */ audioProcessors.length);
       silenceSkippingAudioProcessor = new SilenceSkippingAudioProcessor();
       sonicAudioProcessor = new SonicAudioProcessor();
       this.audioProcessors[audioProcessors.length] = silenceSkippingAudioProcessor;
@@ -272,6 +279,7 @@ public long getSkippedOutputFrameCount() {
   private int preV21OutputBufferOffset;
   private int drainingAudioProcessorIndex;
   private boolean handledEndOfStream;
+  private boolean stoppedAudioTrack;
 
   private boolean playing;
   private int audioSessionId;
@@ -465,19 +473,15 @@ public void configure(
             processingEnabled,
             canApplyPlaybackParameters,
             availableAudioProcessors);
-    if (isInitialized()) {
-      if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
-        // We need a new AudioTrack before we can handle more input. We should first stop() the
-        // track and wait for audio to play out (tracked by [Internal: b/33161961]), but for now we
-        // discard the audio track immediately.
-        flush();
-      } else if (flushAudioProcessors) {
-        // We don't need a new AudioTrack but audio processors need to be drained and flushed.
-        this.pendingConfiguration = pendingConfiguration;
-        return;
-      }
+    // If we have a pending configuration already, we always drain audio processors as the preceding
+    // configuration may have required it (even if this one doesn't).
+    boolean drainAudioProcessors = flushAudioProcessors || this.pendingConfiguration != null;
+    if (isInitialized()
+        && (!pendingConfiguration.canReuseAudioTrack(configuration) || drainAudioProcessors)) {
+      this.pendingConfiguration = pendingConfiguration;
+    } else {
+      configuration = pendingConfiguration;
     }
-    configuration = pendingConfiguration;
   }
 
   private void setupAudioProcessors() {
@@ -504,7 +508,7 @@ private void flushAudioProcessors() {
     }
   }
 
-  private void initialize() throws InitializationException {
+  private void initialize(long presentationTimeUs) throws InitializationException {
     // If we're asynchronously releasing a previous audio track then we block until it has been
     // released. This guarantees that we cannot end up in a state where we have multiple audio
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
@@ -536,11 +540,7 @@ private void initialize() throws InitializationException {
       }
     }
 
-    playbackParameters =
-        configuration.canApplyPlaybackParameters
-            ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
-            : PlaybackParameters.DEFAULT;
-    setupAudioProcessors();
+    applyPlaybackParameters(playbackParameters, presentationTimeUs);
 
     audioTrackPositionTracker.setAudioTrack(
         audioTrack,
@@ -579,21 +579,27 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
     Assertions.checkArgument(inputBuffer == null || buffer == inputBuffer);
 
     if (pendingConfiguration != null) {
-      // We are waiting for audio processors to drain before applying a the new configuration.
       if (!drainAudioProcessorsToEndOfStream()) {
+        // There's still pending data in audio processors to write to the track.
         return false;
+      } else if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
+        playPendingData();
+        if (hasPendingData()) {
+          // We're waiting for playout on the current audio track to finish.
+          return false;
+        }
+        flush();
+      } else {
+        // The current audio track can be reused for the new configuration.
+        configuration = pendingConfiguration;
+        pendingConfiguration = null;
       }
-      configuration = pendingConfiguration;
-      pendingConfiguration = null;
-      playbackParameters =
-          configuration.canApplyPlaybackParameters
-              ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
-              : PlaybackParameters.DEFAULT;
-      setupAudioProcessors();
+      // Re-apply playback parameters.
+      applyPlaybackParameters(playbackParameters, presentationTimeUs);
     }
 
     if (!isInitialized()) {
-      initialize();
+      initialize(presentationTimeUs);
       if (playing) {
         play();
       }
@@ -629,15 +635,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         }
         PlaybackParameters newPlaybackParameters = afterDrainPlaybackParameters;
         afterDrainPlaybackParameters = null;
-        newPlaybackParameters = audioProcessorChain.applyPlaybackParameters(newPlaybackParameters);
-        // Store the position and corresponding media time from which the parameters will apply.
-        playbackParametersCheckpoints.add(
-            new PlaybackParametersCheckpoint(
-                newPlaybackParameters,
-                Math.max(0, presentationTimeUs),
-                configuration.framesToDurationUs(getWrittenFrames())));
-        // Update the set of active audio processors to take into account the new parameters.
-        setupAudioProcessors();
+        applyPlaybackParameters(newPlaybackParameters, presentationTimeUs);
       }
 
       if (startMediaTimeState == START_NOT_SET) {
@@ -786,15 +784,8 @@ private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throw
 
   @Override
   public void playToEndOfStream() throws WriteException {
-    if (handledEndOfStream || !isInitialized()) {
-      return;
-    }
-
-    if (drainAudioProcessorsToEndOfStream()) {
-      // The audio processors have drained, so drain the underlying audio track.
-      audioTrackPositionTracker.handleEndOfStream(getWrittenFrames());
-      audioTrack.stop();
-      bytesUntilNextAvSync = 0;
+    if (!handledEndOfStream && isInitialized() && drainAudioProcessorsToEndOfStream()) {
+      playPendingData();
       handledEndOfStream = true;
     }
   }
@@ -858,8 +849,9 @@ public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParam
         // parameters apply.
         afterDrainPlaybackParameters = playbackParameters;
       } else {
-        // Update the playback parameters now.
-        this.playbackParameters = audioProcessorChain.applyPlaybackParameters(playbackParameters);
+        // Update the playback parameters now. They will be applied to the audio processors during
+        // initialization.
+        this.playbackParameters = playbackParameters;
       }
     }
     return this.playbackParameters;
@@ -976,6 +968,7 @@ public void flush() {
       flushAudioProcessors();
       inputBuffer = null;
       outputBuffer = null;
+      stoppedAudioTrack = false;
       handledEndOfStream = false;
       drainingAudioProcessorIndex = C.INDEX_UNSET;
       avSyncHeader = null;
@@ -1040,6 +1033,21 @@ public void run() {
     }.start();
   }
 
+  private void applyPlaybackParameters(
+      PlaybackParameters playbackParameters, long presentationTimeUs) {
+    PlaybackParameters newPlaybackParameters =
+        configuration.canApplyPlaybackParameters
+            ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
+            : PlaybackParameters.DEFAULT;
+    // Store the position and corresponding media time from which the parameters will apply.
+    playbackParametersCheckpoints.add(
+        new PlaybackParametersCheckpoint(
+            newPlaybackParameters,
+            /* mediaTimeUs= */ Math.max(0, presentationTimeUs),
+            /* positionUs= */ configuration.framesToDurationUs(getWrittenFrames())));
+    setupAudioProcessors();
+  }
+
   private long applySpeedup(long positionUs) {
     @Nullable PlaybackParametersCheckpoint checkpoint = null;
     while (!playbackParametersCheckpoints.isEmpty()
@@ -1125,6 +1133,7 @@ private static int getMaximumEncodedRateBytesPerSecond(@C.Encoding int encoding)
       case C.ENCODING_AC3:
         return 640 * 1000 / 8;
       case C.ENCODING_E_AC3:
+      case C.ENCODING_E_AC3_JOC:
         return 6144 * 1000 / 8;
       case C.ENCODING_AC4:
         return 2688 * 1000 / 8;
@@ -1154,7 +1163,7 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
       return DtsUtil.parseDtsAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC3) {
       return Ac3Util.getAc3SyncframeAudioSampleCount();
-    } else if (encoding == C.ENCODING_E_AC3) {
+    } else if (encoding == C.ENCODING_E_AC3 || encoding == C.ENCODING_E_AC3_JOC) {
       return Ac3Util.parseEAc3SyncframeAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC4) {
       return Ac4Util.parseAc4SyncframeAudioSampleCount(buffer);
@@ -1177,11 +1186,10 @@ private static int writeNonBlockingV21(AudioTrack audioTrack, ByteBuffer buffer,
   @TargetApi(21)
   private int writeNonBlockingWithAvSyncV21(AudioTrack audioTrack, ByteBuffer buffer, int size,
       long presentationTimeUs) {
-    // TODO: Uncomment this when [Internal ref: b/33627517] is clarified or fixed.
-    // if (Util.SDK_INT >= 23) {
-    //   // The underlying platform AudioTrack writes AV sync headers directly.
-    //   return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
-    // }
+    if (Util.SDK_INT >= 26) {
+      // The underlying platform AudioTrack writes AV sync headers directly.
+      return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
+    }
     if (avSyncHeader == null) {
       avSyncHeader = ByteBuffer.allocate(16);
       avSyncHeader.order(ByteOrder.BIG_ENDIAN);
@@ -1223,6 +1231,15 @@ private static void setVolumeInternalV3(AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
+  private void playPendingData() {
+    if (!stoppedAudioTrack) {
+      stoppedAudioTrack = true;
+      audioTrackPositionTracker.handleEndOfStream(getWrittenFrames());
+      audioTrack.stop();
+      bytesUntilNextAvSync = 0;
+    }
+  }
+
   /** Stores playback parameters with the position and media time at which they apply. */
   private static final class PlaybackParametersCheckpoint {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/MediaCodecAudioRenderer.java
index d4dc180a76..7e51c0d540 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/MediaCodecAudioRenderer.java
@@ -45,6 +45,7 @@
 import com.google.android.exoplayer2VRT.util.MimeTypes;
 import com.google.android.exoplayer2VRT.util.Util;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
@@ -245,12 +246,50 @@ public MediaCodecAudioRenderer(
       @Nullable Handler eventHandler,
       @Nullable AudioRendererEventListener eventListener,
       AudioSink audioSink) {
+    this(
+        context,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        /* enableDecoderFallback= */ false,
+        eventHandler,
+        eventListener,
+        audioSink);
+  }
+
+  /**
+   * @param context A context.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
+   *     content is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioSink The sink to which audio will be output.
+   */
+  public MediaCodecAudioRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      AudioSink audioSink) {
     super(
         C.TRACK_TYPE_AUDIO,
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
-        /* enableDecoderFallback= */ false,
+        enableDecoderFallback,
         /* assumedMinimumCodecOperatingRate= */ 44100);
     this.context = context.getApplicationContext();
     this.audioSink = audioSink;
@@ -326,8 +365,18 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         return Collections.singletonList(passthroughDecoderInfo);
       }
     }
-    return mediaCodecSelector.getDecoderInfos(
-        format.sampleMimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
+    List<MediaCodecInfo> decoderInfos =
+        mediaCodecSelector.getDecoderInfos(
+            format.sampleMimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(format.sampleMimeType)) {
+      // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
+      List<MediaCodecInfo> decoderInfosWithEac3 = new ArrayList<>(decoderInfos);
+      decoderInfosWithEac3.addAll(
+          mediaCodecSelector.getDecoderInfos(
+              MimeTypes.AUDIO_E_AC3, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false));
+      decoderInfos = decoderInfosWithEac3;
+    }
+    return Collections.unmodifiableList(decoderInfos);
   }
 
   /**
@@ -341,7 +390,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @return Whether passthrough playback is supported.
    */
   protected boolean allowPassthrough(int channelCount, String mimeType) {
-    return audioSink.supportsOutput(channelCount, MimeTypes.getEncoding(mimeType));
+    return getPassthroughEncoding(channelCount, mimeType) != C.ENCODING_INVALID;
   }
 
   @Override
@@ -355,7 +404,7 @@ protected void configureCodec(
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
     codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);
     passthroughEnabled = codecInfo.passthrough;
-    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
+    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.codecMimeType;
     MediaFormat mediaFormat =
         getMediaFormat(format, codecMimeType, codecMaxInputSize, codecOperatingRate);
     codec.configure(mediaFormat, /* surface= */ null, crypto, /* flags= */ 0);
@@ -437,11 +486,14 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     @C.Encoding int encoding;
     MediaFormat format;
     if (passthroughMediaFormat != null) {
-      encoding = MimeTypes.getEncoding(passthroughMediaFormat.getString(MediaFormat.KEY_MIME));
       format = passthroughMediaFormat;
+      encoding =
+          getPassthroughEncoding(
+              format.getInteger(MediaFormat.KEY_CHANNEL_COUNT),
+              format.getString(MediaFormat.KEY_MIME));
     } else {
-      encoding = pcmEncoding;
       format = outputFormat;
+      encoding = pcmEncoding;
     }
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
@@ -463,6 +515,28 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     }
   }
 
+  /**
+   * Returns the {@link C.Encoding} constant to use for passthrough of the given format, or {@link
+   * C#ENCODING_INVALID} if passthrough is not possible.
+   */
+  @C.Encoding
+  protected int getPassthroughEncoding(int channelCount, String mimeType) {
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
+      if (audioSink.supportsOutput(channelCount, C.ENCODING_E_AC3_JOC)) {
+        return MimeTypes.getEncoding(MimeTypes.AUDIO_E_AC3_JOC);
+      }
+      // E-AC3 receivers can decode JOC streams, but in 2-D rather than 3-D, so try to fall back.
+      mimeType = MimeTypes.AUDIO_E_AC3;
+    }
+
+    @C.Encoding int encoding = MimeTypes.getEncoding(mimeType);
+    if (audioSink.supportsOutput(channelCount, encoding)) {
+      return encoding;
+    } else {
+      return C.ENCODING_INVALID;
+    }
+  }
+
   /**
    * Called when the audio session id becomes known. The default implementation is a no-op. One
    * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
@@ -632,7 +706,8 @@ protected boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException {
     if (codecNeedsEosBufferTimestampWorkaround
@@ -648,7 +723,7 @@ protected boolean processOutputBuffer(
       return true;
     }
 
-    if (shouldSkip) {
+    if (isDecodeOnlyBuffer) {
       codec.releaseOutputBuffer(bufferIndex, false);
       decoderCounters.skippedOutputBufferCount++;
       audioSink.handleDiscontinuity();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/Sonic.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/Sonic.java
index 0d7ba29182..2fd06c3b33 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/Sonic.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/Sonic.java
@@ -30,6 +30,7 @@
   private static final int MINIMUM_PITCH = 65;
   private static final int MAXIMUM_PITCH = 400;
   private static final int AMDF_FREQUENCY = 4000;
+  private static final int BYTES_PER_SAMPLE = 2;
 
   private final int inputSampleRateHz;
   private final int channelCount;
@@ -157,9 +158,9 @@ public void flush() {
     maxDiff = 0;
   }
 
-  /** Returns the number of output frames that can be read with {@link #getOutput(ShortBuffer)}. */
-  public int getFramesAvailable() {
-    return outputFrameCount;
+  /** Returns the size of output that can be read with {@link #getOutput(ShortBuffer)}, in bytes. */
+  public int getOutputSize() {
+    return outputFrameCount * channelCount * BYTES_PER_SAMPLE;
   }
 
   // Internal methods.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/SonicAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/SonicAudioProcessor.java
index c9fdbe13d0..d1242061e1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/SonicAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/audio/SonicAudioProcessor.java
@@ -210,7 +210,7 @@ public void queueInput(ByteBuffer inputBuffer) {
       sonic.queueInput(shortBuffer);
       inputBuffer.position(inputBuffer.position() + inputSize);
     }
-    int outputSize = sonic.getFramesAvailable() * channelCount * 2;
+    int outputSize = sonic.getOutputSize();
     if (outputSize > 0) {
       if (buffer.capacity() < outputSize) {
         buffer = ByteBuffer.allocateDirect(outputSize).order(ByteOrder.nativeOrder());
@@ -243,7 +243,7 @@ public ByteBuffer getOutput() {
 
   @Override
   public boolean isEnded() {
-    return inputEnded && (sonic == null || sonic.getFramesAvailable() == 0);
+    return inputEnded && (sonic == null || sonic.getOutputSize() == 0);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/decoder/SimpleDecoder.java
index e1076acd06..f7a53de87d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/decoder/SimpleDecoder.java
@@ -301,5 +301,6 @@ private void releaseOutputBufferInternal(O outputBuffer) {
    * @param reset Whether the decoder must be reset before decoding.
    * @return A decoder exception if an error occurred, or null if decoding was successful.
    */
-  protected abstract @Nullable E decode(I inputBuffer, O outputBuffer, boolean reset);
+  @Nullable
+  protected abstract E decode(I inputBuffer, O outputBuffer, boolean reset);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/DefaultDrmSessionManager.java
index 1ad3b5533a..e83968075b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/DefaultDrmSessionManager.java
@@ -544,7 +544,7 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(
         ExoMediaDrm<? extends T> md,
-        byte[] sessionId,
+        @Nullable byte[] sessionId,
         int event,
         int extra,
         @Nullable byte[] data) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/ExoMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/ExoMediaDrm.java
index 131d123a48..508040b390 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/ExoMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/ExoMediaDrm.java
@@ -80,7 +80,7 @@
      */
     void onEvent(
         ExoMediaDrm<? extends T> mediaDrm,
-        byte[] sessionId,
+        @Nullable byte[] sessionId,
         int event,
         int extra,
         @Nullable byte[] data);
@@ -215,6 +215,7 @@ KeyRequest getKeyRequest(
       throws NotProvisionedException;
 
   /** @see MediaDrm#provideKeyResponse(byte[], byte[]) */
+  @Nullable
   byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/FrameworkMediaDrm.java
index 5b475dcb30..844f045266 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/drm/FrameworkMediaDrm.java
@@ -84,8 +84,6 @@ private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
     }
   }
 
-  // FIXME: incompatible types in argument.
-  @SuppressWarnings("nullness:argument.type.incompatible")
   @Override
   public void setOnEventListener(
       final ExoMediaDrm.OnEventListener<? super FrameworkMediaCrypto> listener) {
@@ -160,8 +158,7 @@ public KeyRequest getKeyRequest(
     return new KeyRequest(requestData, licenseServerUrl);
   }
 
-  // FIXME: incompatible types in return.
-  @SuppressWarnings("nullness:return.type.incompatible")
+  @Nullable
   @Override
   public byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/MpegAudioHeader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/MpegAudioHeader.java
index 8eb1226b01..1553e169db 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/MpegAudioHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/MpegAudioHeader.java
@@ -186,10 +186,6 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
       }
     }
 
-    // Calculate the bitrate in the same way Mp3Extractor calculates sample timestamps so that
-    // seeking to a given timestamp and playing from the start up to that timestamp give the same
-    // results for CBR streams. See also [internal: b/120390268].
-    bitrate = 8 * frameSize * sampleRate / samplesPerFrame;
     String mimeType = MIME_TYPE_BY_LAYER[3 - layer];
     int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
     header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/TrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/TrackOutput.java
index 3f20a1e67f..013c2ade83 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/TrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/TrackOutput.java
@@ -119,7 +119,7 @@ int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
    * Called to write sample data to the output.
    *
    * @param data A {@link ParsableByteArray} from which to read the sample data.
-   * @param length The number of bytes to read.
+   * @param length The number of bytes to read, starting from {@code data.getPosition()}.
    */
   void sampleData(ParsableByteArray data, int length);
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/AudioTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/AudioTagPayloadReader.java
index 1e7ddf125f..afbc3095a3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/AudioTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/AudioTagPayloadReader.java
@@ -86,11 +86,12 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     if (audioFormat == AUDIO_FORMAT_MP3) {
       int sampleSize = data.bytesLeft();
       output.sampleData(data, sampleSize);
       output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+      return true;
     } else {
       int packetType = data.readUnsignedByte();
       if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
@@ -104,12 +105,15 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
             Collections.singletonList(audioSpecificConfig), null, 0, null);
         output.format(format);
         hasOutputFormat = true;
+        return false;
       } else if (audioFormat != AUDIO_FORMAT_AAC || packetType == AAC_PACKET_TYPE_AAC_RAW) {
         int sampleSize = data.bytesLeft();
         output.sampleData(data, sampleSize);
         output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+        return true;
+      } else {
+        return false;
       }
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/FlvExtractor.java
index e8f6c0195e..985684d86e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/FlvExtractor.java
@@ -74,6 +74,7 @@
 
   private ExtractorOutput extractorOutput;
   private @States int state;
+  private boolean outputFirstSample;
   private long mediaTagTimestampOffsetUs;
   private int bytesToNextTagHeader;
   private int tagType;
@@ -90,7 +91,6 @@ public FlvExtractor() {
     tagData = new ParsableByteArray();
     metadataReader = new ScriptTagPayloadReader();
     state = STATE_READING_FLV_HEADER;
-    mediaTagTimestampOffsetUs = C.TIME_UNSET;
   }
 
   @Override
@@ -132,7 +132,7 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek(long position, long timeUs) {
     state = STATE_READING_FLV_HEADER;
-    mediaTagTimestampOffsetUs = C.TIME_UNSET;
+    outputFirstSample = false;
     bytesToNextTagHeader = 0;
   }
 
@@ -253,14 +253,16 @@ private boolean readTagHeader(ExtractorInput input) throws IOException, Interrup
    */
   private boolean readTagData(ExtractorInput input) throws IOException, InterruptedException {
     boolean wasConsumed = true;
+    boolean wasSampleOutput = false;
+    long timestampUs = getCurrentTimestampUs();
     if (tagType == TAG_TYPE_AUDIO && audioReader != null) {
       ensureReadyForMediaOutput();
-      audioReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+      wasSampleOutput = audioReader.consume(prepareTagData(input), timestampUs);
     } else if (tagType == TAG_TYPE_VIDEO && videoReader != null) {
       ensureReadyForMediaOutput();
-      videoReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+      wasSampleOutput = videoReader.consume(prepareTagData(input), timestampUs);
     } else if (tagType == TAG_TYPE_SCRIPT_DATA && !outputSeekMap) {
-      metadataReader.consume(prepareTagData(input), tagTimestampUs);
+      wasSampleOutput = metadataReader.consume(prepareTagData(input), timestampUs);
       long durationUs = metadataReader.getDurationUs();
       if (durationUs != C.TIME_UNSET) {
         extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
@@ -270,6 +272,11 @@ private boolean readTagData(ExtractorInput input) throws IOException, Interrupte
       input.skipFully(tagDataSize);
       wasConsumed = false;
     }
+    if (!outputFirstSample && wasSampleOutput) {
+      outputFirstSample = true;
+      mediaTagTimestampOffsetUs =
+          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
+    }
     bytesToNextTagHeader = 4; // There's a 4 byte previous tag size before the next header.
     state = STATE_SKIPPING_TO_TAG_HEADER;
     return wasConsumed;
@@ -292,10 +299,11 @@ private void ensureReadyForMediaOutput() {
       extractorOutput.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
       outputSeekMap = true;
     }
-    if (mediaTagTimestampOffsetUs == C.TIME_UNSET) {
-      mediaTagTimestampOffsetUs =
-          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
-    }
   }
 
+  private long getCurrentTimestampUs() {
+    return outputFirstSample
+        ? (mediaTagTimestampOffsetUs + tagTimestampUs)
+        : (metadataReader.getDurationUs() == C.TIME_UNSET ? 0 : tagTimestampUs);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/ScriptTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/ScriptTagPayloadReader.java
index e2bdedc12d..be36ec5c0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/ScriptTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/ScriptTagPayloadReader.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2VRT.extractor.flv;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.ParserException;
+import com.google.android.exoplayer2VRT.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
 import java.util.ArrayList;
 import java.util.Date;
@@ -44,7 +46,7 @@
   private long durationUs;
 
   public ScriptTagPayloadReader() {
-    super(null);
+    super(new DummyTrackOutput());
     durationUs = C.TIME_UNSET;
   }
 
@@ -63,7 +65,7 @@ protected boolean parseHeader(ParsableByteArray data) {
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int nameType = readAmfType(data);
     if (nameType != AMF_TYPE_STRING) {
       // Should never happen.
@@ -72,12 +74,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
     String name = readAmfString(data);
     if (!NAME_METADATA.equals(name)) {
       // We're only interested in metadata.
-      return;
+      return false;
     }
     int type = readAmfType(data);
     if (type != AMF_TYPE_ECMA_ARRAY) {
       // We're not interested in this metadata.
-      return;
+      return false;
     }
     // Set the duration to the value contained in the metadata, if present.
     Map<String, Object> metadata = readAmfEcmaArray(data);
@@ -87,6 +89,7 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
         durationUs = (long) (durationSeconds * C.MICROS_PER_SECOND);
       }
     }
+    return false;
   }
 
   private static int readAmfType(ParsableByteArray data) {
@@ -137,7 +140,10 @@ private static String readAmfString(ParsableByteArray data) {
     ArrayList<Object> list = new ArrayList<>(count);
     for (int i = 0; i < count; i++) {
       int type = readAmfType(data);
-      list.add(readAmfData(data, type));
+      Object value = readAmfData(data, type);
+      if (value != null) {
+        list.add(value);
+      }
     }
     return list;
   }
@@ -156,7 +162,10 @@ private static String readAmfString(ParsableByteArray data) {
       if (type == AMF_TYPE_END_MARKER) {
         break;
       }
-      array.put(key, readAmfData(data, type));
+      Object value = readAmfData(data, type);
+      if (value != null) {
+        array.put(key, value);
+      }
     }
     return array;
   }
@@ -173,7 +182,10 @@ private static String readAmfString(ParsableByteArray data) {
     for (int i = 0; i < count; i++) {
       String key = readAmfString(data);
       int type = readAmfType(data);
-      array.put(key, readAmfData(data, type));
+      Object value = readAmfData(data, type);
+      if (value != null) {
+        array.put(key, value);
+      }
     }
     return array;
   }
@@ -190,6 +202,7 @@ private static Date readAmfDate(ParsableByteArray data) {
     return date;
   }
 
+  @Nullable
   private static Object readAmfData(ParsableByteArray data, int type) {
     switch (type) {
       case AMF_TYPE_NUMBER:
@@ -207,8 +220,8 @@ private static Object readAmfData(ParsableByteArray data, int type) {
       case AMF_TYPE_DATE:
         return readAmfDate(data);
       default:
+        // We don't log a warning because there are types that we knowingly don't support.
         return null;
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/TagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/TagPayloadReader.java
index 8df3ea30b6..9a6c6f6a2d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/TagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/TagPayloadReader.java
@@ -58,12 +58,11 @@ protected TagPayloadReader(TrackOutput output) {
    *
    * @param data The payload data to consume.
    * @param timeUs The timestamp associated with the payload.
+   * @return Whether a sample was output.
    * @throws ParserException If an error occurs parsing the data.
    */
-  public final void consume(ParsableByteArray data, long timeUs) throws ParserException {
-    if (parseHeader(data)) {
-      parsePayload(data, timeUs);
-    }
+  public final boolean consume(ParsableByteArray data, long timeUs) throws ParserException {
+    return parseHeader(data) && parsePayload(data, timeUs);
   }
 
   /**
@@ -78,10 +77,11 @@ public final void consume(ParsableByteArray data, long timeUs) throws ParserExce
   /**
    * Parses tag payload.
    *
-   * @param data Buffer where tag payload is stored
-   * @param timeUs Time position of the frame
+   * @param data Buffer where tag payload is stored.
+   * @param timeUs Time position of the frame.
+   * @return Whether a sample was output.
    * @throws ParserException If an error occurs parsing the payload.
    */
-  protected abstract void parsePayload(ParsableByteArray data, long timeUs) throws ParserException;
-
+  protected abstract boolean parsePayload(ParsableByteArray data, long timeUs)
+      throws ParserException;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/VideoTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/VideoTagPayloadReader.java
index a964076373..78feb9e220 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/VideoTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/flv/VideoTagPayloadReader.java
@@ -47,6 +47,7 @@
 
   // State variables.
   private boolean hasOutputFormat;
+  private boolean hasOutputKeyframe;
   private int frameType;
 
   /**
@@ -60,7 +61,7 @@ public VideoTagPayloadReader(TrackOutput output) {
 
   @Override
   public void seek() {
-    // Do nothing.
+    hasOutputKeyframe = false;
   }
 
   @Override
@@ -77,7 +78,7 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int packetType = data.readUnsignedByte();
     int compositionTimeMs = data.readInt24();
 
@@ -94,7 +95,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
           avcConfig.initializationData, Format.NO_VALUE, avcConfig.pixelWidthAspectRatio, null);
       output.format(format);
       hasOutputFormat = true;
+      return false;
     } else if (packetType == AVC_PACKET_TYPE_AVC_NALU && hasOutputFormat) {
+      boolean isKeyframe = frameType == VIDEO_FRAME_KEYFRAME;
+      if (!hasOutputKeyframe && !isKeyframe) {
+        return false;
+      }
       // TODO: Deduplicate with Mp4Extractor.
       // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
       // they're only 1 or 2 bytes long.
@@ -123,8 +129,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
         output.sampleData(data, bytesToWrite);
         bytesWritten += bytesToWrite;
       }
-      output.sampleMetadata(timeUs, frameType == VIDEO_FRAME_KEYFRAME ? C.BUFFER_FLAG_KEY_FRAME : 0,
-          bytesWritten, 0, null);
+      output.sampleMetadata(
+          timeUs, isKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0, bytesWritten, 0, null);
+      hasOutputKeyframe = true;
+      return true;
+    } else {
+      return false;
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp3/Mp3Extractor.java
index 5c81a1c3c2..064b422ee7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp3/Mp3Extractor.java
@@ -117,6 +117,7 @@
   private Seeker seeker;
   private long basisTimeUs;
   private long samplesRead;
+  private long firstSamplePosition;
   private int sampleBytesRemaining;
 
   public Mp3Extractor() {
@@ -214,6 +215,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
               /* selectionFlags= */ 0,
               /* language= */ null,
               (flags & FLAG_DISABLE_ID3_METADATA) != 0 ? null : metadata));
+      firstSamplePosition = input.getPosition();
+    } else if (firstSamplePosition != 0) {
+      long inputPosition = input.getPosition();
+      if (inputPosition < firstSamplePosition) {
+        // Skip past the seek frame.
+        input.skipFully((int) (firstSamplePosition - inputPosition));
+      }
     }
     return readSample(input);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/AtomParsers.java
index 31d15343b6..85add1f23e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/AtomParsers.java
@@ -1140,10 +1140,6 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
             language);
-      } else if (childAtomType == Atom.TYPE_alac) {
-        initializationData = new byte[childAtomSize];
-        parent.setPosition(childPosition);
-        parent.readBytes(initializationData, /* offset= */ 0, childAtomSize);
       } else if (childAtomType == Atom.TYPE_dOps) {
         // Build an Opus Identification Header (defined in RFC-7845) by concatenating the Opus Magic
         // Signature and the body of the dOps atom.
@@ -1152,7 +1148,16 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         System.arraycopy(opusMagic, 0, initializationData, 0, opusMagic.length);
         parent.setPosition(childPosition + Atom.HEADER_SIZE);
         parent.readBytes(initializationData, opusMagic.length, childAtomBodySize);
-      } else if (childAtomSize == Atom.TYPE_dfLa) {
+      } else if (childAtomType == Atom.TYPE_dfLa) {
+        int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
+        initializationData = new byte[4 + childAtomBodySize];
+        initializationData[0] = 0x66; // f
+        initializationData[1] = 0x4C; // L
+        initializationData[2] = 0x61; // a
+        initializationData[3] = 0x43; // C
+        parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
+        parent.readBytes(initializationData, /* offset= */ 4, childAtomBodySize);
+      } else if (childAtomType == Atom.TYPE_alac) {
         int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
         initializationData = new byte[childAtomBodySize];
         parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/FragmentedMp4Extractor.java
index 16783d6ee2..9da59b2178 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/FragmentedMp4Extractor.java
@@ -35,6 +35,8 @@
 import com.google.android.exoplayer2VRT.extractor.TrackOutput;
 import com.google.android.exoplayer2VRT.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2VRT.extractor.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer2VRT.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2VRT.metadata.emsg.EventMessageEncoder;
 import com.google.android.exoplayer2VRT.text.cea.CeaUtil;
 import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.Log;
@@ -140,6 +142,8 @@
   // Adjusts sample timestamps.
   private final @Nullable TimestampAdjuster timestampAdjuster;
 
+  private final EventMessageEncoder eventMessageEncoder;
+
   // Parser state.
   private final ParsableByteArray atomHeader;
   private final ArrayDeque<ContainerAtom> containerAtoms;
@@ -253,6 +257,7 @@ public FragmentedMp4Extractor(
     this.sideloadedDrmInitData = sideloadedDrmInitData;
     this.closedCaptionFormats = Collections.unmodifiableList(closedCaptionFormats);
     this.additionalEmsgTrackOutput = additionalEmsgTrackOutput;
+    eventMessageEncoder = new EventMessageEncoder();
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalPrefix = new ParsableByteArray(5);
@@ -590,39 +595,71 @@ private void maybeInitExtraTracks() {
     }
   }
 
-  /**
-   * Parses an emsg atom (defined in 23009-1).
-   */
+  /** Handles an emsg atom (defined in 23009-1). */
   private void onEmsgLeafAtomRead(ParsableByteArray atom) {
     if (emsgTrackOutputs == null || emsgTrackOutputs.length == 0) {
       return;
     }
+    atom.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = atom.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+    String schemeIdUri;
+    String value;
+    long timescale;
+    long presentationTimeDeltaUs = C.TIME_UNSET; // Only set if version == 0
+    long sampleTimeUs = C.TIME_UNSET;
+    long durationMs;
+    long id;
+    switch (version) {
+      case 0:
+        schemeIdUri = Assertions.checkNotNull(atom.readNullTerminatedString());
+        value = Assertions.checkNotNull(atom.readNullTerminatedString());
+        timescale = atom.readUnsignedInt();
+        presentationTimeDeltaUs =
+            Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
+        if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
+          sampleTimeUs = segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs;
+        }
+        durationMs =
+            Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MILLIS_PER_SECOND, timescale);
+        id = atom.readUnsignedInt();
+        break;
+      case 1:
+        timescale = atom.readUnsignedInt();
+        sampleTimeUs =
+            Util.scaleLargeTimestamp(atom.readUnsignedLongToLong(), C.MICROS_PER_SECOND, timescale);
+        durationMs =
+            Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MILLIS_PER_SECOND, timescale);
+        id = atom.readUnsignedInt();
+        schemeIdUri = Assertions.checkNotNull(atom.readNullTerminatedString());
+        value = Assertions.checkNotNull(atom.readNullTerminatedString());
+        break;
+      default:
+        Log.w(TAG, "Skipping unsupported emsg version: " + version);
+        return;
+    }
 
-    atom.setPosition(Atom.FULL_HEADER_SIZE);
-    int sampleSize = atom.bytesLeft();
-    atom.readNullTerminatedString(); // schemeIdUri
-    atom.readNullTerminatedString(); // value
-    long timescale = atom.readUnsignedInt();
-    long presentationTimeDeltaUs =
-        Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
-
-    // The presentation_time_delta is accounted for by adjusting the sample timestamp, so we zero it
-    // in the sample data before writing it to the track outputs.
-    int position = atom.getPosition();
-    atom.data[position - 4] = 0;
-    atom.data[position - 3] = 0;
-    atom.data[position - 2] = 0;
-    atom.data[position - 1] = 0;
+    byte[] messageData = new byte[atom.bytesLeft()];
+    atom.readBytes(messageData, /*offset=*/ 0, atom.bytesLeft());
+    EventMessage eventMessage = new EventMessage(schemeIdUri, value, durationMs, id, messageData);
+    ParsableByteArray encodedEventMessage =
+        new ParsableByteArray(eventMessageEncoder.encode(eventMessage));
+    int sampleSize = encodedEventMessage.bytesLeft();
 
     // Output the sample data.
     for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
-      atom.setPosition(Atom.FULL_HEADER_SIZE);
-      emsgTrackOutput.sampleData(atom, sampleSize);
+      encodedEventMessage.setPosition(0);
+      emsgTrackOutput.sampleData(encodedEventMessage, sampleSize);
     }
 
-    // Output the sample metadata.
-    if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
-      long sampleTimeUs = segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs;
+    // Output the sample metadata. This is made a little complicated because emsg-v0 atoms
+    // have presentation time *delta* while v1 atoms have absolute presentation time.
+    if (sampleTimeUs == C.TIME_UNSET) {
+      // We need the first sample timestamp in the segment before we can output the metadata.
+      pendingMetadataSampleInfos.addLast(
+          new MetadataSampleInfo(presentationTimeDeltaUs, sampleSize));
+      pendingMetadataSampleBytes += sampleSize;
+    } else {
       if (timestampAdjuster != null) {
         sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
       }
@@ -630,17 +667,10 @@ private void onEmsgLeafAtomRead(ParsableByteArray atom) {
         emsgTrackOutput.sampleMetadata(
             sampleTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, /* offset= */ 0, null);
       }
-    } else {
-      // We need the first sample timestamp in the segment before we can output the metadata.
-      pendingMetadataSampleInfos.addLast(
-          new MetadataSampleInfo(presentationTimeDeltaUs, sampleSize));
-      pendingMetadataSampleBytes += sampleSize;
     }
   }
 
-  /**
-   * Parses a trex atom (defined in 14496-12).
-   */
+  /** Parses a trex atom (defined in 14496-12). */
   private static Pair<Integer, DefaultSampleValues> parseTrex(ParsableByteArray trex) {
     trex.setPosition(Atom.FULL_HEADER_SIZE);
     int trackId = trex.readInt();
@@ -934,7 +964,9 @@ private static int parseTrun(TrackBundle trackBundle, int index, long decodeTime
     // duration == 0). Other uses of edit lists are uncommon and unsupported.
     if (track.editListDurations != null && track.editListDurations.length == 1
         && track.editListDurations[0] == 0) {
-      edtsOffset = Util.scaleLargeTimestamp(track.editListMediaTimes[0], 1000, track.timescale);
+      edtsOffset =
+          Util.scaleLargeTimestamp(
+              track.editListMediaTimes[0], C.MILLIS_PER_SECOND, track.timescale);
     }
 
     int[] sampleSizeTable = fragment.sampleSizeTable;
@@ -962,12 +994,13 @@ private static int parseTrun(TrackBundle trackBundle, int index, long decodeTime
         // here, because unsigned integers will still be parsed correctly (unless their top bit is
         // set, which is never true in practice because sample offsets are always small).
         int sampleOffset = trun.readInt();
-        sampleCompositionTimeOffsetTable[i] = (int) ((sampleOffset * 1000L) / timescale);
+        sampleCompositionTimeOffsetTable[i] =
+            (int) ((sampleOffset * C.MILLIS_PER_SECOND) / timescale);
       } else {
         sampleCompositionTimeOffsetTable[i] = 0;
       }
       sampleDecodingTimeTable[i] =
-          Util.scaleLargeTimestamp(cumulativeTime, 1000, timescale) - edtsOffset;
+          Util.scaleLargeTimestamp(cumulativeTime, C.MILLIS_PER_SECOND, timescale) - edtsOffset;
       sampleSizeTable[i] = sampleSize;
       sampleIsSyncFrameTable[i] = ((sampleFlags >> 16) & 0x1) == 0
           && (!workaroundEveryVideoFrameIsSyncFrame || i == 0);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/Track.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/Track.java
index 09f3f629be..aa42ce6251 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/Track.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/Track.java
@@ -123,6 +123,7 @@ public Track(int id, int type, long timescale, long movieTimescale, long duratio
    * @return The {@link TrackEncryptionBox} for the given sample description index. Maybe null if no
    *     such entry exists.
    */
+  @Nullable
   public TrackEncryptionBox getSampleDescriptionEncryptionBox(int sampleDescriptionIndex) {
     return sampleDescriptionEncryptionBoxes == null ? null
         : sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/TrackEncryptionBox.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/TrackEncryptionBox.java
index 8b5b916ed2..376e28f7a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/TrackEncryptionBox.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/mp4/TrackEncryptionBox.java
@@ -52,7 +52,7 @@
    * If {@link #perSampleIvSize} is 0, holds the default initialization vector as defined in the
    * track encryption box or sample group description box. Null otherwise.
    */
-  public final byte[] defaultInitializationVector;
+  @Nullable public final byte[] defaultInitializationVector;
 
   /**
    * @param isEncrypted See {@link #isEncrypted}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeeker.java
index c3bef63c64..9e60f7ba48 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeeker.java
@@ -16,29 +16,32 @@
 package com.google.android.exoplayer2VRT.extractor.ogg;
 
 import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.ParserException;
 import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
 import com.google.android.exoplayer2VRT.extractor.SeekMap;
 import com.google.android.exoplayer2VRT.extractor.SeekPoint;
 import com.google.android.exoplayer2VRT.util.Assertions;
+import com.google.android.exoplayer2VRT.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 
 /** Seeks in an Ogg stream. */
 /* package */ final class DefaultOggSeeker implements OggSeeker {
 
-  @VisibleForTesting public static final int MATCH_RANGE = 72000;
-  @VisibleForTesting public static final int MATCH_BYTE_RANGE = 100000;
+  private static final int MATCH_RANGE = 72000;
+  private static final int MATCH_BYTE_RANGE = 100000;
   private static final int DEFAULT_OFFSET = 30000;
 
   private static final int STATE_SEEK_TO_END = 0;
   private static final int STATE_READ_LAST_PAGE = 1;
   private static final int STATE_SEEK = 2;
-  private static final int STATE_IDLE = 3;
+  private static final int STATE_SKIP = 3;
+  private static final int STATE_IDLE = 4;
 
   private final OggPageHeader pageHeader = new OggPageHeader();
-  private final long startPosition;
-  private final long endPosition;
+  private final long payloadStartPosition;
+  private final long payloadEndPosition;
   private final StreamReader streamReader;
 
   private int state;
@@ -54,26 +57,27 @@
   /**
    * Constructs an OggSeeker.
    *
-   * @param startPosition Start position of the payload (inclusive).
-   * @param endPosition End position of the payload (exclusive).
    * @param streamReader The {@link StreamReader} that owns this seeker.
+   * @param payloadStartPosition Start position of the payload (inclusive).
+   * @param payloadEndPosition End position of the payload (exclusive).
    * @param firstPayloadPageSize The total size of the first payload page, in bytes.
    * @param firstPayloadPageGranulePosition The granule position of the first payload page.
-   * @param firstPayloadPageIsLastPage Whether the first payload page is also the last page in the
-   *     ogg stream.
+   * @param firstPayloadPageIsLastPage Whether the first payload page is also the last page.
    */
   public DefaultOggSeeker(
-      long startPosition,
-      long endPosition,
       StreamReader streamReader,
+      long payloadStartPosition,
+      long payloadEndPosition,
       long firstPayloadPageSize,
       long firstPayloadPageGranulePosition,
       boolean firstPayloadPageIsLastPage) {
-    Assertions.checkArgument(startPosition >= 0 && endPosition > startPosition);
+    Assertions.checkArgument(
+        payloadStartPosition >= 0 && payloadEndPosition > payloadStartPosition);
     this.streamReader = streamReader;
-    this.startPosition = startPosition;
-    this.endPosition = endPosition;
-    if (firstPayloadPageSize == endPosition - startPosition || firstPayloadPageIsLastPage) {
+    this.payloadStartPosition = payloadStartPosition;
+    this.payloadEndPosition = payloadEndPosition;
+    if (firstPayloadPageSize == payloadEndPosition - payloadStartPosition
+        || firstPayloadPageIsLastPage) {
       totalGranules = firstPayloadPageGranulePosition;
       state = STATE_IDLE;
     } else {
@@ -90,7 +94,7 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
         positionBeforeSeekToEnd = input.getPosition();
         state = STATE_READ_LAST_PAGE;
         // Seek to the end just before the last page of stream to get the duration.
-        long lastPageSearchPosition = endPosition - OggPageHeader.MAX_PAGE_SIZE;
+        long lastPageSearchPosition = payloadEndPosition - OggPageHeader.MAX_PAGE_SIZE;
         if (lastPageSearchPosition > positionBeforeSeekToEnd) {
           return lastPageSearchPosition;
         }
@@ -100,145 +104,110 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
         state = STATE_IDLE;
         return positionBeforeSeekToEnd;
       case STATE_SEEK:
-        long currentGranule;
-        if (targetGranule == 0) {
-          currentGranule = 0;
-        } else {
-          long position = getNextSeekPosition(targetGranule, input);
-          if (position >= 0) {
-            return position;
-          }
-          currentGranule = skipToPageOfGranule(input, targetGranule, -(position + 2));
+        long position = getNextSeekPosition(input);
+        if (position != C.POSITION_UNSET) {
+          return position;
         }
+        state = STATE_SKIP;
+        // Fall through.
+      case STATE_SKIP:
+        skipToPageOfTargetGranule(input);
         state = STATE_IDLE;
-        return -(currentGranule + 2);
+        return -(startGranule + 2);
       default:
         // Never happens.
         throw new IllegalStateException();
     }
   }
 
-  @Override
-  public long startSeek(long timeUs) {
-    Assertions.checkArgument(state == STATE_IDLE || state == STATE_SEEK);
-    targetGranule = timeUs == 0 ? 0 : streamReader.convertTimeToGranule(timeUs);
-    state = STATE_SEEK;
-    resetSeeking();
-    return targetGranule;
-  }
-
   @Override
   public OggSeekMap createSeekMap() {
     return totalGranules != 0 ? new OggSeekMap() : null;
   }
 
-  @VisibleForTesting
-  public void resetSeeking() {
-    start = startPosition;
-    end = endPosition;
+  @Override
+  public void startSeek(long targetGranule) {
+    this.targetGranule = Util.constrainValue(targetGranule, 0, totalGranules - 1);
+    state = STATE_SEEK;
+    start = payloadStartPosition;
+    end = payloadEndPosition;
     startGranule = 0;
     endGranule = totalGranules;
   }
 
   /**
-   * Returns a position converging to the {@code targetGranule} to which the {@link ExtractorInput}
-   * has to seek and then be passed for another call until a negative number is returned. If a
-   * negative number is returned the input is at a position which is before the target page and at
-   * which it is sensible to just skip pages to the target granule and pre-roll instead of doing
-   * another seek request.
+   * Performs a single step of a seeking binary search, returning the byte position from which data
+   * should be provided for the next step, or {@link C#POSITION_UNSET} if the search has converged.
+   * If the search has converged then {@link #skipToPageOfTargetGranule(ExtractorInput)} should be
+   * called to skip to the target page.
    *
-   * @param targetGranule the target granule position to seek to.
-   * @param input the {@link ExtractorInput} to read from.
-   * @return the position to seek the {@link ExtractorInput} to for a next call or -(currentGranule
-   *     + 2) if it's close enough to skip to the target page.
-   * @throws IOException thrown if reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while reading from the input.
+   * @param input The {@link ExtractorInput} to read from.
+   * @return The byte position from which data should be provided for the next step, or {@link
+   *     C#POSITION_UNSET} if the search has converged.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
    */
-  @VisibleForTesting
-  public long getNextSeekPosition(long targetGranule, ExtractorInput input)
-      throws IOException, InterruptedException {
+  private long getNextSeekPosition(ExtractorInput input) throws IOException, InterruptedException {
     if (start == end) {
-      return -(startGranule + 2);
+      return C.POSITION_UNSET;
     }
 
-    long initialPosition = input.getPosition();
+    long currentPosition = input.getPosition();
     if (!skipToNextPage(input, end)) {
-      if (start == initialPosition) {
+      if (start == currentPosition) {
         throw new IOException("No ogg page can be found.");
       }
       return start;
     }
 
-    pageHeader.populate(input, false);
+    pageHeader.populate(input, /* quiet= */ false);
     input.resetPeekPosition();
 
     long granuleDistance = targetGranule - pageHeader.granulePosition;
     int pageSize = pageHeader.headerSize + pageHeader.bodySize;
-    if (granuleDistance < 0 || granuleDistance > MATCH_RANGE) {
-      if (granuleDistance < 0) {
-        end = initialPosition;
-        endGranule = pageHeader.granulePosition;
-      } else {
-        start = input.getPosition() + pageSize;
-        startGranule = pageHeader.granulePosition;
-        if (end - start + pageSize < MATCH_BYTE_RANGE) {
-          input.skipFully(pageSize);
-          return -(startGranule + 2);
-        }
-      }
-
-      if (end - start < MATCH_BYTE_RANGE) {
-        end = start;
-        return start;
-      }
-
-      long offset = pageSize * (granuleDistance <= 0 ? 2L : 1L);
-      long nextPosition = input.getPosition() - offset
-          + (granuleDistance * (end - start) / (endGranule - startGranule));
-
-      nextPosition = Math.max(nextPosition, start);
-      nextPosition = Math.min(nextPosition, end - 1);
-      return nextPosition;
+    if (0 <= granuleDistance && granuleDistance < MATCH_RANGE) {
+      return C.POSITION_UNSET;
     }
 
-    // position accepted (before target granule and within MATCH_RANGE)
-    input.skipFully(pageSize);
-    return -(pageHeader.granulePosition + 2);
-  }
-
-  private long getEstimatedPosition(long position, long granuleDistance, long offset) {
-    position += (granuleDistance * (endPosition - startPosition) / totalGranules) - offset;
-    if (position < startPosition) {
-      position = startPosition;
-    }
-    if (position >= endPosition) {
-      position = endPosition - 1;
+    if (granuleDistance < 0) {
+      end = currentPosition;
+      endGranule = pageHeader.granulePosition;
+    } else {
+      start = input.getPosition() + pageSize;
+      startGranule = pageHeader.granulePosition;
     }
-    return position;
-  }
 
-  private class OggSeekMap implements SeekMap {
-
-    @Override
-    public boolean isSeekable() {
-      return true;
+    if (end - start < MATCH_BYTE_RANGE) {
+      end = start;
+      return start;
     }
 
-    @Override
-    public SeekPoints getSeekPoints(long timeUs) {
-      if (timeUs == 0) {
-        return new SeekPoints(new SeekPoint(0, startPosition));
-      }
-      long granule = streamReader.convertTimeToGranule(timeUs);
-      long estimatedPosition = getEstimatedPosition(startPosition, granule, DEFAULT_OFFSET);
-      return new SeekPoints(new SeekPoint(timeUs, estimatedPosition));
-    }
+    long offset = pageSize * (granuleDistance <= 0 ? 2L : 1L);
+    long nextPosition =
+        input.getPosition()
+            - offset
+            + (granuleDistance * (end - start) / (endGranule - startGranule));
+    return Util.constrainValue(nextPosition, start, end - 1);
+  }
 
-    @Override
-    public long getDurationUs() {
-      return streamReader.convertGranuleToTime(totalGranules);
+  /**
+   * Skips forward to the start of the page containing the {@code targetGranule}.
+   *
+   * @param input The {@link ExtractorInput} to read from.
+   * @throws ParserException If populating the page header fails.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   */
+  private void skipToPageOfTargetGranule(ExtractorInput input)
+      throws IOException, InterruptedException {
+    pageHeader.populate(input, /* quiet= */ false);
+    while (pageHeader.granulePosition <= targetGranule) {
+      input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
+      start = input.getPosition();
+      startGranule = pageHeader.granulePosition;
+      pageHeader.populate(input, /* quiet= */ false);
     }
-
+    input.resetPeekPosition();
   }
 
   /**
@@ -251,7 +220,7 @@ public long getDurationUs() {
    */
   @VisibleForTesting
   void skipToNextPage(ExtractorInput input) throws IOException, InterruptedException {
-    if (!skipToNextPage(input, endPosition)) {
+    if (!skipToNextPage(input, payloadEndPosition)) {
       // Not found until eof.
       throw new EOFException();
     }
@@ -263,13 +232,12 @@ void skipToNextPage(ExtractorInput input) throws IOException, InterruptedExcepti
    * @param input The {@code ExtractorInput} to skip to the next page.
    * @param limit The limit up to which the search should take place.
    * @return Whether the next page was found.
-   * @throws IOException thrown if peeking/reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while peeking/reading from the input.
+   * @throws IOException If peeking/reading from the input fails.
+   * @throws InterruptedException If interrupted while peeking/reading from the input.
    */
-  @VisibleForTesting
-  boolean skipToNextPage(ExtractorInput input, long limit)
+  private boolean skipToNextPage(ExtractorInput input, long limit)
       throws IOException, InterruptedException {
-    limit = Math.min(limit + 3, endPosition);
+    limit = Math.min(limit + 3, payloadEndPosition);
     byte[] buffer = new byte[2048];
     int peekLength = buffer.length;
     while (true) {
@@ -310,39 +278,35 @@ boolean skipToNextPage(ExtractorInput input, long limit)
   long readGranuleOfLastPage(ExtractorInput input) throws IOException, InterruptedException {
     skipToNextPage(input);
     pageHeader.reset();
-    while ((pageHeader.type & 0x04) != 0x04 && input.getPosition() < endPosition) {
-      pageHeader.populate(input, false);
+    while ((pageHeader.type & 0x04) != 0x04 && input.getPosition() < payloadEndPosition) {
+      pageHeader.populate(input, /* quiet= */ false);
       input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
     }
     return pageHeader.granulePosition;
   }
 
-  /**
-   * Skips to the position of the start of the page containing the {@code targetGranule} and returns
-   * the granule of the page previous to the target page.
-   *
-   * @param input the {@link ExtractorInput} to read from.
-   * @param targetGranule the target granule.
-   * @param currentGranule the current granule or -1 if it's unknown.
-   * @return the granule of the prior page or the {@code currentGranule} if there isn't a prior
-   *     page.
-   * @throws ParserException thrown if populating the page header fails.
-   * @throws IOException thrown if reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while reading from the input.
-   */
-  @VisibleForTesting
-  long skipToPageOfGranule(ExtractorInput input, long targetGranule, long currentGranule)
-      throws IOException, InterruptedException {
-    pageHeader.populate(input, false);
-    while (pageHeader.granulePosition < targetGranule) {
-      input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
-      // Store in a member field to be able to resume after IOExceptions.
-      currentGranule = pageHeader.granulePosition;
-      // Peek next header.
-      pageHeader.populate(input, false);
+  private final class OggSeekMap implements SeekMap {
+
+    @Override
+    public boolean isSeekable() {
+      return true;
     }
-    input.resetPeekPosition();
-    return currentGranule;
-  }
 
+    @Override
+    public SeekPoints getSeekPoints(long timeUs) {
+      long targetGranule = streamReader.convertTimeToGranule(timeUs);
+      long estimatedPosition =
+          payloadStartPosition
+              + (targetGranule * (payloadEndPosition - payloadStartPosition) / totalGranules)
+              - DEFAULT_OFFSET;
+      estimatedPosition =
+          Util.constrainValue(estimatedPosition, payloadStartPosition, payloadEndPosition - 1);
+      return new SeekPoints(new SeekPoint(timeUs, estimatedPosition));
+    }
+
+    @Override
+    public long getDurationUs() {
+      return streamReader.convertGranuleToTime(totalGranules);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/FlacReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/FlacReader.java
index 356b91acca..94565fc0e4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/FlacReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/FlacReader.java
@@ -15,11 +15,12 @@
  */
 package com.google.android.exoplayer2VRT.extractor.ogg;
 
+import com.google.android.exoplayer2VRT.Format;
 import com.google.android.exoplayer2VRT.Format;
 import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
 import com.google.android.exoplayer2VRT.extractor.SeekMap;
 import com.google.android.exoplayer2VRT.extractor.SeekPoint;
-import com.google.android.exoplayer2VRT.util.FlacStreamInfo;
+import com.google.android.exoplayer2VRT.util.FlacStreamMetadata;
 import com.google.android.exoplayer2VRT.util.MimeTypes;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
 import com.google.android.exoplayer2VRT.util.Util;
@@ -38,7 +39,7 @@
 
   private static final int FRAME_HEADER_SAMPLE_NUMBER_OFFSET = 4;
 
-  private FlacStreamInfo streamInfo;
+  private FlacStreamMetadata streamMetadata;
   private FlacOggSeeker flacOggSeeker;
 
   public static boolean verifyBitstreamType(ParsableByteArray data) {
@@ -50,7 +51,7 @@ public static boolean verifyBitstreamType(ParsableByteArray data) {
   protected void reset(boolean headerData) {
     super.reset(headerData);
     if (headerData) {
-      streamInfo = null;
+      streamMetadata = null;
       flacOggSeeker = null;
     }
   }
@@ -71,14 +72,24 @@ protected long preparePayload(ParsableByteArray packet) {
   protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
       throws IOException, InterruptedException {
     byte[] data = packet.data;
-    if (streamInfo == null) {
-      streamInfo = new FlacStreamInfo(data, 17);
+    if (streamMetadata == null) {
+      streamMetadata = new FlacStreamMetadata(data, 17);
       byte[] metadata = Arrays.copyOfRange(data, 9, packet.limit());
       metadata[4] = (byte) 0x80; // Set the last metadata block flag, ignore the other blocks
       List<byte[]> initializationData = Collections.singletonList(metadata);
-      setupData.format = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_FLAC, null,
-          Format.NO_VALUE, streamInfo.bitRate(), streamInfo.channels, streamInfo.sampleRate,
-          initializationData, null, 0, null);
+      setupData.format =
+          Format.createAudioSampleFormat(
+              null,
+              MimeTypes.AUDIO_FLAC,
+              null,
+              Format.NO_VALUE,
+              streamMetadata.bitRate(),
+              streamMetadata.channels,
+              streamMetadata.sampleRate,
+              initializationData,
+              null,
+              0,
+              null);
     } else if ((data[0] & 0x7F) == SEEKTABLE_PACKET_TYPE) {
       flacOggSeeker = new FlacOggSeeker();
       flacOggSeeker.parseSeekTable(packet);
@@ -175,11 +186,9 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
     }
 
     @Override
-    public long startSeek(long timeUs) {
-      long granule = convertTimeToGranule(timeUs);
-      int index = Util.binarySearchFloor(seekPointGranules, granule, true, true);
+    public void startSeek(long targetGranule) {
+      int index = Util.binarySearchFloor(seekPointGranules, targetGranule, true, true);
       pendingSeekGranule = seekPointGranules[index];
-      return granule;
     }
 
     @Override
@@ -211,7 +220,7 @@ public SeekPoints getSeekPoints(long timeUs) {
 
     @Override
     public long getDurationUs() {
-      return streamInfo.durationUs();
+      return streamMetadata.durationUs();
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggPageHeader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggPageHeader.java
index c81e5aada8..c911b4482e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggPageHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggPageHeader.java
@@ -38,7 +38,13 @@
 
   public int revision;
   public int type;
+  /**
+   * The absolute granule position of the page. This is the total number of samples from the start
+   * of the file up to the <em>end</em> of the page. Samples partially in the page that continue on
+   * the next page do not count.
+   */
   public long granulePosition;
+
   public long streamSerialNumber;
   public long pageSequenceNumber;
   public long pageChecksum;
@@ -72,10 +78,10 @@ public void reset() {
    * Peeks an Ogg page header and updates this {@link OggPageHeader}.
    *
    * @param input The {@link ExtractorInput} to read from.
-   * @param quiet If {@code true}, no exceptions are thrown but {@code false} is returned if
-   *     something goes wrong.
-   * @return {@code true} if the read was successful. The read fails if the end of the input is
-   *     encountered without reading data.
+   * @param quiet Whether to return {@code false} rather than throwing an exception if the header
+   *     cannot be populated.
+   * @return Whether the read was successful. The read fails if the end of the input is encountered
+   *     without reading data.
    * @throws IOException If reading data fails or the stream is invalid.
    * @throws InterruptedException If the thread is interrupted.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggSeeker.java
index 0a8653dc37..66c28f5ee6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/OggSeeker.java
@@ -33,16 +33,14 @@
   SeekMap createSeekMap();
 
   /**
-   * Initializes a seek operation.
+   * Starts a seek operation.
    *
-   * @param timeUs The seek position in microseconds.
-   * @return The granule position targeted by the seek.
+   * @param targetGranule The target granule position.
    */
-  long startSeek(long timeUs);
+  void startSeek(long targetGranule);
 
   /**
-   * Reads data from the {@link ExtractorInput} to build the {@link SeekMap} or to continue a
-   * progressive seek.
+   * Reads data from the {@link ExtractorInput} to build the {@link SeekMap} or to continue a seek.
    * <p/>
    * If more data is required or if the position of the input needs to be modified then a position
    * from which data should be provided is returned. Else a negative value is returned. If a seek
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/StreamReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/StreamReader.java
index 67fd9facc3..d4dba02422 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/StreamReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/ogg/StreamReader.java
@@ -91,7 +91,8 @@ final void seek(long position, long timeUs) {
       reset(!seekMapSet);
     } else {
       if (state != STATE_READ_HEADERS) {
-        targetGranule = oggSeeker.startSeek(timeUs);
+        targetGranule = convertTimeToGranule(timeUs);
+        oggSeeker.startSeek(targetGranule);
         state = STATE_READ_PAYLOAD;
       }
     }
@@ -147,9 +148,9 @@ private int readHeaders(ExtractorInput input) throws IOException, InterruptedExc
       boolean isLastPage = (firstPayloadPageHeader.type & 0x04) != 0; // Type 4 is end of stream.
       oggSeeker =
           new DefaultOggSeeker(
+              this,
               payloadStartPosition,
               input.getLength(),
-              this,
               firstPayloadPageHeader.headerSize + firstPayloadPageHeader.bodySize,
               firstPayloadPageHeader.granulePosition,
               isLastPage);
@@ -248,13 +249,13 @@ protected void onSeekEnd(long currentGranule) {
   private static final class UnseekableOggSeeker implements OggSeeker {
 
     @Override
-    public long read(ExtractorInput input) throws IOException, InterruptedException {
+    public long read(ExtractorInput input) {
       return -1;
     }
 
     @Override
-    public long startSeek(long timeUs) {
-      return 0;
+    public void startSeek(long targetGranule) {
+      // Do nothing.
     }
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavExtractor.java
index fef7dcd2b7..b386c28510 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavExtractor.java
@@ -87,12 +87,14 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     if (!wavHeader.hasDataBounds()) {
       WavHeaderReader.skipToData(input, wavHeader);
       extractorOutput.seekMap(wavHeader);
+    } else if (input.getPosition() == 0) {
+      input.skipFully(wavHeader.getDataStartPosition());
     }
 
-    long dataLimit = wavHeader.getDataLimit();
-    Assertions.checkState(dataLimit != C.POSITION_UNSET);
+    long dataEndPosition = wavHeader.getDataEndPosition();
+    Assertions.checkState(dataEndPosition != C.POSITION_UNSET);
 
-    long bytesLeft = dataLimit - input.getPosition();
+    long bytesLeft = dataEndPosition - input.getPosition();
     if (bytesLeft <= 0) {
       return Extractor.RESULT_END_OF_INPUT;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeader.java
index edd86fe108..30b43114f3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeader.java
@@ -33,23 +33,29 @@
   private final int blockAlignment;
   /** Bits per sample for the audio data. */
   private final int bitsPerSample;
-  /** The PCM encoding */
-  @C.PcmEncoding
-  private final int encoding;
-
-  /** Offset to the start of sample data. */
-  private long dataStartPosition;
-  /** Total size in bytes of the sample data. */
-  private long dataSize;
-
-  public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, int blockAlignment,
-      int bitsPerSample, @C.PcmEncoding int encoding) {
+  /** The PCM encoding. */
+  @C.PcmEncoding private final int encoding;
+
+  /** Position of the start of the sample data, in bytes. */
+  private int dataStartPosition;
+  /** Position of the end of the sample data (exclusive), in bytes. */
+  private long dataEndPosition;
+
+  public WavHeader(
+      int numChannels,
+      int sampleRateHz,
+      int averageBytesPerSecond,
+      int blockAlignment,
+      int bitsPerSample,
+      @C.PcmEncoding int encoding) {
     this.numChannels = numChannels;
     this.sampleRateHz = sampleRateHz;
     this.averageBytesPerSecond = averageBytesPerSecond;
     this.blockAlignment = blockAlignment;
     this.bitsPerSample = bitsPerSample;
     this.encoding = encoding;
+    dataStartPosition = C.POSITION_UNSET;
+    dataEndPosition = C.POSITION_UNSET;
   }
 
   // Data bounds.
@@ -57,22 +63,33 @@ public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, i
   /**
    * Sets the data start position and size in bytes of sample data in this WAV.
    *
-   * @param dataStartPosition The data start position in bytes.
-   * @param dataSize The data size in bytes.
+   * @param dataStartPosition The position of the start of the sample data, in bytes.
+   * @param dataEndPosition The position of the end of the sample data (exclusive), in bytes.
    */
-  public void setDataBounds(long dataStartPosition, long dataSize) {
+  public void setDataBounds(int dataStartPosition, long dataEndPosition) {
     this.dataStartPosition = dataStartPosition;
-    this.dataSize = dataSize;
+    this.dataEndPosition = dataEndPosition;
+  }
+
+  /**
+   * Returns the position of the start of the sample data, in bytes, or {@link C#POSITION_UNSET} if
+   * the data bounds have not been set.
+   */
+  public int getDataStartPosition() {
+    return dataStartPosition;
   }
 
-  /** Returns the data limit, or {@link C#POSITION_UNSET} if the data bounds have not been set. */
-  public long getDataLimit() {
-    return hasDataBounds() ? (dataStartPosition + dataSize) : C.POSITION_UNSET;
+  /**
+   * Returns the position of the end of the sample data (exclusive), in bytes, or {@link
+   * C#POSITION_UNSET} if the data bounds have not been set.
+   */
+  public long getDataEndPosition() {
+    return dataEndPosition;
   }
 
   /** Returns whether the data start position and size have been set. */
   public boolean hasDataBounds() {
-    return dataStartPosition != 0 && dataSize != 0;
+    return dataStartPosition != C.POSITION_UNSET;
   }
 
   // SeekMap implementation.
@@ -84,12 +101,13 @@ public boolean isSeekable() {
 
   @Override
   public long getDurationUs() {
-    long numFrames = dataSize / blockAlignment;
+    long numFrames = (dataEndPosition - dataStartPosition) / blockAlignment;
     return (numFrames * C.MICROS_PER_SECOND) / sampleRateHz;
   }
 
   @Override
   public SeekPoints getSeekPoints(long timeUs) {
+    long dataSize = dataEndPosition - dataStartPosition;
     long positionOffset = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
     // Constrain to nearest preceding frame offset.
     positionOffset = (positionOffset / blockAlignment) * blockAlignment;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeaderReader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeaderReader.java
index b9c50d1de7..5cc535d33c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeaderReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/extractor/wav/WavHeaderReader.java
@@ -22,7 +22,6 @@
 import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.Log;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
-import com.google.android.exoplayer2VRT.util.Util;
 import java.io.IOException;
 
 /** Reads a {@code WavHeader} from an input stream; supports resuming from input failures. */
@@ -92,8 +91,8 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
     // If present, skip extensionSize, validBitsPerSample, channelMask, subFormatGuid, ...
     input.advancePeekPosition((int) chunkHeader.size - 16);
 
-    return new WavHeader(numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment,
-        bitsPerSample, encoding);
+    return new WavHeader(
+        numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment, bitsPerSample, encoding);
   }
 
   /**
@@ -122,11 +121,13 @@ public static void skipToData(ExtractorInput input, WavHeader wavHeader)
     ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
     // Skip all chunks until we hit the data header.
     ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
-    while (chunkHeader.id != Util.getIntegerCodeForString("data")) {
-      Log.w(TAG, "Ignoring unknown WAV chunk: " + chunkHeader.id);
+    while (chunkHeader.id != WavUtil.DATA_FOURCC) {
+      if (chunkHeader.id != WavUtil.RIFF_FOURCC && chunkHeader.id != WavUtil.FMT_FOURCC) {
+        Log.w(TAG, "Ignoring unknown WAV chunk: " + chunkHeader.id);
+      }
       long bytesToSkip = ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;
       // Override size of RIFF chunk, since it describes its size as the entire file.
-      if (chunkHeader.id == Util.getIntegerCodeForString("RIFF")) {
+      if (chunkHeader.id == WavUtil.RIFF_FOURCC) {
         bytesToSkip = ChunkHeader.SIZE_IN_BYTES + 4;
       }
       if (bytesToSkip > Integer.MAX_VALUE) {
@@ -138,7 +139,14 @@ public static void skipToData(ExtractorInput input, WavHeader wavHeader)
     // Skip past the "data" header.
     input.skipFully(ChunkHeader.SIZE_IN_BYTES);
 
-    wavHeader.setDataBounds(input.getPosition(), chunkHeader.size);
+    int dataStartPosition = (int) input.getPosition();
+    long dataEndPosition = dataStartPosition + chunkHeader.size;
+    long inputLength = input.getLength();
+    if (inputLength != C.LENGTH_UNSET && dataEndPosition > inputLength) {
+      Log.w(TAG, "Data exceeds input length: " + dataEndPosition + ", " + inputLength);
+      dataEndPosition = inputLength;
+    }
+    wavHeader.setDataBounds(dataStartPosition, dataEndPosition);
   }
 
   private WavHeaderReader() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecInfo.java
index 2f4c24b2d7..8c985b6845 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecInfo.java
@@ -54,8 +54,15 @@
   public final @Nullable String mimeType;
 
   /**
-   * The capabilities of the decoder, like the profiles/levels it supports, or {@code null} if this
-   * is a passthrough codec.
+   * The MIME type that the codec uses for media of type {@link #mimeType}, or {@code null} if this
+   * is a passthrough codec. Equal to {@link #mimeType} unless the codec is known to use a
+   * non-standard MIME type alias.
+   */
+  @Nullable public final String codecMimeType;
+
+  /**
+   * The capabilities of the decoder, like the profiles/levels it supports, or {@code null} if not
+   * known.
    */
   public final @Nullable CodecCapabilities capabilities;
 
@@ -98,6 +105,7 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
     return new MediaCodecInfo(
         name,
         /* mimeType= */ null,
+        /* codecMimeType= */ null,
         /* capabilities= */ null,
         /* passthrough= */ true,
         /* forceDisableAdaptive= */ false,
@@ -109,26 +117,10 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
    *
    * @param name The name of the {@link MediaCodec}.
    * @param mimeType A mime type supported by the {@link MediaCodec}.
-   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
-   * @return The created instance.
-   */
-  public static MediaCodecInfo newInstance(String name, String mimeType,
-      CodecCapabilities capabilities) {
-    return new MediaCodecInfo(
-        name,
-        mimeType,
-        capabilities,
-        /* passthrough= */ false,
-        /* forceDisableAdaptive= */ false,
-        /* forceSecure= */ false);
-  }
-
-  /**
-   * Creates an instance.
-   *
-   * @param name The name of the {@link MediaCodec}.
-   * @param mimeType A mime type supported by the {@link MediaCodec}.
-   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
+   * @param codecMimeType The MIME type that the codec uses for media of type {@code #mimeType}.
+   *     Equal to {@code mimeType} unless the codec is known to use a non-standard MIME type alias.
+   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type, or
+   *     {@code null} if not known.
    * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
    * @param forceSecure Whether {@link #secure} should be forced to {@code true}.
    * @return The created instance.
@@ -136,22 +128,31 @@ public static MediaCodecInfo newInstance(String name, String mimeType,
   public static MediaCodecInfo newInstance(
       String name,
       String mimeType,
-      CodecCapabilities capabilities,
+      String codecMimeType,
+      @Nullable CodecCapabilities capabilities,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     return new MediaCodecInfo(
-        name, mimeType, capabilities, /* passthrough= */ false, forceDisableAdaptive, forceSecure);
+        name,
+        mimeType,
+        codecMimeType,
+        capabilities,
+        /* passthrough= */ false,
+        forceDisableAdaptive,
+        forceSecure);
   }
 
   private MediaCodecInfo(
       String name,
       @Nullable String mimeType,
+      @Nullable String codecMimeType,
       @Nullable CodecCapabilities capabilities,
       boolean passthrough,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     this.name = Assertions.checkNotNull(name);
     this.mimeType = mimeType;
+    this.codecMimeType = codecMimeType;
     this.capabilities = capabilities;
     this.passthrough = passthrough;
     adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
@@ -518,9 +519,15 @@ private static boolean isSecureV21(CodecCapabilities capabilities) {
   @TargetApi(21)
   private static boolean areSizeAndRateSupportedV21(VideoCapabilities capabilities, int width,
       int height, double frameRate) {
-    return frameRate == Format.NO_VALUE || frameRate <= 0
-        ? capabilities.isSizeSupported(width, height)
-        : capabilities.areSizeAndRateSupported(width, height, frameRate);
+    if (frameRate == Format.NO_VALUE || frameRate <= 0) {
+      return capabilities.isSizeSupported(width, height);
+    } else {
+      // The signaled frame rate may be slightly higher than the actual frame rate, so we take the
+      // floor to avoid situations where a range check in areSizeAndRateSupported fails due to
+      // slightly exceeding the limits for a standard format (e.g., 1080p at 30 fps).
+      double floorFrameRate = Math.floor(frameRate);
+      return capabilities.areSizeAndRateSupported(width, height, floorFrameRate);
+    }
   }
 
   @TargetApi(23)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecRenderer.java
index 97468dabe4..7c68a7bd8c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecRenderer.java
@@ -53,7 +53,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -329,14 +328,16 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private int inputIndex;
   private int outputIndex;
   private ByteBuffer outputBuffer;
-  private boolean shouldSkipOutputBuffer;
+  private boolean isDecodeOnlyOutputBuffer;
+  private boolean isLastOutputBuffer;
   private boolean codecReconfigured;
   @ReconfigurationState private int codecReconfigurationState;
   @DrainState private int codecDrainState;
   @DrainAction private int codecDrainAction;
   private boolean codecReceivedBuffers;
   private boolean codecReceivedEos;
-
+  private long lastBufferInStreamPresentationTimeUs;
+  private long largestQueuedPresentationTimeUs;
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
@@ -454,15 +455,13 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
   protected abstract void configureCodec(
       MediaCodecInfo codecInfo,
       MediaCodec codec,
       Format format,
       MediaCrypto crypto,
-      float codecOperatingRate)
-      throws DecoderQueryException;
+      float codecOperatingRate);
 
   protected final void maybeInitCodec() throws ExoPlaybackException {
     if (codec != null || inputFormat == null) {
@@ -601,6 +600,8 @@ protected void releaseCodec() {
     waitingForKeys = false;
     codecHotswapDeadlineMs = C.TIME_UNSET;
     decodeOnlyPresentationTimestamps.clear();
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     try {
       if (codec != null) {
         decoderCounters.decoderReleaseCount++;
@@ -707,10 +708,13 @@ protected boolean flushOrReleaseCodec() {
     waitingForFirstSyncSample = true;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    shouldSkipOutputBuffer = false;
+    isDecodeOnlyOutputBuffer = false;
+    isLastOutputBuffer = false;
 
     waitingForKeys = false;
     decodeOnlyPresentationTimestamps.clear();
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     codecDrainState = DRAIN_STATE_NONE;
     codecDrainAction = DRAIN_ACTION_NONE;
     // Reconfiguration data sent shortly before the flush may not have been processed by the
@@ -742,11 +746,11 @@ private void maybeInitCodecWithFallback(
       try {
         List<MediaCodecInfo> allAvailableCodecInfos =
             getAvailableCodecInfos(mediaCryptoRequiresSecureDecoder);
+        availableCodecInfos = new ArrayDeque<>();
         if (enableDecoderFallback) {
-          availableCodecInfos = new ArrayDeque<>(allAvailableCodecInfos);
-        } else {
-          availableCodecInfos =
-              new ArrayDeque<>(Collections.singletonList(allAvailableCodecInfos.get(0)));
+          availableCodecInfos.addAll(allAvailableCodecInfos);
+        } else if (!allAvailableCodecInfos.isEmpty()) {
+          availableCodecInfos.add(allAvailableCodecInfos.get(0));
         }
         preferredDecoderInitializationException = null;
       } catch (DecoderQueryException e) {
@@ -884,7 +888,8 @@ private void initCodec(MediaCodecInfo codecInfo, MediaCrypto crypto) throws Exce
     codecDrainAction = DRAIN_ACTION_NONE;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    shouldSkipOutputBuffer = false;
+    isDecodeOnlyOutputBuffer = false;
+    isLastOutputBuffer = false;
     waitingForFirstSyncSample = true;
 
     decoderCounters.decoderInitCount++;
@@ -1019,6 +1024,11 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       result = readSource(formatHolder, buffer, false);
     }
 
+    if (hasReadStreamToEnd()) {
+      // Notify output queue of the last buffer's timestamp.
+      lastBufferInStreamPresentationTimeUs = largestQueuedPresentationTimeUs;
+    }
+
     if (result == C.RESULT_NOTHING_READ) {
       return false;
     }
@@ -1091,6 +1101,8 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         formatQueue.add(presentationTimeUs, inputFormat);
         waitingForFirstSampleInFormat = false;
       }
+      largestQueuedPresentationTimeUs =
+          Math.max(largestQueuedPresentationTimeUs, presentationTimeUs);
 
       buffer.flip();
       onQueueInputBuffer(buffer);
@@ -1461,7 +1473,9 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         outputBuffer.position(outputBufferInfo.offset);
         outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);
       }
-      shouldSkipOutputBuffer = shouldSkipOutputBuffer(outputBufferInfo.presentationTimeUs);
+      isDecodeOnlyOutputBuffer = isDecodeOnlyBuffer(outputBufferInfo.presentationTimeUs);
+      isLastOutputBuffer =
+          lastBufferInStreamPresentationTimeUs == outputBufferInfo.presentationTimeUs;
       updateOutputFormatForTime(outputBufferInfo.presentationTimeUs);
     }
 
@@ -1477,7 +1491,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
                 outputIndex,
                 outputBufferInfo.flags,
                 outputBufferInfo.presentationTimeUs,
-                shouldSkipOutputBuffer,
+                isDecodeOnlyOutputBuffer,
+                isLastOutputBuffer,
                 outputFormat);
       } catch (IllegalStateException e) {
         processEndOfStream();
@@ -1497,7 +1512,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
               outputIndex,
               outputBufferInfo.flags,
               outputBufferInfo.presentationTimeUs,
-              shouldSkipOutputBuffer,
+              isDecodeOnlyOutputBuffer,
+              isLastOutputBuffer,
               outputFormat);
     }
 
@@ -1564,7 +1580,9 @@ private void processOutputBuffersChanged() {
    * @param bufferIndex The index of the output buffer.
    * @param bufferFlags The flags attached to the output buffer.
    * @param bufferPresentationTimeUs The presentation time of the output buffer in microseconds.
-   * @param shouldSkip Whether the buffer should be skipped (i.e. not rendered).
+   * @param isDecodeOnlyBuffer Whether the buffer was marked with {@link C#BUFFER_FLAG_DECODE_ONLY}
+   *     by the source.
+   * @param isLastBuffer Whether the buffer is the last sample of the current stream.
    * @param format The format associated with the buffer.
    * @return Whether the output buffer was fully processed (e.g. rendered or skipped).
    * @throws ExoPlaybackException If an error occurs processing the output buffer.
@@ -1577,7 +1595,8 @@ protected abstract boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException;
 
@@ -1657,7 +1676,7 @@ private void updateDrmSessionOrReinitializeCodecV23() throws ExoPlaybackExceptio
     codecDrainAction = DRAIN_ACTION_NONE;
   }
 
-  private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
+  private boolean isDecodeOnlyBuffer(long presentationTimeUs) {
     // We avoid using decodeOnlyPresentationTimestamps.remove(presentationTimeUs) because it would
     // box presentationTimeUs, creating a Long object that would need to be garbage collected.
     int size = decodeOnlyPresentationTimestamps.size();
@@ -1787,9 +1806,8 @@ private static boolean codecNeedsDiscardToSpsWorkaround(String name, Format form
    */
   private static boolean codecNeedsEosPropagationWorkaround(MediaCodecInfo codecInfo) {
     String name = codecInfo.name;
-    return (Util.SDK_INT <= 17
-            && ("OMX.rk.video_decoder.avc".equals(name)
-                || "OMX.allwinner.video.decoder.avc".equals(name)))
+    return (Util.SDK_INT <= 25 && "OMX.rk.video_decoder.avc".equals(name))
+        || (Util.SDK_INT <= 17 && "OMX.allwinner.video.decoder.avc".equals(name))
         || ("Amazon".equals(Util.MANUFACTURER) && "AFTS".equals(Util.MODEL) && codecInfo.secure);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecSelector.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecSelector.java
index f515956e40..88fd3b2610 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecSelector.java
@@ -51,7 +51,8 @@
    * @param mimeType The MIME type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
    * @param requiresTunnelingDecoder Whether a tunneling decoder is required.
-   * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
+   * @return An unmodifiable list of {@link MediaCodecInfo}s corresponding to decoders. May be
+   *     empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
   List<MediaCodecInfo> getDecoderInfos(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecUtil.java
index bd37101835..7be1e1fb4f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/mediacodec/MediaCodecUtil.java
@@ -146,8 +146,8 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boo
    *     unless secure decryption really is required.
    * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
    *     tunneling really is required.
-   * @return A list of all {@link MediaCodecInfo}s for the given mime type, in the order given by
-   *     {@link MediaCodecList}.
+   * @return An unmodifiable list of all {@link MediaCodecInfo}s for the given mime type, in the
+   *     order given by {@link MediaCodecList}.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
   public static synchronized List<MediaCodecInfo> getDecoderInfos(
@@ -161,24 +161,17 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boo
         Util.SDK_INT >= 21
             ? new MediaCodecListCompatV21(secure, tunneling)
             : new MediaCodecListCompatV16();
-    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
+    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
       mediaCodecList = new MediaCodecListCompatV16();
-      decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
+      decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
       if (!decoderInfos.isEmpty()) {
         Log.w(TAG, "MediaCodecList API didn't list secure decoder for: " + mimeType
             + ". Assuming: " + decoderInfos.get(0).name);
       }
     }
-    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
-      // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
-      CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure, key.tunneling);
-      ArrayList<MediaCodecInfo> eac3DecoderInfos =
-          getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);
-      decoderInfos.addAll(eac3DecoderInfos);
-    }
     applyWorkarounds(mimeType, decoderInfos);
     List<MediaCodecInfo> unmodifiableDecoderInfos = Collections.unmodifiableList(decoderInfos);
     decoderInfosCache.put(key, unmodifiableDecoderInfos);
@@ -249,13 +242,11 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
    *
    * @param key The codec key.
    * @param mediaCodecList The codec list.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
    * @return The codec information for usable codecs matching the specified key.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
   private static ArrayList<MediaCodecInfo> getDecoderInfosInternal(CodecKey key,
-      MediaCodecListCompat mediaCodecList, String requestedMimeType) throws DecoderQueryException {
+      MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
     try {
       ArrayList<MediaCodecInfo> decoderInfos = new ArrayList<>();
       String mimeType = key.mimeType;
@@ -265,28 +256,27 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       for (int i = 0; i < numberOfCodecs; i++) {
         android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
         String name = codecInfo.getName();
-        String supportedType =
-            getCodecSupportedType(codecInfo, name, secureDecodersExplicit, requestedMimeType);
-        if (supportedType == null) {
+        String codecMimeType = getCodecMimeType(codecInfo, name, secureDecodersExplicit, mimeType);
+        if (codecMimeType == null) {
           continue;
         }
         try {
-          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(codecMimeType);
           boolean tunnelingSupported =
               mediaCodecList.isFeatureSupported(
-                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);
           boolean tunnelingRequired =
               mediaCodecList.isFeatureRequired(
-                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);
           if ((!key.tunneling && tunnelingRequired) || (key.tunneling && !tunnelingSupported)) {
             continue;
           }
           boolean secureSupported =
               mediaCodecList.isFeatureSupported(
-                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);
           boolean secureRequired =
               mediaCodecList.isFeatureRequired(
-                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);
           if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {
             continue;
           }
@@ -295,12 +285,18 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
               || (!secureDecodersExplicit && !key.secure)) {
             decoderInfos.add(
                 MediaCodecInfo.newInstance(
-                    name, mimeType, capabilities, forceDisableAdaptive, /* forceSecure= */ false));
+                    name,
+                    mimeType,
+                    codecMimeType,
+                    capabilities,
+                    forceDisableAdaptive,
+                    /* forceSecure= */ false));
           } else if (!secureDecodersExplicit && secureSupported) {
             decoderInfos.add(
                 MediaCodecInfo.newInstance(
                     name + ".secure",
                     mimeType,
+                    codecMimeType,
                     capabilities,
                     forceDisableAdaptive,
                     /* forceSecure= */ true));
@@ -314,7 +310,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
           } else {
             // Rethrow error querying primary codec capabilities, or secondary codec
             // capabilities if API level is greater than 23.
-            Log.e(TAG, "Failed to query codec " + name + " (" + supportedType + ")");
+            Log.e(TAG, "Failed to query codec " + name + " (" + codecMimeType + ")");
             throw e;
           }
         }
@@ -328,42 +324,49 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
   }
 
   /**
-   * Returns the codec's supported type for decoding {@code requestedMimeType} on the current
-   * device, or {@code null} if the codec can't be used.
+   * Returns the codec's supported MIME type for media of type {@code mimeType}, or {@code null} if
+   * the codec can't be used.
    *
    * @param info The codec information.
    * @param name The name of the codec
    * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
-   * @return The codec's supported type for decoding {@code requestedMimeType}, or {@code null} if
-   *     the codec can't be used.
+   * @param mimeType The MIME type.
+   * @return The codec's supported MIME type for media of type {@code mimeType}, or {@code null} if
+   *     the codec can't be used. If non-null, the returned type will be equal to {@code mimeType}
+   *     except in cases where the codec is known to use a non-standard MIME type alias.
    */
   @Nullable
-  private static String getCodecSupportedType(
+  private static String getCodecMimeType(
       android.media.MediaCodecInfo info,
       String name,
       boolean secureDecodersExplicit,
-      String requestedMimeType) {
-    if (isCodecUsableDecoder(info, name, secureDecodersExplicit, requestedMimeType)) {
-      if (requestedMimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
-        // Handle decoders that declare support for DV via MIME types that aren't
-        // video/dolby-vision.
-        if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
-          return "video/hevcdv";
-        } else if ("OMX.RTK.video.decoder".equals(name)
-            || "OMX.realtek.video.decoder.tunneled".equals(name)) {
-          return "video/dv_hevc";
-        }
+      String mimeType) {
+    if (!isCodecUsableDecoder(info, name, secureDecodersExplicit, mimeType)) {
+      return null;
+    }
+
+    String[] supportedTypes = info.getSupportedTypes();
+    for (String supportedType : supportedTypes) {
+      if (supportedType.equalsIgnoreCase(mimeType)) {
+        return supportedType;
       }
+    }
 
-      String[] supportedTypes = info.getSupportedTypes();
-      for (String supportedType : supportedTypes) {
-        if (supportedType.equalsIgnoreCase(requestedMimeType)) {
-          return supportedType;
-        }
+    if (mimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
+      // Handle decoders that declare support for DV via MIME types that aren't
+      // video/dolby-vision.
+      if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
+        return "video/hevcdv";
+      } else if ("OMX.RTK.video.decoder".equals(name)
+          || "OMX.realtek.video.decoder.tunneled".equals(name)) {
+        return "video/dv_hevc";
       }
+    } else if (mimeType.equals(MimeTypes.AUDIO_ALAC) && "OMX.lge.alac.decoder".equals(name)) {
+      return "audio/x-lg-alac";
+    } else if (mimeType.equals(MimeTypes.AUDIO_FLAC) && "OMX.lge.flac.decoder".equals(name)) {
+      return "audio/x-lg-flac";
     }
+
     return null;
   }
 
@@ -373,12 +376,14 @@ private static String getCodecSupportedType(
    * @param info The codec information.
    * @param name The name of the codec
    * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
+   * @param mimeType The MIME type.
    * @return Whether the specified codec is usable for decoding on the current device.
    */
-  private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, String name,
-      boolean secureDecodersExplicit, String requestedMimeType) {
+  private static boolean isCodecUsableDecoder(
+      android.media.MediaCodecInfo info,
+      String name,
+      boolean secureDecodersExplicit,
+      String mimeType) {
     if (info.isEncoder() || (!secureDecodersExplicit && name.endsWith(".secure"))) {
       return false;
     }
@@ -386,11 +391,11 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     // Work around broken audio decoders.
     if (Util.SDK_INT < 21
         && ("CIPAACDecoder".equals(name)
-            || "CIPMP3Decoder".equals(name)
-            || "CIPVorbisDecoder".equals(name)
-            || "CIPAMRNBDecoder".equals(name)
-            || "AACDecoder".equals(name)
-            || "MP3Decoder".equals(name))) {
+        || "CIPMP3Decoder".equals(name)
+        || "CIPVorbisDecoder".equals(name)
+        || "CIPAMRNBDecoder".equals(name)
+        || "AACDecoder".equals(name)
+        || "MP3Decoder".equals(name))) {
       return false;
     }
 
@@ -399,7 +404,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     if (Util.SDK_INT < 18
         && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
         && ("a70".equals(Util.DEVICE)
-            || ("Xiaomi".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith("HM")))) {
+        || ("Xiaomi".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith("HM")))) {
       return false;
     }
 
@@ -408,17 +413,17 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     if (Util.SDK_INT == 16
         && "OMX.qcom.audio.decoder.mp3".equals(name)
         && ("dlxu".equals(Util.DEVICE) // HTC Butterfly
-            || "protou".equals(Util.DEVICE) // HTC Desire X
-            || "ville".equals(Util.DEVICE) // HTC One S
-            || "villeplus".equals(Util.DEVICE)
-            || "villec2".equals(Util.DEVICE)
-            || Util.DEVICE.startsWith("gee") // LGE Optimus G
-            || "C6602".equals(Util.DEVICE) // Sony Xperia Z
-            || "C6603".equals(Util.DEVICE)
-            || "C6606".equals(Util.DEVICE)
-            || "C6616".equals(Util.DEVICE)
-            || "L36h".equals(Util.DEVICE)
-            || "SO-02E".equals(Util.DEVICE))) {
+        || "protou".equals(Util.DEVICE) // HTC Desire X
+        || "ville".equals(Util.DEVICE) // HTC One S
+        || "villeplus".equals(Util.DEVICE)
+        || "villec2".equals(Util.DEVICE)
+        || Util.DEVICE.startsWith("gee") // LGE Optimus G
+        || "C6602".equals(Util.DEVICE) // Sony Xperia Z
+        || "C6603".equals(Util.DEVICE)
+        || "C6606".equals(Util.DEVICE)
+        || "C6616".equals(Util.DEVICE)
+        || "L36h".equals(Util.DEVICE)
+        || "SO-02E".equals(Util.DEVICE))) {
       return false;
     }
 
@@ -426,9 +431,9 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     if (Util.SDK_INT == 16
         && "OMX.qcom.audio.decoder.aac".equals(name)
         && ("C1504".equals(Util.DEVICE) // Sony Xperia E
-            || "C1505".equals(Util.DEVICE)
-            || "C1604".equals(Util.DEVICE) // Sony Xperia E dual
-            || "C1605".equals(Util.DEVICE))) {
+        || "C1505".equals(Util.DEVICE)
+        || "C1604".equals(Util.DEVICE) // Sony Xperia E dual
+        || "C1605".equals(Util.DEVICE))) {
       return false;
     }
 
@@ -437,13 +442,13 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
         && ("OMX.SEC.aac.dec".equals(name) || "OMX.Exynos.AAC.Decoder".equals(name))
         && "samsung".equals(Util.MANUFACTURER)
         && (Util.DEVICE.startsWith("zeroflte") // Galaxy S6
-            || Util.DEVICE.startsWith("zerolte") // Galaxy S6 Edge
-            || Util.DEVICE.startsWith("zenlte") // Galaxy S6 Edge+
-            || "SC-05G".equals(Util.DEVICE) // Galaxy S6
-            || "marinelteatt".equals(Util.DEVICE) // Galaxy S6 Active
-            || "404SC".equals(Util.DEVICE) // Galaxy S6 Edge
-            || "SC-04G".equals(Util.DEVICE)
-            || "SCV31".equals(Util.DEVICE))) {
+        || Util.DEVICE.startsWith("zerolte") // Galaxy S6 Edge
+        || Util.DEVICE.startsWith("zenlte") // Galaxy S6 Edge+
+        || "SC-05G".equals(Util.DEVICE) // Galaxy S6
+        || "marinelteatt".equals(Util.DEVICE) // Galaxy S6 Active
+        || "404SC".equals(Util.DEVICE) // Galaxy S6 Edge
+        || "SC-04G".equals(Util.DEVICE)
+        || "SCV31".equals(Util.DEVICE))) {
       return false;
     }
 
@@ -453,10 +458,10 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
         && "OMX.SEC.vp8.dec".equals(name)
         && "samsung".equals(Util.MANUFACTURER)
         && (Util.DEVICE.startsWith("d2")
-            || Util.DEVICE.startsWith("serrano")
-            || Util.DEVICE.startsWith("jflte")
-            || Util.DEVICE.startsWith("santos")
-            || Util.DEVICE.startsWith("t0"))) {
+        || Util.DEVICE.startsWith("serrano")
+        || Util.DEVICE.startsWith("jflte")
+        || Util.DEVICE.startsWith("santos")
+        || Util.DEVICE.startsWith("t0"))) {
       return false;
     }
 
@@ -467,7 +472,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     }
 
     // MTK E-AC3 decoder doesn't support decoding JOC streams in 2-D. See [Internal: b/69400041].
-    if (MimeTypes.AUDIO_E_AC3_JOC.equals(requestedMimeType)
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)
         && "OMX.MTK.AUDIO.DECODER.DSPAC3".equals(name)) {
       return false;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/Metadata.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/Metadata.java
index 75f43029ba..6e3c6c3ff2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/Metadata.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/Metadata.java
@@ -18,6 +18,7 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import androidx.annotation.Nullable;
+import com.google.android.exoplayer2VRT.Format;
 import com.google.android.exoplayer2VRT.util.Util;
 import java.util.Arrays;
 import java.util.List;
@@ -28,10 +29,27 @@
  */
 public final class Metadata implements Parcelable {
 
-  /**
-   * A metadata entry.
-   */
-  public interface Entry extends Parcelable {}
+  /** A metadata entry. */
+  public interface Entry extends Parcelable {
+
+    /**
+     * Returns the {@link Format} that can be used to decode the wrapped metadata in {@link
+     * #getWrappedMetadataBytes()}, or null if this Entry doesn't contain wrapped metadata.
+     */
+    @Nullable
+    default Format getWrappedMetadataFormat() {
+      return null;
+    }
+
+    /**
+     * Returns the bytes of the wrapped metadata in this Entry, or null if it doesn't contain
+     * wrapped metadata.
+     */
+    @Nullable
+    default byte[] getWrappedMetadataBytes() {
+      return null;
+    }
+  }
 
   private final Entry[] entries;
 
@@ -122,6 +140,11 @@ public int hashCode() {
     return Arrays.hashCode(entries);
   }
 
+  @Override
+  public String toString() {
+    return "entries=" + Arrays.toString(entries);
+  }
+
   // Parcelable implementation.
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/MetadataRenderer.java
index 3163f510a4..7fe44d70ee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/MetadataRenderer.java
@@ -27,7 +27,9 @@
 import com.google.android.exoplayer2VRT.FormatHolder;
 import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.Util;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 
 /**
  * A renderer for metadata.
@@ -58,6 +60,7 @@
   private int pendingMetadataCount;
   private MetadataDecoder decoder;
   private boolean inputStreamEnded;
+  private long subsampleOffsetUs;
 
   /**
    * @param output The output.
@@ -126,16 +129,24 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
           // If we ever need to support a metadata format where this is not the case, we'll need to
           // pass the buffer to the decoder and discard the output.
         } else {
-          buffer.subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
+          buffer.subsampleOffsetUs = subsampleOffsetUs;
           buffer.flip();
-          int index = (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
           Metadata metadata = decoder.decode(buffer);
           if (metadata != null) {
-            pendingMetadata[index] = metadata;
-            pendingMetadataTimestamps[index] = buffer.timeUs;
-            pendingMetadataCount++;
+            List<Metadata.Entry> entries = new ArrayList<>(metadata.length());
+            decodeWrappedMetadata(metadata, entries);
+            if (!entries.isEmpty()) {
+              Metadata expandedMetadata = new Metadata(entries);
+              int index =
+                  (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
+              pendingMetadata[index] = expandedMetadata;
+              pendingMetadataTimestamps[index] = buffer.timeUs;
+              pendingMetadataCount++;
+            }
           }
         }
+      } else if (result == C.RESULT_FORMAT_READ) {
+        subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
       }
     }
 
@@ -147,6 +158,36 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
   }
 
+  /**
+   * Iterates through {@code metadata.entries} and checks each one to see if contains wrapped
+   * metadata. If it does, then we recursively decode the wrapped metadata. If it doesn't (recursion
+   * base-case), we add the {@link Metadata.Entry} to {@code decodedEntries} (output parameter).
+   */
+  private void decodeWrappedMetadata(Metadata metadata, List<Metadata.Entry> decodedEntries) {
+    for (int i = 0; i < metadata.length(); i++) {
+      Format wrappedMetadataFormat = metadata.get(i).getWrappedMetadataFormat();
+      if (wrappedMetadataFormat != null && decoderFactory.supportsFormat(wrappedMetadataFormat)) {
+        MetadataDecoder wrappedMetadataDecoder =
+            decoderFactory.createDecoder(wrappedMetadataFormat);
+        // wrappedMetadataFormat != null so wrappedMetadataBytes must be non-null too.
+        byte[] wrappedMetadataBytes =
+            Assertions.checkNotNull(metadata.get(i).getWrappedMetadataBytes());
+        buffer.clear();
+        buffer.ensureSpaceForWrite(wrappedMetadataBytes.length);
+        buffer.data.put(wrappedMetadataBytes);
+        buffer.flip();
+        @Nullable Metadata innerMetadata = wrappedMetadataDecoder.decode(buffer);
+        if (innerMetadata != null) {
+          // The decoding succeeded, so we'll try another level of unwrapping.
+          decodeWrappedMetadata(innerMetadata, decodedEntries);
+        }
+      } else {
+        // Entry doesn't contain any wrapped metadata, so output it directly.
+        decodedEntries.add(metadata.get(i));
+      }
+    }
+  }
+
   @Override
   protected void onDisabled() {
     flushPendingMetadata();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessage.java
index 6c7f262704..39a439231a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessage.java
@@ -20,18 +20,43 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2VRT.Format;
 import com.google.android.exoplayer2VRT.metadata.Metadata;
+import com.google.android.exoplayer2VRT.util.MimeTypes;
 import com.google.android.exoplayer2VRT.util.Util;
 import java.util.Arrays;
 
-/**
- * An Event Message (emsg) as defined in ISO 23009-1.
- */
+/** An Event Message (emsg) as defined in ISO 23009-1. */
 public final class EventMessage implements Metadata.Entry {
 
   /**
-   * The message scheme.
+   * emsg scheme_id_uri from the <a href="https://aomediacodec.github.io/av1-id3/#semantics">CMAF
+   * spec</a>.
+   */
+  @VisibleForTesting public static final String ID3_SCHEME_ID_AOM = "https://aomedia.org/emsg/ID3";
+
+  /**
+   * The Apple-hosted scheme_id equivalent to {@code ID3_SCHEME_ID_AOM} - used before AOM adoption.
    */
+  private static final String ID3_SCHEME_ID_APPLE =
+      "https://developer.apple.com/streaming/emsg-id3";
+
+  /**
+   * scheme_id_uri from section 7.3.2 of <a
+   * href="https://www.scte.org/SCTEDocs/Standards/ANSI_SCTE%20214-3%202015.pdf">SCTE 214-3
+   * 2015</a>.
+   */
+  @VisibleForTesting public static final String SCTE35_SCHEME_ID = "urn:scte:scte35:2014:bin";
+
+  private static final Format ID3_FORMAT =
+      Format.createSampleFormat(
+          /* id= */ null, MimeTypes.APPLICATION_ID3, Format.OFFSET_SAMPLE_RELATIVE);
+  private static final Format SCTE35_FORMAT =
+      Format.createSampleFormat(
+          /* id= */ null, MimeTypes.APPLICATION_SCTE35, Format.OFFSET_SAMPLE_RELATIVE);
+
+  /** The message scheme. */
   public final String schemeIdUri;
 
   /**
@@ -81,6 +106,26 @@ public EventMessage(
     messageData = castNonNull(in.createByteArray());
   }
 
+  @Override
+  @Nullable
+  public Format getWrappedMetadataFormat() {
+    switch (schemeIdUri) {
+      case ID3_SCHEME_ID_AOM:
+      case ID3_SCHEME_ID_APPLE:
+        return ID3_FORMAT;
+      case SCTE35_SCHEME_ID:
+        return SCTE35_FORMAT;
+      default:
+        return null;
+    }
+  }
+
+  @Override
+  @Nullable
+  public byte[] getWrappedMetadataBytes() {
+    return getWrappedMetadataFormat() != null ? messageData : null;
+  }
+
   @Override
   public int hashCode() {
     if (hashCode == 0) {
@@ -113,7 +158,14 @@ public boolean equals(@Nullable Object obj) {
 
   @Override
   public String toString() {
-    return "EMSG: scheme=" + schemeIdUri + ", id=" + id + ", value=" + value;
+    return "EMSG: scheme="
+        + schemeIdUri
+        + ", id="
+        + id
+        + ", durationMs="
+        + durationMs
+        + ", value="
+        + value;
   }
 
   // Parcelable implementation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoder.java
index c7c460fc77..cf2df78963 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoder.java
@@ -15,47 +15,45 @@
  */
 package com.google.android.exoplayer2VRT.metadata.emsg;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.metadata.Metadata;
 import com.google.android.exoplayer2VRT.metadata.MetadataDecoder;
 import com.google.android.exoplayer2VRT.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2VRT.util.Assertions;
-import com.google.android.exoplayer2VRT.util.Log;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
-import com.google.android.exoplayer2VRT.util.Util;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
-/**
- * Decodes Event Message (emsg) atoms, as defined in ISO/IEC 23009-1:2014, Section 5.10.3.3.
- *
- * <p>Atom data should be provided to the decoder without the full atom header (i.e. starting from
- * the first byte of the scheme_id_uri field). It is expected that the presentation_time_delta field
- * should be 0, having already been accounted for by adjusting the sample timestamp.
- */
+/** Decodes data encoded by {@link EventMessageEncoder}. */
 public final class EventMessageDecoder implements MetadataDecoder {
 
-  private static final String TAG = "EventMessageDecoder";
-
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
+  @Nullable
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = inputBuffer.data;
     byte[] data = buffer.array();
     int size = buffer.limit();
-    ParsableByteArray emsgData = new ParsableByteArray(data, size);
-    String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-    String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-    long timescale = emsgData.readUnsignedInt();
-    long presentationTimeDelta = emsgData.readUnsignedInt();
-    if (presentationTimeDelta != 0) {
-      // We expect the source to have accounted for presentation_time_delta by adjusting the sample
-      // timestamp and zeroing the field in the sample data. Log a warning if the field is non-zero.
-      Log.w(TAG, "Ignoring non-zero presentation_time_delta: " + presentationTimeDelta);
+    EventMessage decodedEventMessage = decode(new ParsableByteArray(data, size));
+    if (decodedEventMessage == null) {
+      return null;
+    } else {
+      return new Metadata(decodedEventMessage);
     }
-    long durationMs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(), 1000, timescale);
-    long id = emsgData.readUnsignedInt();
-    byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
-    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
   }
 
+  @Nullable
+  public EventMessage decode(ParsableByteArray emsgData) {
+    try {
+      String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+      String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+      long durationMs = emsgData.readUnsignedInt();
+      long id = emsgData.readUnsignedInt();
+      byte[] messageData =
+          Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
+      return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
+    } catch (RuntimeException e) {
+      return null;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoder.java
index 5176b40295..107428827d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoder.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2VRT.metadata.emsg;
 
-import androidx.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -40,15 +39,12 @@ public EventMessageEncoder() {
    * @param eventMessage The event message to be encoded.
    * @return The serialized byte array.
    */
-  @Nullable
   public byte[] encode(EventMessage eventMessage) {
     byteArrayOutputStream.reset();
     try {
       writeNullTerminatedString(dataOutputStream, eventMessage.schemeIdUri);
       String nonNullValue = eventMessage.value != null ? eventMessage.value : "";
       writeNullTerminatedString(dataOutputStream, nonNullValue);
-      writeUnsignedInt(dataOutputStream, 1000); // timescale
-      writeUnsignedInt(dataOutputStream, 0); // presentation_time_delta
       writeUnsignedInt(dataOutputStream, eventMessage.durationMs);
       writeUnsignedInt(dataOutputStream, eventMessage.id);
       dataOutputStream.write(eventMessage.messageData);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/flac/PictureFrame.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/flac/PictureFrame.java
new file mode 100644
index 0000000000..e0dd002928
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/flac/PictureFrame.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.metadata.flac;
+
+import static com.google.android.exoplayer2VRT.util.Util.castNonNull;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2VRT.metadata.Metadata;
+import java.util.Arrays;
+
+/** A picture parsed from a FLAC file. */
+public final class PictureFrame implements Metadata.Entry {
+
+  /** The type of the picture. */
+  public final int pictureType;
+  /** The mime type of the picture. */
+  public final String mimeType;
+  /** A description of the picture. */
+  public final String description;
+  /** The width of the picture in pixels. */
+  public final int width;
+  /** The height of the picture in pixels. */
+  public final int height;
+  /** The color depth of the picture in bits-per-pixel. */
+  public final int depth;
+  /** For indexed-color pictures (e.g. GIF), the number of colors used. 0 otherwise. */
+  public final int colors;
+  /** The encoded picture data. */
+  public final byte[] pictureData;
+
+  public PictureFrame(
+      int pictureType,
+      String mimeType,
+      String description,
+      int width,
+      int height,
+      int depth,
+      int colors,
+      byte[] pictureData) {
+    this.pictureType = pictureType;
+    this.mimeType = mimeType;
+    this.description = description;
+    this.width = width;
+    this.height = height;
+    this.depth = depth;
+    this.colors = colors;
+    this.pictureData = pictureData;
+  }
+
+  /* package */ PictureFrame(Parcel in) {
+    this.pictureType = in.readInt();
+    this.mimeType = castNonNull(in.readString());
+    this.description = castNonNull(in.readString());
+    this.width = in.readInt();
+    this.height = in.readInt();
+    this.depth = in.readInt();
+    this.colors = in.readInt();
+    this.pictureData = castNonNull(in.createByteArray());
+  }
+
+  @Override
+  public String toString() {
+    return "Picture: mimeType=" + mimeType + ", description=" + description;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    PictureFrame other = (PictureFrame) obj;
+    return (pictureType == other.pictureType)
+        && mimeType.equals(other.mimeType)
+        && description.equals(other.description)
+        && (width == other.width)
+        && (height == other.height)
+        && (depth == other.depth)
+        && (colors == other.colors)
+        && Arrays.equals(pictureData, other.pictureData);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + pictureType;
+    result = 31 * result + mimeType.hashCode();
+    result = 31 * result + description.hashCode();
+    result = 31 * result + width;
+    result = 31 * result + height;
+    result = 31 * result + depth;
+    result = 31 * result + colors;
+    result = 31 * result + Arrays.hashCode(pictureData);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(pictureType);
+    dest.writeString(mimeType);
+    dest.writeString(description);
+    dest.writeInt(width);
+    dest.writeInt(height);
+    dest.writeInt(depth);
+    dest.writeInt(colors);
+    dest.writeByteArray(pictureData);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<PictureFrame> CREATOR =
+      new Parcelable.Creator<PictureFrame>() {
+
+        @Override
+        public PictureFrame createFromParcel(Parcel in) {
+          return new PictureFrame(in);
+        }
+
+        @Override
+        public PictureFrame[] newArray(int size) {
+          return new PictureFrame[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/flac/VorbisComment.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/flac/VorbisComment.java
new file mode 100644
index 0000000000..81142cd812
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/flac/VorbisComment.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.metadata.flac;
+
+import static com.google.android.exoplayer2VRT.util.Util.castNonNull;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2VRT.metadata.Metadata;
+
+/** A vorbis comment. */
+public final class VorbisComment implements Metadata.Entry {
+
+  /** The key. */
+  public final String key;
+
+  /** The value. */
+  public final String value;
+
+  /**
+   * @param key The key.
+   * @param value The value.
+   */
+  public VorbisComment(String key, String value) {
+    this.key = key;
+    this.value = value;
+  }
+
+  /* package */ VorbisComment(Parcel in) {
+    this.key = castNonNull(in.readString());
+    this.value = castNonNull(in.readString());
+  }
+
+  @Override
+  public String toString() {
+    return "VC: " + key + "=" + value;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    VorbisComment other = (VorbisComment) obj;
+    return key.equals(other.key) && value.equals(other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(key);
+    dest.writeString(value);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<VorbisComment> CREATOR =
+      new Parcelable.Creator<VorbisComment>() {
+
+        @Override
+        public VorbisComment createFromParcel(Parcel in) {
+          return new VorbisComment(in);
+        }
+
+        @Override
+        public VorbisComment[] newArray(int size) {
+          return new VorbisComment[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/id3/TextInformationFrame.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/id3/TextInformationFrame.java
index 54484d55f8..63782f9d16 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/id3/TextInformationFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/metadata/id3/TextInformationFrame.java
@@ -66,7 +66,7 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return id + ": value=" + value;
+    return id + ": description=" + description + ": value=" + value;
   }
 
   // Parcelable implementation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadHelper.java
index 09fceac8d0..d85e67774e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadHelper.java
@@ -817,10 +817,10 @@ private MediaSource createMediaSource(
     private final MediaSource mediaSource;
     private final DownloadHelper downloadHelper;
     private final Allocator allocator;
+    private final ArrayList<MediaPeriod> pendingMediaPeriods;
+    private final Handler downloadHelperHandler;
     private final HandlerThread mediaSourceThread;
     private final Handler mediaSourceHandler;
-    private final Handler downloadHelperHandler;
-    private final ArrayList<MediaPeriod> pendingMediaPeriods;
 
     @Nullable public Object manifest;
     public @MonotonicNonNull Timeline timeline;
@@ -832,6 +832,7 @@ public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
       this.mediaSource = mediaSource;
       this.downloadHelper = downloadHelper;
       allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
+      pendingMediaPeriods = new ArrayList<>();
       @SuppressWarnings("methodref.receiver.bound.invalid")
       Handler downloadThreadHandler = Util.createHandler(this::handleDownloadHelperCallbackMessage);
       this.downloadHelperHandler = downloadThreadHandler;
@@ -839,7 +840,6 @@ public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
       mediaSourceThread.start();
       mediaSourceHandler = Util.createHandler(mediaSourceThread.getLooper(), /* callback= */ this);
       mediaSourceHandler.sendEmptyMessage(MESSAGE_PREPARE_SOURCE);
-      pendingMediaPeriods = new ArrayList<>();
     }
 
     public void release() {
@@ -951,6 +951,7 @@ private boolean handleDownloadHelperCallbackMessage(Message msg) {
           downloadHelper.onMediaPrepared();
           return true;
         case DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED:
+          release();
           downloadHelper.onMediaPreparationFailed((IOException) Util.castNonNull(msg.obj));
           return true;
         default:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadService.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadService.java
index 786cefbae5..2c248819f2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadService.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/offline/DownloadService.java
@@ -174,6 +174,7 @@
   @Nullable private final ForegroundNotificationUpdater foregroundNotificationUpdater;
   @Nullable private final String channelId;
   @StringRes private final int channelNameResourceId;
+  @StringRes private final int channelDescriptionResourceId;
 
   private DownloadManager downloadManager;
   private int lastStartId;
@@ -214,7 +215,23 @@ protected DownloadService(
         foregroundNotificationId,
         foregroundNotificationUpdateInterval,
         /* channelId= */ null,
-        /* channelNameResourceId= */ 0);
+        /* channelNameResourceId= */ 0,
+        /* channelDescriptionResourceId= */ 0);
+  }
+
+  /** @deprecated Use {@link #DownloadService(int, long, String, int, int)}. */
+  @Deprecated
+  protected DownloadService(
+      int foregroundNotificationId,
+      long foregroundNotificationUpdateInterval,
+      @Nullable String channelId,
+      @StringRes int channelNameResourceId) {
+    this(
+        foregroundNotificationId,
+        foregroundNotificationUpdateInterval,
+        channelId,
+        channelNameResourceId,
+        /* channelDescriptionResourceId= */ 0);
   }
 
   /**
@@ -230,25 +247,33 @@ protected DownloadService(
    *     unique per package. The value may be truncated if it's too long. Ignored if {@code
    *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
    * @param channelNameResourceId A string resource identifier for the user visible name of the
-   *     channel, if {@code channelId} is specified. The recommended maximum length is 40
-   *     characters. The value may be truncated if it is too long. Ignored if {@code
+   *     notification channel. The recommended maximum length is 40 characters. The value may be
+   *     truncated if it's too long. Ignored if {@code channelId} is null or if {@code
    *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
+   * @param channelDescriptionResourceId A string resource identifier for the user visible
+   *     description of the notification channel, or 0 if no description is provided. The
+   *     recommended maximum length is 300 characters. The value may be truncated if it is too long.
+   *     Ignored if {@code channelId} is null or if {@code foregroundNotificationId} is {@link
+   *     #FOREGROUND_NOTIFICATION_ID_NONE}.
    */
   protected DownloadService(
       int foregroundNotificationId,
       long foregroundNotificationUpdateInterval,
       @Nullable String channelId,
-      @StringRes int channelNameResourceId) {
+      @StringRes int channelNameResourceId,
+      @StringRes int channelDescriptionResourceId) {
     if (foregroundNotificationId == FOREGROUND_NOTIFICATION_ID_NONE) {
       this.foregroundNotificationUpdater = null;
       this.channelId = null;
       this.channelNameResourceId = 0;
+      this.channelDescriptionResourceId = 0;
     } else {
       this.foregroundNotificationUpdater =
           new ForegroundNotificationUpdater(
               foregroundNotificationId, foregroundNotificationUpdateInterval);
       this.channelId = channelId;
       this.channelNameResourceId = channelNameResourceId;
+      this.channelDescriptionResourceId = channelDescriptionResourceId;
     }
   }
 
@@ -543,7 +568,11 @@ public static void startForeground(Context context, Class<? extends DownloadServ
   public void onCreate() {
     if (channelId != null) {
       NotificationUtil.createNotificationChannel(
-          this, channelId, channelNameResourceId, NotificationUtil.IMPORTANCE_LOW);
+          this,
+          channelId,
+          channelNameResourceId,
+          channelDescriptionResourceId,
+          NotificationUtil.IMPORTANCE_LOW);
     }
     Class<? extends DownloadService> clazz = getClass();
     DownloadManagerHelper downloadManagerHelper = downloadManagerListeners.get(clazz);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/PlatformScheduler.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/PlatformScheduler.java
index 19ec36b3a2..c340eb5825 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/PlatformScheduler.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/PlatformScheduler.java
@@ -25,6 +25,7 @@
 import android.content.Intent;
 import android.os.PersistableBundle;
 import androidx.annotation.RequiresPermission;
+import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.Log;
 import com.google.android.exoplayer2VRT.util.Util;
 
@@ -129,9 +130,8 @@ public boolean onStartJob(JobParameters params) {
         logd("Requirements are met");
         String serviceAction = extras.getString(KEY_SERVICE_ACTION);
         String servicePackage = extras.getString(KEY_SERVICE_PACKAGE);
-        // FIXME: incompatible types in argument.
-        @SuppressWarnings("nullness:argument.type.incompatible")
-        Intent intent = new Intent(serviceAction).setPackage(servicePackage);
+        Intent intent =
+            new Intent(Assertions.checkNotNull(serviceAction)).setPackage(servicePackage);
         logd("Starting service action: " + serviceAction + " package: " + servicePackage);
         Util.startForegroundService(this, intent);
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/Requirements.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/Requirements.java
index 00903a695e..bda5ebdf0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/Requirements.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/Requirements.java
@@ -27,6 +27,7 @@
 import android.os.Parcelable;
 import android.os.PowerManager;
 import androidx.annotation.IntDef;
+import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.Util;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -128,7 +129,7 @@ private int getNotMetNetworkRequirements(Context context) {
 
     ConnectivityManager connectivityManager =
         (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+    NetworkInfo networkInfo = Assertions.checkNotNull(connectivityManager).getActiveNetworkInfo();
     if (networkInfo == null
         || !networkInfo.isConnected()
         || !isInternetConnectivityValidated(connectivityManager)) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/RequirementsWatcher.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/RequirementsWatcher.java
index 327b99bc70..56c4b0c221 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/RequirementsWatcher.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/scheduler/RequirementsWatcher.java
@@ -28,6 +28,7 @@
 import android.os.Looper;
 import android.os.PowerManager;
 import androidx.annotation.RequiresApi;
+import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.Util;
 
 /**
@@ -126,7 +127,8 @@ public Requirements getRequirements() {
   @TargetApi(23)
   private void registerNetworkCallbackV23() {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        Assertions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
     NetworkRequest request =
         new NetworkRequest.Builder()
             .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/MediaPeriod.java
index 20635b2d37..b3a884aab6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/MediaPeriod.java
@@ -106,13 +106,16 @@
    * Performs a track selection.
    *
    * <p>The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
-   * indicating whether the existing {@code SampleStream} can be retained for each selection, and
+   * indicating whether the existing {@link SampleStream} can be retained for each selection, and
    * the existing {@code stream}s themselves. The call will update {@code streams} to reflect the
    * provided selections, clearing, setting and replacing entries as required. If an existing sample
    * stream is retained but with the requirement that the consuming renderer be reset, then the
    * corresponding flag in {@code streamResetFlags} will be set to true. This flag will also be set
    * if a new sample stream is created.
    *
+   * <p>Note that previously received {@link TrackSelection TrackSelections} are no longer valid and
+   * references need to be replaced even if the corresponding {@link SampleStream} is kept.
+   *
    * <p>This method is only called after the period has been prepared.
    *
    * @param selections The renderer track selections.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/ProgressiveMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/ProgressiveMediaPeriod.java
index e42f7183ba..d104e3589c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/ProgressiveMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/ProgressiveMediaPeriod.java
@@ -325,7 +325,10 @@ public void reevaluateBuffer(long positionUs) {
 
   @Override
   public boolean continueLoading(long playbackPositionUs) {
-    if (loadingFinished || pendingDeferredRetry || (prepared && enabledTrackCount == 0)) {
+    if (loadingFinished
+        || loader.hasFatalError()
+        || pendingDeferredRetry
+        || (prepared && enabledTrackCount == 0)) {
       return false;
     }
     boolean continuedLoading = loadCondition.open();
@@ -410,6 +413,7 @@ public long seekToUs(long positionUs) {
     if (loader.isLoading()) {
       loader.cancelLoading();
     } else {
+      loader.clearFatalError();
       for (SampleQueue sampleQueue : sampleQueues) {
         sampleQueue.reset();
       }
@@ -733,7 +737,7 @@ private void startLoading() {
     if (prepared) {
       SeekMap seekMap = getPreparedState().seekMap;
       Assertions.checkState(isPendingReset());
-      if (durationUs != C.TIME_UNSET && pendingResetPositionUs >= durationUs) {
+      if (durationUs != C.TIME_UNSET && pendingResetPositionUs > durationUs) {
         loadingFinished = true;
         pendingResetPositionUs = C.TIME_UNSET;
         return;
@@ -1042,21 +1046,28 @@ public Extractor selectExtractor(ExtractorInput input, ExtractorOutput output, U
       if (extractor != null) {
         return extractor;
       }
-      for (Extractor extractor : extractors) {
-        try {
-          if (extractor.sniff(input)) {
-            this.extractor = extractor;
-            break;
+      if (extractors.length == 1) {
+        this.extractor = extractors[0];
+      } else {
+        for (Extractor extractor : extractors) {
+          try {
+            if (extractor.sniff(input)) {
+              this.extractor = extractor;
+              break;
+            }
+          } catch (EOFException e) {
+            // Do nothing.
+          } finally {
+            input.resetPeekPosition();
           }
-        } catch (EOFException e) {
-          // Do nothing.
-        } finally {
-          input.resetPeekPosition();
         }
-      }
-      if (extractor == null) {
-        throw new UnrecognizedInputFormatException("None of the available extractors ("
-            + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.", uri);
+        if (extractor == null) {
+          throw new UnrecognizedInputFormatException(
+              "None of the available extractors ("
+                  + Util.getCommaDelimitedSimpleClassNames(extractors)
+                  + ") could read the stream.",
+              uri);
+        }
       }
       extractor.init(output);
       return extractor;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SilenceMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SilenceMediaSource.java
new file mode 100644
index 0000000000..ee10ca31a2
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SilenceMediaSource.java
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.source;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2VRT.C;
+import com.google.android.exoplayer2VRT.Format;
+import com.google.android.exoplayer2VRT.FormatHolder;
+import com.google.android.exoplayer2VRT.SeekParameters;
+import com.google.android.exoplayer2VRT.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2VRT.trackselection.TrackSelection;
+import com.google.android.exoplayer2VRT.upstream.Allocator;
+import com.google.android.exoplayer2VRT.upstream.TransferListener;
+import com.google.android.exoplayer2VRT.util.Assertions;
+import com.google.android.exoplayer2VRT.util.MimeTypes;
+import com.google.android.exoplayer2VRT.util.Util;
+import java.util.ArrayList;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+
+/** Media source with a single period consisting of silent raw audio of a given duration. */
+public final class SilenceMediaSource extends BaseMediaSource {
+
+  private static final int SAMPLE_RATE_HZ = 44100;
+  @C.PcmEncoding private static final int ENCODING = C.ENCODING_PCM_16BIT;
+  private static final int CHANNEL_COUNT = 2;
+  private static final Format FORMAT =
+      Format.createAudioSampleFormat(
+          /* id=*/ null,
+          MimeTypes.AUDIO_RAW,
+          /* codecs= */ null,
+          /* bitrate= */ Format.NO_VALUE,
+          /* maxInputSize= */ Format.NO_VALUE,
+          CHANNEL_COUNT,
+          SAMPLE_RATE_HZ,
+          ENCODING,
+          /* initializationData= */ null,
+          /* drmInitData= */ null,
+          /* selectionFlags= */ 0,
+          /* language= */ null);
+  private static final byte[] SILENCE_SAMPLE =
+      new byte[Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT) * 1024];
+
+  private final long durationUs;
+
+  /**
+   * Creates a new media source providing silent audio of the given duration.
+   *
+   * @param durationUs The duration of silent audio to output, in microseconds.
+   */
+  public SilenceMediaSource(long durationUs) {
+    Assertions.checkArgument(durationUs >= 0);
+    this.durationUs = durationUs;
+  }
+
+  @Override
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    refreshSourceInfo(
+        new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false),
+        /* manifest= */ null);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() {}
+
+  @Override
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+    return new SilenceMediaPeriod(durationUs);
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {}
+
+  @Override
+  public void releaseSourceInternal() {}
+
+  private static final class SilenceMediaPeriod implements MediaPeriod {
+
+    private static final TrackGroupArray TRACKS = new TrackGroupArray(new TrackGroup(FORMAT));
+
+    private final long durationUs;
+    private final ArrayList<SampleStream> sampleStreams;
+
+    public SilenceMediaPeriod(long durationUs) {
+      this.durationUs = durationUs;
+      sampleStreams = new ArrayList<>();
+    }
+
+    @Override
+    public void prepare(Callback callback, long positionUs) {
+      callback.onPrepared(/* mediaPeriod= */ this);
+    }
+
+    @Override
+    public void maybeThrowPrepareError() {}
+
+    @Override
+    public TrackGroupArray getTrackGroups() {
+      return TRACKS;
+    }
+
+    @Override
+    public long selectTracks(
+        @NullableType TrackSelection[] selections,
+        boolean[] mayRetainStreamFlags,
+        @NullableType SampleStream[] streams,
+        boolean[] streamResetFlags,
+        long positionUs) {
+      positionUs = constrainSeekPosition(positionUs);
+      for (int i = 0; i < selections.length; i++) {
+        if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+          sampleStreams.remove(streams[i]);
+          streams[i] = null;
+        }
+        if (streams[i] == null && selections[i] != null) {
+          SilenceSampleStream stream = new SilenceSampleStream(durationUs);
+          stream.seekTo(positionUs);
+          sampleStreams.add(stream);
+          streams[i] = stream;
+          streamResetFlags[i] = true;
+        }
+      }
+      return positionUs;
+    }
+
+    @Override
+    public void discardBuffer(long positionUs, boolean toKeyframe) {}
+
+    @Override
+    public long readDiscontinuity() {
+      return C.TIME_UNSET;
+    }
+
+    @Override
+    public long seekToUs(long positionUs) {
+      positionUs = constrainSeekPosition(positionUs);
+      for (int i = 0; i < sampleStreams.size(); i++) {
+        ((SilenceSampleStream) sampleStreams.get(i)).seekTo(positionUs);
+      }
+      return positionUs;
+    }
+
+    @Override
+    public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+      return constrainSeekPosition(positionUs);
+    }
+
+    @Override
+    public long getBufferedPositionUs() {
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public long getNextLoadPositionUs() {
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public boolean continueLoading(long positionUs) {
+      return false;
+    }
+
+    @Override
+    public void reevaluateBuffer(long positionUs) {}
+
+    private long constrainSeekPosition(long positionUs) {
+      return Util.constrainValue(positionUs, 0, durationUs);
+    }
+  }
+
+  private static final class SilenceSampleStream implements SampleStream {
+
+    private final long durationBytes;
+
+    private boolean sentFormat;
+    private long positionBytes;
+
+    public SilenceSampleStream(long durationUs) {
+      durationBytes = getAudioByteCount(durationUs);
+      seekTo(0);
+    }
+
+    public void seekTo(long positionUs) {
+      positionBytes = Util.constrainValue(getAudioByteCount(positionUs), 0, durationBytes);
+    }
+
+    @Override
+    public boolean isReady() {
+      return true;
+    }
+
+    @Override
+    public void maybeThrowError() {}
+
+    @Override
+    public int readData(
+        FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {
+      if (!sentFormat || formatRequired) {
+        formatHolder.format = FORMAT;
+        sentFormat = true;
+        return C.RESULT_FORMAT_READ;
+      }
+
+      long bytesRemaining = durationBytes - positionBytes;
+      if (bytesRemaining == 0) {
+        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+
+      int bytesToWrite = (int) Math.min(SILENCE_SAMPLE.length, bytesRemaining);
+      buffer.ensureSpaceForWrite(bytesToWrite);
+      buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
+      buffer.data.put(SILENCE_SAMPLE, /* offset= */ 0, bytesToWrite);
+      buffer.timeUs = getAudioPositionUs(positionBytes);
+      positionBytes += bytesToWrite;
+      return C.RESULT_BUFFER_READ;
+    }
+
+    @Override
+    public int skipData(long positionUs) {
+      long oldPositionBytes = positionBytes;
+      seekTo(positionUs);
+      return (int) ((positionBytes - oldPositionBytes) / SILENCE_SAMPLE.length);
+    }
+  }
+
+  private static long getAudioByteCount(long durationUs) {
+    long audioSampleCount = durationUs * SAMPLE_RATE_HZ / C.MICROS_PER_SECOND;
+    return Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT) * audioSampleCount;
+  }
+
+  private static long getAudioPositionUs(long bytes) {
+    long audioSampleCount = bytes / Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT);
+    return audioSampleCount * C.MICROS_PER_SECOND / SAMPLE_RATE_HZ;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SingleSampleMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SingleSampleMediaPeriod.java
index 3045fbb9fb..681bedb968 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SingleSampleMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/SingleSampleMediaPeriod.java
@@ -141,7 +141,7 @@ public void reevaluateBuffer(long positionUs) {
 
   @Override
   public boolean continueLoading(long positionUs) {
-    if (loadingFinished || loader.isLoading()) {
+    if (loadingFinished || loader.isLoading() || loader.hasFatalError()) {
       return false;
     }
     DataSource dataSource = dataSourceFactory.createDataSource();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/chunk/ChunkSampleStream.java
index 09162e1051..c746f7398a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/source/chunk/ChunkSampleStream.java
@@ -338,6 +338,7 @@ public void seekToUs(long positionUs) {
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
+        loader.clearFatalError();
         primarySampleQueue.reset();
         for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
           embeddedSampleQueue.reset();
@@ -549,7 +550,7 @@ public LoadErrorAction onLoadError(
 
   @Override
   public boolean continueLoading(long positionUs) {
-    if (loadingFinished || loader.isLoading()) {
+    if (loadingFinished || loader.isLoading() || loader.hasFatalError()) {
       return false;
     }
 
@@ -616,7 +617,7 @@ public long getNextLoadPositionUs() {
 
   @Override
   public void reevaluateBuffer(long positionUs) {
-    if (loader.isLoading() || isPendingReset()) {
+    if (loader.isLoading() || loader.hasFatalError() || isPendingReset()) {
       return;
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/Cue.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/Cue.java
index 8ca08df025..07bb9aed45 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/Cue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/Cue.java
@@ -28,9 +28,10 @@
  */
 public class Cue {
 
-  /**
-   * An unset position or width.
-   */
+  /** The empty cue. */
+  public static final Cue EMPTY = new Cue("");
+
+  /** An unset position or width. */
   public static final float DIMEN_UNSET = Float.MIN_VALUE;
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SimpleSubtitleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SimpleSubtitleDecoder.java
index 07f2cbb093..4b09fb9244 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SimpleSubtitleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SimpleSubtitleDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2VRT.text;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.decoder.SimpleDecoder;
 import java.nio.ByteBuffer;
@@ -69,6 +70,7 @@ protected final void releaseOutputBuffer(SubtitleOutputBuffer buffer) {
 
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
+  @Nullable
   protected final SubtitleDecoderException decode(
       SubtitleInputBuffer inputBuffer, SubtitleOutputBuffer outputBuffer, boolean reset) {
     try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SubtitleOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SubtitleOutputBuffer.java
index 825a2ed542..d24bd1e258 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SubtitleOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/SubtitleOutputBuffer.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2VRT.Format;
 import com.google.android.exoplayer2VRT.decoder.OutputBuffer;
+import com.google.android.exoplayer2VRT.util.Assertions;
 import java.util.List;
 
 /**
@@ -45,22 +46,22 @@ public void setContent(long timeUs, Subtitle subtitle, long subsampleOffsetUs) {
 
   @Override
   public int getEventTimeCount() {
-    return subtitle.getEventTimeCount();
+    return Assertions.checkNotNull(subtitle).getEventTimeCount();
   }
 
   @Override
   public long getEventTime(int index) {
-    return subtitle.getEventTime(index) + subsampleOffsetUs;
+    return Assertions.checkNotNull(subtitle).getEventTime(index) + subsampleOffsetUs;
   }
 
   @Override
   public int getNextEventTimeIndex(long timeUs) {
-    return subtitle.getNextEventTimeIndex(timeUs - subsampleOffsetUs);
+    return Assertions.checkNotNull(subtitle).getNextEventTimeIndex(timeUs - subsampleOffsetUs);
   }
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return subtitle.getCues(timeUs - subsampleOffsetUs);
+    return Assertions.checkNotNull(subtitle).getCues(timeUs - subsampleOffsetUs);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/cea/Cea608Decoder.java
index 6ea12f8046..605c947893 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/cea/Cea608Decoder.java
@@ -80,6 +80,11 @@
    * at which point the non-displayed memory becomes the displayed memory (and vice versa).
    */
   private static final byte CTRL_RESUME_CAPTION_LOADING = 0x20;
+
+  private static final byte CTRL_BACKSPACE = 0x21;
+
+  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
+
   /**
    * Command initiating roll-up style captioning, with the maximum of 2 rows displayed
    * simultaneously.
@@ -95,25 +100,31 @@
    * simultaneously.
    */
   private static final byte CTRL_ROLL_UP_CAPTIONS_4_ROWS = 0x27;
+
   /**
    * Command initiating paint-on style captioning. Subsequent data should be addressed immediately
    * to displayed memory without need for the {@link #CTRL_RESUME_CAPTION_LOADING} command.
    */
   private static final byte CTRL_RESUME_DIRECT_CAPTIONING = 0x29;
   /**
-   * Command indicating the end of a pop-on style caption. At this point the caption loaded in
-   * non-displayed memory should be swapped with the one in displayed memory. If no
-   * {@link #CTRL_RESUME_CAPTION_LOADING} command has been received, this command forces the
-   * receiver into pop-on style.
+   * TEXT commands are switching to TEXT service. All consecutive incoming data must be filtered out
+   * until a command is received that switches back to the CAPTION service.
    */
-  private static final byte CTRL_END_OF_CAPTION = 0x2F;
+  private static final byte CTRL_TEXT_RESTART = 0x2A;
+
+  private static final byte CTRL_RESUME_TEXT_DISPLAY = 0x2B;
 
   private static final byte CTRL_ERASE_DISPLAYED_MEMORY = 0x2C;
   private static final byte CTRL_CARRIAGE_RETURN = 0x2D;
   private static final byte CTRL_ERASE_NON_DISPLAYED_MEMORY = 0x2E;
-  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
 
-  private static final byte CTRL_BACKSPACE = 0x21;
+  /**
+   * Command indicating the end of a pop-on style caption. At this point the caption loaded in
+   * non-displayed memory should be swapped with the one in displayed memory. If no {@link
+   * #CTRL_RESUME_CAPTION_LOADING} command has been received, this command forces the receiver into
+   * pop-on style.
+   */
+  private static final byte CTRL_END_OF_CAPTION = 0x2F;
 
   // Basic North American 608 CC char set, mostly ASCII. Indexed by (char-0x20).
   private static final int[] BASIC_CHARACTER_SET = new int[] {
@@ -231,12 +242,17 @@
   private int captionMode;
   private int captionRowCount;
 
-  private boolean captionValid;
+  private boolean isCaptionValid;
   private boolean repeatableControlSet;
   private byte repeatableControlCc1;
   private byte repeatableControlCc2;
   private int currentChannel;
 
+  // The incoming characters may belong to 3 different services based on the last received control
+  // codes. The 3 services are Captioning, Text and XDS. The decoder only processes Captioning
+  // service bytes and drops the rest.
+  private boolean isInCaptionService;
+
   public Cea608Decoder(String mimeType, int accessibilityChannel) {
     ccData = new ParsableByteArray();
     cueBuilders = new ArrayList<>();
@@ -268,6 +284,7 @@ public Cea608Decoder(String mimeType, int accessibilityChannel) {
 
     setCaptionMode(CC_MODE_UNKNOWN);
     resetCueBuilders();
+    isInCaptionService = true;
   }
 
   @Override
@@ -283,11 +300,12 @@ public void flush() {
     setCaptionMode(CC_MODE_UNKNOWN);
     setCaptionRowCount(DEFAULT_CAPTIONS_ROW_COUNT);
     resetCueBuilders();
-    captionValid = false;
+    isCaptionValid = false;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
     currentChannel = NTSC_CC_CHANNEL_1;
+    isInCaptionService = true;
   }
 
   @Override
@@ -340,13 +358,19 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         continue;
       }
 
-      boolean repeatedControlPossible = repeatableControlSet;
-      repeatableControlSet = false;
+      boolean previousIsCaptionValid = isCaptionValid;
+      isCaptionValid =
+          (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG
+              && ODD_PARITY_BYTE_TABLE[ccByte1]
+              && ODD_PARITY_BYTE_TABLE[ccByte2];
 
-      boolean previousCaptionValid = captionValid;
-      captionValid = (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG;
-      if (!captionValid) {
-        if (previousCaptionValid) {
+      if (isRepeatedCommand(isCaptionValid, ccData1, ccData2)) {
+        // Ignore repeated valid commands.
+        continue;
+      }
+
+      if (!isCaptionValid) {
+        if (previousIsCaptionValid) {
           // The encoder has flipped the validity bit to indicate captions are being turned off.
           resetCueBuilders();
           captionDataProcessed = true;
@@ -354,59 +378,41 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         continue;
       }
 
-      // If we've reached this point then there is data to process; flag that work has been done.
-      captionDataProcessed = true;
-
-      if (!ODD_PARITY_BYTE_TABLE[ccByte1] || !ODD_PARITY_BYTE_TABLE[ccByte2]) {
-        // The data is invalid.
-        resetCueBuilders();
+      maybeUpdateIsInCaptionService(ccData1, ccData2);
+      if (!isInCaptionService) {
+        // Only the Captioning service is supported. Drop all other bytes.
         continue;
       }
 
-      // Special North American character set.
-      // ccData1 - 0|0|0|1|C|0|0|1
-      // ccData2 - 0|0|1|1|X|X|X|X
-      if (((ccData1 & 0xF7) == 0x11) && ((ccData2 & 0xF0) == 0x30)) {
-        if (getChannel(ccData1) == selectedChannel) {
-          currentCueBuilder.append(getSpecialChar(ccData2));
-        }
+      if (!updateAndVerifyCurrentChannel(ccData1)) {
+        // Wrong channel.
         continue;
       }
 
-      // Extended Western European character set.
-      // ccData1 - 0|0|0|1|C|0|1|S
-      // ccData2 - 0|0|1|X|X|X|X|X
-      if (((ccData1 & 0xF6) == 0x12) && (ccData2 & 0xE0) == 0x20) {
-        if (getChannel(ccData1) == selectedChannel) {
-          // Remove standard equivalent of the special extended char before appending new one
+      if (isCtrlCode(ccData1)) {
+        if (isSpecialNorthAmericanChar(ccData1, ccData2)) {
+          currentCueBuilder.append(getSpecialNorthAmericanChar(ccData2));
+        } else if (isExtendedWestEuropeanChar(ccData1, ccData2)) {
+          // Remove standard equivalent of the special extended char before appending new one.
           currentCueBuilder.backspace();
-          if ((ccData1 & 0x01) == 0x00) {
-            // Extended Spanish/Miscellaneous and French character set (S = 0).
-            currentCueBuilder.append(getExtendedEsFrChar(ccData2));
-          } else {
-            // Extended Portuguese and German/Danish character set (S = 1).
-            currentCueBuilder.append(getExtendedPtDeChar(ccData2));
-          }
+          currentCueBuilder.append(getExtendedWestEuropeanChar(ccData1, ccData2));
+        } else if (isMidrowCtrlCode(ccData1, ccData2)) {
+          handleMidrowCtrl(ccData2);
+        } else if (isPreambleAddressCode(ccData1, ccData2)) {
+          handlePreambleAddressCode(ccData1, ccData2);
+        } else if (isTabCtrlCode(ccData1, ccData2)) {
+          currentCueBuilder.tabOffset = ccData2 - 0x20;
+        } else if (isMiscCode(ccData1, ccData2)) {
+          handleMiscCode(ccData2);
+        }
+      } else {
+        // Basic North American character set.
+        currentCueBuilder.append(getBasicChar(ccData1));
+        if ((ccData2 & 0xE0) != 0x00) {
+          currentCueBuilder.append(getBasicChar(ccData2));
         }
-        continue;
-      }
-
-      // Control character.
-      // ccData1 - 0|0|0|X|X|X|X|X
-      if ((ccData1 & 0xE0) == 0x00) {
-        handleCtrl(ccData1, ccData2, repeatedControlPossible);
-        continue;
-      }
-
-      if (currentChannel != selectedChannel) {
-        continue;
-      }
-
-      // Basic North American character set.
-      currentCueBuilder.append(getChar(ccData1));
-      if ((ccData2 & 0xE0) != 0x00) {
-        currentCueBuilder.append(getChar(ccData2));
       }
+      captionDataProcessed = true;
     }
 
     if (captionDataProcessed) {
@@ -416,15 +422,22 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
     }
   }
 
-  private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
-    currentChannel = getChannel(cc1);
+  private boolean updateAndVerifyCurrentChannel(byte cc1) {
+    if (isCtrlCode(cc1)) {
+      currentChannel = getChannel(cc1);
+    }
+    return currentChannel == selectedChannel;
+  }
+
+  private boolean isRepeatedCommand(boolean captionValid, byte cc1, byte cc2) {
     // Most control commands are sent twice in succession to ensure they are received properly. We
     // don't want to process duplicate commands, so if we see the same repeatable command twice in a
     // row then we ignore the second one.
-    if (isRepeatable(cc1)) {
-      if (repeatedControlPossible && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
+    if (captionValid && isRepeatable(cc1)) {
+      if (repeatableControlSet && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
         // This is a repeated command, so we ignore it.
-        return;
+        repeatableControlSet = false;
+        return true;
       } else {
         // This is the first occurrence of a repeatable command. Set the repeatable control
         // variables so that we can recognize and ignore a duplicate (if there is one), and then
@@ -433,21 +446,11 @@ private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
         repeatableControlCc1 = cc1;
         repeatableControlCc2 = cc2;
       }
+    } else {
+      // This command is not repeatable.
+      repeatableControlSet = false;
     }
-
-    if (currentChannel != selectedChannel) {
-      return;
-    }
-
-    if (isMidrowCtrlCode(cc1, cc2)) {
-      handleMidrowCtrl(cc2);
-    } else if (isPreambleAddressCode(cc1, cc2)) {
-      handlePreambleAddressCode(cc1, cc2);
-    } else if (isTabCtrlCode(cc1, cc2)) {
-      currentCueBuilder.tabOffset = cc2 - 0x20;
-    } else if (isMiscCode(cc1, cc2)) {
-      handleMiscCode(cc2);
-    }
+    return false;
   }
 
   private void handleMidrowCtrl(byte cc2) {
@@ -629,16 +632,61 @@ private void resetCueBuilders() {
     cueBuilders.add(currentCueBuilder);
   }
 
-  private static char getChar(byte ccData) {
+  private void maybeUpdateIsInCaptionService(byte cc1, byte cc2) {
+    if (isXdsControlCode(cc1)) {
+      isInCaptionService = false;
+    } else if (isServiceSwitchCommand(cc1)) {
+      switch (cc2) {
+        case CTRL_TEXT_RESTART:
+        case CTRL_RESUME_TEXT_DISPLAY:
+          isInCaptionService = false;
+          break;
+        case CTRL_END_OF_CAPTION:
+        case CTRL_RESUME_CAPTION_LOADING:
+        case CTRL_RESUME_DIRECT_CAPTIONING:
+        case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
+        case CTRL_ROLL_UP_CAPTIONS_3_ROWS:
+        case CTRL_ROLL_UP_CAPTIONS_4_ROWS:
+          isInCaptionService = true;
+          break;
+        default:
+          // No update.
+      }
+    }
+  }
+
+  private static char getBasicChar(byte ccData) {
     int index = (ccData & 0x7F) - 0x20;
     return (char) BASIC_CHARACTER_SET[index];
   }
 
-  private static char getSpecialChar(byte ccData) {
+  private static boolean isSpecialNorthAmericanChar(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|0|1
+    // cc2 - 0|0|1|1|X|X|X|X
+    return ((cc1 & 0xF7) == 0x11) && ((cc2 & 0xF0) == 0x30);
+  }
+
+  private static char getSpecialNorthAmericanChar(byte ccData) {
     int index = ccData & 0x0F;
     return (char) SPECIAL_CHARACTER_SET[index];
   }
 
+  private static boolean isExtendedWestEuropeanChar(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|1|S
+    // cc2 - 0|0|1|X|X|X|X|X
+    return ((cc1 & 0xF6) == 0x12) && ((cc2 & 0xE0) == 0x20);
+  }
+
+  private static char getExtendedWestEuropeanChar(byte cc1, byte cc2) {
+    if ((cc1 & 0x01) == 0x00) {
+      // Extended Spanish/Miscellaneous and French character set (S = 0).
+      return getExtendedEsFrChar(cc2);
+    } else {
+      // Extended Portuguese and German/Danish character set (S = 1).
+      return getExtendedPtDeChar(cc2);
+    }
+  }
+
   private static char getExtendedEsFrChar(byte ccData) {
     int index = ccData & 0x1F;
     return (char) SPECIAL_ES_FR_CHARACTER_SET[index];
@@ -649,6 +697,11 @@ private static char getExtendedPtDeChar(byte ccData) {
     return (char) SPECIAL_PT_DE_CHARACTER_SET[index];
   }
 
+  private static boolean isCtrlCode(byte cc1) {
+    // cc1 - 0|0|0|X|X|X|X|X
+    return (cc1 & 0xE0) == 0x00;
+  }
+
   private static int getChannel(byte cc1) {
     // cc1 - X|X|X|X|C|X|X|X
     return (cc1 >> 3) & 0x1;
@@ -683,6 +736,15 @@ private static boolean isRepeatable(byte cc1) {
     return (cc1 & 0xF0) == 0x10;
   }
 
+  private static boolean isXdsControlCode(byte cc1) {
+    return 0x01 <= cc1 && cc1 <= 0x0F;
+  }
+
+  private static boolean isServiceSwitchCommand(byte cc1) {
+    // cc1 - 0|0|0|1|C|1|0|0
+    return (cc1 & 0xF7) == 0x14;
+  }
+
   private static class CueBuilder {
 
     // 608 captions define a 15 row by 32 column screen grid. These constants convert from 608
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/pgs/PgsDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/pgs/PgsDecoder.java
index 40d8e01eea..31e2a491e2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/pgs/PgsDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/pgs/PgsDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2VRT.text.pgs;
 
 import android.graphics.Bitmap;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.text.Cue;
 import com.google.android.exoplayer2VRT.text.SimpleSubtitleDecoder;
 import com.google.android.exoplayer2VRT.text.Subtitle;
@@ -41,7 +42,7 @@
   private final ParsableByteArray inflatedBuffer;
   private final CueBuilder cueBuilder;
 
-  private Inflater inflater;
+  @Nullable private Inflater inflater;
 
   public PgsDecoder() {
     super("PgsDecoder");
@@ -76,6 +77,7 @@ private void maybeInflateData(ParsableByteArray buffer) {
     }
   }
 
+  @Nullable
   private static Cue readNextSection(ParsableByteArray buffer, CueBuilder cueBuilder) {
     int limit = buffer.limit();
     int sectionType = buffer.readUnsignedByte();
@@ -197,6 +199,7 @@ private void parseIdentifierSection(ParsableByteArray buffer, int sectionLength)
       bitmapY = buffer.readUnsignedShort();
     }
 
+    @Nullable
     public Cue build() {
       if (planeWidth == 0
           || planeHeight == 0
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaDecoder.java
index bf3087a9ae..67d6a1ab11 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2VRT.text.ssa;
 
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.text.Cue;
@@ -49,7 +50,7 @@
   private int formatTextIndex;
 
   public SsaDecoder() {
-    this(null);
+    this(/* initializationData= */ null);
   }
 
   /**
@@ -58,7 +59,7 @@ public SsaDecoder() {
    *     format line. The second must contain an SSA header that will be assumed common to all
    *     samples.
    */
-  public SsaDecoder(List<byte[]> initializationData) {
+  public SsaDecoder(@Nullable List<byte[]> initializationData) {
     super("SsaDecoder");
     if (initializationData != null && !initializationData.isEmpty()) {
       haveInitializationData = true;
@@ -201,7 +202,7 @@ private void parseDialogueLine(String dialogueLine, List<Cue> cues, LongArray cu
     cues.add(new Cue(text));
     cueTimesUs.add(startTimeUs);
     if (endTimeUs != C.TIME_UNSET) {
-      cues.add(null);
+      cues.add(Cue.EMPTY);
       cueTimesUs.add(endTimeUs);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaSubtitle.java
index 5b680228c9..b64e2e67da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ssa/SsaSubtitle.java
@@ -32,7 +32,7 @@
   private final long[] cueTimesUs;
 
   /**
-   * @param cues The cues in the subtitle. Null entries may be used to represent empty cues.
+   * @param cues The cues in the subtitle.
    * @param cueTimesUs The cue times, in microseconds.
    */
   public SsaSubtitle(Cue[] cues, long[] cueTimesUs) {
@@ -61,7 +61,7 @@ public long getEventTime(int index) {
   @Override
   public List<Cue> getCues(long timeUs) {
     int index = Util.binarySearchFloor(cueTimesUs, timeUs, true, false);
-    if (index == -1 || cues[index] == null) {
+    if (index == -1 || cues[index] == Cue.EMPTY) {
       // timeUs is earlier than the start of the first cue, or we have an empty cue.
       return Collections.emptyList();
     } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripDecoder.java
index 1886558652..4db222f4fa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripDecoder.java
@@ -111,11 +111,13 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
       // Read and parse the text and tags.
       textBuilder.setLength(0);
       tags.clear();
-      while (!TextUtils.isEmpty(currentLine = subripData.readLine())) {
+      currentLine = subripData.readLine();
+      while (!TextUtils.isEmpty(currentLine)) {
         if (textBuilder.length() > 0) {
           textBuilder.append("<br>");
         }
         textBuilder.append(processLine(currentLine, tags));
+        currentLine = subripData.readLine();
       }
 
       Spanned text = Html.fromHtml(textBuilder.toString());
@@ -132,7 +134,7 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
       cues.add(buildCue(text, alignmentTag));
 
       if (haveEndTimecode) {
-        cues.add(null);
+        cues.add(Cue.EMPTY);
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripSubtitle.java
index d0134c017d..4be71355de 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/subrip/SubripSubtitle.java
@@ -32,7 +32,7 @@
   private final long[] cueTimesUs;
 
   /**
-   * @param cues The cues in the subtitle. Null entries may be used to represent empty cues.
+   * @param cues The cues in the subtitle.
    * @param cueTimesUs The cue times, in microseconds.
    */
   public SubripSubtitle(Cue[] cues, long[] cueTimesUs) {
@@ -61,7 +61,7 @@ public long getEventTime(int index) {
   @Override
   public List<Cue> getCues(long timeUs) {
     int index = Util.binarySearchFloor(cueTimesUs, timeUs, true, false);
-    if (index == -1 || cues[index] == null) {
+    if (index == -1 || cues[index] == Cue.EMPTY) {
       // timeUs is earlier than the start of the first cue, or we have an empty cue.
       return Collections.emptyList();
     } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoder.java
index 46361d0c32..daa0cba5c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoder.java
@@ -429,6 +429,7 @@ private TtmlRegion parseRegionAttributes(
         /* lineType= */ Cue.LINE_TYPE_FRACTION,
         lineAnchor,
         width,
+        height,
         /* textSizeType= */ Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING,
         /* textSize= */ regionTextHeight);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlNode.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlNode.java
index ce5d3642aa..f5c3e18fc3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlNode.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlNode.java
@@ -231,11 +231,11 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
           new Cue(
               bitmap,
               region.position,
-              Cue.ANCHOR_TYPE_MIDDLE,
+              Cue.ANCHOR_TYPE_START,
               region.line,
               region.lineAnchor,
               region.width,
-              /* height= */ Cue.DIMEN_UNSET));
+              region.height));
     }
 
     // Create text based cues.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlRegion.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlRegion.java
index 7844e196ac..d702b6bbf9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlRegion.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/ttml/TtmlRegion.java
@@ -28,6 +28,7 @@
   public final @Cue.LineType int lineType;
   public final @Cue.AnchorType int lineAnchor;
   public final float width;
+  public final float height;
   public final @Cue.TextSizeType int textSizeType;
   public final float textSize;
 
@@ -39,6 +40,7 @@ public TtmlRegion(String id) {
         /* lineType= */ Cue.TYPE_UNSET,
         /* lineAnchor= */ Cue.TYPE_UNSET,
         /* width= */ Cue.DIMEN_UNSET,
+        /* height= */ Cue.DIMEN_UNSET,
         /* textSizeType= */ Cue.TYPE_UNSET,
         /* textSize= */ Cue.DIMEN_UNSET);
   }
@@ -50,6 +52,7 @@ public TtmlRegion(
       @Cue.LineType int lineType,
       @Cue.AnchorType int lineAnchor,
       float width,
+      float height,
       int textSizeType,
       float textSize) {
     this.id = id;
@@ -58,6 +61,7 @@ public TtmlRegion(
     this.lineType = lineType;
     this.lineAnchor = lineAnchor;
     this.width = width;
+    this.height = height;
     this.textSizeType = textSizeType;
     this.textSize = textSize;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/tx3g/Tx3gDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/tx3g/Tx3gDecoder.java
index 119935fc18..5476259a01 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/tx3g/Tx3gDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/tx3g/Tx3gDecoder.java
@@ -65,6 +65,7 @@
   private static final float DEFAULT_VERTICAL_PLACEMENT = 0.85f;
 
   private final ParsableByteArray parsableByteArray;
+
   private boolean customVerticalPlacement;
   private int defaultFontFace;
   private int defaultColorRgba;
@@ -80,10 +81,7 @@
   public Tx3gDecoder(List<byte[]> initializationData) {
     super("Tx3gDecoder");
     parsableByteArray = new ParsableByteArray();
-    decodeInitializationData(initializationData);
-  }
 
-  private void decodeInitializationData(List<byte[]> initializationData) {
     if (initializationData != null && initializationData.size() == 1
         && (initializationData.get(0).length == 48 || initializationData.get(0).length == 53)) {
       byte[] initializationBytes = initializationData.get(0);
@@ -151,8 +149,16 @@ protected Subtitle decode(byte[] bytes, int length, boolean reset)
       }
       parsableByteArray.setPosition(position + atomSize);
     }
-    return new Tx3gSubtitle(new Cue(cueText, null, verticalPlacement, Cue.LINE_TYPE_FRACTION,
-        Cue.ANCHOR_TYPE_START, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET));
+    return new Tx3gSubtitle(
+        new Cue(
+            cueText,
+            /* textAlignment= */ null,
+            verticalPlacement,
+            Cue.LINE_TYPE_FRACTION,
+            Cue.ANCHOR_TYPE_START,
+            Cue.DIMEN_UNSET,
+            Cue.TYPE_UNSET,
+            Cue.DIMEN_UNSET));
   }
 
   private static String readSubtitleText(ParsableByteArray parsableByteArray)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/CssParser.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/CssParser.java
index 176a95fe77..8da9c7018f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/CssParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/CssParser.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
 import com.google.android.exoplayer2VRT.util.Util;
 import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -35,8 +37,8 @@
   private static final String PROPERTY_TEXT_DECORATION = "text-decoration";
   private static final String VALUE_BOLD = "bold";
   private static final String VALUE_UNDERLINE = "underline";
-  private static final String BLOCK_START = "{";
-  private static final String BLOCK_END = "}";
+  private static final String RULE_START = "{";
+  private static final String RULE_END = "}";
   private static final String PROPERTY_FONT_STYLE = "font-style";
   private static final String VALUE_ITALIC = "italic";
 
@@ -52,37 +54,47 @@ public CssParser() {
   }
 
   /**
-   * Takes a CSS style block and consumes up to the first empty line found. Attempts to parse the
-   * contents of the style block and returns a {@link WebvttCssStyle} instance if successful, or
-   * {@code null} otherwise.
+   * Takes a CSS style block and consumes up to the first empty line. Attempts to parse the contents
+   * of the style block and returns a list of {@link WebvttCssStyle} instances if successful. If
+   * parsing fails, it returns a list including only the styles which have been successfully parsed
+   * up to the style rule which was malformed.
    *
    * @param input The input from which the style block should be read.
-   * @return A {@link WebvttCssStyle} that represents the parsed block.
+   * @return A list of {@link WebvttCssStyle}s that represents the parsed block, or a list
+   *     containing the styles up to the parsing failure.
    */
-  public WebvttCssStyle parseBlock(ParsableByteArray input) {
+  public List<WebvttCssStyle> parseBlock(ParsableByteArray input) {
     stringBuilder.setLength(0);
     int initialInputPosition = input.getPosition();
     skipStyleBlock(input);
     styleInput.reset(input.data, input.getPosition());
     styleInput.setPosition(initialInputPosition);
-    String selector = parseSelector(styleInput, stringBuilder);
-    if (selector == null || !BLOCK_START.equals(parseNextToken(styleInput, stringBuilder))) {
-      return null;
-    }
-    WebvttCssStyle style = new WebvttCssStyle();
-    applySelectorToStyle(style, selector);
-    String token = null;
-    boolean blockEndFound = false;
-    while (!blockEndFound) {
-      int position = styleInput.getPosition();
-      token = parseNextToken(styleInput, stringBuilder);
-      blockEndFound = token == null || BLOCK_END.equals(token);
-      if (!blockEndFound) {
-        styleInput.setPosition(position);
-        parseStyleDeclaration(styleInput, style, stringBuilder);
+
+    List<WebvttCssStyle> styles = new ArrayList<>();
+    String selector;
+    while ((selector = parseSelector(styleInput, stringBuilder)) != null) {
+      if (!RULE_START.equals(parseNextToken(styleInput, stringBuilder))) {
+        return styles;
+      }
+      WebvttCssStyle style = new WebvttCssStyle();
+      applySelectorToStyle(style, selector);
+      String token = null;
+      boolean blockEndFound = false;
+      while (!blockEndFound) {
+        int position = styleInput.getPosition();
+        token = parseNextToken(styleInput, stringBuilder);
+        blockEndFound = token == null || RULE_END.equals(token);
+        if (!blockEndFound) {
+          styleInput.setPosition(position);
+          parseStyleDeclaration(styleInput, style, stringBuilder);
+        }
+      }
+      // Check that the style rule ended correctly.
+      if (RULE_END.equals(token)) {
+        styles.add(style);
       }
     }
-    return BLOCK_END.equals(token) ? style : null; // Check that the style block ended correctly.
+    return styles;
   }
 
   /**
@@ -107,7 +119,7 @@ private static String parseSelector(ParsableByteArray input, StringBuilder strin
     if (token == null) {
       return null;
     }
-    if (BLOCK_START.equals(token)) {
+    if (RULE_START.equals(token)) {
       input.setPosition(position);
       return "";
     }
@@ -156,7 +168,7 @@ private static void parseStyleDeclaration(ParsableByteArray input, WebvttCssStyl
     String token = parseNextToken(input, stringBuilder);
     if (";".equals(token)) {
       // The style declaration is well formed.
-    } else if (BLOCK_END.equals(token)) {
+    } else if (RULE_END.equals(token)) {
       // The style declaration is well formed and we can go on, but the closing bracket had to be
       // fed back.
       input.setPosition(position);
@@ -250,7 +262,7 @@ private static String parsePropertyValue(ParsableByteArray input, StringBuilder
         // Syntax error.
         return null;
       }
-      if (BLOCK_END.equals(token) || ";".equals(token)) {
+      if (RULE_END.equals(token) || ";".equals(token)) {
         input.setPosition(position);
         expressionEndFound = true;
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/WebvttDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/WebvttDecoder.java
index c769fa785a..30c133d1cf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/WebvttDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/text/webvtt/WebvttDecoder.java
@@ -80,10 +80,7 @@ protected WebvttSubtitle decode(byte[] bytes, int length, boolean reset)
           throw new SubtitleDecoderException("A style block was found after the first cue.");
         }
         parsableWebvttData.readLine(); // Consume the "STYLE" header.
-        WebvttCssStyle styleBlock = cssParser.parseBlock(parsableWebvttData);
-        if (styleBlock != null) {
-          definedStyles.add(styleBlock);
-        }
+        definedStyles.addAll(cssParser.parseBlock(parsableWebvttData));
       } else if (event == EVENT_CUE) {
         if (cueParser.parseCue(parsableWebvttData, webvttCueBuilder, definedStyles)) {
           subtitles.add(webvttCueBuilder.build());
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/AdaptiveTrackSelection.java
index f01b617193..249237cff9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/AdaptiveTrackSelection.java
@@ -757,7 +757,7 @@ public long getAllocatedBandwidth() {
     for (int i = 0; i < values.length; i++) {
       logValues[i] = new double[values[i].length];
       for (int j = 0; j < values[i].length; j++) {
-        logValues[i][j] = Math.log(values[i][j]);
+        logValues[i][j] = values[i][j] == Format.NO_VALUE ? 0 : Math.log(values[i][j]);
       }
     }
     return logValues;
@@ -779,7 +779,8 @@ public long getAllocatedBandwidth() {
       double totalBitrateDiff = logBitrates[i][logBitrates[i].length - 1] - logBitrates[i][0];
       for (int j = 0; j < logBitrates[i].length - 1; j++) {
         double switchBitrate = 0.5 * (logBitrates[i][j] + logBitrates[i][j + 1]);
-        switchPoints[i][j] = (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
+        switchPoints[i][j] =
+            totalBitrateDiff == 0.0 ? 1.0 : (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
       }
     }
     return switchPoints;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelector.java
index b19ee37e8f..7915b20f25 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelector.java
@@ -19,7 +19,6 @@
 import android.graphics.Point;
 import android.os.Parcel;
 import android.os.Parcelable;
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Pair;
@@ -178,6 +177,7 @@
     private boolean exceedAudioConstraintsIfNecessary;
     private boolean allowAudioMixedMimeTypeAdaptiveness;
     private boolean allowAudioMixedSampleRateAdaptiveness;
+    private boolean allowAudioMixedChannelCountAdaptiveness;
     // General
     private boolean forceLowestBitrate;
     private boolean forceHighestSupportedBitrate;
@@ -215,6 +215,8 @@ private ParametersBuilder(Parameters initialValues) {
       exceedAudioConstraintsIfNecessary = initialValues.exceedAudioConstraintsIfNecessary;
       allowAudioMixedMimeTypeAdaptiveness = initialValues.allowAudioMixedMimeTypeAdaptiveness;
       allowAudioMixedSampleRateAdaptiveness = initialValues.allowAudioMixedSampleRateAdaptiveness;
+      allowAudioMixedChannelCountAdaptiveness =
+          initialValues.allowAudioMixedChannelCountAdaptiveness;
       // General
       forceLowestBitrate = initialValues.forceLowestBitrate;
       forceHighestSupportedBitrate = initialValues.forceHighestSupportedBitrate;
@@ -246,8 +248,10 @@ public ParametersBuilder clearVideoSizeConstraints() {
     }
 
     /**
-     * See {@link Parameters#maxVideoWidth} and {@link Parameters#maxVideoHeight}.
+     * Sets the maximum allowed video width and height.
      *
+     * @param maxVideoWidth Maximum allowed video width in pixels.
+     * @param maxVideoHeight Maximum allowed video height in pixels.
      * @return This builder.
      */
     public ParametersBuilder setMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
@@ -257,8 +261,9 @@ public ParametersBuilder setMaxVideoSize(int maxVideoWidth, int maxVideoHeight)
     }
 
     /**
-     * See {@link Parameters#maxVideoFrameRate}.
+     * Sets the maximum allowed video frame rate.
      *
+     * @param maxVideoFrameRate Maximum allowed video frame rate in hertz.
      * @return This builder.
      */
     public ParametersBuilder setMaxVideoFrameRate(int maxVideoFrameRate) {
@@ -267,8 +272,9 @@ public ParametersBuilder setMaxVideoFrameRate(int maxVideoFrameRate) {
     }
 
     /**
-     * See {@link Parameters#maxVideoBitrate}.
+     * Sets the maximum allowed video bitrate.
      *
+     * @param maxVideoBitrate Maximum allowed video bitrate in bits per second.
      * @return This builder.
      */
     public ParametersBuilder setMaxVideoBitrate(int maxVideoBitrate) {
@@ -277,8 +283,11 @@ public ParametersBuilder setMaxVideoBitrate(int maxVideoBitrate) {
     }
 
     /**
-     * See {@link Parameters#exceedVideoConstraintsIfNecessary}.
+     * Sets whether to exceed the {@link #setMaxVideoSize(int, int)} and {@link
+     * #setMaxAudioBitrate(int)} constraints when no selection can be made otherwise.
      *
+     * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
+     *     selection can be made otherwise.
      * @return This builder.
      */
     public ParametersBuilder setExceedVideoConstraintsIfNecessary(
@@ -288,8 +297,14 @@ public ParametersBuilder setExceedVideoConstraintsIfNecessary(
     }
 
     /**
-     * See {@link Parameters#allowVideoMixedMimeTypeAdaptiveness}.
+     * Sets whether to allow adaptive video selections containing mixed MIME types.
      *
+     * <p>Adaptations between different MIME types may not be completely seamless, in which case
+     * {@link #setAllowVideoNonSeamlessAdaptiveness(boolean)} also needs to be {@code true} for
+     * mixed MIME type selections to be made.
+     *
+     * @param allowVideoMixedMimeTypeAdaptiveness Whether to allow adaptive video selections
+     *     containing mixed MIME types.
      * @return This builder.
      */
     public ParametersBuilder setAllowVideoMixedMimeTypeAdaptiveness(
@@ -299,8 +314,11 @@ public ParametersBuilder setAllowVideoMixedMimeTypeAdaptiveness(
     }
 
     /**
-     * See {@link Parameters#allowVideoNonSeamlessAdaptiveness}.
+     * Sets whether to allow adaptive video selections where adaptation may not be completely
+     * seamless.
      *
+     * @param allowVideoNonSeamlessAdaptiveness Whether to allow adaptive video selections where
+     *     adaptation may not be completely seamless.
      * @return This builder.
      */
     public ParametersBuilder setAllowVideoNonSeamlessAdaptiveness(
@@ -314,7 +332,8 @@ public ParametersBuilder setAllowVideoNonSeamlessAdaptiveness(
      * obtained from {@link Util#getPhysicalDisplaySize(Context)}.
      *
      * @param context Any context.
-     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
+     * @param viewportOrientationMayChange Whether the viewport orientation may change during
+     *     playback.
      * @return This builder.
      */
     public ParametersBuilder setViewportSizeToPhysicalDisplaySize(
@@ -335,12 +354,13 @@ public ParametersBuilder clearViewportSizeConstraints() {
     }
 
     /**
-     * See {@link Parameters#viewportWidth}, {@link Parameters#maxVideoHeight} and {@link
-     * Parameters#viewportOrientationMayChange}.
+     * Sets the viewport size to constrain adaptive video selections so that only tracks suitable
+     * for the viewport are selected.
      *
-     * @param viewportWidth See {@link Parameters#viewportWidth}.
-     * @param viewportHeight See {@link Parameters#viewportHeight}.
-     * @param viewportOrientationMayChange See {@link Parameters#viewportOrientationMayChange}.
+     * @param viewportWidth Viewport width in pixels.
+     * @param viewportHeight Viewport height in pixels.
+     * @param viewportOrientationMayChange Whether the viewport orientation may change during
+     *     playback.
      * @return This builder.
      */
     public ParametersBuilder setViewportSize(
@@ -360,8 +380,9 @@ public ParametersBuilder setPreferredAudioLanguage(@Nullable String preferredAud
     }
 
     /**
-     * See {@link Parameters#maxAudioChannelCount}.
+     * Sets the maximum allowed audio channel count.
      *
+     * @param maxAudioChannelCount Maximum allowed audio channel count.
      * @return This builder.
      */
     public ParametersBuilder setMaxAudioChannelCount(int maxAudioChannelCount) {
@@ -370,8 +391,9 @@ public ParametersBuilder setMaxAudioChannelCount(int maxAudioChannelCount) {
     }
 
     /**
-     * See {@link Parameters#maxAudioBitrate}.
+     * Sets the maximum allowed audio bitrate.
      *
+     * @param maxAudioBitrate Maximum allowed audio bitrate in bits per second.
      * @return This builder.
      */
     public ParametersBuilder setMaxAudioBitrate(int maxAudioBitrate) {
@@ -380,8 +402,11 @@ public ParametersBuilder setMaxAudioBitrate(int maxAudioBitrate) {
     }
 
     /**
-     * See {@link Parameters#exceedAudioConstraintsIfNecessary}.
+     * Sets whether to exceed the {@link #setMaxAudioChannelCount(int)} and {@link
+     * #setMaxAudioBitrate(int)} constraints when no selection can be made otherwise.
      *
+     * @param exceedAudioConstraintsIfNecessary Whether to exceed audio constraints when no
+     *     selection can be made otherwise.
      * @return This builder.
      */
     public ParametersBuilder setExceedAudioConstraintsIfNecessary(
@@ -391,8 +416,12 @@ public ParametersBuilder setExceedAudioConstraintsIfNecessary(
     }
 
     /**
-     * See {@link Parameters#allowAudioMixedMimeTypeAdaptiveness}.
+     * Sets whether to allow adaptive audio selections containing mixed MIME types.
+     *
+     * <p>Adaptations between different MIME types may not be completely seamless.
      *
+     * @param allowAudioMixedMimeTypeAdaptiveness Whether to allow adaptive audio selections
+     *     containing mixed MIME types.
      * @return This builder.
      */
     public ParametersBuilder setAllowAudioMixedMimeTypeAdaptiveness(
@@ -402,8 +431,12 @@ public ParametersBuilder setAllowAudioMixedMimeTypeAdaptiveness(
     }
 
     /**
-     * See {@link Parameters#allowAudioMixedSampleRateAdaptiveness}.
+     * Sets whether to allow adaptive audio selections containing mixed sample rates.
      *
+     * <p>Adaptations between different sample rates may not be completely seamless.
+     *
+     * @param allowAudioMixedSampleRateAdaptiveness Whether to allow adaptive audio selections
+     *     containing mixed sample rates.
      * @return This builder.
      */
     public ParametersBuilder setAllowAudioMixedSampleRateAdaptiveness(
@@ -412,6 +445,21 @@ public ParametersBuilder setAllowAudioMixedSampleRateAdaptiveness(
       return this;
     }
 
+    /**
+     * Sets whether to allow adaptive audio selections containing mixed channel counts.
+     *
+     * <p>Adaptations between different channel counts may not be completely seamless.
+     *
+     * @param allowAudioMixedChannelCountAdaptiveness Whether to allow adaptive audio selections
+     *     containing mixed channel counts.
+     * @return This builder.
+     */
+    public ParametersBuilder setAllowAudioMixedChannelCountAdaptiveness(
+        boolean allowAudioMixedChannelCountAdaptiveness) {
+      this.allowAudioMixedChannelCountAdaptiveness = allowAudioMixedChannelCountAdaptiveness;
+      return this;
+    }
+
     // Text
 
     @Override
@@ -420,6 +468,12 @@ public ParametersBuilder setPreferredTextLanguage(@Nullable String preferredText
       return this;
     }
 
+    @Override
+    public ParametersBuilder setPreferredTextRoleFlags(@C.RoleFlags int preferredTextRoleFlags) {
+      super.setPreferredTextRoleFlags(preferredTextRoleFlags);
+      return this;
+    }
+
     @Override
     public ParametersBuilder setSelectUndeterminedTextLanguage(
         boolean selectUndeterminedTextLanguage) {
@@ -436,8 +490,11 @@ public ParametersBuilder setDisabledTextTrackSelectionFlags(
     // General
 
     /**
-     * See {@link Parameters#forceLowestBitrate}.
+     * Sets whether to force selection of the single lowest bitrate audio and video tracks that
+     * comply with all other constraints.
      *
+     * @param forceLowestBitrate Whether to force selection of the single lowest bitrate audio and
+     *     video tracks.
      * @return This builder.
      */
     public ParametersBuilder setForceLowestBitrate(boolean forceLowestBitrate) {
@@ -446,8 +503,11 @@ public ParametersBuilder setForceLowestBitrate(boolean forceLowestBitrate) {
     }
 
     /**
-     * See {@link Parameters#forceHighestSupportedBitrate}.
+     * Sets whether to force selection of the highest bitrate audio and video tracks that comply
+     * with all other constraints.
      *
+     * @param forceHighestSupportedBitrate Whether to force selection of the highest bitrate audio
+     *     and video tracks.
      * @return This builder.
      */
     public ParametersBuilder setForceHighestSupportedBitrate(boolean forceHighestSupportedBitrate) {
@@ -473,8 +533,15 @@ public ParametersBuilder setAllowNonSeamlessAdaptiveness(boolean allowNonSeamles
     }
 
     /**
-     * See {@link Parameters#exceedRendererCapabilitiesIfNecessary}.
+     * Sets whether to exceed renderer capabilities when no selection can be made otherwise.
      *
+     * <p>This parameter applies when all of the tracks available for a renderer exceed the
+     * renderer's reported capabilities. If the parameter is {@code true} then the lowest quality
+     * track will still be selected. Playback may succeed if the renderer has under-reported its
+     * true capabilities. If {@code false} then no track will be selected.
+     *
+     * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
+     *     selection can be made otherwise.
      * @return This builder.
      */
     public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
@@ -484,7 +551,7 @@ public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
     }
 
     /**
-     * See {@link Parameters#tunnelingAudioSessionId}.
+     * Sets the audio session id to use when tunneling.
      *
      * <p>Enables or disables tunneling. To enable tunneling, pass an audio session id to use when
      * in tunneling mode. Session ids can be generated using {@link
@@ -494,6 +561,7 @@ public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
      *
      * @param tunnelingAudioSessionId The audio session id to use when tunneling, or {@link
      *     C#AUDIO_SESSION_ID_UNSET} to disable tunneling.
+     * @return This builder.
      */
     public ParametersBuilder setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
       this.tunnelingAudioSessionId = tunnelingAudioSessionId;
@@ -508,6 +576,7 @@ public ParametersBuilder setTunnelingAudioSessionId(int tunnelingAudioSessionId)
      *
      * @param rendererIndex The renderer index.
      * @param disabled Whether the renderer is disabled.
+     * @return This builder.
      */
     public final ParametersBuilder setRendererDisabled(int rendererIndex, boolean disabled) {
       if (rendererDisabledFlags.get(rendererIndex) == disabled) {
@@ -544,6 +613,7 @@ public final ParametersBuilder setRendererDisabled(int rendererIndex, boolean di
      * @param rendererIndex The renderer index.
      * @param groups The {@link TrackGroupArray} for which the override should be applied.
      * @param override The override.
+     * @return This builder.
      */
     public final ParametersBuilder setSelectionOverride(
         int rendererIndex, TrackGroupArray groups, SelectionOverride override) {
@@ -565,6 +635,7 @@ public final ParametersBuilder setSelectionOverride(
      *
      * @param rendererIndex The renderer index.
      * @param groups The {@link TrackGroupArray} for which the override should be cleared.
+     * @return This builder.
      */
     public final ParametersBuilder clearSelectionOverride(
         int rendererIndex, TrackGroupArray groups) {
@@ -584,6 +655,7 @@ public final ParametersBuilder clearSelectionOverride(
      * Clears all track selection overrides for the specified renderer.
      *
      * @param rendererIndex The renderer index.
+     * @return This builder.
      */
     public final ParametersBuilder clearSelectionOverrides(int rendererIndex) {
       Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
@@ -595,7 +667,11 @@ public final ParametersBuilder clearSelectionOverrides(int rendererIndex) {
       return this;
     }
 
-    /** Clears all track selection overrides for all renderers. */
+    /**
+     * Clears all track selection overrides for all renderers.
+     *
+     * @return This builder.
+     */
     public final ParametersBuilder clearSelectionOverrides() {
       if (selectionOverrides.size() == 0) {
         // Nothing to clear.
@@ -628,8 +704,10 @@ public Parameters build() {
           exceedAudioConstraintsIfNecessary,
           allowAudioMixedMimeTypeAdaptiveness,
           allowAudioMixedSampleRateAdaptiveness,
+          allowAudioMixedChannelCountAdaptiveness,
           // Text
           preferredTextLanguage,
+          preferredTextRoleFlags,
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags,
           // General
@@ -662,8 +740,8 @@ public Parameters build() {
 
     // Video
     /**
-     * Maximum allowed video width. The default value is {@link Integer#MAX_VALUE} (i.e. no
-     * constraint).
+     * Maximum allowed video width in pixels. The default value is {@link Integer#MAX_VALUE} (i.e.
+     * no constraint).
      *
      * <p>To constrain adaptive video track selections to be suitable for a given viewport (the
      * region of the display within which video will be played), use ({@link #viewportWidth}, {@link
@@ -671,8 +749,8 @@ public Parameters build() {
      */
     public final int maxVideoWidth;
     /**
-     * Maximum allowed video height. The default value is {@link Integer#MAX_VALUE} (i.e. no
-     * constraint).
+     * Maximum allowed video height in pixels. The default value is {@link Integer#MAX_VALUE} (i.e.
+     * no constraint).
      *
      * <p>To constrain adaptive video track selections to be suitable for a given viewport (the
      * region of the display within which video will be played), use ({@link #viewportWidth}, {@link
@@ -680,12 +758,13 @@ public Parameters build() {
      */
     public final int maxVideoHeight;
     /**
-     * Maximum allowed video frame rate. The default value is {@link Integer#MAX_VALUE} (i.e. no
-     * constraint).
+     * Maximum allowed video frame rate in hertz. The default value is {@link Integer#MAX_VALUE}
+     * (i.e. no constraint).
      */
     public final int maxVideoFrameRate;
     /**
-     * Maximum video bitrate. The default value is {@link Integer#MAX_VALUE} (i.e. no constraint).
+     * Maximum allowed video bitrate in bits per second. The default value is {@link
+     * Integer#MAX_VALUE} (i.e. no constraint).
      */
     public final int maxVideoBitrate;
     /**
@@ -695,9 +774,9 @@ public Parameters build() {
      */
     public final boolean exceedVideoConstraintsIfNecessary;
     /**
-     * Whether to allow adaptive video selections containing mixed mime types. Adaptations between
-     * different mime types may not be completely seamless, in which case {@link
-     * #allowVideoNonSeamlessAdaptiveness} also needs to be {@code true} for mixed mime type
+     * Whether to allow adaptive video selections containing mixed MIME types. Adaptations between
+     * different MIME types may not be completely seamless, in which case {@link
+     * #allowVideoNonSeamlessAdaptiveness} also needs to be {@code true} for mixed MIME type
      * selections to be made. The default value is {@code false}.
      */
     public final boolean allowVideoMixedMimeTypeAdaptiveness;
@@ -731,7 +810,8 @@ public Parameters build() {
      */
     public final int maxAudioChannelCount;
     /**
-     * Maximum audio bitrate. The default value is {@link Integer#MAX_VALUE} (i.e. no constraint).
+     * Maximum allowed audio bitrate in bits per second. The default value is {@link
+     * Integer#MAX_VALUE} (i.e. no constraint).
      */
     public final int maxAudioBitrate;
     /**
@@ -740,8 +820,8 @@ public Parameters build() {
      */
     public final boolean exceedAudioConstraintsIfNecessary;
     /**
-     * Whether to allow adaptive audio selections containing mixed mime types. Adaptations between
-     * different mime types may not be completely seamless. The default value is {@code false}.
+     * Whether to allow adaptive audio selections containing mixed MIME types. Adaptations between
+     * different MIME types may not be completely seamless. The default value is {@code false}.
      */
     public final boolean allowAudioMixedMimeTypeAdaptiveness;
     /**
@@ -749,6 +829,12 @@ public Parameters build() {
      * different sample rates may not be completely seamless. The default value is {@code false}.
      */
     public final boolean allowAudioMixedSampleRateAdaptiveness;
+    /**
+     * Whether to allow adaptive audio selections containing mixed channel counts. Adaptations
+     * between different channel counts may not be completely seamless. The default value is {@code
+     * false}.
+     */
+    public final boolean allowAudioMixedChannelCountAdaptiveness;
 
     // General
     /**
@@ -809,8 +895,10 @@ private Parameters() {
           /* exceedAudioConstraintsIfNecessary= */ true,
           /* allowAudioMixedMimeTypeAdaptiveness= */ false,
           /* allowAudioMixedSampleRateAdaptiveness= */ false,
+          /* allowAudioMixedChannelCountAdaptiveness= */ false,
           // Text
           TrackSelectionParameters.DEFAULT.preferredTextLanguage,
+          TrackSelectionParameters.DEFAULT.preferredTextRoleFlags,
           TrackSelectionParameters.DEFAULT.selectUndeterminedTextLanguage,
           TrackSelectionParameters.DEFAULT.disabledTextTrackSelectionFlags,
           // General
@@ -841,8 +929,10 @@ private Parameters() {
         boolean exceedAudioConstraintsIfNecessary,
         boolean allowAudioMixedMimeTypeAdaptiveness,
         boolean allowAudioMixedSampleRateAdaptiveness,
+        boolean allowAudioMixedChannelCountAdaptiveness,
         // Text
         @Nullable String preferredTextLanguage,
+        @C.RoleFlags int preferredTextRoleFlags,
         boolean selectUndeterminedTextLanguage,
         @C.SelectionFlags int disabledTextTrackSelectionFlags,
         // General
@@ -856,6 +946,7 @@ private Parameters() {
       super(
           preferredAudioLanguage,
           preferredTextLanguage,
+          preferredTextRoleFlags,
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags);
       // Video
@@ -875,6 +966,7 @@ private Parameters() {
       this.exceedAudioConstraintsIfNecessary = exceedAudioConstraintsIfNecessary;
       this.allowAudioMixedMimeTypeAdaptiveness = allowAudioMixedMimeTypeAdaptiveness;
       this.allowAudioMixedSampleRateAdaptiveness = allowAudioMixedSampleRateAdaptiveness;
+      this.allowAudioMixedChannelCountAdaptiveness = allowAudioMixedChannelCountAdaptiveness;
       // General
       this.forceLowestBitrate = forceLowestBitrate;
       this.forceHighestSupportedBitrate = forceHighestSupportedBitrate;
@@ -908,6 +1000,7 @@ private Parameters() {
       this.exceedAudioConstraintsIfNecessary = Util.readBoolean(in);
       this.allowAudioMixedMimeTypeAdaptiveness = Util.readBoolean(in);
       this.allowAudioMixedSampleRateAdaptiveness = Util.readBoolean(in);
+      this.allowAudioMixedChannelCountAdaptiveness = Util.readBoolean(in);
       // General
       this.forceLowestBitrate = Util.readBoolean(in);
       this.forceHighestSupportedBitrate = Util.readBoolean(in);
@@ -989,6 +1082,8 @@ public boolean equals(@Nullable Object obj) {
           && exceedAudioConstraintsIfNecessary == other.exceedAudioConstraintsIfNecessary
           && allowAudioMixedMimeTypeAdaptiveness == other.allowAudioMixedMimeTypeAdaptiveness
           && allowAudioMixedSampleRateAdaptiveness == other.allowAudioMixedSampleRateAdaptiveness
+          && allowAudioMixedChannelCountAdaptiveness
+              == other.allowAudioMixedChannelCountAdaptiveness
           // General
           && forceLowestBitrate == other.forceLowestBitrate
           && forceHighestSupportedBitrate == other.forceHighestSupportedBitrate
@@ -1019,6 +1114,7 @@ public int hashCode() {
       result = 31 * result + (exceedAudioConstraintsIfNecessary ? 1 : 0);
       result = 31 * result + (allowAudioMixedMimeTypeAdaptiveness ? 1 : 0);
       result = 31 * result + (allowAudioMixedSampleRateAdaptiveness ? 1 : 0);
+      result = 31 * result + (allowAudioMixedChannelCountAdaptiveness ? 1 : 0);
       // General
       result = 31 * result + (forceLowestBitrate ? 1 : 0);
       result = 31 * result + (forceHighestSupportedBitrate ? 1 : 0);
@@ -1055,6 +1151,7 @@ public void writeToParcel(Parcel dest, int flags) {
       Util.writeBoolean(dest, exceedAudioConstraintsIfNecessary);
       Util.writeBoolean(dest, allowAudioMixedMimeTypeAdaptiveness);
       Util.writeBoolean(dest, allowAudioMixedSampleRateAdaptiveness);
+      Util.writeBoolean(dest, allowAudioMixedChannelCountAdaptiveness);
       // General
       Util.writeBoolean(dest, forceLowestBitrate);
       Util.writeBoolean(dest, forceHighestSupportedBitrate);
@@ -1552,7 +1649,7 @@ public void experimental_allowMultipleAdaptiveSelections() {
       }
     }
 
-    int selectedTextTrackScore = Integer.MIN_VALUE;
+    TextTrackScore selectedTextTrackScore = null;
     int selectedTextRendererIndex = C.INDEX_UNSET;
     for (int i = 0; i < rendererCount; i++) {
       int trackType = mappedTrackInfo.getRendererType(i);
@@ -1562,13 +1659,15 @@ public void experimental_allowMultipleAdaptiveSelections() {
           // Already done. Do nothing.
           break;
         case C.TRACK_TYPE_TEXT:
-          Pair<TrackSelection.Definition, Integer> textSelection =
+          Pair<TrackSelection.Definition, TextTrackScore> textSelection =
               selectTextTrack(
                   mappedTrackInfo.getTrackGroups(i),
                   rendererFormatSupports[i],
                   params,
                   selectedAudioLanguage);
-          if (textSelection != null && textSelection.second > selectedTextTrackScore) {
+          if (textSelection != null
+              && (selectedTextTrackScore == null
+                  || textSelection.second.compareTo(selectedTextTrackScore) > 0)) {
             if (selectedTextRendererIndex != C.INDEX_UNSET) {
               // We've already made a selection for another text renderer, but it had a lower score.
               // Clear the selection for that renderer.
@@ -1934,8 +2033,10 @@ private static boolean isSupportedAdaptiveVideoTrack(
           getAdaptiveAudioTracks(
               selectedGroup,
               formatSupports[selectedGroupIndex],
+              params.maxAudioBitrate,
               params.allowAudioMixedMimeTypeAdaptiveness,
-              params.allowAudioMixedSampleRateAdaptiveness);
+              params.allowAudioMixedSampleRateAdaptiveness,
+              params.allowAudioMixedChannelCountAdaptiveness);
       if (adaptiveTracks.length > 0) {
         definition = new TrackSelection.Definition(selectedGroup, adaptiveTracks);
       }
@@ -1951,8 +2052,10 @@ private static boolean isSupportedAdaptiveVideoTrack(
   private static int[] getAdaptiveAudioTracks(
       TrackGroup group,
       int[] formatSupport,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
-      boolean allowMixedSampleRateAdaptiveness) {
+      boolean allowMixedSampleRateAdaptiveness,
+      boolean allowAudioMixedChannelCountAdaptiveness) {
     int selectedConfigurationTrackCount = 0;
     AudioConfigurationTuple selectedConfiguration = null;
     HashSet<AudioConfigurationTuple> seenConfigurationTuples = new HashSet<>();
@@ -1967,8 +2070,10 @@ private static boolean isSupportedAdaptiveVideoTrack(
                 group,
                 formatSupport,
                 configuration,
+                maxAudioBitrate,
                 allowMixedMimeTypeAdaptiveness,
-                allowMixedSampleRateAdaptiveness);
+                allowMixedSampleRateAdaptiveness,
+                allowAudioMixedChannelCountAdaptiveness);
         if (configurationCount > selectedConfigurationTrackCount) {
           selectedConfiguration = configuration;
           selectedConfigurationTrackCount = configurationCount;
@@ -1977,15 +2082,19 @@ private static boolean isSupportedAdaptiveVideoTrack(
     }
 
     if (selectedConfigurationTrackCount > 1) {
+      Assertions.checkNotNull(selectedConfiguration);
       int[] adaptiveIndices = new int[selectedConfigurationTrackCount];
       int index = 0;
       for (int i = 0; i < group.length; i++) {
+        Format format = group.getFormat(i);
         if (isSupportedAdaptiveAudioTrack(
-            group.getFormat(i),
+            format,
             formatSupport[i],
-            Assertions.checkNotNull(selectedConfiguration),
+            selectedConfiguration,
+            maxAudioBitrate,
             allowMixedMimeTypeAdaptiveness,
-            allowMixedSampleRateAdaptiveness)) {
+            allowMixedSampleRateAdaptiveness,
+            allowAudioMixedChannelCountAdaptiveness)) {
           adaptiveIndices[index++] = i;
         }
       }
@@ -1998,16 +2107,20 @@ private static int getAdaptiveAudioTrackCount(
       TrackGroup group,
       int[] formatSupport,
       AudioConfigurationTuple configuration,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
-      boolean allowMixedSampleRateAdaptiveness) {
+      boolean allowMixedSampleRateAdaptiveness,
+      boolean allowAudioMixedChannelCountAdaptiveness) {
     int count = 0;
     for (int i = 0; i < group.length; i++) {
       if (isSupportedAdaptiveAudioTrack(
           group.getFormat(i),
           formatSupport[i],
           configuration,
+          maxAudioBitrate,
           allowMixedMimeTypeAdaptiveness,
-          allowMixedSampleRateAdaptiveness)) {
+          allowMixedSampleRateAdaptiveness,
+          allowAudioMixedChannelCountAdaptiveness)) {
         count++;
       }
     }
@@ -2018,11 +2131,15 @@ private static boolean isSupportedAdaptiveAudioTrack(
       Format format,
       int formatSupport,
       AudioConfigurationTuple configuration,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
-      boolean allowMixedSampleRateAdaptiveness) {
+      boolean allowMixedSampleRateAdaptiveness,
+      boolean allowAudioMixedChannelCountAdaptiveness) {
     return isSupported(formatSupport, false)
-        && (format.channelCount != Format.NO_VALUE
-            && format.channelCount == configuration.channelCount)
+        && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxAudioBitrate)
+        && (allowAudioMixedChannelCountAdaptiveness
+            || (format.channelCount != Format.NO_VALUE
+                && format.channelCount == configuration.channelCount))
         && (allowMixedMimeTypeAdaptiveness
             || (format.sampleMimeType != null
                 && TextUtils.equals(format.sampleMimeType, configuration.mimeType)))
@@ -2042,21 +2159,21 @@ private static boolean isSupportedAdaptiveAudioTrack(
    *     track, indexed by track group index and track index (in that order).
    * @param params The selector's current constraint parameters.
    * @param selectedAudioLanguage The language of the selected audio track. May be null if the
-   *     selected audio track declares no language or no audio track was selected.
-   * @return The {@link TrackSelection.Definition} and corresponding track score, or null if no
-   *     selection was made.
+   *     selected text track declares no language or no text track was selected.
+   * @return The {@link TrackSelection.Definition} and corresponding {@link TextTrackScore}, or null
+   *     if no selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
   @Nullable
-  protected Pair<TrackSelection.Definition, Integer> selectTextTrack(
+  protected Pair<TrackSelection.Definition, TextTrackScore> selectTextTrack(
       TrackGroupArray groups,
       int[][] formatSupport,
       Parameters params,
       @Nullable String selectedAudioLanguage)
       throws ExoPlaybackException {
     TrackGroup selectedGroup = null;
-    int selectedTrackIndex = 0;
-    int selectedTrackScore = 0;
+    int selectedTrackIndex = C.INDEX_UNSET;
+    TextTrackScore selectedTrackScore = null;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
       int[] trackFormatSupport = formatSupport[groupIndex];
@@ -2064,39 +2181,11 @@ private static boolean isSupportedAdaptiveAudioTrack(
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
-          int maskedSelectionFlags =
-              format.selectionFlags & ~params.disabledTextTrackSelectionFlags;
-          boolean isDefault = (maskedSelectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
-          boolean isForced = (maskedSelectionFlags & C.SELECTION_FLAG_FORCED) != 0;
-          int trackScore;
-          int languageScore = getFormatLanguageScore(format, params.preferredTextLanguage);
-          boolean trackHasNoLanguage = formatHasNoLanguage(format);
-          if (languageScore > 0 || (params.selectUndeterminedTextLanguage && trackHasNoLanguage)) {
-            if (isDefault) {
-              trackScore = 11;
-            } else if (!isForced) {
-              // Prefer non-forced to forced if a preferred text language has been specified. Where
-              // both are provided the non-forced track will usually contain the forced subtitles as
-              // a subset.
-              trackScore = 7;
-            } else {
-              trackScore = 3;
-            }
-            trackScore += languageScore;
-          } else if (isDefault) {
-            trackScore = 2;
-          } else if (isForced
-              && (getFormatLanguageScore(format, selectedAudioLanguage) > 0
-                  || (trackHasNoLanguage && stringDefinesNoLanguage(selectedAudioLanguage)))) {
-            trackScore = 1;
-          } else {
-            // Track should not be selected.
-            continue;
-          }
-          if (isSupported(trackFormatSupport[trackIndex], false)) {
-            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
-          }
-          if (trackScore > selectedTrackScore) {
+          TextTrackScore trackScore =
+              new TextTrackScore(
+                  format, params, trackFormatSupport[trackIndex], selectedAudioLanguage);
+          if (trackScore.isWithinConstraints
+              && (selectedTrackScore == null || trackScore.compareTo(selectedTrackScore) > 0)) {
             selectedGroup = trackGroup;
             selectedTrackIndex = trackIndex;
             selectedTrackScore = trackScore;
@@ -2107,7 +2196,8 @@ private static boolean isSupportedAdaptiveAudioTrack(
     return selectedGroup == null
         ? null
         : Pair.create(
-            new TrackSelection.Definition(selectedGroup, selectedTrackIndex), selectedTrackScore);
+            new TrackSelection.Definition(selectedGroup, selectedTrackIndex),
+            Assertions.checkNotNull(selectedTrackScore));
   }
 
   // General track selection methods.
@@ -2277,19 +2367,17 @@ protected static boolean isSupported(int formatSupport, boolean allowExceedsCapa
         && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
   }
 
-  /** Equivalent to {@link #stringDefinesNoLanguage stringDefinesNoLanguage(format.language)}. */
-  protected static boolean formatHasNoLanguage(Format format) {
-    return stringDefinesNoLanguage(format.language);
-  }
-
   /**
-   * Returns whether the given string does not define a language.
+   * Normalizes the input string to null if it does not define a language, or returns it otherwise.
    *
    * @param language The string.
-   * @return Whether the given string does not define a language.
+   * @return The string, optionally normalized to null if it does not define a language.
    */
-  protected static boolean stringDefinesNoLanguage(@Nullable String language) {
-    return TextUtils.isEmpty(language) || TextUtils.equals(language, C.LANGUAGE_UNDETERMINED);
+  @Nullable
+  protected static String normalizeUndeterminedLanguageToNull(@Nullable String language) {
+    return TextUtils.isEmpty(language) || TextUtils.equals(language, C.LANGUAGE_UNDETERMINED)
+        ? null
+        : language;
   }
 
   /**
@@ -2297,27 +2385,35 @@ protected static boolean stringDefinesNoLanguage(@Nullable String language) {
    *
    * @param format The {@link Format}.
    * @param language The language, or null.
-   * @return A score of 3 if the languages match fully, a score of 2 if the languages match partly,
-   *     a score of 1 if the languages don't match but belong to the same main language, and a score
-   *     of 0 if the languages don't match at all.
+   * @param allowUndeterminedFormatLanguage Whether matches with an empty or undetermined format
+   *     language tag are allowed.
+   * @return A score of 4 if the languages match fully, a score of 3 if the languages match partly,
+   *     a score of 2 if the languages don't match but belong to the same main language, a score of
+   *     1 if the format language is undetermined and such a match is allowed, and a score of 0 if
+   *     the languages don't match at all.
    */
-  protected static int getFormatLanguageScore(Format format, @Nullable String language) {
-    if (format.language == null || language == null) {
-      return 0;
-    }
-    if (TextUtils.equals(format.language, language)) {
+  protected static int getFormatLanguageScore(
+      Format format, @Nullable String language, boolean allowUndeterminedFormatLanguage) {
+    if (!TextUtils.isEmpty(language) && language.equals(format.language)) {
+      // Full literal match of non-empty languages, including matches of an explicit "und" query.
+      return 4;
+    }
+    language = normalizeUndeterminedLanguageToNull(language);
+    String formatLanguage = normalizeUndeterminedLanguageToNull(format.language);
+    if (formatLanguage == null || language == null) {
+      // At least one of the languages is undetermined.
+      return allowUndeterminedFormatLanguage && formatLanguage == null ? 1 : 0;
+    }
+    if (formatLanguage.startsWith(language) || language.startsWith(formatLanguage)) {
+      // Partial match where one language is a subset of the other (e.g. "zh-hans" and "zh-hans-hk")
       return 3;
     }
-    // Partial match where one language is a subset of the other (e.g. "zho-hans" and "zho-hans-hk")
-    if (format.language.startsWith(language) || language.startsWith(format.language)) {
+    String formatMainLanguage = Util.splitAtFirst(formatLanguage, "-")[0];
+    String queryMainLanguage = Util.splitAtFirst(language, "-")[0];
+    if (formatMainLanguage.equals(queryMainLanguage)) {
+      // Partial match where only the main language tag is the same (e.g. "fr-fr" and "fr-ca")
       return 2;
     }
-    // Partial match where only the main language tag is the same (e.g. "fra-fr" and "fra-ca")
-    if (format.language.length() >= 3
-        && language.length() >= 3
-        && format.language.substring(0, 3).equals(language.substring(0, 3))) {
-      return 1;
-    }
     return 0;
   }
 
@@ -2390,11 +2486,28 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
     }
   }
 
+  /**
+   * Compares two integers in a safe way avoiding potential overflow.
+   *
+   * @param first The first value.
+   * @param second The second value.
+   * @return A negative integer if the first value is less than the second. Zero if they are equal.
+   *     A positive integer if the first value is greater than the second.
+   */
+  private static int compareInts(int first, int second) {
+    return first > second ? 1 : (second > first ? -1 : 0);
+  }
+
   /** Represents how well an audio track matches the selection {@link Parameters}. */
   protected static final class AudioTrackScore implements Comparable<AudioTrackScore> {
 
+    /**
+     * Whether the provided format is within the parameter constraints. If {@code false}, the format
+     * should not be selected.
+     */
     public final boolean isWithinConstraints;
 
+    @Nullable private final String language;
     private final Parameters parameters;
     private final boolean isWithinRendererCapabilities;
     private final int preferredLanguageScore;
@@ -2407,8 +2520,13 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
 
     public AudioTrackScore(Format format, Parameters parameters, int formatSupport) {
       this.parameters = parameters;
+      this.language = normalizeUndeterminedLanguageToNull(format.language);
       isWithinRendererCapabilities = isSupported(formatSupport, false);
-      preferredLanguageScore = getFormatLanguageScore(format, parameters.preferredAudioLanguage);
+      preferredLanguageScore =
+          getFormatLanguageScore(
+              format,
+              parameters.preferredAudioLanguage,
+              /* allowUndeterminedFormatLanguage= */ false);
       isDefaultSelectionFlag = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
       channelCount = format.channelCount;
       sampleRate = format.sampleRate;
@@ -2421,7 +2539,9 @@ public AudioTrackScore(Format format, Parameters parameters, int formatSupport)
       int bestMatchIndex = Integer.MAX_VALUE;
       int bestMatchScore = 0;
       for (int i = 0; i < localeLanguages.length; i++) {
-        int score = getFormatLanguageScore(format, localeLanguages[i]);
+        int score =
+            getFormatLanguageScore(
+                format, localeLanguages[i], /* allowUndeterminedFormatLanguage= */ false);
         if (score > 0) {
           bestMatchIndex = i;
           bestMatchScore = score;
@@ -2440,7 +2560,7 @@ public AudioTrackScore(Format format, Parameters parameters, int formatSupport)
      *     negative integer if this score is worse than the other.
      */
     @Override
-    public int compareTo(@NonNull AudioTrackScore other) {
+    public int compareTo(AudioTrackScore other) {
       if (this.isWithinRendererCapabilities != other.isWithinRendererCapabilities) {
         return this.isWithinRendererCapabilities ? 1 : -1;
       }
@@ -2474,22 +2594,14 @@ public int compareTo(@NonNull AudioTrackScore other) {
       if (this.sampleRate != other.sampleRate) {
         return resultSign * compareInts(this.sampleRate, other.sampleRate);
       }
-      return resultSign * compareInts(this.bitrate, other.bitrate);
+      if (Util.areEqual(this.language, other.language)) {
+        // Only compare bit rates of tracks with the same or unknown language.
+        return resultSign * compareInts(this.bitrate, other.bitrate);
+      }
+      return 0;
     }
   }
 
-  /**
-   * Compares two integers in a safe way and avoiding potential overflow.
-   *
-   * @param first The first value.
-   * @param second The second value.
-   * @return A negative integer if the first value is less than the second. Zero if they are equal.
-   *     A positive integer if the first value is greater than the second.
-   */
-  private static int compareInts(int first, int second) {
-    return first > second ? 1 : (second > first ? -1 : 0);
-  }
-
   private static final class AudioConfigurationTuple {
 
     public final int channelCount;
@@ -2525,4 +2637,88 @@ public int hashCode() {
 
   }
 
+  /** Represents how well a text track matches the selection {@link Parameters}. */
+  protected static final class TextTrackScore implements Comparable<TextTrackScore> {
+
+    /**
+     * Whether the provided format is within the parameter constraints. If {@code false}, the format
+     * should not be selected.
+     */
+    public final boolean isWithinConstraints;
+
+    private final boolean isWithinRendererCapabilities;
+    private final boolean isDefault;
+    private final boolean hasPreferredIsForcedFlag;
+    private final int preferredLanguageScore;
+    private final int preferredRoleFlagsScore;
+    private final int selectedAudioLanguageScore;
+    private final boolean hasCaptionRoleFlags;
+
+    public TextTrackScore(
+        Format format,
+        Parameters parameters,
+        int trackFormatSupport,
+        @Nullable String selectedAudioLanguage) {
+      isWithinRendererCapabilities =
+          isSupported(trackFormatSupport, /* allowExceedsCapabilities= */ false);
+      int maskedSelectionFlags =
+          format.selectionFlags & ~parameters.disabledTextTrackSelectionFlags;
+      isDefault = (maskedSelectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
+      boolean isForced = (maskedSelectionFlags & C.SELECTION_FLAG_FORCED) != 0;
+      preferredLanguageScore =
+          getFormatLanguageScore(
+              format, parameters.preferredTextLanguage, parameters.selectUndeterminedTextLanguage);
+      preferredRoleFlagsScore =
+          Integer.bitCount(format.roleFlags & parameters.preferredTextRoleFlags);
+      hasCaptionRoleFlags =
+          (format.roleFlags & (C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND)) != 0;
+      // Prefer non-forced to forced if a preferred text language has been matched. Where both are
+      // provided the non-forced track will usually contain the forced subtitles as a subset.
+      // Otherwise, prefer a forced track.
+      hasPreferredIsForcedFlag =
+          (preferredLanguageScore > 0 && !isForced) || (preferredLanguageScore == 0 && isForced);
+      boolean selectedAudioLanguageUndetermined =
+          normalizeUndeterminedLanguageToNull(selectedAudioLanguage) == null;
+      selectedAudioLanguageScore =
+          getFormatLanguageScore(format, selectedAudioLanguage, selectedAudioLanguageUndetermined);
+      isWithinConstraints =
+          preferredLanguageScore > 0
+              || (parameters.preferredTextLanguage == null && preferredRoleFlagsScore > 0)
+              || isDefault
+              || (isForced && selectedAudioLanguageScore > 0);
+    }
+
+    /**
+     * Compares this score with another.
+     *
+     * @param other The other score to compare to.
+     * @return A positive integer if this score is better than the other. Zero if they are equal. A
+     *     negative integer if this score is worse than the other.
+     */
+    @Override
+    public int compareTo(TextTrackScore other) {
+      if (this.isWithinRendererCapabilities != other.isWithinRendererCapabilities) {
+        return this.isWithinRendererCapabilities ? 1 : -1;
+      }
+      if (this.preferredLanguageScore != other.preferredLanguageScore) {
+        return compareInts(this.preferredLanguageScore, other.preferredLanguageScore);
+      }
+      if (this.preferredRoleFlagsScore != other.preferredRoleFlagsScore) {
+        return compareInts(this.preferredRoleFlagsScore, other.preferredRoleFlagsScore);
+      }
+      if (this.isDefault != other.isDefault) {
+        return this.isDefault ? 1 : -1;
+      }
+      if (this.hasPreferredIsForcedFlag != other.hasPreferredIsForcedFlag) {
+        return this.hasPreferredIsForcedFlag ? 1 : -1;
+      }
+      if (this.selectedAudioLanguageScore != other.selectedAudioLanguageScore) {
+        return compareInts(this.selectedAudioLanguageScore, other.selectedAudioLanguageScore);
+      }
+      if (preferredRoleFlagsScore == 0 && this.hasCaptionRoleFlags != other.hasCaptionRoleFlags) {
+        return this.hasCaptionRoleFlags ? -1 : 1;
+      }
+      return 0;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/TrackSelectionParameters.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/TrackSelectionParameters.java
index 0f4e0ef013..ecc6861295 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/TrackSelectionParameters.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/trackselection/TrackSelectionParameters.java
@@ -35,6 +35,7 @@
     @Nullable /* package */ String preferredAudioLanguage;
     // Text
     @Nullable /* package */ String preferredTextLanguage;
+    @C.RoleFlags /* package */ int preferredTextRoleFlags;
     /* package */ boolean selectUndeterminedTextLanguage;
     @C.SelectionFlags /* package */ int disabledTextTrackSelectionFlags;
 
@@ -52,14 +53,16 @@ public Builder() {
       preferredAudioLanguage = initialValues.preferredAudioLanguage;
       // Text
       preferredTextLanguage = initialValues.preferredTextLanguage;
+      preferredTextRoleFlags = initialValues.preferredTextRoleFlags;
       selectUndeterminedTextLanguage = initialValues.selectUndeterminedTextLanguage;
       disabledTextTrackSelectionFlags = initialValues.disabledTextTrackSelectionFlags;
     }
 
     /**
-     * See {@link TrackSelectionParameters#preferredAudioLanguage}.
+     * Sets the preferred language for audio and forced text tracks.
      *
-     * @param preferredAudioLanguage Preferred audio language as an IETF BCP 47 conformant tag.
+     * @param preferredAudioLanguage Preferred audio language as an IETF BCP 47 conformant tag, or
+     *     {@code null} to select the default track, or the first track if there's no default.
      * @return This builder.
      */
     public Builder setPreferredAudioLanguage(@Nullable String preferredAudioLanguage) {
@@ -70,9 +73,10 @@ public Builder setPreferredAudioLanguage(@Nullable String preferredAudioLanguage
     // Text
 
     /**
-     * See {@link TrackSelectionParameters#preferredTextLanguage}.
+     * Sets the preferred language for text tracks.
      *
-     * @param preferredTextLanguage Preferred text language as an IETF BCP 47 conformant tag.
+     * @param preferredTextLanguage Preferred text language as an IETF BCP 47 conformant tag, or
+     *     {@code null} to select the default track if there is one, or no track otherwise.
      * @return This builder.
      */
     public Builder setPreferredTextLanguage(@Nullable String preferredTextLanguage) {
@@ -81,8 +85,23 @@ public Builder setPreferredTextLanguage(@Nullable String preferredTextLanguage)
     }
 
     /**
-     * See {@link TrackSelectionParameters#selectUndeterminedTextLanguage}.
+     * Sets the preferred {@link C.RoleFlags} for text tracks.
      *
+     * @param preferredTextRoleFlags Preferred text role flags.
+     * @return This builder.
+     */
+    public Builder setPreferredTextRoleFlags(@C.RoleFlags int preferredTextRoleFlags) {
+      this.preferredTextRoleFlags = preferredTextRoleFlags;
+      return this;
+    }
+
+    /**
+     * Sets whether a text track with undetermined language should be selected if no track with
+     * {@link #setPreferredTextLanguage(String)} is available, or if the preferred language is
+     * unset.
+     *
+     * @param selectUndeterminedTextLanguage Whether a text track with undetermined language should
+     *     be selected if no preferred language track is available.
      * @return This builder.
      */
     public Builder setSelectUndeterminedTextLanguage(boolean selectUndeterminedTextLanguage) {
@@ -91,8 +110,10 @@ public Builder setSelectUndeterminedTextLanguage(boolean selectUndeterminedTextL
     }
 
     /**
-     * See {@link TrackSelectionParameters#disabledTextTrackSelectionFlags}.
+     * Sets a bitmask of selection flags that are disabled for text track selections.
      *
+     * @param disabledTextTrackSelectionFlags A bitmask of {@link C.SelectionFlags} that are
+     *     disabled for text track selections.
      * @return This builder.
      */
     public Builder setDisabledTextTrackSelectionFlags(
@@ -108,6 +129,7 @@ public TrackSelectionParameters build() {
           preferredAudioLanguage,
           // Text
           preferredTextLanguage,
+          preferredTextRoleFlags,
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags);
     }
@@ -128,6 +150,11 @@ public TrackSelectionParameters build() {
    * track if there is one, or no track otherwise. The default value is {@code null}.
    */
   @Nullable public final String preferredTextLanguage;
+  /**
+   * The preferred {@link C.RoleFlags} for text tracks. {@code 0} selects the default track if there
+   * is one, or no track otherwise. The default value is {@code 0}.
+   */
+  @C.RoleFlags public final int preferredTextRoleFlags;
   /**
    * Whether a text track with undetermined language should be selected if no track with {@link
    * #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset. The
@@ -145,6 +172,7 @@ public TrackSelectionParameters build() {
         /* preferredAudioLanguage= */ null,
         // Text
         /* preferredTextLanguage= */ null,
+        /* preferredTextRoleFlags= */ 0,
         /* selectUndeterminedTextLanguage= */ false,
         /* disabledTextTrackSelectionFlags= */ 0);
   }
@@ -152,12 +180,14 @@ public TrackSelectionParameters build() {
   /* package */ TrackSelectionParameters(
       @Nullable String preferredAudioLanguage,
       @Nullable String preferredTextLanguage,
+      @C.RoleFlags int preferredTextRoleFlags,
       boolean selectUndeterminedTextLanguage,
       @C.SelectionFlags int disabledTextTrackSelectionFlags) {
     // Audio
     this.preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
     // Text
     this.preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+    this.preferredTextRoleFlags = preferredTextRoleFlags;
     this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
     this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
   }
@@ -167,6 +197,7 @@ public TrackSelectionParameters build() {
     this.preferredAudioLanguage = in.readString();
     // Text
     this.preferredTextLanguage = in.readString();
+    this.preferredTextRoleFlags = in.readInt();
     this.selectUndeterminedTextLanguage = Util.readBoolean(in);
     this.disabledTextTrackSelectionFlags = in.readInt();
   }
@@ -189,6 +220,7 @@ public boolean equals(@Nullable Object obj) {
     return TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
         // Text
         && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage)
+        && preferredTextRoleFlags == other.preferredTextRoleFlags
         && selectUndeterminedTextLanguage == other.selectUndeterminedTextLanguage
         && disabledTextTrackSelectionFlags == other.disabledTextTrackSelectionFlags;
   }
@@ -200,6 +232,7 @@ public int hashCode() {
     result = 31 * result + (preferredAudioLanguage == null ? 0 : preferredAudioLanguage.hashCode());
     // Text
     result = 31 * result + (preferredTextLanguage == null ? 0 : preferredTextLanguage.hashCode());
+    result = 31 * result + preferredTextRoleFlags;
     result = 31 * result + (selectUndeterminedTextLanguage ? 1 : 0);
     result = 31 * result + disabledTextTrackSelectionFlags;
     return result;
@@ -218,6 +251,7 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(preferredAudioLanguage);
     // Text
     dest.writeString(preferredTextLanguage);
+    dest.writeInt(preferredTextRoleFlags);
     Util.writeBoolean(dest, selectUndeterminedTextLanguage);
     dest.writeInt(disabledTextTrackSelectionFlags);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSource.java
index d9ccb57d8a..a9962d8956 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSource.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2VRT.upstream;
 
+import static com.google.android.exoplayer2VRT.util.Util.castNonNull;
+
 import android.net.Uri;
 import androidx.annotation.Nullable;
 import android.util.Base64;
@@ -29,9 +31,10 @@
 
   public static final String SCHEME_DATA = "data";
 
-  private @Nullable DataSpec dataSpec;
-  private int bytesRead;
-  private @Nullable byte[] data;
+  @Nullable private DataSpec dataSpec;
+  @Nullable private byte[] data;
+  private int endPosition;
+  private int readPosition;
 
   public DataSchemeDataSource() {
     super(/* isNetwork= */ false);
@@ -41,6 +44,7 @@ public DataSchemeDataSource() {
   public long open(DataSpec dataSpec) throws IOException {
     transferInitializing(dataSpec);
     this.dataSpec = dataSpec;
+    readPosition = (int) dataSpec.position;
     Uri uri = dataSpec.uri;
     String scheme = uri.getScheme();
     if (!SCHEME_DATA.equals(scheme)) {
@@ -61,8 +65,14 @@ public long open(DataSpec dataSpec) throws IOException {
       // TODO: Add support for other charsets.
       data = Util.getUtf8Bytes(URLDecoder.decode(dataString, C.ASCII_NAME));
     }
+    endPosition =
+        dataSpec.length != C.LENGTH_UNSET ? (int) dataSpec.length + readPosition : data.length;
+    if (endPosition > data.length || readPosition > endPosition) {
+      data = null;
+      throw new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE);
+    }
     transferStarted(dataSpec);
-    return data.length;
+    return (long) endPosition - readPosition;
   }
 
   @Override
@@ -70,29 +80,29 @@ public int read(byte[] buffer, int offset, int readLength) {
     if (readLength == 0) {
       return 0;
     }
-    int remainingBytes = data.length - bytesRead;
+    int remainingBytes = endPosition - readPosition;
     if (remainingBytes == 0) {
       return C.RESULT_END_OF_INPUT;
     }
     readLength = Math.min(readLength, remainingBytes);
-    System.arraycopy(data, bytesRead, buffer, offset, readLength);
-    bytesRead += readLength;
+    System.arraycopy(castNonNull(data), readPosition, buffer, offset, readLength);
+    readPosition += readLength;
     bytesTransferred(readLength);
     return readLength;
   }
 
   @Override
-  public @Nullable Uri getUri() {
+  @Nullable
+  public Uri getUri() {
     return dataSpec != null ? dataSpec.uri : null;
   }
 
   @Override
-  public void close() throws IOException {
+  public void close() {
     if (data != null) {
       data = null;
       transferEnded();
     }
     dataSpec = null;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSpec.java
index ca124ac9bc..58bd47a40d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DataSpec.java
@@ -68,7 +68,7 @@
    * setting this flag may also enable more concurrent access to the data (e.g. reading one fragment
    * whilst writing another).
    */
-  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 4; // 8
+  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 3; // 8
 
   /**
    * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultBandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultBandwidthMeter.java
index 59a0a7e456..3a18310d35 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultBandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultBandwidthMeter.java
@@ -100,6 +100,7 @@ public Builder(Context context) {
       initialBitrateEstimates = getInitialBitrateEstimatesForCountry(Util.getCountryCode(context));
       slidingWindowMaxWeight = DEFAULT_SLIDING_WINDOW_MAX_WEIGHT;
       clock = Clock.DEFAULT;
+      resetOnNetworkTypeChange = true;
     }
 
     /**
@@ -168,14 +169,12 @@ public Builder setClock(Clock clock) {
     }
 
     /**
-     * Sets whether to reset if the network type changes.
-     *
-     * <p>This method is experimental, and will be renamed or removed in a future release.
+     * Sets whether to reset if the network type changes. The default value is {@code true}.
      *
      * @param resetOnNetworkTypeChange Whether to reset if the network type changes.
      * @return This builder.
      */
-    public Builder experimental_resetOnNetworkTypeChange(boolean resetOnNetworkTypeChange) {
+    public Builder setResetOnNetworkTypeChange(boolean resetOnNetworkTypeChange) {
       this.resetOnNetworkTypeChange = resetOnNetworkTypeChange;
       return this;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultDataSource.java
index 3470894931..e269d2a9ca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultDataSource.java
@@ -42,6 +42,7 @@
  *   <li>rtmp: For fetching data over RTMP. Only supported if the project using ExoPlayer has an
  *       explicit dependency on ExoPlayer's RTMP extension.
  *   <li>data: For parsing data inlined in the URI as defined in RFC 2397.
+ *   <li>udp: For fetching data over UDP (e.g. udp://something.com/media).
  *   <li>http(s): For fetching data over HTTP and HTTPS (e.g. https://www.something.com/media.mp4),
  *       if constructed using {@link #DefaultDataSource(Context, TransferListener, String,
  *       boolean)}, or any other schemes supported by a base data source if constructed using {@link
@@ -55,6 +56,7 @@
   private static final String SCHEME_ASSET = "asset";
   private static final String SCHEME_CONTENT = "content";
   private static final String SCHEME_RTMP = "rtmp";
+  private static final String SCHEME_UDP = "udp";
   private static final String SCHEME_RAW = RawResourceDataSource.RAW_RESOURCE_SCHEME;
 
   private final Context context;
@@ -62,12 +64,13 @@
   private final DataSource baseDataSource;
 
   // Lazily initialized.
-  private @Nullable DataSource fileDataSource;
-  private @Nullable DataSource assetDataSource;
-  private @Nullable DataSource contentDataSource;
-  private @Nullable DataSource rtmpDataSource;
-  private @Nullable DataSource dataSchemeDataSource;
-  private @Nullable DataSource rawResourceDataSource;
+  @Nullable private DataSource fileDataSource;
+  @Nullable private DataSource assetDataSource;
+  @Nullable private DataSource contentDataSource;
+  @Nullable private DataSource rtmpDataSource;
+  @Nullable private DataSource udpDataSource;
+  @Nullable private DataSource dataSchemeDataSource;
+  @Nullable private DataSource rawResourceDataSource;
 
   private @Nullable DataSource dataSource;
 
@@ -218,6 +221,7 @@ public void addTransferListener(TransferListener transferListener) {
     maybeAddListenerToDataSource(assetDataSource, transferListener);
     maybeAddListenerToDataSource(contentDataSource, transferListener);
     maybeAddListenerToDataSource(rtmpDataSource, transferListener);
+    maybeAddListenerToDataSource(udpDataSource, transferListener);
     maybeAddListenerToDataSource(dataSchemeDataSource, transferListener);
     maybeAddListenerToDataSource(rawResourceDataSource, transferListener);
   }
@@ -240,6 +244,8 @@ public long open(DataSpec dataSpec) throws IOException {
       dataSource = getContentDataSource();
     } else if (SCHEME_RTMP.equals(scheme)) {
       dataSource = getRtmpDataSource();
+    } else if (SCHEME_UDP.equals(scheme)) {
+      dataSource = getUdpDataSource();
     } else if (DataSchemeDataSource.SCHEME_DATA.equals(scheme)) {
       dataSource = getDataSchemeDataSource();
     } else if (SCHEME_RAW.equals(scheme)) {
@@ -277,6 +283,14 @@ public void close() throws IOException {
     }
   }
 
+  private DataSource getUdpDataSource() {
+    if (udpDataSource == null) {
+      udpDataSource = new UdpDataSource();
+      addListenersToDataSource(udpDataSource);
+    }
+    return udpDataSource;
+  }
+
   private DataSource getFileDataSource() {
     if (fileDataSource == null) {
       fileDataSource = new FileDataSource();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultHttpDataSource.java
index 5c130b632e..72a8bbbdba 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/DefaultHttpDataSource.java
@@ -82,6 +82,7 @@
   private @Nullable HttpURLConnection connection;
   private @Nullable InputStream inputStream;
   private boolean opened;
+  private int responseCode;
 
   private long bytesToSkip;
   private long bytesToRead;
@@ -252,6 +253,11 @@ public DefaultHttpDataSource(
     return connection == null ? null : Uri.parse(connection.getURL().toString());
   }
 
+  @Override
+  public int getResponseCode() {
+    return connection == null || responseCode <= 0 ? -1 : responseCode;
+  }
+
   @Override
   public Map<String, List<String>> getResponseHeaders() {
     return connection == null ? Collections.emptyMap() : connection.getHeaderFields();
@@ -288,7 +294,6 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
           dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
-    int responseCode;
     String responseMessage;
     try {
       responseCode = connection.getResponseCode();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/HttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/HttpDataSource.java
index f1821e2e81..fa9c904159 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/HttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/HttpDataSource.java
@@ -354,6 +354,12 @@ public InvalidResponseCodeException(
    */
   void clearAllRequestProperties();
 
+  /**
+   * When the source is open, returns the HTTP response status code associated with the last {@link
+   * #open} call. Otherwise, returns a negative value.
+   */
+  int getResponseCode();
+
   @Override
   Map<String, List<String>> getResponseHeaders();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/LoadErrorHandlingPolicy.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/LoadErrorHandlingPolicy.java
index 9351142d05..785b607287 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/LoadErrorHandlingPolicy.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/LoadErrorHandlingPolicy.java
@@ -44,8 +44,8 @@
    *
    * @param dataType One of the {@link C C.DATA_TYPE_*} constants indicating the type of data to
    *     load.
-   * @param loadDurationMs The duration in milliseconds of the load up to the point at which the
-   *     error occurred, including any previous attempts.
+   * @param loadDurationMs The duration in milliseconds of the load from the start of the first load
+   *     attempt up to the point at which the error occurred.
    * @param exception The load error.
    * @param errorCount The number of errors this load has encountered, including this one.
    * @return The blacklist duration in milliseconds, or {@link C#TIME_UNSET} if the resource should
@@ -64,8 +64,8 @@ long getBlacklistDurationMsFor(
    *
    * @param dataType One of the {@link C C.DATA_TYPE_*} constants indicating the type of data to
    *     load.
-   * @param loadDurationMs The duration in milliseconds of the load up to the point at which the
-   *     error occurred, including any previous attempts.
+   * @param loadDurationMs The duration in milliseconds of the load from the start of the first load
+   *     attempt up to the point at which the error occurred.
    * @param exception The load error.
    * @param errorCount The number of errors this load has encountered, including this one.
    * @return The number of milliseconds to wait before attempting the load again, or {@link
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/Loader.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/Loader.java
index dd5e375f8b..4f4470b48b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/Loader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/Loader.java
@@ -213,6 +213,19 @@ public static LoadErrorAction createRetryAction(boolean resetErrorCount, long re
         retryDelayMillis);
   }
 
+  /**
+   * Whether the last call to {@link #startLoading} resulted in a fatal error. Calling {@link
+   * #maybeThrowError()} will throw the fatal error.
+   */
+  public boolean hasFatalError() {
+    return fatalError != null;
+  }
+
+  /** Clears any stored fatal error. */
+  public void clearFatalError() {
+    fatalError = null;
+  }
+
   /**
    * Starts loading a {@link Loadable}.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/ResolvingDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/ResolvingDataSource.java
new file mode 100644
index 0000000000..966474eb45
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/ResolvingDataSource.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.upstream;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/** {@link DataSource} wrapper allowing just-in-time resolution of {@link DataSpec DataSpecs}. */
+public final class ResolvingDataSource implements DataSource {
+
+  /** Resolves {@link DataSpec DataSpecs}. */
+  public interface Resolver {
+
+    /**
+     * Resolves a {@link DataSpec} before forwarding it to the wrapped {@link DataSource}. This
+     * method is allowed to block until the {@link DataSpec} has been resolved.
+     *
+     * <p>Note that this method is called for every new connection, so caching of results is
+     * recommended, especially if network operations are involved.
+     *
+     * @param dataSpec The original {@link DataSpec}.
+     * @return The resolved {@link DataSpec}.
+     * @throws IOException If an {@link IOException} occurred while resolving the {@link DataSpec}.
+     */
+    DataSpec resolveDataSpec(DataSpec dataSpec) throws IOException;
+
+    /**
+     * Resolves a URI reported by {@link DataSource#getUri()} for event reporting and caching
+     * purposes.
+     *
+     * <p>Implementations do not need to overwrite this method unless they want to change the
+     * reported URI.
+     *
+     * <p>This method is <em>not</em> allowed to block.
+     *
+     * @param uri The URI as reported by {@link DataSource#getUri()}.
+     * @return The resolved URI used for event reporting and caching.
+     */
+    default Uri resolveReportedUri(Uri uri) {
+      return uri;
+    }
+  }
+
+  /** {@link DataSource.Factory} for {@link ResolvingDataSource} instances. */
+  public static final class Factory implements DataSource.Factory {
+
+    private final DataSource.Factory upstreamFactory;
+    private final Resolver resolver;
+
+    /**
+     * Creates factory for {@link ResolvingDataSource} instances.
+     *
+     * @param upstreamFactory The wrapped {@link DataSource.Factory} handling the resolved {@link
+     *     DataSpec DataSpecs}.
+     * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
+     */
+    public Factory(DataSource.Factory upstreamFactory, Resolver resolver) {
+      this.upstreamFactory = upstreamFactory;
+      this.resolver = resolver;
+    }
+
+    @Override
+    public DataSource createDataSource() {
+      return new ResolvingDataSource(upstreamFactory.createDataSource(), resolver);
+    }
+  }
+
+  private final DataSource upstreamDataSource;
+  private final Resolver resolver;
+
+  private boolean upstreamOpened;
+
+  /**
+   * @param upstreamDataSource The wrapped {@link DataSource}.
+   * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
+   */
+  public ResolvingDataSource(DataSource upstreamDataSource, Resolver resolver) {
+    this.upstreamDataSource = upstreamDataSource;
+    this.resolver = resolver;
+  }
+
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstreamDataSource.addTransferListener(transferListener);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    DataSpec resolvedDataSpec = resolver.resolveDataSpec(dataSpec);
+    upstreamOpened = true;
+    return upstreamDataSource.open(resolvedDataSpec);
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    return upstreamDataSource.read(buffer, offset, readLength);
+  }
+
+  @Nullable
+  @Override
+  public Uri getUri() {
+    Uri reportedUri = upstreamDataSource.getUri();
+    return reportedUri == null ? null : resolver.resolveReportedUri(reportedUri);
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstreamDataSource.getResponseHeaders();
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (upstreamOpened) {
+      upstreamOpened = false;
+      upstreamDataSource.close();
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSink.java
index 6a2a25ddc3..a076b903c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSink.java
@@ -49,7 +49,6 @@
   private final long fragmentSize;
   private final int bufferSize;
 
-  private boolean syncFileDescriptor;
   private DataSpec dataSpec;
   private long dataSpecFragmentSize;
   private File file;
@@ -108,18 +107,6 @@ public CacheDataSink(Cache cache, long fragmentSize, int bufferSize) {
     this.cache = Assertions.checkNotNull(cache);
     this.fragmentSize = fragmentSize == C.LENGTH_UNSET ? Long.MAX_VALUE : fragmentSize;
     this.bufferSize = bufferSize;
-    syncFileDescriptor = true;
-  }
-
-  /**
-   * Sets whether file descriptors are synced when closing output streams.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   *
-   * @param syncFileDescriptor Whether file descriptors are synced when closing output streams.
-   */
-  public void experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
-    this.syncFileDescriptor = syncFileDescriptor;
   }
 
   @Override
@@ -208,9 +195,6 @@ private void closeCurrentOutputStream() throws IOException {
     boolean success = false;
     try {
       outputStream.flush();
-      if (syncFileDescriptor) {
-        underlyingFileOutputStream.getFD().sync();
-      }
       success = true;
     } finally {
       Util.closeQuietly(outputStream);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSinkFactory.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSinkFactory.java
index 7411851aa1..8d83e6cee4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSinkFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSinkFactory.java
@@ -26,8 +26,6 @@
   private final long fragmentSize;
   private final int bufferSize;
 
-  private boolean syncFileDescriptor;
-
   /** @see CacheDataSink#CacheDataSink(Cache, long) */
   public CacheDataSinkFactory(Cache cache, long fragmentSize) {
     this(cache, fragmentSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
@@ -40,20 +38,8 @@ public CacheDataSinkFactory(Cache cache, long fragmentSize, int bufferSize) {
     this.bufferSize = bufferSize;
   }
 
-  /**
-   * See {@link CacheDataSink#experimental_setSyncFileDescriptor(boolean)}.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   */
-  public CacheDataSinkFactory experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
-    this.syncFileDescriptor = syncFileDescriptor;
-    return this;
-  }
-
   @Override
   public DataSink createDataSink() {
-    CacheDataSink dataSink = new CacheDataSink(cache, fragmentSize, bufferSize);
-    dataSink.experimental_setSyncFileDescriptor(syncFileDescriptor);
-    return dataSink;
+    return new CacheDataSink(cache, fragmentSize, bufferSize);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSource.java
index 4988edfa1c..b9a60287e3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheDataSource.java
@@ -134,9 +134,9 @@
 
   private @Nullable DataSource currentDataSource;
   private boolean currentDataSpecLengthUnset;
-  private @Nullable Uri uri;
-  private @Nullable Uri actualUri;
-  private @HttpMethod int httpMethod;
+  @Nullable private Uri uri;
+  @Nullable private Uri actualUri;
+  @HttpMethod private int httpMethod;
   private int flags;
   private @Nullable String key;
   private long readPosition;
@@ -283,7 +283,7 @@ public long open(DataSpec dataSpec) throws IOException {
       }
       openNextSource(false);
       return bytesRemaining;
-    } catch (IOException e) {
+    } catch (Throwable e) {
       handleBeforeThrow(e);
       throw e;
     }
@@ -319,12 +319,15 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
       }
       return bytesRead;
     } catch (IOException e) {
-      if (currentDataSpecLengthUnset && isCausedByPositionOutOfRange(e)) {
+      if (currentDataSpecLengthUnset && CacheUtil.isCausedByPositionOutOfRange(e)) {
         setNoBytesRemainingAndMaybeStoreLength();
         return C.RESULT_END_OF_INPUT;
       }
       handleBeforeThrow(e);
       throw e;
+    } catch (Throwable e) {
+      handleBeforeThrow(e);
+      throw e;
     }
   }
 
@@ -349,7 +352,7 @@ public void close() throws IOException {
     notifyBytesRead();
     try {
       closeCurrentSource();
-    } catch (IOException e) {
+    } catch (Throwable e) {
       handleBeforeThrow(e);
       throw e;
     }
@@ -484,20 +487,6 @@ private static Uri getRedirectedUriOrDefault(Cache cache, String key, Uri defaul
     return redirectedUri != null ? redirectedUri : defaultUri;
   }
 
-  private static boolean isCausedByPositionOutOfRange(IOException e) {
-    Throwable cause = e;
-    while (cause != null) {
-      if (cause instanceof DataSourceException) {
-        int reason = ((DataSourceException) cause).reason;
-        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
-          return true;
-        }
-      }
-      cause = cause.getCause();
-    }
-    return false;
-  }
-
   private boolean isReadingFromUpstream() {
     return !isReadingFromCache();
   }
@@ -530,7 +519,7 @@ private void closeCurrentSource() throws IOException {
     }
   }
 
-  private void handleBeforeThrow(IOException exception) {
+  private void handleBeforeThrow(Throwable exception) {
     if (isReadingFromCache() || exception instanceof CacheException) {
       seenCacheError = true;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheUtil.java
index 4910a4f14d..589e1fa48f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/upstream/cache/CacheUtil.java
@@ -20,6 +20,7 @@
 import android.util.Pair;
 import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.upstream.DataSource;
+import com.google.android.exoplayer2VRT.upstream.DataSourceException;
 import com.google.android.exoplayer2VRT.upstream.DataSpec;
 import com.google.android.exoplayer2VRT.util.Assertions;
 import com.google.android.exoplayer2VRT.util.PriorityTaskManager;
@@ -78,13 +79,7 @@ public static String generateKey(Uri uri) {
       DataSpec dataSpec, Cache cache, @Nullable CacheKeyFactory cacheKeyFactory) {
     String key = buildCacheKey(dataSpec, cacheKeyFactory);
     long position = dataSpec.absoluteStreamPosition;
-    long requestLength;
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      requestLength = dataSpec.length;
-    } else {
-      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
-      requestLength = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
-    }
+    long requestLength = getRequestLength(dataSpec, cache, key);
     long bytesAlreadyCached = 0;
     long bytesLeft = requestLength;
     while (bytesLeft != 0) {
@@ -179,53 +174,66 @@ public static void cache(
     Assertions.checkNotNull(dataSource);
     Assertions.checkNotNull(buffer);
 
+    String key = buildCacheKey(dataSpec, cacheKeyFactory);
+    long bytesLeft;
     ProgressNotifier progressNotifier = null;
     if (progressListener != null) {
       progressNotifier = new ProgressNotifier(progressListener);
       Pair<Long, Long> lengthAndBytesAlreadyCached = getCached(dataSpec, cache, cacheKeyFactory);
       progressNotifier.init(lengthAndBytesAlreadyCached.first, lengthAndBytesAlreadyCached.second);
+      bytesLeft = lengthAndBytesAlreadyCached.first;
+    } else {
+      bytesLeft = getRequestLength(dataSpec, cache, key);
     }
 
-    String key = buildCacheKey(dataSpec, cacheKeyFactory);
     long position = dataSpec.absoluteStreamPosition;
-    long bytesLeft;
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      bytesLeft = dataSpec.length;
-    } else {
-      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
-      bytesLeft = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
-    }
+    boolean lengthUnset = bytesLeft == C.LENGTH_UNSET;
     while (bytesLeft != 0) {
       throwExceptionIfInterruptedOrCancelled(isCanceled);
       long blockLength =
-          cache.getCachedLength(
-              key, position, bytesLeft != C.LENGTH_UNSET ? bytesLeft : Long.MAX_VALUE);
+          cache.getCachedLength(key, position, lengthUnset ? Long.MAX_VALUE : bytesLeft);
       if (blockLength > 0) {
         // Skip already cached data.
       } else {
         // There is a hole in the cache which is at least "-blockLength" long.
         blockLength = -blockLength;
+        long length = blockLength == Long.MAX_VALUE ? C.LENGTH_UNSET : blockLength;
+        boolean isLastBlock = length == bytesLeft;
         long read =
             readAndDiscard(
                 dataSpec,
                 position,
-                blockLength,
+                length,
                 dataSource,
                 buffer,
                 priorityTaskManager,
                 priority,
                 progressNotifier,
+                isLastBlock,
                 isCanceled);
         if (read < blockLength) {
           // Reached to the end of the data.
-          if (enableEOFException && bytesLeft != C.LENGTH_UNSET) {
+          if (enableEOFException && !lengthUnset) {
             throw new EOFException();
           }
           break;
         }
       }
       position += blockLength;
-      bytesLeft -= bytesLeft == C.LENGTH_UNSET ? 0 : blockLength;
+      if (!lengthUnset) {
+        bytesLeft -= blockLength;
+      }
+    }
+  }
+
+  private static long getRequestLength(DataSpec dataSpec, Cache cache, String key) {
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      return dataSpec.length;
+    } else {
+      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
+      return contentLength == C.LENGTH_UNSET
+          ? C.LENGTH_UNSET
+          : contentLength - dataSpec.absoluteStreamPosition;
     }
   }
 
@@ -242,6 +250,7 @@ public static void cache(
    *     caching.
    * @param priority The priority of this task.
    * @param progressNotifier A notifier through which to report progress updates, or {@code null}.
+   * @param isLastBlock Whether this read block is the last block of the content.
    * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @return Number of read bytes, or 0 if no data is available because the end of the opened range
    *     has been reached.
@@ -255,54 +264,64 @@ private static long readAndDiscard(
       PriorityTaskManager priorityTaskManager,
       int priority,
       @Nullable ProgressNotifier progressNotifier,
+      boolean isLastBlock,
       AtomicBoolean isCanceled)
       throws IOException, InterruptedException {
     long positionOffset = absoluteStreamPosition - dataSpec.absoluteStreamPosition;
+    long initialPositionOffset = positionOffset;
+    long endOffset = length != C.LENGTH_UNSET ? positionOffset + length : C.POSITION_UNSET;
     while (true) {
       if (priorityTaskManager != null) {
         // Wait for any other thread with higher priority to finish its job.
         priorityTaskManager.proceed(priority);
       }
+      throwExceptionIfInterruptedOrCancelled(isCanceled);
       try {
-        throwExceptionIfInterruptedOrCancelled(isCanceled);
-        // Create a new dataSpec setting length to C.LENGTH_UNSET to prevent getting an error in
-        // case the given length exceeds the end of input.
-        dataSpec =
-            new DataSpec(
-                dataSpec.uri,
-                dataSpec.httpMethod,
-                dataSpec.httpBody,
-                absoluteStreamPosition,
-                /* position= */ dataSpec.position + positionOffset,
-                C.LENGTH_UNSET,
-                dataSpec.key,
-                dataSpec.flags);
-        long resolvedLength = dataSource.open(dataSpec);
-        if (progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
+        long resolvedLength = C.LENGTH_UNSET;
+        boolean isDataSourceOpen = false;
+        if (endOffset != C.POSITION_UNSET) {
+          // If a specific length is given, first try to open the data source for that length to
+          // avoid more data then required to be requested. If the given length exceeds the end of
+          // input we will get a "position out of range" error. In that case try to open the source
+          // again with unset length.
+          try {
+            resolvedLength =
+                dataSource.open(dataSpec.subrange(positionOffset, endOffset - positionOffset));
+            isDataSourceOpen = true;
+          } catch (IOException exception) {
+            if (!isLastBlock || !isCausedByPositionOutOfRange(exception)) {
+              throw exception;
+            }
+            Util.closeQuietly(dataSource);
+          }
+        }
+        if (!isDataSourceOpen) {
+          resolvedLength = dataSource.open(dataSpec.subrange(positionOffset, C.LENGTH_UNSET));
+        }
+        if (isLastBlock && progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
           progressNotifier.onRequestLengthResolved(positionOffset + resolvedLength);
         }
-        long totalBytesRead = 0;
-        while (totalBytesRead != length) {
+        while (positionOffset != endOffset) {
           throwExceptionIfInterruptedOrCancelled(isCanceled);
           int bytesRead =
               dataSource.read(
                   buffer,
                   0,
-                  length != C.LENGTH_UNSET
-                      ? (int) Math.min(buffer.length, length - totalBytesRead)
+                  endOffset != C.POSITION_UNSET
+                      ? (int) Math.min(buffer.length, endOffset - positionOffset)
                       : buffer.length);
           if (bytesRead == C.RESULT_END_OF_INPUT) {
             if (progressNotifier != null) {
-              progressNotifier.onRequestLengthResolved(positionOffset + totalBytesRead);
+              progressNotifier.onRequestLengthResolved(positionOffset);
             }
             break;
           }
-          totalBytesRead += bytesRead;
+          positionOffset += bytesRead;
           if (progressNotifier != null) {
             progressNotifier.onBytesCached(bytesRead);
           }
         }
-        return totalBytesRead;
+        return positionOffset - initialPositionOffset;
       } catch (PriorityTaskManager.PriorityTooLowException exception) {
         // catch and try again
       } finally {
@@ -340,6 +359,20 @@ public static void remove(Cache cache, String key) {
     }
   }
 
+  /* package */ static boolean isCausedByPositionOutOfRange(IOException e) {
+    Throwable cause = e;
+    while (cause != null) {
+      if (cause instanceof DataSourceException) {
+        int reason = ((DataSourceException) cause).reason;
+        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
+          return true;
+        }
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
   private static String buildCacheKey(
       DataSpec dataSpec, @Nullable CacheKeyFactory cacheKeyFactory) {
     return (cacheKeyFactory != null ? cacheKeyFactory : DEFAULT_CACHE_KEY_FACTORY)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/AtomicFile.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/AtomicFile.java
index 38f56b574f..631705fe0a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/AtomicFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/AtomicFile.java
@@ -108,8 +108,9 @@ public OutputStream startWrite() throws IOException {
     } catch (FileNotFoundException e) {
       File parent = baseName.getParentFile();
       if (parent == null || !parent.mkdirs()) {
-        throw new IOException("Couldn't create directory " + baseName, e);
+        throw new IOException("Couldn't create " + baseName, e);
       }
+      // Try again now that we've created the parent directory.
       try {
         str = new AtomicFileOutputStream(baseName);
       } catch (FileNotFoundException e2) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/FlacStreamInfo.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/FlacStreamMetadata.java
similarity index 64%
rename from library/core/src/main/java/com/google/android/exoplayer2VRT/util/FlacStreamInfo.java
rename to library/core/src/main/java/com/google/android/exoplayer2VRT/util/FlacStreamMetadata.java
index dfc8614676..81b292d56b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/FlacStreamInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/FlacStreamMetadata.java
@@ -15,12 +15,18 @@
  */
 package com.google.android.exoplayer2VRT.util;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2VRT.C;
+import com.google.android.exoplayer2VRT.metadata.Metadata;
+import com.google.android.exoplayer2VRT.metadata.flac.PictureFrame;
+import com.google.android.exoplayer2VRT.metadata.flac.VorbisComment;
+import java.util.ArrayList;
+import java.util.List;
 
-/**
- * Holder for FLAC stream info.
- */
-public final class FlacStreamInfo {
+/** Holder for FLAC metadata. */
+public final class FlacStreamMetadata {
+
+  private static final String TAG = "FlacStreamMetadata";
 
   public final int minBlockSize;
   public final int maxBlockSize;
@@ -30,16 +36,19 @@
   public final int channels;
   public final int bitsPerSample;
   public final long totalSamples;
+  @Nullable public final Metadata metadata;
+
+  private static final String SEPARATOR = "=";
 
   /**
-   * Constructs a FlacStreamInfo parsing the given binary FLAC stream info metadata structure.
+   * Parses binary FLAC stream info metadata.
    *
-   * @param data An array holding FLAC stream info metadata structure
-   * @param offset Offset of the structure in the array
+   * @param data An array containing binary FLAC stream info metadata.
+   * @param offset The offset of the stream info metadata in {@code data}.
    * @see <a href="https://xiph.org/flac/format.html#metadata_block_streaminfo">FLAC format
    *     METADATA_BLOCK_STREAMINFO</a>
    */
-  public FlacStreamInfo(byte[] data, int offset) {
+  public FlacStreamMetadata(byte[] data, int offset) {
     ParsableBitArray scratch = new ParsableBitArray(data);
     scratch.setPosition(offset * 8);
     this.minBlockSize = scratch.readBits(16);
@@ -49,14 +58,11 @@ public FlacStreamInfo(byte[] data, int offset) {
     this.sampleRate = scratch.readBits(20);
     this.channels = scratch.readBits(3) + 1;
     this.bitsPerSample = scratch.readBits(5) + 1;
-    this.totalSamples = ((scratch.readBits(4) & 0xFL) << 32)
-        | (scratch.readBits(32) & 0xFFFFFFFFL);
-    // Remaining 16 bytes is md5 value
+    this.totalSamples = ((scratch.readBits(4) & 0xFL) << 32) | (scratch.readBits(32) & 0xFFFFFFFFL);
+    this.metadata = null;
   }
 
   /**
-   * Constructs a FlacStreamInfo given the parameters.
-   *
    * @param minBlockSize Minimum block size of the FLAC stream.
    * @param maxBlockSize Maximum block size of the FLAC stream.
    * @param minFrameSize Minimum frame size of the FLAC stream.
@@ -65,10 +71,16 @@ public FlacStreamInfo(byte[] data, int offset) {
    * @param channels Number of channels of the FLAC stream.
    * @param bitsPerSample Number of bits per sample of the FLAC stream.
    * @param totalSamples Total samples of the FLAC stream.
+   * @param vorbisComments Vorbis comments. Each entry must be in key=value form.
+   * @param pictureFrames Picture frames.
    * @see <a href="https://xiph.org/flac/format.html#metadata_block_streaminfo">FLAC format
    *     METADATA_BLOCK_STREAMINFO</a>
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_vorbis_comment">FLAC format
+   *     METADATA_BLOCK_VORBIS_COMMENT</a>
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_picture">FLAC format
+   *     METADATA_BLOCK_PICTURE</a>
    */
-  public FlacStreamInfo(
+  public FlacStreamMetadata(
       int minBlockSize,
       int maxBlockSize,
       int minFrameSize,
@@ -76,7 +88,9 @@ public FlacStreamInfo(
       int sampleRate,
       int channels,
       int bitsPerSample,
-      long totalSamples) {
+      long totalSamples,
+      List<String> vorbisComments,
+      List<PictureFrame> pictureFrames) {
     this.minBlockSize = minBlockSize;
     this.maxBlockSize = maxBlockSize;
     this.minFrameSize = minFrameSize;
@@ -85,6 +99,7 @@ public FlacStreamInfo(
     this.channels = channels;
     this.bitsPerSample = bitsPerSample;
     this.totalSamples = totalSamples;
+    this.metadata = buildMetadata(vorbisComments, pictureFrames);
   }
 
   /** Returns the maximum size for a decoded frame from the FLAC stream. */
@@ -126,4 +141,27 @@ public long getApproxBytesPerFrame() {
     }
     return approxBytesPerFrame;
   }
+
+  @Nullable
+  private static Metadata buildMetadata(
+      List<String> vorbisComments, List<PictureFrame> pictureFrames) {
+    if (vorbisComments.isEmpty() && pictureFrames.isEmpty()) {
+      return null;
+    }
+
+    ArrayList<Metadata.Entry> metadataEntries = new ArrayList<>();
+    for (int i = 0; i < vorbisComments.size(); i++) {
+      String vorbisComment = vorbisComments.get(i);
+      String[] keyAndValue = Util.splitAtFirst(vorbisComment, SEPARATOR);
+      if (keyAndValue.length != 2) {
+        Log.w(TAG, "Failed to parse vorbis comment: " + vorbisComment);
+      } else {
+        VorbisComment entry = new VorbisComment(keyAndValue[0], keyAndValue[1]);
+        metadataEntries.add(entry);
+      }
+    }
+    metadataEntries.addAll(pictureFrames);
+
+    return metadataEntries.isEmpty() ? null : new Metadata(metadataEntries);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/MimeTypes.java
index 14b7224d10..130595229b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/MimeTypes.java
@@ -348,8 +348,9 @@ public static int getTrackType(@Nullable String mimeType) {
       case MimeTypes.AUDIO_AC3:
         return C.ENCODING_AC3;
       case MimeTypes.AUDIO_E_AC3:
-      case MimeTypes.AUDIO_E_AC3_JOC:
         return C.ENCODING_E_AC3;
+      case MimeTypes.AUDIO_E_AC3_JOC:
+        return C.ENCODING_E_AC3_JOC;
       case MimeTypes.AUDIO_AC4:
         return C.ENCODING_AC4;
       case MimeTypes.AUDIO_DTS:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/NotificationUtil.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/NotificationUtil.java
index 4870c7689b..9b6a72f430 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/NotificationUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/NotificationUtil.java
@@ -61,6 +61,14 @@
   /** @see NotificationManager#IMPORTANCE_HIGH */
   public static final int IMPORTANCE_HIGH = NotificationManager.IMPORTANCE_HIGH;
 
+  /** @deprecated Use {@link #createNotificationChannel(Context, String, int, int, int)}. */
+  @Deprecated
+  public static void createNotificationChannel(
+      Context context, String id, @StringRes int nameResourceId, @Importance int importance) {
+    createNotificationChannel(
+        context, id, nameResourceId, /* descriptionResourceId= */ 0, importance);
+  }
+
   /**
    * Creates a notification channel that notifications can be posted to. See {@link
    * NotificationChannel} and {@link
@@ -70,21 +78,33 @@
    * @param id The id of the channel. Must be unique per package. The value may be truncated if it's
    *     too long.
    * @param nameResourceId A string resource identifier for the user visible name of the channel.
-   *     You can rename this channel when the system locale changes by listening for the {@link
-   *     Intent#ACTION_LOCALE_CHANGED} broadcast. The recommended maximum length is 40 characters.
-   *     The value may be truncated if it is too long.
+   *     The recommended maximum length is 40 characters. The string may be truncated if it's too
+   *     long. You can rename the channel when the system locale changes by listening for the {@link
+   *     Intent#ACTION_LOCALE_CHANGED} broadcast.
+   * @param descriptionResourceId A string resource identifier for the user visible description of
+   *     the channel, or 0 if no description is provided. The recommended maximum length is 300
+   *     characters. The value may be truncated if it is too long. You can change the description of
+   *     the channel when the system locale changes by listening for the {@link
+   *     Intent#ACTION_LOCALE_CHANGED} broadcast.
    * @param importance The importance of the channel. This controls how interruptive notifications
    *     posted to this channel are. One of {@link #IMPORTANCE_UNSPECIFIED}, {@link
    *     #IMPORTANCE_NONE}, {@link #IMPORTANCE_MIN}, {@link #IMPORTANCE_LOW}, {@link
    *     #IMPORTANCE_DEFAULT} and {@link #IMPORTANCE_HIGH}.
    */
   public static void createNotificationChannel(
-      Context context, String id, @StringRes int nameResourceId, @Importance int importance) {
+      Context context,
+      String id,
+      @StringRes int nameResourceId,
+      @StringRes int descriptionResourceId,
+      @Importance int importance) {
     if (Util.SDK_INT >= 26) {
       NotificationManager notificationManager =
           (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
       NotificationChannel channel =
           new NotificationChannel(id, context.getString(nameResourceId), importance);
+      if (descriptionResourceId != 0) {
+        channel.setDescription(context.getString(descriptionResourceId));
+      }
       notificationManager.createNotificationChannel(channel);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/Util.java
index f0cb4f8562..596f9369c5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/util/Util.java
@@ -71,6 +71,7 @@
 import java.util.Collections;
 import java.util.Formatter;
 import java.util.GregorianCalendar;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.MissingResourceException;
@@ -135,6 +136,10 @@
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
   private static final Pattern ESCAPED_CHARACTER_PATTERN = Pattern.compile("%([A-Fa-f0-9]{2})");
 
+  // Android standardizes to ISO 639-1 2-letter codes and provides no way to map a 3-letter
+  // ISO 639-2 code back to the corresponding 2-letter code.
+  @Nullable private static HashMap<String, String> languageTagIso3ToIso2;
+
   private Util() {}
 
   /**
@@ -450,18 +455,31 @@ public static void writeBoolean(Parcel parcel, boolean value) {
     if (language == null) {
       return null;
     }
-    try {
-      Locale locale = getLocaleForLanguageTag(language);
-      int localeLanguageLength = locale.getLanguage().length();
-      String normLanguage = locale.getISO3Language();
-      if (normLanguage.isEmpty()) {
-        return toLowerInvariant(language);
+    // Locale data (especially for API < 21) may produce tags with '_' instead of the
+    // standard-conformant '-'.
+    String normalizedTag = language.replace('_', '-');
+    if (Util.SDK_INT >= 21) {
+      // Filters out ill-formed sub-tags, replaces deprecated tags and normalizes all valid tags.
+      normalizedTag = normalizeLanguageCodeSyntaxV21(normalizedTag);
+    }
+    if (normalizedTag.isEmpty() || "und".equals(normalizedTag)) {
+      // Tag isn't valid, keep using the original.
+      normalizedTag = language;
+    }
+    normalizedTag = Util.toLowerInvariant(normalizedTag);
+    String mainLanguage = Util.splitAtFirst(normalizedTag, "-")[0];
+    if (mainLanguage.length() == 3) {
+      // 3-letter ISO 639-2/B or ISO 639-2/T language codes will not be converted to 2-letter ISO
+      // 639-1 codes automatically.
+      if (languageTagIso3ToIso2 == null) {
+        languageTagIso3ToIso2 = createIso3ToIso2Map();
+      }
+      String iso2Language = languageTagIso3ToIso2.get(mainLanguage);
+      if (iso2Language != null) {
+        normalizedTag = iso2Language + normalizedTag.substring(/* beginIndex= */ 3);
       }
-      String normTag = getLocaleLanguageTag(locale);
-      return toLowerInvariant(normLanguage + normTag.substring(localeLanguageLength));
-    } catch (MissingResourceException e) {
-      return toLowerInvariant(language);
     }
+    return normalizedTag;
   }
 
   /**
@@ -1512,35 +1530,6 @@ public static String getStringForTime(StringBuilder builder, Formatter formatter
         : formatter.format("%02d:%02d", minutes, seconds).toString();
   }
 
-  /**
-   * Maps a {@link C} {@code TRACK_TYPE_*} constant to the corresponding {@link C} {@code
-   * DEFAULT_*_BUFFER_SIZE} constant.
-   *
-   * @param trackType The track type.
-   * @return The corresponding default buffer size in bytes.
-   * @throws IllegalArgumentException If the track type is an unrecognized or custom track type.
-   */
-  public static int getDefaultBufferSize(int trackType) {
-    switch (trackType) {
-      case C.TRACK_TYPE_DEFAULT:
-        return C.DEFAULT_MUXED_BUFFER_SIZE;
-      case C.TRACK_TYPE_AUDIO:
-        return C.DEFAULT_AUDIO_BUFFER_SIZE;
-      case C.TRACK_TYPE_VIDEO:
-        return C.DEFAULT_VIDEO_BUFFER_SIZE;
-      case C.TRACK_TYPE_TEXT:
-        return C.DEFAULT_TEXT_BUFFER_SIZE;
-      case C.TRACK_TYPE_METADATA:
-        return C.DEFAULT_METADATA_BUFFER_SIZE;
-      case C.TRACK_TYPE_CAMERA_MOTION:
-        return C.DEFAULT_CAMERA_MOTION_BUFFER_SIZE;
-      case C.TRACK_TYPE_NONE:
-        return 0;
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
-
   /**
    * Escapes a string so that it's safe for use as a file or directory name on at least FAT32
    * filesystems. FAT32 is the most restrictive of all filesystems still commonly used today.
@@ -1713,7 +1702,12 @@ public static int getNetworkType(Context context) {
     if (connectivityManager == null) {
       return C.NETWORK_TYPE_UNKNOWN;
     }
-    networkInfo = connectivityManager.getActiveNetworkInfo();
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (SecurityException e) {
+      // Expected if permission was revoked.
+      return C.NETWORK_TYPE_UNKNOWN;
+    }
     if (networkInfo == null || !networkInfo.isConnected()) {
       return C.NETWORK_TYPE_OFFLINE;
     }
@@ -1950,32 +1944,25 @@ private static void getDisplaySizeV16(Display display, Point outSize) {
   }
 
   private static String[] getSystemLocales() {
+    Configuration config = Resources.getSystem().getConfiguration();
     return SDK_INT >= 24
-        ? getSystemLocalesV24()
-        : new String[] {getLocaleLanguageTag(Resources.getSystem().getConfiguration().locale)};
+        ? getSystemLocalesV24(config)
+        : SDK_INT >= 21 ? getSystemLocaleV21(config) : new String[] {config.locale.toString()};
   }
 
   @TargetApi(24)
-  private static String[] getSystemLocalesV24() {
-    return Util.split(Resources.getSystem().getConfiguration().getLocales().toLanguageTags(), ",");
-  }
-
-  private static Locale getLocaleForLanguageTag(String languageTag) {
-    return Util.SDK_INT >= 21 ? getLocaleForLanguageTagV21(languageTag) : new Locale(languageTag);
+  private static String[] getSystemLocalesV24(Configuration config) {
+    return Util.split(config.getLocales().toLanguageTags(), ",");
   }
 
   @TargetApi(21)
-  private static Locale getLocaleForLanguageTagV21(String languageTag) {
-    return Locale.forLanguageTag(languageTag);
-  }
-
-  private static String getLocaleLanguageTag(Locale locale) {
-    return SDK_INT >= 21 ? getLocaleLanguageTagV21(locale) : locale.toString();
+  private static String[] getSystemLocaleV21(Configuration config) {
+    return new String[] {config.locale.toLanguageTag()};
   }
 
   @TargetApi(21)
-  private static String getLocaleLanguageTagV21(Locale locale) {
-    return locale.toLanguageTag();
+  private static String normalizeLanguageCodeSyntaxV21(String languageTag) {
+    return Locale.forLanguageTag(languageTag).toLanguageTag();
   }
 
   private static @C.NetworkType int getMobileNetworkType(NetworkInfo networkInfo) {
@@ -2008,6 +1995,54 @@ private static String getLocaleLanguageTagV21(Locale locale) {
     }
   }
 
+  private static HashMap<String, String> createIso3ToIso2Map() {
+    String[] iso2Languages = Locale.getISOLanguages();
+    HashMap<String, String> iso3ToIso2 =
+        new HashMap<>(
+            /* initialCapacity= */ iso2Languages.length + iso3BibliographicalToIso2.length);
+    for (String iso2 : iso2Languages) {
+      try {
+        // This returns the ISO 639-2/T code for the language.
+        String iso3 = new Locale(iso2).getISO3Language();
+        if (!TextUtils.isEmpty(iso3)) {
+          iso3ToIso2.put(iso3, iso2);
+        }
+      } catch (MissingResourceException e) {
+        // Shouldn't happen for list of known languages, but we don't want to throw either.
+      }
+    }
+    // Add additional ISO 639-2/B codes to mapping.
+    for (int i = 0; i < iso3BibliographicalToIso2.length; i += 2) {
+      iso3ToIso2.put(iso3BibliographicalToIso2[i], iso3BibliographicalToIso2[i + 1]);
+    }
+    return iso3ToIso2;
+  }
+
+  // See https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes.
+  private static final String[] iso3BibliographicalToIso2 =
+      new String[] {
+        "alb", "sq",
+        "arm", "hy",
+        "baq", "eu",
+        "bur", "my",
+        "tib", "bo",
+        "chi", "zh",
+        "cze", "cs",
+        "dut", "nl",
+        "ger", "de",
+        "gre", "el",
+        "fre", "fr",
+        "geo", "ka",
+        "ice", "is",
+        "mac", "mk",
+        "mao", "mi",
+        "may", "ms",
+        "per", "fa",
+        "rum", "ro",
+        "slo", "sk",
+        "wel", "cy"
+      };
+
   /**
    * Allows the CRC calculation to be done byte by byte instead of bit per bit being the order
    * "most significant bit first".
diff --git a/library/core/src/main/java/com/google/android/exoplayer2VRT/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2VRT/video/MediaCodecVideoRenderer.java
index 0a974857a8..0519ebda0e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2VRT/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2VRT/video/MediaCodecVideoRenderer.java
@@ -550,12 +550,13 @@ protected void configureCodec(
       MediaCodec codec,
       Format format,
       MediaCrypto crypto,
-      float codecOperatingRate)
-      throws DecoderQueryException {
+      float codecOperatingRate) {
+    String codecMimeType = codecInfo.codecMimeType;
     codecMaxValues = getCodecMaxValues(codecInfo, format, getStreamFormats());
     MediaFormat mediaFormat =
         getMediaFormat(
             format,
+            codecMimeType,
             codecMaxValues,
             codecOperatingRate,
             deviceNeedsNoPostProcessWorkaround,
@@ -680,7 +681,8 @@ protected boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException {
     if (initialPositionUs == C.TIME_UNSET) {
@@ -689,7 +691,7 @@ protected boolean processOutputBuffer(
 
     long presentationTimeUs = bufferPresentationTimeUs - outputStreamOffsetUs;
 
-    if (shouldSkip) {
+    if (isDecodeOnlyBuffer && !isLastBuffer) {
       skipOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -737,10 +739,10 @@ protected boolean processOutputBuffer(
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
+    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs, isLastBuffer)
         && maybeDropBuffersToKeyframe(codec, bufferIndex, presentationTimeUs, positionUs)) {
       return false;
-    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
+    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs, isLastBuffer)) {
       dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -808,8 +810,8 @@ private void notifyFrameMetadataListener(
 
   /**
    * Returns the offset that should be subtracted from {@code bufferPresentationTimeUs} in {@link
-   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, Format)} to
-   * get the playback position with respect to the media.
+   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, boolean,
+   * Format)} to get the playback position with respect to the media.
    */
   protected long getOutputStreamOffsetUs() {
     return outputStreamOffsetUs;
@@ -861,9 +863,11 @@ protected void onProcessedOutputBuffer(long presentationTimeUs) {
    *     indicates that the buffer is late.
    * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
    *     measured at the start of the current iteration of the rendering loop.
+   * @param isLastBuffer Whether the buffer is the last buffer in the current stream.
    */
-  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferLate(earlyUs);
+  protected boolean shouldDropOutputBuffer(
+      long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {
+    return isBufferLate(earlyUs) && !isLastBuffer;
   }
 
   /**
@@ -874,9 +878,11 @@ protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
    *     negative value indicates that the buffer is late.
    * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
    *     measured at the start of the current iteration of the rendering loop.
+   * @param isLastBuffer Whether the buffer is the last buffer in the current stream.
    */
-  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferVeryLate(earlyUs);
+  protected boolean shouldDropBuffersToKeyframe(
+      long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {
+    return isBufferVeryLate(earlyUs) && !isLastBuffer;
   }
 
   /**
@@ -1107,6 +1113,7 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
    * Returns the framework {@link MediaFormat} that should be used to configure the decoder.
    *
    * @param format The format of media.
+   * @param codecMimeType The MIME type handled by the codec.
    * @param codecMaxValues Codec max values that should be used when configuring the decoder.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
@@ -1119,13 +1126,14 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
   @SuppressLint("InlinedApi")
   protected MediaFormat getMediaFormat(
       Format format,
+      String codecMimeType,
       CodecMaxValues codecMaxValues,
       float codecOperatingRate,
       boolean deviceNeedsNoPostProcessWorkaround,
       int tunnelingAudioSessionId) {
     MediaFormat mediaFormat = new MediaFormat();
     // Set format parameters that should always be set.
-    mediaFormat.setString(MediaFormat.KEY_MIME, format.sampleMimeType);
+    mediaFormat.setString(MediaFormat.KEY_MIME, codecMimeType);
     mediaFormat.setInteger(MediaFormat.KEY_WIDTH, format.width);
     mediaFormat.setInteger(MediaFormat.KEY_HEIGHT, format.height);
     MediaFormatUtil.setCsdBuffers(mediaFormat, format.initializationData);
@@ -1173,11 +1181,9 @@ protected MediaFormat getMediaFormat(
    * @param format The format for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
   protected CodecMaxValues getCodecMaxValues(
-      MediaCodecInfo codecInfo, Format format, Format[] streamFormats)
-      throws DecoderQueryException {
+      MediaCodecInfo codecInfo, Format format, Format[] streamFormats) {
     int maxWidth = format.width;
     int maxHeight = format.height;
     int maxInputSize = getMaxInputSize(codecInfo, format);
@@ -1227,17 +1233,15 @@ protected CodecMaxValues getCodecMaxValues(
   }
 
   /**
-   * Returns a maximum video size to use when configuring a codec for {@code format} in a way
-   * that will allow possible adaptation to other compatible formats that are expected to have the
-   * same aspect ratio, but whose sizes are unknown.
+   * Returns a maximum video size to use when configuring a codec for {@code format} in a way that
+   * will allow possible adaptation to other compatible formats that are expected to have the same
+   * aspect ratio, but whose sizes are unknown.
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format for which the codec is being configured.
    * @return The maximum video size to use, or null if the size of {@code format} should be used.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
-      throws DecoderQueryException {
+  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format) {
     boolean isVerticalVideo = format.height > format.width;
     int formatLongEdgePx = isVerticalVideo ? format.height : format.width;
     int formatShortEdgePx = isVerticalVideo ? format.width : format.height;
@@ -1255,12 +1259,18 @@ private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
           return alignedSize;
         }
       } else {
-        // Conservatively assume the codec requires 16px width and height alignment.
-        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
-        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
-        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
-          return new Point(isVerticalVideo ? shortEdgePx : longEdgePx,
-              isVerticalVideo ? longEdgePx : shortEdgePx);
+        try {
+          // Conservatively assume the codec requires 16px width and height alignment.
+          longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
+          shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
+          if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
+            return new Point(
+                isVerticalVideo ? shortEdgePx : longEdgePx,
+                isVerticalVideo ? longEdgePx : shortEdgePx);
+          }
+        } catch (DecoderQueryException e) {
+          // We tried our best. Give up!
+          return null;
         }
       }
     }
@@ -1423,6 +1433,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
             case "1713":
             case "1714":
             case "A10-70F":
+            case "A10-70L":
             case "A1601":
             case "A2016a40":
             case "A7000-a":
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/webvtt/with_css_styles b/library/core/src/test/assets/webvtt/with_css_styles
index 2056d50adf..c2d47d8192 100644
--- a/library/core/src/test/assets/webvtt/with_css_styles
+++ b/library/core/src/test/assets/webvtt/with_css_styles
@@ -13,8 +13,6 @@ STYLE
 ::cue(#id2) {
   color: peachpuff;
 }
-
-STYLE
 ::cue(v[voice="LaGord"]) { background-color: lime }
 
 STYLE
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/ExoPlayerTest.java
index 12ecab29a3..04c87a9df0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/ExoPlayerTest.java
@@ -20,6 +20,7 @@
 
 import android.content.Context;
 import android.graphics.SurfaceTexture;
+import android.net.Uri;
 import androidx.annotation.Nullable;
 import android.view.Surface;
 import androidx.test.core.app.ApplicationProvider;
@@ -2608,6 +2609,56 @@ public void run(SimpleExoPlayer player) {
     assertThat(bufferedPositionAtFirstDiscontinuityMs.get()).isEqualTo(C.usToMs(windowDurationUs));
   }
 
+  @Test
+  public void contentWithInitialSeekPositionAfterPrerollAdStartsAtSeekPosition() throws Exception {
+    AdPlaybackState adPlaybackState =
+        FakeTimeline.createAdPlaybackState(/* adsPerAdGroup= */ 3, /* adGroupTimesUs= */ 0)
+            .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, Uri.parse("https://ad1"))
+            .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 1, Uri.parse("https://ad2"))
+            .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 2, Uri.parse("https://ad3"));
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount= */ 1,
+                /* id= */ 0,
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 10_000_000,
+                adPlaybackState));
+    final FakeMediaSource fakeMediaSource = new FakeMediaSource(fakeTimeline, null);
+    AtomicReference<Player> playerReference = new AtomicReference<>();
+    AtomicLong contentStartPositionMs = new AtomicLong(C.TIME_UNSET);
+    EventListener eventListener =
+        new EventListener() {
+          @Override
+          public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+            if (reason == Player.DISCONTINUITY_REASON_AD_INSERTION) {
+              contentStartPositionMs.set(playerReference.get().getContentPosition());
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("contentWithInitialSeekAfterPrerollAd")
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    playerReference.set(player);
+                    player.addListener(eventListener);
+                  }
+                })
+            .seek(5_000)
+            .build();
+    new ExoPlayerTestRunner.Builder()
+        .setMediaSource(fakeMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(contentStartPositionMs.get()).isAtLeast(5_000L);
+  }
+
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSinkTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSinkTest.java
index fc590a628b..0fa3faaf86 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSinkTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/audio/DefaultAudioSinkTest.java
@@ -67,6 +67,13 @@ public void setUp() {
             /* enableConvertHighResIntPcmToFloat= */ false);
   }
 
+  @Test
+  public void handlesSpecializedAudioProcessorArray() {
+    defaultAudioSink =
+        new DefaultAudioSink(
+            AudioCapabilities.DEFAULT_AUDIO_CAPABILITIES, new TeeAudioProcessor[0]);
+  }
+
   @Test
   public void handlesBufferAfterReset() throws Exception {
     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerTest.java
index 2d754d3e0f..d2854bb46d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerTest.java
@@ -16,13 +16,16 @@
 package com.google.android.exoplayer2VRT.extractor.ogg;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2VRT.C;
+import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
 import com.google.android.exoplayer2VRT.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2VRT.testutil.OggTestData;
+import com.google.android.exoplayer2VRT.testutil.TestUtil;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.Random;
 import org.junit.Test;
@@ -32,13 +35,15 @@
 @RunWith(AndroidJUnit4.class)
 public final class DefaultOggSeekerTest {
 
+  private final Random random = new Random(0);
+
   @Test
   public void testSetupWithUnsetEndPositionFails() {
     try {
       new DefaultOggSeeker(
-          /* startPosition= */ 0,
-          /* endPosition= */ C.LENGTH_UNSET,
           /* streamReader= */ new TestStreamReader(),
+          /* payloadStartPosition= */ 0,
+          /* payloadEndPosition= */ C.LENGTH_UNSET,
           /* firstPayloadPageSize= */ 1,
           /* firstPayloadPageGranulePosition= */ 1,
           /* firstPayloadPageIsLastPage= */ false);
@@ -56,17 +61,106 @@ public void testSeeking() throws IOException, InterruptedException {
     }
   }
 
+  @Test
+  public void testSkipToNextPage() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                TestUtil.buildTestData(4000, random),
+                new byte[] {'O', 'g', 'g', 'S'},
+                TestUtil.buildTestData(4000, random)),
+            false);
+    skipToNextPage(extractorInput);
+    assertThat(extractorInput.getPosition()).isEqualTo(4000);
+  }
+
+  @Test
+  public void testSkipToNextPageOverlap() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                TestUtil.buildTestData(2046, random),
+                new byte[] {'O', 'g', 'g', 'S'},
+                TestUtil.buildTestData(4000, random)),
+            false);
+    skipToNextPage(extractorInput);
+    assertThat(extractorInput.getPosition()).isEqualTo(2046);
+  }
+
+  @Test
+  public void testSkipToNextPageInputShorterThanPeekLength() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(new byte[] {'x', 'O', 'g', 'g', 'S'}), false);
+    skipToNextPage(extractorInput);
+    assertThat(extractorInput.getPosition()).isEqualTo(1);
+  }
+
+  @Test
+  public void testSkipToNextPageNoMatch() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(new byte[] {'g', 'g', 'S', 'O', 'g', 'g'}, false);
+    try {
+      skipToNextPage(extractorInput);
+      fail();
+    } catch (EOFException e) {
+      // expected
+    }
+  }
+
+  @Test
+  public void testReadGranuleOfLastPage() throws IOException, InterruptedException {
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                TestUtil.buildTestData(100, random),
+                OggTestData.buildOggHeader(0x00, 20000, 66, 3),
+                TestUtil.createByteArray(254, 254, 254), // laces
+                TestUtil.buildTestData(3 * 254, random),
+                OggTestData.buildOggHeader(0x00, 40000, 67, 3),
+                TestUtil.createByteArray(254, 254, 254), // laces
+                TestUtil.buildTestData(3 * 254, random),
+                OggTestData.buildOggHeader(0x05, 60000, 68, 3),
+                TestUtil.createByteArray(254, 254, 254), // laces
+                TestUtil.buildTestData(3 * 254, random)),
+            false);
+    assertReadGranuleOfLastPage(input, 60000);
+  }
+
+  @Test
+  public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, InterruptedException {
+    FakeExtractorInput input = OggTestData.createInput(TestUtil.buildTestData(100, random), false);
+    try {
+      assertReadGranuleOfLastPage(input, 60000);
+      fail();
+    } catch (EOFException e) {
+      // Ignored.
+    }
+  }
+
+  @Test
+  public void testReadGranuleOfLastPageWithUnboundedLength()
+      throws IOException, InterruptedException {
+    FakeExtractorInput input = OggTestData.createInput(new byte[0], true);
+    try {
+      assertReadGranuleOfLastPage(input, 60000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Ignored.
+    }
+  }
+
   private void testSeeking(Random random) throws IOException, InterruptedException {
     OggTestFile testFile = OggTestFile.generate(random, 1000);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(testFile.data).build();
     TestStreamReader streamReader = new TestStreamReader();
     DefaultOggSeeker oggSeeker =
         new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ testFile.data.length,
             /* streamReader= */ streamReader,
+            /* payloadStartPosition= */ 0,
+            /* payloadEndPosition= */ testFile.data.length,
             /* firstPayloadPageSize= */ testFile.firstPayloadPageSize,
-            /* firstPayloadPageGranulePosition= */ testFile.firstPayloadPageGranulePosition,
+            /* firstPayloadPageGranulePosition= */ testFile.firstPayloadPageGranuleCount,
             /* firstPayloadPageIsLastPage= */ false);
     OggPageHeader pageHeader = new OggPageHeader();
 
@@ -78,89 +172,96 @@ private void testSeeking(Random random) throws IOException, InterruptedException
       input.setPosition((int) nextSeekPosition);
     }
 
-    // Test granule 0 from file start
-    assertThat(seekTo(input, oggSeeker, 0, 0)).isEqualTo(0);
+    // Test granule 0 from file start.
+    long granule = seekTo(input, oggSeeker, 0, 0);
+    assertThat(granule).isEqualTo(0);
     assertThat(input.getPosition()).isEqualTo(0);
 
-    // Test granule 0 from file end
-    assertThat(seekTo(input, oggSeeker, 0, testFile.data.length - 1)).isEqualTo(0);
+    // Test granule 0 from file end.
+    granule = seekTo(input, oggSeeker, 0, testFile.data.length - 1);
+    assertThat(granule).isEqualTo(0);
     assertThat(input.getPosition()).isEqualTo(0);
 
-    { // Test last granule
-      long currentGranule = seekTo(input, oggSeeker, testFile.lastGranule, 0);
-      long position = testFile.data.length;
-      assertThat(
-              (testFile.lastGranule > currentGranule && position > input.getPosition())
-                  || (testFile.lastGranule == currentGranule && position == input.getPosition()))
-          .isTrue();
-    }
-
-    { // Test exact granule
-      input.setPosition(testFile.data.length / 2);
-      oggSeeker.skipToNextPage(input);
-      assertThat(pageHeader.populate(input, true)).isTrue();
-      long position = input.getPosition() + pageHeader.headerSize + pageHeader.bodySize;
-      long currentGranule = seekTo(input, oggSeeker, pageHeader.granulePosition, 0);
-      assertThat(
-              (pageHeader.granulePosition > currentGranule && position > input.getPosition())
-                  || (pageHeader.granulePosition == currentGranule
-                      && position == input.getPosition()))
-          .isTrue();
-    }
+    // Test last granule.
+    granule = seekTo(input, oggSeeker, testFile.granuleCount - 1, 0);
+    assertThat(granule).isEqualTo(testFile.granuleCount - testFile.lastPayloadPageGranuleCount);
+    assertThat(input.getPosition()).isEqualTo(testFile.data.length - testFile.lastPayloadPageSize);
 
     for (int i = 0; i < 100; i += 1) {
-      long targetGranule = (long) (random.nextDouble() * testFile.lastGranule);
+      long targetGranule = random.nextInt(testFile.granuleCount);
       int initialPosition = random.nextInt(testFile.data.length);
-
-      long currentGranule = seekTo(input, oggSeeker, targetGranule, initialPosition);
+      granule = seekTo(input, oggSeeker, targetGranule, initialPosition);
       long currentPosition = input.getPosition();
-
-      assertWithMessage("getNextSeekPosition() didn't leave input on a page start.")
-          .that(pageHeader.populate(input, true))
-          .isTrue();
-
-      if (currentGranule == 0) {
+      if (granule == 0) {
         assertThat(currentPosition).isEqualTo(0);
       } else {
         int previousPageStart = testFile.findPreviousPageStart(currentPosition);
         input.setPosition(previousPageStart);
-        assertThat(pageHeader.populate(input, true)).isTrue();
-        assertThat(currentGranule).isEqualTo(pageHeader.granulePosition);
+        pageHeader.populate(input, false);
+        assertThat(granule).isEqualTo(pageHeader.granulePosition);
       }
 
       input.setPosition((int) currentPosition);
-      oggSeeker.skipToPageOfGranule(input, targetGranule, -1);
-      long positionDiff = Math.abs(input.getPosition() - currentPosition);
-
-      long granuleDiff = currentGranule - targetGranule;
-      if ((granuleDiff > DefaultOggSeeker.MATCH_RANGE || granuleDiff < 0)
-          && positionDiff > DefaultOggSeeker.MATCH_BYTE_RANGE) {
-        fail(
-            "granuleDiff ("
-                + granuleDiff
-                + ") or positionDiff ("
-                + positionDiff
-                + ") is more than allowed.");
+      pageHeader.populate(input, false);
+      // The target granule should be within the current page.
+      assertThat(granule).isAtMost(targetGranule);
+      assertThat(targetGranule).isLessThan(pageHeader.granulePosition);
+    }
+  }
+
+  private static void skipToNextPage(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* streamReader= */ new FlacReader(),
+            /* payloadStartPosition= */ 0,
+            /* payloadEndPosition= */ extractorInput.getLength(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
+    while (true) {
+      try {
+        oggSeeker.skipToNextPage(extractorInput);
+        break;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        /* ignored */
       }
     }
   }
 
-  private long seekTo(
+  private static void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
+      throws IOException, InterruptedException {
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* streamReader= */ new FlacReader(),
+            /* payloadStartPosition= */ 0,
+            /* payloadEndPosition= */ input.getLength(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
+    while (true) {
+      try {
+        assertThat(oggSeeker.readGranuleOfLastPage(input)).isEqualTo(expected);
+        break;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        // Ignored.
+      }
+    }
+  }
+
+  private static long seekTo(
       FakeExtractorInput input, DefaultOggSeeker oggSeeker, long targetGranule, int initialPosition)
       throws IOException, InterruptedException {
     long nextSeekPosition = initialPosition;
+    oggSeeker.startSeek(targetGranule);
     int count = 0;
-    oggSeeker.resetSeeking();
-
-    do {
-      input.setPosition((int) nextSeekPosition);
-      nextSeekPosition = oggSeeker.getNextSeekPosition(targetGranule, input);
-
+    while (nextSeekPosition >= 0) {
       if (count++ > 100) {
-        fail("infinite loop?");
+        fail("Seek failed to converge in 100 iterations");
       }
-    } while (nextSeekPosition >= 0);
-
+      input.setPosition((int) nextSeekPosition);
+      nextSeekPosition = oggSeeker.read(input);
+    }
     return -(nextSeekPosition + 2);
   }
 
@@ -171,8 +272,7 @@ protected long preparePayload(ParsableByteArray packet) {
     }
 
     @Override
-    protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
-        throws IOException, InterruptedException {
+    protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData) {
       return false;
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
deleted file mode 100644
index 1ebd7d57a2..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2VRT.extractor.ogg;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.android.exoplayer2VRT.extractor.ExtractorInput;
-import com.google.android.exoplayer2VRT.testutil.FakeExtractorInput;
-import com.google.android.exoplayer2VRT.testutil.OggTestData;
-import com.google.android.exoplayer2VRT.testutil.TestUtil;
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Random;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Unit test for {@link DefaultOggSeeker} utility methods. */
-@RunWith(AndroidJUnit4.class)
-public final class DefaultOggSeekerUtilMethodsTest {
-
-  private final Random random = new Random(0);
-
-  @Test
-  public void testSkipToNextPage() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            TestUtil.buildTestData(4000, random),
-            new byte[] {'O', 'g', 'g', 'S'},
-            TestUtil.buildTestData(4000, random)
-        ), false);
-    skipToNextPage(extractorInput);
-    assertThat(extractorInput.getPosition()).isEqualTo(4000);
-  }
-
-  @Test
-  public void testSkipToNextPageOverlap() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            TestUtil.buildTestData(2046, random),
-            new byte[] {'O', 'g', 'g', 'S'},
-            TestUtil.buildTestData(4000, random)
-        ), false);
-    skipToNextPage(extractorInput);
-    assertThat(extractorInput.getPosition()).isEqualTo(2046);
-  }
-
-  @Test
-  public void testSkipToNextPageInputShorterThanPeekLength() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            new byte[] {'x', 'O', 'g', 'g', 'S'}
-        ), false);
-    skipToNextPage(extractorInput);
-    assertThat(extractorInput.getPosition()).isEqualTo(1);
-  }
-
-  @Test
-  public void testSkipToNextPageNoMatch() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        new byte[] {'g', 'g', 'S', 'O', 'g', 'g'}, false);
-    try {
-      skipToNextPage(extractorInput);
-      fail();
-    } catch (EOFException e) {
-      // expected
-    }
-  }
-
-  private static void skipToNextPage(ExtractorInput extractorInput)
-      throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker =
-        new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ extractorInput.getLength(),
-            /* streamReader= */ new FlacReader(),
-            /* firstPayloadPageSize= */ 1,
-            /* firstPayloadPageGranulePosition= */ 2,
-            /* firstPayloadPageIsLastPage= */ false);
-    while (true) {
-      try {
-        oggSeeker.skipToNextPage(extractorInput);
-        break;
-      } catch (FakeExtractorInput.SimulatedIOException e) { /* ignored */ }
-    }
-  }
-
-  @Test
-  public void testSkipToPageOfGranule() throws IOException, InterruptedException {
-    byte[] packet = TestUtil.buildTestData(3 * 254, random);
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-
-    // expect to be granule of the previous page returned as elapsedSamples
-    skipToPageOfGranule(input, 54000, 40000);
-    // expect to be at the start of the third page
-    assertThat(input.getPosition()).isEqualTo(2 * (30 + (3 * 254)));
-  }
-
-  @Test
-  public void testSkipToPageOfGranulePreciseMatch() throws IOException, InterruptedException {
-    byte[] packet = TestUtil.buildTestData(3 * 254, random);
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-
-    skipToPageOfGranule(input, 40000, 20000);
-    // expect to be at the start of the second page
-    assertThat(input.getPosition()).isEqualTo(30 + (3 * 254));
-  }
-
-  @Test
-  public void testSkipToPageOfGranuleAfterTargetPage() throws IOException, InterruptedException {
-    byte[] packet = TestUtil.buildTestData(3 * 254, random);
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-
-    skipToPageOfGranule(input, 10000, -1);
-    assertThat(input.getPosition()).isEqualTo(0);
-  }
-
-  private void skipToPageOfGranule(ExtractorInput input, long granule,
-      long elapsedSamplesExpected) throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker =
-        new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ input.getLength(),
-            /* streamReader= */ new FlacReader(),
-            /* firstPayloadPageSize= */ 1,
-            /* firstPayloadPageGranulePosition= */ 2,
-            /* firstPayloadPageIsLastPage= */ false);
-    while (true) {
-      try {
-        assertThat(oggSeeker.skipToPageOfGranule(input, granule, -1))
-            .isEqualTo(elapsedSamplesExpected);
-        return;
-      } catch (FakeExtractorInput.SimulatedIOException e) {
-        input.resetPeekPosition();
-      }
-    }
-  }
-
-  @Test
-  public void testReadGranuleOfLastPage() throws IOException, InterruptedException {
-    FakeExtractorInput input = OggTestData.createInput(TestUtil.joinByteArrays(
-        TestUtil.buildTestData(100, random),
-        OggTestData.buildOggHeader(0x00, 20000, 66, 3),
-        TestUtil.createByteArray(254, 254, 254), // laces
-        TestUtil.buildTestData(3 * 254, random),
-        OggTestData.buildOggHeader(0x00, 40000, 67, 3),
-        TestUtil.createByteArray(254, 254, 254), // laces
-        TestUtil.buildTestData(3 * 254, random),
-        OggTestData.buildOggHeader(0x05, 60000, 68, 3),
-        TestUtil.createByteArray(254, 254, 254), // laces
-        TestUtil.buildTestData(3 * 254, random)
-    ), false);
-    assertReadGranuleOfLastPage(input, 60000);
-  }
-
-  @Test
-  public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, InterruptedException {
-    FakeExtractorInput input = OggTestData.createInput(TestUtil.buildTestData(100, random), false);
-    try {
-      assertReadGranuleOfLastPage(input, 60000);
-      fail();
-    } catch (EOFException e) {
-      // ignored
-    }
-  }
-
-  @Test
-  public void testReadGranuleOfLastPageWithUnboundedLength()
-      throws IOException, InterruptedException {
-    FakeExtractorInput input = OggTestData.createInput(new byte[0], true);
-    try {
-      assertReadGranuleOfLastPage(input, 60000);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // ignored
-    }
-  }
-
-  private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
-      throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker =
-        new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ input.getLength(),
-            /* streamReader= */ new FlacReader(),
-            /* firstPayloadPageSize= */ 1,
-            /* firstPayloadPageGranulePosition= */ 2,
-            /* firstPayloadPageIsLastPage= */ false);
-    while (true) {
-      try {
-        assertThat(oggSeeker.readGranuleOfLastPage(input)).isEqualTo(expected);
-        break;
-      } catch (FakeExtractorInput.SimulatedIOException e) {
-        // ignored
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/OggTestFile.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/OggTestFile.java
index 32d6f80651..f496feeff9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/OggTestFile.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/extractor/ogg/OggTestFile.java
@@ -30,35 +30,39 @@
   private static final int MAX_GRANULES_IN_PAGE = 100000;
 
   public final byte[] data;
-  public final long lastGranule;
-  public final int packetCount;
+  public final int granuleCount;
   public final int pageCount;
   public final int firstPayloadPageSize;
-  public final long firstPayloadPageGranulePosition;
+  public final int firstPayloadPageGranuleCount;
+  public final int lastPayloadPageSize;
+  public final int lastPayloadPageGranuleCount;
 
   private OggTestFile(
       byte[] data,
-      long lastGranule,
-      int packetCount,
+      int granuleCount,
       int pageCount,
       int firstPayloadPageSize,
-      long firstPayloadPageGranulePosition) {
+      int firstPayloadPageGranuleCount,
+      int lastPayloadPageSize,
+      int lastPayloadPageGranuleCount) {
     this.data = data;
-    this.lastGranule = lastGranule;
-    this.packetCount = packetCount;
+    this.granuleCount = granuleCount;
     this.pageCount = pageCount;
     this.firstPayloadPageSize = firstPayloadPageSize;
-    this.firstPayloadPageGranulePosition = firstPayloadPageGranulePosition;
+    this.firstPayloadPageGranuleCount = firstPayloadPageGranuleCount;
+    this.lastPayloadPageSize = lastPayloadPageSize;
+    this.lastPayloadPageGranuleCount = lastPayloadPageGranuleCount;
   }
 
   public static OggTestFile generate(Random random, int pageCount) {
     ArrayList<byte[]> fileData = new ArrayList<>();
     int fileSize = 0;
-    long granule = 0;
-    int packetLength = -1;
-    int packetCount = 0;
+    int granuleCount = 0;
     int firstPayloadPageSize = 0;
-    long firstPayloadPageGranulePosition = 0;
+    int firstPayloadPageGranuleCount = 0;
+    int lastPageloadPageSize = 0;
+    int lastPayloadPageGranuleCount = 0;
+    int packetLength = -1;
 
     for (int i = 0; i < pageCount; i++) {
       int headerType = 0x00;
@@ -71,17 +75,17 @@ public static OggTestFile generate(Random random, int pageCount) {
       if (i == pageCount - 1) {
         headerType |= 4;
       }
-      granule += random.nextInt(MAX_GRANULES_IN_PAGE - 1) + 1;
+      int pageGranuleCount = random.nextInt(MAX_GRANULES_IN_PAGE - 1) + 1;
       int pageSegmentCount = random.nextInt(MAX_SEGMENT_COUNT);
-      byte[] header = OggTestData.buildOggHeader(headerType, granule, 0, pageSegmentCount);
+      granuleCount += pageGranuleCount;
+      byte[] header = OggTestData.buildOggHeader(headerType, granuleCount, 0, pageSegmentCount);
       fileData.add(header);
-      fileSize += header.length;
+      int pageSize = header.length;
 
       byte[] laces = new byte[pageSegmentCount];
       int bodySize = 0;
       for (int j = 0; j < pageSegmentCount; j++) {
         if (packetLength < 0) {
-          packetCount++;
           if (i < pageCount - 1) {
             packetLength = random.nextInt(MAX_PACKET_LENGTH);
           } else {
@@ -96,14 +100,19 @@ public static OggTestFile generate(Random random, int pageCount) {
         packetLength -= 255;
       }
       fileData.add(laces);
-      fileSize += laces.length;
+      pageSize += laces.length;
 
       byte[] payload = TestUtil.buildTestData(bodySize, random);
       fileData.add(payload);
-      fileSize += payload.length;
+      pageSize += payload.length;
+
+      fileSize += pageSize;
       if (i == 0) {
-        firstPayloadPageSize = header.length + bodySize;
-        firstPayloadPageGranulePosition = granule;
+        firstPayloadPageSize = pageSize;
+        firstPayloadPageGranuleCount = pageGranuleCount;
+      } else if (i == pageCount - 1) {
+        lastPageloadPageSize = pageSize;
+        lastPayloadPageGranuleCount = pageGranuleCount;
       }
     }
 
@@ -115,11 +124,12 @@ public static OggTestFile generate(Random random, int pageCount) {
     }
     return new OggTestFile(
         file,
-        granule,
-        packetCount,
+        granuleCount,
         pageCount,
         firstPayloadPageSize,
-        firstPayloadPageGranulePosition);
+        firstPayloadPageGranuleCount,
+        lastPageloadPageSize,
+        lastPayloadPageGranuleCount);
   }
 
   public int findPreviousPageStart(long position) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/MetadataRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/MetadataRendererTest.java
new file mode 100644
index 0000000000..fcea343f7c
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/MetadataRendererTest.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.google.android.exoplayer2VRT.metadata;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2VRT.ExoPlaybackException;
+import com.google.android.exoplayer2VRT.Format;
+import com.google.android.exoplayer2VRT.metadata.Metadata;
+import com.google.android.exoplayer2VRT.metadata.MetadataRenderer;
+import com.google.android.exoplayer2VRT.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2VRT.metadata.emsg.EventMessageEncoder;
+import com.google.android.exoplayer2VRT.metadata.id3.TextInformationFrame;
+import com.google.android.exoplayer2VRT.metadata.scte35.TimeSignalCommand;
+import com.google.android.exoplayer2VRT.testutil.FakeSampleStream;
+import com.google.android.exoplayer2VRT.testutil.TestUtil;
+import com.google.android.exoplayer2VRT.util.Assertions;
+import com.google.android.exoplayer2VRT.util.MimeTypes;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests for {@link MetadataRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public class MetadataRendererTest {
+
+  private static final byte[] SCTE35_TIME_SIGNAL_BYTES =
+      TestUtil.joinByteArrays(
+          TestUtil.createByteArray(
+              0, // table_id.
+              0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+              0x14, // section_length(8).
+              0x00, // protocol_version.
+              0x00), // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+          TestUtil.createByteArray(0x00, 0x00, 0x00, 0x00), // pts_adjustment(32).
+          TestUtil.createByteArray(
+              0x00, // cw_index.
+              0x00, // tier(8).
+              0x00, // tier(4), splice_command_length(4).
+              0x05, // splice_command_length(8).
+              0x06, // splice_command_type = time_signal.
+              // Start of splice_time().
+              0x80), // time_specified_flag, reserved, pts_time(1).
+          TestUtil.createByteArray(
+              0x52, 0x03, 0x02, 0x8f), // pts_time(32). PTS for a second after playback position.
+          TestUtil.createByteArray(
+              0x00, 0x00, 0x00, 0x00)); // CRC_32 (ignored, check happens at extraction).
+
+  private static final Format EMSG_FORMAT =
+      Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG, Format.OFFSET_SAMPLE_RELATIVE);
+
+  private final EventMessageEncoder eventMessageEncoder = new EventMessageEncoder();
+
+  @Test
+  public void decodeMetadata() throws Exception {
+    EventMessage emsg =
+        new EventMessage(
+            "urn:test-scheme-id",
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            "Test data".getBytes(UTF_8));
+
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).hasSize(1);
+    assertThat(metadata.get(0).length()).isEqualTo(1);
+    assertThat(metadata.get(0).get(0)).isEqualTo(emsg);
+  }
+
+  @Test
+  public void decodeMetadata_skipsMalformed() throws Exception {
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, "not valid emsg bytes".getBytes(UTF_8));
+
+    assertThat(metadata).isEmpty();
+  }
+
+  @Test
+  public void decodeMetadata_handlesId3WrappedInEmsg() throws Exception {
+    EventMessage emsg =
+        new EventMessage(
+            EventMessage.ID3_SCHEME_ID_AOM,
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            encodeTxxxId3Frame("Test description", "Test value"));
+
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).hasSize(1);
+    assertThat(metadata.get(0).length()).isEqualTo(1);
+    TextInformationFrame expectedId3Frame =
+        new TextInformationFrame("TXXX", "Test description", "Test value");
+    assertThat(metadata.get(0).get(0)).isEqualTo(expectedId3Frame);
+  }
+
+  @Test
+  public void decodeMetadata_handlesScte35WrappedInEmsg() throws Exception {
+
+    EventMessage emsg =
+        new EventMessage(
+            EventMessage.SCTE35_SCHEME_ID,
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            SCTE35_TIME_SIGNAL_BYTES);
+
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).hasSize(1);
+    assertThat(metadata.get(0).length()).isEqualTo(1);
+    assertThat(metadata.get(0).get(0)).isInstanceOf(TimeSignalCommand.class);
+  }
+
+  @Test
+  public void decodeMetadata_skipsMalformedWrappedMetadata() throws Exception {
+    EventMessage emsg =
+        new EventMessage(
+            EventMessage.ID3_SCHEME_ID_AOM,
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            "Not a real ID3 tag".getBytes(ISO_8859_1));
+
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).isEmpty();
+  }
+
+  private static List<Metadata> runRenderer(Format format, byte[] input)
+      throws ExoPlaybackException {
+    List<Metadata> metadata = new ArrayList<>();
+    MetadataRenderer renderer = new MetadataRenderer(metadata::add, /* outputLooper= */ null);
+    renderer.replaceStream(
+        new Format[] {format},
+        new FakeSampleStream(format, /* eventDispatcher= */ null, input),
+        /* offsetUs= */ 0L);
+    renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the format
+    renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the data
+
+    return Collections.unmodifiableList(metadata);
+  }
+
+  /**
+   * Builds an ID3v2 tag containing a single 'user defined text information frame' (id='TXXX') with
+   * {@code description} and {@code value}.
+   *
+   * <ul>
+   *   <li><a href="http://id3.org/id3v2.4.0-structure">ID3v2 overall structure</a>
+   *   <li><a href="http://id3.org/id3v2.4.0-frames">'user defined text information frame' spec</a>
+   *       (item 4.2.6)
+   * </ul>
+   */
+  private static byte[] encodeTxxxId3Frame(String description, String value) {
+    byte[] id3FrameData =
+        TestUtil.joinByteArrays(
+            "TXXX".getBytes(ISO_8859_1), // ID for a 'user defined text information frame'
+            TestUtil.createByteArray(0, 0, 0, 0), // Frame size (set later)
+            TestUtil.createByteArray(0, 0), // Frame flags
+            TestUtil.createByteArray(0), // Character encoding = ISO-8859-1
+            description.getBytes(ISO_8859_1),
+            TestUtil.createByteArray(0), // String null terminator
+            value.getBytes(ISO_8859_1),
+            TestUtil.createByteArray(0)); // String null terminator
+    int frameSizeIndex = 7;
+    int frameSize = id3FrameData.length - 10;
+    Assertions.checkArgument(
+        frameSize < 128, "frameSize must fit in 7 bits to avoid synch-safe encoding: " + frameSize);
+    id3FrameData[frameSizeIndex] = (byte) frameSize;
+
+    byte[] id3Bytes =
+        TestUtil.joinByteArrays(
+            "ID3".getBytes(ISO_8859_1), // identifier
+            TestUtil.createByteArray(0x04, 0x00), // version
+            TestUtil.createByteArray(0), // Tag flags
+            TestUtil.createByteArray(0, 0, 0, 0), // Tag size (set later)
+            id3FrameData);
+    int tagSizeIndex = 9;
+    int tagSize = id3Bytes.length - 10;
+    Assertions.checkArgument(
+        tagSize < 128, "tagSize must fit in 7 bits to avoid synch-safe encoding: " + tagSize);
+    id3Bytes[tagSizeIndex] = (byte) tagSize;
+    return id3Bytes;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoderTest.java
index beea65e925..ab264bd097 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageDecoderTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2VRT.metadata.emsg;
 
+import static com.google.android.exoplayer2VRT.testutil.TestUtil.createByteArray;
+import static com.google.android.exoplayer2VRT.testutil.TestUtil.joinByteArrays;
 import static com.google.common.truth.Truth.assertThat;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -30,18 +32,19 @@
 
   @Test
   public void testDecodeEventMessage() {
-    byte[] rawEmsgBody = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -45, // id = 1000403
-        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
+    byte[] rawEmsgBody =
+        joinByteArrays(
+            createByteArray(117, 114, 110, 58, 116, 101, 115, 116, 0), // scheme_id_uri = "urn:test"
+            createByteArray(49, 50, 51, 0), // value = "123"
+            createByteArray(0, 0, 11, 184), // event_duration_ms = 3000
+            createByteArray(0, 15, 67, 211), // id = 1000403
+            createByteArray(0, 1, 2, 3, 4)); // message_data = {0, 1, 2, 3, 4}
     EventMessageDecoder decoder = new EventMessageDecoder();
     MetadataInputBuffer buffer = new MetadataInputBuffer();
     buffer.data = ByteBuffer.allocate(rawEmsgBody.length).put(rawEmsgBody);
+
     Metadata metadata = decoder.decode(buffer);
+
     assertThat(metadata.length()).isEqualTo(1);
     EventMessage eventMessage = (EventMessage) metadata.get(0);
     assertThat(eventMessage.schemeIdUri).isEqualTo("urn:test");
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoderTest.java
index e2d3251493..3e88836ebd 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/emsg/EventMessageEncoderTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2VRT.metadata.emsg;
 
+import static com.google.android.exoplayer2VRT.testutil.TestUtil.createByteArray;
+import static com.google.android.exoplayer2VRT.testutil.TestUtil.joinByteArrays;
 import static com.google.common.truth.Truth.assertThat;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -29,67 +31,52 @@
 @RunWith(AndroidJUnit4.class)
 public final class EventMessageEncoderTest {
 
+  private static final EventMessage DECODED_MESSAGE =
+      new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+
+  private static final byte[] ENCODED_MESSAGE =
+      joinByteArrays(
+          createByteArray(117, 114, 110, 58, 116, 101, 115, 116, 0), // scheme_id_uri = "urn:test"
+          createByteArray(49, 50, 51, 0), // value = "123"
+          createByteArray(0, 0, 11, 184), // event_duration_ms = 3000
+          createByteArray(0, 15, 67, 211), // id = 1000403
+          createByteArray(0, 1, 2, 3, 4)); // message_data = {0, 1, 2, 3, 4}
+
   @Test
   public void testEncodeEventStream() throws IOException {
-    EventMessage eventMessage =
-        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
-    byte[] expectedEmsgBody =
-        new byte[] {
-          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-          49, 50, 51, 0, // value = "123"
-          0, 0, 3, -24, // timescale = 1000
-          0, 0, 0, 0, // presentation_time_delta = 0
-          0, 0, 11, -72, // event_duration = 3000
-          0, 15, 67, -45, // id = 1000403
-          0, 1, 2, 3, 4
-        }; // message_data = {0, 1, 2, 3, 4}
-    byte[] encodedByteArray = new EventMessageEncoder().encode(eventMessage);
-    assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
+    byte[] foo = new byte[] {1, 2, 3};
+
+    byte[] encodedByteArray = new EventMessageEncoder().encode(DECODED_MESSAGE);
+    assertThat(encodedByteArray).isEqualTo(ENCODED_MESSAGE);
   }
 
   @Test
   public void testEncodeDecodeEventStream() throws IOException {
-    EventMessage expectedEmsg =
-        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
-    byte[] encodedByteArray = new EventMessageEncoder().encode(expectedEmsg);
+    byte[] encodedByteArray = new EventMessageEncoder().encode(DECODED_MESSAGE);
     MetadataInputBuffer buffer = new MetadataInputBuffer();
     buffer.data = ByteBuffer.allocate(encodedByteArray.length).put(encodedByteArray);
 
     EventMessageDecoder decoder = new EventMessageDecoder();
     Metadata metadata = decoder.decode(buffer);
     assertThat(metadata.length()).isEqualTo(1);
-    assertThat(metadata.get(0)).isEqualTo(expectedEmsg);
+    assertThat(metadata.get(0)).isEqualTo(DECODED_MESSAGE);
   }
 
   @Test
   public void testEncodeEventStreamMultipleTimesWorkingCorrectly() throws IOException {
-    EventMessage eventMessage =
-        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
-    byte[] expectedEmsgBody =
-        new byte[] {
-          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-          49, 50, 51, 0, // value = "123"
-          0, 0, 3, -24, // timescale = 1000
-          0, 0, 0, 0, // presentation_time_delta = 0
-          0, 0, 11, -72, // event_duration = 3000
-          0, 15, 67, -45, // id = 1000403
-          0, 1, 2, 3, 4
-        }; // message_data = {0, 1, 2, 3, 4}
     EventMessage eventMessage1 =
         new EventMessage("urn:test", "123", 3000, 1000402, new byte[] {4, 3, 2, 1, 0});
     byte[] expectedEmsgBody1 =
-        new byte[] {
-          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-          49, 50, 51, 0, // value = "123"
-          0, 0, 3, -24, // timescale = 1000
-          0, 0, 0, 0, // presentation_time_delta = 0
-          0, 0, 11, -72, // event_duration = 3000
-          0, 15, 67, -46, // id = 1000402
-          4, 3, 2, 1, 0
-        }; // message_data = {4, 3, 2, 1, 0}
+        joinByteArrays(
+            createByteArray(117, 114, 110, 58, 116, 101, 115, 116, 0), // scheme_id_uri = "urn:test"
+            createByteArray(49, 50, 51, 0), // value = "123"
+            createByteArray(0, 0, 11, 184), // event_duration_ms = 3000
+            createByteArray(0, 15, 67, 210), // id = 1000402
+            createByteArray(4, 3, 2, 1, 0)); // message_data = {4, 3, 2, 1, 0}
+
     EventMessageEncoder eventMessageEncoder = new EventMessageEncoder();
-    byte[] encodedByteArray = eventMessageEncoder.encode(eventMessage);
-    assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
+    byte[] encodedByteArray = eventMessageEncoder.encode(DECODED_MESSAGE);
+    assertThat(encodedByteArray).isEqualTo(ENCODED_MESSAGE);
     byte[] encodedByteArray1 = eventMessageEncoder.encode(eventMessage1);
     assertThat(encodedByteArray1).isEqualTo(expectedEmsgBody1);
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/flac/PictureFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/flac/PictureFrameTest.java
new file mode 100644
index 0000000000..3c246707f5
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/flac/PictureFrameTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.metadata.flac;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link PictureFrame}. */
+@RunWith(AndroidJUnit4.class)
+public final class PictureFrameTest {
+
+  @Test
+  public void testParcelable() {
+    PictureFrame pictureFrameToParcel = new PictureFrame(0, "", "", 0, 0, 0, 0, new byte[0]);
+
+    Parcel parcel = Parcel.obtain();
+    pictureFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    PictureFrame pictureFrameFromParcel = PictureFrame.CREATOR.createFromParcel(parcel);
+    assertThat(pictureFrameFromParcel).isEqualTo(pictureFrameToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/flac/VorbisCommentTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/flac/VorbisCommentTest.java
new file mode 100644
index 0000000000..002fdfac0e
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/metadata/flac/VorbisCommentTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.metadata.flac;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link VorbisComment}. */
+@RunWith(AndroidJUnit4.class)
+public final class VorbisCommentTest {
+
+  @Test
+  public void testParcelable() {
+    VorbisComment vorbisCommentFrameToParcel = new VorbisComment("key", "value");
+
+    Parcel parcel = Parcel.obtain();
+    vorbisCommentFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    VorbisComment vorbisCommentFrameFromParcel = VorbisComment.CREATOR.createFromParcel(parcel);
+    assertThat(vorbisCommentFrameFromParcel).isEqualTo(vorbisCommentFrameToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoderTest.java
index 4cc90d51ef..e394f0c4f7 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/text/ttml/TtmlDecoderTest.java
@@ -514,7 +514,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(24f / 100f);
     assertThat(cue.line).isEqualTo(28f / 100f);
     assertThat(cue.size).isEqualTo(51f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(12f / 100f);
 
     cues = subtitle.getCues(4000000);
     assertThat(cues).hasSize(1);
@@ -524,7 +524,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(21f / 100f);
     assertThat(cue.line).isEqualTo(35f / 100f);
     assertThat(cue.size).isEqualTo(57f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(6f / 100f);
 
     cues = subtitle.getCues(7500000);
     assertThat(cues).hasSize(1);
@@ -534,7 +534,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(24f / 100f);
     assertThat(cue.line).isEqualTo(28f / 100f);
     assertThat(cue.size).isEqualTo(51f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(12f / 100f);
   }
 
   @Test
@@ -549,7 +549,7 @@ public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException
     assertThat(cue.position).isEqualTo(307f / 1280f);
     assertThat(cue.line).isEqualTo(562f / 720f);
     assertThat(cue.size).isEqualTo(653f / 1280f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(86f / 720f);
 
     cues = subtitle.getCues(4000000);
     assertThat(cues).hasSize(1);
@@ -559,7 +559,7 @@ public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException
     assertThat(cue.position).isEqualTo(269f / 1280f);
     assertThat(cue.line).isEqualTo(612f / 720f);
     assertThat(cue.size).isEqualTo(730f / 1280f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(43f / 720f);
   }
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/text/webvtt/CssParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/text/webvtt/CssParserTest.java
index 0805017859..84003be6dd 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/text/webvtt/CssParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/text/webvtt/CssParserTest.java
@@ -21,6 +21,7 @@
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2VRT.util.ParsableByteArray;
 import com.google.android.exoplayer2VRT.util.Util;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -87,21 +88,32 @@ public void testGetInputLimit() {
 
   @Test
   public void testParseMethodSimpleInput() {
-    String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     WebvttCssStyle expectedStyle = new WebvttCssStyle();
+    String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     expectedStyle.setFontColor(0xFF000000);
     expectedStyle.setBackgroundColor(0xFFFFEFD5);
-    assertParserProduces(expectedStyle, styleBlock1);
+    assertParserProduces(styleBlock1, expectedStyle);
 
     String styleBlock2 = " ::cue { color : black }\n\n::cue { color : invalid }";
     expectedStyle = new WebvttCssStyle();
     expectedStyle.setFontColor(0xFF000000);
-    assertParserProduces(expectedStyle, styleBlock2);
+    assertParserProduces(styleBlock2, expectedStyle);
 
-    String styleBlock3 = " \n::cue {\n background-color\n:#00fFFe}";
+    String styleBlock3 = "::cue {\n background-color\n:#00fFFe}";
     expectedStyle = new WebvttCssStyle();
     expectedStyle.setBackgroundColor(0xFF00FFFE);
-    assertParserProduces(expectedStyle, styleBlock3);
+    assertParserProduces(styleBlock3, expectedStyle);
+  }
+
+  @Test
+  public void testParseMethodMultipleRulesInBlockInput() {
+    String styleBlock =
+        "::cue {\n background-color\n:#00fFFe}      \n::cue {\n background-color\n:#00000000}\n";
+    WebvttCssStyle expectedStyle = new WebvttCssStyle();
+    expectedStyle.setBackgroundColor(0xFF00FFFE);
+    WebvttCssStyle secondExpectedStyle = new WebvttCssStyle();
+    secondExpectedStyle.setBackgroundColor(0x000000);
+    assertParserProduces(styleBlock, expectedStyle, secondExpectedStyle);
   }
 
   @Test
@@ -116,7 +128,7 @@ public void testMultiplePropertiesInBlock() {
     expectedStyle.setFontFamily("courier");
     expectedStyle.setBold(true);
 
-    assertParserProduces(expectedStyle, styleBlock);
+    assertParserProduces(styleBlock, expectedStyle);
   }
 
   @Test
@@ -128,7 +140,7 @@ public void testRgbaColorExpression() {
     expectedStyle.setBackgroundColor(0x190A0B0C);
     expectedStyle.setFontColor(0xFF010101);
 
-    assertParserProduces(expectedStyle, styleBlock);
+    assertParserProduces(styleBlock, expectedStyle);
   }
 
   @Test
@@ -203,25 +215,29 @@ private void assertInputLimit(String expectedLine, String s) {
     assertThat(input.readLine()).isEqualTo(expectedLine);
   }
 
-  private void assertParserProduces(WebvttCssStyle expected,
-      String styleBlock){
+  private void assertParserProduces(String styleBlock, WebvttCssStyle... expectedStyles) {
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(styleBlock));
-    WebvttCssStyle actualElem = parser.parseBlock(input);
-    assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
-    if (expected.hasBackgroundColor()) {
-      assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
-    }
-    assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
-    if (expected.hasFontColor()) {
-      assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
+    List<WebvttCssStyle> styles = parser.parseBlock(input);
+    assertThat(styles.size()).isEqualTo(expectedStyles.length);
+    for (int i = 0; i < expectedStyles.length; i++) {
+      WebvttCssStyle expected = expectedStyles[i];
+      WebvttCssStyle actualElem = styles.get(i);
+      assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
+      if (expected.hasBackgroundColor()) {
+        assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
+      }
+      assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
+      if (expected.hasFontColor()) {
+        assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
+      }
+      assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
+      assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
+      assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
+      assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
+      assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
+      assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
+      assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
     }
-    assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
-    assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
-    assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
-    assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
-    assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
-    assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
-    assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelectorTest.java
index c9ccb7452b..4ee2be2b5d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/trackselection/DefaultTrackSelectorTest.java
@@ -143,8 +143,10 @@ public void testParametersParcelable() {
             /* exceedAudioConstraintsIfNecessary= */ false,
             /* allowAudioMixedMimeTypeAdaptiveness= */ true,
             /* allowAudioMixedSampleRateAdaptiveness= */ false,
+            /* allowAudioMixedChannelCountAdaptiveness= */ true,
             // Text
             /* preferredTextLanguage= */ "de",
+            /* preferredTextRoleFlags= */ C.ROLE_FLAG_CAPTION,
             /* selectUndeterminedTextLanguage= */ true,
             /* disabledTextTrackSelectionFlags= */ 8,
             // General
@@ -341,6 +343,76 @@ public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
     assertFixedSelection(result.selections.get(0), trackGroups, formatWithSelectionFlag);
   }
 
+  /** Tests that adaptive audio track selections respect the maximum audio bitrate. */
+  public void testSelectAdaptiveAudioTrackGroupWithMaxBitrate() throws ExoPlaybackException {
+    Format format128k =
+        Format.createAudioSampleFormat(
+            /* id= */ "128",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 128 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    Format format192k =
+        Format.createAudioSampleFormat(
+            /* id= */ "192",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 192 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    Format format256k =
+        Format.createAudioSampleFormat(
+            /* id= */ "256",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 256 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    RendererCapabilities[] rendererCapabilities = {
+      ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES
+    };
+    TrackGroupArray trackGroups =
+        new TrackGroupArray(new TrackGroup(format192k, format128k, format256k));
+
+    TrackSelectorResult result =
+        trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1, 2);
+
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setMaxAudioBitrate(256 * 1024 - 1));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024 - 1));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1);
+
+    trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(10));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1);
+  }
+
   /**
    * Tests that track selector will select audio track with language that match preferred language
    * given by {@link Parameters}.
@@ -648,37 +720,38 @@ public void testSelectTracksWithinCapabilitiesSelectHigherSampleRate()
   }
 
   /**
-   * Tests that track selector will select audio tracks with higher bit-rate when other factors are
-   * the same, and tracks are within renderer's capabilities.
+   * Tests that track selector will select audio tracks with higher bit rate when other factors are
+   * the same, and tracks are within renderer's capabilities, and have the same language.
    */
   @Test
-  public void testSelectTracksWithinCapabilitiesSelectHigherBitrate() throws Exception {
+  public void selectAudioTracks_withinCapabilities_andSameLanguage_selectsHigherBitrate()
+      throws Exception {
     Format lowerBitrateFormat =
         Format.createAudioSampleFormat(
             "audioFormat",
             MimeTypes.AUDIO_AAC,
-            null,
-            15000,
-            Format.NO_VALUE,
-            2,
-            44100,
-            null,
-            null,
-            0,
-            null);
+            /* codecs= */ null,
+            /* bitrate= */ 15000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "hi");
     Format higherBitrateFormat =
         Format.createAudioSampleFormat(
             "audioFormat",
             MimeTypes.AUDIO_AAC,
-            null,
-            30000,
-            Format.NO_VALUE,
-            2,
-            44100,
-            null,
-            null,
-            0,
-            null);
+            /* codecs= */ null,
+            /* bitrate= */ 30000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "hi");
     TrackGroupArray trackGroups = wrapFormats(lowerBitrateFormat, higherBitrateFormat);
 
     TrackSelectorResult result =
@@ -690,14 +763,58 @@ public void testSelectTracksWithinCapabilitiesSelectHigherBitrate() throws Excep
     assertFixedSelection(result.selections.get(0), trackGroups, higherBitrateFormat);
   }
 
+  /**
+   * Tests that track selector will select the first audio track even if other tracks with a
+   * different language have higher bit rates, all other factors are the same, and tracks are within
+   * renderer's capabilities.
+   */
+  @Test
+  public void selectAudioTracks_withinCapabilities_andDifferentLanguage_selectsFirstTrack()
+      throws Exception {
+    Format firstLanguageFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            /* codecs= */ null,
+            /* bitrate= */ 15000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "hi");
+    Format higherBitrateFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            /* codecs= */ null,
+            /* bitrate= */ 30000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "te");
+    TrackGroupArray trackGroups = wrapFormats(firstLanguageFormat, higherBitrateFormat);
+
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, firstLanguageFormat);
+  }
+
   /**
    * Tests that track selector will prefer audio tracks with higher channel count over tracks with
    * higher sample rate when other factors are the same, and tracks are within renderer's
    * capabilities.
    */
   @Test
-  public void testSelectTracksPreferHigherNumChannelBeforeSampleRate()
-      throws Exception {
+  public void testSelectTracksPreferHigherNumChannelBeforeSampleRate() throws Exception {
     Format higherChannelLowerSampleRateFormat =
         Format.createAudioSampleFormat(
             "audioFormat",
@@ -893,7 +1010,6 @@ public void testTextTrackSelectionFlags() throws ExoPlaybackException {
     Format forcedDefault =
         buildTextFormat("forcedDefault", "eng", C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT);
     Format defaultOnly = buildTextFormat("defaultOnly", "eng", C.SELECTION_FLAG_DEFAULT);
-    Format forcedOnlySpanish = buildTextFormat("forcedOnlySpanish", "spa", C.SELECTION_FLAG_FORCED);
     Format noFlag = buildTextFormat("noFlag", "eng");
 
     RendererCapabilities[] textRendererCapabilities =
@@ -933,12 +1049,12 @@ public void testTextTrackSelectionFlags() throws ExoPlaybackException {
     result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
     assertNoSelection(result.selections.get(0));
 
-    // There is a preferred language, so the first language-matching track flagged as default should
-    // be selected.
+    // There is a preferred language, so a language-matching track flagged as default should
+    // be selected, and the one without forced flag should be preferred.
     trackSelector.setParameters(
         Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("eng").build());
     result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);
-    assertFixedSelection(result.selections.get(0), trackGroups, forcedDefault);
+    assertFixedSelection(result.selections.get(0), trackGroups, defaultOnly);
 
     // Same as above, but the default flag is disabled. If multiple tracks match the preferred
     // language, those not flagged as forced are preferred, as they likely include the contents of
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSourceTest.java
index 1e420e936f..e0c3b238a2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/upstream/DataSchemeDataSourceTest.java
@@ -21,6 +21,7 @@
 
 import android.net.Uri;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2VRT.C;
 import com.google.android.exoplayer2VRT.util.Util;
 import java.io.IOException;
 import org.junit.Before;
@@ -31,6 +32,9 @@
 @RunWith(AndroidJUnit4.class)
 public final class DataSchemeDataSourceTest {
 
+  private static final String DATA_SCHEME_URI =
+      "data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiLCJjb250ZW50X2lkIjoiTWpBeE5WOTBaV"
+          + "0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiXX0=";
   private DataSource schemeDataDataSource;
 
   @Before
@@ -40,9 +44,7 @@ public void setUp() {
 
   @Test
   public void testBase64Data() throws IOException {
-    DataSpec dataSpec = buildDataSpec("data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiL"
-        + "CJjb250ZW50X2lkIjoiTWpBeE5WOTBaV0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwM"
-        + "DAwMDAwMDAwMDAiXX0=");
+    DataSpec dataSpec = buildDataSpec(DATA_SCHEME_URI);
     DataSourceAsserts.assertDataSourceContent(
         schemeDataDataSource,
         dataSpec,
@@ -72,6 +74,52 @@ public void testPartialReads() throws IOException {
     assertThat(Util.fromUtf8Bytes(buffer, 0, 18)).isEqualTo("012345678901234567");
   }
 
+  @Test
+  public void testSequentialRangeRequests() throws IOException {
+    DataSpec dataSpec =
+        buildDataSpec(DATA_SCHEME_URI, /* position= */ 1, /* length= */ C.LENGTH_UNSET);
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource,
+        dataSpec,
+        Util.getUtf8Bytes(
+            "\"provider\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
+                + "[\"00000000000000000000000000000000\"]}"));
+    dataSpec = buildDataSpec(DATA_SCHEME_URI, /* position= */ 10, /* length= */ C.LENGTH_UNSET);
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource,
+        dataSpec,
+        Util.getUtf8Bytes(
+            "\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
+                + "[\"00000000000000000000000000000000\"]}"));
+    dataSpec = buildDataSpec(DATA_SCHEME_URI, /* position= */ 15, /* length= */ 5);
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource, dataSpec, Util.getUtf8Bytes("devin"));
+  }
+
+  @Test
+  public void testInvalidStartPositionRequest() throws IOException {
+    try {
+      // Try to open a range starting one byte beyond the resource's length.
+      schemeDataDataSource.open(
+          buildDataSpec(DATA_SCHEME_URI, /* position= */ 108, /* length= */ C.LENGTH_UNSET));
+      fail();
+    } catch (DataSourceException e) {
+      assertThat(e.reason).isEqualTo(DataSourceException.POSITION_OUT_OF_RANGE);
+    }
+  }
+
+  @Test
+  public void testRangeExceedingResourceLengthRequest() throws IOException {
+    try {
+      // Try to open a range exceeding the resource's length.
+      schemeDataDataSource.open(
+          buildDataSpec(DATA_SCHEME_URI, /* position= */ 97, /* length= */ 11));
+      fail();
+    } catch (DataSourceException e) {
+      assertThat(e.reason).isEqualTo(DataSourceException.POSITION_OUT_OF_RANGE);
+    }
+  }
+
   @Test
   public void testIncorrectScheme() {
     try {
@@ -99,7 +147,11 @@ public void testMalformedData() {
   }
 
   private static DataSpec buildDataSpec(String uriString) {
-    return new DataSpec(Uri.parse(uriString));
+    return buildDataSpec(uriString, /* position= */ 0, /* length= */ C.LENGTH_UNSET);
+  }
+
+  private static DataSpec buildDataSpec(String uriString, int position, int length) {
+    return new DataSpec(Uri.parse(uriString), position, length, /* key= */ null);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/util/ColorParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/util/ColorParserTest.java
index 16d35fea4e..8d4fed3886 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/util/ColorParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/util/ColorParserTest.java
@@ -28,7 +28,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-/** Unit test for <code>ColorParser</code>. */
+/** Unit test for {@link ColorParser}. */
 @RunWith(AndroidJUnit4.class)
 public final class ColorParserTest {
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/util/FlacStreamMetadataTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/util/FlacStreamMetadataTest.java
new file mode 100644
index 0000000000..4980261b08
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/util/FlacStreamMetadataTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2VRT.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2VRT.metadata.Metadata;
+import com.google.android.exoplayer2VRT.metadata.flac.VorbisComment;
+import com.google.android.exoplayer2VRT.util.FlacStreamMetadata;
+import java.util.ArrayList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link FlacStreamMetadata}. */
+@RunWith(AndroidJUnit4.class)
+public final class FlacStreamMetadataTest {
+
+  @Test
+  public void parseVorbisComments() {
+    ArrayList<String> commentsList = new ArrayList<>();
+    commentsList.add("Title=Song");
+    commentsList.add("Artist=Singer");
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata.length()).isEqualTo(2);
+    VorbisComment commentFrame = (VorbisComment) metadata.get(0);
+    assertThat(commentFrame.key).isEqualTo("Title");
+    assertThat(commentFrame.value).isEqualTo("Song");
+    commentFrame = (VorbisComment) metadata.get(1);
+    assertThat(commentFrame.key).isEqualTo("Artist");
+    assertThat(commentFrame.value).isEqualTo("Singer");
+  }
+
+  @Test
+  public void parseEmptyVorbisComments() {
+    ArrayList<String> commentsList = new ArrayList<>();
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata).isNull();
+  }
+
+  @Test
+  public void parseVorbisCommentWithEqualsInValue() {
+    ArrayList<String> commentsList = new ArrayList<>();
+    commentsList.add("Title=So=ng");
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata.length()).isEqualTo(1);
+    VorbisComment commentFrame = (VorbisComment) metadata.get(0);
+    assertThat(commentFrame.key).isEqualTo("Title");
+    assertThat(commentFrame.value).isEqualTo("So=ng");
+  }
+
+  @Test
+  public void parseInvalidVorbisComment() {
+    ArrayList<String> commentsList = new ArrayList<>();
+    commentsList.add("TitleSong");
+    commentsList.add("Artist=Singer");
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata.length()).isEqualTo(1);
+    VorbisComment commentFrame = (VorbisComment) metadata.get(0);
+    assertThat(commentFrame.key).isEqualTo("Artist");
+    assertThat(commentFrame.value).isEqualTo("Singer");
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2VRT/util/UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2VRT/util/UtilTest.java
index 8c3ada2f49..ab48ea2fce 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2VRT/util/UtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2VRT/util/UtilTest.java
@@ -268,14 +268,19 @@ public void testInflate() {
   @Test
   @Config(sdk = 21)
   public void testNormalizeLanguageCodeV21() {
-    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("spa");
-    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("spa");
-    assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("spa-ar");
-    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("spa-ar");
-    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("spa-ar-dialect");
-    assertThat(Util.normalizeLanguageCode("es-419")).isEqualTo("spa-419");
-    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zho-hans-tw");
-    assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zho-tw");
+    assertThat(Util.normalizeLanguageCode(null)).isNull();
+    assertThat(Util.normalizeLanguageCode("")).isEmpty();
+    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("es");
+    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("es");
+    assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es_AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("spa_ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("es-ar-dialect");
+    assertThat(Util.normalizeLanguageCode("ES-419")).isEqualTo("es-419");
+    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zh-hans-tw");
+    assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zh-tw");
+    assertThat(Util.normalizeLanguageCode("zho-hans-tw")).isEqualTo("zh-hans-tw");
     assertThat(Util.normalizeLanguageCode("und")).isEqualTo("und");
     assertThat(Util.normalizeLanguageCode("DoesNotExist")).isEqualTo("doesnotexist");
   }
@@ -283,13 +288,49 @@ public void testNormalizeLanguageCodeV21() {
   @Test
   @Config(sdk = 16)
   public void testNormalizeLanguageCode() {
-    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("spa");
-    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("spa");
+    assertThat(Util.normalizeLanguageCode(null)).isNull();
+    assertThat(Util.normalizeLanguageCode("")).isEmpty();
+    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("es");
+    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("es");
     assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es_AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("spa_ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("es-ar-dialect");
+    assertThat(Util.normalizeLanguageCode("ES-419")).isEqualTo("es-419");
+    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zh-hans-tw");
+    // Doesn't work on API < 21 because we can't use Locale syntax verification.
+    // assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zh-tw");
+    assertThat(Util.normalizeLanguageCode("zho-hans-tw")).isEqualTo("zh-hans-tw");
     assertThat(Util.normalizeLanguageCode("und")).isEqualTo("und");
     assertThat(Util.normalizeLanguageCode("DoesNotExist")).isEqualTo("doesnotexist");
   }
 
+  @Test
+  public void testNormalizeIso6392BibliographicalAndTextualCodes() {
+    // See https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes.
+    assertThat(Util.normalizeLanguageCode("alb")).isEqualTo(Util.normalizeLanguageCode("sqi"));
+    assertThat(Util.normalizeLanguageCode("arm")).isEqualTo(Util.normalizeLanguageCode("hye"));
+    assertThat(Util.normalizeLanguageCode("baq")).isEqualTo(Util.normalizeLanguageCode("eus"));
+    assertThat(Util.normalizeLanguageCode("bur")).isEqualTo(Util.normalizeLanguageCode("mya"));
+    assertThat(Util.normalizeLanguageCode("chi")).isEqualTo(Util.normalizeLanguageCode("zho"));
+    assertThat(Util.normalizeLanguageCode("cze")).isEqualTo(Util.normalizeLanguageCode("ces"));
+    assertThat(Util.normalizeLanguageCode("dut")).isEqualTo(Util.normalizeLanguageCode("nld"));
+    assertThat(Util.normalizeLanguageCode("fre")).isEqualTo(Util.normalizeLanguageCode("fra"));
+    assertThat(Util.normalizeLanguageCode("geo")).isEqualTo(Util.normalizeLanguageCode("kat"));
+    assertThat(Util.normalizeLanguageCode("ger")).isEqualTo(Util.normalizeLanguageCode("deu"));
+    assertThat(Util.normalizeLanguageCode("gre")).isEqualTo(Util.normalizeLanguageCode("ell"));
+    assertThat(Util.normalizeLanguageCode("ice")).isEqualTo(Util.normalizeLanguageCode("isl"));
+    assertThat(Util.normalizeLanguageCode("mac")).isEqualTo(Util.normalizeLanguageCode("mkd"));
+    assertThat(Util.normalizeLanguageCode("mao")).isEqualTo(Util.normalizeLanguageCode("mri"));
+    assertThat(Util.normalizeLanguageCode("may")).isEqualTo(Util.normalizeLanguageCode("msa"));
+    assertThat(Util.normalizeLanguageCode("per")).isEqualTo(Util.normalizeLanguageCode("fas"));
+    assertThat(Util.normalizeLanguageCode("rum")).isEqualTo(Util.normalizeLanguageCode("ron"));
+    assertThat(Util.normalizeLanguageCode("slo")).isEqualTo(Util.normalizeLanguageCode("slk"));
+    assertThat(Util.normalizeLanguageCode("tib")).isEqualTo(Util.normalizeLanguageCode("bod"));
+    assertThat(Util.normalizeLanguageCode("wel")).isEqualTo(Util.normalizeLanguageCode("cym"));
+  }
+
   private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
     assertThat(escapeFileName(fileName)).isEqualTo(escapedFileName);
     assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
diff --git a/library/dash/build.gradle b/library/dash/build.gradle
index f6981a2220..9f5775d478 100644
--- a/library/dash/build.gradle
+++ b/library/dash/build.gradle
@@ -41,7 +41,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashChunkSource.java
index ba827eb1bf..576dd32c6a 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashChunkSource.java
@@ -69,4 +69,11 @@ DashChunkSource createDashChunkSource(
    * @param newManifest The new manifest.
    */
   void updateManifest(DashManifest newManifest, int periodIndex);
+
+  /**
+   * Updates the track selection.
+   *
+   * @param trackSelection The new track selection instance. Must be equivalent to the previous one.
+   */
+  void updateTrackSelection(TrackSelection trackSelection);
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaPeriod.java
index da29e808e9..a33f3621a4 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaPeriod.java
@@ -402,17 +402,27 @@ private void selectNewStreams(
       int[] streamIndexToTrackGroupIndex) {
     // Create newly selected primary and event streams.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
+      TrackSelection selection = selections[i];
+      if (selection == null) {
+        continue;
+      }
+      if (streams[i] == null) {
+        // Create new stream for selection.
         streamResetFlags[i] = true;
         int trackGroupIndex = streamIndexToTrackGroupIndex[i];
         TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
         if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_PRIMARY) {
-          streams[i] = buildSampleStream(trackGroupInfo, selections[i], positionUs);
+          streams[i] = buildSampleStream(trackGroupInfo, selection, positionUs);
         } else if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_MANIFEST_EVENTS) {
           EventStream eventStream = eventStreams.get(trackGroupInfo.eventStreamGroupIndex);
-          Format format = selections[i].getTrackGroup().getFormat(0);
+          Format format = selection.getTrackGroup().getFormat(0);
           streams[i] = new EventSampleStream(eventStream, format, manifest.dynamic);
         }
+      } else if (streams[i] instanceof ChunkSampleStream) {
+        // Update selection in existing stream.
+        @SuppressWarnings("unchecked")
+        ChunkSampleStream<DashChunkSource> stream = (ChunkSampleStream<DashChunkSource>) streams[i];
+        stream.getChunkSource().updateTrackSelection(selection);
       }
     }
     // Create newly selected embedded streams from the corresponding primary stream. Note that this
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaSource.java
index 81d929ecd0..79e3d7f7b1 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DashMediaSource.java
@@ -1037,6 +1037,9 @@ private void scheduleManifestRefresh(long delayUntilNextLoadMs) {
 
   private void startLoadingManifest() {
     handler.removeCallbacks(refreshManifestRunnable);
+    if (loader.hasFatalError()) {
+      return;
+    }
     if (loader.isLoading()) {
       manifestLoadPending = true;
       return;
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DefaultDashChunkSource.java
index 5dcf3b0184..6c3071057a 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/DefaultDashChunkSource.java
@@ -111,7 +111,6 @@ public DashChunkSource createDashChunkSource(
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int[] adaptationSetIndices;
-  private final TrackSelection trackSelection;
   private final int trackType;
   private final DataSource dataSource;
   private final long elapsedRealtimeOffsetMs;
@@ -120,6 +119,7 @@ public DashChunkSource createDashChunkSource(
 
   protected final RepresentationHolder[] representationHolders;
 
+  private TrackSelection trackSelection;
   private DashManifest manifest;
   private int periodIndex;
   private IOException fatalError;
@@ -222,6 +222,11 @@ public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
     }
   }
 
+  @Override
+  public void updateTrackSelection(TrackSelection trackSelection) {
+    this.trackSelection = trackSelection;
+  }
+
   @Override
   public void maybeThrowError() throws IOException {
     if (fatalError != null) {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/PlayerEmsgHandler.java
index 4345d5908a..ba16612d61 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/PlayerEmsgHandler.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/PlayerEmsgHandler.java
@@ -360,6 +360,9 @@ private void parseAndDiscardSamples() {
         }
         long eventTimeUs = inputBuffer.timeUs;
         Metadata metadata = decoder.decode(inputBuffer);
+        if (metadata == null) {
+          continue;
+        }
         EventMessage eventMessage = (EventMessage) metadata.get(0);
         if (isPlayerEmsgEvent(eventMessage.schemeIdUri, eventMessage.value)) {
           parsePlayerEmsgEvent(eventTimeUs, eventMessage);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/DashManifestParser.java
index 0dbbf6734a..69eeb10396 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/DashManifestParser.java
@@ -42,6 +42,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 import java.util.regex.Matcher;
@@ -242,7 +243,7 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, null);
+        segmentBase = parseSegmentTemplate(xpp, null, Collections.emptyList());
       } else {
         maybeSkipTag(xpp);
       }
@@ -323,6 +324,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
                 language,
                 roleDescriptors,
                 accessibilityDescriptors,
+                supplementalProperties,
                 segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
@@ -332,7 +334,8 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+        segmentBase =
+            parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase, supplementalProperties);
       } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
@@ -492,6 +495,7 @@ protected RepresentationInfo parseRepresentation(
       String adaptationSetLanguage,
       List<Descriptor> adaptationSetRoleDescriptors,
       List<Descriptor> adaptationSetAccessibilityDescriptors,
+      List<Descriptor> adaptationSetSupplementalProperties,
       SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
@@ -524,7 +528,9 @@ protected RepresentationInfo parseRepresentation(
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+        segmentBase =
+            parseSegmentTemplate(
+                xpp, (SegmentTemplate) segmentBase, adaptationSetSupplementalProperties);
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentProtection")) {
         Pair<String, SchemeData> contentProtection = parseContentProtection(xpp);
         if (contentProtection.first != null) {
@@ -594,6 +600,7 @@ protected Format buildFormat(
             containerMimeType,
             sampleMimeType,
             codecs,
+            /* metadata= */ null,
             bitrate,
             width,
             height,
@@ -608,6 +615,7 @@ protected Format buildFormat(
             containerMimeType,
             sampleMimeType,
             codecs,
+            /* metadata= */ null,
             bitrate,
             audioChannels,
             audioSamplingRate,
@@ -763,13 +771,19 @@ protected SegmentList buildSegmentList(
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplate parent)
+  protected SegmentTemplate parseSegmentTemplate(
+      XmlPullParser xpp,
+      SegmentTemplate parent,
+      List<Descriptor> adaptationSetSupplementalProperties)
       throws XmlPullParserException, IOException {
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
         parent != null ? parent.presentationTimeOffset : 0);
     long duration = parseLong(xpp, "duration", parent != null ? parent.duration : C.TIME_UNSET);
     long startNumber = parseLong(xpp, "startNumber", parent != null ? parent.startNumber : 1);
+    long endNumber =
+        parseLastSegmentNumberSupplementalProperty(adaptationSetSupplementalProperties);
+
     UrlTemplate mediaTemplate = parseUrlTemplate(xpp, "media",
         parent != null ? parent.mediaTemplate : null);
     UrlTemplate initializationTemplate = parseUrlTemplate(xpp, "initialization",
@@ -794,8 +808,16 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
       timeline = timeline != null ? timeline : parent.segmentTimeline;
     }
 
-    return buildSegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
+    return buildSegmentTemplate(
+        initialization,
+        timescale,
+        presentationTimeOffset,
+        startNumber,
+        endNumber,
+        duration,
+        timeline,
+        initializationTemplate,
+        mediaTemplate);
   }
 
   protected SegmentTemplate buildSegmentTemplate(
@@ -803,12 +825,21 @@ protected SegmentTemplate buildSegmentTemplate(
       long timescale,
       long presentationTimeOffset,
       long startNumber,
+      long endNumber,
       long duration,
       List<SegmentTimelineElement> timeline,
       UrlTemplate initializationTemplate,
       UrlTemplate mediaTemplate) {
-    return new SegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
+    return new SegmentTemplate(
+        initialization,
+        timescale,
+        presentationTimeOffset,
+        startNumber,
+        endNumber,
+        duration,
+        timeline,
+        initializationTemplate,
+        mediaTemplate);
   }
 
   /**
@@ -877,7 +908,7 @@ protected EventStream buildEventStream(String schemeIdUri, String value, long ti
     long id = parseLong(xpp, "id", 0);
     long duration = parseLong(xpp, "duration", C.TIME_UNSET);
     long presentationTime = parseLong(xpp, "presentationTime", 0);
-    long durationMs = Util.scaleLargeTimestamp(duration, 1000, timescale);
+    long durationMs = Util.scaleLargeTimestamp(duration, C.MILLIS_PER_SECOND, timescale);
     long presentationTimesUs = Util.scaleLargeTimestamp(presentationTime, C.MICROS_PER_SECOND,
         timescale);
     String messageData = parseString(xpp, "messageData", null);
@@ -1445,6 +1476,18 @@ protected static int parseDolbyChannelConfiguration(XmlPullParser xpp) {
     }
   }
 
+  protected static long parseLastSegmentNumberSupplementalProperty(
+      List<Descriptor> supplementalProperties) {
+    for (int i = 0; i < supplementalProperties.size(); i++) {
+      Descriptor descriptor = supplementalProperties.get(i);
+      if ("http://dashif.org/guidelines/last-segment-number"
+          .equalsIgnoreCase(descriptor.schemeIdUri)) {
+        return Long.parseLong(descriptor.value);
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
   /** A parsed Representation element. */
   protected static final class RepresentationInfo {
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/SegmentBase.java b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/SegmentBase.java
index 1c8b89e12f..e916f5d644 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/SegmentBase.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2VRT/source/dash/manifest/SegmentBase.java
@@ -277,6 +277,7 @@ public boolean isExplicit() {
 
     /* package */ final UrlTemplate initializationTemplate;
     /* package */ final UrlTemplate mediaTemplate;
+    /* package */ final long endNumber;
 
     /**
      * @param initialization A {@link RangedUri} corresponding to initialization data, if such data
@@ -286,6 +287,9 @@ public boolean isExplicit() {
      * @param presentationTimeOffset The presentation time offset. The value in seconds is the
      *     division of this value and {@code timescale}.
      * @param startNumber The sequence number of the first segment.
+     * @param endNumber The sequence number of the last segment as specified by the
+     *     SupplementalProperty with schemeIdUri="http://dashif.org/guidelines/last-segment-number",
+     *     or {@link C#INDEX_UNSET}.
      * @param duration The duration of each segment in the case of fixed duration segments. The
      *     value in seconds is the division of this value and {@code timescale}. If {@code
      *     segmentTimeline} is non-null then this parameter is ignored.
@@ -302,14 +306,21 @@ public SegmentTemplate(
         long timescale,
         long presentationTimeOffset,
         long startNumber,
+        long endNumber,
         long duration,
         List<SegmentTimelineElement> segmentTimeline,
         UrlTemplate initializationTemplate,
         UrlTemplate mediaTemplate) {
-      super(initialization, timescale, presentationTimeOffset, startNumber,
-          duration, segmentTimeline);
+      super(
+          initialization,
+          timescale,
+          presentationTimeOffset,
+          startNumber,
+          duration,
+          segmentTimeline);
       this.initializationTemplate = initializationTemplate;
       this.mediaTemplate = mediaTemplate;
+      this.endNumber = endNumber;
     }
 
     @Override
@@ -340,6 +351,8 @@ public RangedUri getSegmentUrl(Representation representation, long sequenceNumbe
     public int getSegmentCount(long periodDurationUs) {
       if (segmentTimeline != null) {
         return segmentTimeline.size();
+      } else if (endNumber != C.INDEX_UNSET) {
+        return (int) (endNumber - startNumber + 1);
       } else if (periodDurationUs != C.TIME_UNSET) {
         long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
         return (int) Util.ceilDivide(periodDurationUs, durationUs);
@@ -347,7 +360,6 @@ public int getSegmentCount(long periodDurationUs) {
         return DashSegmentIndex.INDEX_UNBOUNDED;
       }
     }
-
   }
 
   /**
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/DashUtilTest.java b/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/DashUtilTest.java
index fcebeb09e1..06ecb3bc4c 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/DashUtilTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/DashUtilTest.java
@@ -80,6 +80,7 @@ private static Representation newRepresentations(DrmInitData drmInitData) {
             MimeTypes.VIDEO_MP4,
             MimeTypes.VIDEO_H264,
             /* codecs= */ "",
+            /* metadata= */ null,
             Format.NO_VALUE,
             /* width= */ 1024,
             /* height= */ 768,
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DashDownloaderTest.java b/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DashDownloaderTest.java
index b0045eada1..15cb8db591 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DashDownloaderTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DashDownloaderTest.java
@@ -35,6 +35,7 @@
 import com.google.android.exoplayer2VRT.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2VRT.offline.DownloaderFactory;
 import com.google.android.exoplayer2VRT.offline.StreamKey;
+import com.google.android.exoplayer2VRT.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2VRT.testutil.FakeDataSet;
 import com.google.android.exoplayer2VRT.testutil.FakeDataSource;
 import com.google.android.exoplayer2VRT.testutil.FakeDataSource.Factory;
@@ -108,7 +109,7 @@ public void testDownloadRepresentation() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -127,7 +128,7 @@ public void testDownloadRepresentationInSmallParts() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -146,7 +147,7 @@ public void testDownloadRepresentations() throws Exception {
     DashDownloader dashDownloader =
         getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -167,7 +168,7 @@ public void testDownloadAllRepresentations() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -256,7 +257,7 @@ public void testDownloadRepresentationFailure() throws Exception {
       // Expected.
     }
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DownloadManagerDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DownloadManagerDashTest.java
index fd5482b420..a1137db68b 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DownloadManagerDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2VRT/source/dash/offline/DownloadManagerDashTest.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2VRT.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2VRT.offline.StreamKey;
 import com.google.android.exoplayer2VRT.scheduler.Requirements;
+import com.google.android.exoplayer2VRT.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2VRT.testutil.DummyMainThread;
 import com.google.android.exoplayer2VRT.testutil.DummyMainThread.TestRunnable;
 import com.google.android.exoplayer2VRT.testutil.FakeDataSet;
@@ -154,7 +155,7 @@ public void testSaveAndLoadActionFile() throws Throwable {
   public void testHandleDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1, fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -162,7 +163,7 @@ public void testHandleMultipleDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1);
     handleDownloadRequest(fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -176,7 +177,7 @@ public void testHandleInterferingDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
diff --git a/library/hls/build.gradle b/library/hls/build.gradle
index 8e9696af70..82e09ab72c 100644
--- a/library/hls/build.gradle
+++ b/library/hls/build.gradle
@@ -39,7 +39,7 @@ android {
 }
 
 dependencies {
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     implementation project(modulePrefix + 'library-core')
     testImplementation project(modulePrefix + 'testutils-robolectric')
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsChunkSource.java
index 5a8d3c414f..44171bd603 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsChunkSource.java
@@ -183,17 +183,15 @@ public TrackGroup getTrackGroup() {
   }
 
   /**
-   * Selects tracks for use.
+   * Sets the current track selection.
    *
-   * @param trackSelection The track selection.
+   * @param trackSelection The {@link TrackSelection}.
    */
-  public void selectTracks(TrackSelection trackSelection) {
+  public void setTrackSelection(TrackSelection trackSelection) {
     this.trackSelection = trackSelection;
   }
 
-  /**
-   * Returns the current track selection.
-   */
+  /** Returns the current {@link TrackSelection}. */
   public TrackSelection getTrackSelection() {
     return trackSelection;
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaChunk.java
index b54caf734d..f6a8c44ef0 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaChunk.java
@@ -392,6 +392,10 @@ private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec
             id3Timestamp != C.TIME_UNSET
                 ? timestampAdjuster.adjustTsTimestamp(id3Timestamp)
                 : startTimeUs);
+      } else {
+        // In case the container format changes mid-stream to non-packed-audio, we need to reset
+        // the timestamp offset.
+        output.setSampleOffsetUs(/* sampleOffsetUs= */ 0L);
       }
       output.init(uid, shouldSpliceIn, /* reusingExtractor= */ false);
       extractor.init(output);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriod.java
index 8e6cf68700..f9b25c1522 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriod.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2VRT.SeekParameters;
 import com.google.android.exoplayer2VRT.drm.DrmInitData;
 import com.google.android.exoplayer2VRT.extractor.Extractor;
+import com.google.android.exoplayer2VRT.metadata.Metadata;
 import com.google.android.exoplayer2VRT.offline.StreamKey;
 import com.google.android.exoplayer2VRT.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2VRT.source.MediaPeriod;
@@ -773,6 +774,7 @@ private static Format deriveVideoFormat(Format variantFormat) {
         variantFormat.containerMimeType,
         sampleMimeType,
         codecs,
+        variantFormat.metadata,
         variantFormat.bitrate,
         variantFormat.width,
         variantFormat.height,
@@ -785,6 +787,7 @@ private static Format deriveVideoFormat(Format variantFormat) {
   private static Format deriveAudioFormat(
       Format variantFormat, Format mediaTagFormat, boolean isPrimaryTrackInVariant) {
     String codecs;
+    Metadata metadata;
     int channelCount = Format.NO_VALUE;
     int selectionFlags = 0;
     int roleFlags = 0;
@@ -792,6 +795,7 @@ private static Format deriveAudioFormat(
     String label = null;
     if (mediaTagFormat != null) {
       codecs = mediaTagFormat.codecs;
+      metadata = mediaTagFormat.metadata;
       channelCount = mediaTagFormat.channelCount;
       selectionFlags = mediaTagFormat.selectionFlags;
       roleFlags = mediaTagFormat.roleFlags;
@@ -799,6 +803,7 @@ private static Format deriveAudioFormat(
       label = mediaTagFormat.label;
     } else {
       codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_AUDIO);
+      metadata = variantFormat.metadata;
       if (isPrimaryTrackInVariant) {
         channelCount = variantFormat.channelCount;
         selectionFlags = variantFormat.selectionFlags;
@@ -815,6 +820,7 @@ private static Format deriveAudioFormat(
         variantFormat.containerMimeType,
         sampleMimeType,
         codecs,
+        metadata,
         bitrate,
         channelCount,
         /* sampleRate= */ Format.NO_VALUE,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsSampleStreamWrapper.java
index 1c924270c9..729464c900 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/HlsSampleStreamWrapper.java
@@ -292,14 +292,17 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     TrackSelection primaryTrackSelection = oldPrimaryTrackSelection;
     // Select new tracks.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
+      TrackSelection selection = selections[i];
+      if (selection == null) {
+        continue;
+      }
+      int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
+      if (trackGroupIndex == primaryTrackGroupIndex) {
+        primaryTrackSelection = selection;
+        chunkSource.setTrackSelection(selection);
+      }
+      if (streams[i] == null) {
         enabledTrackGroupCount++;
-        TrackSelection selection = selections[i];
-        int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
-        if (trackGroupIndex == primaryTrackGroupIndex) {
-          primaryTrackSelection = selection;
-          chunkSource.selectTracks(selection);
-        }
         streams[i] = new HlsSampleStream(this, trackGroupIndex);
         streamResetFlags[i] = true;
         if (trackGroupToSampleQueueIndex != null) {
@@ -322,6 +325,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     if (enabledTrackGroupCount == 0) {
       chunkSource.reset();
       downstreamTrackFormat = null;
+      pendingResetUpstreamFormats = true;
       mediaChunks.clear();
       if (loader.isLoading()) {
         if (sampleQueuesBuilt) {
@@ -421,6 +425,7 @@ public boolean seekToUs(long positionUs, boolean forceReset) {
     if (loader.isLoading()) {
       loader.cancelLoading();
     } else {
+      loader.clearFatalError();
       resetSampleQueues();
     }
     return true;
@@ -568,7 +573,7 @@ public long getNextLoadPositionUs() {
 
   @Override
   public boolean continueLoading(long positionUs) {
-    if (loadingFinished || loader.isLoading()) {
+    if (loadingFinished || loader.isLoading() || loader.hasFatalError()) {
       return false;
     }
 
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/DefaultHlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/DefaultHlsPlaylistTracker.java
index 604c1d4e7c..f92538bf39 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/DefaultHlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/DefaultHlsPlaylistTracker.java
@@ -488,8 +488,8 @@ public void release() {
 
     public void loadPlaylist() {
       blacklistUntilMs = 0;
-      if (loadPending || mediaPlaylistLoader.isLoading()) {
-        // Load already pending or in progress. Do nothing.
+      if (loadPending || mediaPlaylistLoader.isLoading() || mediaPlaylistLoader.hasFatalError()) {
+        // Load already pending, in progress, or a fatal error has been encountered. Do nothing.
         return;
       }
       long currentTimeMs = SystemClock.elapsedRealtime();
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsPlaylistParser.java
index ac1ad3723e..1c6b76a614 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsPlaylistParser.java
@@ -349,6 +349,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                 /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                 /* sampleMimeType= */ null,
                 codecs,
+                /* metadata= */ null,
                 bitrate,
                 width,
                 height,
@@ -422,6 +423,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                       /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                       sampleMimeType,
                       codecs,
+                      /* metadata= */ null,
                       /* bitrate= */ Format.NO_VALUE,
                       width,
                       height,
@@ -451,6 +453,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                   /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                   sampleMimeType,
                   codecs,
+                  /* metadata= */ null,
                   /* bitrate= */ Format.NO_VALUE,
                   channelCount,
                   /* sampleRate= */ Format.NO_VALUE,
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriodTest.java b/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriodTest.java
index 290f5a51a2..41178a78b6 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriodTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/HlsMediaPeriodTest.java
@@ -127,6 +127,7 @@ private static Variant createMuxedVideoAudioVariant(int bitrate) {
             /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
             /* sampleMimeType= */ null,
             /* codecs= */ "avc1.100.41,mp4a.40.2",
+            /* metadata= */ null,
             bitrate,
             /* width= */ Format.NO_VALUE,
             /* height= */ Format.NO_VALUE,
@@ -144,6 +145,7 @@ private static Variant createAudioOnlyVariant(int bitrate) {
             /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
             /* sampleMimeType= */ null,
             /* codecs= */ "mp4a.40.2",
+            /* metadata= */ null,
             bitrate,
             /* width= */ Format.NO_VALUE,
             /* height= */ Format.NO_VALUE,
@@ -176,6 +178,7 @@ private static Format createAudioFormat(String language) {
         /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
         MimeTypes.getMediaMimeType("mp4a.40.2"),
         /* codecs= */ "mp4a.40.2",
+        /* metadata= */ null,
         /* bitrate= */ Format.NO_VALUE,
         /* channelCount= */ Format.NO_VALUE,
         /* sampleRate= */ Format.NO_VALUE,
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/offline/HlsDownloaderTest.java
index ffedd9f9d2..8c596d61eb 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/offline/HlsDownloaderTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/offline/HlsDownloaderTest.java
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer2VRT.offline.DownloaderFactory;
 import com.google.android.exoplayer2VRT.offline.StreamKey;
 import com.google.android.exoplayer2VRT.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2VRT.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2VRT.testutil.FakeDataSet;
 import com.google.android.exoplayer2VRT.testutil.FakeDataSource.Factory;
 import com.google.android.exoplayer2VRT.upstream.DummyDataSource;
@@ -129,12 +130,13 @@ public void testDownloadRepresentation() throws Exception {
 
     assertCachedData(
         cache,
-        fakeDataSet,
-        MASTER_PLAYLIST_URI,
-        MEDIA_PLAYLIST_1_URI,
-        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+        new RequestSet(fakeDataSet)
+            .subset(
+                MASTER_PLAYLIST_URI,
+                MEDIA_PLAYLIST_1_URI,
+                MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts"));
   }
 
   @Test
@@ -186,11 +188,12 @@ public void testDownloadMediaPlaylist() throws Exception {
 
     assertCachedData(
         cache,
-        fakeDataSet,
-        MEDIA_PLAYLIST_1_URI,
-        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+        new RequestSet(fakeDataSet)
+            .subset(
+                MEDIA_PLAYLIST_1_URI,
+                MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts"));
   }
 
   @Test
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 0e44ea2e29..947ca7d052 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2VRT/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -263,7 +263,7 @@ public void testPlaylistWithClosedCaption() throws IOException {
     Format closedCaptionFormat = playlist.muxedCaptionFormats.get(0);
     assertThat(closedCaptionFormat.sampleMimeType).isEqualTo(MimeTypes.APPLICATION_CEA708);
     assertThat(closedCaptionFormat.accessibilityChannel).isEqualTo(4);
-    assertThat(closedCaptionFormat.language).isEqualTo("spa");
+    assertThat(closedCaptionFormat.language).isEqualTo("es");
   }
 
   @Test
diff --git a/library/smoothstreaming/build.gradle b/library/smoothstreaming/build.gradle
index a2e81fb304..fa67ea1d01 100644
--- a/library/smoothstreaming/build.gradle
+++ b/library/smoothstreaming/build.gradle
@@ -41,7 +41,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/DefaultSsChunkSource.java
index 0c4d6161ea..78ee4ec5ec 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/DefaultSsChunkSource.java
@@ -74,10 +74,10 @@ public SsChunkSource createChunkSource(
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int streamElementIndex;
-  private final TrackSelection trackSelection;
   private final ChunkExtractorWrapper[] extractorWrappers;
   private final DataSource dataSource;
 
+  private TrackSelection trackSelection;
   private SsManifest manifest;
   private int currentManifestChunkOffset;
 
@@ -155,6 +155,11 @@ public void updateManifest(SsManifest newManifest) {
     manifest = newManifest;
   }
 
+  @Override
+  public void updateTrackSelection(TrackSelection trackSelection) {
+    this.trackSelection = trackSelection;
+  }
+
   // ChunkSource implementation.
 
   @Override
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsChunkSource.java
index 6c421f5308..90d51595a7 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsChunkSource.java
@@ -55,4 +55,11 @@ SsChunkSource createChunkSource(
    * @param newManifest The new manifest.
    */
   void updateManifest(SsManifest newManifest);
+
+  /**
+   * Updates the track selection.
+   *
+   * @param trackSelection The new track selection instance. Must be equivalent to the previous one.
+   */
+  void updateTrackSelection(TrackSelection trackSelection);
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaPeriod.java
index 9bfbbabc1a..8ba4fdff6c 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaPeriod.java
@@ -126,6 +126,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
           stream.release();
           streams[i] = null;
         } else {
+          stream.getChunkSource().updateTrackSelection(selections[i]);
           sampleStreamsList.add(stream);
         }
       }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaSource.java
index bfef8218d6..36f119769d 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/SsMediaSource.java
@@ -723,6 +723,9 @@ private void scheduleManifestRefresh() {
   }
 
   private void startLoadingManifest() {
+    if (manifestLoader.hasFatalError()) {
+      return;
+    }
     ParsingLoadable<SsManifest> loadable = new ParsingLoadable<>(manifestDataSource,
         manifestUri, C.DATA_TYPE_MANIFEST, manifestParser);
     long elapsedRealtimeMs =
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/manifest/SsManifestParser.java
index 0e54b5c22e..5dbafec270 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2VRT/source/smoothstreaming/manifest/SsManifestParser.java
@@ -586,6 +586,7 @@ private void parseStreamElementStartTag(XmlPullParser parser) throws ParserExcep
       } else {
         subType = parser.getAttributeValue(null, KEY_SUB_TYPE);
       }
+      putNormalizedAttribute(KEY_SUB_TYPE, subType);
       name = parser.getAttributeValue(null, KEY_NAME);
       url = parseRequiredString(parser, KEY_URL);
       maxWidth = parseInt(parser, KEY_MAX_WIDTH, Format.NO_VALUE);
@@ -645,6 +646,7 @@ public Object build() {
     private static final String KEY_CHANNELS = "Channels";
     private static final String KEY_FOUR_CC = "FourCC";
     private static final String KEY_TYPE = "Type";
+    private static final String KEY_SUB_TYPE = "Subtype";
     private static final String KEY_LANGUAGE = "Language";
     private static final String KEY_NAME = "Name";
     private static final String KEY_MAX_WIDTH = "MaxWidth";
@@ -676,6 +678,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 MimeTypes.VIDEO_MP4,
                 sampleMimeType,
                 /* codecs= */ null,
+                /* metadata= */ null,
                 bitrate,
                 width,
                 height,
@@ -701,6 +704,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 MimeTypes.AUDIO_MP4,
                 sampleMimeType,
                 /* codecs= */ null,
+                /* metadata= */ null,
                 bitrate,
                 channels,
                 samplingRate,
@@ -709,6 +713,18 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* roleFlags= */ 0,
                 language);
       } else if (type == C.TRACK_TYPE_TEXT) {
+        String subType = (String) getNormalizedAttribute(KEY_SUB_TYPE);
+        @C.RoleFlags int roleFlags = 0;
+        switch (subType) {
+          case "CAPT":
+            roleFlags = C.ROLE_FLAG_CAPTION;
+            break;
+          case "DESC":
+            roleFlags = C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND;
+            break;
+          default:
+            break;
+        }
         String language = (String) getNormalizedAttribute(KEY_LANGUAGE);
         format =
             Format.createTextContainerFormat(
@@ -719,7 +735,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* codecs= */ null,
                 bitrate,
                 /* selectionFlags= */ 0,
-                /* roleFlags= */ 0,
+                roleFlags,
                 language);
       } else {
         format =
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index 49446b25de..5182dfccf5 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -40,8 +40,8 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.media:media:1.0.0'
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.media:media:1.0.1'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/AspectRatioFrameLayout.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/AspectRatioFrameLayout.java
index d53372e2b3..00c5c7d5bf 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/AspectRatioFrameLayout.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/AspectRatioFrameLayout.java
@@ -18,6 +18,7 @@
 import android.content.Context;
 import android.content.res.TypedArray;
 import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 import java.lang.annotation.Documented;
@@ -97,16 +98,16 @@ void onAspectRatioUpdated(
 
   private final AspectRatioUpdateDispatcher aspectRatioUpdateDispatcher;
 
-  private AspectRatioListener aspectRatioListener;
+  @Nullable private AspectRatioListener aspectRatioListener;
 
   private float videoAspectRatio;
-  private @ResizeMode int resizeMode;
+  @ResizeMode private int resizeMode;
 
   public AspectRatioFrameLayout(Context context) {
-    this(context, null);
+    this(context, /* attrs= */ null);
   }
 
-  public AspectRatioFrameLayout(Context context, AttributeSet attrs) {
+  public AspectRatioFrameLayout(Context context, @Nullable AttributeSet attrs) {
     super(context, attrs);
     resizeMode = RESIZE_MODE_FIT;
     if (attrs != null) {
@@ -136,9 +137,10 @@ public void setAspectRatio(float widthHeightRatio) {
   /**
    * Sets the {@link AspectRatioListener}.
    *
-   * @param listener The listener to be notified about aspect ratios changes.
+   * @param listener The listener to be notified about aspect ratios changes, or null to clear a
+   *     listener that was previously set.
    */
-  public void setAspectRatioListener(AspectRatioListener listener) {
+  public void setAspectRatioListener(@Nullable AspectRatioListener listener) {
     this.aspectRatioListener = listener;
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/DefaultTimeBar.java
index 0c6ee29bef..f331d2c7eb 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/DefaultTimeBar.java
@@ -220,11 +220,26 @@
   private @Nullable long[] adGroupTimesMs;
   private @Nullable boolean[] playedAdGroups;
 
-  /** Creates a new time bar. */
+  public DefaultTimeBar(Context context) {
+    this(context, null);
+  }
+
+  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs) {
+    this(context, attrs, 0);
+  }
+
+  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
+    this(context, attrs, defStyleAttr, attrs);
+  }
+
   // Suppress warnings due to usage of View methods in the constructor.
   @SuppressWarnings("nullness:method.invocation.invalid")
-  public DefaultTimeBar(Context context, AttributeSet attrs) {
-    super(context, attrs);
+  public DefaultTimeBar(
+      Context context,
+      @Nullable AttributeSet attrs,
+      int defStyleAttr,
+      @Nullable AttributeSet timebarAttrs) {
+    super(context, attrs, defStyleAttr);
     seekBounds = new Rect();
     progressBar = new Rect();
     bufferedBar = new Rect();
@@ -251,9 +266,9 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     int defaultScrubberEnabledSize = dpToPx(density, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
     int defaultScrubberDisabledSize = dpToPx(density, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
     int defaultScrubberDraggedSize = dpToPx(density, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
-    if (attrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
-          0);
+    if (timebarAttrs != null) {
+      TypedArray a =
+          context.getTheme().obtainStyledAttributes(timebarAttrs, R.styleable.DefaultTimeBar, 0, 0);
       try {
         scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
         if (scrubberDrawable != null) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerControlView.java
index 34b19cd510..64d7851cd5 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerControlView.java
@@ -28,6 +28,7 @@
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewGroup;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.TextView;
@@ -97,6 +98,9 @@
  *         <li>Corresponding method: None
  *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
+ *   <li>All attributes that can be set on {@link DefaultTimeBar} can also be set on a
+ *       PlayerControlView, and will be propagated to the inflated {@link DefaultTimeBar} unless the
+ *       layout is overridden to specify a custom {@code exo_progress} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
@@ -154,7 +158,15 @@
  *       <ul>
  *         <li>Type: {@link TextView}
  *       </ul>
+ *   <li><b>{@code exo_progress_placeholder}</b> - A placeholder that's replaced with the inflated
+ *       {@link DefaultTimeBar}. Ignored if an {@code exo_progress} view exists.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
  *   <li><b>{@code exo_progress}</b> - Time bar that's updated during playback and allows seeking.
+ *       {@link DefaultTimeBar} attributes set on the PlayerControlView will not be automatically
+ *       propagated through to this instance. If a view exists with this id, any {@code
+ *       exo_progress_placeholder} view will be ignored.
  *       <ul>
  *         <li>Type: {@link TimeBar}
  *       </ul>
@@ -188,6 +200,18 @@
     void onVisibilityChange(int visibility);
   }
 
+  /** Listener to be notified when progress has been updated. */
+  public interface ProgressUpdateListener {
+
+    /**
+     * Called when progress needs to be updated.
+     *
+     * @param position The current position.
+     * @param bufferedPosition The current buffered position.
+     */
+    void onProgressUpdate(long position, long bufferedPosition);
+  }
+
   /** The default fast forward increment, in milliseconds. */
   public static final int DEFAULT_FAST_FORWARD_MS = 15000;
   /** The default rewind increment, in milliseconds. */
@@ -214,7 +238,7 @@
   private final View fastForwardButton;
   private final View rewindButton;
   private final ImageView repeatToggleButton;
-  private final View shuffleButton;
+  private final ImageView shuffleButton;
   private final View vrButton;
   private final TextView durationView;
   private final TextView positionView;
@@ -232,10 +256,17 @@
   private final String repeatOffButtonContentDescription;
   private final String repeatOneButtonContentDescription;
   private final String repeatAllButtonContentDescription;
+  private final Drawable shuffleOnButtonDrawable;
+  private final Drawable shuffleOffButtonDrawable;
+  private final float buttonAlphaEnabled;
+  private final float buttonAlphaDisabled;
+  private final String shuffleOnContentDescription;
+  private final String shuffleOffContentDescription;
 
   @Nullable private Player player;
   private com.google.android.exoplayer2VRT.ControlDispatcher controlDispatcher;
-  private VisibilityListener visibilityListener;
+  @Nullable private VisibilityListener visibilityListener;
+  @Nullable private ProgressUpdateListener progressUpdateListener;
   @Nullable private PlaybackPreparer playbackPreparer;
 
   private boolean isAttachedToWindow;
@@ -256,19 +287,22 @@
   private long currentWindowOffset;
 
   public PlayerControlView(Context context) {
-    this(context, null);
+    this(context, /* attrs= */ null);
   }
 
-  public PlayerControlView(Context context, AttributeSet attrs) {
+  public PlayerControlView(Context context, @Nullable AttributeSet attrs) {
     this(context, attrs, 0);
   }
 
-  public PlayerControlView(Context context, AttributeSet attrs, int defStyleAttr) {
+  public PlayerControlView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
     this(context, attrs, defStyleAttr, attrs);
   }
 
   public PlayerControlView(
-      Context context, AttributeSet attrs, int defStyleAttr, AttributeSet playbackAttrs) {
+      Context context,
+      @Nullable AttributeSet attrs,
+      int defStyleAttr,
+      @Nullable AttributeSet playbackAttrs) {
     super(context, attrs, defStyleAttr);
     int controllerLayoutId = R.layout.exo_vrt_player_control_view;
     rewindMs = DEFAULT_REWIND_MS;
@@ -317,9 +351,27 @@ public PlayerControlView(
     LayoutInflater.from(context).inflate(controllerLayoutId, this);
     setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
 
+    TimeBar customTimeBar = findViewById(R.id.exo_progress);
+    View timeBarPlaceholder = findViewById(R.id.exo_progress_placeholder);
+    if (customTimeBar != null) {
+      timeBar = customTimeBar;
+    } else if (timeBarPlaceholder != null) {
+      // Propagate attrs as timebarAttrs so that DefaultTimeBar's custom attributes are transferred,
+      // but standard attributes (e.g. background) are not.
+      DefaultTimeBar defaultTimeBar = new DefaultTimeBar(context, null, 0, playbackAttrs);
+      defaultTimeBar.setId(R.id.exo_progress);
+      defaultTimeBar.setLayoutParams(timeBarPlaceholder.getLayoutParams());
+      ViewGroup parent = ((ViewGroup) timeBarPlaceholder.getParent());
+      int timeBarIndex = parent.indexOfChild(timeBarPlaceholder);
+      parent.removeView(timeBarPlaceholder);
+      parent.addView(defaultTimeBar, timeBarIndex);
+      timeBar = defaultTimeBar;
+    } else {
+      timeBar = null;
+    }
     durationView = findViewById(R.id.exo_duration);
     positionView = findViewById(R.id.exo_position);
-    timeBar = findViewById(R.id.exo_progress);
+
     if (timeBar != null) {
       timeBar.addListener(componentListener);
     }
@@ -357,16 +409,28 @@ public PlayerControlView(
     }
     vrButton = findViewById(R.id.exo_vr);
     setShowVrButton(false);
+
     Resources resources = context.getResources();
+
+    buttonAlphaEnabled =
+        (float) resources.getInteger(R.integer.exo_media_button_opacity_percentage_enabled) / 100;
+    buttonAlphaDisabled =
+        (float) resources.getInteger(R.integer.exo_media_button_opacity_percentage_disabled) / 100;
+
     repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off);
     repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one);
     repeatAllButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_all);
+    shuffleOnButtonDrawable = resources.getDrawable(R.drawable.exo_controls_shuffle_on);
+    shuffleOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_shuffle_off);
     repeatOffButtonContentDescription =
         resources.getString(R.string.exo_controls_repeat_off_description);
     repeatOneButtonContentDescription =
         resources.getString(R.string.exo_controls_repeat_one_description);
     repeatAllButtonContentDescription =
         resources.getString(R.string.exo_controls_repeat_all_description);
+    shuffleOnContentDescription = resources.getString(R.string.exo_controls_shuffle_on_description);
+    shuffleOffContentDescription =
+        resources.getString(R.string.exo_controls_shuffle_off_description);
   }
 
   @SuppressWarnings("ResourceType")
@@ -454,6 +518,15 @@ public void setVisibilityListener(VisibilityListener listener) {
     this.visibilityListener = listener;
   }
 
+  /**
+   * Sets the {@link ProgressUpdateListener}.
+   *
+   * @param listener The listener to be notified about when progress is updated.
+   */
+  public void setProgressUpdateListener(@Nullable ProgressUpdateListener listener) {
+    this.progressUpdateListener = listener;
+  }
+
   /**
    * Sets the {@link PlaybackPreparer}.
    *
@@ -730,6 +803,8 @@ private void updateRepeatModeButton() {
     }
     if (player == null) {
       setButtonEnabled(false, repeatToggleButton);
+      repeatToggleButton.setImageDrawable(repeatOffButtonDrawable);
+      repeatToggleButton.setContentDescription(repeatOffButtonContentDescription);
       return;
     }
     setButtonEnabled(true, repeatToggleButton);
@@ -760,10 +835,16 @@ private void updateShuffleButton() {
       shuffleButton.setVisibility(GONE);
     } else if (player == null) {
       setButtonEnabled(false, shuffleButton);
+      shuffleButton.setImageDrawable(shuffleOffButtonDrawable);
+      shuffleButton.setContentDescription(shuffleOffContentDescription);
     } else {
-      shuffleButton.setAlpha(player.getShuffleModeEnabled() ? 1f : 0.3f);
-      shuffleButton.setEnabled(true);
-      shuffleButton.setVisibility(VISIBLE);
+      setButtonEnabled(true, shuffleButton);
+      shuffleButton.setImageDrawable(
+          player.getShuffleModeEnabled() ? shuffleOnButtonDrawable : shuffleOffButtonDrawable);
+      shuffleButton.setContentDescription(
+          player.getShuffleModeEnabled()
+              ? shuffleOnContentDescription
+              : shuffleOffContentDescription);
     }
   }
 
@@ -855,6 +936,9 @@ private void updateProgress() {
       timeBar.setPosition(position);
       timeBar.setBufferedPosition(bufferedPosition);
     }
+    if (progressUpdateListener != null) {
+      progressUpdateListener.onProgressUpdate(position, bufferedPosition);
+    }
 
     // Cancel any pending updates and schedule a new one if necessary.
     removeCallbacks(updateProgressAction);
@@ -894,7 +978,7 @@ private void setButtonEnabled(boolean enabled, View view) {
       return;
     }
     view.setEnabled(enabled);
-    view.setAlpha(enabled ? 1f : 0.3f);
+    view.setAlpha(enabled ? buttonAlphaEnabled : buttonAlphaDisabled);
     view.setVisibility(VISIBLE);
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerNotificationManager.java
index 75ce5c9187..f3e445fbfc 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerNotificationManager.java
@@ -385,6 +385,26 @@ public void onBitmap(final Bitmap bitmap) {
   private boolean wasPlayWhenReady;
   private int lastPlaybackState;
 
+  /**
+   * @deprecated Use {@link #createWithNotificationChannel(Context, String, int, int, int,
+   *     MediaDescriptionAdapter)}.
+   */
+  @Deprecated
+  public static PlayerNotificationManager createWithNotificationChannel(
+      Context context,
+      String channelId,
+      @StringRes int channelName,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter) {
+    return createWithNotificationChannel(
+        context,
+        channelId,
+        channelName,
+        /* channelDescription= */ 0,
+        notificationId,
+        mediaDescriptionAdapter);
+  }
+
   /**
    * Creates a notification manager and a low-priority notification channel with the specified
    * {@code channelId} and {@code channelName}.
@@ -397,8 +417,12 @@ public void onBitmap(final Bitmap bitmap) {
    *
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
-   * @param channelName A string resource identifier for the user visible name of the channel. The
-   *     recommended maximum length is 40 characters; the value may be truncated if it is too long.
+   * @param channelName A string resource identifier for the user visible name of the notification
+   *     channel. The recommended maximum length is 40 characters. The string may be truncated if
+   *     it's too long.
+   * @param channelDescription A string resource identifier for the user visible description of the
+   *     notification channel, or 0 if no description is provided. The recommended maximum length is
+   *     300 characters. The value may be truncated if it is too long.
    * @param notificationId The id of the notification.
    * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
    */
@@ -406,14 +430,37 @@ public static PlayerNotificationManager createWithNotificationChannel(
       Context context,
       String channelId,
       @StringRes int channelName,
+      @StringRes int channelDescription,
       int notificationId,
       MediaDescriptionAdapter mediaDescriptionAdapter) {
     NotificationUtil.createNotificationChannel(
-        context, channelId, channelName, NotificationUtil.IMPORTANCE_LOW);
+        context, channelId, channelName, channelDescription, NotificationUtil.IMPORTANCE_LOW);
     return new PlayerNotificationManager(
         context, channelId, notificationId, mediaDescriptionAdapter);
   }
 
+  /**
+   * @deprecated Use {@link #createWithNotificationChannel(Context, String, int, int, int,
+   *     MediaDescriptionAdapter, NotificationListener)}.
+   */
+  @Deprecated
+  public static PlayerNotificationManager createWithNotificationChannel(
+      Context context,
+      String channelId,
+      @StringRes int channelName,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter,
+      @Nullable NotificationListener notificationListener) {
+    return createWithNotificationChannel(
+        context,
+        channelId,
+        channelName,
+        /* channelDescription= */ 0,
+        notificationId,
+        mediaDescriptionAdapter,
+        notificationListener);
+  }
+
   /**
    * Creates a notification manager and a low-priority notification channel with the specified
    * {@code channelId} and {@code channelName}. The {@link NotificationListener} passed as the last
@@ -422,7 +469,9 @@ public static PlayerNotificationManager createWithNotificationChannel(
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
    * @param channelName A string resource identifier for the user visible name of the channel. The
-   *     recommended maximum length is 40 characters; the value may be truncated if it is too long.
+   *     recommended maximum length is 40 characters. The string may be truncated if it's too long.
+   * @param channelDescription A string resource identifier for the user visible description of the
+   *     channel, or 0 if no description is provided.
    * @param notificationId The id of the notification.
    * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
    * @param notificationListener The {@link NotificationListener}.
@@ -431,11 +480,12 @@ public static PlayerNotificationManager createWithNotificationChannel(
       Context context,
       String channelId,
       @StringRes int channelName,
+      @StringRes int channelDescription,
       int notificationId,
       MediaDescriptionAdapter mediaDescriptionAdapter,
       @Nullable NotificationListener notificationListener) {
     NotificationUtil.createNotificationChannel(
-        context, channelId, channelName, NotificationUtil.IMPORTANCE_LOW);
+        context, channelId, channelName, channelDescription, NotificationUtil.IMPORTANCE_LOW);
     return new PlayerNotificationManager(
         context, channelId, notificationId, mediaDescriptionAdapter, notificationListener);
   }
@@ -966,7 +1016,8 @@ private void stopNotification(boolean dismissedByUser) {
       @Nullable NotificationCompat.Builder builder,
       boolean ongoing,
       @Nullable Bitmap largeIcon) {
-    if (player.getPlaybackState() == Player.STATE_IDLE) {
+    if (player.getPlaybackState() == Player.STATE_IDLE
+        && (player.getCurrentTimeline().isEmpty() || playbackPreparer == null)) {
       builderActions = null;
       return null;
     }
@@ -1131,10 +1182,10 @@ private void stopNotification(boolean dismissedByUser) {
     if (skipPreviousActionIndex != -1) {
       actionIndices[actionCounter++] = skipPreviousActionIndex;
     }
-    boolean playWhenReady = player.getPlayWhenReady();
-    if (pauseActionIndex != -1 && playWhenReady) {
+    boolean isPlaying = isPlaying(player);
+    if (pauseActionIndex != -1 && isPlaying) {
       actionIndices[actionCounter++] = pauseActionIndex;
-    } else if (playActionIndex != -1 && !playWhenReady) {
+    } else if (playActionIndex != -1 && !isPlaying) {
       actionIndices[actionCounter++] = playActionIndex;
     }
     if (skipNextActionIndex != -1) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerView.java
index 23ecec53d7..6c2d96d803 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/PlayerView.java
@@ -35,7 +35,6 @@
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
-import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.TextureView;
 import android.view.View;
@@ -50,8 +49,8 @@
 import com.google.android.exoplayer2VRT.PlaybackPreparer;
 import com.google.android.exoplayer2VRT.Player;
 import com.google.android.exoplayer2VRT.Player.DiscontinuityReason;
-import com.google.android.exoplayer2VRT.Player.VideoComponent;
 import com.google.android.exoplayer2VRT.metadata.Metadata;
+import com.google.android.exoplayer2VRT.metadata.flac.PictureFrame;
 import com.google.android.exoplayer2VRT.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2VRT.source.TrackGroupArray;
 import com.google.android.exoplayer2VRT.source.ads.AdsLoader;
@@ -165,9 +164,10 @@
  *         <li>Corresponding method: None
  *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
- *   <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
- *       PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
- *       layout is overridden to specify a custom {@code exo_controller} (see below).
+ *   <li>All attributes that can be set on {@link PlayerControlView} and {@link DefaultTimeBar} can
+ *       also be set on a PlayerView, and will be propagated to the inflated {@link
+ *       PlayerControlView} unless the layout is overridden to specify a custom {@code
+ *       exo_controller} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
@@ -217,9 +217,10 @@
  *         <li>Type: {@link View}
  *       </ul>
  *   <li><b>{@code exo_controller}</b> - An already inflated {@link PlayerControlView}. Allows use
- *       of a custom extension of {@link PlayerControlView}. Note that attributes such as {@code
- *       rewind_increment} will not be automatically propagated through to this instance. If a view
- *       exists with this id, any {@code exo_controller_placeholder} view will be ignored.
+ *       of a custom extension of {@link PlayerControlView}. {@link PlayerControlView} and {@link
+ *       DefaultTimeBar} attributes set on the PlayerView will not be automatically propagated
+ *       through to this instance. If a view exists with this id, any {@code
+ *       exo_controller_placeholder} view will be ignored.
  *       <ul>
  *         <li>Type: {@link PlayerControlView}
  *       </ul>
@@ -303,6 +304,9 @@
   private boolean controllerHideDuringAds;
   private boolean controllerHideOnTouch;
   private int textureViewRotation;
+  private boolean isTouching;
+  private static final int PICTURE_TYPE_FRONT_COVER = 3;
+  private static final int PICTURE_TYPE_NOT_SET = -1;
 
   public PlayerView(Context context) {
     this(context, null);
@@ -405,7 +409,6 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
           break;
         case SURFACE_TYPE_MONO360_VIEW:
           SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
-          sphericalSurfaceView.setSurfaceListener(componentListener);
           sphericalSurfaceView.setSingleTapListener(componentListener);
           surfaceView = sphericalSurfaceView;
           break;
@@ -459,8 +462,9 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       this.controller = customController;
     } else if (controllerPlaceholder != null) {
       // Propagate attrs as playbackAttrs so that PlayerControlView's custom attributes are
-      // transferred, but standard FrameLayout attributes (e.g. background) are not.
+      // transferred, but standard attributes (e.g. background) are not.
       this.controller = new PlayerControlView(context, null, 0, attrs);
+      controller.setId(R.id.exo_controller);
       controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
       ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
       int controllerIndex = parent.indexOfChild(controllerPlaceholder);
@@ -771,11 +775,20 @@ public boolean dispatchKeyEvent(KeyEvent event) {
     if (player != null && player.isPlayingAd()) {
       return super.dispatchKeyEvent(event);
     }
-    boolean isDpadWhenControlHidden =
-        isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
-    boolean handled =
-        isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-    if (handled) {
+
+    boolean isDpadAndUseController = isDpadKey(event.getKeyCode()) && useController;
+    boolean handled = false;
+    if (isDpadAndUseController && !controller.isVisible()) {
+      // Handle the key event by showing the controller.
+      maybeShowController(true);
+      handled = true;
+    } else if (dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event)) {
+      // The key event was handled as a media key or by the super class. We should also show the
+      // controller, or extend its show timeout if already visible.
+      maybeShowController(true);
+      handled = true;
+    } else if (isDpadAndUseController) {
+      // The key event wasn't handled, but we should extend the controller's show timeout.
       maybeShowController(true);
     }
     return handled;
@@ -1039,11 +1052,24 @@ public SubtitleView getSubtitleView() {
   }
 
   @Override
-  public boolean onTouchEvent(MotionEvent ev) {
-    if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+  public boolean onTouchEvent(MotionEvent event) {
+    if (!useController || player == null) {
       return false;
     }
-    return performClick();
+    switch (event.getAction()) {
+      case MotionEvent.ACTION_DOWN:
+        isTouching = true;
+        return true;
+      case MotionEvent.ACTION_UP:
+        if (isTouching) {
+          isTouching = false;
+          performClick();
+          return true;
+        }
+        return false;
+      default:
+        return false;
+    }
   }
 
   @Override
@@ -1226,15 +1252,32 @@ private void updateForCurrentTrackSelections(boolean isNewPlayer) {
   }
 
   private boolean setArtworkFromMetadata(Metadata metadata) {
+    boolean isArtworkSet = false;
+    int currentPictureType = PICTURE_TYPE_NOT_SET;
     for (int i = 0; i < metadata.length(); i++) {
       Metadata.Entry metadataEntry = metadata.get(i);
+      int pictureType;
+      byte[] bitmapData;
       if (metadataEntry instanceof ApicFrame) {
-        byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
+        bitmapData = ((ApicFrame) metadataEntry).pictureData;
+        pictureType = ((ApicFrame) metadataEntry).pictureType;
+      } else if (metadataEntry instanceof PictureFrame) {
+        bitmapData = ((PictureFrame) metadataEntry).pictureData;
+        pictureType = ((PictureFrame) metadataEntry).pictureType;
+      } else {
+        continue;
+      }
+      // Prefer the first front cover picture. If there aren't any, prefer the first picture.
+      if (currentPictureType == PICTURE_TYPE_NOT_SET || pictureType == PICTURE_TYPE_FRONT_COVER) {
         Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        return setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
+        isArtworkSet = setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
+        currentPictureType = pictureType;
+        if (currentPictureType == PICTURE_TYPE_FRONT_COVER) {
+          break;
+        }
       }
     }
-    return false;
+    return isArtworkSet;
   }
 
   private boolean setDrawableArtwork(@Nullable Drawable drawable) {
@@ -1359,7 +1402,6 @@ private boolean isDpadKey(int keyCode) {
           TextOutput,
           VideoListener,
           OnLayoutChangeListener,
-          SphericalSurfaceView.SurfaceListener,
           SingleTapListener {
 
     // TextOutput implementation
@@ -1449,18 +1491,6 @@ public void onLayoutChange(
       applyTextureViewRotation((TextureView) view, textureViewRotation);
     }
 
-    // SphericalSurfaceView.SurfaceTextureListener implementation
-
-    @Override
-    public void surfaceChanged(@Nullable Surface surface) {
-      if (player != null) {
-        VideoComponent videoComponent = player.getVideoComponent();
-        if (videoComponent != null) {
-          videoComponent.setVideoSurface(surface);
-        }
-      }
-    }
-
     // SingleTapListener implementation
 
     @Override
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitlePainter.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitlePainter.java
index 8c222d530f..a5633ed0f4 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitlePainter.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitlePainter.java
@@ -362,10 +362,16 @@ private void setupBitmapLayout() {
     int width = Math.round(parentWidth * cueSize);
     int height = cueBitmapHeight != Cue.DIMEN_UNSET ? Math.round(parentHeight * cueBitmapHeight)
         : Math.round(width * ((float) cueBitmap.getHeight() / cueBitmap.getWidth()));
-    int x = Math.round(cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width)
-        : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
-    int y = Math.round(cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - height)
-        : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
+    int x =
+        Math.round(
+            cuePositionAnchor == Cue.ANCHOR_TYPE_END
+                ? (anchorX - width)
+                : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
+    int y =
+        Math.round(
+            cueLineAnchor == Cue.ANCHOR_TYPE_END
+                ? (anchorY - height)
+                : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
     bitmapRect = new Rect(x, y, x + width, y + height);
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitleView.java
index 08e562301b..2cde2835c0 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/SubtitleView.java
@@ -53,8 +53,8 @@
 
   private final List<SubtitlePainter> painters;
 
-  private List<Cue> cues;
-  private @Cue.TextSizeType int textSizeType;
+  @Nullable private List<Cue> cues;
+  @Cue.TextSizeType private int textSizeType;
   private float textSize;
   private boolean applyEmbeddedStyles;
   private boolean applyEmbeddedFontSizes;
@@ -62,10 +62,10 @@
   private float bottomPaddingFraction;
 
   public SubtitleView(Context context) {
-    this(context, null);
+    this(context, /* attrs= */ null);
   }
 
-  public SubtitleView(Context context, AttributeSet attrs) {
+  public SubtitleView(Context context, @Nullable AttributeSet attrs) {
     super(context, attrs);
     painters = new ArrayList<>();
     textSizeType = Cue.TEXT_SIZE_TYPE_FRACTIONAL;
@@ -246,7 +246,11 @@ public void setBottomPaddingFraction(float bottomPaddingFraction) {
 
   @Override
   public void dispatchDraw(Canvas canvas) {
-    int cueCount = (cues == null) ? 0 : cues.size();
+    List<Cue> cues = this.cues;
+    if (cues == null || cues.isEmpty()) {
+      return;
+    }
+
     int rawViewHeight = getHeight();
 
     // Calculate the cue box bounds relative to the canvas after padding is taken into account.
@@ -267,6 +271,7 @@ public void dispatchDraw(Canvas canvas) {
       return;
     }
 
+    int cueCount = cues.size();
     for (int i = 0; i < cueCount; i++) {
       Cue cue = cues.get(i);
       float cueTextSizePx = resolveCueTextSize(cue, rawViewHeight, viewHeightMinusPadding);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/spherical/SphericalSurfaceView.java b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/spherical/SphericalSurfaceView.java
index 306ee69b82..c422d15f8b 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/spherical/SphericalSurfaceView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2VRT/ui/spherical/SphericalSurfaceView.java
@@ -53,20 +53,6 @@
  */
 public final class SphericalSurfaceView extends GLSurfaceView {
 
-  /**
-   * This listener can be used to be notified when the {@link Surface} associated with this view is
-   * changed.
-   */
-  public interface SurfaceListener {
-    /**
-     * Invoked when the surface is changed or there isn't one anymore. Any previous surface
-     * shouldn't be used after this call.
-     *
-     * @param surface The new surface or null if there isn't one anymore.
-     */
-    void surfaceChanged(@Nullable Surface surface);
-  }
-
   // Arbitrary vertical field of view.
   private static final int FIELD_OF_VIEW_DEGREES = 90;
   private static final float Z_NEAR = .1f;
@@ -84,7 +70,6 @@
   private final Handler mainHandler;
   private final TouchTracker touchTracker;
   private final SceneRenderer scene;
-  private @Nullable SurfaceListener surfaceListener;
   private @Nullable SurfaceTexture surfaceTexture;
   private @Nullable Surface surface;
   private @Nullable Player.VideoComponent videoComponent;
@@ -156,15 +141,6 @@ public void setVideoComponent(@Nullable Player.VideoComponent newVideoComponent)
     }
   }
 
-  /**
-   * Sets the {@link SurfaceListener} used to listen to surface events.
-   *
-   * @param listener The listener for surface events.
-   */
-  public void setSurfaceListener(@Nullable SurfaceListener listener) {
-    surfaceListener = listener;
-  }
-
   /** Sets the {@link SingleTapListener} used to listen to single tap events on this view. */
   public void setSingleTapListener(@Nullable SingleTapListener listener) {
     touchTracker.setSingleTapListener(listener);
@@ -196,8 +172,8 @@ protected void onDetachedFromWindow() {
     mainHandler.post(
         () -> {
           if (surface != null) {
-            if (surfaceListener != null) {
-              surfaceListener.surfaceChanged(null);
+            if (videoComponent != null) {
+              videoComponent.clearVideoSurface(surface);
             }
             releaseSurface(surfaceTexture, surface);
             surfaceTexture = null;
@@ -214,8 +190,8 @@ private void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture) {
           Surface oldSurface = this.surface;
           this.surfaceTexture = surfaceTexture;
           this.surface = new Surface(surfaceTexture);
-          if (surfaceListener != null) {
-            surfaceListener.surfaceChanged(surface);
+          if (videoComponent != null) {
+            videoComponent.setVideoSurface(surface);
           }
           releaseSurface(oldSurfaceTexture, oldSurface);
         });
diff --git a/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle_off.xml b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle_off.xml
new file mode 100644
index 0000000000..283ce30c3c
--- /dev/null
+++ b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle_off.xml
@@ -0,0 +1,26 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportWidth="24.0"
+    android:viewportHeight="24.0">
+
+    <path
+        android:fillColor="#4EFFFFFF"
+        android:pathData="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20
+17.96 7.46 20 9.5V4h-5.5zm0.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04
+2.04-3.13-3.13z" />
+</vector>
diff --git a/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle.xml b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle_on.xml
similarity index 100%
rename from library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle.xml
rename to library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle_on.xml
diff --git a/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle_off.png b/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle_off.png
new file mode 100644
index 0000000000..b693422db7
Binary files /dev/null and b/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle_off.png differ
diff --git a/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle_on.png
similarity index 100%
rename from library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle.png
rename to library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle_on.png
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle_off.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle_off.png
new file mode 100644
index 0000000000..2353dd4289
Binary files /dev/null and b/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle_off.png differ
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle_on.png
similarity index 100%
rename from library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle.png
rename to library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle_on.png
diff --git a/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle_off.png b/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle_off.png
new file mode 100644
index 0000000000..a55d716cce
Binary files /dev/null and b/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle_off.png differ
diff --git a/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle_on.png
similarity index 100%
rename from library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle.png
rename to library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle_on.png
diff --git a/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle_off.png b/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle_off.png
new file mode 100644
index 0000000000..2b67cabf5a
Binary files /dev/null and b/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle_off.png differ
diff --git a/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle_on.png
similarity index 100%
rename from library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle.png
rename to library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle_on.png
diff --git a/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle_off.png b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle_off.png
new file mode 100644
index 0000000000..22209d1f88
Binary files /dev/null and b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle_off.png differ
diff --git a/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle_on.png
similarity index 100%
rename from library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle.png
rename to library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle_on.png
diff --git a/library/ui/src/main/res/layout/exo_vrt_playback_control_view.xml b/library/ui/src/main/res/layout/exo_vrt_playback_control_view.xml
index 7d33ed07a6..acfddf1146 100644
--- a/library/ui/src/main/res/layout/exo_vrt_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_vrt_playback_control_view.xml
@@ -37,7 +37,7 @@
       style="@style/ExoMediaButton.Rewind"/>
 
     <ImageButton android:id="@id/exo_shuffle"
-      style="@style/ExoMediaButton.Shuffle"/>
+      style="@style/ExoMediaButton"/>
 
     <ImageButton android:id="@id/exo_repeat_toggle"
       style="@style/ExoMediaButton"/>
@@ -76,8 +76,7 @@
       android:includeFontPadding="false"
       android:textColor="#FFBEBEBE"/>
 
-    <com.google.android.exoplayer2VRT.ui.DefaultTimeBar
-      android:id="@id/exo_progress"
+    <View android:id="@id/exo_progress_placeholder"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="26dp"/>
diff --git a/library/ui/src/main/res/values-af/strings.xml b/library/ui/src/main/res/values-af/strings.xml
index 8a983c543a..f7802e7648 100644
--- a/library/ui/src/main/res/values-af/strings.xml
+++ b/library/ui/src/main/res/values-af/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Vorige snit</string>
   <string name="exo_controls_next_description">Volgende snit</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Herhaal niks</string>
   <string name="exo_controls_repeat_one_description">Herhaal een</string>
   <string name="exo_controls_repeat_all_description">Herhaal alles</string>
-  <string name="exo_controls_shuffle_description">Skommel</string>
+  <string name="exo_controls_shuffle_on_description">Skommel is aan</string>
+  <string name="exo_controls_shuffle_off_description">Skommel is af</string>
   <string name="exo_controls_fullscreen_description">Volskermmodus</string>
   <string name="exo_controls_vr_description">VR-modus</string>
   <string name="exo_download_description">Aflaai</string>
diff --git a/library/ui/src/main/res/values-am/strings.xml b/library/ui/src/main/res/values-am/strings.xml
index f56a6c06bf..489c18acf2 100644
--- a/library/ui/src/main/res/values-am/strings.xml
+++ b/library/ui/src/main/res/values-am/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">ቀዳሚ ትራክ</string>
   <string name="exo_controls_next_description">ቀጣይ ትራክ</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">ምንም አትድገም</string>
   <string name="exo_controls_repeat_one_description">አንድ ድገም</string>
   <string name="exo_controls_repeat_all_description">ሁሉንም ድገም</string>
-  <string name="exo_controls_shuffle_description">በውዝ</string>
+  <string name="exo_controls_shuffle_on_description">መበወዝ በርቷል</string>
+  <string name="exo_controls_shuffle_off_description">መበወዝ ጠፍቷል</string>
   <string name="exo_controls_fullscreen_description">የሙሉ ማያ ሁነታ</string>
   <string name="exo_controls_vr_description">የቪአር ሁነታ</string>
   <string name="exo_download_description">አውርድ</string>
diff --git a/library/ui/src/main/res/values-ar/strings.xml b/library/ui/src/main/res/values-ar/strings.xml
index 91063e1a54..b341fc1a42 100644
--- a/library/ui/src/main/res/values-ar/strings.xml
+++ b/library/ui/src/main/res/values-ar/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">المقطع الصوتي السابق</string>
   <string name="exo_controls_next_description">المقطع الصوتي التالي</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">عدم التكرار</string>
   <string name="exo_controls_repeat_one_description">تكرار مقطع صوتي واحد</string>
   <string name="exo_controls_repeat_all_description">تكرار الكل</string>
-  <string name="exo_controls_shuffle_description">ترتيب عشوائي</string>
+  <string name="exo_controls_shuffle_on_description">تفعيل الترتيب العشوائي</string>
+  <string name="exo_controls_shuffle_off_description">إيقاف الترتيب العشوائي</string>
   <string name="exo_controls_fullscreen_description">وضع ملء الشاشة</string>
   <string name="exo_controls_vr_description">وضع VR</string>
   <string name="exo_download_description">تنزيل</string>
diff --git a/library/ui/src/main/res/values-az/strings.xml b/library/ui/src/main/res/values-az/strings.xml
index 0f5fbe3f4d..455b7a2ab5 100644
--- a/library/ui/src/main/res/values-az/strings.xml
+++ b/library/ui/src/main/res/values-az/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Əvvəlki trek</string>
   <string name="exo_controls_next_description">Növbəti trek</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Heç biri təkrarlanmasın</string>
   <string name="exo_controls_repeat_one_description">Biri təkrarlansın</string>
   <string name="exo_controls_repeat_all_description">Hamısı təkrarlansın</string>
-  <string name="exo_controls_shuffle_description">Qarışdırın</string>
+  <string name="exo_controls_shuffle_on_description">Qarışdırma aktivdir</string>
+  <string name="exo_controls_shuffle_off_description">Qarışdırma deaktivdir</string>
   <string name="exo_controls_fullscreen_description">Tam ekran rejimi</string>
   <string name="exo_controls_vr_description">VR rejimi</string>
   <string name="exo_download_description">Endirin</string>
diff --git a/library/ui/src/main/res/values-b+sr+Latn/strings.xml b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
index 16300747f7..97bed6fe3e 100644
--- a/library/ui/src/main/res/values-b+sr+Latn/strings.xml
+++ b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Prethodna pesma</string>
   <string name="exo_controls_next_description">Sledeća pesma</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ne ponavljaj nijednu</string>
   <string name="exo_controls_repeat_one_description">Ponovi jednu</string>
   <string name="exo_controls_repeat_all_description">Ponovi sve</string>
-  <string name="exo_controls_shuffle_description">Pusti nasumično</string>
+  <string name="exo_controls_shuffle_on_description">Nasumično puštanje je uključeno</string>
+  <string name="exo_controls_shuffle_off_description">Nasumično puštanje je isključeno</string>
   <string name="exo_controls_fullscreen_description">Režim celog ekrana</string>
   <string name="exo_controls_vr_description">VR režim</string>
   <string name="exo_download_description">Preuzmi</string>
diff --git a/library/ui/src/main/res/values-be/strings.xml b/library/ui/src/main/res/values-be/strings.xml
index 6a33be2a8f..ffa9c3d0a6 100644
--- a/library/ui/src/main/res/values-be/strings.xml
+++ b/library/ui/src/main/res/values-be/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Папярэдні трэк</string>
   <string name="exo_controls_next_description">Наступны трэк</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Не паўтараць нічога</string>
   <string name="exo_controls_repeat_one_description">Паўтарыць адзін элемент</string>
   <string name="exo_controls_repeat_all_description">Паўтарыць усе</string>
-  <string name="exo_controls_shuffle_description">Перамяшаць</string>
+  <string name="exo_controls_shuffle_on_description">Перамешванне ўключана</string>
+  <string name="exo_controls_shuffle_off_description">Перамешванне выключана</string>
   <string name="exo_controls_fullscreen_description">Поўнаэкранны рэжым</string>
   <string name="exo_controls_vr_description">VR-рэжым</string>
   <string name="exo_download_description">Спампаваць</string>
diff --git a/library/ui/src/main/res/values-bg/strings.xml b/library/ui/src/main/res/values-bg/strings.xml
index 511a5e4f19..34e63090a9 100644
--- a/library/ui/src/main/res/values-bg/strings.xml
+++ b/library/ui/src/main/res/values-bg/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Предишен запис</string>
   <string name="exo_controls_next_description">Следващ запис</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Без повтаряне</string>
   <string name="exo_controls_repeat_one_description">Повтаряне на един елемент</string>
   <string name="exo_controls_repeat_all_description">Повтаряне на всички</string>
-  <string name="exo_controls_shuffle_description">Разбъркване</string>
+  <string name="exo_controls_shuffle_on_description">Разбъркването е включено</string>
+  <string name="exo_controls_shuffle_off_description">Разбъркването е изключено</string>
   <string name="exo_controls_fullscreen_description">Режим на цял екран</string>
   <string name="exo_controls_vr_description">режим за VR</string>
   <string name="exo_download_description">Изтегляне</string>
diff --git a/library/ui/src/main/res/values-bn/strings.xml b/library/ui/src/main/res/values-bn/strings.xml
index cca445feca..3ec7cae916 100644
--- a/library/ui/src/main/res/values-bn/strings.xml
+++ b/library/ui/src/main/res/values-bn/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">আগের ট্র্যাক</string>
   <string name="exo_controls_next_description">পরবর্তী ট্র্যাক</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">কোনও আইটেম আবার চালাবেন না</string>
   <string name="exo_controls_repeat_one_description">একটি আইটেম আবার চালান</string>
   <string name="exo_controls_repeat_all_description">সবগুলি আইটেম আবার চালান</string>
-  <string name="exo_controls_shuffle_description">শাফেল করুন</string>
+  <string name="exo_controls_shuffle_on_description">শাফেল মোড চালু করা হয়েছে</string>
+  <string name="exo_controls_shuffle_off_description">শাফেল মোড বন্ধ করা হয়েছে</string>
   <string name="exo_controls_fullscreen_description">পূর্ণ স্ক্রিন মোড</string>
   <string name="exo_controls_vr_description">ভিআর মোড</string>
   <string name="exo_download_description">ডাউনলোড করুন</string>
diff --git a/library/ui/src/main/res/values-bs/strings.xml b/library/ui/src/main/res/values-bs/strings.xml
index 24fb7b2b3b..431c93eed0 100644
--- a/library/ui/src/main/res/values-bs/strings.xml
+++ b/library/ui/src/main/res/values-bs/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Prethodna numera</string>
   <string name="exo_controls_next_description">Sljedeća numera</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ne ponavljaj</string>
   <string name="exo_controls_repeat_one_description">Ponovi jedno</string>
   <string name="exo_controls_repeat_all_description">Ponovi sve</string>
-  <string name="exo_controls_shuffle_description">Izmiješaj</string>
+  <string name="exo_controls_shuffle_on_description">Uključi nasumično</string>
+  <string name="exo_controls_shuffle_off_description">Isključi nasumično</string>
   <string name="exo_controls_fullscreen_description">Način rada preko cijelog ekrana</string>
   <string name="exo_controls_vr_description">VR način rada</string>
   <string name="exo_download_description">Preuzmi</string>
diff --git a/library/ui/src/main/res/values-ca/strings.xml b/library/ui/src/main/res/values-ca/strings.xml
index 3b48eab3b8..411b45356f 100644
--- a/library/ui/src/main/res/values-ca/strings.xml
+++ b/library/ui/src/main/res/values-ca/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Pista anterior</string>
   <string name="exo_controls_next_description">Pista següent</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">No en repeteixis cap</string>
   <string name="exo_controls_repeat_one_description">Repeteix una</string>
   <string name="exo_controls_repeat_all_description">Repeteix tot</string>
-  <string name="exo_controls_shuffle_description">Reprodueix aleatòriament</string>
+  <string name="exo_controls_shuffle_on_description">Activa reproducció aleatòria</string>
+  <string name="exo_controls_shuffle_off_description">Desactiva reproducció aleatòria</string>
   <string name="exo_controls_fullscreen_description">Mode de pantalla completa</string>
   <string name="exo_controls_vr_description">Mode RV</string>
   <string name="exo_download_description">Baixa</string>
diff --git a/library/ui/src/main/res/values-cs/strings.xml b/library/ui/src/main/res/values-cs/strings.xml
index 1568074f9f..0ed613834d 100644
--- a/library/ui/src/main/res/values-cs/strings.xml
+++ b/library/ui/src/main/res/values-cs/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Předchozí skladba</string>
   <string name="exo_controls_next_description">Další skladba</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Neopakovat</string>
   <string name="exo_controls_repeat_one_description">Opakovat jednu</string>
   <string name="exo_controls_repeat_all_description">Opakovat vše</string>
-  <string name="exo_controls_shuffle_description">Náhodně</string>
+  <string name="exo_controls_shuffle_on_description">Náhodné přehrávání zapnuto</string>
+  <string name="exo_controls_shuffle_off_description">Náhodné přehrávání vypnuto</string>
   <string name="exo_controls_fullscreen_description">Režim celé obrazovky</string>
   <string name="exo_controls_vr_description">Režim VR</string>
   <string name="exo_download_description">Stáhnout</string>
diff --git a/library/ui/src/main/res/values-da/strings.xml b/library/ui/src/main/res/values-da/strings.xml
index 19b0f09446..d2c7840f18 100644
--- a/library/ui/src/main/res/values-da/strings.xml
+++ b/library/ui/src/main/res/values-da/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Afspil forrige</string>
   <string name="exo_controls_next_description">Afspil næste</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Gentag ingen</string>
   <string name="exo_controls_repeat_one_description">Gentag én</string>
   <string name="exo_controls_repeat_all_description">Gentag alle</string>
-  <string name="exo_controls_shuffle_description">Bland</string>
+  <string name="exo_controls_shuffle_on_description">Bland er slået til</string>
+  <string name="exo_controls_shuffle_off_description">Bland er slået fra</string>
   <string name="exo_controls_fullscreen_description">Fuld skærm</string>
   <string name="exo_controls_vr_description">VR-tilstand</string>
   <string name="exo_download_description">Download</string>
diff --git a/library/ui/src/main/res/values-de/strings.xml b/library/ui/src/main/res/values-de/strings.xml
index 1bb620dd2b..31e011b372 100644
--- a/library/ui/src/main/res/values-de/strings.xml
+++ b/library/ui/src/main/res/values-de/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Vorheriger Titel</string>
   <string name="exo_controls_next_description">Nächster Titel</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Keinen wiederholen</string>
   <string name="exo_controls_repeat_one_description">Einen wiederholen</string>
   <string name="exo_controls_repeat_all_description">Alle wiederholen</string>
-  <string name="exo_controls_shuffle_description">Zufallsmix</string>
+  <string name="exo_controls_shuffle_on_description">Zufallsmix an</string>
+  <string name="exo_controls_shuffle_off_description">Zufallsmix aus</string>
   <string name="exo_controls_fullscreen_description">Vollbildmodus</string>
   <string name="exo_controls_vr_description">VR-Modus</string>
   <string name="exo_download_description">Herunterladen</string>
diff --git a/library/ui/src/main/res/values-el/strings.xml b/library/ui/src/main/res/values-el/strings.xml
index 1ddbe4a5fa..56c6843b76 100644
--- a/library/ui/src/main/res/values-el/strings.xml
+++ b/library/ui/src/main/res/values-el/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Προηγούμενο κομμάτι</string>
   <string name="exo_controls_next_description">Επόμενο κομμάτι</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Καμία επανάληψη</string>
   <string name="exo_controls_repeat_one_description">Επανάληψη ενός κομματιού</string>
   <string name="exo_controls_repeat_all_description">Επανάληψη όλων</string>
-  <string name="exo_controls_shuffle_description">Τυχαία αναπαραγωγή</string>
+  <string name="exo_controls_shuffle_on_description">Τυχαία αναπαραγωγή: Ενεργή</string>
+  <string name="exo_controls_shuffle_off_description">Τυχαία αναπαραγωγή: Ανενεργή</string>
   <string name="exo_controls_fullscreen_description">Λειτουργία πλήρους οθόνης</string>
   <string name="exo_controls_vr_description">Λειτουργία VR mode</string>
   <string name="exo_download_description">Λήψη</string>
diff --git a/library/ui/src/main/res/values-en-rAU/strings.xml b/library/ui/src/main/res/values-en-rAU/strings.xml
index cf25e2ada0..06c393b168 100644
--- a/library/ui/src/main/res/values-en-rAU/strings.xml
+++ b/library/ui/src/main/res/values-en-rAU/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Previous track</string>
   <string name="exo_controls_next_description">Next track</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Repeat none</string>
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <string name="exo_controls_repeat_all_description">Repeat all</string>
-  <string name="exo_controls_shuffle_description">Shuffle</string>
+  <string name="exo_controls_shuffle_on_description">Shuffle on</string>
+  <string name="exo_controls_shuffle_off_description">Shuffle off</string>
   <string name="exo_controls_fullscreen_description">Full-screen mode</string>
   <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">Download</string>
diff --git a/library/ui/src/main/res/values-en-rGB/strings.xml b/library/ui/src/main/res/values-en-rGB/strings.xml
index cf25e2ada0..06c393b168 100644
--- a/library/ui/src/main/res/values-en-rGB/strings.xml
+++ b/library/ui/src/main/res/values-en-rGB/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Previous track</string>
   <string name="exo_controls_next_description">Next track</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Repeat none</string>
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <string name="exo_controls_repeat_all_description">Repeat all</string>
-  <string name="exo_controls_shuffle_description">Shuffle</string>
+  <string name="exo_controls_shuffle_on_description">Shuffle on</string>
+  <string name="exo_controls_shuffle_off_description">Shuffle off</string>
   <string name="exo_controls_fullscreen_description">Full-screen mode</string>
   <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">Download</string>
diff --git a/library/ui/src/main/res/values-en-rIN/strings.xml b/library/ui/src/main/res/values-en-rIN/strings.xml
index cf25e2ada0..06c393b168 100644
--- a/library/ui/src/main/res/values-en-rIN/strings.xml
+++ b/library/ui/src/main/res/values-en-rIN/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Previous track</string>
   <string name="exo_controls_next_description">Next track</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Repeat none</string>
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <string name="exo_controls_repeat_all_description">Repeat all</string>
-  <string name="exo_controls_shuffle_description">Shuffle</string>
+  <string name="exo_controls_shuffle_on_description">Shuffle on</string>
+  <string name="exo_controls_shuffle_off_description">Shuffle off</string>
   <string name="exo_controls_fullscreen_description">Full-screen mode</string>
   <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">Download</string>
diff --git a/library/ui/src/main/res/values-es-rUS/strings.xml b/library/ui/src/main/res/values-es-rUS/strings.xml
index ceeb0b8497..bd698c76be 100644
--- a/library/ui/src/main/res/values-es-rUS/strings.xml
+++ b/library/ui/src/main/res/values-es-rUS/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Pista anterior</string>
   <string name="exo_controls_next_description">Pista siguiente</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">No repetir</string>
   <string name="exo_controls_repeat_one_description">Repetir uno</string>
   <string name="exo_controls_repeat_all_description">Repetir todo</string>
-  <string name="exo_controls_shuffle_description">Reproducir aleatoriamente</string>
+  <string name="exo_controls_shuffle_on_description">Reprod. aleatoria activada</string>
+  <string name="exo_controls_shuffle_off_description">Reprod. aleatoria desactivada</string>
   <string name="exo_controls_fullscreen_description">Modo de pantalla completa</string>
   <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Descargar</string>
diff --git a/library/ui/src/main/res/values-es/strings.xml b/library/ui/src/main/res/values-es/strings.xml
index 0118da57be..52998fde5a 100644
--- a/library/ui/src/main/res/values-es/strings.xml
+++ b/library/ui/src/main/res/values-es/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Pista anterior</string>
   <string name="exo_controls_next_description">Siguiente pista</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">No repetir</string>
   <string name="exo_controls_repeat_one_description">Repetir uno</string>
   <string name="exo_controls_repeat_all_description">Repetir todo</string>
-  <string name="exo_controls_shuffle_description">Reproducir aleatoriamente</string>
+  <string name="exo_controls_shuffle_on_description">Con reproducción aleatoria</string>
+  <string name="exo_controls_shuffle_off_description">Sin reproducción aleatoria</string>
   <string name="exo_controls_fullscreen_description">Modo de pantalla completa</string>
   <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Descargar</string>
diff --git a/library/ui/src/main/res/values-et/strings.xml b/library/ui/src/main/res/values-et/strings.xml
index 99ca9548ed..42a2487b3d 100644
--- a/library/ui/src/main/res/values-et/strings.xml
+++ b/library/ui/src/main/res/values-et/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Eelmine lugu</string>
   <string name="exo_controls_next_description">Järgmine lugu</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ära korda ühtegi</string>
   <string name="exo_controls_repeat_one_description">Korda ühte</string>
   <string name="exo_controls_repeat_all_description">Korda kõiki</string>
-  <string name="exo_controls_shuffle_description">Esita juhuslikus järjekorras</string>
+  <string name="exo_controls_shuffle_on_description">Lülita juh. järj. esit. sisse</string>
+  <string name="exo_controls_shuffle_off_description">Lülita juh. järj. esit. välja</string>
   <string name="exo_controls_fullscreen_description">Täisekraani režiim</string>
   <string name="exo_controls_vr_description">VR-režiim</string>
   <string name="exo_download_description">Allalaadimine</string>
diff --git a/library/ui/src/main/res/values-eu/strings.xml b/library/ui/src/main/res/values-eu/strings.xml
index 4d992fee0f..db0998916f 100644
--- a/library/ui/src/main/res/values-eu/strings.xml
+++ b/library/ui/src/main/res/values-eu/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Aurreko pista</string>
   <string name="exo_controls_next_description">Hurrengo pista</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ez errepikatu</string>
   <string name="exo_controls_repeat_one_description">Errepikatu bat</string>
   <string name="exo_controls_repeat_all_description">Errepikatu guztiak</string>
-  <string name="exo_controls_shuffle_description">Erreproduzitu ausaz</string>
+  <string name="exo_controls_shuffle_on_description">Ausazko erreprodukzioa aktibatuta</string>
+  <string name="exo_controls_shuffle_off_description">Ausazko erreprodukzioa desaktibatuta</string>
   <string name="exo_controls_fullscreen_description">Pantaila osoko modua</string>
   <string name="exo_controls_vr_description">EB modua</string>
   <string name="exo_download_description">Deskargak</string>
diff --git a/library/ui/src/main/res/values-fa/strings.xml b/library/ui/src/main/res/values-fa/strings.xml
index fed94b5569..ea9a79f06b 100644
--- a/library/ui/src/main/res/values-fa/strings.xml
+++ b/library/ui/src/main/res/values-fa/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">آهنگ قبلی</string>
   <string name="exo_controls_next_description">آهنگ بعدی</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">تکرار هیچ‌کدام</string>
   <string name="exo_controls_repeat_one_description">یکبار تکرار</string>
   <string name="exo_controls_repeat_all_description">تکرار همه</string>
-  <string name="exo_controls_shuffle_description">درهم</string>
+  <string name="exo_controls_shuffle_on_description">پخش درهم روشن</string>
+  <string name="exo_controls_shuffle_off_description">پخش درهم خاموش</string>
   <string name="exo_controls_fullscreen_description">حالت تمام‌صفحه</string>
   <string name="exo_controls_vr_description">حالت واقعیت مجازی</string>
   <string name="exo_download_description">بارگیری</string>
diff --git a/library/ui/src/main/res/values-fi/strings.xml b/library/ui/src/main/res/values-fi/strings.xml
index 0dc2f9d346..2fd5a892b5 100644
--- a/library/ui/src/main/res/values-fi/strings.xml
+++ b/library/ui/src/main/res/values-fi/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Edellinen kappale</string>
   <string name="exo_controls_next_description">Seuraava kappale</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ei uudelleentoistoa</string>
   <string name="exo_controls_repeat_one_description">Toista yksi uudelleen</string>
   <string name="exo_controls_repeat_all_description">Toista kaikki uudelleen</string>
-  <string name="exo_controls_shuffle_description">Satunnaistoisto</string>
+  <string name="exo_controls_shuffle_on_description">Satunnaistoisto käytössä</string>
+  <string name="exo_controls_shuffle_off_description">Satunnaistoisto ei käytössä</string>
   <string name="exo_controls_fullscreen_description">Koko näytön tila</string>
   <string name="exo_controls_vr_description">VR-tila</string>
   <string name="exo_download_description">Lataa</string>
diff --git a/library/ui/src/main/res/values-fr-rCA/strings.xml b/library/ui/src/main/res/values-fr-rCA/strings.xml
index 0f3534924f..5bda34f7e8 100644
--- a/library/ui/src/main/res/values-fr-rCA/strings.xml
+++ b/library/ui/src/main/res/values-fr-rCA/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Chanson précédente</string>
   <string name="exo_controls_next_description">Chanson suivante</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ne rien lire en boucle</string>
   <string name="exo_controls_repeat_one_description">Lire une chanson en boucle</string>
   <string name="exo_controls_repeat_all_description">Tout lire en boucle</string>
-  <string name="exo_controls_shuffle_description">Lecture aléatoire</string>
+  <string name="exo_controls_shuffle_on_description">Lecture aléatoire activée</string>
+  <string name="exo_controls_shuffle_off_description">Lecture aléatoire désactivée</string>
   <string name="exo_controls_fullscreen_description">Mode Plein écran</string>
   <string name="exo_controls_vr_description">Mode RV</string>
   <string name="exo_download_description">Télécharger</string>
diff --git a/library/ui/src/main/res/values-fr/strings.xml b/library/ui/src/main/res/values-fr/strings.xml
index 46c07f531e..c88102d0f5 100644
--- a/library/ui/src/main/res/values-fr/strings.xml
+++ b/library/ui/src/main/res/values-fr/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Titre précédent</string>
   <string name="exo_controls_next_description">Titre suivant</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ne rien lire en boucle</string>
   <string name="exo_controls_repeat_one_description">Lire un titre en boucle</string>
   <string name="exo_controls_repeat_all_description">Tout lire en boucle</string>
-  <string name="exo_controls_shuffle_description">Aléatoire</string>
+  <string name="exo_controls_shuffle_on_description">Lecture aléatoire activée</string>
+  <string name="exo_controls_shuffle_off_description">Lecture aléatoire désactivée</string>
   <string name="exo_controls_fullscreen_description">Mode plein écran</string>
   <string name="exo_controls_vr_description">Mode RV</string>
   <string name="exo_download_description">Télécharger</string>
diff --git a/library/ui/src/main/res/values-gl/strings.xml b/library/ui/src/main/res/values-gl/strings.xml
index e6689353f1..d4f4f24762 100644
--- a/library/ui/src/main/res/values-gl/strings.xml
+++ b/library/ui/src/main/res/values-gl/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Pista anterior</string>
   <string name="exo_controls_next_description">Pista seguinte</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Non repetir</string>
   <string name="exo_controls_repeat_one_description">Repetir unha pista</string>
   <string name="exo_controls_repeat_all_description">Repetir todas as pistas</string>
-  <string name="exo_controls_shuffle_description">Reprodución aleatoria</string>
+  <string name="exo_controls_shuffle_on_description">Reprodución aleatoria activada</string>
+  <string name="exo_controls_shuffle_off_description">Reprodución aleat. desactivada</string>
   <string name="exo_controls_fullscreen_description">Modo de pantalla completa</string>
   <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Descargar</string>
diff --git a/library/ui/src/main/res/values-gu/strings.xml b/library/ui/src/main/res/values-gu/strings.xml
index 488eb39f6a..b34cf8b6f4 100644
--- a/library/ui/src/main/res/values-gu/strings.xml
+++ b/library/ui/src/main/res/values-gu/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">પહેલાંનો ટ્રૅક</string>
   <string name="exo_controls_next_description">આગલો ટ્રૅક</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">કોઈ રિપીટ કરતા નહીં</string>
   <string name="exo_controls_repeat_one_description">એક રિપીટ કરો</string>
   <string name="exo_controls_repeat_all_description">બધાને રિપીટ કરો</string>
-  <string name="exo_controls_shuffle_description">શફલ કરો</string>
+  <string name="exo_controls_shuffle_on_description">શફલ ચાલુ છે</string>
+  <string name="exo_controls_shuffle_off_description">શફલ બંધ છે</string>
   <string name="exo_controls_fullscreen_description">પૂર્ણસ્ક્રીન મોડ</string>
   <string name="exo_controls_vr_description">VR મોડ</string>
   <string name="exo_download_description">ડાઉનલોડ કરો</string>
diff --git a/library/ui/src/main/res/values-hi/strings.xml b/library/ui/src/main/res/values-hi/strings.xml
index 8ba92054ff..5067027d7a 100644
--- a/library/ui/src/main/res/values-hi/strings.xml
+++ b/library/ui/src/main/res/values-hi/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">पिछला ट्रैक</string>
   <string name="exo_controls_next_description">अगला ट्रैक</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">किसी को न दोहराएं</string>
   <string name="exo_controls_repeat_one_description">एक को दोहराएं</string>
   <string name="exo_controls_repeat_all_description">सभी को दोहराएं</string>
-  <string name="exo_controls_shuffle_description">शफ़ल करें</string>
+  <string name="exo_controls_shuffle_on_description">शफ़ल करना चालू है</string>
+  <string name="exo_controls_shuffle_off_description">शफ़ल करना बंद है</string>
   <string name="exo_controls_fullscreen_description">फ़ुलस्क्रीन मोड</string>
   <string name="exo_controls_vr_description">VR मोड</string>
   <string name="exo_download_description">डाउनलोड करें</string>
diff --git a/library/ui/src/main/res/values-hr/strings.xml b/library/ui/src/main/res/values-hr/strings.xml
index 4fa1942986..472367200a 100644
--- a/library/ui/src/main/res/values-hr/strings.xml
+++ b/library/ui/src/main/res/values-hr/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Prethodni zapis</string>
   <string name="exo_controls_next_description">Sljedeći zapis</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Bez ponavljanja</string>
   <string name="exo_controls_repeat_one_description">Ponovi jedno</string>
   <string name="exo_controls_repeat_all_description">Ponovi sve</string>
-  <string name="exo_controls_shuffle_description">Reproduciraj nasumično</string>
+  <string name="exo_controls_shuffle_on_description">Nasumična reproduk. uključena</string>
+  <string name="exo_controls_shuffle_off_description">Nasumična reproduk. isključena</string>
   <string name="exo_controls_fullscreen_description">Prikaz na cijelom zaslonu</string>
   <string name="exo_controls_vr_description">VR način</string>
   <string name="exo_download_description">Preuzmi</string>
diff --git a/library/ui/src/main/res/values-hu/strings.xml b/library/ui/src/main/res/values-hu/strings.xml
index baf77650e0..3fd64ad6f7 100644
--- a/library/ui/src/main/res/values-hu/strings.xml
+++ b/library/ui/src/main/res/values-hu/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Előző szám</string>
   <string name="exo_controls_next_description">Következő szám</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Nincs ismétlés</string>
   <string name="exo_controls_repeat_one_description">Egy szám ismétlése</string>
   <string name="exo_controls_repeat_all_description">Összes szám ismétlése</string>
-  <string name="exo_controls_shuffle_description">Keverés</string>
+  <string name="exo_controls_shuffle_on_description">Keverés bekapcsolva</string>
+  <string name="exo_controls_shuffle_off_description">Keverés kikapcsolva</string>
   <string name="exo_controls_fullscreen_description">Teljes képernyős mód</string>
   <string name="exo_controls_vr_description">VR-mód</string>
   <string name="exo_download_description">Letöltés</string>
diff --git a/library/ui/src/main/res/values-hy/strings.xml b/library/ui/src/main/res/values-hy/strings.xml
index 04a2aeb140..2a4edc93ec 100644
--- a/library/ui/src/main/res/values-hy/strings.xml
+++ b/library/ui/src/main/res/values-hy/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Նախորդը</string>
   <string name="exo_controls_next_description">Հաջորդը</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Չկրկնել</string>
   <string name="exo_controls_repeat_one_description">Կրկնել մեկը</string>
   <string name="exo_controls_repeat_all_description">Կրկնել բոլորը</string>
-  <string name="exo_controls_shuffle_description">Խառնել</string>
+  <string name="exo_controls_shuffle_on_description">Խառնումը միացված է</string>
+  <string name="exo_controls_shuffle_off_description">Խառնումն անջատված է</string>
   <string name="exo_controls_fullscreen_description">Լիաէկրան ռեժիմ</string>
   <string name="exo_controls_vr_description">VR ռեժիմ</string>
   <string name="exo_download_description">Ներբեռնել</string>
diff --git a/library/ui/src/main/res/values-in/strings.xml b/library/ui/src/main/res/values-in/strings.xml
index 7410576e81..cf96a47ae4 100644
--- a/library/ui/src/main/res/values-in/strings.xml
+++ b/library/ui/src/main/res/values-in/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Lagu sebelumnya</string>
   <string name="exo_controls_next_description">Lagu berikutnya</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Jangan ulangi</string>
   <string name="exo_controls_repeat_one_description">Ulangi 1</string>
   <string name="exo_controls_repeat_all_description">Ulangi semua</string>
-  <string name="exo_controls_shuffle_description">Acak</string>
+  <string name="exo_controls_shuffle_on_description">Acak aktif</string>
+  <string name="exo_controls_shuffle_off_description">Acak tidak aktif</string>
   <string name="exo_controls_fullscreen_description">Mode layar penuh</string>
   <string name="exo_controls_vr_description">Mode VR</string>
   <string name="exo_download_description">Download</string>
diff --git a/library/ui/src/main/res/values-is/strings.xml b/library/ui/src/main/res/values-is/strings.xml
index bdb27a6648..a0398dec1f 100644
--- a/library/ui/src/main/res/values-is/strings.xml
+++ b/library/ui/src/main/res/values-is/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Fyrra lag</string>
   <string name="exo_controls_next_description">Næsta lag</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Endurtaka ekkert</string>
   <string name="exo_controls_repeat_one_description">Endurtaka eitt</string>
   <string name="exo_controls_repeat_all_description">Endurtaka allt</string>
-  <string name="exo_controls_shuffle_description">Stokka</string>
+  <string name="exo_controls_shuffle_on_description">Kveikt á stokkun</string>
+  <string name="exo_controls_shuffle_off_description">Slökkt á stokkun</string>
   <string name="exo_controls_fullscreen_description">Allur skjárinn</string>
   <string name="exo_controls_vr_description">sýndarveruleikastilling</string>
   <string name="exo_download_description">Sækja</string>
diff --git a/library/ui/src/main/res/values-it/strings.xml b/library/ui/src/main/res/values-it/strings.xml
index ffa05821e9..b5261ed383 100644
--- a/library/ui/src/main/res/values-it/strings.xml
+++ b/library/ui/src/main/res/values-it/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Traccia precedente</string>
   <string name="exo_controls_next_description">Traccia successiva</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Non ripetere nulla</string>
   <string name="exo_controls_repeat_one_description">Ripeti uno</string>
   <string name="exo_controls_repeat_all_description">Ripeti tutto</string>
-  <string name="exo_controls_shuffle_description">Riproduzione casuale</string>
+  <string name="exo_controls_shuffle_on_description">Attiva riproduzione casuale</string>
+  <string name="exo_controls_shuffle_off_description">Disattiva riproduzione casuale</string>
   <string name="exo_controls_fullscreen_description">Modalità a schermo intero</string>
   <string name="exo_controls_vr_description">Modalità VR</string>
   <string name="exo_download_description">Scarica</string>
diff --git a/library/ui/src/main/res/values-iw/strings.xml b/library/ui/src/main/res/values-iw/strings.xml
index 695196c5be..48e9014a89 100644
--- a/library/ui/src/main/res/values-iw/strings.xml
+++ b/library/ui/src/main/res/values-iw/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">הרצועה הקודמת</string>
   <string name="exo_controls_next_description">הרצועה הבאה</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">אל תחזור על אף פריט</string>
   <string name="exo_controls_repeat_one_description">חזור על פריט אחד</string>
   <string name="exo_controls_repeat_all_description">חזור על הכול</string>
-  <string name="exo_controls_shuffle_description">ערבוב</string>
+  <string name="exo_controls_shuffle_on_description">ההשמעה האקראית מופעלת</string>
+  <string name="exo_controls_shuffle_off_description">ההשמעה האקראית מושבתת</string>
   <string name="exo_controls_fullscreen_description">מצב מסך מלא</string>
   <string name="exo_controls_vr_description">מצב VR</string>
   <string name="exo_download_description">הורדה</string>
diff --git a/library/ui/src/main/res/values-ja/strings.xml b/library/ui/src/main/res/values-ja/strings.xml
index b4158736a8..8217487543 100644
--- a/library/ui/src/main/res/values-ja/strings.xml
+++ b/library/ui/src/main/res/values-ja/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">前のトラック</string>
   <string name="exo_controls_next_description">次のトラック</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">リピートなし</string>
   <string name="exo_controls_repeat_one_description">1 曲をリピート</string>
   <string name="exo_controls_repeat_all_description">全曲をリピート</string>
-  <string name="exo_controls_shuffle_description">シャッフル</string>
+  <string name="exo_controls_shuffle_on_description">シャッフル ON</string>
+  <string name="exo_controls_shuffle_off_description">シャッフル OFF</string>
   <string name="exo_controls_fullscreen_description">全画面モード</string>
   <string name="exo_controls_vr_description">VR モード</string>
   <string name="exo_download_description">ダウンロード</string>
diff --git a/library/ui/src/main/res/values-ka/strings.xml b/library/ui/src/main/res/values-ka/strings.xml
index 13ceaaf51f..b611b088c0 100644
--- a/library/ui/src/main/res/values-ka/strings.xml
+++ b/library/ui/src/main/res/values-ka/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">წინა ჩანაწერი</string>
   <string name="exo_controls_next_description">შემდეგი ჩანაწერი</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">არცერთის გამეორება</string>
   <string name="exo_controls_repeat_one_description">ერთის გამეორება</string>
   <string name="exo_controls_repeat_all_description">ყველას გამეორება</string>
-  <string name="exo_controls_shuffle_description">არეულად დაკვრა</string>
+  <string name="exo_controls_shuffle_on_description">არეულად დაკვრა ჩართულია</string>
+  <string name="exo_controls_shuffle_off_description">არეულად დაკვრა გამორთულია</string>
   <string name="exo_controls_fullscreen_description">სრულეკრანიანი რეჟიმი</string>
   <string name="exo_controls_vr_description">VR რეჟიმი</string>
   <string name="exo_download_description">ჩამოტვირთვა</string>
diff --git a/library/ui/src/main/res/values-kk/strings.xml b/library/ui/src/main/res/values-kk/strings.xml
index 92119d1fe5..6847b2b069 100644
--- a/library/ui/src/main/res/values-kk/strings.xml
+++ b/library/ui/src/main/res/values-kk/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Алдыңғы аудиотрек</string>
   <string name="exo_controls_next_description">Келесі аудиотрек</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ешқайсысын қайталамау</string>
   <string name="exo_controls_repeat_one_description">Біреуін қайталау</string>
   <string name="exo_controls_repeat_all_description">Барлығын қайталау</string>
-  <string name="exo_controls_shuffle_description">Араластыру</string>
+  <string name="exo_controls_shuffle_on_description">Араластыру режимі қосулы.</string>
+  <string name="exo_controls_shuffle_off_description">Араластыру режимі өшірулі.</string>
   <string name="exo_controls_fullscreen_description">Толық экран режимі</string>
   <string name="exo_controls_vr_description">VR режимі</string>
   <string name="exo_download_description">Жүктеп алу</string>
diff --git a/library/ui/src/main/res/values-km/strings.xml b/library/ui/src/main/res/values-km/strings.xml
index 62728de026..ff4795643e 100644
--- a/library/ui/src/main/res/values-km/strings.xml
+++ b/library/ui/src/main/res/values-km/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">សំនៀង​​មុន</string>
   <string name="exo_controls_next_description">សំនៀង​បន្ទាប់</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">មិន​លេង​ឡើងវិញ</string>
   <string name="exo_controls_repeat_one_description">លេង​ឡើង​វិញ​ម្ដង</string>
   <string name="exo_controls_repeat_all_description">លេង​ឡើងវិញ​ទាំងអស់</string>
-  <string name="exo_controls_shuffle_description">ច្របល់</string>
+  <string name="exo_controls_shuffle_on_description">បើក​ការ​ច្របល់</string>
+  <string name="exo_controls_shuffle_off_description">បិទ​ការ​ច្របល់</string>
   <string name="exo_controls_fullscreen_description">មុខងារពេញ​អេក្រង់</string>
   <string name="exo_controls_vr_description">មុខងារ VR</string>
   <string name="exo_download_description">ទាញយក</string>
diff --git a/library/ui/src/main/res/values-kn/strings.xml b/library/ui/src/main/res/values-kn/strings.xml
index 6e6bfcb165..b9181c7297 100644
--- a/library/ui/src/main/res/values-kn/strings.xml
+++ b/library/ui/src/main/res/values-kn/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">ಹಿಂದಿನ ಟ್ರ್ಯಾಕ್</string>
   <string name="exo_controls_next_description">ಮುಂದಿನ ಟ್ರ್ಯಾಕ್</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">ಯಾವುದನ್ನೂ ಪುನರಾವರ್ತಿಸಬೇಡಿ</string>
   <string name="exo_controls_repeat_one_description">ಒಂದನ್ನು ಪುನರಾವರ್ತಿಸಿ</string>
   <string name="exo_controls_repeat_all_description">ಎಲ್ಲವನ್ನು ಪುನರಾವರ್ತಿಸಿ</string>
-  <string name="exo_controls_shuffle_description">ಶಫಲ್‌</string>
+  <string name="exo_controls_shuffle_on_description">ಶಫಲ್ ಆನ್ ಆಗಿದೆ</string>
+  <string name="exo_controls_shuffle_off_description">ಶಫಲ್ ಆಫ್ ಆಗಿದೆ</string>
   <string name="exo_controls_fullscreen_description">ಪೂರ್ಣ ಪರದೆ ಮೋಡ್</string>
   <string name="exo_controls_vr_description">VR ಮೋಡ್</string>
   <string name="exo_download_description">ಡೌನ್‌ಲೋಡ್‌</string>
diff --git a/library/ui/src/main/res/values-ko/strings.xml b/library/ui/src/main/res/values-ko/strings.xml
index 230660ad6a..8e7d5072ce 100644
--- a/library/ui/src/main/res/values-ko/strings.xml
+++ b/library/ui/src/main/res/values-ko/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">이전 트랙</string>
   <string name="exo_controls_next_description">다음 트랙</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">반복 안함</string>
   <string name="exo_controls_repeat_one_description">현재 미디어 반복</string>
   <string name="exo_controls_repeat_all_description">모두 반복</string>
-  <string name="exo_controls_shuffle_description">셔플</string>
+  <string name="exo_controls_shuffle_on_description">셔플 사용</string>
+  <string name="exo_controls_shuffle_off_description">셔플 사용 안함</string>
   <string name="exo_controls_fullscreen_description">전체화면 모드</string>
   <string name="exo_controls_vr_description">가상 현실 모드</string>
   <string name="exo_download_description">다운로드</string>
diff --git a/library/ui/src/main/res/values-ky/strings.xml b/library/ui/src/main/res/values-ky/strings.xml
index 57b8bbb5f5..2c124fedff 100644
--- a/library/ui/src/main/res/values-ky/strings.xml
+++ b/library/ui/src/main/res/values-ky/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Мурунку трек</string>
   <string name="exo_controls_next_description">Кийинки трек</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Кайталанбасын</string>
   <string name="exo_controls_repeat_one_description">Бирөөнү кайталоо</string>
   <string name="exo_controls_repeat_all_description">Баарын кайталоо</string>
-  <string name="exo_controls_shuffle_description">Аралаштыруу</string>
+  <string name="exo_controls_shuffle_on_description">Аралаштыруу күйүк</string>
+  <string name="exo_controls_shuffle_off_description">Аралаштыруу өчүк</string>
   <string name="exo_controls_fullscreen_description">Толук экран режими</string>
   <string name="exo_controls_vr_description">VR режими</string>
   <string name="exo_download_description">Жүктөп алуу</string>
diff --git a/library/ui/src/main/res/values-lo/strings.xml b/library/ui/src/main/res/values-lo/strings.xml
index d7996610b2..fced5cce9e 100644
--- a/library/ui/src/main/res/values-lo/strings.xml
+++ b/library/ui/src/main/res/values-lo/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">ເພງກ່ອນໜ້າ</string>
   <string name="exo_controls_next_description">ເພງຕໍ່ໄປ</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">ບໍ່ຫຼິ້ນຊ້ຳ</string>
   <string name="exo_controls_repeat_one_description">ຫຼິ້ນຊໍ້າ</string>
   <string name="exo_controls_repeat_all_description">ຫຼິ້ນຊ້ຳທັງໝົດ</string>
-  <string name="exo_controls_shuffle_description">ຫຼີ້ນແບບສຸ່ມ</string>
+  <string name="exo_controls_shuffle_on_description">ເປີດການສຸ່ມເພງແລ້ວ</string>
+  <string name="exo_controls_shuffle_off_description">ປິດການສຸ່ມເພງແລ້ວ</string>
   <string name="exo_controls_fullscreen_description">ໂໝດເຕັມຈໍ</string>
   <string name="exo_controls_vr_description">ໂໝດ VR</string>
   <string name="exo_download_description">ດາວໂຫລດ</string>
diff --git a/library/ui/src/main/res/values-lt/strings.xml b/library/ui/src/main/res/values-lt/strings.xml
index 3e9a63dc99..28fbe23c82 100644
--- a/library/ui/src/main/res/values-lt/strings.xml
+++ b/library/ui/src/main/res/values-lt/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Ankstesnis takelis</string>
   <string name="exo_controls_next_description">Kitas takelis</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Nekartoti nieko</string>
   <string name="exo_controls_repeat_one_description">Kartoti vieną</string>
   <string name="exo_controls_repeat_all_description">Kartoti viską</string>
-  <string name="exo_controls_shuffle_description">Maišyti</string>
+  <string name="exo_controls_shuffle_on_description">Maišymas įjungtas</string>
+  <string name="exo_controls_shuffle_off_description">Maišymas išjungtas</string>
   <string name="exo_controls_fullscreen_description">Viso ekrano režimas</string>
   <string name="exo_controls_vr_description">VR režimas</string>
   <string name="exo_download_description">Atsisiųsti</string>
diff --git a/library/ui/src/main/res/values-lv/strings.xml b/library/ui/src/main/res/values-lv/strings.xml
index 59b541808a..b1b73e22c2 100644
--- a/library/ui/src/main/res/values-lv/strings.xml
+++ b/library/ui/src/main/res/values-lv/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Iepriekšējais ieraksts</string>
   <string name="exo_controls_next_description">Nākamais ieraksts</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Neatkārtot nevienu</string>
   <string name="exo_controls_repeat_one_description">Atkārtot vienu</string>
   <string name="exo_controls_repeat_all_description">Atkārtot visu</string>
-  <string name="exo_controls_shuffle_description">Atskaņot jauktā secībā</string>
+  <string name="exo_controls_shuffle_on_description">Atsk. jauktā secībā ieslēgta</string>
+  <string name="exo_controls_shuffle_off_description">Atsk. jauktā secībā izslēgta</string>
   <string name="exo_controls_fullscreen_description">Pilnekrāna režīms</string>
   <string name="exo_controls_vr_description">VR režīms</string>
   <string name="exo_download_description">Lejupielādēt</string>
diff --git a/library/ui/src/main/res/values-mk/strings.xml b/library/ui/src/main/res/values-mk/strings.xml
index 08a54d7240..841c29aefe 100644
--- a/library/ui/src/main/res/values-mk/strings.xml
+++ b/library/ui/src/main/res/values-mk/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Претходна песна</string>
   <string name="exo_controls_next_description">Следна песна</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Не повторувај ниту една</string>
   <string name="exo_controls_repeat_one_description">Повтори една</string>
   <string name="exo_controls_repeat_all_description">Повтори ги сите</string>
-  <string name="exo_controls_shuffle_description">Измешај</string>
+  <string name="exo_controls_shuffle_on_description">Мешањето е вклучено</string>
+  <string name="exo_controls_shuffle_off_description">Мешањето е исклучено</string>
   <string name="exo_controls_fullscreen_description">Режим на цел екран</string>
   <string name="exo_controls_vr_description">Режим на VR</string>
   <string name="exo_download_description">Преземи</string>
diff --git a/library/ui/src/main/res/values-ml/strings.xml b/library/ui/src/main/res/values-ml/strings.xml
index 6e79db0903..be25438ee1 100644
--- a/library/ui/src/main/res/values-ml/strings.xml
+++ b/library/ui/src/main/res/values-ml/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">മുമ്പത്തെ ട്രാക്ക്</string>
   <string name="exo_controls_next_description">അടുത്ത ട്രാക്ക്</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">ഒന്നും ആവർത്തിക്കരുത്</string>
   <string name="exo_controls_repeat_one_description">ഒരെണ്ണം ആവർത്തിക്കുക</string>
   <string name="exo_controls_repeat_all_description">എല്ലാം ആവർത്തിക്കുക</string>
-  <string name="exo_controls_shuffle_description">ഇടകലര്‍ത്തുക</string>
+  <string name="exo_controls_shuffle_on_description">ഇടകലർത്തൽ ഓണാക്കുക</string>
+  <string name="exo_controls_shuffle_off_description">ഇടകലർത്തൽ ഓഫാക്കുക</string>
   <string name="exo_controls_fullscreen_description">പൂർണ്ണ സ്‌ക്രീൻ മോഡ്</string>
   <string name="exo_controls_vr_description">VR മോഡ്</string>
   <string name="exo_download_description">ഡൗൺലോഡ്</string>
diff --git a/library/ui/src/main/res/values-mn/strings.xml b/library/ui/src/main/res/values-mn/strings.xml
index 383d102520..54669c31b5 100644
--- a/library/ui/src/main/res/values-mn/strings.xml
+++ b/library/ui/src/main/res/values-mn/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Өмнөх бичлэг</string>
   <string name="exo_controls_next_description">Дараагийн бичлэг</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Алийг нь ч дахин тоглуулахгүй</string>
   <string name="exo_controls_repeat_one_description">Одоогийн тоглуулж буй медиаг дахин тоглуулах</string>
   <string name="exo_controls_repeat_all_description">Бүгдийг нь дахин тоглуулах</string>
-  <string name="exo_controls_shuffle_description">Холих</string>
+  <string name="exo_controls_shuffle_on_description">Холих асаалттай</string>
+  <string name="exo_controls_shuffle_off_description">Холих унтраалттай</string>
   <string name="exo_controls_fullscreen_description">Бүтэн дэлгэцийн горим</string>
   <string name="exo_controls_vr_description">VR горим</string>
   <string name="exo_download_description">Татах</string>
diff --git a/library/ui/src/main/res/values-mr/strings.xml b/library/ui/src/main/res/values-mr/strings.xml
index a0900ab851..1864e70f3f 100644
--- a/library/ui/src/main/res/values-mr/strings.xml
+++ b/library/ui/src/main/res/values-mr/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">मागील ट्रॅक</string>
   <string name="exo_controls_next_description">पुढील ट्रॅक</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">रीपीट करू नका</string>
   <string name="exo_controls_repeat_one_description">एक रीपीट करा</string>
   <string name="exo_controls_repeat_all_description">सर्व रीपीट करा</string>
-  <string name="exo_controls_shuffle_description">शफल करा</string>
+  <string name="exo_controls_shuffle_on_description">शफल करा सुरू करा</string>
+  <string name="exo_controls_shuffle_off_description">शफल करा बंद करा</string>
   <string name="exo_controls_fullscreen_description">फुल स्क्रीन मोड</string>
   <string name="exo_controls_vr_description">VR मोड</string>
   <string name="exo_download_description">डाउनलोड करा</string>
diff --git a/library/ui/src/main/res/values-ms/strings.xml b/library/ui/src/main/res/values-ms/strings.xml
index 6dab5be8de..612e530096 100644
--- a/library/ui/src/main/res/values-ms/strings.xml
+++ b/library/ui/src/main/res/values-ms/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Lagu sebelumnya</string>
   <string name="exo_controls_next_description">Lagu seterusnya</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Jangan ulang</string>
   <string name="exo_controls_repeat_one_description">Ulang satu</string>
   <string name="exo_controls_repeat_all_description">Ulang semua</string>
-  <string name="exo_controls_shuffle_description">Rombak</string>
+  <string name="exo_controls_shuffle_on_description">Hidupkan rombak</string>
+  <string name="exo_controls_shuffle_off_description">Matikan rombak</string>
   <string name="exo_controls_fullscreen_description">Mod skrin penuh</string>
   <string name="exo_controls_vr_description">Mod VR</string>
   <string name="exo_download_description">Muat turun</string>
diff --git a/library/ui/src/main/res/values-my/strings.xml b/library/ui/src/main/res/values-my/strings.xml
index b30b76d516..44c45ef77d 100644
--- a/library/ui/src/main/res/values-my/strings.xml
+++ b/library/ui/src/main/res/values-my/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">ယခင် တစ်ပုဒ်</string>
   <string name="exo_controls_next_description">နောက် တစ်ပုဒ်</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">မည်သည်ကိုမျှ ပြန်မကျော့ရန်</string>
   <string name="exo_controls_repeat_one_description">တစ်ခုကို ပြန်ကျော့ရန်</string>
   <string name="exo_controls_repeat_all_description">အားလုံး ပြန်ကျော့ရန်</string>
-  <string name="exo_controls_shuffle_description">ရောသမမွှေ</string>
+  <string name="exo_controls_shuffle_on_description">ရောသမမွှေကို ဖွင့်ထားသည်</string>
+  <string name="exo_controls_shuffle_off_description">ရောသမမွှေကို ပိတ်ထားသည်</string>
   <string name="exo_controls_fullscreen_description">မျက်နှာပြင်အပြည့် မုဒ်</string>
   <string name="exo_controls_vr_description">VR မုဒ်</string>
   <string name="exo_download_description">ဒေါင်းလုဒ် လုပ်ရန်</string>
diff --git a/library/ui/src/main/res/values-nb/strings.xml b/library/ui/src/main/res/values-nb/strings.xml
index f2847dd829..a0018d4a36 100644
--- a/library/ui/src/main/res/values-nb/strings.xml
+++ b/library/ui/src/main/res/values-nb/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Forrige spor</string>
   <string name="exo_controls_next_description">Neste spor</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Ikke gjenta noen</string>
   <string name="exo_controls_repeat_one_description">Gjenta én</string>
   <string name="exo_controls_repeat_all_description">Gjenta alle</string>
-  <string name="exo_controls_shuffle_description">Tilfeldig rekkefølge</string>
+  <string name="exo_controls_shuffle_on_description">Tilfeldig rekkefølge er på</string>
+  <string name="exo_controls_shuffle_off_description">Tilfeldig rekkefølge er av</string>
   <string name="exo_controls_fullscreen_description">Fullskjermmodus</string>
   <string name="exo_controls_vr_description">VR-modus</string>
   <string name="exo_download_description">Last ned</string>
diff --git a/library/ui/src/main/res/values-ne/strings.xml b/library/ui/src/main/res/values-ne/strings.xml
index ff56480df1..500b80ec09 100644
--- a/library/ui/src/main/res/values-ne/strings.xml
+++ b/library/ui/src/main/res/values-ne/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">अघिल्लो ट्रयाक</string>
   <string name="exo_controls_next_description">अर्को ट्र्याक</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">कुनै पनि नदोहोर्‍याउनुहोस्</string>
   <string name="exo_controls_repeat_one_description">एउटा दोहोर्‍याउनुहोस्</string>
   <string name="exo_controls_repeat_all_description">सबै दोहोर्‍याउनुहोस्</string>
-  <string name="exo_controls_shuffle_description">मिसाउनुहोस्</string>
+  <string name="exo_controls_shuffle_on_description">मिसाउने सुविधा सक्रिय छ</string>
+  <string name="exo_controls_shuffle_off_description">मिसाउने सुविधा निष्क्रिय छ</string>
   <string name="exo_controls_fullscreen_description">पूर्ण स्क्रिन मोड</string>
   <string name="exo_controls_vr_description">VR मोड</string>
   <string name="exo_download_description">डाउनलोड गर्नुहोस्</string>
diff --git a/library/ui/src/main/res/values-nl/strings.xml b/library/ui/src/main/res/values-nl/strings.xml
index 3fbf113f1e..16b78039f5 100644
--- a/library/ui/src/main/res/values-nl/strings.xml
+++ b/library/ui/src/main/res/values-nl/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Vorige track</string>
   <string name="exo_controls_next_description">Volgende track</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Niets herhalen</string>
   <string name="exo_controls_repeat_one_description">Eén herhalen</string>
   <string name="exo_controls_repeat_all_description">Alles herhalen</string>
-  <string name="exo_controls_shuffle_description">Shuffle</string>
+  <string name="exo_controls_shuffle_on_description">Shuffle aan</string>
+  <string name="exo_controls_shuffle_off_description">Shuffle uit</string>
   <string name="exo_controls_fullscreen_description">Modus \'Volledig scherm\'</string>
   <string name="exo_controls_vr_description">VR-modus</string>
   <string name="exo_download_description">Downloaden</string>
diff --git a/library/ui/src/main/res/values-pa/strings.xml b/library/ui/src/main/res/values-pa/strings.xml
index 9f25759878..2f3bcf9e3d 100644
--- a/library/ui/src/main/res/values-pa/strings.xml
+++ b/library/ui/src/main/res/values-pa/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">ਪਿਛਲਾ ਟਰੈਕ</string>
   <string name="exo_controls_next_description">ਅਗਲਾ ਟਰੈਕ</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">ਕਿਸੇ ਨੂੰ ਨਾ ਦੁਹਰਾਓ</string>
   <string name="exo_controls_repeat_one_description">ਇੱਕ ਵਾਰ ਦੁਹਰਾਓ</string>
   <string name="exo_controls_repeat_all_description">ਸਾਰਿਆਂ ਨੂੰ ਦੁਹਰਾਓ</string>
-  <string name="exo_controls_shuffle_description">ਬੇਤਰਤੀਬ ਕਰੋ</string>
+  <string name="exo_controls_shuffle_on_description">\'ਬੇਤਰਤੀਬ ਕਰੋ\' ਮੋਡ ਚਾਲੂ ਹੈ</string>
+  <string name="exo_controls_shuffle_off_description">\'ਬੇਤਰਤੀਬ ਕਰੋ\' ਮੋਡ ਬੰਦ ਹੈ</string>
   <string name="exo_controls_fullscreen_description">ਪੂਰੀ-ਸਕ੍ਰੀਨ ਮੋਡ</string>
   <string name="exo_controls_vr_description">VR ਮੋਡ</string>
   <string name="exo_download_description">ਡਾਊਨਲੋਡ ਕਰੋ</string>
diff --git a/library/ui/src/main/res/values-pl/strings.xml b/library/ui/src/main/res/values-pl/strings.xml
index 8df3b62b0c..1c5a52c81e 100644
--- a/library/ui/src/main/res/values-pl/strings.xml
+++ b/library/ui/src/main/res/values-pl/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Poprzedni utwór</string>
   <string name="exo_controls_next_description">Następny utwór</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Nie powtarzaj</string>
   <string name="exo_controls_repeat_one_description">Powtórz jeden</string>
   <string name="exo_controls_repeat_all_description">Powtórz wszystkie</string>
-  <string name="exo_controls_shuffle_description">Odtwarzanie losowe</string>
+  <string name="exo_controls_shuffle_on_description">Włącz odtwarzanie losowe</string>
+  <string name="exo_controls_shuffle_off_description">Wyłącz odtwarzanie losowe</string>
   <string name="exo_controls_fullscreen_description">Tryb pełnoekranowy</string>
   <string name="exo_controls_vr_description">Tryb VR</string>
   <string name="exo_download_description">Pobierz</string>
diff --git a/library/ui/src/main/res/values-pt-rPT/strings.xml b/library/ui/src/main/res/values-pt-rPT/strings.xml
index 188e18f6b5..529e554dbd 100644
--- a/library/ui/src/main/res/values-pt-rPT/strings.xml
+++ b/library/ui/src/main/res/values-pt-rPT/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Faixa anterior</string>
   <string name="exo_controls_next_description">Faixa seguinte</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Não repetir nenhum</string>
   <string name="exo_controls_repeat_one_description">Repetir um</string>
   <string name="exo_controls_repeat_all_description">Repetir tudo</string>
-  <string name="exo_controls_shuffle_description">Reproduzir aleatoriamente</string>
+  <string name="exo_controls_shuffle_on_description">Reprodução aleatória ativada</string>
+  <string name="exo_controls_shuffle_off_description">Reprodução aleatória desativ.</string>
   <string name="exo_controls_fullscreen_description">Modo de ecrã inteiro</string>
   <string name="exo_controls_vr_description">Modo de RV</string>
   <string name="exo_download_description">Transferir</string>
diff --git a/library/ui/src/main/res/values-pt/strings.xml b/library/ui/src/main/res/values-pt/strings.xml
index 9e83387a76..8704bf895c 100644
--- a/library/ui/src/main/res/values-pt/strings.xml
+++ b/library/ui/src/main/res/values-pt/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Faixa anterior</string>
   <string name="exo_controls_next_description">Próxima faixa</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Não repetir</string>
   <string name="exo_controls_repeat_one_description">Repetir uma</string>
   <string name="exo_controls_repeat_all_description">Repetir tudo</string>
-  <string name="exo_controls_shuffle_description">Aleatório</string>
+  <string name="exo_controls_shuffle_on_description">Ordem aleatória ativada</string>
+  <string name="exo_controls_shuffle_off_description">Ordem aleatória desativada</string>
   <string name="exo_controls_fullscreen_description">Modo de tela cheia</string>
   <string name="exo_controls_vr_description">Modo RV</string>
   <string name="exo_download_description">Fazer o download</string>
diff --git a/library/ui/src/main/res/values-ro/strings.xml b/library/ui/src/main/res/values-ro/strings.xml
index 9bb8cfc8ee..15a5bf3cd6 100644
--- a/library/ui/src/main/res/values-ro/strings.xml
+++ b/library/ui/src/main/res/values-ro/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Melodia anterioară</string>
   <string name="exo_controls_next_description">Următoarea înregistrare</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Nu repetați niciunul</string>
   <string name="exo_controls_repeat_one_description">Repetați unul</string>
   <string name="exo_controls_repeat_all_description">Repetați-le pe toate</string>
-  <string name="exo_controls_shuffle_description">Redați aleatoriu</string>
+  <string name="exo_controls_shuffle_on_description">Redare aleatorie activată</string>
+  <string name="exo_controls_shuffle_off_description">Redare aleatorie dezactivată</string>
   <string name="exo_controls_fullscreen_description">Modul Ecran complet</string>
   <string name="exo_controls_vr_description">Mod RV</string>
   <string name="exo_download_description">Descărcați</string>
diff --git a/library/ui/src/main/res/values-ru/strings.xml b/library/ui/src/main/res/values-ru/strings.xml
index e66a282da4..f45d8bd2eb 100644
--- a/library/ui/src/main/res/values-ru/strings.xml
+++ b/library/ui/src/main/res/values-ru/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Предыдущий трек</string>
   <string name="exo_controls_next_description">Следующий трек</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Не повторять</string>
   <string name="exo_controls_repeat_one_description">Повторять трек</string>
   <string name="exo_controls_repeat_all_description">Повторять все</string>
-  <string name="exo_controls_shuffle_description">Перемешать</string>
+  <string name="exo_controls_shuffle_on_description">Перемешивание включено</string>
+  <string name="exo_controls_shuffle_off_description">Перемешивание отключено</string>
   <string name="exo_controls_fullscreen_description">Полноэкранный режим</string>
   <string name="exo_controls_vr_description">VR-режим</string>
   <string name="exo_download_description">Скачать</string>
diff --git a/library/ui/src/main/res/values-si/strings.xml b/library/ui/src/main/res/values-si/strings.xml
index b6bfb1848f..5e34550886 100644
--- a/library/ui/src/main/res/values-si/strings.xml
+++ b/library/ui/src/main/res/values-si/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">පෙර ඛණ්ඩය</string>
   <string name="exo_controls_next_description">ඊළඟ ඛණ්ඩය</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">කිසිවක් පුනරාවර්තනය නොකරන්න</string>
   <string name="exo_controls_repeat_one_description">එකක් පුනරාවර්තනය කරන්න</string>
   <string name="exo_controls_repeat_all_description">සියල්ල පුනරාවර්තනය කරන්න</string>
-  <string name="exo_controls_shuffle_description">කලවම් කරන්න</string>
+  <string name="exo_controls_shuffle_on_description">කලවම් කිරීම ක්‍රියාත්මකයි</string>
+  <string name="exo_controls_shuffle_off_description">කලවම් කිරීම ක්‍රියා විරහිතයි</string>
   <string name="exo_controls_fullscreen_description">සම්පූර්ණ තිර ප්‍රකාරය</string>
   <string name="exo_controls_vr_description">VR ප්‍රකාරය</string>
   <string name="exo_download_description">බාගන්න</string>
diff --git a/library/ui/src/main/res/values-sk/strings.xml b/library/ui/src/main/res/values-sk/strings.xml
index 6d5ddaea28..44b0df1871 100644
--- a/library/ui/src/main/res/values-sk/strings.xml
+++ b/library/ui/src/main/res/values-sk/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Predchádzajúca skladba</string>
   <string name="exo_controls_next_description">Ďalšia skladba</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Neopakovať</string>
   <string name="exo_controls_repeat_one_description">Opakovať jednu</string>
   <string name="exo_controls_repeat_all_description">Opakovať všetko</string>
-  <string name="exo_controls_shuffle_description">Náhodne prehrávať</string>
+  <string name="exo_controls_shuffle_on_description">Náhodné prehrávanie je zapnuté</string>
+  <string name="exo_controls_shuffle_off_description">Náhodné prehrávanie je vypnuté</string>
   <string name="exo_controls_fullscreen_description">Režim celej obrazovky</string>
   <string name="exo_controls_vr_description">režim VR</string>
   <string name="exo_download_description">Stiahnuť</string>
diff --git a/library/ui/src/main/res/values-sl/strings.xml b/library/ui/src/main/res/values-sl/strings.xml
index 1e3adff704..a7521fedcf 100644
--- a/library/ui/src/main/res/values-sl/strings.xml
+++ b/library/ui/src/main/res/values-sl/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Prejšnja skladba</string>
   <string name="exo_controls_next_description">Naslednja skladba</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Brez ponavljanja</string>
   <string name="exo_controls_repeat_one_description">Ponavljanje ene</string>
   <string name="exo_controls_repeat_all_description">Ponavljanje vseh</string>
-  <string name="exo_controls_shuffle_description">Naključno predvajanje</string>
+  <string name="exo_controls_shuffle_on_description">Naklj. predvajanje vklopljeno</string>
+  <string name="exo_controls_shuffle_off_description">Naklj. predvajanje izklopljeno</string>
   <string name="exo_controls_fullscreen_description">Celozaslonski način</string>
   <string name="exo_controls_vr_description">Način VR</string>
   <string name="exo_download_description">Prenos</string>
diff --git a/library/ui/src/main/res/values-sq/strings.xml b/library/ui/src/main/res/values-sq/strings.xml
index d5b8903ed7..9cded5468e 100644
--- a/library/ui/src/main/res/values-sq/strings.xml
+++ b/library/ui/src/main/res/values-sq/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Kënga e mëparshme</string>
   <string name="exo_controls_next_description">Kënga tjetër</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Mos përsërit asnjë</string>
   <string name="exo_controls_repeat_one_description">Përsërit një</string>
   <string name="exo_controls_repeat_all_description">Përsërit të gjitha</string>
-  <string name="exo_controls_shuffle_description">Përziej</string>
+  <string name="exo_controls_shuffle_on_description">Përzierja aktive</string>
+  <string name="exo_controls_shuffle_off_description">Përzierja joaktive</string>
   <string name="exo_controls_fullscreen_description">Modaliteti me ekran të plotë</string>
   <string name="exo_controls_vr_description">Modaliteti RV</string>
   <string name="exo_download_description">Shkarko</string>
diff --git a/library/ui/src/main/res/values-sr/strings.xml b/library/ui/src/main/res/values-sr/strings.xml
index b45fd8ab03..ec0523161b 100644
--- a/library/ui/src/main/res/values-sr/strings.xml
+++ b/library/ui/src/main/res/values-sr/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Претходна песма</string>
   <string name="exo_controls_next_description">Следећа песма</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Не понављај ниједну</string>
   <string name="exo_controls_repeat_one_description">Понови једну</string>
   <string name="exo_controls_repeat_all_description">Понови све</string>
-  <string name="exo_controls_shuffle_description">Пусти насумично</string>
+  <string name="exo_controls_shuffle_on_description">Насумично пуштање је укључено</string>
+  <string name="exo_controls_shuffle_off_description">Насумично пуштање је искључено</string>
   <string name="exo_controls_fullscreen_description">Режим целог екрана</string>
   <string name="exo_controls_vr_description">ВР режим</string>
   <string name="exo_download_description">Преузми</string>
diff --git a/library/ui/src/main/res/values-sv/strings.xml b/library/ui/src/main/res/values-sv/strings.xml
index 7af95a4632..db65628119 100644
--- a/library/ui/src/main/res/values-sv/strings.xml
+++ b/library/ui/src/main/res/values-sv/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Föregående spår</string>
   <string name="exo_controls_next_description">Nästa spår</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Upprepa inga</string>
   <string name="exo_controls_repeat_one_description">Upprepa en</string>
   <string name="exo_controls_repeat_all_description">Upprepa alla</string>
-  <string name="exo_controls_shuffle_description">Blanda spår</string>
+  <string name="exo_controls_shuffle_on_description">Blanda spår</string>
+  <string name="exo_controls_shuffle_off_description">Blanda inte spår</string>
   <string name="exo_controls_fullscreen_description">Helskärmsläge</string>
   <string name="exo_controls_vr_description">VR-läge</string>
   <string name="exo_download_description">Ladda ned</string>
diff --git a/library/ui/src/main/res/values-sw/strings.xml b/library/ui/src/main/res/values-sw/strings.xml
index 1cdd325278..c237a24326 100644
--- a/library/ui/src/main/res/values-sw/strings.xml
+++ b/library/ui/src/main/res/values-sw/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Wimbo uliotangulia</string>
   <string name="exo_controls_next_description">Wimbo unaofuata</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Usirudie yoyote</string>
   <string name="exo_controls_repeat_one_description">Rudia moja</string>
   <string name="exo_controls_repeat_all_description">Rudia zote</string>
-  <string name="exo_controls_shuffle_description">Changanya</string>
+  <string name="exo_controls_shuffle_on_description">Hali ya kuchanganya imewashwa</string>
+  <string name="exo_controls_shuffle_off_description">Hali ya kuchanganya imezimwa</string>
   <string name="exo_controls_fullscreen_description">Hali ya skrini nzima</string>
   <string name="exo_controls_vr_description">Hali ya Uhalisia Pepe</string>
   <string name="exo_download_description">Pakua</string>
diff --git a/library/ui/src/main/res/values-ta/strings.xml b/library/ui/src/main/res/values-ta/strings.xml
index 2b2b9e13d6..e8b9367ee7 100644
--- a/library/ui/src/main/res/values-ta/strings.xml
+++ b/library/ui/src/main/res/values-ta/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">முந்தைய டிராக்</string>
   <string name="exo_controls_next_description">அடுத்த டிராக்</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">எதையும் மீண்டும் இயக்காதே</string>
   <string name="exo_controls_repeat_one_description">இதை மட்டும் மீண்டும் இயக்கு</string>
   <string name="exo_controls_repeat_all_description">அனைத்தையும் மீண்டும் இயக்கு</string>
-  <string name="exo_controls_shuffle_description">வரிசை மாற்றி இயக்கு</string>
+  <string name="exo_controls_shuffle_on_description">கலைத்துப் போடுதல்: ஆன்</string>
+  <string name="exo_controls_shuffle_off_description">கலைத்துப் போடுதல்: ஆஃப்</string>
   <string name="exo_controls_fullscreen_description">முழுத்திரைப் பயன்முறை</string>
   <string name="exo_controls_vr_description">VR பயன்முறை</string>
   <string name="exo_download_description">பதிவிறக்கும் பட்டன்</string>
diff --git a/library/ui/src/main/res/values-te/strings.xml b/library/ui/src/main/res/values-te/strings.xml
index ea344b0345..413dad984e 100644
--- a/library/ui/src/main/res/values-te/strings.xml
+++ b/library/ui/src/main/res/values-te/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">మునుపటి ట్రాక్</string>
   <string name="exo_controls_next_description">తదుపరి ట్రాక్</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">దేన్నీ పునరావృతం చేయకండి</string>
   <string name="exo_controls_repeat_one_description">ఒకదాన్ని పునరావృతం చేయండి</string>
   <string name="exo_controls_repeat_all_description">అన్నింటినీ పునరావృతం చేయండి</string>
-  <string name="exo_controls_shuffle_description">షఫుల్ చేయండి</string>
+  <string name="exo_controls_shuffle_on_description">షఫుల్‌ను ఆన్ చేస్తుంది</string>
+  <string name="exo_controls_shuffle_off_description">షఫుల్‌ను ఆఫ్ చేస్తుంది</string>
   <string name="exo_controls_fullscreen_description">పూర్తి స్క్రీన్ మోడ్</string>
   <string name="exo_controls_vr_description">వర్చువల్ రియాలిటీ మోడ్</string>
   <string name="exo_download_description">డౌన్‌లోడ్ చేయి</string>
diff --git a/library/ui/src/main/res/values-th/strings.xml b/library/ui/src/main/res/values-th/strings.xml
index 3cd933ccf1..41a551dde7 100644
--- a/library/ui/src/main/res/values-th/strings.xml
+++ b/library/ui/src/main/res/values-th/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">แทร็กก่อนหน้า</string>
   <string name="exo_controls_next_description">แทร็กถัดไป</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">ไม่เล่นซ้ำ</string>
   <string name="exo_controls_repeat_one_description">เล่นซ้ำเพลงเดียว</string>
   <string name="exo_controls_repeat_all_description">เล่นซ้ำทั้งหมด</string>
-  <string name="exo_controls_shuffle_description">สุ่ม</string>
+  <string name="exo_controls_shuffle_on_description">เปิดการสุ่มเพลงอยู่</string>
+  <string name="exo_controls_shuffle_off_description">ปิดการสุ่มเพลงอยู่</string>
   <string name="exo_controls_fullscreen_description">โหมดเต็มหน้าจอ</string>
   <string name="exo_controls_vr_description">โหมด VR</string>
   <string name="exo_download_description">ดาวน์โหลด</string>
diff --git a/library/ui/src/main/res/values-tl/strings.xml b/library/ui/src/main/res/values-tl/strings.xml
index 21852c5011..b4e3caa4dd 100644
--- a/library/ui/src/main/res/values-tl/strings.xml
+++ b/library/ui/src/main/res/values-tl/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Nakaraang track</string>
   <string name="exo_controls_next_description">Susunod na track</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Walang uulitin</string>
   <string name="exo_controls_repeat_one_description">Mag-ulit ng isa</string>
   <string name="exo_controls_repeat_all_description">Ulitin lahat</string>
-  <string name="exo_controls_shuffle_description">I-shuffle</string>
+  <string name="exo_controls_shuffle_on_description">Naka-on ang pag-shuffle</string>
+  <string name="exo_controls_shuffle_off_description">Naka-off ang pag-shuffle</string>
   <string name="exo_controls_fullscreen_description">Fullscreen mode</string>
   <string name="exo_controls_vr_description">VR mode</string>
   <string name="exo_download_description">I-download</string>
diff --git a/library/ui/src/main/res/values-tr/strings.xml b/library/ui/src/main/res/values-tr/strings.xml
index 2fbf36514f..c6c89d683a 100644
--- a/library/ui/src/main/res/values-tr/strings.xml
+++ b/library/ui/src/main/res/values-tr/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Önceki parça</string>
   <string name="exo_controls_next_description">Sonraki parça</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Hiçbirini tekrarlama</string>
   <string name="exo_controls_repeat_one_description">Birini tekrarla</string>
   <string name="exo_controls_repeat_all_description">Tümünü tekrarla</string>
-  <string name="exo_controls_shuffle_description">Karıştır</string>
+  <string name="exo_controls_shuffle_on_description">Karıştırma açık</string>
+  <string name="exo_controls_shuffle_off_description">Karıştırma kapalı</string>
   <string name="exo_controls_fullscreen_description">Tam ekran modu</string>
   <string name="exo_controls_vr_description">VR modu</string>
   <string name="exo_download_description">İndir</string>
diff --git a/library/ui/src/main/res/values-uk/strings.xml b/library/ui/src/main/res/values-uk/strings.xml
index 5d338b61af..11b19dd58c 100644
--- a/library/ui/src/main/res/values-uk/strings.xml
+++ b/library/ui/src/main/res/values-uk/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Попередня композиція</string>
   <string name="exo_controls_next_description">Наступна композиція</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Не повторювати</string>
   <string name="exo_controls_repeat_one_description">Повторити 1</string>
   <string name="exo_controls_repeat_all_description">Повторити всі</string>
-  <string name="exo_controls_shuffle_description">Перемішати</string>
+  <string name="exo_controls_shuffle_on_description">Перемішування ввімкнено</string>
+  <string name="exo_controls_shuffle_off_description">Перемішування вимкнено</string>
   <string name="exo_controls_fullscreen_description">Повноекранний режим</string>
   <string name="exo_controls_vr_description">Режим віртуальної реальності</string>
   <string name="exo_download_description">Завантажити</string>
diff --git a/library/ui/src/main/res/values-ur/strings.xml b/library/ui/src/main/res/values-ur/strings.xml
index aa98b0728e..886bc1d449 100644
--- a/library/ui/src/main/res/values-ur/strings.xml
+++ b/library/ui/src/main/res/values-ur/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">پچھلا ٹریک</string>
   <string name="exo_controls_next_description">اگلا ٹریک</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">کسی کو نہ دہرائیں</string>
   <string name="exo_controls_repeat_one_description">ایک کو دہرائیں</string>
   <string name="exo_controls_repeat_all_description">سبھی کو دہرائیں</string>
-  <string name="exo_controls_shuffle_description">شفل کریں</string>
+  <string name="exo_controls_shuffle_on_description">شفل آن</string>
+  <string name="exo_controls_shuffle_off_description">شفل آف</string>
   <string name="exo_controls_fullscreen_description">پوری اسکرین والی وضع</string>
   <string name="exo_controls_vr_description">VR موڈ</string>
   <string name="exo_download_description">ڈاؤن لوڈ کریں</string>
diff --git a/library/ui/src/main/res/values-uz/strings.xml b/library/ui/src/main/res/values-uz/strings.xml
index 2dcf5a518d..b9688858cf 100644
--- a/library/ui/src/main/res/values-uz/strings.xml
+++ b/library/ui/src/main/res/values-uz/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Avvalgi trek</string>
   <string name="exo_controls_next_description">Keyingi trek</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Takrorlanmasin</string>
   <string name="exo_controls_repeat_one_description">Bittasini takrorlash</string>
   <string name="exo_controls_repeat_all_description">Hammasini takrorlash</string>
-  <string name="exo_controls_shuffle_description">Aralash</string>
+  <string name="exo_controls_shuffle_on_description">Tasodifiy ijro yoqilgan</string>
+  <string name="exo_controls_shuffle_off_description">Tasodifiy ijro yoqilmagan</string>
   <string name="exo_controls_fullscreen_description">Butun ekran rejimi</string>
   <string name="exo_controls_vr_description">VR rejimi</string>
   <string name="exo_download_description">Yuklab olish</string>
@@ -24,7 +39,7 @@
   <string name="exo_track_selection_title_text">Matn</string>
   <string name="exo_track_selection_none">Hech qanday</string>
   <string name="exo_track_selection_auto">Avtomatik</string>
-  <string name="exo_track_unknown">Notanish</string>
+  <string name="exo_track_unknown">Noaniq</string>
   <string name="exo_track_resolution">%1$d × %2$d</string>
   <string name="exo_track_mono">Mono</string>
   <string name="exo_track_stereo">Stereo</string>
diff --git a/library/ui/src/main/res/values-vi/strings.xml b/library/ui/src/main/res/values-vi/strings.xml
index 1cdb249ef0..3fbb842e9a 100644
--- a/library/ui/src/main/res/values-vi/strings.xml
+++ b/library/ui/src/main/res/values-vi/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Bản nhạc trước</string>
   <string name="exo_controls_next_description">Bản nhạc tiếp theo</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Không lặp lại</string>
   <string name="exo_controls_repeat_one_description">Lặp lại một</string>
   <string name="exo_controls_repeat_all_description">Lặp lại tất cả</string>
-  <string name="exo_controls_shuffle_description">Phát ngẫu nhiên</string>
+  <string name="exo_controls_shuffle_on_description">Chế độ trộn bài đang bật</string>
+  <string name="exo_controls_shuffle_off_description">Chế độ trộn bài đang tắt</string>
   <string name="exo_controls_fullscreen_description">Chế độ toàn màn hình</string>
   <string name="exo_controls_vr_description">Chế độ thực tế ảo</string>
   <string name="exo_download_description">Tải xuống</string>
diff --git a/library/ui/src/main/res/values-zh-rCN/strings.xml b/library/ui/src/main/res/values-zh-rCN/strings.xml
index fe21669ea4..0182adbe62 100644
--- a/library/ui/src/main/res/values-zh-rCN/strings.xml
+++ b/library/ui/src/main/res/values-zh-rCN/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">上一曲</string>
   <string name="exo_controls_next_description">下一曲</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">不重复播放</string>
   <string name="exo_controls_repeat_one_description">重复播放一项</string>
   <string name="exo_controls_repeat_all_description">全部重复播放</string>
-  <string name="exo_controls_shuffle_description">随机播放</string>
+  <string name="exo_controls_shuffle_on_description">随机播放功能已开启</string>
+  <string name="exo_controls_shuffle_off_description">随机播放功能已关闭</string>
   <string name="exo_controls_fullscreen_description">全屏模式</string>
   <string name="exo_controls_vr_description">VR 模式</string>
   <string name="exo_download_description">下载</string>
diff --git a/library/ui/src/main/res/values-zh-rHK/strings.xml b/library/ui/src/main/res/values-zh-rHK/strings.xml
index 56e0a1a53b..83076adea2 100644
--- a/library/ui/src/main/res/values-zh-rHK/strings.xml
+++ b/library/ui/src/main/res/values-zh-rHK/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">上一首曲目</string>
   <string name="exo_controls_next_description">下一首曲目</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">不重複播放</string>
   <string name="exo_controls_repeat_one_description">重複播放單一項目</string>
   <string name="exo_controls_repeat_all_description">全部重複播放</string>
-  <string name="exo_controls_shuffle_description">隨機播放</string>
+  <string name="exo_controls_shuffle_on_description">已開啟隨機播放功能</string>
+  <string name="exo_controls_shuffle_off_description">已關閉隨機播放功能</string>
   <string name="exo_controls_fullscreen_description">全螢幕模式</string>
   <string name="exo_controls_vr_description">虛擬現實模式</string>
   <string name="exo_download_description">下載</string>
diff --git a/library/ui/src/main/res/values-zh-rTW/strings.xml b/library/ui/src/main/res/values-zh-rTW/strings.xml
index 7b29f7924e..99d6ff8304 100644
--- a/library/ui/src/main/res/values-zh-rTW/strings.xml
+++ b/library/ui/src/main/res/values-zh-rTW/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">上一首曲目</string>
   <string name="exo_controls_next_description">下一首曲目</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">不重複播放</string>
   <string name="exo_controls_repeat_one_description">重複播放單一項目</string>
   <string name="exo_controls_repeat_all_description">重複播放所有項目</string>
-  <string name="exo_controls_shuffle_description">隨機播放</string>
+  <string name="exo_controls_shuffle_on_description">隨機播放已開啟</string>
+  <string name="exo_controls_shuffle_off_description">隨機播放已關閉</string>
   <string name="exo_controls_fullscreen_description">全螢幕模式</string>
   <string name="exo_controls_vr_description">虛擬實境模式</string>
   <string name="exo_download_description">下載</string>
diff --git a/library/ui/src/main/res/values-zu/strings.xml b/library/ui/src/main/res/values-zu/strings.xml
index 83cf9b2e97..60dc913b14 100644
--- a/library/ui/src/main/res/values-zu/strings.xml
+++ b/library/ui/src/main/res/values-zu/strings.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <string name="exo_controls_previous_description">Ithrekhi yangaphambilini</string>
   <string name="exo_controls_next_description">Ithrekhi elandelayo</string>
@@ -10,7 +24,8 @@
   <string name="exo_controls_repeat_off_description">Phinda okungekho</string>
   <string name="exo_controls_repeat_one_description">Phinda okukodwa</string>
   <string name="exo_controls_repeat_all_description">Phinda konke</string>
-  <string name="exo_controls_shuffle_description">Shova</string>
+  <string name="exo_controls_shuffle_on_description">Ukushova kuvuliwe</string>
+  <string name="exo_controls_shuffle_off_description">Ukushova kuvaliwe</string>
   <string name="exo_controls_fullscreen_description">Imodi yesikrini esigcwele</string>
   <string name="exo_controls_vr_description">Inqubo ye-VR</string>
   <string name="exo_download_description">Landa</string>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index f4a7976ebd..706fba0e0b 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -24,25 +24,43 @@
     <enum name="zoom" value="4"/>
   </attr>
 
-  <!-- Must be kept in sync with SimpleExoPlayerView -->
+  <!-- Must be kept in sync with PlayerView -->
   <attr name="surface_type" format="enum">
     <enum name="none" value="0"/>
     <enum name="surface_view" value="1"/>
     <enum name="texture_view" value="2"/>
     <enum name="spherical_view" value="3"/>
   </attr>
-  <attr name="show_timeout" format="integer"/>
-  <attr name="rewind_increment" format="integer"/>
-  <attr name="fastforward_increment" format="integer"/>
-  <attr name="player_layout_id" format="reference"/>
-  <attr name="controller_layout_id" format="reference"/>
+
+  <!-- Must be kept in sync with RepeatModeUtil -->
   <attr name="repeat_toggle_modes">
     <flag name="none" value="0"/>
     <flag name="one" value="1"/>
     <flag name="all" value="2"/>
   </attr>
+
+  <!-- PlayerControlView attributes -->
+  <attr name="show_timeout" format="integer"/>
+  <attr name="rewind_increment" format="integer"/>
+  <attr name="fastforward_increment" format="integer"/>
   <attr name="show_shuffle_button" format="boolean"/>
   <attr name="time_bar_min_update_interval" format="integer"/>
+  <attr name="controller_layout_id" format="reference"/>
+
+  <!-- DefaultTimeBar attributes -->
+  <attr name="bar_height" format="dimension"/>
+  <attr name="touch_target_height" format="dimension"/>
+  <attr name="ad_marker_width" format="dimension"/>
+  <attr name="scrubber_enabled_size" format="dimension"/>
+  <attr name="scrubber_disabled_size" format="dimension"/>
+  <attr name="scrubber_dragged_size" format="dimension"/>
+  <attr name="scrubber_drawable" format="reference"/>
+  <attr name="played_color" format="color"/>
+  <attr name="scrubber_color" format="color"/>
+  <attr name="buffered_color" format="color"/>
+  <attr name="unplayed_color" format="color"/>
+  <attr name="ad_marker_color" format="color"/>
+  <attr name="played_ad_marker_color" format="color"/>
 
   <declare-styleable name="PlayerView">
     <attr name="use_artwork" format="boolean"/>
@@ -58,9 +76,11 @@
       <enum name="always" value="2"/>
     </attr>
     <attr name="keep_content_on_player_reset" format="boolean"/>
-    <attr name="resize_mode"/>
+    <attr name="player_layout_id" format="reference"/>
+
     <attr name="surface_type"/>
-    <attr name="player_layout_id"/>
+    <!-- AspectRatioFrameLayout attributes -->
+    <attr name="resize_mode"/>
     <!-- PlayerControlView attributes -->
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
@@ -69,6 +89,20 @@
     <attr name="show_shuffle_button"/>
     <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
+    <!-- DefaultTimeBar attributes -->
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
   <declare-styleable name="AspectRatioFrameLayout">
@@ -83,22 +117,36 @@
     <attr name="show_shuffle_button"/>
     <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
+    <!-- DefaultTimeBar attributes -->
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
   <declare-styleable name="DefaultTimeBar">
-    <attr name="bar_height" format="dimension"/>
-    <attr name="touch_target_height" format="dimension"/>
-    <attr name="ad_marker_width" format="dimension"/>
-    <attr name="scrubber_enabled_size" format="dimension"/>
-    <attr name="scrubber_disabled_size" format="dimension"/>
-    <attr name="scrubber_dragged_size" format="dimension"/>
-    <attr name="scrubber_drawable" format="reference"/>
-    <attr name="played_color" format="color"/>
-    <attr name="scrubber_color" format="color"/>
-    <attr name="buffered_color" format="color"/>
-    <attr name="unplayed_color" format="color"/>
-    <attr name="ad_marker_color" format="color"/>
-    <attr name="played_ad_marker_color" format="color"/>
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
 </resources>
diff --git a/library/ui/src/main/res/values/constants.xml b/library/ui/src/main/res/values/constants.xml
index 9b374d8382..9bd616583e 100644
--- a/library/ui/src/main/res/values/constants.xml
+++ b/library/ui/src/main/res/values/constants.xml
@@ -18,6 +18,9 @@
   <dimen name="exo_media_button_width">71dp</dimen>
   <dimen name="exo_media_button_height">52dp</dimen>
 
+  <integer name="exo_media_button_opacity_percentage_enabled">100</integer>
+  <integer name="exo_media_button_opacity_percentage_disabled">33</integer>
+
   <color name="exo_error_message_background_color">#AA000000</color>
   <color name="exo_edit_mode_background_color">#FFF4F3F0</color>
 
diff --git a/library/ui/src/main/res/values/drawables.xml b/library/ui/src/main/res/values/drawables.xml
index b528c9cc9a..3cd9168726 100644
--- a/library/ui/src/main/res/values/drawables.xml
+++ b/library/ui/src/main/res/values/drawables.xml
@@ -1,4 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
 <resources>
   <drawable name="exo_controls_play">@drawable/exo_icon_play</drawable>
   <drawable name="exo_controls_pause">@drawable/exo_icon_pause</drawable>
diff --git a/library/ui/src/main/res/values/ids.xml b/library/ui/src/main/res/values/ids.xml
index e57301f946..17b55cd731 100644
--- a/library/ui/src/main/res/values/ids.xml
+++ b/library/ui/src/main/res/values/ids.xml
@@ -33,6 +33,7 @@
   <item name="exo_repeat_toggle" type="id"/>
   <item name="exo_duration" type="id"/>
   <item name="exo_position" type="id"/>
+  <item name="exo_progress_placeholder" type="id"/>
   <item name="exo_progress" type="id"/>
   <item name="exo_buffering" type="id"/>
   <item name="exo_error_message" type="id"/>
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index bbb4aca8d5..f0282b4991 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -34,8 +34,10 @@
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <!-- Description for a button that controls the repeat mode of a media playback. In this mode the entire playlist is repeated. [CHAR LIMIT=30] -->
   <string name="exo_controls_repeat_all_description">Repeat all</string>
-  <!-- Description for a media control button that toggles whether shuffle mode is enabled. [CHAR LIMIT=30] -->
-  <string name="exo_controls_shuffle_description">Shuffle</string>
+  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is on. [CHAR LIMIT=40] -->
+  <string name="exo_controls_shuffle_on_description">Shuffle on</string>
+  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is off. [CHAR LIMIT=40] -->
+  <string name="exo_controls_shuffle_off_description">Shuffle off</string>
   <!-- Description for a media control button that toggles whether a video playback is fullscreen. [CHAR LIMIT=30] -->
   <string name="exo_controls_fullscreen_description">Fullscreen mode</string>
   <!-- Description for a media control button that toggles whether a video playback is in VR mode. [CHAR LIMIT=30] -->
diff --git a/library/ui/src/main/res/values/styles.xml b/library/ui/src/main/res/values/styles.xml
index 89d7a2fc8e..c458a3ea99 100644
--- a/library/ui/src/main/res/values/styles.xml
+++ b/library/ui/src/main/res/values/styles.xml
@@ -51,11 +51,6 @@
     <item name="android:contentDescription">@string/exo_controls_pause_description</item>
   </style>
 
-  <style name="ExoMediaButton.Shuffle">
-    <item name="android:src">@drawable/exo_controls_shuffle</item>
-    <item name="android:contentDescription">@string/exo_controls_shuffle_description</item>
-  </style>
-
   <style name="ExoMediaButton.VR">
     <item name="android:src">@drawable/exo_icon_vr</item>
     <item name="android:contentDescription">@string/exo_controls_vr_description</item>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index dd5cfa64a7..5865d3c36d 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -34,7 +34,7 @@ android {
 dependencies {
     androidTestImplementation 'androidx.test:rules:' + androidXTestVersion
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
-    androidTestImplementation 'androidx.annotation:annotation:1.0.2'
+    androidTestImplementation 'androidx.annotation:annotation:1.1.0'
     androidTestImplementation project(modulePrefix + 'library-core')
     androidTestImplementation project(modulePrefix + 'library-dash')
     androidTestImplementation project(modulePrefix + 'library-hls')
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
index 166a8a9622..a2dd366432 100644
--- a/playbacktests/src/androidTest/AndroidManifest.xml
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -23,7 +23,7 @@
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
   <uses-sdk/>
 
-  <application android:debuggable="true"
+  <application
       android:allowBackup="false"
       tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
     <uses-library android:name="android.test.runner"/>
diff --git a/publish.gradle b/publish.gradle
index 7a92afd2ed..952cde668a 100644
--- a/publish.gradle
+++ b/publish.gradle
@@ -23,6 +23,21 @@ if (project.ext.has("exoplayerPublishEnabled")
         groupId = 'com.google.android.exoplayerVRT'
         website = 'https://github.com/tristan-vrt/ExoPlayer'
     }
+
+    gradle.taskGraph.whenReady { taskGraph ->
+        project.tasks
+                .findAll { task -> task.name.contains("generatePomFileFor") }
+                .forEach { task ->
+                    task.doLast {
+                        task.outputs.files
+                                .filter { File file ->
+                                    file.path.contains("publications") \
+                                        && file.name.matches("^pom-.+\\.xml\$")
+                                }
+                                .forEach { File file -> addLicense(file) }
+                    }
+                }
+    }
 }
 
 def getBintrayRepo() {
@@ -30,3 +45,24 @@ def getBintrayRepo() {
         property('publicRepo').toBoolean()
     return publicRepo ? 'exoplayer' : 'exoplayer-test'
 }
+
+static void addLicense(File pom) {
+    def licenseNode = new Node(null, "license")
+    licenseNode.append(
+        new Node(null, "name", "The Apache Software License, Version 2.0"))
+    licenseNode.append(
+        new Node(null, "url", "http://www.apache.org/licenses/LICENSE-2.0.txt"))
+    licenseNode.append(new Node(null, "distribution", "repo"))
+    def licensesNode = new Node(null, "licenses")
+    licensesNode.append(licenseNode)
+
+    def xml = new XmlParser().parse(pom)
+    xml.append(licensesNode)
+
+    def writer = new PrintWriter(new FileWriter(pom))
+    writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
+    def printer = new XmlNodePrinter(writer)
+    printer.preserveWhitespace = true
+    printer.print(xml)
+    writer.close()
+}
diff --git a/testutils/build.gradle b/testutils/build.gradle
index bdc26d5c19..1ec358b83d 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -41,7 +41,7 @@ dependencies {
     api 'org.mockito:mockito-core:' + mockitoVersion
     api 'androidx.test.ext:junit:' + androidXTestVersion
     api 'androidx.test.ext:truth:' + androidXTestVersion
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation project(modulePrefix + 'library-core')
     implementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
     annotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/DebugRenderersFactory.java
index ab703da30d..475fe7f8cd 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/DebugRenderersFactory.java
@@ -30,7 +30,6 @@
 import com.google.android.exoplayer2VRT.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2VRT.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2VRT.mediacodec.MediaCodecSelector;
-import com.google.android.exoplayer2VRT.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2VRT.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2VRT.video.VideoRendererEventListener;
 import java.nio.ByteBuffer;
@@ -55,6 +54,7 @@ protected void buildVideoRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
       long allowedVideoJoiningTimeMs,
@@ -113,8 +113,7 @@ protected void configureCodec(
         MediaCodec codec,
         Format format,
         MediaCrypto crypto,
-        float operatingRate)
-        throws DecoderQueryException {
+        float operatingRate) {
       // If the codec is being initialized whilst the renderer is started, default behavior is to
       // render the first frame (i.e. the keyframe before the current position), then drop frames up
       // to the current playback position. For test runs that place a maximum limit on the number of
@@ -164,14 +163,15 @@ protected boolean processOutputBuffer(
         int bufferIndex,
         int bufferFlags,
         long bufferPresentationTimeUs,
-        boolean shouldSkip,
+        boolean isDecodeOnlyBuffer,
+        boolean isLastBuffer,
         Format format)
         throws ExoPlaybackException {
       if (skipToPositionBeforeRenderingFirstFrame && bufferPresentationTimeUs < positionUs) {
         // After the codec has been initialized, don't render the first frame until we've caught up
         // to the playback position. Else test runs on devices that do not support dummy surface
         // will drop frames between rendering the first one and catching up [Internal: b/66494991].
-        shouldSkip = true;
+        isDecodeOnlyBuffer = true;
       }
       return super.processOutputBuffer(
           positionUs,
@@ -181,7 +181,8 @@ protected boolean processOutputBuffer(
           bufferIndex,
           bufferFlags,
           bufferPresentationTimeUs,
-          shouldSkip,
+          isDecodeOnlyBuffer,
+          isLastBuffer,
           format);
     }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExoPlayerTestRunner.java
index 0ce0ecd3f7..9330d5d067 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExoPlayerTestRunner.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExoPlayerTestRunner.java
@@ -418,7 +418,7 @@ public ExoPlayerTestRunner start() {
             if (actionSchedule != null) {
               actionSchedule.start(player, trackSelector, null, handler, ExoPlayerTestRunner.this);
             }
-            player.prepare(mediaSource);
+            player.prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
           } catch (Exception e) {
             handleException(e);
           }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExtractorAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExtractorAsserts.java
index 843f7ee7ac..4ab0d4713d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExtractorAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/ExtractorAsserts.java
@@ -175,17 +175,26 @@ private static FakeExtractorOutput assertOutput(
       extractorOutput.assertOutput(context, file + ".0" + DUMP_EXTENSION);
     }
 
+    // Seeking to (timeUs=0, position=0) should always work, and cause the same data to be output.
+    extractorOutput.clearTrackOutputs();
+    input.reset();
+    consumeTestData(extractor, input, /* timeUs= */ 0, extractorOutput, false);
+    if (simulateUnknownLength && assetExists(context, file + UNKNOWN_LENGTH_EXTENSION)) {
+      extractorOutput.assertOutput(context, file + UNKNOWN_LENGTH_EXTENSION);
+    } else {
+      extractorOutput.assertOutput(context, file + ".0" + DUMP_EXTENSION);
+    }
+
+    // If the SeekMap is seekable, test seeking to 4 positions in the stream.
     SeekMap seekMap = extractorOutput.seekMap;
     if (seekMap.isSeekable()) {
       long durationUs = seekMap.getDurationUs();
       for (int j = 0; j < 4; j++) {
+        extractorOutput.clearTrackOutputs();
         long timeUs = (durationUs * j) / 3;
         long position = seekMap.getSeekPoints(timeUs).first.position;
+        input.reset();
         input.setPosition((int) position);
-        for (int i = 0; i < extractorOutput.numberOfTracks; i++) {
-          extractorOutput.trackOutputs.valueAt(i).clear();
-        }
-
         consumeTestData(extractor, input, timeUs, extractorOutput, false);
         extractorOutput.assertOutput(context, file + '.' + j + DUMP_EXTENSION);
       }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorInput.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorInput.java
index 5812940736..3eccdbb3e0 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorInput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorInput.java
@@ -80,6 +80,15 @@ private FakeExtractorInput(byte[] data, boolean simulateUnknownLength,
     failedPeekPositions = new SparseBooleanArray();
   }
 
+  /** Resets the input to its initial state. */
+  public void reset() {
+    readPosition = 0;
+    peekPosition = 0;
+    partiallySatisfiedTargetPositions.clear();
+    failedReadPositions.clear();
+    failedPeekPositions.clear();
+  }
+
   /**
    * Sets the read and peek positions.
    *
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorOutput.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorOutput.java
index e6a36bd73a..5d775c1c5b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeExtractorOutput.java
@@ -70,6 +70,12 @@ public void seekMap(SeekMap seekMap) {
     this.seekMap = seekMap;
   }
 
+  public void clearTrackOutputs() {
+    for (int i = 0; i < numberOfTracks; i++) {
+      trackOutputs.valueAt(i).clear();
+    }
+  }
+
   public void assertEquals(FakeExtractorOutput expected) {
     assertThat(numberOfTracks).isEqualTo(expected.numberOfTracks);
     assertThat(tracksEnded).isEqualTo(expected.tracksEnded);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeSampleStream.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeSampleStream.java
index 631d4d7f06..141c07f304 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeSampleStream.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/FakeSampleStream.java
@@ -32,6 +32,7 @@
 
   private final Format format;
   private final @Nullable EventDispatcher eventDispatcher;
+  private final byte[] sampleData;
 
   private boolean notifiedDownstreamFormat;
   private boolean readFormat;
@@ -47,9 +48,23 @@
    */
   public FakeSampleStream(
       Format format, @Nullable EventDispatcher eventDispatcher, boolean shouldOutputSample) {
+    this(format, eventDispatcher, new byte[] {0});
+    readSample = !shouldOutputSample;
+  }
+
+  /**
+   * Creates fake sample stream which outputs the given {@link Format}, one sample with the provided
+   * bytes, then end of stream.
+   *
+   * @param format The {@link Format} to output.
+   * @param eventDispatcher An {@link EventDispatcher} to notify of read events.
+   * @param sampleData The sample data to output.
+   */
+  public FakeSampleStream(
+      Format format, @Nullable EventDispatcher eventDispatcher, byte[] sampleData) {
     this.format = format;
     this.eventDispatcher = eventDispatcher;
-    readSample = !shouldOutputSample;
+    this.sampleData = sampleData;
   }
 
   @Override
@@ -58,8 +73,8 @@ public boolean isReady() {
   }
 
   @Override
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
-      boolean formatRequired) {
+  public int readData(
+      FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {
     if (eventDispatcher != null && !notifiedDownstreamFormat) {
       eventDispatcher.downstreamFormatChanged(
           C.TRACK_TYPE_UNKNOWN,
@@ -75,9 +90,8 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       return C.RESULT_FORMAT_READ;
     } else if (!readSample) {
       buffer.timeUs = 0;
-      buffer.ensureSpaceForWrite(1);
-      buffer.data.put((byte) 0);
-      buffer.flip();
+      buffer.ensureSpaceForWrite(sampleData.length);
+      buffer.data.put(sampleData);
       readSample = true;
       return C.RESULT_BUFFER_READ;
     } else {
@@ -95,5 +109,4 @@ public void maybeThrowError() throws IOException {
   public int skipData(long positionUs) {
     return 0;
   }
-
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/HostActivity.java
index 3ca39d4d8f..57c4b69f46 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2VRT/testutil/HostActivity.java
@@ -166,7 +166,8 @@ public void runTest(
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     requestWindowFeature(Window.FEATURE_NO_TITLE);
-    setContentView(getResources().getIdentifier("host_activity", "layout", getPackageName()));
+    setContentView(
+        getResources().getIdentifier("exo_testutils_host_activity", "layout", getPackageName()));
     surfaceView = findViewById(
         getResources().getIdentifier("surface_view", "id", getPackageName()));
     surfaceView.getHolder().addCallback(this);
diff --git a/testutils/src/main/res/layout/host_activity.xml b/testutils/src/main/res/layout/exo_testutils_host_activity.xml
similarity index 100%
rename from testutils/src/main/res/layout/host_activity.xml
rename to testutils/src/main/res/layout/exo_testutils_host_activity.xml
diff --git a/testutils_robolectric/build.gradle b/testutils_robolectric/build.gradle
index a3859a9e48..758d22b5d9 100644
--- a/testutils_robolectric/build.gradle
+++ b/testutils_robolectric/build.gradle
@@ -41,5 +41,5 @@ dependencies {
     api 'org.robolectric:robolectric:' + robolectricVersion
     api project(modulePrefix + 'testutils')
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/CacheAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/CacheAsserts.java
index a60d3576b4..4436d9c8bd 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/CacheAsserts.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/CacheAsserts.java
@@ -33,58 +33,89 @@
 /** Assertion methods for {@link Cache}. */
 public final class CacheAsserts {
 
-  /**
-   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
-    ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    Uri[] uris = new Uri[allData.size()];
-    for (int i = 0; i < allData.size(); i++) {
-      uris[i] = allData.get(i).uri;
+  /** Defines a set of data requests. */
+  public static final class RequestSet {
+
+    private final FakeDataSet fakeDataSet;
+    private DataSpec[] dataSpecs;
+
+    public RequestSet(FakeDataSet fakeDataSet) {
+      this.fakeDataSet = fakeDataSet;
+      ArrayList<FakeData> allData = fakeDataSet.getAllData();
+      dataSpecs = new DataSpec[allData.size()];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(allData.get(i).uri);
+      }
     }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
 
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
-      throws IOException {
-    Uri[] uris = new Uri[uriStrings.length];
-    for (int i = 0; i < uriStrings.length; i++) {
-      uris[i] = Uri.parse(uriStrings[i]);
+    public RequestSet subset(String... uriStrings) {
+      dataSpecs = new DataSpec[uriStrings.length];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(Uri.parse(uriStrings[i]));
+      }
+      return this;
+    }
+
+    public RequestSet subset(Uri... uris) {
+      dataSpecs = new DataSpec[uris.length];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(uris[i]);
+      }
+      return this;
+    }
+
+    public RequestSet subset(DataSpec... dataSpecs) {
+      this.dataSpecs = dataSpecs;
+      return this;
+    }
+
+    public int getCount() {
+      return dataSpecs.length;
+    }
+
+    public byte[] getData(int i) {
+      return fakeDataSet.getData(dataSpecs[i].uri).getData();
+    }
+
+    public DataSpec getDataSpec(int i) {
+      return dataSpecs[i];
+    }
+
+    public RequestSet useBoundedDataSpecFor(String uriString) {
+      FakeData data = fakeDataSet.getData(uriString);
+      for (int i = 0; i < dataSpecs.length; i++) {
+        DataSpec spec = dataSpecs[i];
+        if (spec.uri.getPath().equals(uriString)) {
+          dataSpecs[i] = spec.subrange(0, data.getData().length);
+          return this;
+        }
+      }
+      throw new IllegalStateException();
     }
-    assertCachedData(cache, fakeDataSet, uris);
   }
 
   /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   * Asserts that the cache contains necessary data for the {@code requestSet}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
+  public static void assertCachedData(Cache cache, RequestSet requestSet) throws IOException {
     int totalLength = 0;
-    for (Uri uri : uris) {
-      byte[] data = fakeDataSet.getData(uri).getData();
-      assertDataCached(cache, uri, data);
+    for (int i = 0; i < requestSet.getCount(); i++) {
+      byte[] data = requestSet.getData(i);
+      assertDataCached(cache, requestSet.getDataSpec(i), data);
       totalLength += data.length;
     }
     assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
   }
 
   /**
-   * Asserts that the cache contains the given data for {@code uriString}.
+   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
-  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    DataSpec dataSpec = new DataSpec(uri);
-    assertDataCached(cache, dataSpec, expected);
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
+    assertCachedData(cache, new RequestSet(fakeDataSet));
   }
 
   /**
@@ -95,15 +126,18 @@ public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throw
   public static void assertDataCached(Cache cache, DataSpec dataSpec, byte[] expected)
       throws IOException {
     DataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    dataSource.open(dataSpec);
+    byte[] bytes;
     try {
-      byte[] bytes = TestUtil.readToEnd(dataSource);
-      assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
-          .that(bytes)
-          .isEqualTo(expected);
+      dataSource.open(dataSpec);
+      bytes = TestUtil.readToEnd(dataSource);
+    } catch (IOException e) {
+      throw new IOException("Opening/reading cache failed: " + dataSpec, e);
     } finally {
       dataSource.close();
     }
+    assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
+        .that(bytes)
+        .isEqualTo(expected);
   }
 
   /**
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/StubExoPlayer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/StubExoPlayer.java
index e066fb65fe..23d7705d9c 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/StubExoPlayer.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2VRT/testutil/StubExoPlayer.java
@@ -79,6 +79,12 @@ public int getPlaybackState() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
+  @PlaybackSuppressionReason
+  public int getPlaybackSuppressionReason() {
+    throw new UnsupportedOperationException();
+  }
+
   @Override
   public ExoPlaybackException getPlaybackError() {
     throw new UnsupportedOperationException();
