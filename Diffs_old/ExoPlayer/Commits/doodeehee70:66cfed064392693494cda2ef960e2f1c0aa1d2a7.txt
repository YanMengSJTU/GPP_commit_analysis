diff --git a/.github/ISSUE_TEMPLATE/bug.md b/.github/ISSUE_TEMPLATE/bug.md
index 690069ffa8..c0980df440 100644
--- a/.github/ISSUE_TEMPLATE/bug.md
+++ b/.github/ISSUE_TEMPLATE/bug.md
@@ -8,9 +8,12 @@ assignees: ''
 
 Before filing a bug:
 -----------------------
-- Search existing issues, including issues that are closed.
-- Consult our FAQs, supported devices and supported formats pages. These can be
-  found at https://exoplayer.dev/.
+- Search existing issues, including issues that are closed:
+  https://github.com/google/ExoPlayer/issues?q=is%3Aissue
+- Consult our developer website, which can be found at https://exoplayer.dev/.
+  It provides detailed information about supported formats and devices.
+- Learn how to create useful log output by using the EventLogger:
+  https://exoplayer.dev/listening-to-player-events.html#using-eventlogger
 - Rule out issues in your own code. A good way to do this is to try and
   reproduce the issue in the ExoPlayer demo app. Information about the ExoPlayer
   demo app can be found here:
@@ -33,16 +36,17 @@ or a small sample app that you’re able to share as source code on GitHub.
 Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
 media that reproduces the issue. If you don't wish to post it publicly, please
 submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
-in the format "Issue #1234". Provide all the metadata we'd need to play the
-content like drm license urls or similar. If the content is accessible only in
-certain countries or regions, please say so.
+in the format "Issue #1234", where "#1234" should be replaced with your issue
+number. Provide all the metadata we'd need to play the content like drm license
+urls or similar. If the content is accessible only in certain countries or
+regions, please say so.
 
 ### [REQUIRED] A full bug report captured from the device
 Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
 log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
 bug report to dev.exoplayer@gmail.com using a subject in the format
-"Issue #1234".
+"Issue #1234", where "#1234" should be replaced with your issue number.
 
 ### [REQUIRED] Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
diff --git a/.github/ISSUE_TEMPLATE/content_not_playing.md b/.github/ISSUE_TEMPLATE/content_not_playing.md
index f326e7cd46..c8d4668a6a 100644
--- a/.github/ISSUE_TEMPLATE/content_not_playing.md
+++ b/.github/ISSUE_TEMPLATE/content_not_playing.md
@@ -8,9 +8,12 @@ assignees: ''
 
 Before filing a content issue:
 ------------------------------
-- Search existing issues, including issues that are closed.
+- Search existing issues, including issues that are closed:
+  https://github.com/google/ExoPlayer/issues?q=is%3Aissue
 - Consult our supported formats page, which can be found at
   https://exoplayer.dev/supported-formats.html.
+- Learn how to create useful log output by using the EventLogger:
+  https://exoplayer.dev/listening-to-player-events.html#using-eventlogger
 - Try playing your content in the ExoPlayer demo app. Information about the
   ExoPlayer demo app can be found here:
   http://exoplayer.dev/demo-application.html.
@@ -30,9 +33,10 @@ and you expect to play, like 5.1 audio track, text tracks or drm systems.
 Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
 media that reproduces the issue. If you don't wish to post it publicly, please
 submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
-in the format "Issue #1234". Provide all the metadata we'd need to play the
-content like drm license urls or similar. If the content is accessible only in
-certain countries or regions, please say so.
+in the format "Issue #1234", where "#1234" should be replaced with your issue
+number. Provide all the metadata we'd need to play the content like drm license
+urls or similar. If the content is accessible only in certain countries or
+regions, please say so.
 
 ### [REQUIRED] Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
@@ -41,6 +45,13 @@ Specify the absolute version number. Avoid using terms such as "latest".
 Specify the devices and versions of Android on which you expect the content to
 play. If possible, please test on multiple devices and Android versions.
 
+### [REQUIRED] A full bug report captured from the device
+Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
+log snippet is NOT sufficient. Please attach the captured bug report as a file.
+If you don't wish to post it publicly, please submit the issue, then email the
+bug report to dev.exoplayer@gmail.com using a subject in the format
+"Issue #1234", where "#1234" should be replaced with your issue number.
+
 <!-- DO NOT DELETE
 validate_template=true
 template_path=.github/ISSUE_TEMPLATE/content_not_playing.md
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
index 089de35910..d481de33ce 100644
--- a/.github/ISSUE_TEMPLATE/feature_request.md
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -8,8 +8,9 @@ assignees: ''
 
 Before filing a feature request:
 -----------------------
-- Search existing open issues, specifically with the label ‘enhancement’.
-- Search existing pull requests.
+- Search existing open issues, specifically with the label ‘enhancement’:
+  https://github.com/google/ExoPlayer/labels/enhancement
+- Search existing pull requests: https://github.com/google/ExoPlayer/pulls
 
 When filing a feature request:
 -----------------------
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
index 3ed569862f..b5f40884d8 100644
--- a/.github/ISSUE_TEMPLATE/question.md
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -12,8 +12,12 @@ Before filing a question:
   a general Android development question, please do so on Stack Overflow.
 - Search existing issues, including issues that are closed. It’s often the
   quickest way to get an answer!
-- Consult our FAQs, developer guide and the class reference of ExoPlayer. These
-  can be found at https://exoplayer.dev/.
+  https://github.com/google/ExoPlayer/issues?q=is%3Aissue
+- Consult our developer website, which can be found at https://exoplayer.dev/.
+  It provides detailed information about supported formats, devices as well as
+  information about how to use the ExoPlayer library.
+- The ExoPlayer library Javadoc can be found at
+  https://exoplayer.dev/doc/reference/
 
 When filing a question:
 -----------------------
@@ -28,6 +32,23 @@ important for us to know this so that we can improve our documentation.
 ### [REQUIRED] Question
 Describe your question in detail.
 
+### A full bug report captured from the device
+In case your question refers to a problem you are seeing in your app, capture a
+full bug report using "adb bugreport". Please attach the captured bug report as
+a file. If you don't wish to post it publicly, please submit the issue, then
+email the bug report to dev.exoplayer@gmail.com using a subject in the format
+"Issue #1234", where "#1234" should be replaced with your issue number.
+
+### Link to test content
+In case your question is related to a piece of media, which you are trying to
+play, please provide a JSON snippet for the demo app’s media.exolist.json file,
+or a link to media that reproduces the issue. If you don't wish to post it
+publicly, please submit the issue, then email the link to
+dev.exoplayer@gmail.com using a subject in the format "Issue #1234", where
+"#1234" should be replaced with your issue number. Provide all the metadata we'd
+need to play the content like drm license urls or similar. If the content is
+accessible only in certain countries or regions, please say so.
+
 <!-- DO NOT DELETE
 validate_template=true
 template_path=.github/ISSUE_TEMPLATE/question.md
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 9e69bcc917..04bf514c12 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,86 @@
 # Release notes #
 
+### 2.10.3 ###
+
+* Display last frame when seeking to end of stream
+  ([#2568](https://github.com/google/ExoPlayer/issues/2568)).
+* Audio:
+  * Fix an issue where not all audio was played out when the configuration
+    for the underlying track was changing (e.g., at some period transitions).
+  * Fix an issue where playback speed was applied inaccurately in playlists
+    ([#6117](https://github.com/google/ExoPlayer/issues/6117)).
+* UI: Fix `PlayerView` incorrectly consuming touch events if no controller is
+  attached ([#6109](https://github.com/google/ExoPlayer/issues/6109)).
+* CEA608: Fix repetition of special North American characters
+  ([#6133](https://github.com/google/ExoPlayer/issues/6133)).
+* FLV: Fix bug that caused playback of some live streams to not start
+  ([#6111](https://github.com/google/ExoPlayer/issues/6111)).
+* SmoothStreaming: Parse text stream `Subtype` into `Format.roleFlags`.
+* MediaSession extension: Fix `MediaSessionConnector.play()` not resuming
+  playback ([#6093](https://github.com/google/ExoPlayer/issues/6093)).
+
+### 2.10.2 ###
+
+* Add `ResolvingDataSource` for just-in-time resolution of `DataSpec`s
+  ([#5779](https://github.com/google/ExoPlayer/issues/5779)).
+* Add `SilenceMediaSource` that can be used to play silence of a given
+  duration ([#5735](https://github.com/google/ExoPlayer/issues/5735)).
+* Offline:
+  * Prevent unexpected `DownloadHelper.Callback.onPrepared` callbacks after
+    preparation of a `DownloadHelper` fails
+    ([#5915](https://github.com/google/ExoPlayer/issues/5915)).
+  * Fix `CacheUtil.cache()` downloading too much data
+    ([#5927](https://github.com/google/ExoPlayer/issues/5927)).
+  * Fix misreporting cached bytes when caching is paused
+    ([#5573](https://github.com/google/ExoPlayer/issues/5573)).
+* UI:
+  * Allow setting `DefaultTimeBar` attributes on `PlayerView` and
+    `PlayerControlView`.
+  * Change playback controls toggle from touch down to touch up events
+    ([#5784](https://github.com/google/ExoPlayer/issues/5784)).
+  * Fix issue where playback controls were not kept visible on key presses
+    ([#5963](https://github.com/google/ExoPlayer/issues/5963)).
+* Subtitles:
+  * CEA-608: Handle XDS and TEXT modes
+    ([#5807](https://github.com/google/ExoPlayer/pull/5807)).
+  * TTML: Fix bitmap rendering
+    ([#5633](https://github.com/google/ExoPlayer/pull/5633)).
+* IMA: Fix ad pod index offset calculation without preroll
+  ([#5928](https://github.com/google/ExoPlayer/issues/5928)).
+* Add a `playWhenReady` flag to MediaSessionConnector.PlaybackPreparer methods
+  to indicate whether a controller sent a play or only a prepare command. This
+  allows to take advantage of decoder reuse with the MediaSessionConnector
+  ([#5891](https://github.com/google/ExoPlayer/issues/5891)).
+* Add `ProgressUpdateListener` to `PlayerControlView`
+  ([#5834](https://github.com/google/ExoPlayer/issues/5834)).
+* Add support for auto-detecting UDP streams in `DefaultDataSource`
+  ([#6036](https://github.com/google/ExoPlayer/pull/6036)).
+* Allow enabling decoder fallback with `DefaultRenderersFactory`
+  ([#5942](https://github.com/google/ExoPlayer/issues/5942)).
+* Gracefully handle revoked `ACCESS_NETWORK_STATE` permission
+  ([#6019](https://github.com/google/ExoPlayer/issues/6019)).
+* Fix decoding problems when seeking back after seeking beyond a mid-roll ad
+  ([#6009](https://github.com/google/ExoPlayer/issues/6009)).
+* Fix application of `maxAudioBitrate` for adaptive audio track groups
+  ([#6006](https://github.com/google/ExoPlayer/issues/6006)).
+* Fix bug caused by parallel adaptive track selection using `Format`s without
+  bitrate information
+  ([#5971](https://github.com/google/ExoPlayer/issues/5971)).
+* Fix bug in `CastPlayer.getCurrentWindowIndex()`
+  ([#5955](https://github.com/google/ExoPlayer/issues/5955)).
+
+### 2.10.1 ###
+
+* Offline: Add option to remove all downloads.
+* HLS: Fix `NullPointerException` when using HLS chunkless preparation
+  ([#5868](https://github.com/google/ExoPlayer/issues/5868)).
+* Fix handling of empty values and line terminators in SHOUTcast ICY metadata
+  ([#5876](https://github.com/google/ExoPlayer/issues/5876)).
+* Fix DVB subtitles for SDK 28
+  ([#5862](https://github.com/google/ExoPlayer/issues/5862)).
+* Add a workaround for a decoder failure on ZTE Axon7 mini devices when playing
+  48kHz audio ([#5821](https://github.com/google/ExoPlayer/issues/5821)).
+
 ### 2.10.0 ###
 
 * Core library:
diff --git a/build.gradle b/build.gradle
index 4761a1fbe0..bc538ead68 100644
--- a/build.gradle
+++ b/build.gradle
@@ -36,7 +36,7 @@ allprojects {
         jcenter()
     }
     project.ext {
-        exoplayerPublishEnabled = true
+        exoplayerPublishEnabled = false
     }
     if (it.hasProperty('externalBuildDir')) {
         if (!new File(externalBuildDir).isAbsolute()) {
@@ -44,6 +44,7 @@ allprojects {
         }
         buildDir = "${externalBuildDir}/${project.name}"
     }
+    group = 'com.google.android.exoplayer'
 }
 
 apply from: 'javadoc_combined.gradle'
diff --git a/constants.gradle b/constants.gradle
index 5063c59141..70e77b22c6 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.10.0'
-    releaseVersionCode = 2010000
+    releaseVersion = '2.10.3'
+    releaseVersionCode = 2010003
     minSdkVersion = 16
     targetSdkVersion = 28
     compileSdkVersion = 28
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
index 4b71b3a001..df153a1423 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
@@ -66,7 +66,6 @@
   private final Listener listener;
   private final ConcatenatingMediaSource concatenatingMediaSource;
 
-  private boolean castMediaQueueCreationPending;
   private int currentItemIndex;
   private Player currentPlayer;
 
@@ -268,9 +267,6 @@ public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
   public void onTimelineChanged(
       Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
     updateCurrentItemIndex();
-    if (currentPlayer == castPlayer && timeline.isEmpty()) {
-      castMediaQueueCreationPending = true;
-    }
   }
 
   // CastPlayer.SessionAvailabilityListener implementation.
@@ -332,7 +328,6 @@ private void setCurrentPlayer(Player currentPlayer) {
     this.currentPlayer = currentPlayer;
 
     // Media queue management.
-    castMediaQueueCreationPending = currentPlayer == castPlayer;
     if (currentPlayer == exoPlayer) {
       exoPlayer.prepare(concatenatingMediaSource);
     }
@@ -352,12 +347,11 @@ private void setCurrentPlayer(Player currentPlayer) {
    */
   private void setCurrentItem(int itemIndex, long positionMs, boolean playWhenReady) {
     maybeSetCurrentItemAndNotify(itemIndex);
-    if (castMediaQueueCreationPending) {
+    if (currentPlayer == castPlayer && castPlayer.getCurrentTimeline().isEmpty()) {
       MediaQueueItem[] items = new MediaQueueItem[mediaQueue.size()];
       for (int i = 0; i < items.length; i++) {
         items[i] = buildMediaQueueItem(mediaQueue.get(i));
       }
-      castMediaQueueCreationPending = false;
       castPlayer.loadItems(items, itemIndex, positionMs, Player.REPEAT_MODE_OFF);
     } else {
       currentPlayer.seekTo(itemIndex, positionMs);
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
index f372a47df6..a913a9b891 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
@@ -30,15 +30,12 @@
 import com.google.android.exoplayer2.offline.DownloadManager;
 import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.offline.DownloadService;
-import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.List;
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /** Tracks media that has been downloaded. */
@@ -86,11 +83,9 @@ public boolean isDownloaded(Uri uri) {
   }
 
   @SuppressWarnings("unchecked")
-  public List<StreamKey> getOfflineStreamKeys(Uri uri) {
+  public DownloadRequest getDownloadRequest(Uri uri) {
     Download download = downloads.get(uri);
-    return download != null && download.state != Download.STATE_FAILED
-        ? download.request.streamKeys
-        : Collections.emptyList();
+    return download != null && download.state != Download.STATE_FAILED ? download.request : null;
   }
 
   public void toggleDownload(
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index acb24adebe..35307eb5d8 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -45,7 +45,8 @@
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
-import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -75,7 +76,6 @@
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
-import java.util.List;
 import java.util.UUID;
 
 /** An activity that plays media using {@link SimpleExoPlayer}. */
@@ -457,33 +457,26 @@ private MediaSource buildMediaSource(Uri uri) {
   }
 
   private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
+    DownloadRequest downloadRequest =
+        ((DemoApplication) getApplication()).getDownloadTracker().getDownloadRequest(uri);
+    if (downloadRequest != null) {
+      return DownloadHelper.createMediaSource(downloadRequest, dataSourceFactory);
+    }
     @ContentType int type = Util.inferContentType(uri, overrideExtension);
-    List<StreamKey> offlineStreamKeys = getOfflineStreamKeys(uri);
     switch (type) {
       case C.TYPE_DASH:
-        return new DashMediaSource.Factory(dataSourceFactory)
-            .setStreamKeys(offlineStreamKeys)
-            .createMediaSource(uri);
+        return new DashMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_SS:
-        return new SsMediaSource.Factory(dataSourceFactory)
-            .setStreamKeys(offlineStreamKeys)
-            .createMediaSource(uri);
+        return new SsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_HLS:
-        return new HlsMediaSource.Factory(dataSourceFactory)
-            .setStreamKeys(offlineStreamKeys)
-            .createMediaSource(uri);
+        return new HlsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_OTHER:
         return new ProgressiveMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
-      default: {
+      default:
         throw new IllegalStateException("Unsupported type: " + type);
-      }
     }
   }
 
-  private List<StreamKey> getOfflineStreamKeys(Uri uri) {
-    return ((DemoApplication) getApplication()).getDownloadTracker().getOfflineStreamKeys(uri);
-  }
-
   private DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(
       UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
       throws UnsupportedDrmException {
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
index a7dd1a0df8..bc409410c3 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
@@ -306,7 +306,7 @@ public CharSequence getPageTitle(int position) {
     }
   }
 
-  /** Fragment to show a track seleciton in tab of the track selection dialog. */
+  /** Fragment to show a track selection in tab of the track selection dialog. */
   public static final class TrackSelectionViewFragment extends Fragment
       implements TrackSelectionView.TrackSelectionListener {
 
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index 4dc463ff81..e067789bc4 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -31,7 +31,7 @@ android {
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:16.1.2'
+    api 'com.google.android.gms:play-services-cast-framework:16.2.0'
     implementation 'androidx.annotation:annotation:1.0.2'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 14bb433d2b..4b973715b1 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -45,8 +45,11 @@
 import com.google.android.gms.cast.framework.media.RemoteMediaClient.MediaChannelResult;
 import com.google.android.gms.common.api.PendingResult;
 import com.google.android.gms.common.api.ResultCallback;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * {@link Player} implementation that communicates with a Cast receiver app.
@@ -86,8 +89,10 @@
   private final StatusListener statusListener;
   private final SeekResultCallback seekResultCallback;
 
-  // Listeners.
-  private final CopyOnWriteArraySet<EventListener> listeners;
+  // Listeners and notification.
+  private final CopyOnWriteArrayList<ListenerHolder> listeners;
+  private final ArrayList<ListenerNotificationTask> notificationsBatch;
+  private final ArrayDeque<ListenerNotificationTask> ongoingNotificationsTasks;
   private SessionAvailabilityListener sessionAvailabilityListener;
 
   // Internal state.
@@ -113,7 +118,9 @@ public CastPlayer(CastContext castContext) {
     period = new Timeline.Period();
     statusListener = new StatusListener();
     seekResultCallback = new SeekResultCallback();
-    listeners = new CopyOnWriteArraySet<>();
+    listeners = new CopyOnWriteArrayList<>();
+    notificationsBatch = new ArrayList<>();
+    ongoingNotificationsTasks = new ArrayDeque<>();
 
     SessionManager sessionManager = castContext.getSessionManager();
     sessionManager.addSessionManagerListener(statusListener, CastSession.class);
@@ -296,12 +303,17 @@ public Looper getApplicationLooper() {
 
   @Override
   public void addListener(EventListener listener) {
-    listeners.add(listener);
+    listeners.addIfAbsent(new ListenerHolder(listener));
   }
 
   @Override
   public void removeListener(EventListener listener) {
-    listeners.remove(listener);
+    for (ListenerHolder listenerHolder : listeners) {
+      if (listenerHolder.listener.equals(listener)) {
+        listenerHolder.release();
+        listeners.remove(listenerHolder);
+      }
+    }
   }
 
   @Override
@@ -347,14 +359,13 @@ public void seekTo(int windowIndex, long positionMs) {
       pendingSeekCount++;
       pendingSeekWindowIndex = windowIndex;
       pendingSeekPositionMs = positionMs;
-      for (EventListener listener : listeners) {
-        listener.onPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPositionDiscontinuity(DISCONTINUITY_REASON_SEEK)));
     } else if (pendingSeekCount == 0) {
-      for (EventListener listener : listeners) {
-        listener.onSeekProcessed();
-      }
+      notificationsBatch.add(new ListenerNotificationTask(EventListener::onSeekProcessed));
     }
+    flushNotifications();
   }
 
   @Override
@@ -530,30 +541,40 @@ public void updateInternalState() {
         || this.playWhenReady != playWhenReady) {
       this.playbackState = playbackState;
       this.playWhenReady = playWhenReady;
-      for (EventListener listener : listeners) {
-        listener.onPlayerStateChanged(this.playWhenReady, this.playbackState);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPlayerStateChanged(this.playWhenReady, this.playbackState)));
     }
     @RepeatMode int repeatMode = fetchRepeatMode(remoteMediaClient);
     if (this.repeatMode != repeatMode) {
       this.repeatMode = repeatMode;
-      for (EventListener listener : listeners) {
-        listener.onRepeatModeChanged(repeatMode);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(listener -> listener.onRepeatModeChanged(this.repeatMode)));
+    }
+    maybeUpdateTimelineAndNotify();
+
+    int currentWindowIndex = C.INDEX_UNSET;
+    MediaQueueItem currentItem = remoteMediaClient.getCurrentItem();
+    if (currentItem != null) {
+      currentWindowIndex = currentTimeline.getIndexOfPeriod(currentItem.getItemId());
+    }
+    if (currentWindowIndex == C.INDEX_UNSET) {
+      // The timeline is empty. Fall back to index 0, which is what ExoPlayer would do.
+      currentWindowIndex = 0;
     }
-    int currentWindowIndex = fetchCurrentWindowIndex(getMediaStatus());
     if (this.currentWindowIndex != currentWindowIndex && pendingSeekCount == 0) {
       this.currentWindowIndex = currentWindowIndex;
-      for (EventListener listener : listeners) {
-        listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener ->
+                  listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION)));
     }
     if (updateTracksAndSelections()) {
-      for (EventListener listener : listeners) {
-        listener.onTracksChanged(currentTrackGroups, currentTrackSelection);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onTracksChanged(currentTrackGroups, currentTrackSelection)));
     }
-    maybeUpdateTimelineAndNotify();
+    flushNotifications();
   }
 
   private void maybeUpdateTimelineAndNotify() {
@@ -561,9 +582,10 @@ private void maybeUpdateTimelineAndNotify() {
       @Player.TimelineChangeReason int reason = waitingForInitialTimeline
           ? Player.TIMELINE_CHANGE_REASON_PREPARED : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
       waitingForInitialTimeline = false;
-      for (EventListener listener : listeners) {
-        listener.onTimelineChanged(currentTimeline, null, reason);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener ->
+                  listener.onTimelineChanged(currentTimeline, /* manifest= */ null, reason)));
     }
   }
 
@@ -701,16 +723,6 @@ private static int fetchRepeatMode(RemoteMediaClient remoteMediaClient) {
     }
   }
 
-  /**
-   * Retrieves the current item index from {@code mediaStatus} and maps it into a window index. If
-   * there is no media session, returns 0.
-   */
-  private static int fetchCurrentWindowIndex(@Nullable MediaStatus mediaStatus) {
-    Integer currentItemId = mediaStatus != null
-        ? mediaStatus.getIndexById(mediaStatus.getCurrentItemId()) : null;
-    return currentItemId != null ? currentItemId : 0;
-  }
-
   private static boolean isTrackActive(long id, long[] activeTrackIds) {
     for (long activeTrackId : activeTrackIds) {
       if (activeTrackId == id) {
@@ -826,7 +838,23 @@ public void onSessionResuming(CastSession castSession, String s) {
 
   }
 
-  // Result callbacks hooks.
+  // Internal methods.
+
+  private void flushNotifications() {
+    boolean recursiveNotification = !ongoingNotificationsTasks.isEmpty();
+    ongoingNotificationsTasks.addAll(notificationsBatch);
+    notificationsBatch.clear();
+    if (recursiveNotification) {
+      // This will be handled once the current notification task is finished.
+      return;
+    }
+    while (!ongoingNotificationsTasks.isEmpty()) {
+      ongoingNotificationsTasks.peekFirst().execute();
+      ongoingNotificationsTasks.removeFirst();
+    }
+  }
+
+  // Internal classes.
 
   private final class SeekResultCallback implements ResultCallback<MediaChannelResult> {
 
@@ -840,9 +868,25 @@ public void onResult(@NonNull MediaChannelResult result) {
       if (--pendingSeekCount == 0) {
         pendingSeekWindowIndex = C.INDEX_UNSET;
         pendingSeekPositionMs = C.TIME_UNSET;
-        for (EventListener listener : listeners) {
-          listener.onSeekProcessed();
-        }
+        notificationsBatch.add(new ListenerNotificationTask(EventListener::onSeekProcessed));
+        flushNotifications();
+      }
+    }
+  }
+
+  private final class ListenerNotificationTask {
+
+    private final Iterator<ListenerHolder> listenersSnapshot;
+    private final ListenerInvocation listenerInvocation;
+
+    private ListenerNotificationTask(ListenerInvocation listenerInvocation) {
+      this.listenersSnapshot = listeners.iterator();
+      this.listenerInvocation = listenerInvocation;
+    }
+
+    public void execute() {
+      while (listenersSnapshot.hasNext()) {
+        listenersSnapshot.next().invoke(listenerInvocation);
       }
     }
   }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index a9995af0e4..ca196b1d2f 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -113,7 +113,7 @@ public InterruptedIOException(InterruptedException e) {
 
   private final CronetEngine cronetEngine;
   private final Executor executor;
-  private final Predicate<String> contentTypePredicate;
+  @Nullable private final Predicate<String> contentTypePredicate;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
@@ -146,6 +146,18 @@ public InterruptedIOException(InterruptedException e) {
 
   private volatile long currentConnectTimeoutMs;
 
+  /**
+   * @param cronetEngine A CronetEngine.
+   * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
+   *     be a direct executor (i.e. executes tasks on the calling thread) in order to avoid a thread
+   *     hop from Cronet's internal network thread to the response handling thread. However, to
+   *     avoid slowing down overall network performance, care must be taken to make sure response
+   *     handling is a fast operation when using a direct executor.
+   */
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor) {
+    this(cronetEngine, executor, /* contentTypePredicate= */ null);
+  }
+
   /**
    * @param cronetEngine A CronetEngine.
    * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
@@ -158,7 +170,9 @@ public InterruptedIOException(InterruptedException e) {
    *     #open(DataSpec)}.
    */
   public CronetDataSource(
-      CronetEngine cronetEngine, Executor executor, Predicate<String> contentTypePredicate) {
+      CronetEngine cronetEngine,
+      Executor executor,
+      @Nullable Predicate<String> contentTypePredicate) {
     this(
         cronetEngine,
         executor,
@@ -188,7 +202,7 @@ public CronetDataSource(
   public CronetDataSource(
       CronetEngine cronetEngine,
       Executor executor,
-      Predicate<String> contentTypePredicate,
+      @Nullable Predicate<String> contentTypePredicate,
       int connectTimeoutMs,
       int readTimeoutMs,
       boolean resetTimeoutOnRedirects,
@@ -225,7 +239,7 @@ public CronetDataSource(
   public CronetDataSource(
       CronetEngine cronetEngine,
       Executor executor,
-      Predicate<String> contentTypePredicate,
+      @Nullable Predicate<String> contentTypePredicate,
       int connectTimeoutMs,
       int readTimeoutMs,
       boolean resetTimeoutOnRedirects,
@@ -246,7 +260,7 @@ public CronetDataSource(
   /* package */ CronetDataSource(
       CronetEngine cronetEngine,
       Executor executor,
-      Predicate<String> contentTypePredicate,
+      @Nullable Predicate<String> contentTypePredicate,
       int connectTimeoutMs,
       int readTimeoutMs,
       boolean resetTimeoutOnRedirects,
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index a91bbbd981..2df9448d08 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -34,6 +34,7 @@ android {
 dependencies {
     api 'com.google.ads.interactivemedia.v3:interactivemedia:3.11.2'
     implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.annotation:annotation:1.0.2'
     implementation 'com.google.android.gms:play-services-ads-identifier:16.0.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 465ad51ac5..68e48b8d33 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -948,8 +948,8 @@ public void resumeAd() {
   @Override
   public void onTimelineChanged(
       Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
-    if (reason == Player.TIMELINE_CHANGE_REASON_RESET) {
-      // The player is being reset and this source will be released.
+    if (timeline.isEmpty()) {
+      // The player is being reset or contains no media.
       return;
     }
     Assertions.checkArgument(timeline.getPeriodCount() == 1);
@@ -1054,13 +1054,8 @@ private void startAdPlayback() {
     long contentPositionMs = player.getCurrentPosition();
     int adGroupIndexForPosition =
         adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
-    if (adGroupIndexForPosition == 0) {
-      podIndexOffset = 0;
-    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
-      // There is no preroll and midroll pod indices start at 1.
-      podIndexOffset = -1;
-    } else /* adGroupIndexForPosition > 0 */ {
-      // Skip ad groups before the one at or immediately before the playback position.
+    if (adGroupIndexForPosition > 0 && adGroupIndexForPosition != C.INDEX_UNSET) {
+      // Skip any ad groups before the one at or immediately before the playback position.
       for (int i = 0; i < adGroupIndexForPosition; i++) {
         adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
       }
@@ -1070,9 +1065,18 @@ private void startAdPlayback() {
       long adGroupBeforeTimeUs = adGroupTimesUs[adGroupIndexForPosition - 1];
       double midpointTimeUs = (adGroupForPositionTimeUs + adGroupBeforeTimeUs) / 2d;
       adsRenderingSettings.setPlayAdsAfterTime(midpointTimeUs / C.MICROS_PER_SECOND);
+    }
 
-      // We're removing one or more ads, which means that the earliest ad (if any) will be a
-      // midroll/postroll. Midroll pod indices start at 1.
+    // IMA indexes any remaining midroll ad pods from 1. A preroll (if present) has index 0.
+    // Store an index offset as we want to index all ads (including skipped ones) from 0.
+    if (adGroupIndexForPosition == 0 && adGroupTimesUs[0] == 0) {
+      // We are playing a preroll.
+      podIndexOffset = 0;
+    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
+      // There's no ad to play which means there's no preroll.
+      podIndexOffset = -1;
+    } else {
+      // We are playing a midroll and any ads before it were skipped.
       podIndexOffset = adGroupIndexForPosition - 1;
     }
 
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 9c80fabc50..7e72904078 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -172,7 +172,7 @@ boolean onCommand(
         ResultReceiver cb);
   }
 
-  /** Interface to which playback preparation actions are delegated. */
+  /** Interface to which playback preparation and play actions are delegated. */
   public interface PlaybackPreparer extends CommandReceiver {
 
     long ACTIONS =
@@ -197,14 +197,36 @@ boolean onCommand(
      * @return The bitmask of the supported media actions.
      */
     long getSupportedPrepareActions();
-    /** See {@link MediaSessionCompat.Callback#onPrepare()}. */
-    void onPrepare();
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}. */
-    void onPrepareFromMediaId(String mediaId, Bundle extras);
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}. */
-    void onPrepareFromSearch(String query, Bundle extras);
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}. */
-    void onPrepareFromUri(Uri uri, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepare()}.
+     *
+     * @param playWhenReady Whether playback should be started after preparation.
+     */
+    void onPrepare(boolean playWhenReady);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}.
+     *
+     * @param mediaId The media id of the media item to be prepared.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromMediaId(String mediaId, boolean playWhenReady, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}.
+     *
+     * @param query The search query.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromSearch(String query, boolean playWhenReady, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}.
+     *
+     * @param uri The {@link Uri} of the media item to be prepared.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromUri(Uri uri, boolean playWhenReady, Bundle extras);
   }
 
   /**
@@ -355,6 +377,13 @@ void onCustomAction(
     /**
      * Gets the {@link MediaMetadataCompat} to be published to the session.
      *
+     * <p>An app may need to load metadata resources like artwork bitmaps asynchronously. In such a
+     * case the app should return a {@link MediaMetadataCompat} object that does not contain these
+     * resources as a placeholder. The app should start an asynchronous operation to download the
+     * bitmap and put it into a cache. Finally, the app should call {@link
+     * #invalidateMediaSessionMetadata()}. This causes this callback to be called again and the app
+     * can now return a {@link MediaMetadataCompat} object with all the resources included.
+     *
      * @param player The player connected to the media session.
      * @return The {@link MediaMetadataCompat} to be published to the session.
      */
@@ -834,13 +863,6 @@ private boolean canDispatchMediaButtonEvent() {
     return player != null && mediaButtonEventHandler != null;
   }
 
-  private void stopPlayerForPrepare(boolean playWhenReady) {
-    if (player != null) {
-      player.stop();
-      player.setPlayWhenReady(playWhenReady);
-    }
-  }
-
   private void rewind(Player player) {
     if (player.isCurrentWindowSeekable() && rewindMs > 0) {
       seekTo(player, player.getCurrentPosition() - rewindMs);
@@ -1047,12 +1069,13 @@ public void onPlay() {
       if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_PLAY)) {
         if (player.getPlaybackState() == Player.STATE_IDLE) {
           if (playbackPreparer != null) {
-            playbackPreparer.onPrepare();
+            playbackPreparer.onPrepare(/* playWhenReady= */ true);
           }
         } else if (player.getPlaybackState() == Player.STATE_ENDED) {
           controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
-        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ true);
+        controlDispatcher.dispatchSetPlayWhenReady(
+            Assertions.checkNotNull(player), /* playWhenReady= */ true);
       }
     }
 
@@ -1182,56 +1205,49 @@ public void onCommand(String command, Bundle extras, ResultReceiver cb) {
     @Override
     public void onPrepare() {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepare();
+        playbackPreparer.onPrepare(/* playWhenReady= */ false);
       }
     }
 
     @Override
     public void onPrepareFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromMediaId(mediaId, extras);
+        playbackPreparer.onPrepareFromMediaId(mediaId, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPrepareFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_SEARCH)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromSearch(query, extras);
+        playbackPreparer.onPrepareFromSearch(query, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPrepareFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_URI)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromUri(uri, extras);
+        playbackPreparer.onPrepareFromUri(uri, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPlayFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromMediaId(mediaId, extras);
+        playbackPreparer.onPrepareFromMediaId(mediaId, /* playWhenReady= */ true, extras);
       }
     }
 
     @Override
     public void onPlayFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_SEARCH)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromSearch(query, extras);
+        playbackPreparer.onPrepareFromSearch(query, /* playWhenReady= */ true, extras);
       }
     }
 
     @Override
     public void onPlayFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_URI)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromUri(uri, extras);
+        playbackPreparer.onPrepareFromUri(uri, /* playWhenReady= */ true, extras);
       }
     }
 
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index a749495184..8eb8bba920 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -73,6 +73,15 @@
   private long bytesSkipped;
   private long bytesRead;
 
+  /**
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the source.
+   * @param userAgent An optional User-Agent string.
+   */
+  public OkHttpDataSource(Call.Factory callFactory, @Nullable String userAgent) {
+    this(callFactory, userAgent, /* contentTypePredicate= */ null);
+  }
+
   /**
    * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
    *     by the source.
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 0de29eea32..be75eae359 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -29,6 +29,7 @@ VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 ```
 
 * Download the [Android NDK][] and set its location in an environment variable.
+  The build configuration has been tested with Android NDK r19c.
 
 ```
 NDK_PATH="<path to Android NDK>"
@@ -54,7 +55,7 @@ git checkout tags/v1.8.0 -b v1.8.0
 
 ```
 cd ${VP9_EXT_PATH}/jni && \
-./generate_libvpx_android_configs.sh "${NDK_PATH}"
+./generate_libvpx_android_configs.sh
 ```
 
 * Build the JNI native libraries from the command line:
@@ -66,7 +67,6 @@ ${NDK_PATH}/ndk-build APP_ABI=all -j4
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
 [Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
-[#3520]: https://github.com/google/ExoPlayer/issues/3520
 
 ## Notes ##
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index 22330e0a05..30d7b8e92c 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -60,8 +60,8 @@ public void release() {
    * Initializes the buffer.
    *
    * @param timeUs The presentation timestamp for the buffer, in microseconds.
-   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE} and {@link
-   *     VpxDecoder#OUTPUT_MODE_YUV}.
+   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE}, {@link
+   *     VpxDecoder#OUTPUT_MODE_YUV} and {@link VpxDecoder#OUTPUT_MODE_SURFACE_YUV}.
    */
   public void init(long timeUs, int mode) {
     this.timeUs = timeUs;
@@ -110,6 +110,15 @@ public boolean initForYuvFrame(int width, int height, int yStride, int uvStride,
     return true;
   }
 
+  /**
+   * Configures the buffer for the given frame dimensions when passing actual frame data via {@link
+   * #decoderPrivate}. Called via JNI after decoding completes.
+   */
+  public void initForPrivateFrame(int width, int height) {
+    this.width = width;
+    this.height = height;
+  }
+
   private void initData(int size) {
     if (data == null || data.capacity() < size) {
       data = ByteBuffer.allocateDirect(size);
diff --git a/extensions/vp9/src/main/jni/Application.mk b/extensions/vp9/src/main/jni/Application.mk
index 59bf5f8f87..ed28f07acb 100644
--- a/extensions/vp9/src/main/jni/Application.mk
+++ b/extensions/vp9/src/main/jni/Application.mk
@@ -15,6 +15,6 @@
 #
 
 APP_OPTIM := release
-APP_STL := gnustl_static
+APP_STL := c++_static
 APP_CPPFLAGS := -frtti
-APP_PLATFORM := android-9
+APP_PLATFORM := android-16
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
index eab6862555..18f1dd5c69 100755
--- a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -20,46 +20,33 @@
 
 set -e
 
-if [ $# -ne 1 ]; then
-  echo "Usage: ${0} <path_to_android_ndk>"
+if [ $# -ne 0 ]; then
+  echo "Usage: ${0}"
   exit
 fi
 
-ndk="${1}"
-shift 1
-
 # configuration parameters common to all architectures
 common_params="--disable-examples --disable-docs --enable-realtime-only"
 common_params+=" --disable-vp8 --disable-vp9-encoder --disable-webm-io"
 common_params+=" --disable-libyuv --disable-runtime-cpu-detect"
+common_params+=" --enable-external-build"
 
 # configuration parameters for various architectures
 arch[0]="armeabi-v7a"
-config[0]="--target=armv7-android-gcc --sdk-path=$ndk --enable-neon"
-config[0]+=" --enable-neon-asm"
+config[0]="--target=armv7-android-gcc --enable-neon --enable-neon-asm"
 
-arch[1]="armeabi"
-config[1]="--target=armv7-android-gcc --sdk-path=$ndk --disable-neon"
-config[1]+=" --disable-neon-asm"
+arch[1]="x86"
+config[1]="--force-target=x86-android-gcc --disable-sse2"
+config[1]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
+config[1]+=" --disable-avx2 --enable-pic"
 
-arch[2]="mips"
-config[2]="--force-target=mips32-android-gcc --sdk-path=$ndk"
+arch[2]="arm64-v8a"
+config[2]="--force-target=armv8-android-gcc --enable-neon"
 
-arch[3]="x86"
-config[3]="--force-target=x86-android-gcc --sdk-path=$ndk --disable-sse2"
+arch[3]="x86_64"
+config[3]="--force-target=x86_64-android-gcc --disable-sse2"
 config[3]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
-config[3]+=" --disable-avx2 --enable-pic"
-
-arch[4]="arm64-v8a"
-config[4]="--force-target=armv8-android-gcc --sdk-path=$ndk --enable-neon"
-
-arch[5]="x86_64"
-config[5]="--force-target=x86_64-android-gcc --sdk-path=$ndk --disable-sse2"
-config[5]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
-config[5]+=" --disable-avx2 --enable-pic --disable-neon --disable-neon-asm"
-
-arch[6]="mips64"
-config[6]="--force-target=mips64-android-gcc --sdk-path=$ndk"
+config[3]+=" --disable-avx2 --enable-pic --disable-neon --disable-neon-asm"
 
 limit=$((${#arch[@]} - 1))
 
@@ -102,10 +89,7 @@ for i in $(seq 0 ${limit}); do
   # configure and make
   echo "build_android_configs: "
   echo "configure ${config[${i}]} ${common_params}"
-  ../../libvpx/configure ${config[${i}]} ${common_params} --extra-cflags=" \
-    -isystem $ndk/sysroot/usr/include/arm-linux-androideabi \
-    -isystem $ndk/sysroot/usr/include \
-    "
+  ../../libvpx/configure ${config[${i}]} ${common_params}
   rm -f libvpx_srcs.txt
   for f in ${allowed_files}; do
     # the build system supports multiple different configurations. avoid
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 82c023afbc..9fc8b09a18 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -60,6 +60,7 @@
 
 // JNI references for VpxOutputBuffer class.
 static jmethodID initForYuvFrame;
+static jmethodID initForPrivateFrame;
 static jfieldID dataField;
 static jfieldID outputModeField;
 static jfieldID decoderPrivateField;
@@ -481,6 +482,8 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
       "com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
                                      "(IIIII)Z");
+  initForPrivateFrame =
+      env->GetMethodID(outputBufferClass, "initForPrivateFrame", "(II)V");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
@@ -602,6 +605,10 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     }
     jfb->d_w = img->d_w;
     jfb->d_h = img->d_h;
+    env->CallVoidMethod(jOutputBuffer, initForPrivateFrame, img->d_w, img->d_h);
+    if (env->ExceptionCheck()) {
+      return -1;
+    }
     env->SetIntField(jOutputBuffer, decoderPrivateField,
                      id + kDecoderPrivateBase);
   }
diff --git a/gradle.properties b/gradle.properties
index 4b9bfa8fa2..31ff0ad6b6 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -3,3 +3,4 @@ android.useAndroidX=true
 android.enableJetifier=true
 android.enableUnitTestBinaryResources=true
 buildDir=buildout
+org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m
diff --git a/issues/player-accessed-on-wrong-thread.md b/issues/player-accessed-on-wrong-thread.md
new file mode 100644
index 0000000000..d4f1e74f45
--- /dev/null
+++ b/issues/player-accessed-on-wrong-thread.md
@@ -0,0 +1,5 @@
+---
+permalink: /issues/player-accessed-on-wrong-thread
+redirect_to:
+  - https://exoplayer.dev/troubleshooting.html#what-do-player-is-accessed-on-the-wrong-thread-warnings-mean
+---
diff --git a/javadoc_library.gradle b/javadoc_library.gradle
index a818ea390e..74fcc3dd6c 100644
--- a/javadoc_library.gradle
+++ b/javadoc_library.gradle
@@ -18,10 +18,13 @@ android.libraryVariants.all { variant ->
     if (!name.equals("release")) {
         return; // Skip non-release builds.
     }
+    def allSourceDirs = variant.sourceSets.inject ([]) {
+        acc, val -> acc << val.javaDirectories
+    }
     task("generateJavadoc", type: Javadoc) {
         description = "Generates Javadoc for the ${javadocTitle}."
         title = "ExoPlayer ${javadocTitle}"
-        source = variant.javaCompileProvider.get().source
+        source = allSourceDirs
         options {
             links "http://docs.oracle.com/javase/7/docs/api/"
             linksOffline "https://developer.android.com/reference",
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
index 07ba438182..8c11810506 100644
--- a/library/core/proguard-rules.txt
+++ b/library/core/proguard-rules.txt
@@ -46,18 +46,21 @@
 
 # Constructors accessed via reflection in DownloadHelper
 -dontnote com.google.android.exoplayer2.source.dash.DashMediaSource$Factory
--keepclassmembers class com.google.android.exoplayer2.source.dash.DashMediaSource$Factory {
+-keepclasseswithmembers class com.google.android.exoplayer2.source.dash.DashMediaSource$Factory {
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  ** setStreamKeys(java.util.List);
   com.google.android.exoplayer2.source.dash.DashMediaSource createMediaSource(android.net.Uri);
 }
 -dontnote com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory
--keepclassmembers class com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory {
+-keepclasseswithmembers class com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory {
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  ** setStreamKeys(java.util.List);
   com.google.android.exoplayer2.source.hls.HlsMediaSource createMediaSource(android.net.Uri);
 }
 -dontnote com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory
--keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory {
+-keepclasseswithmembers class com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory {
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  ** setStreamKeys(java.util.List);
   com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource createMediaSource(android.net.Uri);
 }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 04a90b38d8..0120451bc1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -146,8 +146,8 @@ private C() {}
    * {@link #ENCODING_INVALID}, {@link #ENCODING_PCM_8BIT}, {@link #ENCODING_PCM_16BIT}, {@link
    * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
    * #ENCODING_PCM_MU_LAW}, {@link #ENCODING_PCM_A_LAW}, {@link #ENCODING_AC3}, {@link
-   * #ENCODING_E_AC3}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or
-   * {@link #ENCODING_DOLBY_TRUEHD}.
+   * #ENCODING_E_AC3}, {@link #ENCODING_E_AC3_JOC}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS},
+   * {@link #ENCODING_DTS_HD} or {@link #ENCODING_DOLBY_TRUEHD}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -163,6 +163,7 @@ private C() {}
     ENCODING_PCM_A_LAW,
     ENCODING_AC3,
     ENCODING_E_AC3,
+    ENCODING_E_AC3_JOC,
     ENCODING_AC4,
     ENCODING_DTS,
     ENCODING_DTS_HD,
@@ -210,6 +211,8 @@ private C() {}
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
   /** @see AudioFormat#ENCODING_E_AC3 */
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+  /** @see AudioFormat#ENCODING_E_AC3_JOC */
+  public static final int ENCODING_E_AC3_JOC = AudioFormat.ENCODING_E_AC3_JOC;
   /** @see AudioFormat#ENCODING_AC4 */
   public static final int ENCODING_AC4 = AudioFormat.ENCODING_AC4;
   /** @see AudioFormat#ENCODING_DTS */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 2a977f5bba..490d961396 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.audio.DefaultAudioSink;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -90,6 +91,7 @@
   @ExtensionRendererMode private int extensionRendererMode;
   private long allowedVideoJoiningTimeMs;
   private boolean playClearSamplesWithoutKeys;
+  private boolean enableDecoderFallback;
   private MediaCodecSelector mediaCodecSelector;
 
   /** @param context A {@link Context}. */
@@ -202,6 +204,19 @@ public DefaultRenderersFactory setPlayClearSamplesWithoutKeys(
     return this;
   }
 
+  /**
+   * Sets whether to enable fallback to lower-priority decoders if decoder initialization fails.
+   * This may result in using a decoder that is less efficient or slower than the primary decoder.
+   *
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setEnableDecoderFallback(boolean enableDecoderFallback) {
+    this.enableDecoderFallback = enableDecoderFallback;
+    return this;
+  }
+
   /**
    * Sets a {@link MediaCodecSelector} for use by {@link MediaCodec} based renderers.
    *
@@ -248,6 +263,7 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         eventHandler,
         videoRendererEventListener,
         allowedVideoJoiningTimeMs,
@@ -258,6 +274,7 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         buildAudioProcessors(),
         eventHandler,
         audioRendererEventListener,
@@ -282,6 +299,9 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
    * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
    *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
    *     the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
    * @param eventHandler A handler associated with the main thread's looper.
    * @param eventListener An event listener.
    * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
@@ -294,6 +314,7 @@ protected void buildVideoRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
       long allowedVideoJoiningTimeMs,
@@ -305,6 +326,7 @@ protected void buildVideoRenderers(
             allowedVideoJoiningTimeMs,
             drmSessionManager,
             playClearSamplesWithoutKeys,
+            enableDecoderFallback,
             eventHandler,
             eventListener,
             MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
@@ -356,6 +378,9 @@ protected void buildVideoRenderers(
    * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
    *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
    *     the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
    * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
    *     before output. May be empty.
    * @param eventHandler A handler to use when invoking event listeners and outputs.
@@ -368,6 +393,7 @@ protected void buildAudioRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       AudioProcessor[] audioProcessors,
       Handler eventHandler,
       AudioRendererEventListener eventListener,
@@ -378,10 +404,10 @@ protected void buildAudioRenderers(
             mediaCodecSelector,
             drmSessionManager,
             playClearSamplesWithoutKeys,
+            enableDecoderFallback,
             eventHandler,
             eventListener,
-            AudioCapabilities.getCapabilities(context),
-            audioProcessors));
+            new DefaultAudioSink(AudioCapabilities.getCapabilities(context), audioProcessors)));
 
     if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
       return;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 15deb8ea47..c004058082 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -510,7 +510,7 @@ public long getBufferedPosition() {
 
   @Override
   public long getTotalBufferedDuration() {
-    return Math.max(0, C.usToMs(playbackInfo.totalBufferedDurationUs));
+    return C.usToMs(playbackInfo.totalBufferedDurationUs);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 37774bccb5..a9fe73371a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -729,13 +729,20 @@ private long seekToPeriodPosition(
       newPlayingPeriodHolder = queue.advancePlayingPeriod();
     }
 
-    // Disable all the renderers if the period being played is changing, or if forced.
-    if (oldPlayingPeriodHolder != newPlayingPeriodHolder || forceDisableRenderers) {
+    // Disable all renderers if the period being played is changing, if the seek results in negative
+    // renderer timestamps, or if forced.
+    if (forceDisableRenderers
+        || oldPlayingPeriodHolder != newPlayingPeriodHolder
+        || (newPlayingPeriodHolder != null
+            && newPlayingPeriodHolder.toRendererTime(periodPositionUs) < 0)) {
       for (Renderer renderer : enabledRenderers) {
         disableRenderer(renderer);
       }
       enabledRenderers = new Renderer[0];
       oldPlayingPeriodHolder = null;
+      if (newPlayingPeriodHolder != null) {
+        newPlayingPeriodHolder.setRendererOffset(/* rendererPositionOffsetUs= */ 0);
+      }
     }
 
     // Update the holders.
@@ -1053,11 +1060,14 @@ private void maybeTriggerPendingMessages(long oldPeriodPositionUs, long newPerio
         && nextInfo.resolvedPeriodIndex == currentPeriodIndex
         && nextInfo.resolvedPeriodTimeUs > oldPeriodPositionUs
         && nextInfo.resolvedPeriodTimeUs <= newPeriodPositionUs) {
-      sendMessageToTarget(nextInfo.message);
-      if (nextInfo.message.getDeleteAfterDelivery() || nextInfo.message.isCanceled()) {
-        pendingMessages.remove(nextPendingMessageIndex);
-      } else {
-        nextPendingMessageIndex++;
+      try {
+        sendMessageToTarget(nextInfo.message);
+      } finally {
+        if (nextInfo.message.getDeleteAfterDelivery() || nextInfo.message.isCanceled()) {
+          pendingMessages.remove(nextPendingMessageIndex);
+        } else {
+          nextPendingMessageIndex++;
+        }
       }
       nextInfo =
           nextPendingMessageIndex < pendingMessages.size()
@@ -1795,9 +1805,12 @@ private long getTotalBufferedDurationUs() {
 
   private long getTotalBufferedDurationUs(long bufferedPositionInLoadingPeriodUs) {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    return loadingPeriodHolder == null
-        ? 0
-        : bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    if (loadingPeriodHolder == null) {
+      return 0;
+    }
+    long totalBufferedDurationUs =
+        bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    return Math.max(0, totalBufferedDurationUs);
   }
 
   private void updateLoadControlTrackSelection(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 72760db31b..190f4de5a6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.10.0";
+  public static final String VERSION = "2.10.3";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.0";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.3";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2010000;
+  public static final int VERSION_INT = 2010003;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 5950bc627f..a21afc4b51 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -67,8 +67,7 @@
    * Creates a new holder with information required to play it as part of a timeline.
    *
    * @param rendererCapabilities The renderer capabilities.
-   * @param rendererPositionOffsetUs The time offset of the start of the media period to provide to
-   *     renderers.
+   * @param rendererPositionOffsetUs The renderer time of the start of the period, in microseconds.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
    * @param mediaSource The media source that produced the media period.
@@ -82,7 +81,7 @@ public MediaPeriodHolder(
       MediaSource mediaSource,
       MediaPeriodInfo info) {
     this.rendererCapabilities = rendererCapabilities;
-    this.rendererPositionOffsetUs = rendererPositionOffsetUs - info.startPositionUs;
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs;
     this.trackSelector = trackSelector;
     this.mediaSource = mediaSource;
     this.uid = info.id.periodUid;
@@ -115,6 +114,15 @@ public long getRendererOffset() {
     return rendererPositionOffsetUs;
   }
 
+  /**
+   * Sets the renderer time of the start of the period, in microseconds.
+   *
+   * @param rendererPositionOffsetUs The new renderer position offset, in microseconds.
+   */
+  public void setRendererOffset(long rendererPositionOffsetUs) {
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs;
+  }
+
   /** Returns start position of period in renderer time. */
   public long getStartPositionRendererTime() {
     return info.startPositionUs + rendererPositionOffsetUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 249548340e..86fa5e11ee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -144,8 +144,8 @@ public MediaPeriod enqueueNextMediaPeriod(
       MediaPeriodInfo info) {
     long rendererPositionOffsetUs =
         loading == null
-            ? info.startPositionUs
-            : (loading.getRendererOffset() + loading.info.durationUs);
+            ? (info.id.isAd() ? info.contentPositionUs : 0)
+            : (loading.getRendererOffset() + loading.info.durationUs - info.startPositionUs);
     MediaPeriodHolder newPeriodHolder =
         new MediaPeriodHolder(
             rendererCapabilities,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 910404a875..f1b6b5bc90 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -1231,8 +1231,7 @@ private void verifyApplicationThread() {
       Log.w(
           TAG,
           "Player is accessed on the wrong thread. See "
-              + "https://exoplayer.dev/faqs.html#"
-              + "what-do-player-is-accessed-on-the-wrong-thread-warnings-mean",
+              + "https://exoplayer.dev/issues/player-accessed-on-wrong-thread",
           hasNotifiedFullWrongThreadWarning ? null : new IllegalStateException());
       hasNotifiedFullWrongThreadWarning = true;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
index 7f74216cc8..3400cf25b6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
@@ -59,7 +59,7 @@
     public final Timeline timeline;
 
     /**
-     * Window index in the {@code timeline} this event belongs to, or the prospective window index
+     * Window index in the {@link #timeline} this event belongs to, or the prospective window index
      * if the timeline is not yet known and empty.
      */
     public final int windowIndex;
@@ -76,7 +76,7 @@
     public final long eventPlaybackPositionMs;
 
     /**
-     * Position in the current timeline window ({@code timeline.getCurrentWindowIndex()} or the
+     * Position in the current timeline window ({@link Player#getCurrentWindowIndex()}) or the
      * currently playing ad at the time of the event, in milliseconds.
      */
     public final long currentPlaybackPositionMs;
@@ -91,15 +91,15 @@
      * @param realtimeMs Elapsed real-time as returned by {@code SystemClock.elapsedRealtime()} at
      *     the time of the event, in milliseconds.
      * @param timeline Timeline at the time of the event.
-     * @param windowIndex Window index in the {@code timeline} this event belongs to, or the
+     * @param windowIndex Window index in the {@link #timeline} this event belongs to, or the
      *     prospective window index if the timeline is not yet known and empty.
      * @param mediaPeriodId Media period identifier for the media period this event belongs to, or
      *     {@code null} if the event is not associated with a specific media period.
      * @param eventPlaybackPositionMs Position in the window or ad this event belongs to at the time
      *     of the event, in milliseconds.
-     * @param currentPlaybackPositionMs Position in the current timeline window ({@code
-     *     timeline.getCurrentWindowIndex()} or the currently playing ad at the time of the event,
-     *     in milliseconds.
+     * @param currentPlaybackPositionMs Position in the current timeline window ({@link
+     *     Player#getCurrentWindowIndex()}) or the currently playing ad at the time of the event, in
+     *     milliseconds.
      * @param totalBufferedDurationMs Total buffered duration from {@link
      *     #currentPlaybackPositionMs} at the time of the event, in milliseconds. This includes
      *     pre-buffered data for subsequent ads and windows.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index ffcd893e7b..be1b7d3d53 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -272,6 +272,7 @@ public long getSkippedOutputFrameCount() {
   private int preV21OutputBufferOffset;
   private int drainingAudioProcessorIndex;
   private boolean handledEndOfStream;
+  private boolean stoppedAudioTrack;
 
   private boolean playing;
   private int audioSessionId;
@@ -465,19 +466,15 @@ public void configure(
             processingEnabled,
             canApplyPlaybackParameters,
             availableAudioProcessors);
-    if (isInitialized()) {
-      if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
-        // We need a new AudioTrack before we can handle more input. We should first stop() the
-        // track and wait for audio to play out (tracked by [Internal: b/33161961]), but for now we
-        // discard the audio track immediately.
-        flush();
-      } else if (flushAudioProcessors) {
-        // We don't need a new AudioTrack but audio processors need to be drained and flushed.
-        this.pendingConfiguration = pendingConfiguration;
-        return;
-      }
+    // If we have a pending configuration already, we always drain audio processors as the preceding
+    // configuration may have required it (even if this one doesn't).
+    boolean drainAudioProcessors = flushAudioProcessors || this.pendingConfiguration != null;
+    if (isInitialized()
+        && (!pendingConfiguration.canReuseAudioTrack(configuration) || drainAudioProcessors)) {
+      this.pendingConfiguration = pendingConfiguration;
+    } else {
+      configuration = pendingConfiguration;
     }
-    configuration = pendingConfiguration;
   }
 
   private void setupAudioProcessors() {
@@ -504,7 +501,7 @@ private void flushAudioProcessors() {
     }
   }
 
-  private void initialize() throws InitializationException {
+  private void initialize(long presentationTimeUs) throws InitializationException {
     // If we're asynchronously releasing a previous audio track then we block until it has been
     // released. This guarantees that we cannot end up in a state where we have multiple audio
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
@@ -536,11 +533,7 @@ private void initialize() throws InitializationException {
       }
     }
 
-    playbackParameters =
-        configuration.canApplyPlaybackParameters
-            ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
-            : PlaybackParameters.DEFAULT;
-    setupAudioProcessors();
+    applyPlaybackParameters(playbackParameters, presentationTimeUs);
 
     audioTrackPositionTracker.setAudioTrack(
         audioTrack,
@@ -579,21 +572,27 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
     Assertions.checkArgument(inputBuffer == null || buffer == inputBuffer);
 
     if (pendingConfiguration != null) {
-      // We are waiting for audio processors to drain before applying a the new configuration.
       if (!drainAudioProcessorsToEndOfStream()) {
+        // There's still pending data in audio processors to write to the track.
         return false;
+      } else if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
+        playPendingData();
+        if (hasPendingData()) {
+          // We're waiting for playout on the current audio track to finish.
+          return false;
+        }
+        flush();
+      } else {
+        // The current audio track can be reused for the new configuration.
+        configuration = pendingConfiguration;
+        pendingConfiguration = null;
       }
-      configuration = pendingConfiguration;
-      pendingConfiguration = null;
-      playbackParameters =
-          configuration.canApplyPlaybackParameters
-              ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
-              : PlaybackParameters.DEFAULT;
-      setupAudioProcessors();
+      // Re-apply playback parameters.
+      applyPlaybackParameters(playbackParameters, presentationTimeUs);
     }
 
     if (!isInitialized()) {
-      initialize();
+      initialize(presentationTimeUs);
       if (playing) {
         play();
       }
@@ -629,15 +628,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         }
         PlaybackParameters newPlaybackParameters = afterDrainPlaybackParameters;
         afterDrainPlaybackParameters = null;
-        newPlaybackParameters = audioProcessorChain.applyPlaybackParameters(newPlaybackParameters);
-        // Store the position and corresponding media time from which the parameters will apply.
-        playbackParametersCheckpoints.add(
-            new PlaybackParametersCheckpoint(
-                newPlaybackParameters,
-                Math.max(0, presentationTimeUs),
-                configuration.framesToDurationUs(getWrittenFrames())));
-        // Update the set of active audio processors to take into account the new parameters.
-        setupAudioProcessors();
+        applyPlaybackParameters(newPlaybackParameters, presentationTimeUs);
       }
 
       if (startMediaTimeState == START_NOT_SET) {
@@ -786,15 +777,8 @@ private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throw
 
   @Override
   public void playToEndOfStream() throws WriteException {
-    if (handledEndOfStream || !isInitialized()) {
-      return;
-    }
-
-    if (drainAudioProcessorsToEndOfStream()) {
-      // The audio processors have drained, so drain the underlying audio track.
-      audioTrackPositionTracker.handleEndOfStream(getWrittenFrames());
-      audioTrack.stop();
-      bytesUntilNextAvSync = 0;
+    if (!handledEndOfStream && isInitialized() && drainAudioProcessorsToEndOfStream()) {
+      playPendingData();
       handledEndOfStream = true;
     }
   }
@@ -858,8 +842,9 @@ public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParam
         // parameters apply.
         afterDrainPlaybackParameters = playbackParameters;
       } else {
-        // Update the playback parameters now.
-        this.playbackParameters = audioProcessorChain.applyPlaybackParameters(playbackParameters);
+        // Update the playback parameters now. They will be applied to the audio processors during
+        // initialization.
+        this.playbackParameters = playbackParameters;
       }
     }
     return this.playbackParameters;
@@ -976,6 +961,7 @@ public void flush() {
       flushAudioProcessors();
       inputBuffer = null;
       outputBuffer = null;
+      stoppedAudioTrack = false;
       handledEndOfStream = false;
       drainingAudioProcessorIndex = C.INDEX_UNSET;
       avSyncHeader = null;
@@ -1040,6 +1026,21 @@ public void run() {
     }.start();
   }
 
+  private void applyPlaybackParameters(
+      PlaybackParameters playbackParameters, long presentationTimeUs) {
+    PlaybackParameters newPlaybackParameters =
+        configuration.canApplyPlaybackParameters
+            ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
+            : PlaybackParameters.DEFAULT;
+    // Store the position and corresponding media time from which the parameters will apply.
+    playbackParametersCheckpoints.add(
+        new PlaybackParametersCheckpoint(
+            newPlaybackParameters,
+            /* mediaTimeUs= */ Math.max(0, presentationTimeUs),
+            /* positionUs= */ configuration.framesToDurationUs(getWrittenFrames())));
+    setupAudioProcessors();
+  }
+
   private long applySpeedup(long positionUs) {
     @Nullable PlaybackParametersCheckpoint checkpoint = null;
     while (!playbackParametersCheckpoints.isEmpty()
@@ -1125,6 +1126,7 @@ private static int getMaximumEncodedRateBytesPerSecond(@C.Encoding int encoding)
       case C.ENCODING_AC3:
         return 640 * 1000 / 8;
       case C.ENCODING_E_AC3:
+      case C.ENCODING_E_AC3_JOC:
         return 6144 * 1000 / 8;
       case C.ENCODING_AC4:
         return 2688 * 1000 / 8;
@@ -1154,7 +1156,7 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
       return DtsUtil.parseDtsAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC3) {
       return Ac3Util.getAc3SyncframeAudioSampleCount();
-    } else if (encoding == C.ENCODING_E_AC3) {
+    } else if (encoding == C.ENCODING_E_AC3 || encoding == C.ENCODING_E_AC3_JOC) {
       return Ac3Util.parseEAc3SyncframeAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC4) {
       return Ac4Util.parseAc4SyncframeAudioSampleCount(buffer);
@@ -1177,11 +1179,10 @@ private static int writeNonBlockingV21(AudioTrack audioTrack, ByteBuffer buffer,
   @TargetApi(21)
   private int writeNonBlockingWithAvSyncV21(AudioTrack audioTrack, ByteBuffer buffer, int size,
       long presentationTimeUs) {
-    // TODO: Uncomment this when [Internal ref: b/33627517] is clarified or fixed.
-    // if (Util.SDK_INT >= 23) {
-    //   // The underlying platform AudioTrack writes AV sync headers directly.
-    //   return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
-    // }
+    if (Util.SDK_INT >= 26) {
+      // The underlying platform AudioTrack writes AV sync headers directly.
+      return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
+    }
     if (avSyncHeader == null) {
       avSyncHeader = ByteBuffer.allocate(16);
       avSyncHeader.order(ByteOrder.BIG_ENDIAN);
@@ -1223,6 +1224,15 @@ private static void setVolumeInternalV3(AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
+  private void playPendingData() {
+    if (!stoppedAudioTrack) {
+      stoppedAudioTrack = true;
+      audioTrackPositionTracker.handleEndOfStream(getWrittenFrames());
+      audioTrack.stop();
+      bytesUntilNextAvSync = 0;
+    }
+  }
+
   /** Stores playback parameters with the position and media time at which they apply. */
   private static final class PlaybackParametersCheckpoint {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 07769e7d85..ace7ebbcc6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -245,12 +245,50 @@ public MediaCodecAudioRenderer(
       @Nullable Handler eventHandler,
       @Nullable AudioRendererEventListener eventListener,
       AudioSink audioSink) {
+    this(
+        context,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        /* enableDecoderFallback= */ false,
+        eventHandler,
+        eventListener,
+        audioSink);
+  }
+
+  /**
+   * @param context A context.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
+   *     content is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioSink The sink to which audio will be output.
+   */
+  public MediaCodecAudioRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      AudioSink audioSink) {
     super(
         C.TRACK_TYPE_AUDIO,
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
-        /* enableDecoderFallback= */ false,
+        enableDecoderFallback,
         /* assumedMinimumCodecOperatingRate= */ 44100);
     this.context = context.getApplicationContext();
     this.audioSink = audioSink;
@@ -341,7 +379,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @return Whether passthrough playback is supported.
    */
   protected boolean allowPassthrough(int channelCount, String mimeType) {
-    return audioSink.supportsOutput(channelCount, MimeTypes.getEncoding(mimeType));
+    return getPassthroughEncoding(channelCount, mimeType) != C.ENCODING_INVALID;
   }
 
   @Override
@@ -437,11 +475,14 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     @C.Encoding int encoding;
     MediaFormat format;
     if (passthroughMediaFormat != null) {
-      encoding = MimeTypes.getEncoding(passthroughMediaFormat.getString(MediaFormat.KEY_MIME));
       format = passthroughMediaFormat;
+      encoding =
+          getPassthroughEncoding(
+              format.getInteger(MediaFormat.KEY_CHANNEL_COUNT),
+              format.getString(MediaFormat.KEY_MIME));
     } else {
-      encoding = pcmEncoding;
       format = outputFormat;
+      encoding = pcmEncoding;
     }
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
@@ -463,6 +504,28 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     }
   }
 
+  /**
+   * Returns the {@link C.Encoding} constant to use for passthrough of the given format, or {@link
+   * C#ENCODING_INVALID} if passthrough is not possible.
+   */
+  @C.Encoding
+  protected int getPassthroughEncoding(int channelCount, String mimeType) {
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
+      if (audioSink.supportsOutput(channelCount, C.ENCODING_E_AC3_JOC)) {
+        return MimeTypes.getEncoding(MimeTypes.AUDIO_E_AC3_JOC);
+      }
+      // E-AC3 receivers can decode JOC streams, but in 2-D rather than 3-D, so try to fall back.
+      mimeType = MimeTypes.AUDIO_E_AC3;
+    }
+
+    @C.Encoding int encoding = MimeTypes.getEncoding(mimeType);
+    if (audioSink.supportsOutput(channelCount, encoding)) {
+      return encoding;
+    } else {
+      return C.ENCODING_INVALID;
+    }
+  }
+
   /**
    * Called when the audio session id becomes known. The default implementation is a no-op. One
    * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
@@ -632,7 +695,8 @@ protected boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException {
     if (codecNeedsEosBufferTimestampWorkaround
@@ -648,7 +712,7 @@ protected boolean processOutputBuffer(
       return true;
     }
 
-    if (shouldSkip) {
+    if (isDecodeOnlyBuffer) {
       codec.releaseOutputBuffer(bufferIndex, false);
       decoderCounters.skippedOutputBufferCount++;
       audioSink.handleDiscontinuity();
@@ -786,7 +850,7 @@ protected MediaFormat getMediaFormat(
     // Set codec configuration values.
     if (Util.SDK_INT >= 23) {
       mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 /* realtime priority */);
-      if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET) {
+      if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET && !deviceDoesntSupportOperatingRate()) {
         mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
       }
     }
@@ -809,6 +873,17 @@ private void updateCurrentPosition() {
     }
   }
 
+  /**
+   * Returns whether the device's decoders are known to not support setting the codec operating
+   * rate.
+   *
+   * <p>See <a href="https://github.com/google/ExoPlayer/issues/5821">GitHub issue #5821</a>.
+   */
+  private static boolean deviceDoesntSupportOperatingRate() {
+    return Util.SDK_INT == 23
+        && ("ZTE B2017G".equals(Util.MODEL) || "AXON 7 mini".equals(Util.MODEL));
+  }
+
   /**
    * Returns whether the decoder is known to output six audio channels when provided with input with
    * fewer than six channels.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 3820836e49..fb684f627f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -544,7 +544,7 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(
         ExoMediaDrm<? extends T> md,
-        byte[] sessionId,
+        @Nullable byte[] sessionId,
         int event,
         int extra,
         @Nullable byte[] data) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
index 49915f3af5..6bd8d9688f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
@@ -80,7 +80,7 @@
      */
     void onEvent(
         ExoMediaDrm<? extends T> mediaDrm,
-        byte[] sessionId,
+        @Nullable byte[] sessionId,
         int event,
         int extra,
         @Nullable byte[] data);
@@ -215,6 +215,7 @@ KeyRequest getKeyRequest(
       throws NotProvisionedException;
 
   /** @see MediaDrm#provideKeyResponse(byte[], byte[]) */
+  @Nullable
   byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index 615aa0e7b1..2cb7e66a2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -84,8 +84,6 @@ private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
     }
   }
 
-  // FIXME: incompatible types in argument.
-  @SuppressWarnings("nullness:argument.type.incompatible")
   @Override
   public void setOnEventListener(
       final ExoMediaDrm.OnEventListener<? super FrameworkMediaCrypto> listener) {
@@ -160,8 +158,7 @@ public KeyRequest getKeyRequest(
     return new KeyRequest(requestData, licenseServerUrl);
   }
 
-  // FIXME: incompatible types in return.
-  @SuppressWarnings("nullness:return.type.incompatible")
+  @Nullable
   @Override
   public byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
index ec5ad88aeb..b10f2bf80b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
@@ -86,11 +86,12 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     if (audioFormat == AUDIO_FORMAT_MP3) {
       int sampleSize = data.bytesLeft();
       output.sampleData(data, sampleSize);
       output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+      return true;
     } else {
       int packetType = data.readUnsignedByte();
       if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
@@ -104,12 +105,15 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
             Collections.singletonList(audioSpecificConfig), null, 0, null);
         output.format(format);
         hasOutputFormat = true;
+        return false;
       } else if (audioFormat != AUDIO_FORMAT_AAC || packetType == AAC_PACKET_TYPE_AAC_RAW) {
         int sampleSize = data.bytesLeft();
         output.sampleData(data, sampleSize);
         output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+        return true;
+      } else {
+        return false;
       }
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 0a2c0c46f6..de6ed2710a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -74,6 +74,7 @@
 
   private ExtractorOutput extractorOutput;
   private @States int state;
+  private boolean outputFirstSample;
   private long mediaTagTimestampOffsetUs;
   private int bytesToNextTagHeader;
   private int tagType;
@@ -90,7 +91,6 @@ public FlvExtractor() {
     tagData = new ParsableByteArray();
     metadataReader = new ScriptTagPayloadReader();
     state = STATE_READING_FLV_HEADER;
-    mediaTagTimestampOffsetUs = C.TIME_UNSET;
   }
 
   @Override
@@ -132,7 +132,7 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek(long position, long timeUs) {
     state = STATE_READING_FLV_HEADER;
-    mediaTagTimestampOffsetUs = C.TIME_UNSET;
+    outputFirstSample = false;
     bytesToNextTagHeader = 0;
   }
 
@@ -253,14 +253,16 @@ private boolean readTagHeader(ExtractorInput input) throws IOException, Interrup
    */
   private boolean readTagData(ExtractorInput input) throws IOException, InterruptedException {
     boolean wasConsumed = true;
+    boolean wasSampleOutput = false;
+    long timestampUs = getCurrentTimestampUs();
     if (tagType == TAG_TYPE_AUDIO && audioReader != null) {
       ensureReadyForMediaOutput();
-      audioReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+      wasSampleOutput = audioReader.consume(prepareTagData(input), timestampUs);
     } else if (tagType == TAG_TYPE_VIDEO && videoReader != null) {
       ensureReadyForMediaOutput();
-      videoReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+      wasSampleOutput = videoReader.consume(prepareTagData(input), timestampUs);
     } else if (tagType == TAG_TYPE_SCRIPT_DATA && !outputSeekMap) {
-      metadataReader.consume(prepareTagData(input), tagTimestampUs);
+      wasSampleOutput = metadataReader.consume(prepareTagData(input), timestampUs);
       long durationUs = metadataReader.getDurationUs();
       if (durationUs != C.TIME_UNSET) {
         extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
@@ -270,6 +272,11 @@ private boolean readTagData(ExtractorInput input) throws IOException, Interrupte
       input.skipFully(tagDataSize);
       wasConsumed = false;
     }
+    if (!outputFirstSample && wasSampleOutput) {
+      outputFirstSample = true;
+      mediaTagTimestampOffsetUs =
+          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
+    }
     bytesToNextTagHeader = 4; // There's a 4 byte previous tag size before the next header.
     state = STATE_SKIPPING_TO_TAG_HEADER;
     return wasConsumed;
@@ -292,10 +299,11 @@ private void ensureReadyForMediaOutput() {
       extractorOutput.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
       outputSeekMap = true;
     }
-    if (mediaTagTimestampOffsetUs == C.TIME_UNSET) {
-      mediaTagTimestampOffsetUs =
-          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
-    }
   }
 
+  private long getCurrentTimestampUs() {
+    return outputFirstSample
+        ? (mediaTagTimestampOffsetUs + tagTimestampUs)
+        : (metadataReader.getDurationUs() == C.TIME_UNSET ? 0 : tagTimestampUs);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
index 2dec85ffcc..eb1cc8f336 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
@@ -63,7 +63,7 @@ protected boolean parseHeader(ParsableByteArray data) {
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int nameType = readAmfType(data);
     if (nameType != AMF_TYPE_STRING) {
       // Should never happen.
@@ -72,12 +72,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
     String name = readAmfString(data);
     if (!NAME_METADATA.equals(name)) {
       // We're only interested in metadata.
-      return;
+      return false;
     }
     int type = readAmfType(data);
     if (type != AMF_TYPE_ECMA_ARRAY) {
       // We're not interested in this metadata.
-      return;
+      return false;
     }
     // Set the duration to the value contained in the metadata, if present.
     Map<String, Object> metadata = readAmfEcmaArray(data);
@@ -87,6 +87,7 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
         durationUs = (long) (durationSeconds * C.MICROS_PER_SECOND);
       }
     }
+    return false;
   }
 
   private static int readAmfType(ParsableByteArray data) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java
index e8652d653f..48914b7c2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java
@@ -58,12 +58,11 @@ protected TagPayloadReader(TrackOutput output) {
    *
    * @param data The payload data to consume.
    * @param timeUs The timestamp associated with the payload.
+   * @return Whether a sample was output.
    * @throws ParserException If an error occurs parsing the data.
    */
-  public final void consume(ParsableByteArray data, long timeUs) throws ParserException {
-    if (parseHeader(data)) {
-      parsePayload(data, timeUs);
-    }
+  public final boolean consume(ParsableByteArray data, long timeUs) throws ParserException {
+    return parseHeader(data) && parsePayload(data, timeUs);
   }
 
   /**
@@ -78,10 +77,11 @@ public final void consume(ParsableByteArray data, long timeUs) throws ParserExce
   /**
    * Parses tag payload.
    *
-   * @param data Buffer where tag payload is stored
-   * @param timeUs Time position of the frame
+   * @param data Buffer where tag payload is stored.
+   * @param timeUs Time position of the frame.
+   * @return Whether a sample was output.
    * @throws ParserException If an error occurs parsing the payload.
    */
-  protected abstract void parsePayload(ParsableByteArray data, long timeUs) throws ParserException;
-
+  protected abstract boolean parsePayload(ParsableByteArray data, long timeUs)
+      throws ParserException;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
index 92db91e20b..5ddaafb4a8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
@@ -47,6 +47,7 @@
 
   // State variables.
   private boolean hasOutputFormat;
+  private boolean hasOutputKeyframe;
   private int frameType;
 
   /**
@@ -60,7 +61,7 @@ public VideoTagPayloadReader(TrackOutput output) {
 
   @Override
   public void seek() {
-    // Do nothing.
+    hasOutputKeyframe = false;
   }
 
   @Override
@@ -77,7 +78,7 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int packetType = data.readUnsignedByte();
     int compositionTimeMs = data.readInt24();
 
@@ -94,7 +95,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
           avcConfig.initializationData, Format.NO_VALUE, avcConfig.pixelWidthAspectRatio, null);
       output.format(format);
       hasOutputFormat = true;
+      return false;
     } else if (packetType == AVC_PACKET_TYPE_AVC_NALU && hasOutputFormat) {
+      boolean isKeyframe = frameType == VIDEO_FRAME_KEYFRAME;
+      if (!hasOutputKeyframe && !isKeyframe) {
+        return false;
+      }
       // TODO: Deduplicate with Mp4Extractor.
       // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
       // they're only 1 or 2 bytes long.
@@ -123,8 +129,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
         output.sampleData(data, bytesToWrite);
         bytesWritten += bytesToWrite;
       }
-      output.sampleMetadata(timeUs, frameType == VIDEO_FRAME_KEYFRAME ? C.BUFFER_FLAG_KEY_FRAME : 0,
-          bytesWritten, 0, null);
+      output.sampleMetadata(
+          timeUs, isKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0, bytesWritten, 0, null);
+      hasOutputKeyframe = true;
+      return true;
+    } else {
+      return false;
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 0185a6d8af..6fb0ac6856 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -60,7 +60,7 @@
    * The threshold number of samples to trim from the start/end of an audio track when applying an
    * edit below which gapless info can be used (rather than removing samples from the sample table).
    */
-  private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 3;
+  private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 4;
 
   /** The magic signature for an Opus Identification header, as defined in RFC-7845. */
   private static final byte[] opusMagic = Util.getUtf8Bytes("OpusHead");
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 08ba94f257..2158f182b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -518,9 +518,15 @@ private static boolean isSecureV21(CodecCapabilities capabilities) {
   @TargetApi(21)
   private static boolean areSizeAndRateSupportedV21(VideoCapabilities capabilities, int width,
       int height, double frameRate) {
-    return frameRate == Format.NO_VALUE || frameRate <= 0
-        ? capabilities.isSizeSupported(width, height)
-        : capabilities.areSizeAndRateSupported(width, height, frameRate);
+    if (frameRate == Format.NO_VALUE || frameRate <= 0) {
+      return capabilities.isSizeSupported(width, height);
+    } else {
+      // The signaled frame rate may be slightly higher than the actual frame rate, so we take the
+      // floor to avoid situations where a range check in areSizeAndRateSupported fails due to
+      // slightly exceeding the limits for a standard format (e.g., 1080p at 30 fps).
+      double floorFrameRate = Math.floor(frameRate);
+      return capabilities.areSizeAndRateSupported(width, height, floorFrameRate);
+    }
   }
 
   @TargetApi(23)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index f7855810d4..c3072a1590 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -53,7 +53,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -329,14 +328,16 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private int inputIndex;
   private int outputIndex;
   private ByteBuffer outputBuffer;
-  private boolean shouldSkipOutputBuffer;
+  private boolean isDecodeOnlyOutputBuffer;
+  private boolean isLastOutputBuffer;
   private boolean codecReconfigured;
   @ReconfigurationState private int codecReconfigurationState;
   @DrainState private int codecDrainState;
   @DrainAction private int codecDrainAction;
   private boolean codecReceivedBuffers;
   private boolean codecReceivedEos;
-
+  private long lastBufferInStreamPresentationTimeUs;
+  private long largestQueuedPresentationTimeUs;
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
@@ -454,15 +455,13 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
   protected abstract void configureCodec(
       MediaCodecInfo codecInfo,
       MediaCodec codec,
       Format format,
       MediaCrypto crypto,
-      float codecOperatingRate)
-      throws DecoderQueryException;
+      float codecOperatingRate);
 
   protected final void maybeInitCodec() throws ExoPlaybackException {
     if (codec != null || inputFormat == null) {
@@ -601,6 +600,8 @@ protected void releaseCodec() {
     waitingForKeys = false;
     codecHotswapDeadlineMs = C.TIME_UNSET;
     decodeOnlyPresentationTimestamps.clear();
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     try {
       if (codec != null) {
         decoderCounters.decoderReleaseCount++;
@@ -707,10 +708,13 @@ protected boolean flushOrReleaseCodec() {
     waitingForFirstSyncSample = true;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    shouldSkipOutputBuffer = false;
+    isDecodeOnlyOutputBuffer = false;
+    isLastOutputBuffer = false;
 
     waitingForKeys = false;
     decodeOnlyPresentationTimestamps.clear();
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     codecDrainState = DRAIN_STATE_NONE;
     codecDrainAction = DRAIN_ACTION_NONE;
     // Reconfiguration data sent shortly before the flush may not have been processed by the
@@ -742,11 +746,11 @@ private void maybeInitCodecWithFallback(
       try {
         List<MediaCodecInfo> allAvailableCodecInfos =
             getAvailableCodecInfos(mediaCryptoRequiresSecureDecoder);
+        availableCodecInfos = new ArrayDeque<>();
         if (enableDecoderFallback) {
-          availableCodecInfos = new ArrayDeque<>(allAvailableCodecInfos);
-        } else {
-          availableCodecInfos =
-              new ArrayDeque<>(Collections.singletonList(allAvailableCodecInfos.get(0)));
+          availableCodecInfos.addAll(allAvailableCodecInfos);
+        } else if (!allAvailableCodecInfos.isEmpty()) {
+          availableCodecInfos.add(allAvailableCodecInfos.get(0));
         }
         preferredDecoderInitializationException = null;
       } catch (DecoderQueryException e) {
@@ -884,7 +888,8 @@ private void initCodec(MediaCodecInfo codecInfo, MediaCrypto crypto) throws Exce
     codecDrainAction = DRAIN_ACTION_NONE;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    shouldSkipOutputBuffer = false;
+    isDecodeOnlyOutputBuffer = false;
+    isLastOutputBuffer = false;
     waitingForFirstSyncSample = true;
 
     decoderCounters.decoderInitCount++;
@@ -1019,6 +1024,11 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       result = readSource(formatHolder, buffer, false);
     }
 
+    if (hasReadStreamToEnd()) {
+      // Notify output queue of the last buffer's timestamp.
+      lastBufferInStreamPresentationTimeUs = largestQueuedPresentationTimeUs;
+    }
+
     if (result == C.RESULT_NOTHING_READ) {
       return false;
     }
@@ -1091,6 +1101,8 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         formatQueue.add(presentationTimeUs, inputFormat);
         waitingForFirstSampleInFormat = false;
       }
+      largestQueuedPresentationTimeUs =
+          Math.max(largestQueuedPresentationTimeUs, presentationTimeUs);
 
       buffer.flip();
       onQueueInputBuffer(buffer);
@@ -1461,7 +1473,9 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         outputBuffer.position(outputBufferInfo.offset);
         outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);
       }
-      shouldSkipOutputBuffer = shouldSkipOutputBuffer(outputBufferInfo.presentationTimeUs);
+      isDecodeOnlyOutputBuffer = isDecodeOnlyBuffer(outputBufferInfo.presentationTimeUs);
+      isLastOutputBuffer =
+          lastBufferInStreamPresentationTimeUs == outputBufferInfo.presentationTimeUs;
       updateOutputFormatForTime(outputBufferInfo.presentationTimeUs);
     }
 
@@ -1477,7 +1491,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
                 outputIndex,
                 outputBufferInfo.flags,
                 outputBufferInfo.presentationTimeUs,
-                shouldSkipOutputBuffer,
+                isDecodeOnlyOutputBuffer,
+                isLastOutputBuffer,
                 outputFormat);
       } catch (IllegalStateException e) {
         processEndOfStream();
@@ -1497,7 +1512,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
               outputIndex,
               outputBufferInfo.flags,
               outputBufferInfo.presentationTimeUs,
-              shouldSkipOutputBuffer,
+              isDecodeOnlyOutputBuffer,
+              isLastOutputBuffer,
               outputFormat);
     }
 
@@ -1564,7 +1580,9 @@ private void processOutputBuffersChanged() {
    * @param bufferIndex The index of the output buffer.
    * @param bufferFlags The flags attached to the output buffer.
    * @param bufferPresentationTimeUs The presentation time of the output buffer in microseconds.
-   * @param shouldSkip Whether the buffer should be skipped (i.e. not rendered).
+   * @param isDecodeOnlyBuffer Whether the buffer was marked with {@link C#BUFFER_FLAG_DECODE_ONLY}
+   *     by the source.
+   * @param isLastBuffer Whether the buffer is the last sample of the current stream.
    * @param format The format associated with the buffer.
    * @return Whether the output buffer was fully processed (e.g. rendered or skipped).
    * @throws ExoPlaybackException If an error occurs processing the output buffer.
@@ -1577,7 +1595,8 @@ protected abstract boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException;
 
@@ -1657,7 +1676,7 @@ private void updateDrmSessionOrReinitializeCodecV23() throws ExoPlaybackExceptio
     codecDrainAction = DRAIN_ACTION_NONE;
   }
 
-  private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
+  private boolean isDecodeOnlyBuffer(long presentationTimeUs) {
     // We avoid using decodeOnlyPresentationTimestamps.remove(presentationTimeUs) because it would
     // box presentationTimeUs, creating a Long object that would need to be garbage collected.
     int size = decodeOnlyPresentationTimestamps.size();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 3211f7ea8e..374c15eea0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -176,7 +176,7 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boo
       // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
       CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure, key.tunneling);
       ArrayList<MediaCodecInfo> eac3DecoderInfos =
-          getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);
+          getDecoderInfosInternal(eac3Key, mediaCodecList, MimeTypes.AUDIO_E_AC3);
       decoderInfos.addAll(eac3DecoderInfos);
     }
     applyWorkarounds(mimeType, decoderInfos);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
index d04cd3a999..3d873926bb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
@@ -31,7 +31,7 @@
 
   private static final String TAG = "IcyDecoder";
 
-  private static final Pattern METADATA_ELEMENT = Pattern.compile("(.+?)='(.+?)';");
+  private static final Pattern METADATA_ELEMENT = Pattern.compile("(.+?)='(.*?)';", Pattern.DOTALL);
   private static final String STREAM_KEY_NAME = "streamtitle";
   private static final String STREAM_KEY_URL = "streamurl";
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
index 06f308d1e9..ef4bd00f20 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
@@ -233,6 +233,19 @@ public void setDownloadingStatesToQueued() throws DatabaseIOException {
     }
   }
 
+  @Override
+  public void setStatesToRemoving() throws DatabaseIOException {
+    ensureInitialized();
+    try {
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_STATE, Download.STATE_REMOVING);
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.update(tableName, values, /* whereClause= */ null, /* whereArgs= */ null);
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
   @Override
   public void setStopReason(int stopReason) throws DatabaseIOException {
     ensureInitialized();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
index 8a15c82c89..821696aae7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
@@ -20,7 +20,6 @@
 import android.os.HandlerThread;
 import android.os.Message;
 import androidx.annotation.Nullable;
-import android.util.Pair;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -32,6 +31,7 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSource.Factory;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -106,30 +107,13 @@
     void onPrepareError(DownloadHelper helper, IOException e);
   }
 
-  @Nullable private static final Constructor<?> DASH_FACTORY_CONSTRUCTOR;
-  @Nullable private static final Constructor<?> HLS_FACTORY_CONSTRUCTOR;
-  @Nullable private static final Constructor<?> SS_FACTORY_CONSTRUCTOR;
-  @Nullable private static final Method DASH_FACTORY_CREATE_METHOD;
-  @Nullable private static final Method HLS_FACTORY_CREATE_METHOD;
-  @Nullable private static final Method SS_FACTORY_CREATE_METHOD;
-
-  static {
-    Pair<@NullableType Constructor<?>, @NullableType Method> dashFactoryMethods =
-        getMediaSourceFactoryMethods(
-            "com.google.android.exoplayer2.source.dash.DashMediaSource$Factory");
-    DASH_FACTORY_CONSTRUCTOR = dashFactoryMethods.first;
-    DASH_FACTORY_CREATE_METHOD = dashFactoryMethods.second;
-    Pair<@NullableType Constructor<?>, @NullableType Method> hlsFactoryMethods =
-        getMediaSourceFactoryMethods(
-            "com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory");
-    HLS_FACTORY_CONSTRUCTOR = hlsFactoryMethods.first;
-    HLS_FACTORY_CREATE_METHOD = hlsFactoryMethods.second;
-    Pair<@NullableType Constructor<?>, @NullableType Method> ssFactoryMethods =
-        getMediaSourceFactoryMethods(
-            "com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory");
-    SS_FACTORY_CONSTRUCTOR = ssFactoryMethods.first;
-    SS_FACTORY_CREATE_METHOD = ssFactoryMethods.second;
-  }
+  private static final MediaSourceFactory DASH_FACTORY =
+      getMediaSourceFactory("com.google.android.exoplayer2.source.dash.DashMediaSource$Factory");
+  private static final MediaSourceFactory SS_FACTORY =
+      getMediaSourceFactory(
+          "com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory");
+  private static final MediaSourceFactory HLS_FACTORY =
+      getMediaSourceFactory("com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory");
 
   /**
    * Creates a {@link DownloadHelper} for progressive streams.
@@ -202,8 +186,7 @@ public static DownloadHelper forDash(
         DownloadRequest.TYPE_DASH,
         uri,
         /* cacheKey= */ null,
-        createMediaSource(
-            uri, dataSourceFactory, DASH_FACTORY_CONSTRUCTOR, DASH_FACTORY_CREATE_METHOD),
+        DASH_FACTORY.createMediaSource(uri, dataSourceFactory, /* streamKeys= */ null),
         trackSelectorParameters,
         Util.getRendererCapabilities(renderersFactory, drmSessionManager));
   }
@@ -252,8 +235,7 @@ public static DownloadHelper forHls(
         DownloadRequest.TYPE_HLS,
         uri,
         /* cacheKey= */ null,
-        createMediaSource(
-            uri, dataSourceFactory, HLS_FACTORY_CONSTRUCTOR, HLS_FACTORY_CREATE_METHOD),
+        HLS_FACTORY.createMediaSource(uri, dataSourceFactory, /* streamKeys= */ null),
         trackSelectorParameters,
         Util.getRendererCapabilities(renderersFactory, drmSessionManager));
   }
@@ -302,11 +284,42 @@ public static DownloadHelper forSmoothStreaming(
         DownloadRequest.TYPE_SS,
         uri,
         /* cacheKey= */ null,
-        createMediaSource(uri, dataSourceFactory, SS_FACTORY_CONSTRUCTOR, SS_FACTORY_CREATE_METHOD),
+        SS_FACTORY.createMediaSource(uri, dataSourceFactory, /* streamKeys= */ null),
         trackSelectorParameters,
         Util.getRendererCapabilities(renderersFactory, drmSessionManager));
   }
 
+  /**
+   * Utility method to create a MediaSource which only contains the tracks defined in {@code
+   * downloadRequest}.
+   *
+   * @param downloadRequest A {@link DownloadRequest}.
+   * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+   * @return A MediaSource which only contains the tracks defined in {@code downloadRequest}.
+   */
+  public static MediaSource createMediaSource(
+      DownloadRequest downloadRequest, DataSource.Factory dataSourceFactory) {
+    MediaSourceFactory factory;
+    switch (downloadRequest.type) {
+      case DownloadRequest.TYPE_DASH:
+        factory = DASH_FACTORY;
+        break;
+      case DownloadRequest.TYPE_SS:
+        factory = SS_FACTORY;
+        break;
+      case DownloadRequest.TYPE_HLS:
+        factory = HLS_FACTORY;
+        break;
+      case DownloadRequest.TYPE_PROGRESSIVE:
+        return new ProgressiveMediaSource.Factory(dataSourceFactory)
+            .createMediaSource(downloadRequest.uri);
+      default:
+        throw new IllegalStateException("Unsupported type: " + downloadRequest.type);
+    }
+    return factory.createMediaSource(
+        downloadRequest.uri, dataSourceFactory, downloadRequest.streamKeys);
+  }
+
   private final String downloadType;
   private final Uri uri;
   @Nullable private final String cacheKey;
@@ -739,35 +752,54 @@ private TrackSelectorResult runTrackSelection(int periodIndex) {
     }
   }
 
-  private static Pair<@NullableType Constructor<?>, @NullableType Method>
-      getMediaSourceFactoryMethods(String className) {
+  private static MediaSourceFactory getMediaSourceFactory(String className) {
     Constructor<?> constructor = null;
+    Method setStreamKeysMethod = null;
     Method createMethod = null;
     try {
       // LINT.IfChange
       Class<?> factoryClazz = Class.forName(className);
-      constructor = factoryClazz.getConstructor(DataSource.Factory.class);
+      constructor = factoryClazz.getConstructor(Factory.class);
+      setStreamKeysMethod = factoryClazz.getMethod("setStreamKeys", List.class);
       createMethod = factoryClazz.getMethod("createMediaSource", Uri.class);
       // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
-    } catch (Exception e) {
+    } catch (ClassNotFoundException e) {
       // Expected if the app was built without the respective module.
+    } catch (NoSuchMethodException | SecurityException e) {
+      // Something is wrong with the library or the proguard configuration.
+      throw new IllegalStateException(e);
     }
-    return Pair.create(constructor, createMethod);
+    return new MediaSourceFactory(constructor, setStreamKeysMethod, createMethod);
   }
 
-  private static MediaSource createMediaSource(
-      Uri uri,
-      DataSource.Factory dataSourceFactory,
-      @Nullable Constructor<?> factoryConstructor,
-      @Nullable Method createMediaSourceMethod) {
-    if (factoryConstructor == null || createMediaSourceMethod == null) {
-      throw new IllegalStateException("Module missing to create media source.");
+  private static final class MediaSourceFactory {
+    @Nullable private final Constructor<?> constructor;
+    @Nullable private final Method setStreamKeysMethod;
+    @Nullable private final Method createMethod;
+
+    public MediaSourceFactory(
+        @Nullable Constructor<?> constructor,
+        @Nullable Method setStreamKeysMethod,
+        @Nullable Method createMethod) {
+      this.constructor = constructor;
+      this.setStreamKeysMethod = setStreamKeysMethod;
+      this.createMethod = createMethod;
     }
-    try {
-      Object factory = factoryConstructor.newInstance(dataSourceFactory);
-      return (MediaSource) Assertions.checkNotNull(createMediaSourceMethod.invoke(factory, uri));
-    } catch (Exception e) {
-      throw new IllegalStateException("Failed to instantiate media source.", e);
+
+    private MediaSource createMediaSource(
+        Uri uri, Factory dataSourceFactory, @Nullable List<StreamKey> streamKeys) {
+      if (constructor == null || setStreamKeysMethod == null || createMethod == null) {
+        throw new IllegalStateException("Module missing to create media source.");
+      }
+      try {
+        Object factory = constructor.newInstance(dataSourceFactory);
+        if (streamKeys != null) {
+          setStreamKeysMethod.invoke(factory, streamKeys);
+        }
+        return (MediaSource) Assertions.checkNotNull(createMethod.invoke(factory, uri));
+      } catch (Exception e) {
+        throw new IllegalStateException("Failed to instantiate media source.", e);
+      }
     }
   }
 
@@ -785,10 +817,10 @@ private static MediaSource createMediaSource(
     private final MediaSource mediaSource;
     private final DownloadHelper downloadHelper;
     private final Allocator allocator;
+    private final ArrayList<MediaPeriod> pendingMediaPeriods;
+    private final Handler downloadHelperHandler;
     private final HandlerThread mediaSourceThread;
     private final Handler mediaSourceHandler;
-    private final Handler downloadHelperHandler;
-    private final ArrayList<MediaPeriod> pendingMediaPeriods;
 
     @Nullable public Object manifest;
     public @MonotonicNonNull Timeline timeline;
@@ -800,6 +832,7 @@ public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
       this.mediaSource = mediaSource;
       this.downloadHelper = downloadHelper;
       allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
+      pendingMediaPeriods = new ArrayList<>();
       @SuppressWarnings("methodref.receiver.bound.invalid")
       Handler downloadThreadHandler = Util.createHandler(this::handleDownloadHelperCallbackMessage);
       this.downloadHelperHandler = downloadThreadHandler;
@@ -807,7 +840,6 @@ public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
       mediaSourceThread.start();
       mediaSourceHandler = Util.createHandler(mediaSourceThread.getLooper(), /* callback= */ this);
       mediaSourceHandler.sendEmptyMessage(MESSAGE_PREPARE_SOURCE);
-      pendingMediaPeriods = new ArrayList<>();
     }
 
     public void release() {
@@ -919,6 +951,7 @@ private boolean handleDownloadHelperCallbackMessage(Message msg) {
           downloadHelper.onMediaPrepared();
           return true;
         case DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED:
+          release();
           downloadHelper.onMediaPreparationFailed((IOException) Util.castNonNull(msg.obj));
           return true;
         default:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
index 3bf03dd3e8..ec5ff81d97 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
@@ -133,10 +133,11 @@ default void onRequirementsStateChanged(
   private static final int MSG_SET_MIN_RETRY_COUNT = 5;
   private static final int MSG_ADD_DOWNLOAD = 6;
   private static final int MSG_REMOVE_DOWNLOAD = 7;
-  private static final int MSG_TASK_STOPPED = 8;
-  private static final int MSG_CONTENT_LENGTH_CHANGED = 9;
-  private static final int MSG_UPDATE_PROGRESS = 10;
-  private static final int MSG_RELEASE = 11;
+  private static final int MSG_REMOVE_ALL_DOWNLOADS = 8;
+  private static final int MSG_TASK_STOPPED = 9;
+  private static final int MSG_CONTENT_LENGTH_CHANGED = 10;
+  private static final int MSG_UPDATE_PROGRESS = 11;
+  private static final int MSG_RELEASE = 12;
 
   private static final String TAG = "DownloadManager";
 
@@ -446,6 +447,12 @@ public void removeDownload(String id) {
     internalHandler.obtainMessage(MSG_REMOVE_DOWNLOAD, id).sendToTarget();
   }
 
+  /** Cancels all pending downloads and removes all downloaded data. */
+  public void removeAllDownloads() {
+    pendingMessages++;
+    internalHandler.obtainMessage(MSG_REMOVE_ALL_DOWNLOADS).sendToTarget();
+  }
+
   /**
    * Stops the downloads and releases resources. Waits until the downloads are persisted to the
    * download index. The manager must not be accessed after this method has been called.
@@ -652,6 +659,9 @@ public void handleMessage(Message message) {
           id = (String) message.obj;
           removeDownload(id);
           break;
+        case MSG_REMOVE_ALL_DOWNLOADS:
+          removeAllDownloads();
+          break;
         case MSG_TASK_STOPPED:
           Task task = (Task) message.obj;
           onTaskStopped(task);
@@ -797,6 +807,36 @@ private void removeDownload(String id) {
       syncTasks();
     }
 
+    private void removeAllDownloads() {
+      List<Download> terminalDownloads = new ArrayList<>();
+      try (DownloadCursor cursor = downloadIndex.getDownloads(STATE_COMPLETED, STATE_FAILED)) {
+        while (cursor.moveToNext()) {
+          terminalDownloads.add(cursor.getDownload());
+        }
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to load downloads.");
+      }
+      for (int i = 0; i < downloads.size(); i++) {
+        downloads.set(i, copyDownloadWithState(downloads.get(i), STATE_REMOVING));
+      }
+      for (int i = 0; i < terminalDownloads.size(); i++) {
+        downloads.add(copyDownloadWithState(terminalDownloads.get(i), STATE_REMOVING));
+      }
+      Collections.sort(downloads, InternalHandler::compareStartTimes);
+      try {
+        downloadIndex.setStatesToRemoving();
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to update index.", e);
+      }
+      ArrayList<Download> updateList = new ArrayList<>(downloads);
+      for (int i = 0; i < downloads.size(); i++) {
+        DownloadUpdate update =
+            new DownloadUpdate(downloads.get(i), /* isRemove= */ false, updateList);
+        mainHandler.obtainMessage(MSG_DOWNLOAD_UPDATE, update).sendToTarget();
+      }
+      syncTasks();
+    }
+
     private void release() {
       for (Task task : activeTasks.values()) {
         task.cancel(/* released= */ true);
@@ -1057,16 +1097,7 @@ private Download putDownloadWithState(Download download, @Download.State int sta
       // to set STATE_STOPPED either, because it doesn't have a stopReason argument.
       Assertions.checkState(
           state != STATE_COMPLETED && state != STATE_FAILED && state != STATE_STOPPED);
-      return putDownload(
-          new Download(
-              download.request,
-              state,
-              download.startTimeMs,
-              /* updateTimeMs= */ System.currentTimeMillis(),
-              download.contentLength,
-              /* stopReason= */ 0,
-              FAILURE_REASON_NONE,
-              download.progress));
+      return putDownload(copyDownloadWithState(download, state));
     }
 
     private Download putDownload(Download download) {
@@ -1120,6 +1151,18 @@ private int getDownloadIndex(String id) {
       return C.INDEX_UNSET;
     }
 
+    private static Download copyDownloadWithState(Download download, @Download.State int state) {
+      return new Download(
+          download.request,
+          state,
+          download.startTimeMs,
+          /* updateTimeMs= */ System.currentTimeMillis(),
+          download.contentLength,
+          /* stopReason= */ 0,
+          FAILURE_REASON_NONE,
+          download.progress);
+    }
+
     private static int compareStartTimes(Download first, Download second) {
       return Util.compareLong(first.startTimeMs, second.startTimeMs);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
index fdd7163a2c..3900dc8e93 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
@@ -77,6 +77,16 @@
   public static final String ACTION_REMOVE_DOWNLOAD =
       "com.google.android.exoplayer.downloadService.action.REMOVE_DOWNLOAD";
 
+  /**
+   * Removes all downloads. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_REMOVE_ALL_DOWNLOADS =
+      "com.google.android.exoplayer.downloadService.action.REMOVE_ALL_DOWNLOADS";
+
   /**
    * Resumes all downloads except those that have a non-zero {@link Download#stopReason}. Extras:
    *
@@ -296,6 +306,19 @@ public static Intent buildRemoveDownloadIntent(
         .putExtra(KEY_CONTENT_ID, id);
   }
 
+  /**
+   * Builds an {@link Intent} for removing all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildRemoveAllDownloadsIntent(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    return getIntent(context, clazz, ACTION_REMOVE_ALL_DOWNLOADS, foreground);
+  }
+
   /**
    * Builds an {@link Intent} for resuming all downloads.
    *
@@ -414,6 +437,19 @@ public static void sendRemoveDownload(
     startService(context, intent, foreground);
   }
 
+  /**
+   * Starts the service if not started already and removes all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendRemoveAllDownloads(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    Intent intent = buildRemoveAllDownloadsIntent(context, clazz, foreground);
+    startService(context, intent, foreground);
+  }
+
   /**
    * Starts the service if not started already and resumes all downloads.
    *
@@ -560,6 +596,9 @@ public int onStartCommand(Intent intent, int flags, int startId) {
           downloadManager.removeDownload(contentId);
         }
         break;
+      case ACTION_REMOVE_ALL_DOWNLOADS:
+        downloadManager.removeAllDownloads();
+        break;
       case ACTION_RESUME_DOWNLOADS:
         downloadManager.resumeDownloads();
         break;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
index ae634f8544..dc7085c85e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
@@ -44,6 +44,13 @@
    */
   void setDownloadingStatesToQueued() throws IOException;
 
+  /**
+   * Sets all states to {@link Download#STATE_REMOVING}.
+   *
+   * @throws IOException If an error occurs updating the state.
+   */
+  void setStatesToRemoving() throws IOException;
+
   /**
    * Sets the stop reason of the downloads in a terminal state ({@link Download#STATE_COMPLETED},
    * {@link Download#STATE_FAILED}).
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
index 8572c9c7ca..752239c991 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
@@ -25,6 +25,7 @@
 import android.content.Intent;
 import android.os.PersistableBundle;
 import androidx.annotation.RequiresPermission;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
@@ -36,7 +37,7 @@
  * <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
  * <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
  *
- * <service android:name="com.google.android.exoplayer2.util.scheduler.PlatformScheduler$PlatformSchedulerService"
+ * <service android:name="com.google.android.exoplayer2.scheduler.PlatformScheduler$PlatformSchedulerService"
  *     android:permission="android.permission.BIND_JOB_SERVICE"
  *     android:exported="true"/>
  * }</pre>
@@ -129,9 +130,8 @@ public boolean onStartJob(JobParameters params) {
         logd("Requirements are met");
         String serviceAction = extras.getString(KEY_SERVICE_ACTION);
         String servicePackage = extras.getString(KEY_SERVICE_PACKAGE);
-        // FIXME: incompatible types in argument.
-        @SuppressWarnings("nullness:argument.type.incompatible")
-        Intent intent = new Intent(serviceAction).setPackage(servicePackage);
+        Intent intent =
+            new Intent(Assertions.checkNotNull(serviceAction)).setPackage(servicePackage);
         logd("Starting service action: " + serviceAction + " package: " + servicePackage);
         Util.startForegroundService(this, intent);
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
index 30cf452572..5db86935f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
@@ -27,6 +27,7 @@
 import android.os.Parcelable;
 import android.os.PowerManager;
 import androidx.annotation.IntDef;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -128,7 +129,7 @@ private int getNotMetNetworkRequirements(Context context) {
 
     ConnectivityManager connectivityManager =
         (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+    NetworkInfo networkInfo = Assertions.checkNotNull(connectivityManager).getActiveNetworkInfo();
     if (networkInfo == null
         || !networkInfo.isConnected()
         || !isInternetConnectivityValidated(connectivityManager)) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
index f0d0f37cdf..9bd550f868 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
@@ -28,6 +28,7 @@
 import android.os.Looper;
 import android.os.PowerManager;
 import androidx.annotation.RequiresApi;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -126,7 +127,8 @@ public Requirements getRequirements() {
   @TargetApi(23)
   private void registerNetworkCallbackV23() {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        Assertions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
     NetworkRequest request =
         new NetworkRequest.Builder()
             .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
index d9f0008a7f..4dafa0ba76 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
@@ -733,7 +733,7 @@ private void startLoading() {
     if (prepared) {
       SeekMap seekMap = getPreparedState().seekMap;
       Assertions.checkState(isPendingReset());
-      if (durationUs != C.TIME_UNSET && pendingResetPositionUs >= durationUs) {
+      if (durationUs != C.TIME_UNSET && pendingResetPositionUs > durationUs) {
         loadingFinished = true;
         pendingResetPositionUs = C.TIME_UNSET;
         return;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
new file mode 100644
index 0000000000..b03dd0ea7c
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+
+/** Media source with a single period consisting of silent raw audio of a given duration. */
+public final class SilenceMediaSource extends BaseMediaSource {
+
+  private static final int SAMPLE_RATE_HZ = 44100;
+  @C.PcmEncoding private static final int ENCODING = C.ENCODING_PCM_16BIT;
+  private static final int CHANNEL_COUNT = 2;
+  private static final Format FORMAT =
+      Format.createAudioSampleFormat(
+          /* id=*/ null,
+          MimeTypes.AUDIO_RAW,
+          /* codecs= */ null,
+          /* bitrate= */ Format.NO_VALUE,
+          /* maxInputSize= */ Format.NO_VALUE,
+          CHANNEL_COUNT,
+          SAMPLE_RATE_HZ,
+          ENCODING,
+          /* initializationData= */ null,
+          /* drmInitData= */ null,
+          /* selectionFlags= */ 0,
+          /* language= */ null);
+  private static final byte[] SILENCE_SAMPLE =
+      new byte[Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT) * 1024];
+
+  private final long durationUs;
+
+  /**
+   * Creates a new media source providing silent audio of the given duration.
+   *
+   * @param durationUs The duration of silent audio to output, in microseconds.
+   */
+  public SilenceMediaSource(long durationUs) {
+    Assertions.checkArgument(durationUs >= 0);
+    this.durationUs = durationUs;
+  }
+
+  @Override
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    refreshSourceInfo(
+        new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false),
+        /* manifest= */ null);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() {}
+
+  @Override
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+    return new SilenceMediaPeriod(durationUs);
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {}
+
+  @Override
+  public void releaseSourceInternal() {}
+
+  private static final class SilenceMediaPeriod implements MediaPeriod {
+
+    private static final TrackGroupArray TRACKS = new TrackGroupArray(new TrackGroup(FORMAT));
+
+    private final long durationUs;
+    private final ArrayList<SampleStream> sampleStreams;
+
+    public SilenceMediaPeriod(long durationUs) {
+      this.durationUs = durationUs;
+      sampleStreams = new ArrayList<>();
+    }
+
+    @Override
+    public void prepare(Callback callback, long positionUs) {
+      callback.onPrepared(/* mediaPeriod= */ this);
+    }
+
+    @Override
+    public void maybeThrowPrepareError() {}
+
+    @Override
+    public TrackGroupArray getTrackGroups() {
+      return TRACKS;
+    }
+
+    @Override
+    public long selectTracks(
+        @NullableType TrackSelection[] selections,
+        boolean[] mayRetainStreamFlags,
+        @NullableType SampleStream[] streams,
+        boolean[] streamResetFlags,
+        long positionUs) {
+      for (int i = 0; i < selections.length; i++) {
+        if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+          sampleStreams.remove(streams[i]);
+          streams[i] = null;
+        }
+        if (streams[i] == null && selections[i] != null) {
+          SilenceSampleStream stream = new SilenceSampleStream(durationUs);
+          stream.seekTo(positionUs);
+          sampleStreams.add(stream);
+          streams[i] = stream;
+          streamResetFlags[i] = true;
+        }
+      }
+      return positionUs;
+    }
+
+    @Override
+    public void discardBuffer(long positionUs, boolean toKeyframe) {}
+
+    @Override
+    public long readDiscontinuity() {
+      return C.TIME_UNSET;
+    }
+
+    @Override
+    public long seekToUs(long positionUs) {
+      for (int i = 0; i < sampleStreams.size(); i++) {
+        ((SilenceSampleStream) sampleStreams.get(i)).seekTo(positionUs);
+      }
+      return positionUs;
+    }
+
+    @Override
+    public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+      return positionUs;
+    }
+
+    @Override
+    public long getBufferedPositionUs() {
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public long getNextLoadPositionUs() {
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public boolean continueLoading(long positionUs) {
+      return false;
+    }
+
+    @Override
+    public void reevaluateBuffer(long positionUs) {}
+  }
+
+  private static final class SilenceSampleStream implements SampleStream {
+
+    private final long durationBytes;
+
+    private boolean sentFormat;
+    private long positionBytes;
+
+    public SilenceSampleStream(long durationUs) {
+      durationBytes = getAudioByteCount(durationUs);
+      seekTo(0);
+    }
+
+    public void seekTo(long positionUs) {
+      positionBytes = getAudioByteCount(positionUs);
+    }
+
+    @Override
+    public boolean isReady() {
+      return true;
+    }
+
+    @Override
+    public void maybeThrowError() {}
+
+    @Override
+    public int readData(
+        FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {
+      if (!sentFormat || formatRequired) {
+        formatHolder.format = FORMAT;
+        sentFormat = true;
+        return C.RESULT_FORMAT_READ;
+      }
+
+      long bytesRemaining = durationBytes - positionBytes;
+      if (bytesRemaining == 0) {
+        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+
+      int bytesToWrite = (int) Math.min(SILENCE_SAMPLE.length, bytesRemaining);
+      buffer.ensureSpaceForWrite(bytesToWrite);
+      buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
+      buffer.data.put(SILENCE_SAMPLE, /* offset= */ 0, bytesToWrite);
+      buffer.timeUs = getAudioPositionUs(positionBytes);
+      positionBytes += bytesToWrite;
+      return C.RESULT_BUFFER_READ;
+    }
+
+    @Override
+    public int skipData(long positionUs) {
+      long oldPositionBytes = positionBytes;
+      seekTo(positionUs);
+      return (int) ((positionBytes - oldPositionBytes) / SILENCE_SAMPLE.length);
+    }
+  }
+
+  private static long getAudioByteCount(long durationUs) {
+    long audioSampleCount = durationUs * SAMPLE_RATE_HZ / C.MICROS_PER_SECOND;
+    return Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT) * audioSampleCount;
+  }
+
+  private static long getAudioPositionUs(long bytes) {
+    long audioSampleCount = bytes / Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT);
+    return audioSampleCount * C.MICROS_PER_SECOND / SAMPLE_RATE_HZ;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 9316e4fb86..5a14063aa1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -80,6 +80,11 @@
    * at which point the non-displayed memory becomes the displayed memory (and vice versa).
    */
   private static final byte CTRL_RESUME_CAPTION_LOADING = 0x20;
+
+  private static final byte CTRL_BACKSPACE = 0x21;
+
+  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
+
   /**
    * Command initiating roll-up style captioning, with the maximum of 2 rows displayed
    * simultaneously.
@@ -95,25 +100,31 @@
    * simultaneously.
    */
   private static final byte CTRL_ROLL_UP_CAPTIONS_4_ROWS = 0x27;
+
   /**
    * Command initiating paint-on style captioning. Subsequent data should be addressed immediately
    * to displayed memory without need for the {@link #CTRL_RESUME_CAPTION_LOADING} command.
    */
   private static final byte CTRL_RESUME_DIRECT_CAPTIONING = 0x29;
   /**
-   * Command indicating the end of a pop-on style caption. At this point the caption loaded in
-   * non-displayed memory should be swapped with the one in displayed memory. If no
-   * {@link #CTRL_RESUME_CAPTION_LOADING} command has been received, this command forces the
-   * receiver into pop-on style.
+   * TEXT commands are switching to TEXT service. All consecutive incoming data must be filtered out
+   * until a command is received that switches back to the CAPTION service.
    */
-  private static final byte CTRL_END_OF_CAPTION = 0x2F;
+  private static final byte CTRL_TEXT_RESTART = 0x2A;
+
+  private static final byte CTRL_RESUME_TEXT_DISPLAY = 0x2B;
 
   private static final byte CTRL_ERASE_DISPLAYED_MEMORY = 0x2C;
   private static final byte CTRL_CARRIAGE_RETURN = 0x2D;
   private static final byte CTRL_ERASE_NON_DISPLAYED_MEMORY = 0x2E;
-  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
 
-  private static final byte CTRL_BACKSPACE = 0x21;
+  /**
+   * Command indicating the end of a pop-on style caption. At this point the caption loaded in
+   * non-displayed memory should be swapped with the one in displayed memory. If no {@link
+   * #CTRL_RESUME_CAPTION_LOADING} command has been received, this command forces the receiver into
+   * pop-on style.
+   */
+  private static final byte CTRL_END_OF_CAPTION = 0x2F;
 
   // Basic North American 608 CC char set, mostly ASCII. Indexed by (char-0x20).
   private static final int[] BASIC_CHARACTER_SET = new int[] {
@@ -231,12 +242,17 @@
   private int captionMode;
   private int captionRowCount;
 
-  private boolean captionValid;
+  private boolean isCaptionValid;
   private boolean repeatableControlSet;
   private byte repeatableControlCc1;
   private byte repeatableControlCc2;
   private int currentChannel;
 
+  // The incoming characters may belong to 3 different services based on the last received control
+  // codes. The 3 services are Captioning, Text and XDS. The decoder only processes Captioning
+  // service bytes and drops the rest.
+  private boolean isInCaptionService;
+
   public Cea608Decoder(String mimeType, int accessibilityChannel) {
     ccData = new ParsableByteArray();
     cueBuilders = new ArrayList<>();
@@ -268,6 +284,7 @@ public Cea608Decoder(String mimeType, int accessibilityChannel) {
 
     setCaptionMode(CC_MODE_UNKNOWN);
     resetCueBuilders();
+    isInCaptionService = true;
   }
 
   @Override
@@ -283,11 +300,12 @@ public void flush() {
     setCaptionMode(CC_MODE_UNKNOWN);
     setCaptionRowCount(DEFAULT_CAPTIONS_ROW_COUNT);
     resetCueBuilders();
-    captionValid = false;
+    isCaptionValid = false;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
     currentChannel = NTSC_CC_CHANNEL_1;
+    isInCaptionService = true;
   }
 
   @Override
@@ -340,13 +358,19 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         continue;
       }
 
-      boolean repeatedControlPossible = repeatableControlSet;
-      repeatableControlSet = false;
+      boolean previousIsCaptionValid = isCaptionValid;
+      isCaptionValid =
+          (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG
+              && ODD_PARITY_BYTE_TABLE[ccByte1]
+              && ODD_PARITY_BYTE_TABLE[ccByte2];
 
-      boolean previousCaptionValid = captionValid;
-      captionValid = (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG;
-      if (!captionValid) {
-        if (previousCaptionValid) {
+      if (isRepeatedCommand(isCaptionValid, ccData1, ccData2)) {
+        // Ignore repeated valid commands.
+        continue;
+      }
+
+      if (!isCaptionValid) {
+        if (previousIsCaptionValid) {
           // The encoder has flipped the validity bit to indicate captions are being turned off.
           resetCueBuilders();
           captionDataProcessed = true;
@@ -354,59 +378,41 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         continue;
       }
 
-      // If we've reached this point then there is data to process; flag that work has been done.
-      captionDataProcessed = true;
-
-      if (!ODD_PARITY_BYTE_TABLE[ccByte1] || !ODD_PARITY_BYTE_TABLE[ccByte2]) {
-        // The data is invalid.
-        resetCueBuilders();
+      maybeUpdateIsInCaptionService(ccData1, ccData2);
+      if (!isInCaptionService) {
+        // Only the Captioning service is supported. Drop all other bytes.
         continue;
       }
 
-      // Special North American character set.
-      // ccData1 - 0|0|0|1|C|0|0|1
-      // ccData2 - 0|0|1|1|X|X|X|X
-      if (((ccData1 & 0xF7) == 0x11) && ((ccData2 & 0xF0) == 0x30)) {
-        if (getChannel(ccData1) == selectedChannel) {
-          currentCueBuilder.append(getSpecialChar(ccData2));
-        }
+      if (!updateAndVerifyCurrentChannel(ccData1)) {
+        // Wrong channel.
         continue;
       }
 
-      // Extended Western European character set.
-      // ccData1 - 0|0|0|1|C|0|1|S
-      // ccData2 - 0|0|1|X|X|X|X|X
-      if (((ccData1 & 0xF6) == 0x12) && (ccData2 & 0xE0) == 0x20) {
-        if (getChannel(ccData1) == selectedChannel) {
-          // Remove standard equivalent of the special extended char before appending new one
+      if (isCtrlCode(ccData1)) {
+        if (isSpecialNorthAmericanChar(ccData1, ccData2)) {
+          currentCueBuilder.append(getSpecialNorthAmericanChar(ccData2));
+        } else if (isExtendedWestEuropeanChar(ccData1, ccData2)) {
+          // Remove standard equivalent of the special extended char before appending new one.
           currentCueBuilder.backspace();
-          if ((ccData1 & 0x01) == 0x00) {
-            // Extended Spanish/Miscellaneous and French character set (S = 0).
-            currentCueBuilder.append(getExtendedEsFrChar(ccData2));
-          } else {
-            // Extended Portuguese and German/Danish character set (S = 1).
-            currentCueBuilder.append(getExtendedPtDeChar(ccData2));
-          }
+          currentCueBuilder.append(getExtendedWestEuropeanChar(ccData1, ccData2));
+        } else if (isMidrowCtrlCode(ccData1, ccData2)) {
+          handleMidrowCtrl(ccData2);
+        } else if (isPreambleAddressCode(ccData1, ccData2)) {
+          handlePreambleAddressCode(ccData1, ccData2);
+        } else if (isTabCtrlCode(ccData1, ccData2)) {
+          currentCueBuilder.tabOffset = ccData2 - 0x20;
+        } else if (isMiscCode(ccData1, ccData2)) {
+          handleMiscCode(ccData2);
+        }
+      } else {
+        // Basic North American character set.
+        currentCueBuilder.append(getBasicChar(ccData1));
+        if ((ccData2 & 0xE0) != 0x00) {
+          currentCueBuilder.append(getBasicChar(ccData2));
         }
-        continue;
-      }
-
-      // Control character.
-      // ccData1 - 0|0|0|X|X|X|X|X
-      if ((ccData1 & 0xE0) == 0x00) {
-        handleCtrl(ccData1, ccData2, repeatedControlPossible);
-        continue;
-      }
-
-      if (currentChannel != selectedChannel) {
-        continue;
-      }
-
-      // Basic North American character set.
-      currentCueBuilder.append(getChar(ccData1));
-      if ((ccData2 & 0xE0) != 0x00) {
-        currentCueBuilder.append(getChar(ccData2));
       }
+      captionDataProcessed = true;
     }
 
     if (captionDataProcessed) {
@@ -416,15 +422,22 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
     }
   }
 
-  private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
-    currentChannel = getChannel(cc1);
+  private boolean updateAndVerifyCurrentChannel(byte cc1) {
+    if (isCtrlCode(cc1)) {
+      currentChannel = getChannel(cc1);
+    }
+    return currentChannel == selectedChannel;
+  }
+
+  private boolean isRepeatedCommand(boolean captionValid, byte cc1, byte cc2) {
     // Most control commands are sent twice in succession to ensure they are received properly. We
     // don't want to process duplicate commands, so if we see the same repeatable command twice in a
     // row then we ignore the second one.
-    if (isRepeatable(cc1)) {
-      if (repeatedControlPossible && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
+    if (captionValid && isRepeatable(cc1)) {
+      if (repeatableControlSet && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
         // This is a repeated command, so we ignore it.
-        return;
+        repeatableControlSet = false;
+        return true;
       } else {
         // This is the first occurrence of a repeatable command. Set the repeatable control
         // variables so that we can recognize and ignore a duplicate (if there is one), and then
@@ -433,21 +446,11 @@ private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
         repeatableControlCc1 = cc1;
         repeatableControlCc2 = cc2;
       }
+    } else {
+      // This command is not repeatable.
+      repeatableControlSet = false;
     }
-
-    if (currentChannel != selectedChannel) {
-      return;
-    }
-
-    if (isMidrowCtrlCode(cc1, cc2)) {
-      handleMidrowCtrl(cc2);
-    } else if (isPreambleAddressCode(cc1, cc2)) {
-      handlePreambleAddressCode(cc1, cc2);
-    } else if (isTabCtrlCode(cc1, cc2)) {
-      currentCueBuilder.tabOffset = cc2 - 0x20;
-    } else if (isMiscCode(cc1, cc2)) {
-      handleMiscCode(cc2);
-    }
+    return false;
   }
 
   private void handleMidrowCtrl(byte cc2) {
@@ -629,16 +632,61 @@ private void resetCueBuilders() {
     cueBuilders.add(currentCueBuilder);
   }
 
-  private static char getChar(byte ccData) {
+  private void maybeUpdateIsInCaptionService(byte cc1, byte cc2) {
+    if (isXdsControlCode(cc1)) {
+      isInCaptionService = false;
+    } else if (isServiceSwitchCommand(cc1)) {
+      switch (cc2) {
+        case CTRL_TEXT_RESTART:
+        case CTRL_RESUME_TEXT_DISPLAY:
+          isInCaptionService = false;
+          break;
+        case CTRL_END_OF_CAPTION:
+        case CTRL_RESUME_CAPTION_LOADING:
+        case CTRL_RESUME_DIRECT_CAPTIONING:
+        case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
+        case CTRL_ROLL_UP_CAPTIONS_3_ROWS:
+        case CTRL_ROLL_UP_CAPTIONS_4_ROWS:
+          isInCaptionService = true;
+          break;
+        default:
+          // No update.
+      }
+    }
+  }
+
+  private static char getBasicChar(byte ccData) {
     int index = (ccData & 0x7F) - 0x20;
     return (char) BASIC_CHARACTER_SET[index];
   }
 
-  private static char getSpecialChar(byte ccData) {
+  private static boolean isSpecialNorthAmericanChar(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|0|1
+    // cc2 - 0|0|1|1|X|X|X|X
+    return ((cc1 & 0xF7) == 0x11) && ((cc2 & 0xF0) == 0x30);
+  }
+
+  private static char getSpecialNorthAmericanChar(byte ccData) {
     int index = ccData & 0x0F;
     return (char) SPECIAL_CHARACTER_SET[index];
   }
 
+  private static boolean isExtendedWestEuropeanChar(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|1|S
+    // cc2 - 0|0|1|X|X|X|X|X
+    return ((cc1 & 0xF6) == 0x12) && ((cc2 & 0xE0) == 0x20);
+  }
+
+  private static char getExtendedWestEuropeanChar(byte cc1, byte cc2) {
+    if ((cc1 & 0x01) == 0x00) {
+      // Extended Spanish/Miscellaneous and French character set (S = 0).
+      return getExtendedEsFrChar(cc2);
+    } else {
+      // Extended Portuguese and German/Danish character set (S = 1).
+      return getExtendedPtDeChar(cc2);
+    }
+  }
+
   private static char getExtendedEsFrChar(byte ccData) {
     int index = ccData & 0x1F;
     return (char) SPECIAL_ES_FR_CHARACTER_SET[index];
@@ -649,6 +697,11 @@ private static char getExtendedPtDeChar(byte ccData) {
     return (char) SPECIAL_PT_DE_CHARACTER_SET[index];
   }
 
+  private static boolean isCtrlCode(byte cc1) {
+    // cc1 - 0|0|0|X|X|X|X|X
+    return (cc1 & 0xE0) == 0x00;
+  }
+
   private static int getChannel(byte cc1) {
     // cc1 - X|X|X|X|C|X|X|X
     return (cc1 >> 3) & 0x1;
@@ -683,6 +736,15 @@ private static boolean isRepeatable(byte cc1) {
     return (cc1 & 0xF0) == 0x10;
   }
 
+  private static boolean isXdsControlCode(byte cc1) {
+    return 0x01 <= cc1 && cc1 <= 0x0F;
+  }
+
+  private static boolean isServiceSwitchCommand(byte cc1) {
+    // cc1 - 0|0|0|1|C|1|0|0
+    return (cc1 & 0xF7) == 0x14;
+  }
+
   private static class CueBuilder {
 
     // 608 captions define a 15 row by 32 column screen grid. These constants convert from 608
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
index eb956f06db..3f2fef454f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
@@ -21,7 +21,6 @@
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
-import android.graphics.Region;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.util.Log;
@@ -150,6 +149,8 @@ public void reset() {
     List<Cue> cues = new ArrayList<>();
     SparseArray<PageRegion> pageRegions = subtitleService.pageComposition.regions;
     for (int i = 0; i < pageRegions.size(); i++) {
+      // Save clean clipping state.
+      canvas.save();
       PageRegion pageRegion = pageRegions.valueAt(i);
       int regionId = pageRegions.keyAt(i);
       RegionComposition regionComposition = subtitleService.regions.get(regionId);
@@ -163,9 +164,7 @@ public void reset() {
           displayDefinition.horizontalPositionMaximum);
       int clipBottom = Math.min(baseVerticalAddress + regionComposition.height,
           displayDefinition.verticalPositionMaximum);
-      canvas.clipRect(baseHorizontalAddress, baseVerticalAddress, clipRight, clipBottom,
-          Region.Op.REPLACE);
-
+      canvas.clipRect(baseHorizontalAddress, baseVerticalAddress, clipRight, clipBottom);
       ClutDefinition clutDefinition = subtitleService.cluts.get(regionComposition.clutId);
       if (clutDefinition == null) {
         clutDefinition = subtitleService.ancillaryCluts.get(regionComposition.clutId);
@@ -214,9 +213,11 @@ public void reset() {
           (float) regionComposition.height / displayDefinition.height));
 
       canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+      // Restore clean clipping state.
+      canvas.restore();
     }
 
-    return cues;
+    return Collections.unmodifiableList(cues);
   }
 
   // Static parsing.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
index b39f467968..6e0c495466 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
@@ -429,6 +429,7 @@ private TtmlRegion parseRegionAttributes(
         /* lineType= */ Cue.LINE_TYPE_FRACTION,
         lineAnchor,
         width,
+        height,
         /* textSizeType= */ Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING,
         /* textSize= */ regionTextHeight);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
index ecf5c8b0a0..3b4d061aaa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
@@ -231,11 +231,11 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
           new Cue(
               bitmap,
               region.position,
-              Cue.ANCHOR_TYPE_MIDDLE,
+              Cue.ANCHOR_TYPE_START,
               region.line,
               region.lineAnchor,
               region.width,
-              /* height= */ Cue.DIMEN_UNSET));
+              region.height));
     }
 
     // Create text based cues.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
index 2b1e9cf99a..3cbc25d4b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
@@ -28,6 +28,7 @@
   public final @Cue.LineType int lineType;
   public final @Cue.AnchorType int lineAnchor;
   public final float width;
+  public final float height;
   public final @Cue.TextSizeType int textSizeType;
   public final float textSize;
 
@@ -39,6 +40,7 @@ public TtmlRegion(String id) {
         /* lineType= */ Cue.TYPE_UNSET,
         /* lineAnchor= */ Cue.TYPE_UNSET,
         /* width= */ Cue.DIMEN_UNSET,
+        /* height= */ Cue.DIMEN_UNSET,
         /* textSizeType= */ Cue.TYPE_UNSET,
         /* textSize= */ Cue.DIMEN_UNSET);
   }
@@ -50,6 +52,7 @@ public TtmlRegion(
       @Cue.LineType int lineType,
       @Cue.AnchorType int lineAnchor,
       float width,
+      float height,
       int textSizeType,
       float textSize) {
     this.id = id;
@@ -58,6 +61,7 @@ public TtmlRegion(
     this.lineType = lineType;
     this.lineAnchor = lineAnchor;
     this.width = width;
+    this.height = height;
     this.textSizeType = textSizeType;
     this.textSize = textSize;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java
index 81c362bda5..f87710a44c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -35,8 +37,8 @@
   private static final String PROPERTY_TEXT_DECORATION = "text-decoration";
   private static final String VALUE_BOLD = "bold";
   private static final String VALUE_UNDERLINE = "underline";
-  private static final String BLOCK_START = "{";
-  private static final String BLOCK_END = "}";
+  private static final String RULE_START = "{";
+  private static final String RULE_END = "}";
   private static final String PROPERTY_FONT_STYLE = "font-style";
   private static final String VALUE_ITALIC = "italic";
 
@@ -52,37 +54,47 @@ public CssParser() {
   }
 
   /**
-   * Takes a CSS style block and consumes up to the first empty line found. Attempts to parse the
-   * contents of the style block and returns a {@link WebvttCssStyle} instance if successful, or
-   * {@code null} otherwise.
+   * Takes a CSS style block and consumes up to the first empty line. Attempts to parse the contents
+   * of the style block and returns a list of {@link WebvttCssStyle} instances if successful. If
+   * parsing fails, it returns a list including only the styles which have been successfully parsed
+   * up to the style rule which was malformed.
    *
    * @param input The input from which the style block should be read.
-   * @return A {@link WebvttCssStyle} that represents the parsed block.
+   * @return A list of {@link WebvttCssStyle}s that represents the parsed block, or a list
+   *     containing the styles up to the parsing failure.
    */
-  public WebvttCssStyle parseBlock(ParsableByteArray input) {
+  public List<WebvttCssStyle> parseBlock(ParsableByteArray input) {
     stringBuilder.setLength(0);
     int initialInputPosition = input.getPosition();
     skipStyleBlock(input);
     styleInput.reset(input.data, input.getPosition());
     styleInput.setPosition(initialInputPosition);
-    String selector = parseSelector(styleInput, stringBuilder);
-    if (selector == null || !BLOCK_START.equals(parseNextToken(styleInput, stringBuilder))) {
-      return null;
-    }
-    WebvttCssStyle style = new WebvttCssStyle();
-    applySelectorToStyle(style, selector);
-    String token = null;
-    boolean blockEndFound = false;
-    while (!blockEndFound) {
-      int position = styleInput.getPosition();
-      token = parseNextToken(styleInput, stringBuilder);
-      blockEndFound = token == null || BLOCK_END.equals(token);
-      if (!blockEndFound) {
-        styleInput.setPosition(position);
-        parseStyleDeclaration(styleInput, style, stringBuilder);
+
+    List<WebvttCssStyle> styles = new ArrayList<>();
+    String selector;
+    while ((selector = parseSelector(styleInput, stringBuilder)) != null) {
+      if (!RULE_START.equals(parseNextToken(styleInput, stringBuilder))) {
+        return styles;
+      }
+      WebvttCssStyle style = new WebvttCssStyle();
+      applySelectorToStyle(style, selector);
+      String token = null;
+      boolean blockEndFound = false;
+      while (!blockEndFound) {
+        int position = styleInput.getPosition();
+        token = parseNextToken(styleInput, stringBuilder);
+        blockEndFound = token == null || RULE_END.equals(token);
+        if (!blockEndFound) {
+          styleInput.setPosition(position);
+          parseStyleDeclaration(styleInput, style, stringBuilder);
+        }
+      }
+      // Check that the style rule ended correctly.
+      if (RULE_END.equals(token)) {
+        styles.add(style);
       }
     }
-    return BLOCK_END.equals(token) ? style : null; // Check that the style block ended correctly.
+    return styles;
   }
 
   /**
@@ -107,7 +119,7 @@ private static String parseSelector(ParsableByteArray input, StringBuilder strin
     if (token == null) {
       return null;
     }
-    if (BLOCK_START.equals(token)) {
+    if (RULE_START.equals(token)) {
       input.setPosition(position);
       return "";
     }
@@ -156,7 +168,7 @@ private static void parseStyleDeclaration(ParsableByteArray input, WebvttCssStyl
     String token = parseNextToken(input, stringBuilder);
     if (";".equals(token)) {
       // The style declaration is well formed.
-    } else if (BLOCK_END.equals(token)) {
+    } else if (RULE_END.equals(token)) {
       // The style declaration is well formed and we can go on, but the closing bracket had to be
       // fed back.
       input.setPosition(position);
@@ -250,7 +262,7 @@ private static String parsePropertyValue(ParsableByteArray input, StringBuilder
         // Syntax error.
         return null;
       }
-      if (BLOCK_END.equals(token) || ";".equals(token)) {
+      if (RULE_END.equals(token) || ";".equals(token)) {
         input.setPosition(position);
         expressionEndFound = true;
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
index 06d3c14970..fe3c86bd1e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
@@ -80,10 +80,7 @@ protected WebvttSubtitle decode(byte[] bytes, int length, boolean reset)
           throw new SubtitleDecoderException("A style block was found after the first cue.");
         }
         parsableWebvttData.readLine(); // Consume the "STYLE" header.
-        WebvttCssStyle styleBlock = cssParser.parseBlock(parsableWebvttData);
-        if (styleBlock != null) {
-          definedStyles.add(styleBlock);
-        }
+        definedStyles.addAll(cssParser.parseBlock(parsableWebvttData));
       } else if (event == EVENT_CUE) {
         if (cueParser.parseCue(parsableWebvttData, webvttCueBuilder, definedStyles)) {
           subtitles.add(webvttCueBuilder.build());
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index bbf57c5602..0adadd87c2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -757,7 +757,7 @@ public long getAllocatedBandwidth() {
     for (int i = 0; i < values.length; i++) {
       logValues[i] = new double[values[i].length];
       for (int j = 0; j < values[i].length; j++) {
-        logValues[i][j] = Math.log(values[i][j]);
+        logValues[i][j] = values[i][j] == Format.NO_VALUE ? 0 : Math.log(values[i][j]);
       }
     }
     return logValues;
@@ -779,7 +779,8 @@ public long getAllocatedBandwidth() {
       double totalBitrateDiff = logBitrates[i][logBitrates[i].length - 1] - logBitrates[i][0];
       for (int j = 0; j < logBitrates[i].length - 1; j++) {
         double switchBitrate = 0.5 * (logBitrates[i][j] + logBitrates[i][j + 1]);
-        switchPoints[i][j] = (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
+        switchPoints[i][j] =
+            totalBitrateDiff == 0.0 ? 1.0 : (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
       }
     }
     return switchPoints;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 3200e40495..949bd178ea 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -1934,6 +1934,7 @@ private static boolean isSupportedAdaptiveVideoTrack(
           getAdaptiveAudioTracks(
               selectedGroup,
               formatSupports[selectedGroupIndex],
+              params.maxAudioBitrate,
               params.allowAudioMixedMimeTypeAdaptiveness,
               params.allowAudioMixedSampleRateAdaptiveness);
       if (adaptiveTracks.length > 0) {
@@ -1951,6 +1952,7 @@ private static boolean isSupportedAdaptiveVideoTrack(
   private static int[] getAdaptiveAudioTracks(
       TrackGroup group,
       int[] formatSupport,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness) {
     int selectedConfigurationTrackCount = 0;
@@ -1967,6 +1969,7 @@ private static boolean isSupportedAdaptiveVideoTrack(
                 group,
                 formatSupport,
                 configuration,
+                maxAudioBitrate,
                 allowMixedMimeTypeAdaptiveness,
                 allowMixedSampleRateAdaptiveness);
         if (configurationCount > selectedConfigurationTrackCount) {
@@ -1977,13 +1980,16 @@ private static boolean isSupportedAdaptiveVideoTrack(
     }
 
     if (selectedConfigurationTrackCount > 1) {
+      Assertions.checkNotNull(selectedConfiguration);
       int[] adaptiveIndices = new int[selectedConfigurationTrackCount];
       int index = 0;
       for (int i = 0; i < group.length; i++) {
+        Format format = group.getFormat(i);
         if (isSupportedAdaptiveAudioTrack(
-            group.getFormat(i),
+            format,
             formatSupport[i],
-            Assertions.checkNotNull(selectedConfiguration),
+            selectedConfiguration,
+            maxAudioBitrate,
             allowMixedMimeTypeAdaptiveness,
             allowMixedSampleRateAdaptiveness)) {
           adaptiveIndices[index++] = i;
@@ -1998,6 +2004,7 @@ private static int getAdaptiveAudioTrackCount(
       TrackGroup group,
       int[] formatSupport,
       AudioConfigurationTuple configuration,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness) {
     int count = 0;
@@ -2006,6 +2013,7 @@ private static int getAdaptiveAudioTrackCount(
           group.getFormat(i),
           formatSupport[i],
           configuration,
+          maxAudioBitrate,
           allowMixedMimeTypeAdaptiveness,
           allowMixedSampleRateAdaptiveness)) {
         count++;
@@ -2018,9 +2026,11 @@ private static boolean isSupportedAdaptiveAudioTrack(
       Format format,
       int formatSupport,
       AudioConfigurationTuple configuration,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness) {
     return isSupported(formatSupport, false)
+        && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxAudioBitrate)
         && (format.channelCount != Format.NO_VALUE
             && format.channelCount == configuration.channelCount)
         && (allowMixedMimeTypeAdaptiveness
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index 8b4107850c..69db1cfdb1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -42,6 +42,7 @@
  *   <li>rtmp: For fetching data over RTMP. Only supported if the project using ExoPlayer has an
  *       explicit dependency on ExoPlayer's RTMP extension.
  *   <li>data: For parsing data inlined in the URI as defined in RFC 2397.
+ *   <li>udp: For fetching data over UDP (e.g. udp://something.com/media).
  *   <li>http(s): For fetching data over HTTP and HTTPS (e.g. https://www.something.com/media.mp4),
  *       if constructed using {@link #DefaultDataSource(Context, TransferListener, String,
  *       boolean)}, or any other schemes supported by a base data source if constructed using {@link
@@ -55,6 +56,7 @@
   private static final String SCHEME_ASSET = "asset";
   private static final String SCHEME_CONTENT = "content";
   private static final String SCHEME_RTMP = "rtmp";
+  private static final String SCHEME_UDP = "udp";
   private static final String SCHEME_RAW = RawResourceDataSource.RAW_RESOURCE_SCHEME;
 
   private final Context context;
@@ -62,12 +64,13 @@
   private final DataSource baseDataSource;
 
   // Lazily initialized.
-  private @Nullable DataSource fileDataSource;
-  private @Nullable DataSource assetDataSource;
-  private @Nullable DataSource contentDataSource;
-  private @Nullable DataSource rtmpDataSource;
-  private @Nullable DataSource dataSchemeDataSource;
-  private @Nullable DataSource rawResourceDataSource;
+  @Nullable private DataSource fileDataSource;
+  @Nullable private DataSource assetDataSource;
+  @Nullable private DataSource contentDataSource;
+  @Nullable private DataSource rtmpDataSource;
+  @Nullable private DataSource udpDataSource;
+  @Nullable private DataSource dataSchemeDataSource;
+  @Nullable private DataSource rawResourceDataSource;
 
   private @Nullable DataSource dataSource;
 
@@ -218,6 +221,7 @@ public void addTransferListener(TransferListener transferListener) {
     maybeAddListenerToDataSource(assetDataSource, transferListener);
     maybeAddListenerToDataSource(contentDataSource, transferListener);
     maybeAddListenerToDataSource(rtmpDataSource, transferListener);
+    maybeAddListenerToDataSource(udpDataSource, transferListener);
     maybeAddListenerToDataSource(dataSchemeDataSource, transferListener);
     maybeAddListenerToDataSource(rawResourceDataSource, transferListener);
   }
@@ -240,6 +244,8 @@ public long open(DataSpec dataSpec) throws IOException {
       dataSource = getContentDataSource();
     } else if (SCHEME_RTMP.equals(scheme)) {
       dataSource = getRtmpDataSource();
+    } else if (SCHEME_UDP.equals(scheme)) {
+      dataSource = getUdpDataSource();
     } else if (DataSchemeDataSource.SCHEME_DATA.equals(scheme)) {
       dataSource = getDataSchemeDataSource();
     } else if (SCHEME_RAW.equals(scheme)) {
@@ -277,6 +283,14 @@ public void close() throws IOException {
     }
   }
 
+  private DataSource getUdpDataSource() {
+    if (udpDataSource == null) {
+      udpDataSource = new UdpDataSource();
+      addListenersToDataSource(udpDataSource);
+    }
+    return udpDataSource;
+  }
+
   private DataSource getFileDataSource() {
     if (fileDataSource == null) {
       fileDataSource = new FileDataSource();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 6aad517004..66036b7a84 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -89,6 +89,11 @@
   private long bytesSkipped;
   private long bytesRead;
 
+  /** @param userAgent The User-Agent string that should be used. */
+  public DefaultHttpDataSource(String userAgent) {
+    this(userAgent, /* contentTypePredicate= */ null);
+  }
+
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
new file mode 100644
index 0000000000..99f0dee207
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/** {@link DataSource} wrapper allowing just-in-time resolution of {@link DataSpec DataSpecs}. */
+public final class ResolvingDataSource implements DataSource {
+
+  /** Resolves {@link DataSpec DataSpecs}. */
+  public interface Resolver {
+
+    /**
+     * Resolves a {@link DataSpec} before forwarding it to the wrapped {@link DataSource}. This
+     * method is allowed to block until the {@link DataSpec} has been resolved.
+     *
+     * <p>Note that this method is called for every new connection, so caching of results is
+     * recommended, especially if network operations are involved.
+     *
+     * @param dataSpec The original {@link DataSpec}.
+     * @return The resolved {@link DataSpec}.
+     * @throws IOException If an {@link IOException} occurred while resolving the {@link DataSpec}.
+     */
+    DataSpec resolveDataSpec(DataSpec dataSpec) throws IOException;
+
+    /**
+     * Resolves a URI reported by {@link DataSource#getUri()} for event reporting and caching
+     * purposes.
+     *
+     * <p>Implementations do not need to overwrite this method unless they want to change the
+     * reported URI.
+     *
+     * <p>This method is <em>not</em> allowed to block.
+     *
+     * @param uri The URI as reported by {@link DataSource#getUri()}.
+     * @return The resolved URI used for event reporting and caching.
+     */
+    default Uri resolveReportedUri(Uri uri) {
+      return uri;
+    }
+  }
+
+  /** {@link DataSource.Factory} for {@link ResolvingDataSource} instances. */
+  public static final class Factory implements DataSource.Factory {
+
+    private final DataSource.Factory upstreamFactory;
+    private final Resolver resolver;
+
+    /**
+     * Creates factory for {@link ResolvingDataSource} instances.
+     *
+     * @param upstreamFactory The wrapped {@link DataSource.Factory} handling the resolved {@link
+     *     DataSpec DataSpecs}.
+     * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
+     */
+    public Factory(DataSource.Factory upstreamFactory, Resolver resolver) {
+      this.upstreamFactory = upstreamFactory;
+      this.resolver = resolver;
+    }
+
+    @Override
+    public DataSource createDataSource() {
+      return new ResolvingDataSource(upstreamFactory.createDataSource(), resolver);
+    }
+  }
+
+  private final DataSource upstreamDataSource;
+  private final Resolver resolver;
+
+  private boolean upstreamOpened;
+
+  /**
+   * @param upstreamDataSource The wrapped {@link DataSource}.
+   * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
+   */
+  public ResolvingDataSource(DataSource upstreamDataSource, Resolver resolver) {
+    this.upstreamDataSource = upstreamDataSource;
+    this.resolver = resolver;
+  }
+
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstreamDataSource.addTransferListener(transferListener);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    DataSpec resolvedDataSpec = resolver.resolveDataSpec(dataSpec);
+    upstreamOpened = true;
+    return upstreamDataSource.open(resolvedDataSpec);
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    return upstreamDataSource.read(buffer, offset, readLength);
+  }
+
+  @Nullable
+  @Override
+  public Uri getUri() {
+    Uri reportedUri = upstreamDataSource.getUri();
+    return reportedUri == null ? null : resolver.resolveReportedUri(reportedUri);
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstreamDataSource.getResponseHeaders();
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (upstreamOpened) {
+      upstreamOpened = false;
+      upstreamDataSource.close();
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 2caf4c92f8..566c928b20 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -49,7 +49,6 @@
   private final long fragmentSize;
   private final int bufferSize;
 
-  private boolean syncFileDescriptor;
   private DataSpec dataSpec;
   private long dataSpecFragmentSize;
   private File file;
@@ -108,18 +107,6 @@ public CacheDataSink(Cache cache, long fragmentSize, int bufferSize) {
     this.cache = Assertions.checkNotNull(cache);
     this.fragmentSize = fragmentSize == C.LENGTH_UNSET ? Long.MAX_VALUE : fragmentSize;
     this.bufferSize = bufferSize;
-    syncFileDescriptor = true;
-  }
-
-  /**
-   * Sets whether file descriptors are synced when closing output streams.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   *
-   * @param syncFileDescriptor Whether file descriptors are synced when closing output streams.
-   */
-  public void experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
-    this.syncFileDescriptor = syncFileDescriptor;
   }
 
   @Override
@@ -208,9 +195,6 @@ private void closeCurrentOutputStream() throws IOException {
     boolean success = false;
     try {
       outputStream.flush();
-      if (syncFileDescriptor) {
-        underlyingFileOutputStream.getFD().sync();
-      }
       success = true;
     } finally {
       Util.closeQuietly(outputStream);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
index 856e9db168..ce9735badd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
@@ -26,8 +26,6 @@
   private final long fragmentSize;
   private final int bufferSize;
 
-  private boolean syncFileDescriptor;
-
   /** @see CacheDataSink#CacheDataSink(Cache, long) */
   public CacheDataSinkFactory(Cache cache, long fragmentSize) {
     this(cache, fragmentSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
@@ -40,20 +38,8 @@ public CacheDataSinkFactory(Cache cache, long fragmentSize, int bufferSize) {
     this.bufferSize = bufferSize;
   }
 
-  /**
-   * See {@link CacheDataSink#experimental_setSyncFileDescriptor(boolean)}.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   */
-  public CacheDataSinkFactory experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
-    this.syncFileDescriptor = syncFileDescriptor;
-    return this;
-  }
-
   @Override
   public DataSink createDataSink() {
-    CacheDataSink dataSink = new CacheDataSink(cache, fragmentSize, bufferSize);
-    dataSink.experimental_setSyncFileDescriptor(syncFileDescriptor);
-    return dataSink;
+    return new CacheDataSink(cache, fragmentSize, bufferSize);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 58b2d176cf..e5df8d55c3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -134,9 +134,9 @@
 
   private @Nullable DataSource currentDataSource;
   private boolean currentDataSpecLengthUnset;
-  private @Nullable Uri uri;
-  private @Nullable Uri actualUri;
-  private @HttpMethod int httpMethod;
+  @Nullable private Uri uri;
+  @Nullable private Uri actualUri;
+  @HttpMethod private int httpMethod;
   private int flags;
   private @Nullable String key;
   private long readPosition;
@@ -319,7 +319,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
       }
       return bytesRead;
     } catch (IOException e) {
-      if (currentDataSpecLengthUnset && isCausedByPositionOutOfRange(e)) {
+      if (currentDataSpecLengthUnset && CacheUtil.isCausedByPositionOutOfRange(e)) {
         setNoBytesRemainingAndMaybeStoreLength();
         return C.RESULT_END_OF_INPUT;
       }
@@ -484,20 +484,6 @@ private static Uri getRedirectedUriOrDefault(Cache cache, String key, Uri defaul
     return redirectedUri != null ? redirectedUri : defaultUri;
   }
 
-  private static boolean isCausedByPositionOutOfRange(IOException e) {
-    Throwable cause = e;
-    while (cause != null) {
-      if (cause instanceof DataSourceException) {
-        int reason = ((DataSourceException) cause).reason;
-        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
-          return true;
-        }
-      }
-      cause = cause.getCause();
-    }
-    return false;
-  }
-
   private boolean isReadingFromUpstream() {
     return !isReadingFromCache();
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index 219d736835..47470c5de7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -20,6 +20,7 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
@@ -78,13 +79,7 @@ public static String generateKey(Uri uri) {
       DataSpec dataSpec, Cache cache, @Nullable CacheKeyFactory cacheKeyFactory) {
     String key = buildCacheKey(dataSpec, cacheKeyFactory);
     long position = dataSpec.absoluteStreamPosition;
-    long requestLength;
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      requestLength = dataSpec.length;
-    } else {
-      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
-      requestLength = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
-    }
+    long requestLength = getRequestLength(dataSpec, cache, key);
     long bytesAlreadyCached = 0;
     long bytesLeft = requestLength;
     while (bytesLeft != 0) {
@@ -179,53 +174,66 @@ public static void cache(
     Assertions.checkNotNull(dataSource);
     Assertions.checkNotNull(buffer);
 
+    String key = buildCacheKey(dataSpec, cacheKeyFactory);
+    long bytesLeft;
     ProgressNotifier progressNotifier = null;
     if (progressListener != null) {
       progressNotifier = new ProgressNotifier(progressListener);
       Pair<Long, Long> lengthAndBytesAlreadyCached = getCached(dataSpec, cache, cacheKeyFactory);
       progressNotifier.init(lengthAndBytesAlreadyCached.first, lengthAndBytesAlreadyCached.second);
+      bytesLeft = lengthAndBytesAlreadyCached.first;
+    } else {
+      bytesLeft = getRequestLength(dataSpec, cache, key);
     }
 
-    String key = buildCacheKey(dataSpec, cacheKeyFactory);
     long position = dataSpec.absoluteStreamPosition;
-    long bytesLeft;
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      bytesLeft = dataSpec.length;
-    } else {
-      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
-      bytesLeft = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
-    }
+    boolean lengthUnset = bytesLeft == C.LENGTH_UNSET;
     while (bytesLeft != 0) {
       throwExceptionIfInterruptedOrCancelled(isCanceled);
       long blockLength =
-          cache.getCachedLength(
-              key, position, bytesLeft != C.LENGTH_UNSET ? bytesLeft : Long.MAX_VALUE);
+          cache.getCachedLength(key, position, lengthUnset ? Long.MAX_VALUE : bytesLeft);
       if (blockLength > 0) {
         // Skip already cached data.
       } else {
         // There is a hole in the cache which is at least "-blockLength" long.
         blockLength = -blockLength;
+        long length = blockLength == Long.MAX_VALUE ? C.LENGTH_UNSET : blockLength;
+        boolean isLastBlock = length == bytesLeft;
         long read =
             readAndDiscard(
                 dataSpec,
                 position,
-                blockLength,
+                length,
                 dataSource,
                 buffer,
                 priorityTaskManager,
                 priority,
                 progressNotifier,
+                isLastBlock,
                 isCanceled);
         if (read < blockLength) {
           // Reached to the end of the data.
-          if (enableEOFException && bytesLeft != C.LENGTH_UNSET) {
+          if (enableEOFException && !lengthUnset) {
             throw new EOFException();
           }
           break;
         }
       }
       position += blockLength;
-      bytesLeft -= bytesLeft == C.LENGTH_UNSET ? 0 : blockLength;
+      if (!lengthUnset) {
+        bytesLeft -= blockLength;
+      }
+    }
+  }
+
+  private static long getRequestLength(DataSpec dataSpec, Cache cache, String key) {
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      return dataSpec.length;
+    } else {
+      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
+      return contentLength == C.LENGTH_UNSET
+          ? C.LENGTH_UNSET
+          : contentLength - dataSpec.absoluteStreamPosition;
     }
   }
 
@@ -242,6 +250,7 @@ public static void cache(
    *     caching.
    * @param priority The priority of this task.
    * @param progressNotifier A notifier through which to report progress updates, or {@code null}.
+   * @param isLastBlock Whether this read block is the last block of the content.
    * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @return Number of read bytes, or 0 if no data is available because the end of the opened range
    *     has been reached.
@@ -255,54 +264,64 @@ private static long readAndDiscard(
       PriorityTaskManager priorityTaskManager,
       int priority,
       @Nullable ProgressNotifier progressNotifier,
+      boolean isLastBlock,
       AtomicBoolean isCanceled)
       throws IOException, InterruptedException {
     long positionOffset = absoluteStreamPosition - dataSpec.absoluteStreamPosition;
+    long initialPositionOffset = positionOffset;
+    long endOffset = length != C.LENGTH_UNSET ? positionOffset + length : C.POSITION_UNSET;
     while (true) {
       if (priorityTaskManager != null) {
         // Wait for any other thread with higher priority to finish its job.
         priorityTaskManager.proceed(priority);
       }
+      throwExceptionIfInterruptedOrCancelled(isCanceled);
       try {
-        throwExceptionIfInterruptedOrCancelled(isCanceled);
-        // Create a new dataSpec setting length to C.LENGTH_UNSET to prevent getting an error in
-        // case the given length exceeds the end of input.
-        dataSpec =
-            new DataSpec(
-                dataSpec.uri,
-                dataSpec.httpMethod,
-                dataSpec.httpBody,
-                absoluteStreamPosition,
-                /* position= */ dataSpec.position + positionOffset,
-                C.LENGTH_UNSET,
-                dataSpec.key,
-                dataSpec.flags);
-        long resolvedLength = dataSource.open(dataSpec);
-        if (progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
+        long resolvedLength = C.LENGTH_UNSET;
+        boolean isDataSourceOpen = false;
+        if (endOffset != C.POSITION_UNSET) {
+          // If a specific length is given, first try to open the data source for that length to
+          // avoid more data then required to be requested. If the given length exceeds the end of
+          // input we will get a "position out of range" error. In that case try to open the source
+          // again with unset length.
+          try {
+            resolvedLength =
+                dataSource.open(dataSpec.subrange(positionOffset, endOffset - positionOffset));
+            isDataSourceOpen = true;
+          } catch (IOException exception) {
+            if (!isLastBlock || !isCausedByPositionOutOfRange(exception)) {
+              throw exception;
+            }
+            Util.closeQuietly(dataSource);
+          }
+        }
+        if (!isDataSourceOpen) {
+          resolvedLength = dataSource.open(dataSpec.subrange(positionOffset, C.LENGTH_UNSET));
+        }
+        if (isLastBlock && progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
           progressNotifier.onRequestLengthResolved(positionOffset + resolvedLength);
         }
-        long totalBytesRead = 0;
-        while (totalBytesRead != length) {
+        while (positionOffset != endOffset) {
           throwExceptionIfInterruptedOrCancelled(isCanceled);
           int bytesRead =
               dataSource.read(
                   buffer,
                   0,
-                  length != C.LENGTH_UNSET
-                      ? (int) Math.min(buffer.length, length - totalBytesRead)
+                  endOffset != C.POSITION_UNSET
+                      ? (int) Math.min(buffer.length, endOffset - positionOffset)
                       : buffer.length);
           if (bytesRead == C.RESULT_END_OF_INPUT) {
             if (progressNotifier != null) {
-              progressNotifier.onRequestLengthResolved(positionOffset + totalBytesRead);
+              progressNotifier.onRequestLengthResolved(positionOffset);
             }
             break;
           }
-          totalBytesRead += bytesRead;
+          positionOffset += bytesRead;
           if (progressNotifier != null) {
             progressNotifier.onBytesCached(bytesRead);
           }
         }
-        return totalBytesRead;
+        return positionOffset - initialPositionOffset;
       } catch (PriorityTaskManager.PriorityTooLowException exception) {
         // catch and try again
       } finally {
@@ -340,6 +359,20 @@ public static void remove(Cache cache, String key) {
     }
   }
 
+  /*package*/ static boolean isCausedByPositionOutOfRange(IOException e) {
+    Throwable cause = e;
+    while (cause != null) {
+      if (cause instanceof DataSourceException) {
+        int reason = ((DataSourceException) cause).reason;
+        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
+          return true;
+        }
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
   private static String buildCacheKey(
       DataSpec dataSpec, @Nullable CacheKeyFactory cacheKeyFactory) {
     return (cacheKeyFactory != null ? cacheKeyFactory : DEFAULT_CACHE_KEY_FACTORY)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index e603f76dbc..61457c308d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -348,8 +348,9 @@ public static int getTrackType(@Nullable String mimeType) {
       case MimeTypes.AUDIO_AC3:
         return C.ENCODING_AC3;
       case MimeTypes.AUDIO_E_AC3:
-      case MimeTypes.AUDIO_E_AC3_JOC:
         return C.ENCODING_E_AC3;
+      case MimeTypes.AUDIO_E_AC3_JOC:
+        return C.ENCODING_E_AC3_JOC;
       case MimeTypes.AUDIO_AC4:
         return C.ENCODING_AC4;
       case MimeTypes.AUDIO_DTS:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index 97bcb68708..86ad6fd6b3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -1713,7 +1713,12 @@ public static int getNetworkType(Context context) {
     if (connectivityManager == null) {
       return C.NETWORK_TYPE_UNKNOWN;
     }
-    networkInfo = connectivityManager.getActiveNetworkInfo();
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (SecurityException e) {
+      // Expected if permission was revoked.
+      return C.NETWORK_TYPE_UNKNOWN;
+    }
     if (networkInfo == null || !networkInfo.isConnected()) {
       return C.NETWORK_TYPE_OFFLINE;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 193fbddfec..8d5b890c7f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -550,8 +550,7 @@ protected void configureCodec(
       MediaCodec codec,
       Format format,
       MediaCrypto crypto,
-      float codecOperatingRate)
-      throws DecoderQueryException {
+      float codecOperatingRate) {
     codecMaxValues = getCodecMaxValues(codecInfo, format, getStreamFormats());
     MediaFormat mediaFormat =
         getMediaFormat(
@@ -680,7 +679,8 @@ protected boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException {
     if (initialPositionUs == C.TIME_UNSET) {
@@ -689,7 +689,7 @@ protected boolean processOutputBuffer(
 
     long presentationTimeUs = bufferPresentationTimeUs - outputStreamOffsetUs;
 
-    if (shouldSkip) {
+    if (isDecodeOnlyBuffer && !isLastBuffer) {
       skipOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -737,10 +737,10 @@ protected boolean processOutputBuffer(
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
+    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs, isLastBuffer)
         && maybeDropBuffersToKeyframe(codec, bufferIndex, presentationTimeUs, positionUs)) {
       return false;
-    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
+    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs, isLastBuffer)) {
       dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -808,8 +808,8 @@ private void notifyFrameMetadataListener(
 
   /**
    * Returns the offset that should be subtracted from {@code bufferPresentationTimeUs} in {@link
-   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, Format)} to
-   * get the playback position with respect to the media.
+   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, boolean,
+   * Format)} to get the playback position with respect to the media.
    */
   protected long getOutputStreamOffsetUs() {
     return outputStreamOffsetUs;
@@ -861,9 +861,11 @@ protected void onProcessedOutputBuffer(long presentationTimeUs) {
    *     indicates that the buffer is late.
    * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
    *     measured at the start of the current iteration of the rendering loop.
+   * @param isLastBuffer Whether the buffer is the last buffer in the current stream.
    */
-  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferLate(earlyUs);
+  protected boolean shouldDropOutputBuffer(
+      long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {
+    return isBufferLate(earlyUs) && !isLastBuffer;
   }
 
   /**
@@ -874,9 +876,11 @@ protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
    *     negative value indicates that the buffer is late.
    * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
    *     measured at the start of the current iteration of the rendering loop.
+   * @param isLastBuffer Whether the buffer is the last buffer in the current stream.
    */
-  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferVeryLate(earlyUs);
+  protected boolean shouldDropBuffersToKeyframe(
+      long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {
+    return isBufferVeryLate(earlyUs) && !isLastBuffer;
   }
 
   /**
@@ -1173,11 +1177,9 @@ protected MediaFormat getMediaFormat(
    * @param format The format for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
   protected CodecMaxValues getCodecMaxValues(
-      MediaCodecInfo codecInfo, Format format, Format[] streamFormats)
-      throws DecoderQueryException {
+      MediaCodecInfo codecInfo, Format format, Format[] streamFormats) {
     int maxWidth = format.width;
     int maxHeight = format.height;
     int maxInputSize = getMaxInputSize(codecInfo, format);
@@ -1227,17 +1229,15 @@ protected CodecMaxValues getCodecMaxValues(
   }
 
   /**
-   * Returns a maximum video size to use when configuring a codec for {@code format} in a way
-   * that will allow possible adaptation to other compatible formats that are expected to have the
-   * same aspect ratio, but whose sizes are unknown.
+   * Returns a maximum video size to use when configuring a codec for {@code format} in a way that
+   * will allow possible adaptation to other compatible formats that are expected to have the same
+   * aspect ratio, but whose sizes are unknown.
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format for which the codec is being configured.
    * @return The maximum video size to use, or null if the size of {@code format} should be used.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
-      throws DecoderQueryException {
+  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format) {
     boolean isVerticalVideo = format.height > format.width;
     int formatLongEdgePx = isVerticalVideo ? format.height : format.width;
     int formatShortEdgePx = isVerticalVideo ? format.width : format.height;
@@ -1255,12 +1255,18 @@ private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
           return alignedSize;
         }
       } else {
-        // Conservatively assume the codec requires 16px width and height alignment.
-        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
-        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
-        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
-          return new Point(isVerticalVideo ? shortEdgePx : longEdgePx,
-              isVerticalVideo ? longEdgePx : shortEdgePx);
+        try {
+          // Conservatively assume the codec requires 16px width and height alignment.
+          longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
+          shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
+          if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
+            return new Point(
+                isVerticalVideo ? shortEdgePx : longEdgePx,
+                isVerticalVideo ? longEdgePx : shortEdgePx);
+          }
+        } catch (DecoderQueryException e) {
+          // We tried our best. Give up!
+          return null;
         }
       }
     }
diff --git a/library/core/src/test/assets/webvtt/with_css_styles b/library/core/src/test/assets/webvtt/with_css_styles
index 2056d50adf..c2d47d8192 100644
--- a/library/core/src/test/assets/webvtt/with_css_styles
+++ b/library/core/src/test/assets/webvtt/with_css_styles
@@ -13,8 +13,6 @@ STYLE
 ::cue(#id2) {
   color: peachpuff;
 }
-
-STYLE
 ::cue(v[voice="LaGord"]) { background-color: lime }
 
 STYLE
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
index 9cbcea5814..4602d172a6 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
@@ -48,6 +48,17 @@ public void decode_titleOnly() {
     assertThat(streamInfo.url).isNull();
   }
 
+  @Test
+  public void decode_emptyTitle() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEmpty();
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
   @Test
   public void decode_semiColonInTitle() {
     IcyDecoder decoder = new IcyDecoder();
@@ -70,6 +81,17 @@ public void decode_quoteInTitle() {
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
 
+  @Test
+  public void decode_lineTerminatorInTitle() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='test\r\ntitle';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEqualTo("test\r\ntitle");
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
   @Test
   public void decode_notIcy() {
     IcyDecoder decoder = new IcyDecoder();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
index 2b9ef11235..de430d1416 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
@@ -243,6 +243,27 @@ public void secondSameRemoveRequestIgnored() throws Throwable {
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
+  @Test
+  public void removeAllDownloads_removesAllDownloads() throws Throwable {
+    // Finish one download and keep one running.
+    DownloadRunner runner1 = new DownloadRunner(uri1);
+    DownloadRunner runner2 = new DownloadRunner(uri2);
+    runner1.postDownloadRequest();
+    runner1.getDownloader(0).unblock();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    runner2.postDownloadRequest();
+
+    runner1.postRemoveAllRequest();
+    runner1.getDownloader(1).unblock();
+    runner2.getDownloader(1).unblock();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+
+    runner1.getTask().assertRemoved();
+    runner2.getTask().assertRemoved();
+    assertThat(downloadManager.getCurrentDownloads()).isEmpty();
+    assertThat(downloadIndex.getDownloads().getCount()).isEqualTo(0);
+  }
+
   @Test
   public void differentDownloadRequestsMerged() throws Throwable {
     DownloadRunner runner = new DownloadRunner(uri1);
@@ -605,6 +626,11 @@ private DownloadRunner postRemoveRequest() {
       return this;
     }
 
+    private DownloadRunner postRemoveAllRequest() {
+      runOnMainThread(() -> downloadManager.removeAllDownloads());
+      return this;
+    }
+
     private DownloadRunner postDownloadRequest(StreamKey... keys) {
       DownloadRequest downloadRequest =
           new DownloadRequest(
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
index 000d0634ce..85af6482c0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
@@ -514,7 +514,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(24f / 100f);
     assertThat(cue.line).isEqualTo(28f / 100f);
     assertThat(cue.size).isEqualTo(51f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(12f / 100f);
 
     cues = subtitle.getCues(4000000);
     assertThat(cues).hasSize(1);
@@ -524,7 +524,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(21f / 100f);
     assertThat(cue.line).isEqualTo(35f / 100f);
     assertThat(cue.size).isEqualTo(57f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(6f / 100f);
 
     cues = subtitle.getCues(7500000);
     assertThat(cues).hasSize(1);
@@ -534,7 +534,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(24f / 100f);
     assertThat(cue.line).isEqualTo(28f / 100f);
     assertThat(cue.size).isEqualTo(51f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(12f / 100f);
   }
 
   @Test
@@ -549,7 +549,7 @@ public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException
     assertThat(cue.position).isEqualTo(307f / 1280f);
     assertThat(cue.line).isEqualTo(562f / 720f);
     assertThat(cue.size).isEqualTo(653f / 1280f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(86f / 720f);
 
     cues = subtitle.getCues(4000000);
     assertThat(cues).hasSize(1);
@@ -559,7 +559,7 @@ public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException
     assertThat(cue.position).isEqualTo(269f / 1280f);
     assertThat(cue.line).isEqualTo(612f / 720f);
     assertThat(cue.size).isEqualTo(730f / 1280f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(43f / 720f);
   }
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
index fb9e1a875f..72be083181 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
@@ -21,6 +21,7 @@
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -87,21 +88,32 @@ public void testGetInputLimit() {
 
   @Test
   public void testParseMethodSimpleInput() {
-    String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     WebvttCssStyle expectedStyle = new WebvttCssStyle();
+    String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     expectedStyle.setFontColor(0xFF000000);
     expectedStyle.setBackgroundColor(0xFFFFEFD5);
-    assertParserProduces(expectedStyle, styleBlock1);
+    assertParserProduces(styleBlock1, expectedStyle);
 
     String styleBlock2 = " ::cue { color : black }\n\n::cue { color : invalid }";
     expectedStyle = new WebvttCssStyle();
     expectedStyle.setFontColor(0xFF000000);
-    assertParserProduces(expectedStyle, styleBlock2);
+    assertParserProduces(styleBlock2, expectedStyle);
 
-    String styleBlock3 = " \n::cue {\n background-color\n:#00fFFe}";
+    String styleBlock3 = "::cue {\n background-color\n:#00fFFe}";
     expectedStyle = new WebvttCssStyle();
     expectedStyle.setBackgroundColor(0xFF00FFFE);
-    assertParserProduces(expectedStyle, styleBlock3);
+    assertParserProduces(styleBlock3, expectedStyle);
+  }
+
+  @Test
+  public void testParseMethodMultipleRulesInBlockInput() {
+    String styleBlock =
+        "::cue {\n background-color\n:#00fFFe}      \n::cue {\n background-color\n:#00000000}\n";
+    WebvttCssStyle expectedStyle = new WebvttCssStyle();
+    expectedStyle.setBackgroundColor(0xFF00FFFE);
+    WebvttCssStyle secondExpectedStyle = new WebvttCssStyle();
+    secondExpectedStyle.setBackgroundColor(0x000000);
+    assertParserProduces(styleBlock, expectedStyle, secondExpectedStyle);
   }
 
   @Test
@@ -116,7 +128,7 @@ public void testMultiplePropertiesInBlock() {
     expectedStyle.setFontFamily("courier");
     expectedStyle.setBold(true);
 
-    assertParserProduces(expectedStyle, styleBlock);
+    assertParserProduces(styleBlock, expectedStyle);
   }
 
   @Test
@@ -128,7 +140,7 @@ public void testRgbaColorExpression() {
     expectedStyle.setBackgroundColor(0x190A0B0C);
     expectedStyle.setFontColor(0xFF010101);
 
-    assertParserProduces(expectedStyle, styleBlock);
+    assertParserProduces(styleBlock, expectedStyle);
   }
 
   @Test
@@ -203,25 +215,29 @@ private void assertInputLimit(String expectedLine, String s) {
     assertThat(input.readLine()).isEqualTo(expectedLine);
   }
 
-  private void assertParserProduces(WebvttCssStyle expected,
-      String styleBlock){
+  private void assertParserProduces(String styleBlock, WebvttCssStyle... expectedStyles) {
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(styleBlock));
-    WebvttCssStyle actualElem = parser.parseBlock(input);
-    assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
-    if (expected.hasBackgroundColor()) {
-      assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
-    }
-    assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
-    if (expected.hasFontColor()) {
-      assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
+    List<WebvttCssStyle> styles = parser.parseBlock(input);
+    assertThat(styles.size()).isEqualTo(expectedStyles.length);
+    for (int i = 0; i < expectedStyles.length; i++) {
+      WebvttCssStyle expected = expectedStyles[i];
+      WebvttCssStyle actualElem = styles.get(i);
+      assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
+      if (expected.hasBackgroundColor()) {
+        assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
+      }
+      assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
+      if (expected.hasFontColor()) {
+        assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
+      }
+      assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
+      assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
+      assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
+      assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
+      assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
+      assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
+      assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
     }
-    assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
-    assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
-    assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
-    assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
-    assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
-    assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
-    assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index 83fe34db97..224b2965ba 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -341,6 +341,76 @@ public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
     assertFixedSelection(result.selections.get(0), trackGroups, formatWithSelectionFlag);
   }
 
+  /** Tests that adaptive audio track selections respect the maximum audio bitrate. */
+  public void testSelectAdaptiveAudioTrackGroupWithMaxBitrate() throws ExoPlaybackException {
+    Format format128k =
+        Format.createAudioSampleFormat(
+            /* id= */ "128",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 128 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    Format format192k =
+        Format.createAudioSampleFormat(
+            /* id= */ "192",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 192 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    Format format256k =
+        Format.createAudioSampleFormat(
+            /* id= */ "256",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 256 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    RendererCapabilities[] rendererCapabilities = {
+      ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES
+    };
+    TrackGroupArray trackGroups =
+        new TrackGroupArray(new TrackGroup(format192k, format128k, format256k));
+
+    TrackSelectorResult result =
+        trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1, 2);
+
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setMaxAudioBitrate(256 * 1024 - 1));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024 - 1));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1);
+
+    trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(10));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1);
+  }
+
   /**
    * Tests that track selector will select audio track with language that match preferred language
    * given by {@link Parameters}.
@@ -893,7 +963,6 @@ public void testTextTrackSelectionFlags() throws ExoPlaybackException {
     Format forcedDefault =
         buildTextFormat("forcedDefault", "eng", C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT);
     Format defaultOnly = buildTextFormat("defaultOnly", "eng", C.SELECTION_FLAG_DEFAULT);
-    Format forcedOnlySpanish = buildTextFormat("forcedOnlySpanish", "spa", C.SELECTION_FLAG_FORCED);
     Format noFlag = buildTextFormat("noFlag", "eng");
 
     RendererCapabilities[] textRendererCapabilities =
diff --git a/library/dash/README.md b/library/dash/README.md
index 7831033b99..1076716684 100644
--- a/library/dash/README.md
+++ b/library/dash/README.md
@@ -6,7 +6,9 @@ play DASH content, instantiate a `DashMediaSource` and pass it to
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.source.dash.*`
   belong to this module.
 
+[Developer Guide]: https://exoplayer.dev/dash.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index c4f61a73cd..f03a443431 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -42,6 +42,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 import java.util.regex.Matcher;
@@ -242,7 +243,7 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, null);
+        segmentBase = parseSegmentTemplate(xpp, null, Collections.emptyList());
       } else {
         maybeSkipTag(xpp);
       }
@@ -323,6 +324,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
                 language,
                 roleDescriptors,
                 accessibilityDescriptors,
+                supplementalProperties,
                 segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
@@ -332,7 +334,8 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+        segmentBase =
+            parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase, supplementalProperties);
       } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
@@ -492,6 +495,7 @@ protected RepresentationInfo parseRepresentation(
       String adaptationSetLanguage,
       List<Descriptor> adaptationSetRoleDescriptors,
       List<Descriptor> adaptationSetAccessibilityDescriptors,
+      List<Descriptor> adaptationSetSupplementalProperties,
       SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
@@ -524,7 +528,9 @@ protected RepresentationInfo parseRepresentation(
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+        segmentBase =
+            parseSegmentTemplate(
+                xpp, (SegmentTemplate) segmentBase, adaptationSetSupplementalProperties);
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentProtection")) {
         Pair<String, SchemeData> contentProtection = parseContentProtection(xpp);
         if (contentProtection.first != null) {
@@ -763,13 +769,19 @@ protected SegmentList buildSegmentList(
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplate parent)
+  protected SegmentTemplate parseSegmentTemplate(
+      XmlPullParser xpp,
+      SegmentTemplate parent,
+      List<Descriptor> adaptationSetSupplementalProperties)
       throws XmlPullParserException, IOException {
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
         parent != null ? parent.presentationTimeOffset : 0);
     long duration = parseLong(xpp, "duration", parent != null ? parent.duration : C.TIME_UNSET);
     long startNumber = parseLong(xpp, "startNumber", parent != null ? parent.startNumber : 1);
+    long endNumber =
+        parseLastSegmentNumberSupplementalProperty(adaptationSetSupplementalProperties);
+
     UrlTemplate mediaTemplate = parseUrlTemplate(xpp, "media",
         parent != null ? parent.mediaTemplate : null);
     UrlTemplate initializationTemplate = parseUrlTemplate(xpp, "initialization",
@@ -794,8 +806,16 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
       timeline = timeline != null ? timeline : parent.segmentTimeline;
     }
 
-    return buildSegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
+    return buildSegmentTemplate(
+        initialization,
+        timescale,
+        presentationTimeOffset,
+        startNumber,
+        endNumber,
+        duration,
+        timeline,
+        initializationTemplate,
+        mediaTemplate);
   }
 
   protected SegmentTemplate buildSegmentTemplate(
@@ -803,12 +823,21 @@ protected SegmentTemplate buildSegmentTemplate(
       long timescale,
       long presentationTimeOffset,
       long startNumber,
+      long endNumber,
       long duration,
       List<SegmentTimelineElement> timeline,
       UrlTemplate initializationTemplate,
       UrlTemplate mediaTemplate) {
-    return new SegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
+    return new SegmentTemplate(
+        initialization,
+        timescale,
+        presentationTimeOffset,
+        startNumber,
+        endNumber,
+        duration,
+        timeline,
+        initializationTemplate,
+        mediaTemplate);
   }
 
   /**
@@ -1445,6 +1474,18 @@ protected static int parseDolbyChannelConfiguration(XmlPullParser xpp) {
     }
   }
 
+  protected static long parseLastSegmentNumberSupplementalProperty(
+      List<Descriptor> supplementalProperties) {
+    for (int i = 0; i < supplementalProperties.size(); i++) {
+      Descriptor descriptor = supplementalProperties.get(i);
+      if ("http://dashif.org/guidelines/last-segment-number"
+          .equalsIgnoreCase(descriptor.schemeIdUri)) {
+        return Long.parseLong(descriptor.value);
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
   /** A parsed Representation element. */
   protected static final class RepresentationInfo {
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
index f033232590..ba4faafd95 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
@@ -277,6 +277,7 @@ public boolean isExplicit() {
 
     /* package */ final UrlTemplate initializationTemplate;
     /* package */ final UrlTemplate mediaTemplate;
+    /* package */ final long endNumber;
 
     /**
      * @param initialization A {@link RangedUri} corresponding to initialization data, if such data
@@ -286,6 +287,9 @@ public boolean isExplicit() {
      * @param presentationTimeOffset The presentation time offset. The value in seconds is the
      *     division of this value and {@code timescale}.
      * @param startNumber The sequence number of the first segment.
+     * @param endNumber The sequence number of the last segment as specified by the
+     *     SupplementalProperty with schemeIdUri="http://dashif.org/guidelines/last-segment-number",
+     *     or {@link C#INDEX_UNSET}.
      * @param duration The duration of each segment in the case of fixed duration segments. The
      *     value in seconds is the division of this value and {@code timescale}. If {@code
      *     segmentTimeline} is non-null then this parameter is ignored.
@@ -302,14 +306,21 @@ public SegmentTemplate(
         long timescale,
         long presentationTimeOffset,
         long startNumber,
+        long endNumber,
         long duration,
         List<SegmentTimelineElement> segmentTimeline,
         UrlTemplate initializationTemplate,
         UrlTemplate mediaTemplate) {
-      super(initialization, timescale, presentationTimeOffset, startNumber,
-          duration, segmentTimeline);
+      super(
+          initialization,
+          timescale,
+          presentationTimeOffset,
+          startNumber,
+          duration,
+          segmentTimeline);
       this.initializationTemplate = initializationTemplate;
       this.mediaTemplate = mediaTemplate;
+      this.endNumber = endNumber;
     }
 
     @Override
@@ -340,6 +351,8 @@ public RangedUri getSegmentUrl(Representation representation, long sequenceNumbe
     public int getSegmentCount(long periodDurationUs) {
       if (segmentTimeline != null) {
         return segmentTimeline.size();
+      } else if (endNumber != C.INDEX_UNSET) {
+        return (int) (endNumber - startNumber + 1);
       } else if (periodDurationUs != C.TIME_UNSET) {
         long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
         return (int) Util.ceilDivide(periodDurationUs, durationUs);
@@ -347,7 +360,6 @@ public int getSegmentCount(long periodDurationUs) {
         return DashSegmentIndex.INDEX_UNBOUNDED;
       }
     }
-
   }
 
   /**
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
index b3a6b8271b..94dae35ed5 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
@@ -35,6 +35,7 @@
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.DownloaderFactory;
 import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
@@ -108,7 +109,7 @@ public void testDownloadRepresentation() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -127,7 +128,7 @@ public void testDownloadRepresentationInSmallParts() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -146,7 +147,7 @@ public void testDownloadRepresentations() throws Exception {
     DashDownloader dashDownloader =
         getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -167,7 +168,7 @@ public void testDownloadAllRepresentations() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -256,7 +257,7 @@ public void testDownloadRepresentationFailure() throws Exception {
       // Expected.
     }
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
index 35db882e2a..280bc45b70 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.scheduler.Requirements;
+import com.google.android.exoplayer2.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.DummyMainThread.TestRunnable;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
@@ -154,7 +155,7 @@ public void testSaveAndLoadActionFile() throws Throwable {
   public void testHandleDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1, fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -162,7 +163,7 @@ public void testHandleMultipleDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1);
     handleDownloadRequest(fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -176,7 +177,7 @@ public void testHandleInterferingDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
diff --git a/library/hls/README.md b/library/hls/README.md
index 1dd1b7a62e..3470c29e3c 100644
--- a/library/hls/README.md
+++ b/library/hls/README.md
@@ -5,7 +5,9 @@ instantiate a `HlsMediaSource` and pass it to `ExoPlayer.prepare`.
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.source.hls.*`
   belong to this module.
 
+[Developer Guide]: https://exoplayer.dev/hls.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index ef233bb566..2cfd14c79d 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -802,7 +802,7 @@ private static Format deriveAudioFormat(
       if (isPrimaryTrackInVariant) {
         channelCount = variantFormat.channelCount;
         selectionFlags = variantFormat.selectionFlags;
-        roleFlags = mediaTagFormat.roleFlags;
+        roleFlags = variantFormat.roleFlags;
         language = variantFormat.language;
         label = variantFormat.label;
       }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 65039b9364..434b6c2011 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -322,6 +322,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     if (enabledTrackGroupCount == 0) {
       chunkSource.reset();
       downstreamTrackFormat = null;
+      pendingResetUpstreamFormats = true;
       mediaChunks.clear();
       if (loader.isLoading()) {
         if (sampleQueuesBuilt) {
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
index 7d77a78316..d06d047f66 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer2.offline.DownloaderFactory;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
@@ -129,12 +130,13 @@ public void testDownloadRepresentation() throws Exception {
 
     assertCachedData(
         cache,
-        fakeDataSet,
-        MASTER_PLAYLIST_URI,
-        MEDIA_PLAYLIST_1_URI,
-        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+        new RequestSet(fakeDataSet)
+            .subset(
+                MASTER_PLAYLIST_URI,
+                MEDIA_PLAYLIST_1_URI,
+                MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts"));
   }
 
   @Test
@@ -186,11 +188,12 @@ public void testDownloadMediaPlaylist() throws Exception {
 
     assertCachedData(
         cache,
-        fakeDataSet,
-        MEDIA_PLAYLIST_1_URI,
-        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+        new RequestSet(fakeDataSet)
+            .subset(
+                MEDIA_PLAYLIST_1_URI,
+                MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts"));
   }
 
   @Test
diff --git a/library/smoothstreaming/README.md b/library/smoothstreaming/README.md
index 4fa24543d6..d53471d17c 100644
--- a/library/smoothstreaming/README.md
+++ b/library/smoothstreaming/README.md
@@ -5,8 +5,10 @@ instantiate a `SsMediaSource` and pass it to `ExoPlayer.prepare`.
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching
   `com.google.android.exoplayer2.source.smoothstreaming.*` belong to this
   module.
 
+[Developer Guide]: https://exoplayer.dev/smoothstreaming.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 66731660f5..39e22f2982 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -586,6 +586,7 @@ private void parseStreamElementStartTag(XmlPullParser parser) throws ParserExcep
       } else {
         subType = parser.getAttributeValue(null, KEY_SUB_TYPE);
       }
+      putNormalizedAttribute(KEY_SUB_TYPE, subType);
       name = parser.getAttributeValue(null, KEY_NAME);
       url = parseRequiredString(parser, KEY_URL);
       maxWidth = parseInt(parser, KEY_MAX_WIDTH, Format.NO_VALUE);
@@ -645,6 +646,7 @@ public Object build() {
     private static final String KEY_CHANNELS = "Channels";
     private static final String KEY_FOUR_CC = "FourCC";
     private static final String KEY_TYPE = "Type";
+    private static final String KEY_SUB_TYPE = "Subtype";
     private static final String KEY_LANGUAGE = "Language";
     private static final String KEY_NAME = "Name";
     private static final String KEY_MAX_WIDTH = "MaxWidth";
@@ -709,6 +711,18 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* roleFlags= */ 0,
                 language);
       } else if (type == C.TRACK_TYPE_TEXT) {
+        String subType = (String) getNormalizedAttribute(KEY_SUB_TYPE);
+        @C.RoleFlags int roleFlags = 0;
+        switch (subType) {
+          case "CAPT":
+            roleFlags = C.ROLE_FLAG_CAPTION;
+            break;
+          case "DESC":
+            roleFlags = C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND;
+            break;
+          default:
+            break;
+        }
         String language = (String) getNormalizedAttribute(KEY_LANGUAGE);
         format =
             Format.createTextContainerFormat(
@@ -719,7 +733,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* codecs= */ null,
                 bitrate,
                 /* selectionFlags= */ 0,
-                /* roleFlags= */ 0,
+                roleFlags,
                 language);
       } else {
         format =
diff --git a/library/ui/README.md b/library/ui/README.md
index 341ea2fb16..16136b3d94 100644
--- a/library/ui/README.md
+++ b/library/ui/README.md
@@ -4,7 +4,9 @@ Provides UI components and resources for use with ExoPlayer.
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ui.*`
   belong to this module.
 
+[Developer Guide]: https://exoplayer.dev/ui-components.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index 49446b25de..6384bf920f 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -40,7 +40,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.media:media:1.0.0'
+    implementation 'androidx.media:media:1.0.1'
     implementation 'androidx.annotation:annotation:1.0.2'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index 328b5d6a49..5c70203788 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -220,11 +220,26 @@
   private @Nullable long[] adGroupTimesMs;
   private @Nullable boolean[] playedAdGroups;
 
-  /** Creates a new time bar. */
+  public DefaultTimeBar(Context context) {
+    this(context, null);
+  }
+
+  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs) {
+    this(context, attrs, 0);
+  }
+
+  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
+    this(context, attrs, defStyleAttr, attrs);
+  }
+
   // Suppress warnings due to usage of View methods in the constructor.
   @SuppressWarnings("nullness:method.invocation.invalid")
-  public DefaultTimeBar(Context context, AttributeSet attrs) {
-    super(context, attrs);
+  public DefaultTimeBar(
+      Context context,
+      @Nullable AttributeSet attrs,
+      int defStyleAttr,
+      @Nullable AttributeSet timebarAttrs) {
+    super(context, attrs, defStyleAttr);
     seekBounds = new Rect();
     progressBar = new Rect();
     bufferedBar = new Rect();
@@ -251,9 +266,9 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     int defaultScrubberEnabledSize = dpToPx(density, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
     int defaultScrubberDisabledSize = dpToPx(density, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
     int defaultScrubberDraggedSize = dpToPx(density, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
-    if (attrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
-          0);
+    if (timebarAttrs != null) {
+      TypedArray a =
+          context.getTheme().obtainStyledAttributes(timebarAttrs, R.styleable.DefaultTimeBar, 0, 0);
       try {
         scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
         if (scrubberDrawable != null) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index a5deb808c1..383d796692 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -28,6 +28,7 @@
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewGroup;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.TextView;
@@ -97,6 +98,9 @@
  *         <li>Corresponding method: None
  *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
+ *   <li>All attributes that can be set on {@link DefaultTimeBar} can also be set on a
+ *       PlayerControlView, and will be propagated to the inflated {@link DefaultTimeBar} unless the
+ *       layout is overridden to specify a custom {@code exo_progress} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
@@ -154,7 +158,15 @@
  *       <ul>
  *         <li>Type: {@link TextView}
  *       </ul>
+ *   <li><b>{@code exo_progress_placeholder}</b> - A placeholder that's replaced with the inflated
+ *       {@link DefaultTimeBar}. Ignored if an {@code exo_progress} view exists.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
  *   <li><b>{@code exo_progress}</b> - Time bar that's updated during playback and allows seeking.
+ *       {@link DefaultTimeBar} attributes set on the PlayerControlView will not be automatically
+ *       propagated through to this instance. If a view exists with this id, any {@code
+ *       exo_progress_placeholder} view will be ignored.
  *       <ul>
  *         <li>Type: {@link TimeBar}
  *       </ul>
@@ -188,6 +200,18 @@
     void onVisibilityChange(int visibility);
   }
 
+  /** Listener to be notified when progress has been updated. */
+  public interface ProgressUpdateListener {
+
+    /**
+     * Called when progress needs to be updated.
+     *
+     * @param position The current position.
+     * @param bufferedPosition The current buffered position.
+     */
+    void onProgressUpdate(long position, long bufferedPosition);
+  }
+
   /** The default fast forward increment, in milliseconds. */
   public static final int DEFAULT_FAST_FORWARD_MS = 15000;
   /** The default rewind increment, in milliseconds. */
@@ -235,7 +259,8 @@
 
   @Nullable private Player player;
   private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
-  private VisibilityListener visibilityListener;
+  @Nullable private VisibilityListener visibilityListener;
+  @Nullable private ProgressUpdateListener progressUpdateListener;
   @Nullable private PlaybackPreparer playbackPreparer;
 
   private boolean isAttachedToWindow;
@@ -317,9 +342,27 @@ public PlayerControlView(
     LayoutInflater.from(context).inflate(controllerLayoutId, this);
     setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
 
+    TimeBar customTimeBar = findViewById(R.id.exo_progress);
+    View timeBarPlaceholder = findViewById(R.id.exo_progress_placeholder);
+    if (customTimeBar != null) {
+      timeBar = customTimeBar;
+    } else if (timeBarPlaceholder != null) {
+      // Propagate attrs as timebarAttrs so that DefaultTimeBar's custom attributes are transferred,
+      // but standard attributes (e.g. background) are not.
+      DefaultTimeBar defaultTimeBar = new DefaultTimeBar(context, null, 0, playbackAttrs);
+      defaultTimeBar.setId(R.id.exo_progress);
+      defaultTimeBar.setLayoutParams(timeBarPlaceholder.getLayoutParams());
+      ViewGroup parent = ((ViewGroup) timeBarPlaceholder.getParent());
+      int timeBarIndex = parent.indexOfChild(timeBarPlaceholder);
+      parent.removeView(timeBarPlaceholder);
+      parent.addView(defaultTimeBar, timeBarIndex);
+      timeBar = defaultTimeBar;
+    } else {
+      timeBar = null;
+    }
     durationView = findViewById(R.id.exo_duration);
     positionView = findViewById(R.id.exo_position);
-    timeBar = findViewById(R.id.exo_progress);
+
     if (timeBar != null) {
       timeBar.addListener(componentListener);
     }
@@ -454,6 +497,15 @@ public void setVisibilityListener(VisibilityListener listener) {
     this.visibilityListener = listener;
   }
 
+  /**
+   * Sets the {@link ProgressUpdateListener}.
+   *
+   * @param listener The listener to be notified about when progress is updated.
+   */
+  public void setProgressUpdateListener(@Nullable ProgressUpdateListener listener) {
+    this.progressUpdateListener = listener;
+  }
+
   /**
    * Sets the {@link PlaybackPreparer}.
    *
@@ -855,6 +907,9 @@ private void updateProgress() {
       timeBar.setPosition(position);
       timeBar.setBufferedPosition(bufferedPosition);
     }
+    if (progressUpdateListener != null) {
+      progressUpdateListener.onProgressUpdate(position, bufferedPosition);
+    }
 
     // Cancel any pending updates and schedule a new one if necessary.
     removeCallbacks(updateProgressAction);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index 1dbd696b12..cedd3dbec5 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -966,7 +966,8 @@ private void stopNotification(boolean dismissedByUser) {
       @Nullable NotificationCompat.Builder builder,
       boolean ongoing,
       @Nullable Bitmap largeIcon) {
-    if (player.getPlaybackState() == Player.STATE_IDLE) {
+    if (player.getPlaybackState() == Player.STATE_IDLE
+        && (player.getCurrentTimeline().isEmpty() || playbackPreparer == null)) {
       builderActions = null;
       return null;
     }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 93461c1b24..e6bc1a6a71 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -35,7 +35,6 @@
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
-import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.TextureView;
 import android.view.View;
@@ -50,7 +49,6 @@
 import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
-import com.google.android.exoplayer2.Player.VideoComponent;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -165,9 +163,10 @@
  *         <li>Corresponding method: None
  *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
- *   <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
- *       PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
- *       layout is overridden to specify a custom {@code exo_controller} (see below).
+ *   <li>All attributes that can be set on {@link PlayerControlView} and {@link DefaultTimeBar} can
+ *       also be set on a PlayerView, and will be propagated to the inflated {@link
+ *       PlayerControlView} unless the layout is overridden to specify a custom {@code
+ *       exo_controller} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
@@ -217,9 +216,10 @@
  *         <li>Type: {@link View}
  *       </ul>
  *   <li><b>{@code exo_controller}</b> - An already inflated {@link PlayerControlView}. Allows use
- *       of a custom extension of {@link PlayerControlView}. Note that attributes such as {@code
- *       rewind_increment} will not be automatically propagated through to this instance. If a view
- *       exists with this id, any {@code exo_controller_placeholder} view will be ignored.
+ *       of a custom extension of {@link PlayerControlView}. {@link PlayerControlView} and {@link
+ *       DefaultTimeBar} attributes set on the PlayerView will not be automatically propagated
+ *       through to this instance. If a view exists with this id, any {@code
+ *       exo_controller_placeholder} view will be ignored.
  *       <ul>
  *         <li>Type: {@link PlayerControlView}
  *       </ul>
@@ -303,6 +303,7 @@
   private boolean controllerHideDuringAds;
   private boolean controllerHideOnTouch;
   private int textureViewRotation;
+  private boolean isTouching;
 
   public PlayerView(Context context) {
     this(context, null);
@@ -405,7 +406,6 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
           break;
         case SURFACE_TYPE_MONO360_VIEW:
           SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
-          sphericalSurfaceView.setSurfaceListener(componentListener);
           sphericalSurfaceView.setSingleTapListener(componentListener);
           surfaceView = sphericalSurfaceView;
           break;
@@ -459,8 +459,9 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       this.controller = customController;
     } else if (controllerPlaceholder != null) {
       // Propagate attrs as playbackAttrs so that PlayerControlView's custom attributes are
-      // transferred, but standard FrameLayout attributes (e.g. background) are not.
+      // transferred, but standard attributes (e.g. background) are not.
       this.controller = new PlayerControlView(context, null, 0, attrs);
+      controller.setId(R.id.exo_controller);
       controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
       ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
       int controllerIndex = parent.indexOfChild(controllerPlaceholder);
@@ -771,11 +772,20 @@ public boolean dispatchKeyEvent(KeyEvent event) {
     if (player != null && player.isPlayingAd()) {
       return super.dispatchKeyEvent(event);
     }
-    boolean isDpadWhenControlHidden =
-        isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
-    boolean handled =
-        isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-    if (handled) {
+
+    boolean isDpadAndUseController = isDpadKey(event.getKeyCode()) && useController;
+    boolean handled = false;
+    if (isDpadAndUseController && !controller.isVisible()) {
+      // Handle the key event by showing the controller.
+      maybeShowController(true);
+      handled = true;
+    } else if (dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event)) {
+      // The key event was handled as a media key or by the super class. We should also show the
+      // controller, or extend its show timeout if already visible.
+      maybeShowController(true);
+      handled = true;
+    } else if (isDpadAndUseController) {
+      // The key event wasn't handled, but we should extend the controller's show timeout.
       maybeShowController(true);
     }
     return handled;
@@ -1039,11 +1049,24 @@ public SubtitleView getSubtitleView() {
   }
 
   @Override
-  public boolean onTouchEvent(MotionEvent ev) {
-    if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+  public boolean onTouchEvent(MotionEvent event) {
+    if (!useController || player == null) {
       return false;
     }
-    return performClick();
+    switch (event.getAction()) {
+      case MotionEvent.ACTION_DOWN:
+        isTouching = true;
+        return true;
+      case MotionEvent.ACTION_UP:
+        if (isTouching) {
+          isTouching = false;
+          performClick();
+          return true;
+        }
+        return false;
+      default:
+        return false;
+    }
   }
 
   @Override
@@ -1130,9 +1153,6 @@ public ViewGroup getAdViewGroup() {
   // Internal methods.
 
   private boolean toggleControllerVisibility() {
-    if (!useController || player == null) {
-      return false;
-    }
     if (!controller.isVisible()) {
       maybeShowController(true);
     } else if (controllerHideOnTouch) {
@@ -1359,7 +1379,6 @@ private boolean isDpadKey(int keyCode) {
           TextOutput,
           VideoListener,
           OnLayoutChangeListener,
-          SphericalSurfaceView.SurfaceListener,
           SingleTapListener {
 
     // TextOutput implementation
@@ -1449,22 +1468,13 @@ public void onLayoutChange(
       applyTextureViewRotation((TextureView) view, textureViewRotation);
     }
 
-    // SphericalSurfaceView.SurfaceTextureListener implementation
-
-    @Override
-    public void surfaceChanged(@Nullable Surface surface) {
-      if (player != null) {
-        VideoComponent videoComponent = player.getVideoComponent();
-        if (videoComponent != null) {
-          videoComponent.setVideoSurface(surface);
-        }
-      }
-    }
-
     // SingleTapListener implementation
 
     @Override
     public boolean onSingleTapUp(MotionEvent e) {
+      if (!useController || player == null) {
+        return false;
+      }
       return toggleControllerVisibility();
     }
   }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index 4f22362de6..9ed1bbd006 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -362,10 +362,16 @@ private void setupBitmapLayout() {
     int width = Math.round(parentWidth * cueSize);
     int height = cueBitmapHeight != Cue.DIMEN_UNSET ? Math.round(parentHeight * cueBitmapHeight)
         : Math.round(width * ((float) cueBitmap.getHeight() / cueBitmap.getWidth()));
-    int x = Math.round(cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width)
-        : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
-    int y = Math.round(cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - height)
-        : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
+    int x =
+        Math.round(
+            cuePositionAnchor == Cue.ANCHOR_TYPE_END
+                ? (anchorX - width)
+                : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
+    int y =
+        Math.round(
+            cueLineAnchor == Cue.ANCHOR_TYPE_END
+                ? (anchorY - height)
+                : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
     bitmapRect = new Rect(x, y, x + width, y + height);
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
index 1029a28323..02b3043665 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
@@ -53,20 +53,6 @@
  */
 public final class SphericalSurfaceView extends GLSurfaceView {
 
-  /**
-   * This listener can be used to be notified when the {@link Surface} associated with this view is
-   * changed.
-   */
-  public interface SurfaceListener {
-    /**
-     * Invoked when the surface is changed or there isn't one anymore. Any previous surface
-     * shouldn't be used after this call.
-     *
-     * @param surface The new surface or null if there isn't one anymore.
-     */
-    void surfaceChanged(@Nullable Surface surface);
-  }
-
   // Arbitrary vertical field of view.
   private static final int FIELD_OF_VIEW_DEGREES = 90;
   private static final float Z_NEAR = .1f;
@@ -84,7 +70,6 @@
   private final Handler mainHandler;
   private final TouchTracker touchTracker;
   private final SceneRenderer scene;
-  private @Nullable SurfaceListener surfaceListener;
   private @Nullable SurfaceTexture surfaceTexture;
   private @Nullable Surface surface;
   private @Nullable Player.VideoComponent videoComponent;
@@ -156,15 +141,6 @@ public void setVideoComponent(@Nullable Player.VideoComponent newVideoComponent)
     }
   }
 
-  /**
-   * Sets the {@link SurfaceListener} used to listen to surface events.
-   *
-   * @param listener The listener for surface events.
-   */
-  public void setSurfaceListener(@Nullable SurfaceListener listener) {
-    surfaceListener = listener;
-  }
-
   /** Sets the {@link SingleTapListener} used to listen to single tap events on this view. */
   public void setSingleTapListener(@Nullable SingleTapListener listener) {
     touchTracker.setSingleTapListener(listener);
@@ -196,8 +172,8 @@ protected void onDetachedFromWindow() {
     mainHandler.post(
         () -> {
           if (surface != null) {
-            if (surfaceListener != null) {
-              surfaceListener.surfaceChanged(null);
+            if (videoComponent != null) {
+              videoComponent.clearVideoSurface(surface);
             }
             releaseSurface(surfaceTexture, surface);
             surfaceTexture = null;
@@ -214,8 +190,8 @@ private void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture) {
           Surface oldSurface = this.surface;
           this.surfaceTexture = surfaceTexture;
           this.surface = new Surface(surfaceTexture);
-          if (surfaceListener != null) {
-            surfaceListener.surfaceChanged(surface);
+          if (videoComponent != null) {
+            videoComponent.setVideoSurface(surface);
           }
           releaseSurface(oldSurfaceTexture, oldSurface);
         });
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index ed2fb8e2b2..027e57ee92 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -76,8 +76,7 @@
       android:includeFontPadding="false"
       android:textColor="#FFBEBEBE"/>
 
-    <com.google.android.exoplayer2.ui.DefaultTimeBar
-      android:id="@id/exo_progress"
+    <View android:id="@id/exo_progress_placeholder"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="26dp"/>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index f4a7976ebd..706fba0e0b 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -24,25 +24,43 @@
     <enum name="zoom" value="4"/>
   </attr>
 
-  <!-- Must be kept in sync with SimpleExoPlayerView -->
+  <!-- Must be kept in sync with PlayerView -->
   <attr name="surface_type" format="enum">
     <enum name="none" value="0"/>
     <enum name="surface_view" value="1"/>
     <enum name="texture_view" value="2"/>
     <enum name="spherical_view" value="3"/>
   </attr>
-  <attr name="show_timeout" format="integer"/>
-  <attr name="rewind_increment" format="integer"/>
-  <attr name="fastforward_increment" format="integer"/>
-  <attr name="player_layout_id" format="reference"/>
-  <attr name="controller_layout_id" format="reference"/>
+
+  <!-- Must be kept in sync with RepeatModeUtil -->
   <attr name="repeat_toggle_modes">
     <flag name="none" value="0"/>
     <flag name="one" value="1"/>
     <flag name="all" value="2"/>
   </attr>
+
+  <!-- PlayerControlView attributes -->
+  <attr name="show_timeout" format="integer"/>
+  <attr name="rewind_increment" format="integer"/>
+  <attr name="fastforward_increment" format="integer"/>
   <attr name="show_shuffle_button" format="boolean"/>
   <attr name="time_bar_min_update_interval" format="integer"/>
+  <attr name="controller_layout_id" format="reference"/>
+
+  <!-- DefaultTimeBar attributes -->
+  <attr name="bar_height" format="dimension"/>
+  <attr name="touch_target_height" format="dimension"/>
+  <attr name="ad_marker_width" format="dimension"/>
+  <attr name="scrubber_enabled_size" format="dimension"/>
+  <attr name="scrubber_disabled_size" format="dimension"/>
+  <attr name="scrubber_dragged_size" format="dimension"/>
+  <attr name="scrubber_drawable" format="reference"/>
+  <attr name="played_color" format="color"/>
+  <attr name="scrubber_color" format="color"/>
+  <attr name="buffered_color" format="color"/>
+  <attr name="unplayed_color" format="color"/>
+  <attr name="ad_marker_color" format="color"/>
+  <attr name="played_ad_marker_color" format="color"/>
 
   <declare-styleable name="PlayerView">
     <attr name="use_artwork" format="boolean"/>
@@ -58,9 +76,11 @@
       <enum name="always" value="2"/>
     </attr>
     <attr name="keep_content_on_player_reset" format="boolean"/>
-    <attr name="resize_mode"/>
+    <attr name="player_layout_id" format="reference"/>
+
     <attr name="surface_type"/>
-    <attr name="player_layout_id"/>
+    <!-- AspectRatioFrameLayout attributes -->
+    <attr name="resize_mode"/>
     <!-- PlayerControlView attributes -->
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
@@ -69,6 +89,20 @@
     <attr name="show_shuffle_button"/>
     <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
+    <!-- DefaultTimeBar attributes -->
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
   <declare-styleable name="AspectRatioFrameLayout">
@@ -83,22 +117,36 @@
     <attr name="show_shuffle_button"/>
     <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
+    <!-- DefaultTimeBar attributes -->
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
   <declare-styleable name="DefaultTimeBar">
-    <attr name="bar_height" format="dimension"/>
-    <attr name="touch_target_height" format="dimension"/>
-    <attr name="ad_marker_width" format="dimension"/>
-    <attr name="scrubber_enabled_size" format="dimension"/>
-    <attr name="scrubber_disabled_size" format="dimension"/>
-    <attr name="scrubber_dragged_size" format="dimension"/>
-    <attr name="scrubber_drawable" format="reference"/>
-    <attr name="played_color" format="color"/>
-    <attr name="scrubber_color" format="color"/>
-    <attr name="buffered_color" format="color"/>
-    <attr name="unplayed_color" format="color"/>
-    <attr name="ad_marker_color" format="color"/>
-    <attr name="played_ad_marker_color" format="color"/>
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
 </resources>
diff --git a/library/ui/src/main/res/values/ids.xml b/library/ui/src/main/res/values/ids.xml
index e57301f946..17b55cd731 100644
--- a/library/ui/src/main/res/values/ids.xml
+++ b/library/ui/src/main/res/values/ids.xml
@@ -33,6 +33,7 @@
   <item name="exo_repeat_toggle" type="id"/>
   <item name="exo_duration" type="id"/>
   <item name="exo_position" type="id"/>
+  <item name="exo_progress_placeholder" type="id"/>
   <item name="exo_progress" type="id"/>
   <item name="exo_buffering" type="id"/>
   <item name="exo_error_message" type="id"/>
diff --git a/publish.gradle b/publish.gradle
index 85cf87aa85..8cfc2b2ea1 100644
--- a/publish.gradle
+++ b/publish.gradle
@@ -23,6 +23,21 @@ if (project.ext.has("exoplayerPublishEnabled")
         groupId = 'com.google.android.exoplayer'
         website = 'https://github.com/google/ExoPlayer'
     }
+
+    gradle.taskGraph.whenReady { taskGraph ->
+        project.tasks
+                .findAll { task -> task.name.contains("generatePomFileFor") }
+                .forEach { task ->
+                    task.doLast {
+                        task.outputs.files
+                                .filter { File file ->
+                                    file.path.contains("publications") \
+                                        && file.name.matches("^pom-.+\\.xml\$")
+                                }
+                                .forEach { File file -> addLicense(file) }
+                    }
+                }
+    }
 }
 
 def getBintrayRepo() {
@@ -30,3 +45,24 @@ def getBintrayRepo() {
         property('publicRepo').toBoolean()
     return publicRepo ? 'exoplayer' : 'exoplayer-test'
 }
+
+static void addLicense(File pom) {
+    def licenseNode = new Node(null, "license")
+    licenseNode.append(
+        new Node(null, "name", "The Apache Software License, Version 2.0"))
+    licenseNode.append(
+        new Node(null, "url", "http://www.apache.org/licenses/LICENSE-2.0.txt"))
+    licenseNode.append(new Node(null, "distribution", "repo"))
+    def licensesNode = new Node(null, "licenses")
+    licensesNode.append(licenseNode)
+
+    def xml = new XmlParser().parse(pom)
+    xml.append(licensesNode)
+
+    def writer = new PrintWriter(new FileWriter(pom))
+    writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
+    def printer = new XmlNodePrinter(writer)
+    printer.preserveWhitespace = true
+    printer.print(xml)
+    writer.close()
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
index 70059114db..8b11a89d8d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
@@ -30,7 +30,6 @@
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
-import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.nio.ByteBuffer;
@@ -55,6 +54,7 @@ protected void buildVideoRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
       long allowedVideoJoiningTimeMs,
@@ -113,8 +113,7 @@ protected void configureCodec(
         MediaCodec codec,
         Format format,
         MediaCrypto crypto,
-        float operatingRate)
-        throws DecoderQueryException {
+        float operatingRate) {
       // If the codec is being initialized whilst the renderer is started, default behavior is to
       // render the first frame (i.e. the keyframe before the current position), then drop frames up
       // to the current playback position. For test runs that place a maximum limit on the number of
@@ -164,14 +163,15 @@ protected boolean processOutputBuffer(
         int bufferIndex,
         int bufferFlags,
         long bufferPresentationTimeUs,
-        boolean shouldSkip,
+        boolean isDecodeOnlyBuffer,
+        boolean isLastBuffer,
         Format format)
         throws ExoPlaybackException {
       if (skipToPositionBeforeRenderingFirstFrame && bufferPresentationTimeUs < positionUs) {
         // After the codec has been initialized, don't render the first frame until we've caught up
         // to the playback position. Else test runs on devices that do not support dummy surface
         // will drop frames between rendering the first one and catching up [Internal: b/66494991].
-        shouldSkip = true;
+        isDecodeOnlyBuffer = true;
       }
       return super.processOutputBuffer(
           positionUs,
@@ -181,7 +181,8 @@ protected boolean processOutputBuffer(
           bufferIndex,
           bufferFlags,
           bufferPresentationTimeUs,
-          shouldSkip,
+          isDecodeOnlyBuffer,
+          isLastBuffer,
           format);
     }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 73e8ac4f3e..39429a8fa1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -166,7 +166,8 @@ public void runTest(
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     requestWindowFeature(Window.FEATURE_NO_TITLE);
-    setContentView(getResources().getIdentifier("host_activity", "layout", getPackageName()));
+    setContentView(
+        getResources().getIdentifier("exo_testutils_host_activity", "layout", getPackageName()));
     surfaceView = findViewById(
         getResources().getIdentifier("surface_view", "id", getPackageName()));
     surfaceView.getHolder().addCallback(this);
diff --git a/testutils/src/main/res/layout/host_activity.xml b/testutils/src/main/res/layout/exo_testutils_host_activity.xml
similarity index 100%
rename from testutils/src/main/res/layout/host_activity.xml
rename to testutils/src/main/res/layout/exo_testutils_host_activity.xml
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
index 664532d3ff..00c9e60bd5 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
@@ -33,58 +33,89 @@
 /** Assertion methods for {@link Cache}. */
 public final class CacheAsserts {
 
-  /**
-   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
-    ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    Uri[] uris = new Uri[allData.size()];
-    for (int i = 0; i < allData.size(); i++) {
-      uris[i] = allData.get(i).uri;
+  /** Defines a set of data requests. */
+  public static final class RequestSet {
+
+    private final FakeDataSet fakeDataSet;
+    private DataSpec[] dataSpecs;
+
+    public RequestSet(FakeDataSet fakeDataSet) {
+      this.fakeDataSet = fakeDataSet;
+      ArrayList<FakeData> allData = fakeDataSet.getAllData();
+      dataSpecs = new DataSpec[allData.size()];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(allData.get(i).uri);
+      }
     }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
 
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
-      throws IOException {
-    Uri[] uris = new Uri[uriStrings.length];
-    for (int i = 0; i < uriStrings.length; i++) {
-      uris[i] = Uri.parse(uriStrings[i]);
+    public RequestSet subset(String... uriStrings) {
+      dataSpecs = new DataSpec[uriStrings.length];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(Uri.parse(uriStrings[i]));
+      }
+      return this;
+    }
+
+    public RequestSet subset(Uri... uris) {
+      dataSpecs = new DataSpec[uris.length];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(uris[i]);
+      }
+      return this;
+    }
+
+    public RequestSet subset(DataSpec... dataSpecs) {
+      this.dataSpecs = dataSpecs;
+      return this;
+    }
+
+    public int getCount() {
+      return dataSpecs.length;
+    }
+
+    public byte[] getData(int i) {
+      return fakeDataSet.getData(dataSpecs[i].uri).getData();
+    }
+
+    public DataSpec getDataSpec(int i) {
+      return dataSpecs[i];
+    }
+
+    public RequestSet useBoundedDataSpecFor(String uriString) {
+      FakeData data = fakeDataSet.getData(uriString);
+      for (int i = 0; i < dataSpecs.length; i++) {
+        DataSpec spec = dataSpecs[i];
+        if (spec.uri.getPath().equals(uriString)) {
+          dataSpecs[i] = spec.subrange(0, data.getData().length);
+          return this;
+        }
+      }
+      throw new IllegalStateException();
     }
-    assertCachedData(cache, fakeDataSet, uris);
   }
 
   /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   * Asserts that the cache contains necessary data for the {@code requestSet}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
+  public static void assertCachedData(Cache cache, RequestSet requestSet) throws IOException {
     int totalLength = 0;
-    for (Uri uri : uris) {
-      byte[] data = fakeDataSet.getData(uri).getData();
-      assertDataCached(cache, uri, data);
+    for (int i = 0; i < requestSet.getCount(); i++) {
+      byte[] data = requestSet.getData(i);
+      assertDataCached(cache, requestSet.getDataSpec(i), data);
       totalLength += data.length;
     }
     assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
   }
 
   /**
-   * Asserts that the cache contains the given data for {@code uriString}.
+   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
-  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    DataSpec dataSpec = new DataSpec(uri);
-    assertDataCached(cache, dataSpec, expected);
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
+    assertCachedData(cache, new RequestSet(fakeDataSet));
   }
 
   /**
@@ -95,15 +126,18 @@ public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throw
   public static void assertDataCached(Cache cache, DataSpec dataSpec, byte[] expected)
       throws IOException {
     DataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    dataSource.open(dataSpec);
+    byte[] bytes;
     try {
-      byte[] bytes = TestUtil.readToEnd(dataSource);
-      assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
-          .that(bytes)
-          .isEqualTo(expected);
+      dataSource.open(dataSpec);
+      bytes = TestUtil.readToEnd(dataSource);
+    } catch (IOException e) {
+      throw new IOException("Opening/reading cache failed: " + dataSpec, e);
     } finally {
       dataSource.close();
     }
+    assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
+        .that(bytes)
+        .isEqualTo(expected);
   }
 
   /**
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
index 6669504c07..fd7be241df 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
@@ -27,7 +27,7 @@
 /** Fake {@link MediaChunk}. */
 public final class FakeMediaChunk extends MediaChunk {
 
-  private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT", null);
+  private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT");
 
   public FakeMediaChunk(Format trackFormat, long startTimeUs, long endTimeUs) {
     this(new DataSpec(Uri.EMPTY), trackFormat, startTimeUs, endTimeUs);
