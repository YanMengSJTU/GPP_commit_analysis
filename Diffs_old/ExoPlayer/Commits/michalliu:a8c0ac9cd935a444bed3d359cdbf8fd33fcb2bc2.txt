diff --git a/.gitignore b/.gitignore
index 8af9c0b3bb..26d3e3980c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,6 +39,7 @@ proguard-project.txt
 
 # Other
 .DS_Store
+cmake-build-debug
 dist
 tmp
 
diff --git a/.hgignore b/.hgignore
new file mode 100644
index 0000000000..f7c3656f65
--- /dev/null
+++ b/.hgignore
@@ -0,0 +1,71 @@
+# Mercurial's .hgignore files can only be used in the root directory.
+# You can still apply these rules by adding
+# include:path/to/this/directory/.hgignore to the top-level .hgignore file.
+
+# Ensure same syntax as in .gitignore can be used
+syntax:glob
+
+# Android generated
+bin
+gen
+libs
+obj
+lint.xml
+
+# IntelliJ IDEA
+.idea
+*.iml
+*.ipr
+*.iws
+classes
+gen-external-apklibs
+
+# Eclipse
+.project
+.classpath
+.settings
+.checkstyle
+.cproject
+
+# Gradle
+.gradle
+build
+buildout
+out
+
+# Maven
+target
+release.properties
+pom.xml.*
+
+# Ant
+ant.properties
+local.properties
+proguard.cfg
+proguard-project.txt
+
+# Other
+.DS_Store
+cmake-build-debug
+dist
+tmp
+
+# VP9 extension
+extensions/vp9/src/main/jni/libvpx
+extensions/vp9/src/main/jni/libvpx_android_configs
+extensions/vp9/src/main/jni/libyuv
+
+# Opus extension
+extensions/opus/src/main/jni/libopus
+
+# FLAC extension
+extensions/flac/src/main/jni/flac
+
+# FFmpeg extension
+extensions/ffmpeg/src/main/jni/ffmpeg
+
+# Cronet extension
+extensions/cronet/jniLibs/*
+!extensions/cronet/jniLibs/README.md
+extensions/cronet/libs/*
+!extensions/cronet/libs/README.md
diff --git a/README.md b/README.md
index 92b15d7c62..ecfe3eb96f 100644
--- a/README.md
+++ b/README.md
@@ -42,18 +42,18 @@ Next add a gradle compile dependency to the `build.gradle` file of your app
 module. The following will add a dependency to the full library:
 
 ```gradle
-compile 'com.google.android.exoplayer:exoplayer:r2.X.X'
+compile 'com.google.android.exoplayer:exoplayer:2.X.X'
 ```
 
-where `r2.X.X` is your preferred version. Alternatively, you can depend on only
+where `2.X.X` is your preferred version. Alternatively, you can depend on only
 the library modules that you actually need. For example the following will add
 dependencies on the Core, DASH and UI library modules, as might be required for
 an app that plays DASH content:
 
 ```gradle
-compile 'com.google.android.exoplayer:exoplayer-core:r2.X.X'
-compile 'com.google.android.exoplayer:exoplayer-dash:r2.X.X'
-compile 'com.google.android.exoplayer:exoplayer-ui:r2.X.X'
+compile 'com.google.android.exoplayer:exoplayer-core:2.X.X'
+compile 'com.google.android.exoplayer:exoplayer-dash:2.X.X'
+compile 'com.google.android.exoplayer:exoplayer-ui:2.X.X'
 ```
 
 The available library modules are listed below. Adding a dependency to the full
@@ -69,7 +69,7 @@ individually.
 In addition to library modules, ExoPlayer has multiple extension modules that
 depend on external libraries to provide additional functionality. Some
 extensions are available from JCenter, whereas others must be built manaully.
-Browse the [extensions directory] and their individual READMEs for details.
+Browse the [extensions directory][] and their individual READMEs for details.
 
 More information on the library and extension modules that are available from
 JCenter can be found on [Bintray][].
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index c63a20ba94..579c2a92ac 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,93 @@
 # Release notes #
 
+### 2.6.0 ###
+
+* Removed "r" prefix from versions. This release is "2.6.0", not "r2.6.0".
+* New `Player.DefaultEventListener` abstract class can be extended to avoid
+  having to implement all methods defined by `Player.EventListener`.
+* Added a reason to `EventListener.onPositionDiscontinuity`
+  ([#3252](https://github.com/google/ExoPlayer/issues/3252)).
+* New `setShuffleModeEnabled` method for enabling shuffled playback.
+* SimpleExoPlayer: Support for multiple video, text and metadata outputs.
+* Support for `Renderer`s that don't consume any media
+  ([#3212](https://github.com/google/ExoPlayer/issues/3212)).
+* Fix reporting of internal position discontinuities via
+  `Player.onPositionDiscontinuity`. `DISCONTINUITY_REASON_SEEK_ADJUSTMENT` is
+  added to disambiguate position adjustments during seeks from other types of
+  internal position discontinuity.
+* Fix potential `IndexOutOfBoundsException` when calling `ExoPlayer.getDuration`
+  ([#3362](https://github.com/google/ExoPlayer/issues/3362)).
+* Fix playbacks involving looping, concatenation and ads getting stuck when
+  media contains tracks with uneven durations
+  ([#1874](https://github.com/google/ExoPlayer/issues/1874)).
+* Fix issue with `ContentDataSource` when reading from certain `ContentProvider`
+  implementations ([#3426](https://github.com/google/ExoPlayer/issues/3426)).
+* Better playback experience when the video decoder cannot keep up, by skipping
+  to key-frames. This is particularly relevant for variable speed playbacks.
+* Allow `SingleSampleMediaSource` to suppress load errors
+  ([#3140](https://github.com/google/ExoPlayer/issues/3140)).
+* `DynamicConcatenatingMediaSource`: Allow specifying a callback to be invoked
+  after a dynamic playlist modification has been applied
+  ([#3407](https://github.com/google/ExoPlayer/issues/3407)).
+* Audio: New `AudioSink` interface allows customization of audio output path.
+* Offline: Added `Downloader` implementations for DASH, HLS, SmoothStreaming
+  and progressive streams.
+* Track selection:
+  * Fixed adaptive track selection logic for live playbacks
+    ([#3017](https://github.com/google/ExoPlayer/issues/3017)).
+  * Added ability to select the lowest bitrate tracks.
+* DASH:
+  * Don't crash when a malformed or unexpected manifest update occurs
+    ([#2795](https://github.com/google/ExoPlayer/issues/2795)).
+* HLS:
+  * Support for Widevine protected FMP4 variants.
+  * Support CEA-608 in FMP4 variants.
+  * Support extractor injection
+    ([#2748](https://github.com/google/ExoPlayer/issues/2748)).
+* DRM:
+  * Improved compatibility with ClearKey content
+    ([#3138](https://github.com/google/ExoPlayer/issues/3138)).
+  * Support multiple PSSH boxes of the same type.
+  * Retry initial provisioning and key requests if they fail
+  * Fix incorrect parsing of non-CENC sinf boxes.
+* IMA extension:
+  * Expose `AdsLoader` via getter
+    ([#3322](https://github.com/google/ExoPlayer/issues/3322)).
+  * Handle `setPlayWhenReady` calls during ad playbacks
+    ([#3303](https://github.com/google/ExoPlayer/issues/3303)).
+  * Ignore seeks if an ad is playing
+    ([#3309](https://github.com/google/ExoPlayer/issues/3309)).
+  * Improve robustness of `ImaAdsLoader` in case content is not paused between
+    content to ad transitions
+    ([#3430](https://github.com/google/ExoPlayer/issues/3430)).
+* UI:
+  * Allow specifying a `Drawable` for the `TimeBar` scrubber
+    ([#3337](https://github.com/google/ExoPlayer/issues/3337)).
+  * Allow multiple listeners on `TimeBar`
+    ([#3406](https://github.com/google/ExoPlayer/issues/3406)).
+* New Leanback extension: Simplifies binding Exoplayer to Leanback UI
+  components.
+* Unit tests moved to Robolectric.
+* Misc bugfixes.
+
+### r2.5.4 ###
+
+* Remove unnecessary media playlist fetches during playback of live HLS streams.
+* Add the ability to inject a HLS playlist parser through `HlsMediaSource`.
+* Fix potential `IndexOutOfBoundsException` when using `ImaMediaSource`
+  ([#3334](https://github.com/google/ExoPlayer/issues/3334)).
+* Fix an issue parsing MP4 content containing non-CENC sinf boxes.
+* Fix memory leak when seeking with repeated periods.
+* Fix playback position when `ExoPlayer.prepare` is called with `resetPosition`
+  set to false.
+* Ignore MP4 edit lists that seem invalid
+  ([#3351](https://github.com/google/ExoPlayer/issues/3351)).
+* Add extractor flag for ignoring all MP4 edit lists
+  ([#3358](https://github.com/google/ExoPlayer/issues/3358)).
+* Improve extensibility by exposing public constructors for
+  `FrameworkMediaCrypto` and by making `DefaultDashChunkSource.getNextChunk`
+  non-final.
+
 ### r2.5.3 ###
 
 * IMA extension: Support skipping of skippable ads on AndroidTV and other
diff --git a/build.gradle b/build.gradle
index 8ec24a6e82..2623db66fc 100644
--- a/build.gradle
+++ b/build.gradle
@@ -14,12 +14,10 @@
 buildscript {
     repositories {
         jcenter()
-        maven {
-            url "https://maven.google.com"
-        }
+        google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0-beta4'
+        classpath 'com.android.tools.build:gradle:3.0.0'
         classpath 'com.novoda:bintray-release:0.5.0'
     }
     // Workaround for the following test coverage issue. Remove when fixed:
@@ -34,9 +32,7 @@ buildscript {
 allprojects {
     repositories {
         jcenter()
-        maven {
-            url "https://maven.google.com"
-        }
+        google()
     }
     project.ext {
         exoplayerPublishEnabled = true
diff --git a/constants.gradle b/constants.gradle
index db7b12acf0..2a7754d65c 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -12,19 +12,23 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 project.ext {
-    // Important: ExoPlayer specifies a minSdkVersion of 9 because various
+    // Important: ExoPlayer specifies a minSdkVersion of 14 because various
     // components provided by the library may be of use on older devices.
     // However, please note that the core media playback functionality provided
     // by the library requires API level 16 or greater.
-    minSdkVersion = 9
-    compileSdkVersion = 25
-    targetSdkVersion = 25
-    buildToolsVersion = '25'
+    minSdkVersion = 14
+    compileSdkVersion = 26
+    targetSdkVersion = 26
+    buildToolsVersion = '26.0.2'
     testSupportLibraryVersion = '0.5'
-    supportLibraryVersion = '25.4.0'
+    supportLibraryVersion = '27.0.0'
+    playServicesLibraryVersion = '11.4.2'
     dexmakerVersion = '1.2'
     mockitoVersion = '1.9.5'
-    releaseVersion = 'r2.5.3'
+    junitVersion = '4.12'
+    truthVersion = '0.35'
+    robolectricVersion = '3.4.2'
+    releaseVersion = '2.6.0'
     modulePrefix = ':'
     if (gradle.ext.has('exoplayerModulePrefix')) {
         modulePrefix += gradle.ext.exoplayerModulePrefix
diff --git a/core_settings.gradle b/core_settings.gradle
index 20e7b235a2..7a8320b1a1 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -33,6 +33,7 @@ include modulePrefix + 'extension-okhttp'
 include modulePrefix + 'extension-opus'
 include modulePrefix + 'extension-vp9'
 include modulePrefix + 'extension-rtmp'
+include modulePrefix + 'extension-leanback'
 
 project(modulePrefix + 'library').projectDir = new File(rootDir, 'library/all')
 project(modulePrefix + 'library-core').projectDir = new File(rootDir, 'library/core')
@@ -50,6 +51,7 @@ project(modulePrefix + 'extension-okhttp').projectDir = new File(rootDir, 'exten
 project(modulePrefix + 'extension-opus').projectDir = new File(rootDir, 'extensions/opus')
 project(modulePrefix + 'extension-vp9').projectDir = new File(rootDir, 'extensions/vp9')
 project(modulePrefix + 'extension-rtmp').projectDir = new File(rootDir, 'extensions/rtmp')
+project(modulePrefix + 'extension-leanback').projectDir = new File(rootDir, 'extensions/leanback')
 
 if (gradle.ext.has('exoplayerIncludeCronetExtension')
         && gradle.ext.exoplayerIncludeCronetExtension) {
diff --git a/demo/src/main/res/drawable-xhdpi/ic_banner.png b/demo/src/main/res/drawable-xhdpi/ic_banner.png
deleted file mode 100644
index 520d83cc3b..0000000000
Binary files a/demo/src/main/res/drawable-xhdpi/ic_banner.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-hdpi/ic_launcher.png b/demo/src/main/res/mipmap-hdpi/ic_launcher.png
deleted file mode 100644
index 6e8b5499de..0000000000
Binary files a/demo/src/main/res/mipmap-hdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-mdpi/ic_launcher.png b/demo/src/main/res/mipmap-mdpi/ic_launcher.png
deleted file mode 100644
index 26fe2f0782..0000000000
Binary files a/demo/src/main/res/mipmap-mdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-xhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png
deleted file mode 100644
index d3251491ce..0000000000
Binary files a/demo/src/main/res/mipmap-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png
deleted file mode 100644
index b5a12d35f3..0000000000
Binary files a/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png
deleted file mode 100644
index 9c26192c32..0000000000
Binary files a/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demos/README.md b/demos/README.md
new file mode 100644
index 0000000000..7e62249db1
--- /dev/null
+++ b/demos/README.md
@@ -0,0 +1,4 @@
+# ExoPlayer demos #
+
+This directory contains applications that demonstrate how to use ExoPlayer.
+Browse the individual demos and their READMEs to learn more.
diff --git a/demos/ima/README.md b/demos/ima/README.md
new file mode 100644
index 0000000000..8002b56667
--- /dev/null
+++ b/demos/ima/README.md
@@ -0,0 +1,4 @@
+# IMA demo application #
+
+This folder contains a demo application that showcases ExoPlayer integration
+with the IMA SDK.
diff --git a/demos/ima/build.gradle b/demos/ima/build.gradle
new file mode 100644
index 0000000000..c32228de28
--- /dev/null
+++ b/demos/ima/build.gradle
@@ -0,0 +1,47 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion 16
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    buildTypes {
+        release {
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt')
+        }
+        debug {
+            jniDebuggable = true
+        }
+    }
+
+    lintOptions {
+        // The demo app does not have translations.
+        disable 'MissingTranslation'
+    }
+}
+
+dependencies {
+    compile project(modulePrefix + 'library-core')
+    compile project(modulePrefix + 'library-ui')
+    compile project(modulePrefix + 'extension-ima')
+}
diff --git a/demos/ima/src/main/AndroidManifest.xml b/demos/ima/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..5252d2feeb
--- /dev/null
+++ b/demos/ima/src/main/AndroidManifest.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer2.imademo"
+    android:versionCode="2600"
+    android:versionName="2.6.0">
+
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="26"/>
+
+  <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
+      android:largeHeap="true" android:allowBackup="false">
+
+    <activity android:name="com.google.android.exoplayer2.imademo.MainActivity"
+        android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
+        android:label="@string/application_name"
+        android:theme="@style/PlayerTheme">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+
+  </application>
+
+</manifest>
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java
new file mode 100644
index 0000000000..fb9cd05cd4
--- /dev/null
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.imademo;
+
+import android.app.Activity;
+import android.os.Bundle;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
+
+/**
+ * Main Activity for the IMA plugin demo. {@link ExoPlayer} objects are created by
+ * {@link PlayerManager}, which this class instantiates.
+ */
+public final class MainActivity extends Activity {
+
+  private SimpleExoPlayerView playerView;
+  private PlayerManager player;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.main_activity);
+    playerView = findViewById(R.id.player_view);
+    player = new PlayerManager(this);
+  }
+
+  @Override
+  public void onResume() {
+    super.onResume();
+    player.init(this, playerView);
+  }
+
+  @Override
+  public void onPause() {
+    super.onPause();
+    player.reset();
+  }
+
+  @Override
+  public void onDestroy() {
+    player.release();
+    super.onDestroy();
+  }
+
+}
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
new file mode 100644
index 0000000000..e11c840d12
--- /dev/null
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.imademo;
+
+import android.content.Context;
+import android.net.Uri;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.ext.ima.ImaAdsLoader;
+import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Manages the {@link ExoPlayer}, the IMA plugin and all video playback.
+ */
+/* package */ final class PlayerManager {
+
+  private final ImaAdsLoader adsLoader;
+
+  private SimpleExoPlayer player;
+  private long contentPosition;
+
+  public PlayerManager(Context context) {
+    String adTag = context.getString(R.string.ad_tag_url);
+    adsLoader = new ImaAdsLoader(context, Uri.parse(adTag));
+  }
+
+  public void init(Context context, SimpleExoPlayerView simpleExoPlayerView) {
+    // Create a default track selector.
+    BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+    TrackSelection.Factory videoTrackSelectionFactory =
+        new AdaptiveTrackSelection.Factory(bandwidthMeter);
+    TrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
+
+    // Create a player instance.
+    player = ExoPlayerFactory.newSimpleInstance(context, trackSelector);
+
+    // Bind the player to the view.
+    simpleExoPlayerView.setPlayer(player);
+
+    // Produces DataSource instances through which media data is loaded.
+    DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context,
+        Util.getUserAgent(context, context.getString(R.string.application_name)));
+
+    // Produces Extractor instances for parsing the content media (i.e. not the ad).
+    ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();
+
+    // This is the MediaSource representing the content media (i.e. not the ad).
+    String contentUrl = context.getString(R.string.content_url);
+    MediaSource contentMediaSource = new ExtractorMediaSource(
+        Uri.parse(contentUrl), dataSourceFactory, extractorsFactory, null, null);
+
+    // Compose the content media source into a new AdsMediaSource with both ads and content.
+    MediaSource mediaSourceWithAds = new AdsMediaSource(contentMediaSource, dataSourceFactory,
+        adsLoader, simpleExoPlayerView.getOverlayFrameLayout());
+
+    // Prepare the player with the source.
+    player.seekTo(contentPosition);
+    player.prepare(mediaSourceWithAds);
+    player.setPlayWhenReady(true);
+  }
+
+  public void reset() {
+    if (player != null) {
+      contentPosition = player.getContentPosition();
+      player.release();
+      player = null;
+    }
+  }
+
+  public void release() {
+    if (player != null) {
+      player.release();
+      player = null;
+    }
+    adsLoader.release();
+  }
+
+}
diff --git a/demos/ima/src/main/res/layout/main_activity.xml b/demos/ima/src/main/res/layout/main_activity.xml
new file mode 100644
index 0000000000..ad5da62f47
--- /dev/null
+++ b/demos/ima/src/main/res/layout/main_activity.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<com.google.android.exoplayer2.ui.SimpleExoPlayerView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/player_view"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:keepScreenOn="true"/>
diff --git a/demos/ima/src/main/res/mipmap-hdpi/ic_launcher.png b/demos/ima/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..adaa93220e
Binary files /dev/null and b/demos/ima/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demos/ima/src/main/res/mipmap-mdpi/ic_launcher.png b/demos/ima/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..9b6f7d5e80
Binary files /dev/null and b/demos/ima/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demos/ima/src/main/res/mipmap-xhdpi/ic_launcher.png b/demos/ima/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..2101026c9f
Binary files /dev/null and b/demos/ima/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demos/ima/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demos/ima/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..223ec8bd11
Binary files /dev/null and b/demos/ima/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demos/ima/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demos/ima/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..698ed68c42
Binary files /dev/null and b/demos/ima/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demos/ima/src/main/res/values/strings.xml b/demos/ima/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..67a7f06f8b
--- /dev/null
+++ b/demos/ima/src/main/res/values/strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+  <string name="application_name">Exo IMA Demo</string>
+
+  <string name="content_url"><![CDATA[http://rmcdn.2mdn.net/MotifFiles/html/1248596/android_1330378998288.mp4]]></string>
+
+  <string name="ad_tag_url"><![CDATA[https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dlinear&correlator=]]></string>
+
+</resources>
diff --git a/library/ui/src/main/res/values-v11/styles.xml b/demos/ima/src/main/res/values/styles.xml
similarity index 65%
rename from library/ui/src/main/res/values-v11/styles.xml
rename to demos/ima/src/main/res/values/styles.xml
index 6f77440287..1c78ad58df 100644
--- a/library/ui/src/main/res/values-v11/styles.xml
+++ b/demos/ima/src/main/res/values/styles.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
+<!-- Copyright (C) 2017 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,12 +13,11 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<resources>
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
 
-  <style name="ExoMediaButton">
-    <item name="android:background">?android:attr/selectableItemBackground</item>
-    <item name="android:layout_width">@dimen/exo_media_button_width</item>
-    <item name="android:layout_height">@dimen/exo_media_button_height</item>
+  <style name="PlayerTheme" parent="android:Theme.Holo">
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:windowBackground">@android:color/black</item>
   </style>
 
 </resources>
diff --git a/demo/README.md b/demos/main/README.md
similarity index 100%
rename from demo/README.md
rename to demos/main/README.md
diff --git a/demo/build.gradle b/demos/main/build.gradle
similarity index 98%
rename from demo/build.gradle
rename to demos/main/build.gradle
index e0874e3147..adad8f0e58 100644
--- a/demo/build.gradle
+++ b/demos/main/build.gradle
@@ -11,7 +11,7 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-apply from: '../constants.gradle'
+apply from: '../../constants.gradle'
 apply plugin: 'com.android.application'
 
 android {
diff --git a/demo/src/main/AndroidManifest.xml b/demos/main/src/main/AndroidManifest.xml
similarity index 97%
rename from demo/src/main/AndroidManifest.xml
rename to demos/main/src/main/AndroidManifest.xml
index 612044762f..d041e24d80 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demos/main/src/main/AndroidManifest.xml
@@ -16,14 +16,14 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.demo"
-    android:versionCode="2503"
-    android:versionName="2.5.3">
+    android:versionCode="2600"
+    android:versionName="2.6.0">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
   <uses-feature android:name="android.software.leanback" android:required="false"/>
   <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
-  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="25"/>
+  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="26"/>
 
   <application
       android:label="@string/application_name"
diff --git a/demo/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
similarity index 97%
rename from demo/src/main/assets/media.exolist.json
rename to demos/main/src/main/assets/media.exolist.json
index 59d8259d37..38a0c577ae 100644
--- a/demo/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -344,11 +344,11 @@
     "samples": [
       {
         "name": "Apple 4x3 basic stream",
-        "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8"
       },
       {
         "name": "Apple 16x9 basic stream",
-        "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_16x9/bipbop_16x9_variant.m3u8"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_16x9/bipbop_16x9_variant.m3u8"
       },
       {
         "name": "Apple master playlist advanced (TS)",
@@ -360,11 +360,11 @@
       },
       {
         "name": "Apple TS media playlist",
-        "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8"
       },
       {
         "name": "Apple AAC media playlist",
-        "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear0/prog_index.m3u8"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear0/prog_index.m3u8"
       },
       {
         "name": "Apple ID3 metadata",
@@ -381,11 +381,11 @@
       },
       {
         "name": "Apple AAC 10s",
-        "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear0/fileSequence0.aac"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear0/fileSequence0.aac"
       },
       {
         "name": "Apple TS 10s",
-        "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/fileSequence0.ts"
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear1/fileSequence0.ts"
       },
       {
         "name": "Android screens (Matroska)",
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
similarity index 100%
rename from demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
rename to demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java
similarity index 100%
rename from demo/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java
rename to demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
similarity index 93%
rename from demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
rename to demos/main/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index 2ea4b5b7cf..27a5c68e28 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -29,7 +29,7 @@
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
@@ -55,10 +55,9 @@
 /**
  * Logs player events using {@link Log}.
  */
-/* package */ final class EventLogger implements Player.EventListener, AudioRendererEventListener,
-    VideoRendererEventListener, AdaptiveMediaSourceEventListener,
-    ExtractorMediaSource.EventListener, DefaultDrmSessionManager.EventListener,
-    MetadataRenderer.Output {
+/* package */ final class EventLogger implements Player.EventListener, MetadataOutput,
+    AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
+    ExtractorMediaSource.EventListener, DefaultDrmSessionManager.EventListener {
 
   private static final String TAG = "EventLogger";
   private static final int MAX_TIMELINE_ITEM_LINES = 3;
@@ -101,8 +100,13 @@ public void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
   }
 
   @Override
-  public void onPositionDiscontinuity() {
-    Log.d(TAG, "positionDiscontinuity");
+  public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
+    Log.d(TAG, "shuffleModeEnabled [" + shuffleModeEnabled + "]");
+  }
+
+  @Override
+  public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+    Log.d(TAG, "positionDiscontinuity [" + getDiscontinuityReasonString(reason) + "]");
   }
 
   @Override
@@ -205,7 +209,12 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
     Log.d(TAG, "]");
   }
 
-  // MetadataRenderer.Output
+  @Override
+  public void onSeekProcessed() {
+    Log.d(TAG, "seekProcessed");
+  }
+
+  // MetadataOutput
 
   @Override
   public void onMetadata(Metadata metadata) {
@@ -244,7 +253,7 @@ public void onAudioDisabled(DecoderCounters counters) {
   }
 
   @Override
-  public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+  public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
     printInternalError("audioTrackUnderrun [" + bufferSize + ", " + bufferSizeMs + ", "
         + elapsedSinceLastFeedMs + "]", null);
   }
@@ -480,4 +489,19 @@ private static String getRepeatModeString(@Player.RepeatMode int repeatMode) {
         return "?";
     }
   }
+
+  private static String getDiscontinuityReasonString(@Player.DiscontinuityReason int reason) {
+    switch (reason) {
+      case Player.DISCONTINUITY_REASON_PERIOD_TRANSITION:
+        return "PERIOD_TRANSITION";
+      case Player.DISCONTINUITY_REASON_SEEK:
+        return "SEEK";
+      case Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT:
+        return "SEEK_ADJUSTMENT";
+      case Player.DISCONTINUITY_REASON_INTERNAL:
+        return "INTERNAL";
+      default:
+        return "?";
+    }
+  }
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
similarity index 77%
rename from demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
rename to demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 6416cd5aa2..08c5bddb09 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -34,14 +34,12 @@
 import android.widget.TextView;
 import android.widget.Toast;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Player.EventListener;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -56,6 +54,8 @@
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
 import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
@@ -73,8 +73,6 @@
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.util.Util;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
@@ -83,12 +81,13 @@
 /**
  * An activity that plays media using {@link SimpleExoPlayer}.
  */
-public class PlayerActivity extends Activity implements OnClickListener, EventListener,
+public class PlayerActivity extends Activity implements OnClickListener,
     PlaybackControlView.VisibilityListener {
 
   public static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
   public static final String DRM_LICENSE_URL = "drm_license_url";
   public static final String DRM_KEY_REQUEST_PROPERTIES = "drm_key_request_properties";
+  public static final String DRM_MULTI_SESSION = "drm_multi_session";
   public static final String PREFER_EXTENSION_DECODERS = "prefer_extension_decoders";
 
   public static final String ACTION_VIEW = "com.google.android.exoplayer.demo.action.VIEW";
@@ -128,9 +127,9 @@
 
   // Fields used only for ad playback. The ads loader is loaded via reflection.
 
-  private Object imaAdsLoader; // com.google.android.exoplayer2.ext.ima.ImaAdsLoader
+  private AdsLoader adsLoader;
   private Uri loadedAdTagUri;
-  private ViewGroup adOverlayViewGroup;
+  private ViewGroup adUiViewGroup;
 
   // Activity lifecycle
 
@@ -148,12 +147,12 @@ public void onCreate(Bundle savedInstanceState) {
     setContentView(R.layout.player_activity);
     View rootView = findViewById(R.id.root);
     rootView.setOnClickListener(this);
-    debugRootView = (LinearLayout) findViewById(R.id.controls_root);
-    debugTextView = (TextView) findViewById(R.id.debug_text_view);
-    retryButton = (Button) findViewById(R.id.retry_button);
+    debugRootView = findViewById(R.id.controls_root);
+    debugTextView = findViewById(R.id.debug_text_view);
+    retryButton = findViewById(R.id.retry_button);
     retryButton.setOnClickListener(this);
 
-    simpleExoPlayerView = (SimpleExoPlayerView) findViewById(R.id.player_view);
+    simpleExoPlayerView = findViewById(R.id.player_view);
     simpleExoPlayerView.setControllerVisibilityListener(this);
     simpleExoPlayerView.requestFocus();
   }
@@ -177,7 +176,7 @@ public void onStart() {
   @Override
   public void onResume() {
     super.onResume();
-    if ((Util.SDK_INT <= 23 || player == null)) {
+    if (Util.SDK_INT <= 23 || player == null) {
       initializePlayer();
     }
   }
@@ -219,8 +218,8 @@ public void onRequestPermissionsResult(int requestCode, @NonNull String[] permis
 
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
-    // If the event was not handled then see if the player view can handle it.
-    return super.dispatchKeyEvent(event) || simpleExoPlayerView.dispatchKeyEvent(event);
+    // See whether the player view wants to handle media or DPAD keys events.
+    return simpleExoPlayerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
   }
 
   // OnClickListener methods
@@ -264,13 +263,14 @@ private void initializePlayer() {
       if (drmSchemeUuid != null) {
         String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL);
         String[] keyRequestPropertiesArray = intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES);
+        boolean multiSession = intent.getBooleanExtra(DRM_MULTI_SESSION, false);
         int errorStringId = R.string.error_drm_unknown;
         if (Util.SDK_INT < 18) {
           errorStringId = R.string.error_drm_not_supported;
         } else {
           try {
             drmSessionManager = buildDrmSessionManagerV18(drmSchemeUuid, drmLicenseUrl,
-                keyRequestPropertiesArray);
+                keyRequestPropertiesArray, multiSession);
           } catch (UnsupportedDrmException e) {
             errorStringId = e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
                 ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown;
@@ -292,7 +292,7 @@ private void initializePlayer() {
           drmSessionManager, extensionRendererMode);
 
       player = ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector);
-      player.addListener(this);
+      player.addListener(new PlayerEventListener());
       player.addListener(eventLogger);
       player.addMetadataOutput(eventLogger);
       player.setAudioDebugListener(eventLogger);
@@ -358,7 +358,7 @@ private void initializePlayer() {
   }
 
   private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
-    int type = TextUtils.isEmpty(overrideExtension) ? Util.inferContentType(uri)
+    @ContentType int type = TextUtils.isEmpty(overrideExtension) ? Util.inferContentType(uri)
         : Util.inferContentType("." + overrideExtension);
     switch (type) {
       case C.TYPE_SS:
@@ -379,7 +379,8 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
   }
 
   private DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(UUID uuid,
-      String licenseUrl, String[] keyRequestPropertiesArray) throws UnsupportedDrmException {
+      String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
+      throws UnsupportedDrmException {
     HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(licenseUrl,
         buildHttpDataSourceFactory(false));
     if (keyRequestPropertiesArray != null) {
@@ -389,7 +390,7 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
       }
     }
     return new DefaultDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), drmCallback,
-        null, mainHandler, eventLogger);
+        null, mainHandler, eventLogger, multiSession);
   }
 
   private void releasePlayer() {
@@ -450,136 +451,25 @@ private MediaSource createAdsMediaSource(MediaSource mediaSource, Uri adTagUri)
     // Load the extension source using reflection so the demo app doesn't have to depend on it.
     // The ads loader is reused for multiple playbacks, so that ad playback can resume.
     Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
-    if (imaAdsLoader == null) {
-      imaAdsLoader = loaderClass.getConstructor(Context.class, Uri.class)
+    if (adsLoader == null) {
+      adsLoader = (AdsLoader) loaderClass.getConstructor(Context.class, Uri.class)
           .newInstance(this, adTagUri);
-      adOverlayViewGroup = new FrameLayout(this);
+      adUiViewGroup = new FrameLayout(this);
       // The demo app has a non-null overlay frame layout.
-      simpleExoPlayerView.getOverlayFrameLayout().addView(adOverlayViewGroup);
+      simpleExoPlayerView.getOverlayFrameLayout().addView(adUiViewGroup);
     }
-    Class<?> sourceClass =
-        Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsMediaSource");
-    Constructor<?> constructor = sourceClass.getConstructor(MediaSource.class,
-        DataSource.Factory.class, loaderClass, ViewGroup.class);
-    return (MediaSource) constructor.newInstance(mediaSource, mediaDataSourceFactory, imaAdsLoader,
-        adOverlayViewGroup);
+    return new AdsMediaSource(mediaSource, mediaDataSourceFactory, adsLoader, adUiViewGroup);
   }
 
   private void releaseAdsLoader() {
-    if (imaAdsLoader != null) {
-      try {
-        Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
-        Method releaseMethod = loaderClass.getMethod("release");
-        releaseMethod.invoke(imaAdsLoader);
-      } catch (Exception e) {
-        // Should never happen.
-        throw new IllegalStateException(e);
-      }
-      imaAdsLoader = null;
+    if (adsLoader != null) {
+      adsLoader.release();
+      adsLoader = null;
       loadedAdTagUri = null;
       simpleExoPlayerView.getOverlayFrameLayout().removeAllViews();
     }
   }
 
-  // Player.EventListener implementation
-
-  @Override
-  public void onLoadingChanged(boolean isLoading) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-    if (playbackState == Player.STATE_ENDED) {
-      showControls();
-    }
-    updateButtonVisibilities();
-  }
-
-  @Override
-  public void onRepeatModeChanged(int repeatMode) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPositionDiscontinuity() {
-    if (inErrorState) {
-      // This will only occur if the user has performed a seek whilst in the error state. Update the
-      // resume position so that if the user then retries, playback will resume from the position to
-      // which they seeked.
-      updateResumePosition();
-    }
-  }
-
-  @Override
-  public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPlayerError(ExoPlaybackException e) {
-    String errorString = null;
-    if (e.type == ExoPlaybackException.TYPE_RENDERER) {
-      Exception cause = e.getRendererException();
-      if (cause instanceof DecoderInitializationException) {
-        // Special case for decoder initialization failures.
-        DecoderInitializationException decoderInitializationException =
-            (DecoderInitializationException) cause;
-        if (decoderInitializationException.decoderName == null) {
-          if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
-            errorString = getString(R.string.error_querying_decoders);
-          } else if (decoderInitializationException.secureDecoderRequired) {
-            errorString = getString(R.string.error_no_secure_decoder,
-                decoderInitializationException.mimeType);
-          } else {
-            errorString = getString(R.string.error_no_decoder,
-                decoderInitializationException.mimeType);
-          }
-        } else {
-          errorString = getString(R.string.error_instantiating_decoder,
-              decoderInitializationException.decoderName);
-        }
-      }
-    }
-    if (errorString != null) {
-      showToast(errorString);
-    }
-    inErrorState = true;
-    if (isBehindLiveWindow(e)) {
-      clearResumePosition();
-      initializePlayer();
-    } else {
-      updateResumePosition();
-      updateButtonVisibilities();
-      showControls();
-    }
-  }
-
-  @Override
-  @SuppressWarnings("ReferenceEquality")
-  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-    updateButtonVisibilities();
-    if (trackGroups != lastSeenTrackGroupArray) {
-      MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
-      if (mappedTrackInfo != null) {
-        if (mappedTrackInfo.getTrackTypeRendererSupport(C.TRACK_TYPE_VIDEO)
-            == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
-          showToast(R.string.error_unsupported_video);
-        }
-        if (mappedTrackInfo.getTrackTypeRendererSupport(C.TRACK_TYPE_AUDIO)
-            == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
-          showToast(R.string.error_unsupported_audio);
-        }
-      }
-      lastSeenTrackGroupArray = trackGroups;
-    }
-  }
-
   // User controls
 
   private void updateButtonVisibilities() {
@@ -649,4 +539,85 @@ private static boolean isBehindLiveWindow(ExoPlaybackException e) {
     return false;
   }
 
+  private class PlayerEventListener extends Player.DefaultEventListener {
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (playbackState == Player.STATE_ENDED) {
+        showControls();
+      }
+      updateButtonVisibilities();
+    }
+
+    @Override
+    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+      if (inErrorState) {
+        // This will only occur if the user has performed a seek whilst in the error state. Update
+        // the resume position so that if the user then retries, playback will resume from the
+        // position to which they seeked.
+        updateResumePosition();
+      }
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException e) {
+      String errorString = null;
+      if (e.type == ExoPlaybackException.TYPE_RENDERER) {
+        Exception cause = e.getRendererException();
+        if (cause instanceof DecoderInitializationException) {
+          // Special case for decoder initialization failures.
+          DecoderInitializationException decoderInitializationException =
+              (DecoderInitializationException) cause;
+          if (decoderInitializationException.decoderName == null) {
+            if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
+              errorString = getString(R.string.error_querying_decoders);
+            } else if (decoderInitializationException.secureDecoderRequired) {
+              errorString = getString(R.string.error_no_secure_decoder,
+                  decoderInitializationException.mimeType);
+            } else {
+              errorString = getString(R.string.error_no_decoder,
+                  decoderInitializationException.mimeType);
+            }
+          } else {
+            errorString = getString(R.string.error_instantiating_decoder,
+                decoderInitializationException.decoderName);
+          }
+        }
+      }
+      if (errorString != null) {
+        showToast(errorString);
+      }
+      inErrorState = true;
+      if (isBehindLiveWindow(e)) {
+        clearResumePosition();
+        initializePlayer();
+      } else {
+        updateResumePosition();
+        updateButtonVisibilities();
+        showControls();
+      }
+    }
+
+    @Override
+    @SuppressWarnings("ReferenceEquality")
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      updateButtonVisibilities();
+      if (trackGroups != lastSeenTrackGroupArray) {
+        MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+        if (mappedTrackInfo != null) {
+          if (mappedTrackInfo.getTrackTypeRendererSupport(C.TRACK_TYPE_VIDEO)
+              == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+            showToast(R.string.error_unsupported_video);
+          }
+          if (mappedTrackInfo.getTrackTypeRendererSupport(C.TRACK_TYPE_AUDIO)
+              == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+            showToast(R.string.error_unsupported_audio);
+          }
+        }
+        lastSeenTrackGroupArray = trackGroups;
+      }
+    }
+
+  }
+
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
similarity index 88%
rename from demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
rename to demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index 87b8e92e83..1f84b1f29c 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -90,7 +90,7 @@ private void onSampleGroups(final List<SampleGroup> groups, boolean sawError) {
       Toast.makeText(getApplicationContext(), R.string.sample_list_load_error, Toast.LENGTH_LONG)
           .show();
     }
-    ExpandableListView sampleList = (ExpandableListView) findViewById(R.id.sample_list);
+    ExpandableListView sampleList = findViewById(R.id.sample_list);
     sampleList.setAdapter(new SampleAdapter(this, groups));
     sampleList.setOnChildClickListener(new OnChildClickListener() {
       @Override
@@ -182,6 +182,7 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
       UUID drmUuid = null;
       String drmLicenseUrl = null;
       String[] drmKeyRequestProperties = null;
+      boolean drmMultiSession = false;
       boolean preferExtensionDecoders = false;
       ArrayList<UriSample> playlistSamples = null;
       String adTagUri = null;
@@ -220,6 +221,9 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
             reader.endObject();
             drmKeyRequestProperties = drmKeyRequestPropertiesList.toArray(new String[0]);
             break;
+          case "drm_multi_session":
+            drmMultiSession = reader.nextBoolean();
+            break;
           case "prefer_extension_decoders":
             Assertions.checkState(!insidePlaylist,
                 "Invalid attribute on nested item: prefer_extension_decoders");
@@ -242,15 +246,16 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
         }
       }
       reader.endObject();
-
+      DrmInfo drmInfo = drmUuid == null ? null : new DrmInfo(drmUuid, drmLicenseUrl,
+          drmKeyRequestProperties, drmMultiSession);
       if (playlistSamples != null) {
         UriSample[] playlistSamplesArray = playlistSamples.toArray(
             new UriSample[playlistSamples.size()]);
-        return new PlaylistSample(sampleName, drmUuid, drmLicenseUrl, drmKeyRequestProperties,
-            preferExtensionDecoders, playlistSamplesArray);
+        return new PlaylistSample(sampleName, preferExtensionDecoders, drmInfo,
+            playlistSamplesArray);
       } else {
-        return new UriSample(sampleName, drmUuid, drmLicenseUrl, drmKeyRequestProperties,
-            preferExtensionDecoders, uri, extension, adTagUri);
+        return new UriSample(sampleName, preferExtensionDecoders, drmInfo, uri, extension,
+            adTagUri);
       }
     }
 
@@ -271,7 +276,7 @@ private UUID getDrmUuid(String typeString) throws ParserException {
           return C.WIDEVINE_UUID;
         case "playready":
           return C.PLAYREADY_UUID;
-        case "cenc":
+        case "clearkey":
           return C.CLEARKEY_UUID;
         default:
           try {
@@ -372,31 +377,47 @@ public SampleGroup(String title) {
 
   }
 
-  private abstract static class Sample {
-
-    public final String name;
-    public final boolean preferExtensionDecoders;
+  private static final class DrmInfo {
     public final UUID drmSchemeUuid;
     public final String drmLicenseUrl;
     public final String[] drmKeyRequestProperties;
+    public final boolean drmMultiSession;
 
-    public Sample(String name, UUID drmSchemeUuid, String drmLicenseUrl,
-        String[] drmKeyRequestProperties, boolean preferExtensionDecoders) {
-      this.name = name;
+    public DrmInfo(UUID drmSchemeUuid, String drmLicenseUrl,
+        String[] drmKeyRequestProperties, boolean drmMultiSession) {
       this.drmSchemeUuid = drmSchemeUuid;
       this.drmLicenseUrl = drmLicenseUrl;
       this.drmKeyRequestProperties = drmKeyRequestProperties;
+      this.drmMultiSession = drmMultiSession;
+    }
+
+    public void updateIntent(Intent intent) {
+      Assertions.checkNotNull(intent);
+      intent.putExtra(PlayerActivity.DRM_SCHEME_UUID_EXTRA, drmSchemeUuid.toString());
+      intent.putExtra(PlayerActivity.DRM_LICENSE_URL, drmLicenseUrl);
+      intent.putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES, drmKeyRequestProperties);
+      intent.putExtra(PlayerActivity.DRM_MULTI_SESSION, drmMultiSession);
+    }
+  }
+
+  private abstract static class Sample {
+    public final String name;
+    public final boolean preferExtensionDecoders;
+    public final DrmInfo drmInfo;
+
+    public Sample(String name, boolean preferExtensionDecoders, DrmInfo drmInfo) {
+      this.name = name;
       this.preferExtensionDecoders = preferExtensionDecoders;
+      this.drmInfo = drmInfo;
     }
 
     public Intent buildIntent(Context context) {
       Intent intent = new Intent(context, PlayerActivity.class);
       intent.putExtra(PlayerActivity.PREFER_EXTENSION_DECODERS, preferExtensionDecoders);
-      if (drmSchemeUuid != null) {
-        intent.putExtra(PlayerActivity.DRM_SCHEME_UUID_EXTRA, drmSchemeUuid.toString());
-        intent.putExtra(PlayerActivity.DRM_LICENSE_URL, drmLicenseUrl);
-        intent.putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES, drmKeyRequestProperties);
+      if (drmInfo != null) {
+        drmInfo.updateIntent(intent);
       }
+
       return intent;
     }
 
@@ -408,10 +429,9 @@ public Intent buildIntent(Context context) {
     public final String extension;
     public final String adTagUri;
 
-    public UriSample(String name, UUID drmSchemeUuid, String drmLicenseUrl,
-        String[] drmKeyRequestProperties, boolean preferExtensionDecoders, String uri,
+    public UriSample(String name, boolean preferExtensionDecoders, DrmInfo drmInfo, String uri,
         String extension, String adTagUri) {
-      super(name, drmSchemeUuid, drmLicenseUrl, drmKeyRequestProperties, preferExtensionDecoders);
+      super(name, preferExtensionDecoders, drmInfo);
       this.uri = uri;
       this.extension = extension;
       this.adTagUri = adTagUri;
@@ -432,10 +452,9 @@ public Intent buildIntent(Context context) {
 
     public final UriSample[] children;
 
-    public PlaylistSample(String name, UUID drmSchemeUuid, String drmLicenseUrl,
-        String[] drmKeyRequestProperties, boolean preferExtensionDecoders,
+    public PlaylistSample(String name, boolean preferExtensionDecoders, DrmInfo drmInfo,
         UriSample... children) {
-      super(name, drmSchemeUuid, drmLicenseUrl, drmKeyRequestProperties, preferExtensionDecoders);
+      super(name, preferExtensionDecoders, drmInfo);
       this.children = children;
     }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
similarity index 99%
rename from demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
rename to demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index fb7217f8fd..e033b91eef 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -109,7 +109,7 @@ public void showSelectionDialog(Activity activity, CharSequence title, MappedTra
   private View buildView(Context context) {
     LayoutInflater inflater = LayoutInflater.from(context);
     View view = inflater.inflate(R.layout.track_selection_dialog, null);
-    ViewGroup root = (ViewGroup) view.findViewById(R.id.root);
+    ViewGroup root = view.findViewById(R.id.root);
 
     TypedArray attributeArray = context.getTheme().obtainStyledAttributes(
         new int[] {android.R.attr.selectableItemBackground});
diff --git a/demos/main/src/main/res/drawable-xhdpi/ic_banner.png b/demos/main/src/main/res/drawable-xhdpi/ic_banner.png
new file mode 100644
index 0000000000..09de177387
Binary files /dev/null and b/demos/main/src/main/res/drawable-xhdpi/ic_banner.png differ
diff --git a/demo/src/main/res/layout/list_divider.xml b/demos/main/src/main/res/layout/list_divider.xml
similarity index 100%
rename from demo/src/main/res/layout/list_divider.xml
rename to demos/main/src/main/res/layout/list_divider.xml
diff --git a/demo/src/main/res/layout/player_activity.xml b/demos/main/src/main/res/layout/player_activity.xml
similarity index 100%
rename from demo/src/main/res/layout/player_activity.xml
rename to demos/main/src/main/res/layout/player_activity.xml
diff --git a/demo/src/main/res/layout/sample_chooser_activity.xml b/demos/main/src/main/res/layout/sample_chooser_activity.xml
similarity index 100%
rename from demo/src/main/res/layout/sample_chooser_activity.xml
rename to demos/main/src/main/res/layout/sample_chooser_activity.xml
diff --git a/demo/src/main/res/layout/track_selection_dialog.xml b/demos/main/src/main/res/layout/track_selection_dialog.xml
similarity index 100%
rename from demo/src/main/res/layout/track_selection_dialog.xml
rename to demos/main/src/main/res/layout/track_selection_dialog.xml
diff --git a/demos/main/src/main/res/mipmap-hdpi/ic_launcher.png b/demos/main/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..adaa93220e
Binary files /dev/null and b/demos/main/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demos/main/src/main/res/mipmap-mdpi/ic_launcher.png b/demos/main/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..9b6f7d5e80
Binary files /dev/null and b/demos/main/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demos/main/src/main/res/mipmap-xhdpi/ic_launcher.png b/demos/main/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..2101026c9f
Binary files /dev/null and b/demos/main/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demos/main/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demos/main/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..223ec8bd11
Binary files /dev/null and b/demos/main/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demos/main/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demos/main/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..698ed68c42
Binary files /dev/null and b/demos/main/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/values/strings.xml b/demos/main/src/main/res/values/strings.xml
similarity index 99%
rename from demo/src/main/res/values/strings.xml
rename to demos/main/src/main/res/values/strings.xml
index cc6357c574..b38ccf6e88 100644
--- a/demo/src/main/res/values/strings.xml
+++ b/demos/main/src/main/res/values/strings.xml
@@ -13,7 +13,6 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
   <string name="application_name">ExoPlayer</string>
diff --git a/demo/src/main/res/values/styles.xml b/demos/main/src/main/res/values/styles.xml
similarity index 99%
rename from demo/src/main/res/values/styles.xml
rename to demos/main/src/main/res/values/styles.xml
index 751a224210..5616bb9869 100644
--- a/demo/src/main/res/values/styles.xml
+++ b/demos/main/src/main/res/values/styles.xml
@@ -13,7 +13,6 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-
 <resources xmlns:android="http://schemas.android.com/apk/res/android">
 
   <style name="PlayerTheme" parent="android:Theme.Holo">
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 930a53c7c5..197dec80a5 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -27,6 +27,11 @@ android {
     sourceSets.main {
         jniLibs.srcDirs = ['jniLibs']
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
 }
 
 dependencies {
diff --git a/extensions/cronet/src/androidTest/AndroidManifest.xml b/extensions/cronet/src/androidTest/AndroidManifest.xml
index 1f371a1864..7f14a28e83 100644
--- a/extensions/cronet/src/androidTest/AndroidManifest.xml
+++ b/extensions/cronet/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.ext.cronet">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
index 4282244a7a..a65bb0951b 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.android.exoplayer2.ext.cronet;
 
 import static org.junit.Assert.assertArrayEquals;
@@ -22,11 +21,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.MockitoAnnotations.initMocks;
 
-import android.annotation.TargetApi;
-import android.os.Build.VERSION_CODES;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
@@ -68,7 +64,6 @@ public void testReadFullBuffer() throws IOException {
     assertArrayEquals(TEST_DATA, byteBuffer.array());
   }
 
-  @TargetApi(VERSION_CODES.GINGERBREAD)
   @Test
   public void testReadPartialBuffer() throws IOException {
     byte[] firstHalf = Arrays.copyOfRange(TEST_DATA, 0, TEST_DATA.length / 2);
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index 06a356487e..4c6a42849f 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.android.exoplayer2.ext.cronet;
 
 import static org.junit.Assert.assertArrayEquals;
@@ -75,12 +74,13 @@
 public final class CronetDataSourceTest {
 
   private static final int TEST_CONNECT_TIMEOUT_MS = 100;
-  private static final int TEST_READ_TIMEOUT_MS = 50;
+  private static final int TEST_READ_TIMEOUT_MS = 100;
   private static final String TEST_URL = "http://google.com";
   private static final String TEST_CONTENT_TYPE = "test/test";
   private static final byte[] TEST_POST_BODY = "test post body".getBytes();
   private static final long TEST_CONTENT_LENGTH = 16000L;
   private static final int TEST_CONNECTION_STATUS = 5;
+  private static final int TEST_INVALID_CONNECTION_STATUS = -1;
 
   private DataSpec testDataSpec;
   private DataSpec testPostDataSpec;
@@ -103,6 +103,7 @@
   @Mock private CronetEngine mockCronetEngine;
 
   private CronetDataSource dataSourceUnderTest;
+  private boolean redirectCalled;
 
   @Before
   public void setUp() throws Exception {
@@ -119,10 +120,11 @@ public void setUp() throws Exception {
             TEST_READ_TIMEOUT_MS,
             true, // resetTimeoutOnRedirects
             mockClock,
-            null));
+            null,
+            false));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
     when(mockCronetEngine.newUrlRequestBuilder(
-            anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
+        anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
         .thenReturn(mockUrlRequestBuilder);
     when(mockUrlRequestBuilder.allowDirectExecutor()).thenReturn(mockUrlRequestBuilder);
     when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest);
@@ -139,10 +141,14 @@ public void setUp() throws Exception {
   }
 
   private UrlResponseInfo createUrlResponseInfo(int statusCode) {
+    return createUrlResponseInfoWithUrl(TEST_URL, statusCode);
+  }
+
+  private UrlResponseInfo createUrlResponseInfoWithUrl(String url, int statusCode) {
     ArrayList<Map.Entry<String, String>> responseHeaderList = new ArrayList<>();
     responseHeaderList.addAll(testResponseHeader.entrySet());
     return new UrlResponseInfoImpl(
-        Collections.singletonList(TEST_URL),
+        Collections.singletonList(url),
         statusCode,
         null, // httpStatusText
         responseHeaderList,
@@ -151,11 +157,16 @@ private UrlResponseInfo createUrlResponseInfo(int statusCode) {
         null); // proxyServer
   }
 
-  @Test(expected = IllegalStateException.class)
+  @Test
   public void testOpeningTwiceThrows() throws HttpDataSourceException {
     mockResponseStartSuccess();
     dataSourceUnderTest.open(testDataSpec);
-    dataSourceUnderTest.open(testDataSpec);
+    try {
+      dataSourceUnderTest.open(testDataSpec);
+      fail("Expected IllegalStateException.");
+    } catch (IllegalStateException e) {
+      // Expected.
+    }
   }
 
   @Test
@@ -564,6 +575,45 @@ public void run() {
     verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
 
+  @Test
+  public void testConnectInterrupted() {
+    when(mockClock.elapsedRealtime()).thenReturn(0L);
+    final ConditionVariable startCondition = buildUrlRequestStartedCondition();
+    final ConditionVariable timedOutCondition = new ConditionVariable();
+
+    Thread thread =
+        new Thread() {
+          @Override
+          public void run() {
+            try {
+              dataSourceUnderTest.open(testDataSpec);
+              fail();
+            } catch (HttpDataSourceException e) {
+              // Expected.
+              assertTrue(e instanceof CronetDataSource.OpenException);
+              assertTrue(e.getCause() instanceof CronetDataSource.InterruptedIOException);
+              assertEquals(
+                  TEST_INVALID_CONNECTION_STATUS,
+                  ((CronetDataSource.OpenException) e).cronetConnectionStatus);
+              timedOutCondition.open();
+            }
+          }
+        };
+    thread.start();
+    startCondition.block();
+
+    // We should still be trying to open.
+    assertFalse(timedOutCondition.block(50));
+    // We should still be trying to open as we approach the timeout.
+    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
+    assertFalse(timedOutCondition.block(50));
+    // Now we interrupt.
+    thread.interrupt();
+    timedOutCondition.block();
+
+    verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
+  }
+
   @Test
   public void testConnectResponseBeforeTimeout() {
     when(mockClock.elapsedRealtime()).thenReturn(0L);
@@ -650,6 +700,111 @@ public void run() {
     assertEquals(1, openExceptions.get());
   }
 
+  @Test
+  public void testRedirectParseAndAttachCookie_dataSourceDoesNotHandleSetCookie_followsRedirect()
+      throws HttpDataSourceException {
+    mockSingleRedirectSuccess();
+    mockFollowRedirectSuccess();
+
+    testResponseHeader.put("Set-Cookie", "testcookie=testcookie; Path=/video");
+
+    dataSourceUnderTest.open(testDataSpec);
+    verify(mockUrlRequestBuilder, never()).addHeader(eq("Cookie"), any(String.class));
+    verify(mockUrlRequest).followRedirect();
+  }
+
+  @Test
+  public void testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeaders()
+      throws HttpDataSourceException {
+    dataSourceUnderTest = spy(
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            mockTransferListener,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            mockClock,
+            null,
+            true));
+    dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
+
+    mockSingleRedirectSuccess();
+
+    testResponseHeader.put("Set-Cookie", "testcookie=testcookie; Path=/video");
+
+    dataSourceUnderTest.open(testDataSpec);
+    verify(mockUrlRequestBuilder).addHeader(eq("Cookie"), any(String.class));
+    verify(mockUrlRequestBuilder, never()).addHeader(eq("Range"), any(String.class));
+    verify(mockUrlRequestBuilder, times(2)).addHeader("Content-Type", TEST_CONTENT_TYPE);
+    verify(mockUrlRequest, never()).followRedirect();
+    verify(mockUrlRequest, times(2)).start();
+  }
+
+  @Test
+  public void testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeadersIncludingByteRangeHeader()
+      throws HttpDataSourceException {
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+    dataSourceUnderTest = spy(
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            mockTransferListener,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            mockClock,
+            null,
+            true));
+    dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
+
+    mockSingleRedirectSuccess();
+
+    testResponseHeader.put("Set-Cookie", "testcookie=testcookie; Path=/video");
+
+    dataSourceUnderTest.open(testDataSpec);
+    verify(mockUrlRequestBuilder).addHeader(eq("Cookie"), any(String.class));
+    verify(mockUrlRequestBuilder, times(2)).addHeader("Range", "bytes=1000-5999");
+    verify(mockUrlRequestBuilder, times(2)).addHeader("Content-Type", TEST_CONTENT_TYPE);
+    verify(mockUrlRequest, never()).followRedirect();
+    verify(mockUrlRequest, times(2)).start();
+  }
+
+  @Test
+  public void testRedirectNoSetCookieFollowsRedirect() throws HttpDataSourceException {
+    mockSingleRedirectSuccess();
+    mockFollowRedirectSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+    verify(mockUrlRequestBuilder, never()).addHeader(eq("Cookie"), any(String.class));
+    verify(mockUrlRequest).followRedirect();
+  }
+
+  @Test
+  public void testRedirectNoSetCookieFollowsRedirect_dataSourceHandlesSetCookie()
+      throws HttpDataSourceException {
+    dataSourceUnderTest = spy(
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockContentTypePredicate,
+            mockTransferListener,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true, // resetTimeoutOnRedirects
+            mockClock,
+            null,
+            true));
+    mockSingleRedirectSuccess();
+    mockFollowRedirectSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+    verify(mockUrlRequestBuilder, never()).addHeader(eq("Cookie"), any(String.class));
+    verify(mockUrlRequest).followRedirect();
+  }
+
   @Test
   public void testExceptionFromTransferListener() throws HttpDataSourceException {
     mockResponseStartSuccess();
@@ -684,6 +839,38 @@ public void testReadFailure() throws HttpDataSourceException {
     }
   }
 
+  @Test
+  public void testReadInterrupted() throws HttpDataSourceException {
+    when(mockClock.elapsedRealtime()).thenReturn(0L);
+    mockResponseStartSuccess();
+    dataSourceUnderTest.open(testDataSpec);
+
+    final ConditionVariable startCondition = buildReadStartedCondition();
+    final ConditionVariable timedOutCondition = new ConditionVariable();
+    byte[] returnedBuffer = new byte[8];
+    Thread thread =
+        new Thread() {
+          @Override
+          public void run() {
+            try {
+              dataSourceUnderTest.read(returnedBuffer, 0, 8);
+              fail();
+            } catch (HttpDataSourceException e) {
+              // Expected.
+              assertTrue(e.getCause() instanceof CronetDataSource.InterruptedIOException);
+              timedOutCondition.open();
+            }
+          }
+        };
+    thread.start();
+    startCondition.block();
+
+    assertFalse(timedOutCondition.block(50));
+    // Now we interrupt.
+    thread.interrupt();
+    timedOutCondition.block();
+  }
+
   @Test
   public void testAllowDirectExecutor() throws HttpDataSourceException {
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
@@ -732,6 +919,38 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }).when(mockUrlRequest).start();
   }
 
+  private void mockSingleRedirectSuccess() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        if (!redirectCalled) {
+          redirectCalled = true;
+          dataSourceUnderTest.onRedirectReceived(
+              mockUrlRequest,
+              createUrlResponseInfoWithUrl("http://example.com/video", 300),
+              "http://example.com/video/redirect");
+        } else {
+          dataSourceUnderTest.onResponseStarted(
+              mockUrlRequest,
+              testUrlResponseInfo);
+        }
+        return null;
+      }
+    }).when(mockUrlRequest).start();
+  }
+
+  private void mockFollowRedirectSuccess() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        dataSourceUnderTest.onResponseStarted(
+            mockUrlRequest,
+            testUrlResponseInfo);
+        return null;
+      }
+    }).when(mockUrlRequest).followRedirect();
+  }
+
   private void mockResponseStartFailure() {
     doAnswer(new Answer<Object>() {
       @Override
@@ -769,16 +988,34 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
   }
 
   private void mockReadFailure() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onFailed(
-            mockUrlRequest,
-            createUrlResponseInfo(500), // statusCode
-            mockNetworkException);
-        return null;
-      }
-    }).when(mockUrlRequest).read(any(ByteBuffer.class));
+    doAnswer(
+        new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) throws Throwable {
+            dataSourceUnderTest.onFailed(
+                mockUrlRequest,
+                createUrlResponseInfo(500), // statusCode
+                mockNetworkException);
+            return null;
+          }
+        })
+        .when(mockUrlRequest)
+        .read(any(ByteBuffer.class));
+  }
+
+  private ConditionVariable buildReadStartedCondition() {
+    final ConditionVariable startedCondition = new ConditionVariable();
+    doAnswer(
+        new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) throws Throwable {
+            startedCondition.open();
+            return null;
+          }
+        })
+        .when(mockUrlRequest)
+        .read(any(ByteBuffer.class));
+    return startedCondition;
   }
 
   private ConditionVariable buildUrlRequestStartedCondition() {
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 204a2756bb..536155a70f 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import android.net.Uri;
-import android.os.ConditionVariable;
 import android.text.TextUtils;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
@@ -27,6 +26,7 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.Predicate;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
@@ -74,6 +74,14 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
 
   }
 
+  /** Thrown on catching an InterruptedException. */
+  public static final class InterruptedIOException extends IOException {
+
+    public InterruptedIOException(InterruptedException e) {
+      super(e);
+    }
+  }
+
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.cronet");
   }
@@ -89,6 +97,9 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
 
   private static final String TAG = "CronetDataSource";
   private static final String CONTENT_TYPE = "Content-Type";
+  private static final String SET_COOKIE = "Set-Cookie";
+  private static final String COOKIE = "Cookie";
+
   private static final Pattern CONTENT_RANGE_HEADER_PATTERN =
       Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
   // The size of read buffer passed to cronet UrlRequest.read().
@@ -101,6 +112,7 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
+  private final boolean handleSetCookieRequests;
   private final RequestProperties defaultRequestProperties;
   private final RequestProperties requestProperties;
   private final ConditionVariable operation;
@@ -144,7 +156,7 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
   public CronetDataSource(CronetEngine cronetEngine, Executor executor,
       Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener) {
     this(cronetEngine, executor, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
-        DEFAULT_READ_TIMEOUT_MILLIS, false, null);
+        DEFAULT_READ_TIMEOUT_MILLIS, false, null, false);
   }
 
   /**
@@ -168,13 +180,40 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
       int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects,
       RequestProperties defaultRequestProperties) {
     this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
-        readTimeoutMs, resetTimeoutOnRedirects, Clock.DEFAULT, defaultRequestProperties);
+        readTimeoutMs, resetTimeoutOnRedirects, Clock.DEFAULT, defaultRequestProperties, false);
+  }
+
+  /**
+   * @param cronetEngine A CronetEngine.
+   * @param executor The {@link java.util.concurrent.Executor} that will handle responses.
+   *     This may be a direct executor (i.e. executes tasks on the calling thread) in order
+   *     to avoid a thread hop from Cronet's internal network thread to the response handling
+   *     thread. However, to avoid slowing down overall network performance, care must be taken
+   *     to make sure response handling is a fast operation when using a direct executor.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from
+   *     {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   * @param connectTimeoutMs The connection timeout, in milliseconds.
+   * @param readTimeoutMs The read timeout, in milliseconds.
+   * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
+   * @param defaultRequestProperties The default request properties to be used.
+   * @param handleSetCookieRequests Whether "Set-Cookie" requests on redirect should be forwarded to
+   *     the redirect url in the "Cookie" header.
+   */
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
+      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects,
+      RequestProperties defaultRequestProperties, boolean handleSetCookieRequests) {
+    this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
+        readTimeoutMs, resetTimeoutOnRedirects, Clock.DEFAULT, defaultRequestProperties,
+        handleSetCookieRequests);
   }
 
   /* package */ CronetDataSource(CronetEngine cronetEngine, Executor executor,
       Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
       int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock,
-      RequestProperties defaultRequestProperties) {
+      RequestProperties defaultRequestProperties, boolean handleSetCookieRequests) {
     this.cronetEngine = Assertions.checkNotNull(cronetEngine);
     this.executor = Assertions.checkNotNull(executor);
     this.contentTypePredicate = contentTypePredicate;
@@ -184,6 +223,7 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
     this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
     this.clock = Assertions.checkNotNull(clock);
     this.defaultRequestProperties = defaultRequestProperties;
+    this.handleSetCookieRequests = handleSetCookieRequests;
     requestProperties = new RequestProperties();
     operation = new ConditionVariable();
   }
@@ -223,15 +263,24 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     operation.close();
     resetConnectTimeout();
     currentDataSpec = dataSpec;
-    currentUrlRequest = buildRequest(dataSpec);
+    try {
+      currentUrlRequest = buildRequestBuilder(dataSpec).build();
+    } catch (IOException e) {
+      throw new OpenException(e, currentDataSpec, Status.IDLE);
+    }
     currentUrlRequest.start();
-    boolean requestStarted = blockUntilConnectTimeout();
 
-    if (exception != null) {
-      throw new OpenException(exception, currentDataSpec, getStatus(currentUrlRequest));
-    } else if (!requestStarted) {
-      // The timeout was reached before the connection was opened.
-      throw new OpenException(new SocketTimeoutException(), dataSpec, getStatus(currentUrlRequest));
+    try {
+      boolean connectionOpened = blockUntilConnectTimeout();
+      if (exception != null) {
+        throw new OpenException(exception, currentDataSpec, getStatus(currentUrlRequest));
+      } else if (!connectionOpened) {
+        // The timeout was reached before the connection was opened.
+        throw new OpenException(
+            new SocketTimeoutException(), dataSpec, getStatus(currentUrlRequest));
+      }
+    } catch (InterruptedException e) {
+      throw new OpenException(new InterruptedIOException(e), dataSpec, Status.INVALID);
     }
 
     // Check for a valid response code.
@@ -299,14 +348,24 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
       operation.close();
       readBuffer.clear();
       currentUrlRequest.read(readBuffer);
-      if (!operation.block(readTimeoutMs)) {
-        // We're timing out, but since the operation is still ongoing we'll need to replace
-        // readBuffer to avoid the possibility of it being written to by this operation during a
-        // subsequent request.
+      try {
+        if (!operation.block(readTimeoutMs)) {
+          throw new SocketTimeoutException();
+        }
+      } catch (InterruptedException | SocketTimeoutException e) {
+        // If we're timing out or getting interrupted, the operation is still ongoing.
+        // So we'll need to replace readBuffer to avoid the possibility of it being written to by
+        // this operation during a subsequent request.
         readBuffer = null;
         throw new HttpDataSourceException(
-            new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
-      } else if (exception != null) {
+            e instanceof InterruptedException
+                ? new InterruptedIOException((InterruptedException) e)
+                : (SocketTimeoutException) e,
+            currentDataSpec,
+            HttpDataSourceException.TYPE_READ);
+      }
+
+      if (exception != null) {
         throw new HttpDataSourceException(exception, currentDataSpec,
             HttpDataSourceException.TYPE_READ);
       } else if (finished) {
@@ -379,7 +438,28 @@ public synchronized void onRedirectReceived(UrlRequest request, UrlResponseInfo
     if (resetTimeoutOnRedirects) {
       resetConnectTimeout();
     }
-    request.followRedirect();
+
+    Map<String, List<String>> headers = info.getAllHeaders();
+    if (!handleSetCookieRequests || isEmpty(headers.get(SET_COOKIE))) {
+      request.followRedirect();
+    } else {
+      currentUrlRequest.cancel();
+      DataSpec redirectUrlDataSpec = new DataSpec(Uri.parse(newLocationUrl),
+          currentDataSpec.postBody, currentDataSpec.absoluteStreamPosition,
+          currentDataSpec.position, currentDataSpec.length, currentDataSpec.key,
+          currentDataSpec.flags);
+      UrlRequest.Builder requestBuilder;
+      try {
+        requestBuilder = buildRequestBuilder(redirectUrlDataSpec);
+      } catch (IOException e) {
+        exception = e;
+        return;
+      }
+      String cookieHeadersValue = parseCookies(headers.get(SET_COOKIE));
+      attachCookies(requestBuilder, cookieHeadersValue);
+      currentUrlRequest = requestBuilder.build();
+      currentUrlRequest.start();
+    }
   }
 
   @Override
@@ -427,7 +507,7 @@ public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
 
   // Internal methods.
 
-  private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
+  private UrlRequest.Builder buildRequestBuilder(DataSpec dataSpec) throws IOException {
     UrlRequest.Builder requestBuilder = cronetEngine.newUrlRequestBuilder(
         dataSpec.uri.toString(), this, executor).allowDirectExecutor();
     // Set the headers.
@@ -446,20 +526,25 @@ private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
       requestBuilder.addHeader(key, headerEntry.getValue());
     }
     if (dataSpec.postBody != null && dataSpec.postBody.length != 0 && !isContentTypeHeaderSet) {
-      throw new OpenException("POST request with non-empty body must set Content-Type", dataSpec,
-          Status.IDLE);
+      throw new IOException("POST request with non-empty body must set Content-Type");
     }
     // Set the Range header.
-    if (currentDataSpec.position != 0 || currentDataSpec.length != C.LENGTH_UNSET) {
+    if (dataSpec.position != 0 || dataSpec.length != C.LENGTH_UNSET) {
       StringBuilder rangeValue = new StringBuilder();
       rangeValue.append("bytes=");
-      rangeValue.append(currentDataSpec.position);
+      rangeValue.append(dataSpec.position);
       rangeValue.append("-");
-      if (currentDataSpec.length != C.LENGTH_UNSET) {
-        rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
+      if (dataSpec.length != C.LENGTH_UNSET) {
+        rangeValue.append(dataSpec.position + dataSpec.length - 1);
       }
       requestBuilder.addHeader("Range", rangeValue.toString());
     }
+    // TODO: Uncomment when https://bugs.chromium.org/p/chromium/issues/detail?id=767025 is fixed
+    // (adjusting the code as necessary).
+    // Force identity encoding unless gzip is allowed.
+    // if (!dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP)) {
+    //   requestBuilder.addHeader("Accept-Encoding", "identity");
+    // }
     // Set the method and (if non-empty) the body.
     if (dataSpec.postBody != null) {
       requestBuilder.setHttpMethod("POST");
@@ -468,10 +553,10 @@ private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
             executor);
       }
     }
-    return requestBuilder.build();
+    return requestBuilder;
   }
 
-  private boolean blockUntilConnectTimeout() {
+  private boolean blockUntilConnectTimeout() throws InterruptedException {
     long now = clock.elapsedRealtime();
     boolean opened = false;
     while (!opened && now < currentConnectTimeoutMs) {
@@ -538,7 +623,18 @@ private static long getContentLength(UrlResponseInfo info) {
     return contentLength;
   }
 
-  private static int getStatus(UrlRequest request) {
+  private static String parseCookies(List<String> setCookieHeaders) {
+    return TextUtils.join(";", setCookieHeaders);
+  }
+
+  private static void attachCookies(UrlRequest.Builder requestBuilder, String cookies) {
+    if (TextUtils.isEmpty(cookies)) {
+      return;
+    }
+    requestBuilder.addHeader(COOKIE, cookies);
+  }
+
+  private static int getStatus(UrlRequest request) throws InterruptedException {
     final ConditionVariable conditionVariable = new ConditionVariable();
     final int[] statusHolder = new int[1];
     request.getStatus(new UrlRequest.StatusListener() {
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index 57b637d1e2..b29c836887 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -3,6 +3,14 @@
 The FFmpeg extension provides `FfmpegAudioRenderer`, which uses FFmpeg for
 decoding and can render audio encoded in a variety of formats.
 
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension also requires building and including one or
+more external libraries as described below. These are licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
 ## Build instructions ##
 
 To use this extension you need to clone the ExoPlayer repository and depend on
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index 453a18476e..ed8a5b0eac 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.MimeTypes;
 
@@ -58,13 +59,18 @@ public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener even
   }
 
   @Override
-  protected int supportsFormatInternal(Format format) {
-    if (!FfmpegLibrary.isAvailable()) {
+  protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      Format format) {
+    String sampleMimeType = format.sampleMimeType;
+    if (!FfmpegLibrary.isAvailable() || !MimeTypes.isAudio(sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!FfmpegLibrary.supportsFormat(sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_SUBTYPE;
+    } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
+    } else {
+      return FORMAT_HANDLED;
     }
-    String mimeType = format.sampleMimeType;
-    return FfmpegLibrary.supportsFormat(mimeType) ? FORMAT_HANDLED
-        : MimeTypes.isAudio(mimeType) ? FORMAT_UNSUPPORTED_SUBTYPE : FORMAT_UNSUPPORTED_TYPE;
   }
 
   @Override
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
index 113b41a93d..fda5f0085d 100644
--- a/extensions/flac/README.md
+++ b/extensions/flac/README.md
@@ -3,6 +3,14 @@
 The Flac extension provides `FlacExtractor` and `LibflacAudioRenderer`, which
 use libFLAC (the Flac decoding library) to extract and decode FLAC audio.
 
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension also requires building and including one or
+more external libraries as described below. These are licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
 ## Build instructions ##
 
 To use this extension you need to clone the ExoPlayer repository and depend on
@@ -30,7 +38,7 @@ NDK_PATH="<path to Android NDK>"
 
 ```
 cd "${FLAC_EXT_PATH}/jni" && \
-curl http://downloads.xiph.org/releases/flac/flac-1.3.1.tar.xz | tar xJ && \
+curl https://ftp.osuosl.org/pub/xiph/releases/flac/flac-1.3.1.tar.xz | tar xJ && \
 mv flac-1.3.1 flac
 ```
 
diff --git a/extensions/flac/src/androidTest/AndroidManifest.xml b/extensions/flac/src/androidTest/AndroidManifest.xml
index 73032ab50c..8a7ad50429 100644
--- a/extensions/flac/src/androidTest/AndroidManifest.xml
+++ b/extensions/flac/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.flac.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index 1fa30bed9d..65fb4c8195 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -22,15 +22,11 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
-import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
 /**
@@ -45,20 +41,22 @@ public void testBasicPlayback() throws ExoPlaybackException {
   }
 
   private void playUri(String uri) throws ExoPlaybackException {
-    TestPlaybackThread thread = new TestPlaybackThread(Uri.parse(uri),
+    TestPlaybackRunnable testPlaybackRunnable = new TestPlaybackRunnable(Uri.parse(uri),
         getInstrumentation().getContext());
+    Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
     try {
       thread.join();
     } catch (InterruptedException e) {
       fail(); // Should never happen.
     }
-    if (thread.playbackException != null) {
-      throw thread.playbackException;
+    if (testPlaybackRunnable.playbackException != null) {
+      throw testPlaybackRunnable.playbackException;
     }
   }
 
-  private static class TestPlaybackThread extends Thread implements Player.EventListener {
+  private static class TestPlaybackRunnable extends Player.DefaultEventListener
+      implements Runnable {
 
     private final Context context;
     private final Uri uri;
@@ -66,7 +64,7 @@ private void playUri(String uri) throws ExoPlaybackException {
     private ExoPlayer player;
     private ExoPlaybackException playbackException;
 
-    public TestPlaybackThread(Uri uri, Context context) {
+    public TestPlaybackRunnable(Uri uri, Context context) {
       this.uri = uri;
       this.context = context;
     }
@@ -89,31 +87,6 @@ public void run() {
       Looper.loop();
     }
 
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPositionDiscontinuity() {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
-      // Do nothing.
-    }
-
     @Override
     public void onPlayerError(ExoPlaybackException error) {
       playbackException = error;
@@ -123,20 +96,11 @@ public void onPlayerError(ExoPlaybackException error) {
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       if (playbackState == Player.STATE_ENDED
           || (playbackState == Player.STATE_IDLE && playbackException != null)) {
-        releasePlayerAndQuitLooper();
+        player.release();
+        Looper.myLooper().quit();
       }
     }
 
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-      // Do nothing.
-    }
-
-    private void releasePlayerAndQuitLooper() {
-      player.release();
-      Looper.myLooper().quit();
-    }
-
   }
 
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index 7b71b5c743..a2f141a712 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
+import static com.google.android.exoplayer2.util.Util.getPcmEncoding;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -122,10 +124,20 @@ public long getDurationUs() {
         }
 
       });
-
-      Format mediaFormat = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_RAW, null,
-          streamInfo.bitRate(), Format.NO_VALUE, streamInfo.channels, streamInfo.sampleRate,
-          C.ENCODING_PCM_16BIT, null, null, 0, null);
+      Format mediaFormat =
+          Format.createAudioSampleFormat(
+              null,
+              MimeTypes.AUDIO_RAW,
+              null,
+              streamInfo.bitRate(),
+              Format.NO_VALUE,
+              streamInfo.channels,
+              streamInfo.sampleRate,
+              getPcmEncoding(streamInfo.bitsPerSample),
+              null,
+              null,
+              0,
+              null);
       trackOutput.format(mediaFormat);
 
       outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index 246cde9d2f..dc376d2ea4 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.MimeTypes;
 
@@ -46,9 +47,16 @@ public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eve
   }
 
   @Override
-  protected int supportsFormatInternal(Format format) {
-    return FlacLibrary.isAvailable() && MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)
-        ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+  protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      Format format) {
+    if (!FlacLibrary.isAvailable()
+        || !MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
+    } else {
+      return FORMAT_HANDLED;
+    }
   }
 
   @Override
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index 6c6e57f5f7..b9918e7871 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -42,6 +42,9 @@
 #define CHECK(x) \
   if (!(x)) ALOGE("Check failed: %s ", #x)
 
+const int endian = 1;
+#define isBigEndian() (*(reinterpret_cast<const char *>(&endian)) == 0)
+
 // The FLAC parser calls our C++ static callbacks using C calling conventions,
 // inside FLAC__stream_decoder_process_until_end_of_metadata
 // and FLAC__stream_decoder_process_single.
@@ -180,85 +183,42 @@ void FLACParser::errorCallback(FLAC__StreamDecoderErrorStatus status) {
   mErrorStatus = status;
 }
 
-// Copy samples from FLAC native 32-bit non-interleaved to 16-bit interleaved.
+// Copy samples from FLAC native 32-bit non-interleaved to
+// correct bit-depth (non-zero padded), interleaved.
 // These are candidates for optimization if needed.
-
-static void copyMono8(int16_t *dst, const int *const *src, unsigned nSamples,
-                      unsigned /* nChannels */) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    *dst++ = src[0][i] << 8;
-  }
-}
-
-static void copyStereo8(int16_t *dst, const int *const *src, unsigned nSamples,
-                        unsigned /* nChannels */) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    *dst++ = src[0][i] << 8;
-    *dst++ = src[1][i] << 8;
-  }
-}
-
-static void copyMultiCh8(int16_t *dst, const int *const *src, unsigned nSamples,
-                         unsigned nChannels) {
+static void copyToByteArrayBigEndian(int8_t *dst, const int *const *src,
+                                     unsigned bytesPerSample, unsigned nSamples,
+                                     unsigned nChannels) {
   for (unsigned i = 0; i < nSamples; ++i) {
     for (unsigned c = 0; c < nChannels; ++c) {
-      *dst++ = src[c][i] << 8;
+      // point to the first byte of the source address
+      // and then skip the first few bytes (most significant bytes)
+      // depending on the bit depth
+      const int8_t *byteSrc =
+          reinterpret_cast<const int8_t *>(&src[c][i]) + 4 - bytesPerSample;
+      memcpy(dst, byteSrc, bytesPerSample);
+      dst = dst + bytesPerSample;
     }
   }
 }
 
-static void copyMono16(int16_t *dst, const int *const *src, unsigned nSamples,
-                       unsigned /* nChannels */) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    *dst++ = src[0][i];
-  }
-}
-
-static void copyStereo16(int16_t *dst, const int *const *src, unsigned nSamples,
-                         unsigned /* nChannels */) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    *dst++ = src[0][i];
-    *dst++ = src[1][i];
-  }
-}
-
-static void copyMultiCh16(int16_t *dst, const int *const *src,
-                          unsigned nSamples, unsigned nChannels) {
+static void copyToByteArrayLittleEndian(int8_t *dst, const int *const *src,
+                                        unsigned bytesPerSample,
+                                        unsigned nSamples, unsigned nChannels) {
   for (unsigned i = 0; i < nSamples; ++i) {
     for (unsigned c = 0; c < nChannels; ++c) {
-      *dst++ = src[c][i];
+      // with little endian, the most significant bytes will be at the end
+      // copy the bytes in little endian will remove the most significant byte
+      // so we are good here.
+      memcpy(dst, &(src[c][i]), bytesPerSample);
+      dst = dst + bytesPerSample;
     }
   }
 }
 
-// 24-bit versions should do dithering or noise-shaping, here or in AudioFlinger
-
-static void copyMono24(int16_t *dst, const int *const *src, unsigned nSamples,
-                       unsigned /* nChannels */) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    *dst++ = src[0][i] >> 8;
-  }
-}
-
-static void copyStereo24(int16_t *dst, const int *const *src, unsigned nSamples,
+static void copyTrespass(int8_t * /* dst */, const int *const * /* src */,
+                         unsigned /* bytesPerSample */, unsigned /* nSamples */,
                          unsigned /* nChannels */) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    *dst++ = src[0][i] >> 8;
-    *dst++ = src[1][i] >> 8;
-  }
-}
-
-static void copyMultiCh24(int16_t *dst, const int *const *src,
-                          unsigned nSamples, unsigned nChannels) {
-  for (unsigned i = 0; i < nSamples; ++i) {
-    for (unsigned c = 0; c < nChannels; ++c) {
-      *dst++ = src[c][i] >> 8;
-    }
-  }
-}
-
-static void copyTrespass(int16_t * /* dst */, const int *const * /* src */,
-                         unsigned /* nSamples */, unsigned /* nChannels */) {
   TRESPASS();
 }
 
@@ -340,6 +300,7 @@ bool FLACParser::decodeMetadata() {
       case 8:
       case 16:
       case 24:
+      case 32:
         break;
       default:
         ALOGE("unsupported bits per sample %u", getBitsPerSample());
@@ -363,23 +324,11 @@ bool FLACParser::decodeMetadata() {
         ALOGE("unsupported sample rate %u", getSampleRate());
         return false;
     }
-    // configure the appropriate copy function, defaulting to trespass
-    static const struct {
-      unsigned mChannels;
-      unsigned mBitsPerSample;
-      void (*mCopy)(int16_t *dst, const int *const *src, unsigned nSamples,
-                    unsigned nChannels);
-    } table[] = {
-        {1, 8, copyMono8},   {2, 8, copyStereo8},   {8, 8, copyMultiCh8},
-        {1, 16, copyMono16}, {2, 16, copyStereo16}, {8, 16, copyMultiCh16},
-        {1, 24, copyMono24}, {2, 24, copyStereo24}, {8, 24, copyMultiCh24},
-    };
-    for (unsigned i = 0; i < sizeof(table) / sizeof(table[0]); ++i) {
-      if (table[i].mChannels >= getChannels() &&
-          table[i].mBitsPerSample == getBitsPerSample()) {
-        mCopy = table[i].mCopy;
-        break;
-      }
+    // configure the appropriate copy function based on device endianness.
+    if (isBigEndian()) {
+      mCopy = copyToByteArrayBigEndian;
+    } else {
+      mCopy = copyToByteArrayLittleEndian;
     }
   } else {
     ALOGE("missing STREAMINFO");
@@ -424,7 +373,8 @@ size_t FLACParser::readBuffer(void *output, size_t output_size) {
     return -1;
   }
 
-  size_t bufferSize = blocksize * getChannels() * sizeof(int16_t);
+  unsigned bytesPerSample = getBitsPerSample() >> 3;
+  size_t bufferSize = blocksize * getChannels() * bytesPerSample;
   if (bufferSize > output_size) {
     ALOGE(
         "FLACParser::readBuffer not enough space in output buffer "
@@ -434,8 +384,8 @@ size_t FLACParser::readBuffer(void *output, size_t output_size) {
   }
 
   // copy PCM from FLAC write buffer to our media buffer, with interleaving.
-  (*mCopy)(reinterpret_cast<int16_t *>(output), mWriteBuffer, blocksize,
-           getChannels());
+  (*mCopy)(reinterpret_cast<int8_t *>(output), mWriteBuffer, bytesPerSample,
+           blocksize, getChannels());
 
   // fill in buffer metadata
   CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
index 8c302adb36..8a769b66d4 100644
--- a/extensions/flac/src/main/jni/include/flac_parser.h
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -86,8 +86,8 @@ class FLACParser {
  private:
   DataSource *mDataSource;
 
-  void (*mCopy)(int16_t *dst, const int *const *src, unsigned nSamples,
-                unsigned nChannels);
+  void (*mCopy)(int8_t *dst, const int *const *src, unsigned bytesPerSample,
+                unsigned nSamples, unsigned nChannels);
 
   // handle to underlying libFLAC parser
   FLAC__StreamDecoder *mDecoder;
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index 66665576bb..8236024512 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -26,7 +26,7 @@ android {
 
 dependencies {
     compile project(modulePrefix + 'library-core')
-    compile 'com.google.vr:sdk-audio:1.60.1'
+    compile 'com.google.vr:sdk-audio:1.80.0'
 }
 
 ext {
diff --git a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
index 5750f5f04d..8d71f551cd 100644
--- a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
+++ b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
@@ -138,6 +138,11 @@ public int getOutputEncoding() {
     return C.ENCODING_PCM_16BIT;
   }
 
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
   @Override
   public void queueInput(ByteBuffer input) {
     int position = input.position();
diff --git a/extensions/ima/README.md b/extensions/ima/README.md
index 4f63214f04..a796ca8694 100644
--- a/extensions/ima/README.md
+++ b/extensions/ima/README.md
@@ -1,11 +1,11 @@
 # ExoPlayer IMA extension #
 
-The IMA extension is a [MediaSource][] implementation wrapping the
+The IMA extension is an [AdsLoader][] implementation wrapping the
 [Interactive Media Ads SDK for Android][IMA]. You can use it to insert ads
 alongside content.
 
 [IMA]: https://developers.google.com/interactive-media-ads/docs/sdks/android/
-[MediaSource]: https://google.github.io/ExoPlayer/doc/reference/index.html?com/google/android/exoplayer2/source/MediaSource.html
+[AdsLoader]: https://google.github.io/ExoPlayer/doc/reference/index.html?com/google/android/exoplayer2/source/ads/AdsLoader.html
 
 ## Getting the extension ##
 
@@ -27,7 +27,7 @@ locally. Instructions for doing this can be found in ExoPlayer's
 ## Using the extension ##
 
 To play ads alongside a single-window content `MediaSource`, prepare the player
-with an `ImaAdsMediaSource` constructed using an `ImaAdsLoader`, the content
+with an `AdsMediaSource` constructed using an `ImaAdsLoader`, the content
 `MediaSource` and an overlay `ViewGroup` on top of the player. Pass an ad tag
 URI from your ad campaign when creating the `ImaAdsLoader`. The IMA
 documentation includes some [sample ad tags][] for testing.
@@ -38,7 +38,7 @@ background, and are recreated when the player returns to the foreground. When
 playing ads it is necessary to persist ad playback state while in the background
 by keeping a reference to the `ImaAdsLoader`. Reuse it when resuming playback of
 the same content/ads by passing it in when constructing the new
-`ImaAdsMediaSource`. It is also important to persist the player position when
+`AdsMediaSource`. It is also important to persist the player position when
 entering the background by storing the value of `player.getContentPosition()`.
 On returning to the foreground, seek to that position before preparing the new
 player instance. Finally, it is important to call `ImaAdsLoader.release()` when
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index c9285162a8..5038aaf5b9 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -19,7 +19,7 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 14
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
@@ -28,14 +28,15 @@ android {
 dependencies {
     compile project(modulePrefix + 'library-core')
     // This dependency is necessary to force the supportLibraryVersion of
-    // com.android.support:support-v4 to be used. Else an older version (25.2.0) is included via:
-    // com.google.android.gms:play-services-ads:11.0.2
-    // |-- com.google.android.gms:play-services-ads-lite:[11.0.2] -> 11.0.2
-    //   |-- com.google.android.gms:play-services-basement:[11.0.2] -> 11.0.2
+    // com.android.support:support-v4 to be used. Else an older version (25.2.0)
+    // is included via:
+    // com.google.android.gms:play-services-ads:11.4.2
+    // |-- com.google.android.gms:play-services-ads-lite:11.4.2
+    //   |-- com.google.android.gms:play-services-basement:11.4.2
     //     |-- com.android.support:support-v4:25.2.0
     compile 'com.android.support:support-v4:' + supportLibraryVersion
     compile 'com.google.ads.interactivemedia.v3:interactivemedia:3.7.4'
-    compile 'com.google.android.gms:play-services-ads:11.0.2'
+    compile 'com.google.android.gms:play-services-ads:' + playServicesLibraryVersion
     androidTestCompile project(modulePrefix + 'library')
     androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index b6d9280579..5b61db0264 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -18,6 +18,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.SystemClock;
+import android.support.annotation.IntDef;
 import android.util.Log;
 import android.view.ViewGroup;
 import android.webkit.WebView;
@@ -29,7 +30,6 @@
 import com.google.ads.interactivemedia.v3.api.AdEvent.AdEventListener;
 import com.google.ads.interactivemedia.v3.api.AdEvent.AdEventType;
 import com.google.ads.interactivemedia.v3.api.AdPodInfo;
-import com.google.ads.interactivemedia.v3.api.AdsLoader;
 import com.google.ads.interactivemedia.v3.api.AdsLoader.AdsLoadedListener;
 import com.google.ads.interactivemedia.v3.api.AdsManager;
 import com.google.ads.interactivemedia.v3.api.AdsManagerLoadedEvent;
@@ -44,13 +44,14 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -58,39 +59,8 @@
 /**
  * Loads ads using the IMA SDK. All methods are called on the main thread.
  */
-public final class ImaAdsLoader implements Player.EventListener, VideoAdPlayer,
-    ContentProgressProvider, AdErrorListener, AdsLoadedListener, AdEventListener {
-
-  /**
-   * Listener for ad loader events. All methods are called on the main thread.
-   */
-  /* package */ interface EventListener {
-
-    /**
-     * Called when the ad playback state has been updated.
-     *
-     * @param adPlaybackState The new ad playback state.
-     */
-    void onAdPlaybackState(AdPlaybackState adPlaybackState);
-
-    /**
-     * Called when there was an error loading ads.
-     *
-     * @param error The error.
-     */
-    void onLoadError(IOException error);
-
-    /**
-     * Called when the user clicks through an ad (for example, following a 'learn more' link).
-     */
-    void onAdClicked();
-
-    /**
-     * Called when the user taps a non-clickthrough part of an ad.
-     */
-    void onAdTapped();
-
-  }
+public final class ImaAdsLoader extends Player.DefaultEventListener implements AdsLoader,
+    VideoAdPlayer, ContentProgressProvider, AdErrorListener, AdsLoadedListener, AdEventListener {
 
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.ima");
@@ -121,12 +91,31 @@
   private static final String FOCUS_SKIP_BUTTON_WORKAROUND_JS = "javascript:"
       + "try{ document.getElementsByClassName(\"videoAdUiSkipButton\")[0].focus(); } catch (e) {}";
 
+  /**
+   * The state of ad playback based on IMA's calls to {@link #playAd()} and {@link #pauseAd()}.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({IMA_AD_STATE_NONE, IMA_AD_STATE_PLAYING, IMA_AD_STATE_PAUSED})
+  private @interface ImaAdState {}
+  /**
+   * The ad playback state when IMA is not playing an ad.
+   */
+  private static final int IMA_AD_STATE_NONE = 0;
+  /**
+   * The ad playback state when IMA has called {@link #playAd()} and not {@link #pauseAd()}.
+   */
+  private static final int IMA_AD_STATE_PLAYING = 1;
+  /**
+   * The ad playback state when IMA has called {@link #pauseAd()} while playing an ad.
+   */
+  private static final int IMA_AD_STATE_PAUSED = 2;
+
   private final Uri adTagUri;
   private final Timeline.Period period;
   private final List<VideoAdPlayerCallback> adCallbacks;
   private final ImaSdkFactory imaSdkFactory;
   private final AdDisplayContainer adDisplayContainer;
-  private final AdsLoader adsLoader;
+  private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
   private EventListener eventListener;
   private Player player;
@@ -150,26 +139,17 @@
    */
   private boolean imaPausedContent;
   /**
-   * If {@link #playingAd} is set, stores whether IMA has called {@link #playAd()} and not
-   * {@link #stopAd()}.
-   */
-  private boolean imaPlayingAd;
-  /**
-   * If {@link #playingAd} is set, stores whether IMA has called {@link #pauseAd()} since a
-   * preceding call to {@link #playAd()} for the current ad.
+   * The current ad playback state based on IMA's calls to {@link #playAd()} and {@link #stopAd()}.
    */
-  private boolean imaPausedInAd;
+  private @ImaAdState int imaAdState;
   /**
-   * Whether {@link AdsLoader#contentComplete()} has been called since starting ad playback.
+   * Whether {@link com.google.ads.interactivemedia.v3.api.AdsLoader#contentComplete()} has been
+   * called since starting ad playback.
    */
   private boolean sentContentComplete;
 
   // Fields tracking the player/loader state.
 
-  /**
-   * Whether the player's play when ready flag has temporarily been set to true for playing ads.
-   */
-  private boolean playWhenReadyOverriddenForAds;
   /**
    * Whether the player is playing an ad.
    */
@@ -249,14 +229,17 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
   }
 
   /**
-   * Attaches a player that will play ads loaded using this instance.
-   *
-   * @param player The player instance that will play the loaded ads.
-   * @param eventListener Listener for ads loader events.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * Returns the underlying {@code com.google.ads.interactivemedia.v3.api.AdsLoader} wrapped by
+   * this instance.
    */
-  /* package */ void attachPlayer(ExoPlayer player, EventListener eventListener,
-      ViewGroup adUiViewGroup) {
+  public com.google.ads.interactivemedia.v3.api.AdsLoader getAdsLoader() {
+    return adsLoader;
+  }
+
+  // AdsLoader implementation.
+
+  @Override
+  public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup) {
     this.player = player;
     this.eventListener = eventListener;
     this.adUiViewGroup = adUiViewGroup;
@@ -265,8 +248,8 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
     adDisplayContainer.setAdContainer(adUiViewGroup);
     player.addListener(this);
     if (adPlaybackState != null) {
-      eventListener.onAdPlaybackState(adPlaybackState);
-      if (imaPausedContent) {
+      eventListener.onAdPlaybackState(adPlaybackState.copy());
+      if (imaPausedContent && player.getPlayWhenReady()) {
         adsManager.resume();
       }
     } else {
@@ -274,14 +257,10 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
     }
   }
 
-  /**
-   * Detaches the attached player and event listener. To attach a new player, call
-   * {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. Call {@link #release()} to release
-   * all resources associated with this instance.
-   */
-  /* package */ void detachPlayer() {
+  @Override
+  public void detachPlayer() {
     if (adsManager != null && imaPausedContent) {
-      adPlaybackState.setAdResumePositionUs(C.msToUs(player.getCurrentPosition()));
+      adPlaybackState.setAdResumePositionUs(playingAd ? C.msToUs(player.getCurrentPosition()) : 0);
       adsManager.pause();
     }
     lastAdProgress = getAdProgress();
@@ -292,9 +271,7 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
     adUiViewGroup = null;
   }
 
-  /**
-   * Releases the loader. Must be called when the instance is no longer needed.
-   */
+  @Override
   public void release() {
     released = true;
     if (adsManager != null) {
@@ -303,7 +280,7 @@ public void release() {
     }
   }
 
-  // AdsLoader.AdsLoadedListener implementation.
+  // com.google.ads.interactivemedia.v3.api.AdsLoader.AdsLoadedListener implementation.
 
   @Override
   public void onAdsManagerLoaded(AdsManagerLoadedEvent adsManagerLoadedEvent) {
@@ -477,28 +454,32 @@ public void playAd() {
     if (DEBUG) {
       Log.d(TAG, "playAd");
     }
+    switch (imaAdState) {
+      case IMA_AD_STATE_PLAYING:
+        // IMA does not always call stopAd before resuming content.
+        // See [Internal: b/38354028, b/63320878].
+        Log.w(TAG, "Unexpected playAd without stopAd");
+        break;
+      case IMA_AD_STATE_NONE:
+        imaAdState = IMA_AD_STATE_PLAYING;
+        for (int i = 0; i < adCallbacks.size(); i++) {
+          adCallbacks.get(i).onPlay();
+        }
+        break;
+      case IMA_AD_STATE_PAUSED:
+        imaAdState = IMA_AD_STATE_PLAYING;
+        for (int i = 0; i < adCallbacks.size(); i++) {
+          adCallbacks.get(i).onResume();
+        }
+        break;
+      default:
+        throw new IllegalStateException();
+    }
     if (player == null) {
       // Sometimes messages from IMA arrive after detaching the player. See [Internal: b/63801642].
       Log.w(TAG, "Unexpected playAd while detached");
     } else if (!player.getPlayWhenReady()) {
-      playWhenReadyOverriddenForAds = true;
-      player.setPlayWhenReady(true);
-    }
-    if (imaPlayingAd && !imaPausedInAd) {
-      // Work around an issue where IMA does not always call stopAd before resuming content.
-      // See [Internal: b/38354028, b/63320878].
-      Log.w(TAG, "Unexpected playAd without stopAd");
-    }
-    if (!imaPlayingAd) {
-      imaPlayingAd = true;
-      for (VideoAdPlayerCallback callback : adCallbacks) {
-        callback.onPlay();
-      }
-    } else if (imaPausedInAd) {
-      imaPausedInAd = false;
-      for (VideoAdPlayerCallback callback : adCallbacks) {
-        callback.onResume();
-      }
+      adsManager.pause();
     }
   }
 
@@ -511,7 +492,7 @@ public void stopAd() {
       // Sometimes messages from IMA arrive after detaching the player. See [Internal: b/63801642].
       Log.w(TAG, "Unexpected stopAd while detached");
     }
-    if (!imaPlayingAd) {
+    if (imaAdState == IMA_AD_STATE_NONE) {
       Log.w(TAG, "Unexpected stopAd");
       return;
     }
@@ -523,13 +504,13 @@ public void pauseAd() {
     if (DEBUG) {
       Log.d(TAG, "pauseAd");
     }
-    if (!imaPlayingAd) {
+    if (imaAdState == IMA_AD_STATE_NONE) {
       // This method is called after content is resumed.
       return;
     }
-    imaPausedInAd = true;
-    for (VideoAdPlayerCallback callback : adCallbacks) {
-      callback.onPause();
+    imaAdState = IMA_AD_STATE_PAUSED;
+    for (int i = 0; i < adCallbacks.size(); i++) {
+      adCallbacks.get(i).onPause();
     }
   }
 
@@ -549,53 +530,53 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
     }
     Assertions.checkArgument(timeline.getPeriodCount() == 1);
     this.timeline = timeline;
-    contentDurationMs = C.usToMs(timeline.getPeriod(0, period).durationUs);
+    long contentDurationUs = timeline.getPeriod(0, period).durationUs;
+    contentDurationMs = C.usToMs(contentDurationUs);
+    if (contentDurationUs != C.TIME_UNSET) {
+      adPlaybackState.contentDurationUs = contentDurationUs;
+    }
     updateImaStateForPlayerState();
   }
 
-  @Override
-  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onLoadingChanged(boolean isLoading) {
-    // Do nothing.
-  }
-
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
     if (adsManager == null) {
       return;
     }
 
-    if (!imaPlayingAd && playbackState == Player.STATE_BUFFERING && playWhenReady) {
+    if (imaAdState == IMA_AD_STATE_PLAYING && !playWhenReady) {
+      adsManager.pause();
+      return;
+    }
+
+    if (imaAdState == IMA_AD_STATE_PAUSED && playWhenReady) {
+      adsManager.resume();
+      return;
+    }
+
+    if (imaAdState == IMA_AD_STATE_NONE && playbackState == Player.STATE_BUFFERING
+        && playWhenReady) {
       checkForContentComplete();
-    } else if (imaPlayingAd && playbackState == Player.STATE_ENDED) {
+    } else if (imaAdState != IMA_AD_STATE_NONE && playbackState == Player.STATE_ENDED) {
       // IMA is waiting for the ad playback to finish so invoke the callback now.
       // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
-      for (VideoAdPlayerCallback callback : adCallbacks) {
-        callback.onEnded();
+      for (int i = 0; i < adCallbacks.size(); i++) {
+        adCallbacks.get(i).onEnded();
       }
     }
   }
 
-  @Override
-  public void onRepeatModeChanged(int repeatMode) {
-    // Do nothing.
-  }
-
   @Override
   public void onPlayerError(ExoPlaybackException error) {
     if (playingAd) {
-      for (VideoAdPlayerCallback callback : adCallbacks) {
-        callback.onError();
+      for (int i = 0; i < adCallbacks.size(); i++) {
+        adCallbacks.get(i).onError();
       }
     }
   }
 
   @Override
-  public void onPositionDiscontinuity() {
+  public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
     if (adsManager == null) {
       return;
     }
@@ -621,11 +602,6 @@ public void onPositionDiscontinuity() {
     }
   }
 
-  @Override
-  public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-    // Do nothing.
-  }
-
   // Internal methods.
 
   private void requestAds() {
@@ -639,24 +615,19 @@ private void requestAds() {
   private void updateImaStateForPlayerState() {
     boolean wasPlayingAd = playingAd;
     playingAd = player.isPlayingAd();
-    if (!playingAd && playWhenReadyOverriddenForAds) {
-      playWhenReadyOverriddenForAds = false;
-      player.setPlayWhenReady(false);
-    }
     if (!sentContentComplete) {
       boolean adFinished = (wasPlayingAd && !playingAd)
           || playingAdIndexInAdGroup != player.getCurrentAdIndexInAdGroup();
       if (adFinished) {
         // IMA is waiting for the ad playback to finish so invoke the callback now.
         // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
-        for (VideoAdPlayerCallback callback : adCallbacks) {
-          callback.onEnded();
+        for (int i = 0; i < adCallbacks.size(); i++) {
+          adCallbacks.get(i).onEnded();
         }
       }
       if (!wasPlayingAd && playingAd) {
         int adGroupIndex = player.getCurrentAdGroupIndex();
         // IMA hasn't sent CONTENT_PAUSE_REQUESTED yet, so fake the content position.
-        Assertions.checkState(fakeContentProgressElapsedRealtimeMs == C.TIME_UNSET);
         fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
         fakeContentProgressOffsetMs = C.usToMs(adPlaybackState.adGroupTimesUs[adGroupIndex]);
         if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
@@ -668,7 +639,8 @@ private void updateImaStateForPlayerState() {
   }
 
   private void resumeContentInternal() {
-    if (imaPlayingAd) {
+    if (imaAdState != IMA_AD_STATE_NONE) {
+      imaAdState = IMA_AD_STATE_NONE;
       if (DEBUG) {
         Log.d(TAG, "Unexpected CONTENT_RESUME_REQUESTED without stopAd");
       }
@@ -678,10 +650,10 @@ private void resumeContentInternal() {
       adGroupIndex = C.INDEX_UNSET;
       updateAdPlaybackState();
     }
-    clearFlags();
   }
 
   private void pauseContentInternal() {
+    imaAdState = IMA_AD_STATE_NONE;
     if (sentPendingContentPositionMs) {
       pendingContentPositionMs = C.TIME_UNSET;
       sentPendingContentPositionMs = false;
@@ -689,24 +661,16 @@ private void pauseContentInternal() {
     // IMA is requesting to pause content, so stop faking the content position.
     fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
     fakeContentProgressOffsetMs = C.TIME_UNSET;
-    clearFlags();
   }
 
   private void stopAdInternal() {
-    Assertions.checkState(imaPlayingAd);
+    Assertions.checkState(imaAdState != IMA_AD_STATE_NONE);
+    imaAdState = IMA_AD_STATE_NONE;
     adPlaybackState.playedAd(adGroupIndex);
     updateAdPlaybackState();
     if (!playingAd) {
       adGroupIndex = C.INDEX_UNSET;
     }
-    clearFlags();
-  }
-
-  private void clearFlags() {
-    // If an ad is displayed, these flags will be updated in response to playAd/pauseAd/stopAd until
-    // the content is resumed.
-    imaPlayingAd = false;
-    imaPausedInAd = false;
   }
 
   private void checkForContentComplete() {
@@ -728,6 +692,15 @@ private void updateAdPlaybackState() {
     }
   }
 
+  private void focusSkipButton() {
+    if (playingAd && adUiViewGroup != null && adUiViewGroup.getChildCount() > 0
+        && adUiViewGroup.getChildAt(0) instanceof WebView) {
+      WebView webView = (WebView) (adUiViewGroup.getChildAt(0));
+      webView.requestFocus();
+      webView.loadUrl(FOCUS_SKIP_BUTTON_WORKAROUND_JS);
+    }
+  }
+
   private static long[] getAdGroupTimesUs(List<Float> cuePoints) {
     if (cuePoints.isEmpty()) {
       // If no cue points are specified, there is a preroll ad.
@@ -744,13 +717,4 @@ private void updateAdPlaybackState() {
     return adGroupTimesUs;
   }
 
-  private void focusSkipButton() {
-    if (playingAd && adUiViewGroup != null && adUiViewGroup.getChildCount() > 0
-        && adUiViewGroup.getChildAt(0) instanceof WebView) {
-      WebView webView = (WebView) (adUiViewGroup.getChildAt(0));
-      webView.requestFocus();
-      webView.loadUrl(FOCUS_SKIP_BUTTON_WORKAROUND_JS);
-    }
-  }
-
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
index d56a3ad41f..02aa4807a5 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
@@ -16,83 +16,26 @@
 package com.google.android.exoplayer2.ext.ima;
 
 import android.os.Handler;
-import android.os.Looper;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import android.view.ViewGroup;
-import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
- * A {@link MediaSource} that inserts ads linearly with a provided content media source using the
- * Interactive Media Ads SDK for ad loading and tracking.
+ * A {@link MediaSource} that inserts ads linearly with a provided content media source.
+ *
+ * @deprecated Use com.google.android.exoplayer2.source.ads.AdsMediaSource with ImaAdsLoader.
  */
+@Deprecated
 public final class ImaAdsMediaSource implements MediaSource {
 
-  /**
-   * Listener for events relating to ad loading.
-   */
-  public interface AdsListener {
-
-    /**
-     * Called if there was an error loading ads. The media source will load the content without ads
-     * if ads can't be loaded, so listen for this event if you need to implement additional handling
-     * (for example, stopping the player).
-     *
-     * @param error The error.
-     */
-    void onAdLoadError(IOException error);
-
-    /**
-     * Called when the user clicks through an ad (for example, following a 'learn more' link).
-     */
-    void onAdClicked();
-
-    /**
-     * Called when the user taps a non-clickthrough part of an ad.
-     */
-    void onAdTapped();
-
-  }
-
-  private static final String TAG = "ImaAdsMediaSource";
-
-  private final MediaSource contentMediaSource;
-  private final DataSource.Factory dataSourceFactory;
-  private final ImaAdsLoader imaAdsLoader;
-  private final ViewGroup adUiViewGroup;
-  private final Handler mainHandler;
-  private final AdsLoaderListener adsLoaderListener;
-  private final Map<MediaPeriod, MediaSource> adMediaSourceByMediaPeriod;
-  private final Timeline.Period period;
-  @Nullable
-  private final Handler eventHandler;
-  @Nullable
-  private final AdsListener eventListener;
-
-  private Handler playerHandler;
-  private ExoPlayer player;
-  private volatile boolean released;
-
-  // Accessed on the player thread.
-  private Timeline contentTimeline;
-  private Object contentManifest;
-  private AdPlaybackState adPlaybackState;
-  private MediaSource[][] adGroupMediaSources;
-  private long[][] adDurationsUs;
-  private MediaSource.Listener listener;
+  private final AdsMediaSource adsMediaSource;
 
   /**
    * Constructs a new source that inserts ads linearly with the content specified by
@@ -121,230 +64,41 @@ public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory data
    */
   public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
       ImaAdsLoader imaAdsLoader, ViewGroup adUiViewGroup, @Nullable Handler eventHandler,
-      @Nullable AdsListener eventListener) {
-    this.contentMediaSource = contentMediaSource;
-    this.dataSourceFactory = dataSourceFactory;
-    this.imaAdsLoader = imaAdsLoader;
-    this.adUiViewGroup = adUiViewGroup;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
-    mainHandler = new Handler(Looper.getMainLooper());
-    adsLoaderListener = new AdsLoaderListener();
-    adMediaSourceByMediaPeriod = new HashMap<>();
-    period = new Timeline.Period();
-    adGroupMediaSources = new MediaSource[0][];
-    adDurationsUs = new long[0][];
+      @Nullable AdsMediaSource.AdsListener eventListener) {
+    adsMediaSource = new AdsMediaSource(contentMediaSource, dataSourceFactory, imaAdsLoader,
+        adUiViewGroup, eventHandler, eventListener);
   }
 
   @Override
-  public void prepareSource(final ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    Assertions.checkArgument(isTopLevelSource);
-    this.listener = listener;
-    this.player = player;
-    playerHandler = new Handler();
-    contentMediaSource.prepareSource(player, false, new Listener() {
+  public void prepareSource(final ExoPlayer player, boolean isTopLevelSource,
+      final Listener listener) {
+    adsMediaSource.prepareSource(player, false, new Listener() {
       @Override
-      public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
-        ImaAdsMediaSource.this.onContentSourceInfoRefreshed(timeline, manifest);
-      }
-    });
-    mainHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        imaAdsLoader.attachPlayer(player, adsLoaderListener, adUiViewGroup);
+      public void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
+          @Nullable Object manifest) {
+        listener.onSourceInfoRefreshed(ImaAdsMediaSource.this, timeline, manifest);
       }
     });
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    contentMediaSource.maybeThrowSourceInfoRefreshError();
-    for (MediaSource[] mediaSources : adGroupMediaSources) {
-      for (MediaSource mediaSource : mediaSources) {
-        if (mediaSource != null) {
-          mediaSource.maybeThrowSourceInfoRefreshError();
-        }
-      }
-    }
+    adsMediaSource.maybeThrowSourceInfoRefreshError();
   }
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    if (adPlaybackState.adGroupCount > 0 && id.isAd()) {
-      final int adGroupIndex = id.adGroupIndex;
-      final int adIndexInAdGroup = id.adIndexInAdGroup;
-      if (adGroupMediaSources[adGroupIndex].length <= adIndexInAdGroup) {
-        MediaSource adMediaSource = new ExtractorMediaSource(
-            adPlaybackState.adUris[id.adGroupIndex][id.adIndexInAdGroup], dataSourceFactory,
-            new DefaultExtractorsFactory(), mainHandler, adsLoaderListener);
-        int oldAdCount = adGroupMediaSources[id.adGroupIndex].length;
-        if (adIndexInAdGroup >= oldAdCount) {
-          int adCount = adIndexInAdGroup + 1;
-          adGroupMediaSources[adGroupIndex] =
-              Arrays.copyOf(adGroupMediaSources[adGroupIndex], adCount);
-          adDurationsUs[adGroupIndex] = Arrays.copyOf(adDurationsUs[adGroupIndex], adCount);
-          Arrays.fill(adDurationsUs[adGroupIndex], oldAdCount, adCount, C.TIME_UNSET);
-        }
-        adGroupMediaSources[adGroupIndex][adIndexInAdGroup] = adMediaSource;
-        adMediaSource.prepareSource(player, false, new Listener() {
-          @Override
-          public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
-            onAdSourceInfoRefreshed(adGroupIndex, adIndexInAdGroup, timeline);
-          }
-        });
-      }
-      MediaSource mediaSource = adGroupMediaSources[adGroupIndex][adIndexInAdGroup];
-      MediaPeriod mediaPeriod = mediaSource.createPeriod(new MediaPeriodId(0), allocator);
-      adMediaSourceByMediaPeriod.put(mediaPeriod, mediaSource);
-      return mediaPeriod;
-    } else {
-      return contentMediaSource.createPeriod(id, allocator);
-    }
+    return adsMediaSource.createPeriod(id, allocator);
   }
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
-    if (adMediaSourceByMediaPeriod.containsKey(mediaPeriod)) {
-      adMediaSourceByMediaPeriod.remove(mediaPeriod).releasePeriod(mediaPeriod);
-    } else {
-      contentMediaSource.releasePeriod(mediaPeriod);
-    }
+    adsMediaSource.releasePeriod(mediaPeriod);
   }
 
   @Override
   public void releaseSource() {
-    released = true;
-    contentMediaSource.releaseSource();
-    for (MediaSource[] mediaSources : adGroupMediaSources) {
-      for (MediaSource mediaSource : mediaSources) {
-        if (mediaSource != null) {
-          mediaSource.releaseSource();
-        }
-      }
-    }
-    mainHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        imaAdsLoader.detachPlayer();
-      }
-    });
-  }
-
-  // Internal methods.
-
-  private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
-    if (this.adPlaybackState == null) {
-      adGroupMediaSources = new MediaSource[adPlaybackState.adGroupCount][];
-      Arrays.fill(adGroupMediaSources, new MediaSource[0]);
-      adDurationsUs = new long[adPlaybackState.adGroupCount][];
-      Arrays.fill(adDurationsUs, new long[0]);
-    }
-    this.adPlaybackState = adPlaybackState;
-    maybeUpdateSourceInfo();
-  }
-
-  private void onLoadError(final IOException error) {
-    Log.w(TAG, "Ad load error", error);
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if (!released) {
-            eventListener.onAdLoadError(error);
-          }
-        }
-      });
-    }
-  }
-
-  private void onContentSourceInfoRefreshed(Timeline timeline, Object manifest) {
-    contentTimeline = timeline;
-    contentManifest = manifest;
-    maybeUpdateSourceInfo();
-  }
-
-  private void onAdSourceInfoRefreshed(int adGroupIndex, int adIndexInAdGroup, Timeline timeline) {
-    Assertions.checkArgument(timeline.getPeriodCount() == 1);
-    adDurationsUs[adGroupIndex][adIndexInAdGroup] = timeline.getPeriod(0, period).getDurationUs();
-    maybeUpdateSourceInfo();
-  }
-
-  private void maybeUpdateSourceInfo() {
-    if (adPlaybackState != null && contentTimeline != null) {
-      Timeline timeline = adPlaybackState.adGroupCount == 0 ? contentTimeline
-          : new SinglePeriodAdTimeline(contentTimeline, adPlaybackState.adGroupTimesUs,
-              adPlaybackState.adCounts, adPlaybackState.adsLoadedCounts,
-              adPlaybackState.adsPlayedCounts, adDurationsUs, adPlaybackState.adResumePositionUs);
-      listener.onSourceInfoRefreshed(timeline, contentManifest);
-    }
-  }
-
-  /**
-   * Listener for ad loading events. All methods are called on the main thread.
-   */
-  private final class AdsLoaderListener implements ImaAdsLoader.EventListener,
-      ExtractorMediaSource.EventListener {
-
-    @Override
-    public void onAdPlaybackState(final AdPlaybackState adPlaybackState) {
-      if (released) {
-        return;
-      }
-      playerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if (released) {
-            return;
-          }
-          ImaAdsMediaSource.this.onAdPlaybackState(adPlaybackState);
-        }
-      });
-    }
-
-    @Override
-    public void onLoadError(final IOException error) {
-      if (released) {
-        return;
-      }
-      playerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if (released) {
-            return;
-          }
-          ImaAdsMediaSource.this.onLoadError(error);
-        }
-      });
-    }
-
-    @Override
-    public void onAdClicked() {
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            if (!released) {
-              eventListener.onAdClicked();
-            }
-          }
-        });
-      }
-    }
-
-    @Override
-    public void onAdTapped() {
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            if (!released) {
-              eventListener.onAdTapped();
-            }
-          }
-        });
-      }
-    }
-
+    adsMediaSource.releaseSource();
   }
 
 }
diff --git a/extensions/leanback/README.md b/extensions/leanback/README.md
new file mode 100644
index 0000000000..1fa71c9a8c
--- /dev/null
+++ b/extensions/leanback/README.md
@@ -0,0 +1,31 @@
+# ExoPlayer Leanback extension #
+
+This [Leanback][] Extension provides a [PlayerAdapter][] implementation for
+ExoPlayer.
+
+[PlayerAdapter]: https://developer.android.com/reference/android/support/v17/leanback/media/PlayerAdapter.html
+[Leanback]: https://developer.android.com/reference/android/support/v17/leanback/package-summary.html
+
+## Getting the extension ##
+
+The easiest way to use the extension is to add it as a gradle dependency:
+
+```gradle
+compile 'com.google.android.exoplayer:extension-leanback:rX.X.X'
+```
+
+where `rX.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
+
+Alternatively, you can clone the ExoPlayer repository and depend on the module
+locally. Instructions for doing this can be found in ExoPlayer's
+[top level README][].
+
+[top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
+
+## Links ##
+
+* [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.leanback.*`
+  belong to this module.
+
+[Javadoc]: https://google.github.io/ExoPlayer/doc/reference/index.html
diff --git a/extensions/leanback/build.gradle b/extensions/leanback/build.gradle
new file mode 100644
index 0000000000..715e2e56d7
--- /dev/null
+++ b/extensions/leanback/build.gradle
@@ -0,0 +1,41 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion 17
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+}
+
+dependencies {
+    compile project(modulePrefix + 'library-core')
+    compile('com.android.support:leanback-v17:' + supportLibraryVersion)
+}
+
+ext {
+    javadocTitle = 'Leanback extension for Exoplayer library'
+}
+apply from: '../../javadoc_library.gradle'
+
+ext {
+    releaseArtifact = 'extension-leanback'
+    releaseDescription = 'Leanback extension for ExoPlayer.'
+}
+apply from: '../../publish.gradle'
diff --git a/extensions/leanback/src/main/AndroidManifest.xml b/extensions/leanback/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..20cc9bf285
--- /dev/null
+++ b/extensions/leanback/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.leanback"/>
diff --git a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
new file mode 100644
index 0000000000..510ed9cf4f
--- /dev/null
+++ b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.leanback;
+
+import android.content.Context;
+import android.os.Handler;
+import android.support.annotation.Nullable;
+import android.support.v17.leanback.R;
+import android.support.v17.leanback.media.PlaybackGlueHost;
+import android.support.v17.leanback.media.PlayerAdapter;
+import android.support.v17.leanback.media.SurfaceHolderGlueHost;
+import android.util.Pair;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ControlDispatcher;
+import com.google.android.exoplayer2.DefaultControlDispatcher;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.util.ErrorMessageProvider;
+
+/**
+ * Leanback {@code PlayerAdapter} implementation for {@link SimpleExoPlayer}.
+ */
+public final class LeanbackPlayerAdapter extends PlayerAdapter {
+
+  static {
+    ExoPlayerLibraryInfo.registerModule("goog.exo.leanback");
+  }
+
+  private final Context context;
+  private final SimpleExoPlayer player;
+  private final Handler handler;
+  private final ComponentListener componentListener;
+  private final Runnable updateProgressRunnable;
+
+  private ControlDispatcher controlDispatcher;
+  private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
+  private SurfaceHolderGlueHost surfaceHolderGlueHost;
+  private boolean hasSurface;
+  private boolean lastNotifiedPreparedState;
+
+  /**
+   * Builds an instance. Note that the {@code PlayerAdapter} does not manage the lifecycle of the
+   * {@link SimpleExoPlayer} instance. The caller remains responsible for releasing the player when
+   * it's no longer required.
+   *
+   * @param context The current context (activity).
+   * @param player Instance of your exoplayer that needs to be configured.
+   * @param updatePeriodMs The delay between player control updates, in milliseconds.
+   */
+  public LeanbackPlayerAdapter(Context context, SimpleExoPlayer player, final int updatePeriodMs) {
+    this.context = context;
+    this.player = player;
+    handler = new Handler();
+    componentListener = new ComponentListener();
+    controlDispatcher = new DefaultControlDispatcher();
+    updateProgressRunnable = new Runnable() {
+      @Override
+      public void run() {
+        Callback callback = getCallback();
+        callback.onCurrentPositionChanged(LeanbackPlayerAdapter.this);
+        callback.onBufferedPositionChanged(LeanbackPlayerAdapter.this);
+        handler.postDelayed(this, updatePeriodMs);
+      }
+    };
+  }
+
+  /**
+   * Sets the {@link ControlDispatcher}.
+   *
+   * @param controlDispatcher The {@link ControlDispatcher}, or null to use
+   *     {@link DefaultControlDispatcher}.
+   */
+  public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
+    this.controlDispatcher = controlDispatcher == null ? new DefaultControlDispatcher()
+        : controlDispatcher;
+  }
+
+  /**
+   * Sets the optional {@link ErrorMessageProvider}.
+   *
+   * @param errorMessageProvider The {@link ErrorMessageProvider}.
+   */
+  public void setErrorMessageProvider(
+      ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider) {
+    this.errorMessageProvider = errorMessageProvider;
+  }
+
+  // PlayerAdapter implementation.
+
+  @Override
+  public void onAttachedToHost(PlaybackGlueHost host) {
+    if (host instanceof SurfaceHolderGlueHost) {
+      surfaceHolderGlueHost = ((SurfaceHolderGlueHost) host);
+      surfaceHolderGlueHost.setSurfaceHolderCallback(componentListener);
+    }
+    notifyStateChanged();
+    player.addListener(componentListener);
+    player.addVideoListener(componentListener);
+  }
+
+  @Override
+  public void onDetachedFromHost() {
+    player.removeListener(componentListener);
+    player.removeVideoListener(componentListener);
+    if (surfaceHolderGlueHost != null) {
+      surfaceHolderGlueHost.setSurfaceHolderCallback(null);
+      surfaceHolderGlueHost = null;
+    }
+    hasSurface = false;
+    Callback callback = getCallback();
+    callback.onBufferingStateChanged(this, false);
+    callback.onPlayStateChanged(this);
+    maybeNotifyPreparedStateChanged(callback);
+  }
+
+  @Override
+  public void setProgressUpdatingEnabled(boolean enabled) {
+    handler.removeCallbacks(updateProgressRunnable);
+    if (enabled) {
+      handler.post(updateProgressRunnable);
+    }
+  }
+
+  @Override
+  public boolean isPlaying() {
+    int playbackState = player.getPlaybackState();
+    return playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED
+        && player.getPlayWhenReady();
+  }
+
+  @Override
+  public long getDuration() {
+    long durationMs = player.getDuration();
+    return durationMs == C.TIME_UNSET ? -1 : durationMs;
+  }
+
+  @Override
+  public long getCurrentPosition() {
+    return player.getPlaybackState() == Player.STATE_IDLE ? -1 : player.getCurrentPosition();
+  }
+
+  @Override
+  public void play() {
+    if (player.getPlaybackState() == Player.STATE_ENDED) {
+      controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+    }
+    if (controlDispatcher.dispatchSetPlayWhenReady(player, true)) {
+      getCallback().onPlayStateChanged(this);
+    }
+  }
+
+  @Override
+  public void pause() {
+    if (controlDispatcher.dispatchSetPlayWhenReady(player, false)) {
+      getCallback().onPlayStateChanged(this);
+    }
+  }
+
+  @Override
+  public void seekTo(long positionMs) {
+    controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), positionMs);
+  }
+
+  @Override
+  public long getBufferedPosition() {
+    return player.getBufferedPosition();
+  }
+
+  @Override
+  public boolean isPrepared() {
+    return player.getPlaybackState() != Player.STATE_IDLE
+        && (surfaceHolderGlueHost == null || hasSurface);
+  }
+
+  // Internal methods.
+
+  /* package */ void setVideoSurface(Surface surface) {
+    hasSurface = surface != null;
+    player.setVideoSurface(surface);
+    maybeNotifyPreparedStateChanged(getCallback());
+  }
+
+  /* package */ void notifyStateChanged() {
+    int playbackState = player.getPlaybackState();
+    Callback callback = getCallback();
+    maybeNotifyPreparedStateChanged(callback);
+    callback.onPlayStateChanged(this);
+    callback.onBufferingStateChanged(this, playbackState == Player.STATE_BUFFERING);
+    if (playbackState == Player.STATE_ENDED) {
+      callback.onPlayCompleted(this);
+    }
+  }
+
+  private void maybeNotifyPreparedStateChanged(Callback callback) {
+    boolean isPrepared = isPrepared();
+    if (lastNotifiedPreparedState != isPrepared) {
+      lastNotifiedPreparedState = isPrepared;
+      callback.onPreparedStateChanged(this);
+    }
+  }
+
+  private final class ComponentListener extends Player.DefaultEventListener implements
+      SimpleExoPlayer.VideoListener, SurfaceHolder.Callback {
+
+    // SurfaceHolder.Callback implementation.
+
+    @Override
+    public void surfaceCreated(SurfaceHolder surfaceHolder) {
+      setVideoSurface(surfaceHolder.getSurface());
+    }
+
+    @Override
+    public void surfaceChanged(SurfaceHolder surfaceHolder, int format, int width, int height) {
+      // Do nothing.
+    }
+
+    @Override
+    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
+      setVideoSurface(null);
+    }
+
+    // Player.EventListener implementation.
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      notifyStateChanged();
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException exception) {
+      Callback callback = getCallback();
+      if (errorMessageProvider != null) {
+        Pair<Integer, String> errorMessage = errorMessageProvider.getErrorMessage(exception);
+        callback.onError(LeanbackPlayerAdapter.this, errorMessage.first, errorMessage.second);
+      } else {
+        callback.onError(LeanbackPlayerAdapter.this, exception.type, context.getString(
+            R.string.lb_media_player_error, exception.type, exception.rendererIndex));
+      }
+    }
+
+    @Override
+    public void onTimelineChanged(Timeline timeline, Object manifest) {
+      Callback callback = getCallback();
+      callback.onDurationChanged(LeanbackPlayerAdapter.this);
+      callback.onCurrentPositionChanged(LeanbackPlayerAdapter.this);
+      callback.onBufferedPositionChanged(LeanbackPlayerAdapter.this);
+    }
+
+    @Override
+    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+      Callback callback = getCallback();
+      callback.onCurrentPositionChanged(LeanbackPlayerAdapter.this);
+      callback.onBufferedPositionChanged(LeanbackPlayerAdapter.this);
+    }
+
+    // SimpleExoplayerView.Callback implementation.
+
+    @Override
+    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
+        float pixelWidthHeightRatio) {
+      getCallback().onVideoSizeChanged(LeanbackPlayerAdapter.this, width, height);
+    }
+
+    @Override
+    public void onRenderedFirstFrame() {
+      // Do nothing.
+    }
+
+  }
+
+}
diff --git a/extensions/mediasession/build.gradle b/extensions/mediasession/build.gradle
index 85a8ac46e2..651bd952f8 100644
--- a/extensions/mediasession/build.gradle
+++ b/extensions/mediasession/build.gradle
@@ -27,7 +27,6 @@ android {
 dependencies {
     compile project(modulePrefix + 'library-core')
     compile 'com.android.support:support-media-compat:' + supportLibraryVersion
-    compile 'com.android.support:appcompat-v7:' + supportLibraryVersion
 }
 
 ext {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
index c3586b29e6..1eb3ffd13d 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
@@ -15,10 +15,12 @@
  */
 package com.google.android.exoplayer2.ext.mediasession;
 
+import android.os.Bundle;
+import android.os.ResultReceiver;
 import android.support.v4.media.session.PlaybackStateCompat;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.util.RepeatModeUtil;
 
 /**
  * A default implementation of {@link MediaSessionConnector.PlaybackController}.
@@ -38,33 +40,37 @@
 
   private static final long BASE_ACTIONS = PlaybackStateCompat.ACTION_PLAY_PAUSE
       | PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_PAUSE
-      | PlaybackStateCompat.ACTION_STOP;
+      | PlaybackStateCompat.ACTION_STOP | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE
+      | PlaybackStateCompat.ACTION_SET_REPEAT_MODE;
 
   protected final long rewindIncrementMs;
   protected final long fastForwardIncrementMs;
+  protected final int repeatToggleModes;
 
   /**
    * Creates a new instance.
    * <p>
-   * Equivalent to {@code DefaultPlaybackController(
-   *     DefaultPlaybackController.DEFAULT_REWIND_MS,
-   *     DefaultPlaybackController.DEFAULT_FAST_FORWARD_MS)}.
+   * Equivalent to {@code DefaultPlaybackController(DefaultPlaybackController.DEFAULT_REWIND_MS,
+   *     DefaultPlaybackController.DEFAULT_FAST_FORWARD_MS,
+   *     MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES)}.
    */
   public DefaultPlaybackController() {
-    this(DEFAULT_REWIND_MS, DEFAULT_FAST_FORWARD_MS);
+    this(DEFAULT_REWIND_MS, DEFAULT_FAST_FORWARD_MS,
+        MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES);
   }
 
   /**
    * Creates a new instance with the given fast forward and rewind increments.
-   *
-   * @param rewindIncrementMs The rewind increment in milliseconds. A zero or negative value will
+   *  @param rewindIncrementMs The rewind increment in milliseconds. A zero or negative value will
    *     cause the rewind action to be disabled.
    * @param fastForwardIncrementMs The fast forward increment in milliseconds. A zero or negative
-   *     value will cause the fast forward action to be removed.
+   * @param repeatToggleModes The available repeatToggleModes.
    */
-  public DefaultPlaybackController(long rewindIncrementMs, long fastForwardIncrementMs) {
+  public DefaultPlaybackController(long rewindIncrementMs, long fastForwardIncrementMs,
+      @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
     this.rewindIncrementMs = rewindIncrementMs;
     this.fastForwardIncrementMs = fastForwardIncrementMs;
+    this.repeatToggleModes = repeatToggleModes;
   }
 
   @Override
@@ -125,4 +131,44 @@ public void onStop(Player player) {
     player.stop();
   }
 
+  @Override
+  public void onSetShuffleMode(Player player, int shuffleMode) {
+    player.setShuffleModeEnabled(shuffleMode == PlaybackStateCompat.SHUFFLE_MODE_ALL
+        || shuffleMode == PlaybackStateCompat.SHUFFLE_MODE_GROUP);
+  }
+
+  @Override
+  public void onSetRepeatMode(Player player, int repeatMode) {
+    int selectedExoPlayerRepeatMode = player.getRepeatMode();
+    switch (repeatMode) {
+      case PlaybackStateCompat.REPEAT_MODE_ALL:
+      case PlaybackStateCompat.REPEAT_MODE_GROUP:
+        if ((repeatToggleModes & RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL) != 0) {
+          selectedExoPlayerRepeatMode = Player.REPEAT_MODE_ALL;
+        }
+        break;
+      case PlaybackStateCompat.REPEAT_MODE_ONE:
+        if ((repeatToggleModes & RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE) != 0) {
+          selectedExoPlayerRepeatMode = Player.REPEAT_MODE_ONE;
+        }
+        break;
+      default:
+        selectedExoPlayerRepeatMode = Player.REPEAT_MODE_OFF;
+        break;
+    }
+    player.setRepeatMode(selectedExoPlayerRepeatMode);
+  }
+
+  // CommandReceiver implementation.
+
+  @Override
+  public String[] getCommands() {
+    return null;
+  }
+
+  @Override
+  public void onCommand(Player player, String command, Bundle extras, ResultReceiver cb) {
+    // Do nothing.
+  }
+
 }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 329d446506..aa007ea1d6 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -36,8 +36,8 @@
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.util.ErrorMessageProvider;
+import com.google.android.exoplayer2.util.RepeatModeUtil;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -72,16 +72,37 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.mediasession");
   }
 
+  /**
+   * The default repeat toggle modes which is the bitmask of
+   * {@link RepeatModeUtil#REPEAT_TOGGLE_MODE_ONE} and
+   * {@link RepeatModeUtil#REPEAT_TOGGLE_MODE_ALL}.
+   */
+  public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
+      RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE | RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL;
   public static final String EXTRAS_PITCH = "EXO_PITCH";
   private static final int BASE_MEDIA_SESSION_FLAGS = MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS
       | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS;
   private static final int EDITOR_MEDIA_SESSION_FLAGS = BASE_MEDIA_SESSION_FLAGS
       | MediaSessionCompat.FLAG_HANDLES_QUEUE_COMMANDS;
 
+  /**
+   * Receiver of media commands sent by a media controller.
+   */
+  public interface CommandReceiver {
+    /**
+     * Returns the commands the receiver handles, or {@code null} if no commands need to be handled.
+     */
+    String[] getCommands();
+    /**
+     * See {@link MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}.
+     */
+    void onCommand(Player player, String command, Bundle extras, ResultReceiver cb);
+  }
+
   /**
    * Interface to which playback preparation actions are delegated.
    */
-  public interface PlaybackPreparer {
+  public interface PlaybackPreparer extends CommandReceiver {
 
     long ACTIONS = PlaybackStateCompat.ACTION_PREPARE
         | PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID
@@ -120,28 +141,27 @@
      * See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}.
      */
     void onPrepareFromUri(Uri uri, Bundle extras);
-    /**
-     * See {@link MediaSessionCompat.Callback#onCommand(String, Bundle, ResultReceiver)}.
-     */
-    void onCommand(String command, Bundle extras, ResultReceiver cb);
   }
 
   /**
    * Interface to which playback actions are delegated.
    */
-  public interface PlaybackController {
+  public interface PlaybackController extends CommandReceiver {
 
     long ACTIONS = PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PLAY
         | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_SEEK_TO
         | PlaybackStateCompat.ACTION_FAST_FORWARD | PlaybackStateCompat.ACTION_REWIND
-        | PlaybackStateCompat.ACTION_STOP;
+        | PlaybackStateCompat.ACTION_STOP | PlaybackStateCompat.ACTION_SET_REPEAT_MODE
+        | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE;
 
     /**
      * Returns the actions which are supported by the controller. The supported actions must be a
      * bitmask combined out of {@link PlaybackStateCompat#ACTION_PLAY_PAUSE},
      * {@link PlaybackStateCompat#ACTION_PLAY}, {@link PlaybackStateCompat#ACTION_PAUSE},
      * {@link PlaybackStateCompat#ACTION_SEEK_TO}, {@link PlaybackStateCompat#ACTION_FAST_FORWARD},
-     * {@link PlaybackStateCompat#ACTION_REWIND} and {@link PlaybackStateCompat#ACTION_STOP}.
+     * {@link PlaybackStateCompat#ACTION_REWIND}, {@link PlaybackStateCompat#ACTION_STOP},
+     * {@link PlaybackStateCompat#ACTION_SET_REPEAT_MODE} and
+     * {@link PlaybackStateCompat#ACTION_SET_SHUFFLE_MODE}.
      *
      * @param player The player.
      * @return The bitmask of the supported media actions.
@@ -171,24 +191,30 @@
      * See {@link MediaSessionCompat.Callback#onStop()}.
      */
     void onStop(Player player);
+    /**
+     * See {@link MediaSessionCompat.Callback#onSetShuffleMode(int)}.
+     */
+    void onSetShuffleMode(Player player, int shuffleMode);
+    /**
+     * See {@link MediaSessionCompat.Callback#onSetRepeatMode(int)}.
+     */
+    void onSetRepeatMode(Player player, int repeatMode);
   }
 
   /**
    * Handles queue navigation actions, and updates the media session queue by calling
    * {@code MediaSessionCompat.setQueue()}.
    */
-  public interface QueueNavigator {
+  public interface QueueNavigator extends CommandReceiver {
 
     long ACTIONS = PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM
-        | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS
-        | PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE_ENABLED;
+        | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
 
     /**
      * Returns the actions which are supported by the navigator. The supported actions must be a
      * bitmask combined out of {@link PlaybackStateCompat#ACTION_SKIP_TO_QUEUE_ITEM},
      * {@link PlaybackStateCompat#ACTION_SKIP_TO_NEXT},
-     * {@link PlaybackStateCompat#ACTION_SKIP_TO_PREVIOUS},
-     * {@link PlaybackStateCompat#ACTION_SET_SHUFFLE_MODE_ENABLED}.
+     * {@link PlaybackStateCompat#ACTION_SKIP_TO_PREVIOUS}.
      *
      * @param player The {@link Player}.
      * @return The bitmask of the supported media actions.
@@ -230,16 +256,12 @@
      * See {@link MediaSessionCompat.Callback#onSkipToNext()}.
      */
     void onSkipToNext(Player player);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSetShuffleModeEnabled(boolean)}.
-     */
-    void onSetShuffleModeEnabled(Player player, boolean enabled);
   }
 
   /**
    * Handles media session queue edits.
    */
-  public interface QueueEditor {
+  public interface QueueEditor extends CommandReceiver {
 
     long ACTIONS = PlaybackStateCompat.ACTION_SET_RATING;
 
@@ -297,17 +319,6 @@
     PlaybackStateCompat.CustomAction getCustomAction();
   }
 
-  /**
-   * Converts an exception into an error code and a user readable error message.
-   */
-  public interface ErrorMessageProvider {
-    /**
-     * Returns a pair consisting of an error code and a user readable error message for a given
-     * exception.
-     */
-    Pair<Integer, String> getErrorMessage(ExoPlaybackException playbackException);
-  }
-
   /**
    * The wrapped {@link MediaSessionCompat}.
    */
@@ -319,11 +330,12 @@
   private final ExoPlayerEventListener exoPlayerEventListener;
   private final MediaSessionCallback mediaSessionCallback;
   private final PlaybackController playbackController;
+  private final Map<String, CommandReceiver> commandMap;
 
   private Player player;
   private CustomActionProvider[] customActionProviders;
   private Map<String, CustomActionProvider> customActionMap;
-  private ErrorMessageProvider errorMessageProvider;
+  private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
   private PlaybackPreparer playbackPreparer;
   private QueueNavigator queueNavigator;
   private QueueEditor queueEditor;
@@ -338,7 +350,7 @@
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
    */
   public MediaSessionConnector(MediaSessionCompat mediaSession) {
-    this(mediaSession, new DefaultPlaybackController());
+    this(mediaSession, null);
   }
 
   /**
@@ -360,7 +372,8 @@ public MediaSessionConnector(MediaSessionCompat mediaSession,
    * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.
    *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
-   * @param playbackController A {@link PlaybackController} for handling playback actions.
+   * @param playbackController A {@link PlaybackController} for handling playback actions, or
+   *     {@code null} if the connector should handle playback actions directly.
    * @param doMaintainMetadata Whether the connector should maintain the metadata of the session. If
    *     {@code false}, you need to maintain the metadata of the media session yourself (provide at
    *     least the duration to allow clients to show a progress bar).
@@ -368,7 +381,8 @@ public MediaSessionConnector(MediaSessionCompat mediaSession,
   public MediaSessionConnector(MediaSessionCompat mediaSession,
       PlaybackController playbackController, boolean doMaintainMetadata) {
     this.mediaSession = mediaSession;
-    this.playbackController = playbackController;
+    this.playbackController = playbackController != null ? playbackController
+        : new DefaultPlaybackController();
     this.handler = new Handler(Looper.myLooper() != null ? Looper.myLooper()
         : Looper.getMainLooper());
     this.doMaintainMetadata = doMaintainMetadata;
@@ -377,6 +391,8 @@ public MediaSessionConnector(MediaSessionCompat mediaSession,
     mediaSessionCallback = new MediaSessionCallback();
     exoPlayerEventListener = new ExoPlayerEventListener();
     customActionMap = Collections.emptyMap();
+    commandMap = new HashMap<>();
+    registerCommandReceiver(playbackController);
   }
 
   /**
@@ -396,8 +412,12 @@ public void setPlayer(Player player, PlaybackPreparer playbackPreparer,
       this.player.removeListener(exoPlayerEventListener);
       mediaSession.setCallback(null);
     }
-    this.playbackPreparer = playbackPreparer;
+    unregisterCommandReceiver(this.playbackPreparer);
+
     this.player = player;
+    this.playbackPreparer = playbackPreparer;
+    registerCommandReceiver(playbackPreparer);
+
     this.customActionProviders = (player != null && customActionProviders != null)
         ? customActionProviders : new CustomActionProvider[0];
     if (player != null) {
@@ -413,19 +433,21 @@ public void setPlayer(Player player, PlaybackPreparer playbackPreparer,
    *
    * @param errorMessageProvider The error message provider.
    */
-  public void setErrorMessageProvider(ErrorMessageProvider errorMessageProvider) {
+  public void setErrorMessageProvider(
+      ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider) {
     this.errorMessageProvider = errorMessageProvider;
   }
 
   /**
    * Sets the {@link QueueNavigator} to handle queue navigation actions {@code ACTION_SKIP_TO_NEXT},
-   * {@code ACTION_SKIP_TO_PREVIOUS}, {@code ACTION_SKIP_TO_QUEUE_ITEM} and
-   * {@code ACTION_SET_SHUFFLE_MODE_ENABLED}.
+   * {@code ACTION_SKIP_TO_PREVIOUS} and {@code ACTION_SKIP_TO_QUEUE_ITEM}.
    *
    * @param queueNavigator The queue navigator.
    */
   public void setQueueNavigator(QueueNavigator queueNavigator) {
+    unregisterCommandReceiver(this.queueNavigator);
     this.queueNavigator = queueNavigator;
+    registerCommandReceiver(queueNavigator);
   }
 
   /**
@@ -434,11 +456,29 @@ public void setQueueNavigator(QueueNavigator queueNavigator) {
    * @param queueEditor The queue editor.
    */
   public void setQueueEditor(QueueEditor queueEditor) {
+    unregisterCommandReceiver(this.queueEditor);
     this.queueEditor = queueEditor;
+    registerCommandReceiver(queueEditor);
     mediaSession.setFlags(queueEditor == null ? BASE_MEDIA_SESSION_FLAGS
         : EDITOR_MEDIA_SESSION_FLAGS);
   }
 
+  private void registerCommandReceiver(CommandReceiver commandReceiver) {
+    if (commandReceiver != null && commandReceiver.getCommands() != null) {
+      for (String command : commandReceiver.getCommands()) {
+        commandMap.put(command, commandReceiver);
+      }
+    }
+  }
+
+  private void unregisterCommandReceiver(CommandReceiver commandReceiver) {
+    if (commandReceiver != null && commandReceiver.getCommands() != null) {
+      for (String command : commandReceiver.getCommands()) {
+        commandMap.remove(command);
+      }
+    }
+  }
+
   private void updateMediaSessionPlaybackState() {
     PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
     if (player == null) {
@@ -482,11 +522,8 @@ private void updateMediaSessionPlaybackState() {
   }
 
   private long buildPlaybackActions() {
-    long actions = 0;
-    if (playbackController != null) {
-      actions |= (PlaybackController.ACTIONS & playbackController
-          .getSupportedPlaybackActions(player));
-    }
+    long actions = (PlaybackController.ACTIONS
+        & playbackController.getSupportedPlaybackActions(player));
     if (playbackPreparer != null) {
       actions |= (PlaybackPreparer.ACTIONS & playbackPreparer.getSupportedPrepareActions());
     }
@@ -571,7 +608,7 @@ private boolean canDispatchToPlaybackPreparer(long action) {
   }
 
   private boolean canDispatchToPlaybackController(long action) {
-    return playbackController != null && (playbackController.getSupportedPlaybackActions(player)
+    return (playbackController.getSupportedPlaybackActions(player)
         & PlaybackController.ACTIONS & action) != 0;
   }
 
@@ -585,17 +622,22 @@ private boolean canDispatchToQueueEditor(long action) {
         & QueueEditor.ACTIONS & action) != 0;
   }
 
-  private class ExoPlayerEventListener implements Player.EventListener {
+  private class ExoPlayerEventListener extends Player.DefaultEventListener {
 
     private int currentWindowIndex;
     private int currentWindowCount;
 
     @Override
     public void onTimelineChanged(Timeline timeline, Object manifest) {
+      int windowCount = player.getCurrentTimeline().getWindowCount();
+      int windowIndex = player.getCurrentWindowIndex();
       if (queueNavigator != null) {
         queueNavigator.onTimelineChanged(player);
+        updateMediaSessionPlaybackState();
+      } else if (currentWindowCount != windowCount || currentWindowIndex != windowIndex) {
+        // active queue item and queue navigation actions may need to be updated
+        updateMediaSessionPlaybackState();
       }
-      int windowCount = player.getCurrentTimeline().getWindowCount();
       if (currentWindowCount != windowCount) {
         // active queue item and queue navigation actions may need to be updated
         updateMediaSessionPlaybackState();
@@ -605,16 +647,6 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
       updateMediaSessionMetadata();
     }
 
-    @Override
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       updateMediaSessionPlaybackState();
@@ -628,6 +660,13 @@ public void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
       updateMediaSessionPlaybackState();
     }
 
+    @Override
+    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
+      mediaSession.setShuffleMode(shuffleModeEnabled ? PlaybackStateCompat.SHUFFLE_MODE_ALL
+          : PlaybackStateCompat.SHUFFLE_MODE_NONE);
+      updateMediaSessionPlaybackState();
+    }
+
     @Override
     public void onPlayerError(ExoPlaybackException error) {
       playbackException = error;
@@ -635,13 +674,13 @@ public void onPlayerError(ExoPlaybackException error) {
     }
 
     @Override
-    public void onPositionDiscontinuity() {
+    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
       if (currentWindowIndex != player.getCurrentWindowIndex()) {
         if (queueNavigator != null) {
           queueNavigator.onCurrentWindowIndexChanged(player);
         }
-        updateMediaSessionMetadata();
         currentWindowIndex = player.getCurrentWindowIndex();
+        updateMediaSessionMetadata();
       }
       updateMediaSessionPlaybackState();
     }
@@ -697,6 +736,20 @@ public void onStop() {
       }
     }
 
+    @Override
+    public void onSetShuffleMode(int shuffleMode) {
+      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE)) {
+        playbackController.onSetShuffleMode(player, shuffleMode);
+      }
+    }
+
+    @Override
+    public void onSetRepeatMode(int repeatMode) {
+      if (canDispatchToPlaybackController(PlaybackStateCompat.ACTION_SET_REPEAT_MODE)) {
+        playbackController.onSetRepeatMode(player, repeatMode);
+      }
+    }
+
     @Override
     public void onSkipToNext() {
       if (canDispatchToQueueNavigator(PlaybackStateCompat.ACTION_SKIP_TO_NEXT)) {
@@ -718,11 +771,6 @@ public void onSkipToQueueItem(long id) {
       }
     }
 
-    @Override
-    public void onSetRepeatMode(int repeatMode) {
-      // implemented as custom action
-    }
-
     @Override
     public void onCustomAction(@NonNull String action, @Nullable Bundle extras) {
       Map<String, CustomActionProvider> actionMap = customActionMap;
@@ -734,8 +782,9 @@ public void onCustomAction(@NonNull String action, @Nullable Bundle extras) {
 
     @Override
     public void onCommand(String command, Bundle extras, ResultReceiver cb) {
-      if (playbackPreparer != null) {
-        playbackPreparer.onCommand(command, extras, cb);
+      CommandReceiver commandReceiver = commandMap.get(command);
+      if (commandReceiver != null) {
+        commandReceiver.onCommand(player, command, extras, cb);
       }
     }
 
@@ -802,13 +851,6 @@ public void onPlayFromUri(Uri uri, Bundle extras) {
       }
     }
 
-    @Override
-    public void onSetShuffleModeEnabled(boolean enabled) {
-      if (canDispatchToQueueNavigator(PlaybackStateCompat.ACTION_SET_SHUFFLE_MODE_ENABLED)) {
-        queueNavigator.onSetShuffleModeEnabled(player, enabled);
-      }
-    }
-
     @Override
     public void onAddQueueItem(MediaDescriptionCompat description) {
       if (queueEditor != null) {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
index abefe533ce..1db5889e00 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/RepeatModeActionProvider.java
@@ -1,4 +1,3 @@
-package com.google.android.exoplayer2.ext.mediasession;
 /*
  * Copyright (c) 2017 The Android Open Source Project
  *
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package com.google.android.exoplayer2.ext.mediasession;
 
 import android.content.Context;
 import android.os.Bundle;
@@ -26,12 +26,6 @@
  */
 public final class RepeatModeActionProvider implements MediaSessionConnector.CustomActionProvider {
 
-  /**
-   * The default repeat toggle modes.
-   */
-  public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
-      RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE | RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL;
-
   private static final String ACTION_REPEAT_MODE = "ACTION_EXO_REPEAT_MODE";
 
   private final Player player;
@@ -45,13 +39,13 @@
    * Creates a new instance.
    * <p>
    * Equivalent to {@code RepeatModeActionProvider(context, player,
-   *     RepeatModeActionProvider.DEFAULT_REPEAT_TOGGLE_MODES)}.
+   *     MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES)}.
    *
    * @param context The context.
    * @param player The player on which to toggle the repeat mode.
    */
   public RepeatModeActionProvider(Context context, Player player) {
-    this(context, player, DEFAULT_REPEAT_TOGGLE_MODES);
+    this(context, player, MediaSessionConnector.DEFAULT_REPEAT_TOGGLE_MODES);
   }
 
   /**
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
new file mode 100644
index 0000000000..65090a3c1c
--- /dev/null
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mediasession;
+
+import android.os.Bundle;
+import android.os.ResultReceiver;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.media.MediaDescriptionCompat;
+import android.support.v4.media.RatingCompat;
+import android.support.v4.media.session.MediaControllerCompat;
+import android.support.v4.media.session.MediaSessionCompat;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.source.DynamicConcatenatingMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.util.Util;
+import java.util.List;
+
+/**
+ * A {@link MediaSessionConnector.QueueEditor} implementation based on the
+ * {@link DynamicConcatenatingMediaSource}.
+ * <p>
+ * This class implements the {@link MediaSessionConnector.CommandReceiver} interface and handles
+ * the {@link #COMMAND_MOVE_QUEUE_ITEM} to move a queue item instead of removing and inserting it.
+ * This allows to move the currently playing window without interrupting playback.
+ */
+public final class TimelineQueueEditor implements MediaSessionConnector.QueueEditor,
+    MediaSessionConnector.CommandReceiver {
+
+  public static final String COMMAND_MOVE_QUEUE_ITEM = "exo_move_window";
+  public static final String EXTRA_FROM_INDEX = "from_index";
+  public static final String EXTRA_TO_INDEX = "to_index";
+
+  /**
+   * Factory to create {@link MediaSource}s.
+   */
+  public interface MediaSourceFactory {
+    /**
+     * Creates a {@link MediaSource} for the given {@link MediaDescriptionCompat}.
+     *
+     * @param description The {@link MediaDescriptionCompat} to create a media source for.
+     * @return A {@link MediaSource} or {@code null} if no source can be created for the given
+     *     description.
+     */
+    @Nullable MediaSource createMediaSource(MediaDescriptionCompat description);
+  }
+
+  /**
+   * Adapter to get {@link MediaDescriptionCompat} of items in the queue and to notify the
+   * application about changes in the queue to sync the data structure backing the
+   * {@link MediaSessionConnector}.
+   */
+  public interface QueueDataAdapter {
+    /**
+     * Gets the {@link MediaDescriptionCompat} for a {@code position}.
+     *
+     * @param position The position in the queue for which to provide a description.
+     * @return A {@link MediaDescriptionCompat}.
+     */
+    MediaDescriptionCompat getMediaDescription(int position);
+    /**
+     * Adds a {@link MediaDescriptionCompat} at the given {@code position}.
+     *
+     * @param position The position at which to add.
+     * @param description The {@link MediaDescriptionCompat} to be added.
+     */
+    void add(int position, MediaDescriptionCompat description);
+    /**
+     * Removes the item at the given {@code position}.
+     *
+     * @param position The position at which to remove the item.
+     */
+    void remove(int position);
+    /**
+     * Moves a queue item from position {@code from} to position {@code to}.
+     *
+     * @param from The position from which to remove the item.
+     * @param to The target position to which to move the item.
+     */
+    void move(int from, int to);
+  }
+
+  /**
+   * Used to evaluate whether two {@link MediaDescriptionCompat} are considered equal.
+   */
+  interface MediaDescriptionEqualityChecker {
+    /**
+     * Returns {@code true} whether the descriptions are considered equal.
+     *
+     * @param d1 The first {@link MediaDescriptionCompat}.
+     * @param d2 The second {@link MediaDescriptionCompat}.
+     * @return {@code true} if considered equal.
+     */
+    boolean equals(MediaDescriptionCompat d1, MediaDescriptionCompat d2);
+  }
+
+  /**
+   * Media description comparator comparing the media IDs. Media IDs are considered equals if both
+   * are {@code null}.
+   */
+  public static final class MediaIdEqualityChecker implements MediaDescriptionEqualityChecker {
+
+    @Override
+    public boolean equals(MediaDescriptionCompat d1, MediaDescriptionCompat d2) {
+      return Util.areEqual(d1.getMediaId(), d2.getMediaId());
+    }
+
+  }
+
+  private final MediaControllerCompat mediaController;
+  private final QueueDataAdapter queueDataAdapter;
+  private final MediaSourceFactory sourceFactory;
+  private final MediaDescriptionEqualityChecker equalityChecker;
+  private final DynamicConcatenatingMediaSource queueMediaSource;
+
+  /**
+   * Creates a new {@link TimelineQueueEditor} with a given mediaSourceFactory.
+   *
+   * @param mediaController A {@link MediaControllerCompat} to read the current queue.
+   * @param queueMediaSource The {@link DynamicConcatenatingMediaSource} to
+   *     manipulate.
+   * @param queueDataAdapter A {@link QueueDataAdapter} to change the backing data.
+   * @param sourceFactory The {@link MediaSourceFactory} to build media sources.
+   */
+  public TimelineQueueEditor(@NonNull MediaControllerCompat mediaController,
+      @NonNull DynamicConcatenatingMediaSource queueMediaSource,
+      @NonNull QueueDataAdapter queueDataAdapter, @NonNull MediaSourceFactory sourceFactory) {
+    this(mediaController, queueMediaSource, queueDataAdapter, sourceFactory,
+        new MediaIdEqualityChecker());
+  }
+
+  /**
+   * Creates a new {@link TimelineQueueEditor} with a given mediaSourceFactory.
+   *
+   * @param mediaController A {@link MediaControllerCompat} to read the current queue.
+   * @param queueMediaSource The {@link DynamicConcatenatingMediaSource} to
+   *     manipulate.
+   * @param queueDataAdapter A {@link QueueDataAdapter} to change the backing data.
+   * @param sourceFactory The {@link MediaSourceFactory} to build media sources.
+   * @param equalityChecker The {@link MediaDescriptionEqualityChecker} to match queue items.
+   */
+  public TimelineQueueEditor(@NonNull MediaControllerCompat mediaController,
+      @NonNull DynamicConcatenatingMediaSource queueMediaSource,
+      @NonNull QueueDataAdapter queueDataAdapter, @NonNull MediaSourceFactory sourceFactory,
+      @NonNull MediaDescriptionEqualityChecker equalityChecker) {
+    this.mediaController = mediaController;
+    this.queueMediaSource = queueMediaSource;
+    this.queueDataAdapter = queueDataAdapter;
+    this.sourceFactory = sourceFactory;
+    this.equalityChecker = equalityChecker;
+  }
+
+  @Override
+  public long getSupportedQueueEditorActions(@Nullable Player player) {
+    return 0;
+  }
+
+  @Override
+  public void onAddQueueItem(Player player, MediaDescriptionCompat description) {
+    onAddQueueItem(player, description, player.getCurrentTimeline().getWindowCount());
+  }
+
+  @Override
+  public void onAddQueueItem(Player player, MediaDescriptionCompat description, int index) {
+    MediaSource mediaSource = sourceFactory.createMediaSource(description);
+    if (mediaSource != null) {
+      queueDataAdapter.add(index, description);
+      queueMediaSource.addMediaSource(index, mediaSource);
+    }
+  }
+
+  @Override
+  public void onRemoveQueueItem(Player player, MediaDescriptionCompat description) {
+    List<MediaSessionCompat.QueueItem> queue = mediaController.getQueue();
+    for (int i = 0; i < queue.size(); i++) {
+      if (equalityChecker.equals(queue.get(i).getDescription(), description)) {
+        onRemoveQueueItemAt(player, i);
+        return;
+      }
+    }
+  }
+
+  @Override
+  public void onRemoveQueueItemAt(Player player, int index) {
+    queueDataAdapter.remove(index);
+    queueMediaSource.removeMediaSource(index);
+  }
+
+  @Override
+  public void onSetRating(Player player, RatingCompat rating) {
+    // Do nothing.
+  }
+
+  // CommandReceiver implementation.
+
+  @NonNull
+  @Override
+  public String[] getCommands() {
+    return new String[] {COMMAND_MOVE_QUEUE_ITEM};
+  }
+
+  @Override
+  public void onCommand(Player player, String command, Bundle extras, ResultReceiver cb) {
+    int from = extras.getInt(EXTRA_FROM_INDEX, C.INDEX_UNSET);
+    int to = extras.getInt(EXTRA_TO_INDEX, C.INDEX_UNSET);
+    if (from != C.INDEX_UNSET && to != C.INDEX_UNSET) {
+      queueDataAdapter.move(from, to);
+      queueMediaSource.moveMediaSource(from, to);
+    }
+  }
+
+}
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
index 521b4cd6e3..1b9bd3ecd9 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.ext.mediasession;
 
+import android.os.Bundle;
+import android.os.ResultReceiver;
 import android.support.annotation.Nullable;
 import android.support.v4.media.MediaDescriptionCompat;
 import android.support.v4.media.session.MediaSessionCompat;
@@ -23,7 +25,6 @@
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.util.Util;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -126,8 +127,7 @@ public void onSkipToPrevious(Player player) {
     if (timeline.isEmpty()) {
       return;
     }
-    int previousWindowIndex = timeline.getPreviousWindowIndex(player.getCurrentWindowIndex(),
-        player.getRepeatMode());
+    int previousWindowIndex = player.getPreviousWindowIndex();
     if (player.getCurrentPosition() > MAX_POSITION_FOR_SEEK_TO_PREVIOUS
         || previousWindowIndex == C.INDEX_UNSET) {
       player.seekTo(0);
@@ -154,16 +154,22 @@ public void onSkipToNext(Player player) {
     if (timeline.isEmpty()) {
       return;
     }
-    int nextWindowIndex = timeline.getNextWindowIndex(player.getCurrentWindowIndex(),
-        player.getRepeatMode());
+    int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
       player.seekTo(nextWindowIndex, C.TIME_UNSET);
     }
   }
 
+  // CommandReceiver implementation.
+
+  @Override
+  public String[] getCommands() {
+    return null;
+  }
+
   @Override
-  public void onSetShuffleModeEnabled(Player player, boolean enabled) {
-    // TODO: Implement this.
+  public void onCommand(Player player, String command, Bundle extras, ResultReceiver cb) {
+    // Do nothing.
   }
 
   private void publishFloatingQueueWindow(Player player) {
@@ -186,3 +192,4 @@ private void publishFloatingQueueWindow(Player player) {
   }
 
 }
+
diff --git a/extensions/okhttp/README.md b/extensions/okhttp/README.md
index f84d0c35f2..e40535d4e8 100644
--- a/extensions/okhttp/README.md
+++ b/extensions/okhttp/README.md
@@ -6,6 +6,14 @@ The OkHttp extension is an [HttpDataSource][] implementation using Square's
 [HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
 [OkHttp]: https://square.github.io/okhttp/
 
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension requires depending on OkHttp, which is
+licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
 ## Getting the extension ##
 
 The easiest way to use the extension is to add it as a gradle dependency:
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index bc9e0eba3e..13bcff8a4e 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -31,7 +31,7 @@ android {
 
 dependencies {
     compile project(modulePrefix + 'library-core')
-    compile('com.squareup.okhttp3:okhttp:3.8.1') {
+    compile('com.squareup.okhttp3:okhttp:3.9.0') {
         exclude group: 'org.json'
     }
 }
diff --git a/extensions/opus/README.md b/extensions/opus/README.md
index d766e8c9c4..15c3e5413d 100644
--- a/extensions/opus/README.md
+++ b/extensions/opus/README.md
@@ -3,6 +3,14 @@
 The Opus extension provides `LibopusAudioRenderer`, which uses libopus (the Opus
 decoding library) to decode Opus audio.
 
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension also requires building and including one or
+more external libraries as described below. These are licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
 ## Build instructions ##
 
 To use this extension you need to clone the ExoPlayer repository and depend on
diff --git a/extensions/opus/src/androidTest/AndroidManifest.xml b/extensions/opus/src/androidTest/AndroidManifest.xml
index e77590dc65..aba71a0821 100644
--- a/extensions/opus/src/androidTest/AndroidManifest.xml
+++ b/extensions/opus/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.opus.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index 4c576b2cc0..591f43f38a 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -22,15 +22,11 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
-import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
 /**
@@ -45,20 +41,22 @@ public void testBasicPlayback() throws ExoPlaybackException {
   }
 
   private void playUri(String uri) throws ExoPlaybackException {
-    TestPlaybackThread thread = new TestPlaybackThread(Uri.parse(uri),
+    TestPlaybackRunnable testPlaybackRunnable = new TestPlaybackRunnable(Uri.parse(uri),
         getInstrumentation().getContext());
+    Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
     try {
       thread.join();
     } catch (InterruptedException e) {
       fail(); // Should never happen.
     }
-    if (thread.playbackException != null) {
-      throw thread.playbackException;
+    if (testPlaybackRunnable.playbackException != null) {
+      throw testPlaybackRunnable.playbackException;
     }
   }
 
-  private static class TestPlaybackThread extends Thread implements Player.EventListener {
+  private static class TestPlaybackRunnable extends Player.DefaultEventListener
+      implements Runnable {
 
     private final Context context;
     private final Uri uri;
@@ -66,7 +64,7 @@ private void playUri(String uri) throws ExoPlaybackException {
     private ExoPlayer player;
     private ExoPlaybackException playbackException;
 
-    public TestPlaybackThread(Uri uri, Context context) {
+    public TestPlaybackRunnable(Uri uri, Context context) {
       this.uri = uri;
       this.context = context;
     }
@@ -89,31 +87,6 @@ public void run() {
       Looper.loop();
     }
 
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPositionDiscontinuity() {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
-      // Do nothing.
-    }
-
     @Override
     public void onPlayerError(ExoPlaybackException error) {
       playbackException = error;
@@ -123,20 +96,11 @@ public void onPlayerError(ExoPlaybackException error) {
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       if (playbackState == Player.STATE_ENDED
           || (playbackState == Player.STATE_IDLE && playbackException != null)) {
-        releasePlayerAndQuitLooper();
+        player.release();
+        Looper.myLooper().quit();
       }
     }
 
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-      // Do nothing.
-    }
-
-    private void releasePlayerAndQuitLooper() {
-      player.release();
-      Looper.myLooper().quit();
-    }
-
   }
 
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index 730473ddad..e4745d0c29 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -71,9 +71,16 @@ public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eve
   }
 
   @Override
-  protected int supportsFormatInternal(Format format) {
-    return OpusLibrary.isAvailable() && MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)
-        ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+  protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      Format format) {
+    if (!OpusLibrary.isAvailable()
+        || !MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
+    } else {
+      return FORMAT_HANDLED;
+    }
   }
 
   @Override
diff --git a/extensions/rtmp/README.md b/extensions/rtmp/README.md
index 7e6bc0d641..fb822b8326 100644
--- a/extensions/rtmp/README.md
+++ b/extensions/rtmp/README.md
@@ -7,6 +7,14 @@ streams using [LibRtmp Client for Android][].
 [RTMP]: https://en.wikipedia.org/wiki/Real-Time_Messaging_Protocol
 [LibRtmp Client for Android]: https://github.com/ant-media/LibRtmp-Client-for-Android
 
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension requires depending on LibRtmp Client for
+Android, which is licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
 ## Getting the extension ##
 
 The easiest way to use the extension is to add it as a gradle dependency:
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 7bce4a2a25..941b413c09 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -3,6 +3,14 @@
 The VP9 extension provides `LibvpxVideoRenderer`, which uses libvpx (the VPx
 decoding library) to decode VP9 video.
 
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension also requires building and including one or
+more external libraries as described below. These are licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
 ## Build instructions ##
 
 To use this extension you need to clone the ExoPlayer repository and depend on
diff --git a/extensions/vp9/src/androidTest/AndroidManifest.xml b/extensions/vp9/src/androidTest/AndroidManifest.xml
index b8b28fc346..f29381a320 100644
--- a/extensions/vp9/src/androidTest/AndroidManifest.xml
+++ b/extensions/vp9/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.vp9.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index 0bc945174e..c2c1867a90 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -23,15 +23,11 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
-import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
 /**
@@ -74,20 +70,22 @@ public void testInvalidBitstream() {
   }
 
   private void playUri(String uri) throws ExoPlaybackException {
-    TestPlaybackThread thread = new TestPlaybackThread(Uri.parse(uri),
+    TestPlaybackRunnable testPlaybackRunnable = new TestPlaybackRunnable(Uri.parse(uri),
         getInstrumentation().getContext());
+    Thread thread = new Thread(testPlaybackRunnable);
     thread.start();
     try {
       thread.join();
     } catch (InterruptedException e) {
       fail(); // Should never happen.
     }
-    if (thread.playbackException != null) {
-      throw thread.playbackException;
+    if (testPlaybackRunnable.playbackException != null) {
+      throw testPlaybackRunnable.playbackException;
     }
   }
 
-  private static class TestPlaybackThread extends Thread implements Player.EventListener {
+  private static class TestPlaybackRunnable extends Player.DefaultEventListener
+      implements Runnable {
 
     private final Context context;
     private final Uri uri;
@@ -95,7 +93,7 @@ private void playUri(String uri) throws ExoPlaybackException {
     private ExoPlayer player;
     private ExoPlaybackException playbackException;
 
-    public TestPlaybackThread(Uri uri, Context context) {
+    public TestPlaybackRunnable(Uri uri, Context context) {
       this.uri = uri;
       this.context = context;
     }
@@ -121,31 +119,6 @@ public void run() {
       Looper.loop();
     }
 
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPositionDiscontinuity() {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
-      // Do nothing.
-    }
-
     @Override
     public void onPlayerError(ExoPlaybackException error) {
       playbackException = error;
@@ -155,20 +128,11 @@ public void onPlayerError(ExoPlaybackException error) {
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       if (playbackState == Player.STATE_ENDED
           || (playbackState == Player.STATE_IDLE && playbackException != null)) {
-        releasePlayerAndQuitLooper();
+        player.release();
+        Looper.myLooper().quit();
       }
     }
 
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-      // Do nothing.
-    }
-
-    private void releasePlayerAndQuitLooper() {
-      player.release();
-      Looper.myLooper().quit();
-    }
-
   }
 
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index b3c06b2a0f..dd303af0d8 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -21,7 +21,6 @@
 import android.os.Looper;
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
-import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
@@ -48,7 +47,6 @@
  * Decodes and renders video using the native VP9 decoder.
  */
 public final class LibvpxVideoRenderer extends BaseRenderer {
-  public static final String TAG = "LibvpxVideoRenderer";
 
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
@@ -111,12 +109,12 @@
   private DrmSession<ExoMediaCrypto> drmSession;
   private DrmSession<ExoMediaCrypto> pendingDrmSession;
 
-  @ReinitializationState
-  private int decoderReinitializationState;
+  private @ReinitializationState int decoderReinitializationState;
   private boolean decoderReceivedBuffers;
 
   private Bitmap bitmap;
   private boolean renderedFirstFrame;
+  private boolean forceRenderFrame;
   private long joiningDeadlineMs;
   private Surface surface;
   private VpxOutputBufferRenderer outputBufferRenderer;
@@ -131,7 +129,7 @@
   private long droppedFrameAccumulationStartTimeMs;
   private int droppedFrames;
   private int consecutiveDroppedFrameCount;
-  private String vpxDecoderInfo;
+  private int buffersInCodecCount;
 
   /**
    * @param scaleToFit Whether video frames should be scaled to fit when rendering.
@@ -197,19 +195,12 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
 
   @Override
   public int supportsFormat(Format format) {
-    Log.d(TAG, "supportsFormat " + format.sampleMimeType);
-    if (!VpxLibrary.isAvailable()) {
-      Log.w(TAG, "VpxLibrary not available");
-    } else {
-      if (vpxDecoderInfo == null) {
-        vpxDecoderInfo = "VpxLibrary Version:" + VpxLibrary.getVersion()
-                + ", build params:" + VpxLibrary.getBuildConfig()
-                + ", HighBitDepthSupported:" + VpxLibrary.isHighBitDepthSupported();
-        Log.i(TAG, vpxDecoderInfo);
-      }
+    if (!VpxLibrary.isAvailable() || !MimeTypes.VIDEO_VP9.equalsIgnoreCase(format.sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
     }
-    return VpxLibrary.isAvailable() && MimeTypes.VIDEO_VP9.equalsIgnoreCase(format.sampleMimeType)
-        ? (FORMAT_HANDLED | ADAPTIVE_SEAMLESS) : FORMAT_UNSUPPORTED_TYPE;
+    return FORMAT_HANDLED | ADAPTIVE_SEAMLESS;
   }
 
   @Override
@@ -267,6 +258,7 @@ private boolean drainOutputBuffer(long positionUs) throws ExoPlaybackException,
         return false;
       }
       decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+      buffersInCodecCount -= outputBuffer.skippedOutputBufferCount;
     }
 
     if (nextOutputBuffer == null) {
@@ -289,26 +281,42 @@ private boolean drainOutputBuffer(long positionUs) throws ExoPlaybackException,
     if (outputMode == VpxDecoder.OUTPUT_MODE_NONE) {
       // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
       if (isBufferLate(outputBuffer.timeUs - positionUs)) {
+        forceRenderFrame = false;
         skipBuffer();
+        buffersInCodecCount--;
         return true;
       }
       return false;
     }
 
+    if (forceRenderFrame) {
+      forceRenderFrame = false;
+      renderBuffer();
+      buffersInCodecCount--;
+      return true;
+    }
+
     final long nextOutputBufferTimeUs =
         nextOutputBuffer != null && !nextOutputBuffer.isEndOfStream()
             ? nextOutputBuffer.timeUs : C.TIME_UNSET;
-    if (shouldDropOutputBuffer(
+
+    long earlyUs = outputBuffer.timeUs - positionUs;
+    if (shouldDropBuffersToKeyframe(earlyUs) && maybeDropBuffersToKeyframe(positionUs)) {
+      forceRenderFrame = true;
+      return false;
+    } else if (shouldDropOutputBuffer(
         outputBuffer.timeUs, nextOutputBufferTimeUs, positionUs, joiningDeadlineMs)) {
       dropBuffer();
+      buffersInCodecCount--;
       return true;
     }
 
     // If we have yet to render a frame to the current output (either initially or immediately
     // following a seek), render one irrespective of the state or current position.
     if (!renderedFirstFrame
-        || (getState() == STATE_STARTED && outputBuffer.timeUs <= positionUs + 30000)) {
+        || (getState() == STATE_STARTED && earlyUs <= 30000)) {
       renderBuffer();
+      buffersInCodecCount--;
     }
     return false;
   }
@@ -317,18 +325,29 @@ private boolean drainOutputBuffer(long positionUs) throws ExoPlaybackException,
    * Returns whether the current frame should be dropped.
    *
    * @param outputBufferTimeUs The timestamp of the current output buffer.
-   * @param nextOutputBufferTimeUs The timestamp of the next output buffer or
-   *     {@link C#TIME_UNSET} if the next output buffer is unavailable.
+   * @param nextOutputBufferTimeUs The timestamp of the next output buffer or {@link C#TIME_UNSET}
+   *     if the next output buffer is unavailable.
    * @param positionUs The current playback position.
    * @param joiningDeadlineMs The joining deadline.
    * @return Returns whether to drop the current output buffer.
    */
-  protected boolean shouldDropOutputBuffer(long outputBufferTimeUs, long nextOutputBufferTimeUs,
+  private boolean shouldDropOutputBuffer(long outputBufferTimeUs, long nextOutputBufferTimeUs,
       long positionUs, long joiningDeadlineMs) {
     return isBufferLate(outputBufferTimeUs - positionUs)
         && (joiningDeadlineMs != C.TIME_UNSET || nextOutputBufferTimeUs != C.TIME_UNSET);
   }
 
+  /**
+   * Returns whether to drop all buffers from the buffer being processed to the keyframe at or after
+   * the current playback position, if possible.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   */
+  private boolean shouldDropBuffersToKeyframe(long earlyUs) {
+    return isBufferVeryLate(earlyUs);
+  }
+
   private void renderBuffer() {
     int bufferMode = outputBuffer.mode;
     boolean renderRgb = bufferMode == VpxDecoder.OUTPUT_MODE_RGB && surface != null;
@@ -352,18 +371,35 @@ private void renderBuffer() {
   }
 
   private void dropBuffer() {
-    decoderCounters.droppedOutputBufferCount++;
-    droppedFrames++;
-    consecutiveDroppedFrameCount++;
-    decoderCounters.maxConsecutiveDroppedOutputBufferCount = Math.max(
-        consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedOutputBufferCount);
-    if (droppedFrames == maxDroppedFramesToNotify) {
-      maybeNotifyDroppedFrames();
-    }
+    updateDroppedBufferCounters(1);
     outputBuffer.release();
     outputBuffer = null;
   }
 
+  private boolean maybeDropBuffersToKeyframe(long positionUs) throws ExoPlaybackException {
+    int droppedSourceBufferCount = skipSource(positionUs);
+    if (droppedSourceBufferCount == 0) {
+      return false;
+    }
+    decoderCounters.droppedToKeyframeCount++;
+    // We dropped some buffers to catch up, so update the decoder counters and flush the codec,
+    // which releases all pending buffers buffers including the current output buffer.
+    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
+    flushDecoder();
+    return true;
+  }
+
+  private void updateDroppedBufferCounters(int droppedBufferCount) {
+    decoderCounters.droppedBufferCount += droppedBufferCount;
+    droppedFrames += droppedBufferCount;
+    consecutiveDroppedFrameCount += droppedBufferCount;
+    decoderCounters.maxConsecutiveDroppedBufferCount = Math.max(consecutiveDroppedFrameCount,
+        decoderCounters.maxConsecutiveDroppedBufferCount);
+    if (droppedFrames >= maxDroppedFramesToNotify) {
+      maybeNotifyDroppedFrames();
+    }
+  }
+
   private void skipBuffer() {
     decoderCounters.skippedOutputBufferCount++;
     outputBuffer.release();
@@ -436,6 +472,7 @@ private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackExcepti
     inputBuffer.flip();
     inputBuffer.colorInfo = formatHolder.format.colorInfo;
     decoder.queueInputBuffer(inputBuffer);
+    buffersInCodecCount++;
     decoderReceivedBuffers = true;
     decoderCounters.inputBufferCount++;
     inputBuffer = null;
@@ -455,6 +492,8 @@ private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackExc
 
   private void flushDecoder() throws ExoPlaybackException {
     waitingForKeys = false;
+    forceRenderFrame = false;
+    buffersInCodecCount = 0;
     if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
       releaseDecoder();
       maybeInitDecoder();
@@ -611,6 +650,8 @@ private void releaseDecoder() {
     decoderCounters.decoderReleaseCount++;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     decoderReceivedBuffers = false;
+    forceRenderFrame = false;
+    buffersInCodecCount = 0;
   }
 
   private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
@@ -745,8 +786,13 @@ private void maybeNotifyDroppedFrames() {
   }
 
   private static boolean isBufferLate(long earlyUs) {
-    // Class a buffer as late if it should have been presented more than 30ms ago.
+    // Class a buffer as late if it should have been presented more than 30 ms ago.
     return earlyUs < -30000;
   }
 
+  private static boolean isBufferVeryLate(long earlyUs) {
+    // Class a buffer as very late if it should have been presented more than 500 ms ago.
+    return earlyUs < -500000;
+  }
+
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 4bec5bdf4c..ef999d5d2b 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -120,14 +120,16 @@ protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer
       }
     }
 
-    outputBuffer.init(inputBuffer.timeUs, outputMode);
-    int getFrameResult = vpxGetFrame(vpxDecContext, outputBuffer);
-    if (getFrameResult == 1) {
-      outputBuffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
-    } else if (getFrameResult == -1) {
-      return new VpxDecoderException("Buffer initialization failed.");
+    if (!inputBuffer.isDecodeOnly()) {
+      outputBuffer.init(inputBuffer.timeUs, outputMode);
+      int getFrameResult = vpxGetFrame(vpxDecContext, outputBuffer);
+      if (getFrameResult == 1) {
+        outputBuffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
+      } else if (getFrameResult == -1) {
+        return new VpxDecoderException("Buffer initialization failed.");
+      }
+      outputBuffer.colorInfo = inputBuffer.colorInfo;
     }
-    outputBuffer.colorInfo = inputBuffer.colorInfo;
     return null;
   }
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java
index e7468d8593..8c765952e7 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.opengl.GLSurfaceView;
 import android.util.AttributeSet;
@@ -23,7 +22,6 @@
 /**
  * A GLSurfaceView extension that scales itself to the given aspect ratio.
  */
-@TargetApi(11)
 public class VpxVideoSurfaceView extends GLSurfaceView implements VpxOutputBufferRenderer {
 
   private final VpxRenderer renderer;
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index f0b93b1dc2..5c480d1525 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -15,6 +15,9 @@
  */
 
 #include <cpu-features.h>
+#ifdef __ARM_NEON__
+#include <arm_neon.h>
+#endif
 #include <jni.h>
 
 #include <android/log.h>
@@ -70,6 +73,216 @@ jint JNI_OnLoad(JavaVM* vm, void* reserved) {
   return JNI_VERSION_1_6;
 }
 
+#ifdef __ARM_NEON__
+static int convert_16_to_8_neon(const vpx_image_t* const img, jbyte* const data,
+                                const int32_t uvHeight, const int32_t yLength,
+                                const int32_t uvLength) {
+  if (!(android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON)) return 0;
+  uint32x2_t lcg_val = vdup_n_u32(random());
+  lcg_val = vset_lane_u32(random(), lcg_val, 1);
+  // LCG values recommended in good ol' "Numerical Recipes"
+  const uint32x2_t LCG_MULT = vdup_n_u32(1664525);
+  const uint32x2_t LCG_INCR = vdup_n_u32(1013904223);
+
+  const uint16_t* srcBase =
+      reinterpret_cast<uint16_t*>(img->planes[VPX_PLANE_Y]);
+  uint8_t* dstBase = reinterpret_cast<uint8_t*>(data);
+  // In units of uint16_t, so /2 from raw stride
+  const int srcStride = img->stride[VPX_PLANE_Y] / 2;
+  const int dstStride = img->stride[VPX_PLANE_Y];
+
+  for (int y = 0; y < img->d_h; y++) {
+    const uint16_t* src = srcBase;
+    uint8_t* dst = dstBase;
+
+    // Each read consumes 4 2-byte samples, but to reduce branches and
+    // random steps we unroll to four rounds, so each loop consumes 16
+    // samples.
+    const int imax = img->d_w & ~15;
+    int i;
+    for (i = 0; i < imax; i += 16) {
+      // Run a round of the RNG.
+      lcg_val = vmla_u32(LCG_INCR, lcg_val, LCG_MULT);
+
+      // The lower two bits of this LCG parameterization are garbage,
+      // leaving streaks on the image. We access the upper bits of each
+      // 16-bit lane by shifting. (We use this both as an 8- and 16-bit
+      // vector, so the choice of which one to keep it as is arbitrary.)
+      uint8x8_t randvec =
+          vreinterpret_u8_u16(vshr_n_u16(vreinterpret_u16_u32(lcg_val), 8));
+
+      // We retrieve the values and shift them so that the bits we'll
+      // shift out (after biasing) are in the upper 8 bits of each 16-bit
+      // lane.
+      uint16x4_t values = vshl_n_u16(vld1_u16(src), 6);
+      src += 4;
+
+      // We add the bias bits in the lower 8 to the shifted values to get
+      // the final values in the upper 8 bits.
+      uint16x4_t added1 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+
+      // Shifting the randvec bits left by 2 bits, as an 8-bit vector,
+      // should leave us with enough bias to get the needed rounding
+      // operation.
+      randvec = vshl_n_u8(randvec, 2);
+
+      // Retrieve and sum the next 4 pixels.
+      values = vshl_n_u16(vld1_u16(src), 6);
+      src += 4;
+      uint16x4_t added2 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+
+      // Reinterpret the two added vectors as 8x8, zip them together, and
+      // discard the lower portions.
+      uint8x8_t zipped =
+          vuzp_u8(vreinterpret_u8_u16(added1), vreinterpret_u8_u16(added2))
+              .val[1];
+      vst1_u8(dst, zipped);
+      dst += 8;
+
+      // Run it again with the next two rounds using the remaining
+      // entropy in randvec.
+      randvec = vshl_n_u8(randvec, 2);
+      values = vshl_n_u16(vld1_u16(src), 6);
+      src += 4;
+      added1 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+      randvec = vshl_n_u8(randvec, 2);
+      values = vshl_n_u16(vld1_u16(src), 6);
+      src += 4;
+      added2 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+      zipped = vuzp_u8(vreinterpret_u8_u16(added1), vreinterpret_u8_u16(added2))
+                   .val[1];
+      vst1_u8(dst, zipped);
+      dst += 8;
+    }
+
+    uint32_t randval = 0;
+    // For the remaining pixels in each row - usually none, as most
+    // standard sizes are divisible by 32 - convert them "by hand".
+    while (i < img->d_w) {
+      if (!randval) randval = random();
+      dstBase[i] = (srcBase[i] + (randval & 3)) >> 2;
+      i++;
+      randval >>= 2;
+    }
+
+    srcBase += srcStride;
+    dstBase += dstStride;
+  }
+
+  const uint16_t* srcUBase =
+      reinterpret_cast<uint16_t*>(img->planes[VPX_PLANE_U]);
+  const uint16_t* srcVBase =
+      reinterpret_cast<uint16_t*>(img->planes[VPX_PLANE_V]);
+  const int32_t uvWidth = (img->d_w + 1) / 2;
+  uint8_t* dstUBase = reinterpret_cast<uint8_t*>(data + yLength);
+  uint8_t* dstVBase = reinterpret_cast<uint8_t*>(data + yLength + uvLength);
+  const int srcUVStride = img->stride[VPX_PLANE_V] / 2;
+  const int dstUVStride = img->stride[VPX_PLANE_V];
+
+  for (int y = 0; y < uvHeight; y++) {
+    const uint16_t* srcU = srcUBase;
+    const uint16_t* srcV = srcVBase;
+    uint8_t* dstU = dstUBase;
+    uint8_t* dstV = dstVBase;
+
+    // As before, each i++ consumes 4 samples (8 bytes). For simplicity we
+    // don't unroll these loops more than we have to, which is 8 samples.
+    const int imax = uvWidth & ~7;
+    int i;
+    for (i = 0; i < imax; i += 8) {
+      lcg_val = vmla_u32(LCG_INCR, lcg_val, LCG_MULT);
+      uint8x8_t randvec =
+          vreinterpret_u8_u16(vshr_n_u16(vreinterpret_u16_u32(lcg_val), 8));
+      uint16x4_t uVal1 = vqadd_u16(vshl_n_u16(vld1_u16(srcU), 6),
+                                   vreinterpret_u16_u8(randvec));
+      srcU += 4;
+      randvec = vshl_n_u8(randvec, 2);
+      uint16x4_t vVal1 = vqadd_u16(vshl_n_u16(vld1_u16(srcV), 6),
+                                   vreinterpret_u16_u8(randvec));
+      srcV += 4;
+      randvec = vshl_n_u8(randvec, 2);
+      uint16x4_t uVal2 = vqadd_u16(vshl_n_u16(vld1_u16(srcU), 6),
+                                   vreinterpret_u16_u8(randvec));
+      srcU += 4;
+      randvec = vshl_n_u8(randvec, 2);
+      uint16x4_t vVal2 = vqadd_u16(vshl_n_u16(vld1_u16(srcV), 6),
+                                   vreinterpret_u16_u8(randvec));
+      srcV += 4;
+      vst1_u8(dstU,
+              vuzp_u8(vreinterpret_u8_u16(uVal1), vreinterpret_u8_u16(uVal2))
+                  .val[1]);
+      dstU += 8;
+      vst1_u8(dstV,
+              vuzp_u8(vreinterpret_u8_u16(vVal1), vreinterpret_u8_u16(vVal2))
+                  .val[1]);
+      dstV += 8;
+    }
+
+    i *= 4;
+    uint32_t randval = 0;
+    while (i < uvWidth) {
+      if (!randval) randval = random();
+      dstUBase[i] = (srcUBase[i] + (randval & 3)) >> 2;
+      randval >>= 2;
+      dstVBase[i] = (srcVBase[i] + (randval & 3)) >> 2;
+      randval >>= 2;
+      i++;
+    }
+
+    srcUBase += srcUVStride;
+    srcVBase += srcUVStride;
+    dstUBase += dstUVStride;
+    dstVBase += dstUVStride;
+  }
+
+  return 1;
+}
+
+#endif  // __ARM_NEON__
+
+static void convert_16_to_8_standard(const vpx_image_t* const img,
+                                     jbyte* const data, const int32_t uvHeight,
+                                     const int32_t yLength,
+                                     const int32_t uvLength) {
+  // Y
+  int sampleY = 0;
+  for (int y = 0; y < img->d_h; y++) {
+    const uint16_t* srcBase = reinterpret_cast<uint16_t*>(
+        img->planes[VPX_PLANE_Y] + img->stride[VPX_PLANE_Y] * y);
+    int8_t* destBase = data + img->stride[VPX_PLANE_Y] * y;
+    for (int x = 0; x < img->d_w; x++) {
+      // Lightweight dither. Carryover the remainder of each 10->8 bit
+      // conversion to the next pixel.
+      sampleY += *srcBase++;
+      *destBase++ = sampleY >> 2;
+      sampleY = sampleY & 3;  // Remainder.
+    }
+  }
+  // UV
+  int sampleU = 0;
+  int sampleV = 0;
+  const int32_t uvWidth = (img->d_w + 1) / 2;
+  for (int y = 0; y < uvHeight; y++) {
+    const uint16_t* srcUBase = reinterpret_cast<uint16_t*>(
+        img->planes[VPX_PLANE_U] + img->stride[VPX_PLANE_U] * y);
+    const uint16_t* srcVBase = reinterpret_cast<uint16_t*>(
+        img->planes[VPX_PLANE_V] + img->stride[VPX_PLANE_V] * y);
+    int8_t* destUBase = data + yLength + img->stride[VPX_PLANE_U] * y;
+    int8_t* destVBase =
+        data + yLength + uvLength + img->stride[VPX_PLANE_V] * y;
+    for (int x = 0; x < uvWidth; x++) {
+      // Lightweight dither. Carryover the remainder of each 10->8 bit
+      // conversion to the next pixel.
+      sampleU += *srcUBase++;
+      *destUBase++ = sampleU >> 2;
+      sampleU = sampleU & 3;  // Remainder.
+      sampleV += *srcVBase++;
+      *destVBase++ = sampleV >> 2;
+      sampleV = sampleV & 3;  // Remainder.
+    }
+  }
+}
+
 DECODER_FUNC(jlong, vpxInit) {
   vpx_codec_ctx_t* context = new vpx_codec_ctx_t();
   vpx_codec_dec_cfg_t cfg = {0, 0, 0};
@@ -201,47 +414,17 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
       // Note: The stride for BT2020 is twice of what we use so this is wasting
       // memory. The long term goal however is to upload half-float/short so
       // it's not important to optimize the stride at this time.
-      // Y
-      int sampleY = 0;
-      for (int y = 0; y < img->d_h; y++) {
-        const uint16_t* srcBase = reinterpret_cast<uint16_t*>(
-            img->planes[VPX_PLANE_Y] + img->stride[VPX_PLANE_Y] * y);
-        int8_t* destBase = data + img->stride[VPX_PLANE_Y] * y;
-        for (int x = 0; x < img->d_w; x++) {
-          // Lightweight dither. Carryover the remainder of each 10->8 bit
-          // conversion to the next pixel.
-          sampleY += *srcBase++;
-          *destBase++ = sampleY >> 2;
-          sampleY = sampleY & 3;  // Remainder.
-        }
-      }
-      // UV
-      int sampleU = 0;
-      int sampleV = 0;
-      const int32_t uvWidth = (img->d_w + 1) / 2;
-      for (int y = 0; y < uvHeight; y++) {
-        const uint16_t* srcUBase = reinterpret_cast<uint16_t*>(
-            img->planes[VPX_PLANE_U] + img->stride[VPX_PLANE_U] * y);
-        const uint16_t* srcVBase = reinterpret_cast<uint16_t*>(
-            img->planes[VPX_PLANE_V] + img->stride[VPX_PLANE_V] * y);
-        int8_t* destUBase = data + yLength + img->stride[VPX_PLANE_U] * y;
-        int8_t* destVBase = data + yLength + uvLength
-            + img->stride[VPX_PLANE_V] * y;
-        for (int x = 0; x < uvWidth; x++) {
-          // Lightweight dither. Carryover the remainder of each 10->8 bit
-          // conversion to the next pixel.
-          sampleU += *srcUBase++;
-          *destUBase++ = sampleU >> 2;
-          sampleU = sampleU & 3;  // Remainder.
-          sampleV += *srcVBase++;
-          *destVBase++ = sampleV >> 2;
-          sampleV = sampleV & 3;  // Remainder.
-        }
+      int converted = 0;
+#ifdef __ARM_NEON__
+      converted = convert_16_to_8_neon(img, data, uvHeight, yLength, uvLength);
+#endif  // __ARM_NEON__
+      if (!converted) {
+        convert_16_to_8_standard(img, data, uvHeight, yLength, uvLength);
       }
     } else {
-      // TODO: This copy can be eliminated by using external frame buffers. This
-      // is insignificant for smaller videos but takes ~1.5ms for 1080p clips.
-      // So this should eventually be gotten rid of.
+      // TODO: This copy can be eliminated by using external frame
+      // buffers. This is insignificant for smaller videos but takes ~1.5ms
+      // for 1080p clips. So this should eventually be gotten rid of.
       memcpy(data, img->planes[VPX_PLANE_Y], yLength);
       memcpy(data + yLength, img->planes[VPX_PLANE_U], uvLength);
       memcpy(data + yLength + uvLength, img->planes[VPX_PLANE_V], uvLength);
@@ -255,9 +438,7 @@ DECODER_FUNC(jstring, vpxGetErrorMessage, jlong jContext) {
   return env->NewStringUTF(vpx_codec_error(context));
 }
 
-DECODER_FUNC(jint, vpxGetErrorCode, jlong jContext) {
-  return errorCode;
-}
+DECODER_FUNC(jint, vpxGetErrorCode, jlong jContext) { return errorCode; }
 
 LIBRARY_FUNC(jstring, vpxIsSecureDecodeSupported) {
   // Doesn't support
diff --git a/library/all/src/main/AndroidManifest.xml b/library/all/src/main/AndroidManifest.xml
index 1efda648e9..f31f55b40a 100644
--- a/library/all/src/main/AndroidManifest.xml
+++ b/library/all/src/main/AndroidManifest.xml
@@ -13,5 +13,4 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-
 <manifest package="com.google.android.exoplayer2"/>
diff --git a/library/core/build.gradle b/library/core/build.gradle
index ecad1e58b5..d50834efd5 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -28,6 +28,9 @@ android {
         androidTest {
             java.srcDirs += "../../testutils/src/main/java/"
         }
+        test {
+            java.srcDirs += "../../testutils/src/main/java/"
+        }
     }
 
     buildTypes {
@@ -44,6 +47,10 @@ dependencies {
     androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
     androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile 'com.google.truth:truth:' + truthVersion
+    testCompile 'junit:junit:' + junitVersion
+    testCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile 'org.robolectric:robolectric:' + robolectricVersion
 }
 
 ext {
diff --git a/library/core/src/androidTest/AndroidManifest.xml b/library/core/src/androidTest/AndroidManifest.xml
index aeddc611cf..4997994e18 100644
--- a/library/core/src/androidTest/AndroidManifest.xml
+++ b/library/core/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.core.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/library/core/src/androidTest/assets/webvtt/typical_with_bad_timestamps b/library/core/src/androidTest/assets/webvtt/typical_with_bad_timestamps
new file mode 100644
index 0000000000..bb70a9fa26
--- /dev/null
+++ b/library/core/src/androidTest/assets/webvtt/typical_with_bad_timestamps
@@ -0,0 +1,14 @@
+WEBVTT # This comment is allowed
+
+# First timestamp is missing the 1/1000ths component, but parse anyway.
+00:00 --> 00:01.234
+This is the first subtitle.
+
+02.345 --> 00:03.456
+This is the second subtitle.
+
+0.0.0 --> 00:05.678
+This should be discarded (too many dots).
+
+00:06.789 --> not-a-timestamp
+This should be discarded (not a timestamp).
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
index bf4ea6e972..56d5f05d00 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -15,20 +15,22 @@
  */
 package com.google.android.exoplayer2;
 
-import android.util.Pair;
+import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.testutil.ExoPlayerWrapper;
+import com.google.android.exoplayer2.testutil.ActionSchedule;
+import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner;
+import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder;
 import com.google.android.exoplayer2.testutil.FakeMediaClockRenderer;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
 import com.google.android.exoplayer2.testutil.FakeRenderer;
+import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
-import com.google.android.exoplayer2.util.MimeTypes;
-import java.util.LinkedList;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import junit.framework.TestCase;
 
 /**
@@ -43,67 +45,59 @@
    */
   private static final int TIMEOUT_MS = 10000;
 
-  private static final Format TEST_VIDEO_FORMAT = Format.createVideoSampleFormat(null,
-      MimeTypes.VIDEO_H264, null, Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE,
-      null, null);
-  private static final Format TEST_AUDIO_FORMAT =  Format.createAudioSampleFormat(null,
-      MimeTypes.AUDIO_AAC, null, Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
-
   /**
    * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
    * error.
    */
   public void testPlayEmptyTimeline() throws Exception {
-    ExoPlayerWrapper playerWrapper = new ExoPlayerWrapper();
     Timeline timeline = Timeline.EMPTY;
-    MediaSource mediaSource = new FakeMediaSource(timeline, null);
     FakeRenderer renderer = new FakeRenderer();
-    playerWrapper.setup(mediaSource, renderer);
-    playerWrapper.blockUntilEnded(TIMEOUT_MS);
-    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setTimeline(timeline).setRenderers(renderer)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityCount(0);
+    testRunner.assertTimelinesEqual();
     assertEquals(0, renderer.formatReadCount);
     assertEquals(0, renderer.bufferReadCount);
     assertFalse(renderer.isEnded);
-    playerWrapper.assertSourceInfosEquals(Pair.create(timeline, null));
   }
 
   /**
    * Tests playback of a source that exposes a single period.
    */
   public void testPlaySinglePeriodTimeline() throws Exception {
-    ExoPlayerWrapper playerWrapper = new ExoPlayerWrapper();
     Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
     Object manifest = new Object();
-    MediaSource mediaSource = new FakeMediaSource(timeline, manifest, TEST_VIDEO_FORMAT);
-    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
-    playerWrapper.setup(mediaSource, renderer);
-    playerWrapper.blockUntilEnded(TIMEOUT_MS);
-    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setTimeline(timeline).setManifest(manifest).setRenderers(renderer)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityCount(0);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertManifestsEqual(manifest);
+    testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
     assertEquals(1, renderer.formatReadCount);
     assertEquals(1, renderer.bufferReadCount);
     assertTrue(renderer.isEnded);
-    assertEquals(new TrackGroupArray(new TrackGroup(TEST_VIDEO_FORMAT)), playerWrapper.trackGroups);
-    playerWrapper.assertSourceInfosEquals(Pair.create(timeline, manifest));
   }
 
   /**
    * Tests playback of a source that exposes three periods.
    */
   public void testPlayMultiPeriodTimeline() throws Exception {
-    ExoPlayerWrapper playerWrapper = new ExoPlayerWrapper();
     Timeline timeline = new FakeTimeline(
         new TimelineWindowDefinition(false, false, 0),
         new TimelineWindowDefinition(false, false, 0),
         new TimelineWindowDefinition(false, false, 0));
-    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT);
-    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
-    playerWrapper.setup(mediaSource, renderer);
-    playerWrapper.blockUntilEnded(TIMEOUT_MS);
-    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setTimeline(timeline).setRenderers(renderer)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityCount(2);
+    testRunner.assertTimelinesEqual(timeline);
     assertEquals(3, renderer.formatReadCount);
     assertEquals(1, renderer.bufferReadCount);
     assertTrue(renderer.isEnded);
-    playerWrapper.assertSourceInfosEquals(Pair.create(timeline, null));
   }
 
   /**
@@ -111,16 +105,12 @@ public void testPlayMultiPeriodTimeline() throws Exception {
    * source.
    */
   public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
-    final ExoPlayerWrapper playerWrapper = new ExoPlayerWrapper();
     Timeline timeline = new FakeTimeline(
         new TimelineWindowDefinition(false, false, 10),
         new TimelineWindowDefinition(false, false, 10),
         new TimelineWindowDefinition(false, false, 10));
-    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT,
-        TEST_AUDIO_FORMAT);
-
-    FakeRenderer videoRenderer = new FakeRenderer(TEST_VIDEO_FORMAT);
-    FakeMediaClockRenderer audioRenderer = new FakeMediaClockRenderer(TEST_AUDIO_FORMAT) {
+    final FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    FakeMediaClockRenderer audioRenderer = new FakeMediaClockRenderer(Builder.AUDIO_FORMAT) {
 
       @Override
       public long getPositionUs() {
@@ -143,35 +133,30 @@ public PlaybackParameters getPlaybackParameters() {
 
       @Override
       public boolean isEnded() {
-        // Allow playback to end once the final period is playing.
-        return playerWrapper.positionDiscontinuityCount == 2;
+        return videoRenderer.isEnded();
       }
 
     };
-    playerWrapper.setup(mediaSource, videoRenderer, audioRenderer);
-    playerWrapper.blockUntilEnded(TIMEOUT_MS);
-    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setTimeline(timeline).setRenderers(videoRenderer, audioRenderer)
+        .setSupportedFormats(Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityCount(2);
+    testRunner.assertTimelinesEqual(timeline);
     assertEquals(1, audioRenderer.positionResetCount);
     assertTrue(videoRenderer.isEnded);
     assertTrue(audioRenderer.isEnded);
-    playerWrapper.assertSourceInfosEquals(Pair.create(timeline, null));
   }
 
   public void testRepreparationGivesFreshSourceInfo() throws Exception {
-    ExoPlayerWrapper playerWrapper = new ExoPlayerWrapper();
     Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
-    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
-
-    // Prepare the player with a source with the first manifest and a non-empty timeline
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
     Object firstSourceManifest = new Object();
-    playerWrapper.setup(new FakeMediaSource(timeline, firstSourceManifest, TEST_VIDEO_FORMAT),
-        renderer);
-    playerWrapper.blockUntilSourceInfoRefreshed(TIMEOUT_MS);
-
-    // Prepare the player again with a source and a new manifest, which will never be exposed.
+    MediaSource firstSource = new FakeMediaSource(timeline, firstSourceManifest,
+        Builder.VIDEO_FORMAT);
     final CountDownLatch queuedSourceInfoCountDownLatch = new CountDownLatch(1);
     final CountDownLatch completePreparationCountDownLatch = new CountDownLatch(1);
-    playerWrapper.prepare(new FakeMediaSource(timeline, new Object(), TEST_VIDEO_FORMAT) {
+    MediaSource secondSource = new FakeMediaSource(timeline, new Object(), Builder.VIDEO_FORMAT) {
       @Override
       public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
         super.prepareSource(player, isTopLevelSource, listener);
@@ -185,29 +170,49 @@ public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener l
           throw new IllegalStateException(e);
         }
       }
-    });
-
-    // Prepare the player again with a third source.
-    queuedSourceInfoCountDownLatch.await();
+    };
     Object thirdSourceManifest = new Object();
-    playerWrapper.prepare(new FakeMediaSource(timeline, thirdSourceManifest, TEST_VIDEO_FORMAT));
-    completePreparationCountDownLatch.countDown();
-
-    // Wait for playback to complete.
-    playerWrapper.blockUntilEnded(TIMEOUT_MS);
-    assertEquals(0, playerWrapper.positionDiscontinuityCount);
-    assertEquals(1, renderer.formatReadCount);
-    assertEquals(1, renderer.bufferReadCount);
-    assertTrue(renderer.isEnded);
-    assertEquals(new TrackGroupArray(new TrackGroup(TEST_VIDEO_FORMAT)), playerWrapper.trackGroups);
+    MediaSource thirdSource = new FakeMediaSource(timeline, thirdSourceManifest,
+        Builder.VIDEO_FORMAT);
 
+    // Prepare the player with a source with the first manifest and a non-empty timeline. Prepare
+    // the player again with a source and a new manifest, which will never be exposed. Allow the
+    // test thread to prepare the player with a third source, and block the playback thread until
+    // the test thread's call to prepare() has returned.
+    ActionSchedule actionSchedule = new ActionSchedule.Builder("testRepreparation")
+        .waitForTimelineChanged(timeline)
+        .prepareSource(secondSource)
+        .executeRunnable(new Runnable() {
+          @Override
+          public void run() {
+            try {
+              queuedSourceInfoCountDownLatch.await();
+            } catch (InterruptedException e) {
+              // Ignore.
+            }
+          }
+        })
+        .prepareSource(thirdSource)
+        .executeRunnable(new Runnable() {
+          @Override
+          public void run() {
+            completePreparationCountDownLatch.countDown();
+          }
+        })
+        .build();
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setMediaSource(firstSource).setRenderers(renderer).setActionSchedule(actionSchedule)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityCount(0);
     // The first source's preparation completed with a non-empty timeline. When the player was
     // re-prepared with the second source, it immediately exposed an empty timeline, but the source
     // info refresh from the second source was suppressed as we re-prepared with the third source.
-    playerWrapper.assertSourceInfosEquals(
-        Pair.create(timeline, firstSourceManifest),
-        Pair.create(Timeline.EMPTY, null),
-        Pair.create(timeline, thirdSourceManifest));
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, timeline);
+    testRunner.assertManifestsEqual(firstSourceManifest, null, thirdSourceManifest);
+    testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
+    assertEquals(1, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
   }
 
   public void testRepeatModeChanges() throws Exception {
@@ -215,49 +220,95 @@ public void testRepeatModeChanges() throws Exception {
         new TimelineWindowDefinition(true, false, 100000),
         new TimelineWindowDefinition(true, false, 100000),
         new TimelineWindowDefinition(true, false, 100000));
-    final int[] actionSchedule = { // 0 -> 1
-        Player.REPEAT_MODE_ONE, // 1 -> 1
-        Player.REPEAT_MODE_OFF, // 1 -> 2
-        Player.REPEAT_MODE_ONE, // 2 -> 2
-        Player.REPEAT_MODE_ALL, // 2 -> 0
-        Player.REPEAT_MODE_ONE, // 0 -> 0
-        -1, // 0 -> 0
-        Player.REPEAT_MODE_OFF, // 0 -> 1
-        -1, // 1 -> 2
-        -1  // 2 -> ended
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule = new ActionSchedule.Builder("testRepeatMode") // 0 -> 1
+        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ONE) // 1 -> 1
+        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_OFF) // 1 -> 2
+        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ONE) // 2 -> 2
+        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ALL) // 2 -> 0
+        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ONE) // 0 -> 0
+        .waitForPositionDiscontinuity()                                       // 0 -> 0
+        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_OFF) // 0 -> end
+        .build();
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setTimeline(timeline).setRenderers(renderer).setActionSchedule(actionSchedule)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPlayedPeriodIndices(0, 1, 1, 2, 2, 0, 0, 0, 1, 2);
+    testRunner.assertTimelinesEqual(timeline);
+    assertTrue(renderer.isEnded);
+  }
+
+  public void testShuffleModeEnabledChanges() throws Exception {
+    Timeline fakeTimeline = new FakeTimeline(new TimelineWindowDefinition(true, false, 100000));
+    MediaSource[] fakeMediaSources = {
+        new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+        new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+        new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT)
     };
-    int[] expectedWindowIndices = {1, 1, 2, 2, 0, 0, 0, 1, 2};
-    final LinkedList<Integer> windowIndices = new LinkedList<>();
-    final CountDownLatch actionCounter = new CountDownLatch(actionSchedule.length);
-    ExoPlayerWrapper playerWrapper = new ExoPlayerWrapper() {
+    ConcatenatingMediaSource mediaSource = new ConcatenatingMediaSource(false,
+        new FakeShuffleOrder(3), fakeMediaSources);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule = new ActionSchedule.Builder("testShuffleModeEnabled")
+        .setRepeatMode(Player.REPEAT_MODE_ALL).waitForPositionDiscontinuity() // 0 -> 1
+        .setShuffleModeEnabled(true).waitForPositionDiscontinuity()           // 1 -> 0
+        .waitForPositionDiscontinuity().waitForPositionDiscontinuity()        // 0 -> 2 -> 1
+        .setShuffleModeEnabled(false).setRepeatMode(Player.REPEAT_MODE_OFF)   // 1 -> 2 -> end
+        .build();
+    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
+        .setMediaSource(mediaSource).setRenderers(renderer).setActionSchedule(actionSchedule)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPlayedPeriodIndices(0, 1, 0, 2, 1, 2);
+    assertTrue(renderer.isEnded);
+  }
+
+  public void testPeriodHoldersReleasedAfterSeekWithRepeatModeAll() throws Exception {
+    Timeline fakeTimeline = new FakeTimeline(new TimelineWindowDefinition(true, false, 100000));
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule = new ActionSchedule.Builder("testPeriodHoldersReleased")
+        .setRepeatMode(Player.REPEAT_MODE_ALL)
+        .waitForPositionDiscontinuity()
+        .seek(0) // Seek with repeat mode set to REPEAT_MODE_ALL.
+        .waitForPositionDiscontinuity()
+        .setRepeatMode(Player.REPEAT_MODE_OFF) // Turn off repeat so that playback can finish.
+        .build();
+    new ExoPlayerTestRunner.Builder()
+        .setTimeline(fakeTimeline).setRenderers(renderer).setActionSchedule(actionSchedule)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    assertTrue(renderer.isEnded);
+  }
+
+  public void testSeekProcessedCallback() throws Exception {
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(true, false, 100000),
+        new TimelineWindowDefinition(true, false, 100000));
+    ActionSchedule actionSchedule = new ActionSchedule.Builder("testSeekProcessedCallback")
+        // Initial seek before timeline preparation finished.
+        .pause().seek(10).waitForPlaybackState(Player.STATE_READY)
+        // Re-seek to same position, start playback and wait until playback reaches second window.
+        .seek(10).play().waitForPositionDiscontinuity()
+        // Seek twice in concession, expecting the first seek to be replaced.
+        .seek(5).seek(60).build();
+    final List<Integer> playbackStatesWhenSeekProcessed = new ArrayList<>();
+    Player.EventListener eventListener = new Player.DefaultEventListener() {
+      private int currentPlaybackState = Player.STATE_IDLE;
+
       @Override
-      @SuppressWarnings("ResourceType")
-      public void onPositionDiscontinuity() {
-        super.onPositionDiscontinuity();
-        int actionIndex = actionSchedule.length - (int) actionCounter.getCount();
-        if (actionSchedule[actionIndex] != -1) {
-          player.setRepeatMode(actionSchedule[actionIndex]);
-        }
-        windowIndices.add(player.getCurrentWindowIndex());
-        actionCounter.countDown();
+      public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+        currentPlaybackState = playbackState;
+      }
+
+      @Override
+      public void onSeekProcessed() {
+        playbackStatesWhenSeekProcessed.add(currentPlaybackState);
       }
     };
-    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT);
-    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
-    playerWrapper.setup(mediaSource, renderer);
-    boolean finished = actionCounter.await(TIMEOUT_MS, TimeUnit.MILLISECONDS);
-    playerWrapper.release();
-    assertTrue("Test playback timed out waiting for action schedule to end.", finished);
-    if (playerWrapper.exception != null) {
-      throw playerWrapper.exception;
-    }
-    assertEquals(expectedWindowIndices.length, windowIndices.size());
-    for (int i = 0; i < expectedWindowIndices.length; i++) {
-      assertEquals(expectedWindowIndices[i], windowIndices.get(i).intValue());
-    }
-    assertEquals(9, playerWrapper.positionDiscontinuityCount);
-    assertTrue(renderer.isEnded);
-    playerWrapper.assertSourceInfosEquals(Pair.create(timeline, null));
+    new ExoPlayerTestRunner.Builder()
+        .setTimeline(timeline).setEventListener(eventListener).setActionSchedule(actionSchedule)
+        .build().start().blockUntilEnded(TIMEOUT_MS);
+    assertEquals(3, playbackStatesWhenSeekProcessed.size());
+    assertEquals(Player.STATE_BUFFERING, (int) playbackStatesWhenSeekProcessed.get(0));
+    assertEquals(Player.STATE_READY, (int) playbackStatesWhenSeekProcessed.get(1));
+    assertEquals(Player.STATE_BUFFERING, (int) playbackStatesWhenSeekProcessed.get(2));
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java
index d9ee27bd62..f5c33843a1 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java
@@ -33,23 +33,25 @@ public void testSinglePeriodTimeline() {
     Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(1, 111));
     TimelineAsserts.assertWindowIds(timeline, 111);
     TimelineAsserts.assertPeriodCounts(timeline, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
   }
 
   public void testMultiPeriodTimeline() {
     Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(5, 111));
     TimelineAsserts.assertWindowIds(timeline, 111);
     TimelineAsserts.assertPeriodCounts(timeline, 5);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
   }
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
deleted file mode 100644
index aa8cbfdb62..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.drm;
-
-import static com.google.android.exoplayer2.C.PLAYREADY_UUID;
-import static com.google.android.exoplayer2.C.WIDEVINE_UUID;
-import static com.google.android.exoplayer2.util.MimeTypes.VIDEO_MP4;
-
-import android.os.Parcel;
-import android.test.MoreAsserts;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import junit.framework.TestCase;
-
-/**
- * Unit test for {@link DrmInitData}.
- */
-public class DrmInitDataTest extends TestCase {
-
-  private static final SchemeData DATA_1 = new SchemeData(WIDEVINE_UUID, "cbc1", VIDEO_MP4,
-      TestUtil.buildTestData(128, 1 /* data seed */));
-  private static final SchemeData DATA_2 = new SchemeData(PLAYREADY_UUID,  null, VIDEO_MP4,
-      TestUtil.buildTestData(128, 2 /* data seed */));
-  private static final SchemeData DATA_1B = new SchemeData(WIDEVINE_UUID, "cbc1", VIDEO_MP4,
-      TestUtil.buildTestData(128, 1 /* data seed */));
-  private static final SchemeData DATA_2B = new SchemeData(PLAYREADY_UUID, null, VIDEO_MP4,
-      TestUtil.buildTestData(128, 2 /* data seed */));
-  private static final SchemeData DATA_UNIVERSAL = new SchemeData(C.UUID_NIL, null, VIDEO_MP4,
-      TestUtil.buildTestData(128, 3 /* data seed */));
-
-  public void testParcelable() {
-    DrmInitData drmInitDataToParcel = new DrmInitData(DATA_1, DATA_2);
-
-    Parcel parcel = Parcel.obtain();
-    drmInitDataToParcel.writeToParcel(parcel, 0);
-    parcel.setDataPosition(0);
-
-    DrmInitData drmInitDataFromParcel = DrmInitData.CREATOR.createFromParcel(parcel);
-    assertEquals(drmInitDataToParcel, drmInitDataFromParcel);
-
-    parcel.recycle();
-  }
-
-  public void testEquals() {
-    DrmInitData drmInitData = new DrmInitData(DATA_1, DATA_2);
-
-    // Basic non-referential equality test.
-    DrmInitData testInitData = new DrmInitData(DATA_1, DATA_2);
-    assertEquals(drmInitData, testInitData);
-    assertEquals(drmInitData.hashCode(), testInitData.hashCode());
-
-    // Basic non-referential equality test with non-referential scheme data.
-    testInitData = new DrmInitData(DATA_1B, DATA_2B);
-    assertEquals(drmInitData, testInitData);
-    assertEquals(drmInitData.hashCode(), testInitData.hashCode());
-
-    // Passing the scheme data in reverse order shouldn't affect equality.
-    testInitData = new DrmInitData(DATA_2, DATA_1);
-    assertEquals(drmInitData, testInitData);
-    assertEquals(drmInitData.hashCode(), testInitData.hashCode());
-
-    // Ditto.
-    testInitData = new DrmInitData(DATA_2B, DATA_1B);
-    assertEquals(drmInitData, testInitData);
-    assertEquals(drmInitData.hashCode(), testInitData.hashCode());
-
-    // Different number of tuples should affect equality.
-    testInitData = new DrmInitData(DATA_1);
-    MoreAsserts.assertNotEqual(drmInitData, testInitData);
-
-    // Different data in one of the tuples should affect equality.
-    testInitData = new DrmInitData(DATA_1, DATA_UNIVERSAL);
-    MoreAsserts.assertNotEqual(drmInitData, testInitData);
-  }
-
-  public void testGet() {
-    // Basic matching.
-    DrmInitData testInitData = new DrmInitData(DATA_1, DATA_2);
-    assertEquals(DATA_1, testInitData.get(WIDEVINE_UUID));
-    assertEquals(DATA_2, testInitData.get(PLAYREADY_UUID));
-    assertNull(testInitData.get(C.UUID_NIL));
-
-    // Basic matching including universal data.
-    testInitData = new DrmInitData(DATA_1, DATA_2, DATA_UNIVERSAL);
-    assertEquals(DATA_1, testInitData.get(WIDEVINE_UUID));
-    assertEquals(DATA_2, testInitData.get(PLAYREADY_UUID));
-    assertEquals(DATA_UNIVERSAL, testInitData.get(C.UUID_NIL));
-
-    // Passing the scheme data in reverse order shouldn't affect equality.
-    testInitData = new DrmInitData(DATA_UNIVERSAL, DATA_2, DATA_1);
-    assertEquals(DATA_1, testInitData.get(WIDEVINE_UUID));
-    assertEquals(DATA_2, testInitData.get(PLAYREADY_UUID));
-    assertEquals(DATA_UNIVERSAL, testInitData.get(C.UUID_NIL));
-
-    // Universal data should be returned in the absence of a specific match.
-    testInitData = new DrmInitData(DATA_1, DATA_UNIVERSAL);
-    assertEquals(DATA_1, testInitData.get(WIDEVINE_UUID));
-    assertEquals(DATA_UNIVERSAL, testInitData.get(PLAYREADY_UUID));
-    assertEquals(DATA_UNIVERSAL, testInitData.get(C.UUID_NIL));
-  }
-
-  public void testDuplicateSchemeDataRejected() {
-    try {
-      new DrmInitData(DATA_1, DATA_1);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // Expected.
-    }
-
-    try {
-      new DrmInitData(DATA_1, DATA_1B);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // Expected.
-    }
-
-    try {
-      new DrmInitData(DATA_1, DATA_2, DATA_1B);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // Expected.
-    }
-  }
-
-  public void testSchemeDataMatches() {
-    assertTrue(DATA_1.matches(WIDEVINE_UUID));
-    assertFalse(DATA_1.matches(PLAYREADY_UUID));
-    assertFalse(DATA_2.matches(C.UUID_NIL));
-
-    assertFalse(DATA_2.matches(WIDEVINE_UUID));
-    assertTrue(DATA_2.matches(PLAYREADY_UUID));
-    assertFalse(DATA_2.matches(C.UUID_NIL));
-
-    assertTrue(DATA_UNIVERSAL.matches(WIDEVINE_UUID));
-    assertTrue(DATA_UNIVERSAL.matches(PLAYREADY_UUID));
-    assertTrue(DATA_UNIVERSAL.matches(C.UUID_NIL));
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
index 9f5b067b5e..22ae57932b 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.android.exoplayer2.drm;
 
 import static org.mockito.Matchers.any;
@@ -24,10 +23,9 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.upstream.HttpDataSource;
 import java.util.HashMap;
 import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 
 /**
  * Tests {@link OfflineLicenseHelper}.
@@ -35,15 +33,15 @@
 public class OfflineLicenseHelperTest extends InstrumentationTestCase {
 
   private OfflineLicenseHelper<?> offlineLicenseHelper;
-  @Mock private HttpDataSource httpDataSource;
   @Mock private MediaDrmCallback mediaDrmCallback;
   @Mock private ExoMediaDrm<ExoMediaCrypto> mediaDrm;
 
   @Override
   protected void setUp() throws Exception {
-    TestUtil.setUpMockito(this);
+    setUpMockito(this);
     when(mediaDrm.openSession()).thenReturn(new byte[] {1, 2, 3});
-    offlineLicenseHelper = new OfflineLicenseHelper<>(mediaDrm, mediaDrmCallback, null);
+    offlineLicenseHelper = new OfflineLicenseHelper<>(C.WIDEVINE_UUID, mediaDrm, mediaDrmCallback,
+        null);
   }
 
   @Override
@@ -154,8 +152,18 @@ private void setStubLicenseAndPlaybackDurationValues(long licenseDuration,
   }
 
   private static DrmInitData newDrmInitData() {
-    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "cenc", "mimeType",
+    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
         new byte[] {1, 4, 7, 0, 3, 6}));
   }
 
+  /**
+   * Sets up Mockito for an instrumentation test.
+   */
+  private static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
+    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
+    System.setProperty("dexmaker.dexcache",
+        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
+    MockitoAnnotations.initMocks(instrumentationTestCase);
+  }
+
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
index 3be23422cc..b1ebdf3261 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
 
@@ -56,7 +57,7 @@ public void testVorbis() throws Exception {
 
   public void testSniffVorbis() throws Exception {
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 1),
+        OggTestData.buildOggHeader(0x02, 0, 1000, 1),
         TestUtil.createByteArray(7),  // Laces
         new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
     assertTrue(sniff(data));
@@ -64,7 +65,7 @@ public void testSniffVorbis() throws Exception {
 
   public void testSniffFlac() throws Exception {
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 1),
+        OggTestData.buildOggHeader(0x02, 0, 1000, 1),
         TestUtil.createByteArray(5),  // Laces
         new byte[] {0x7F, 'F', 'L', 'A', 'C'});
     assertTrue(sniff(data));
@@ -72,26 +73,26 @@ public void testSniffFlac() throws Exception {
 
   public void testSniffFailsOpusFile() throws Exception {
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 0x00),
+        OggTestData.buildOggHeader(0x02, 0, 1000, 0x00),
         new byte[] {'O', 'p', 'u', 's'});
     assertFalse(sniff(data));
   }
 
   public void testSniffFailsInvalidOggHeader() throws Exception {
-    byte[] data = TestData.buildOggHeader(0x00, 0, 1000, 0x00);
+    byte[] data = OggTestData.buildOggHeader(0x00, 0, 1000, 0x00);
     assertFalse(sniff(data));
   }
 
   public void testSniffInvalidHeader() throws Exception {
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 1),
+        OggTestData.buildOggHeader(0x02, 0, 1000, 1),
         TestUtil.createByteArray(7),  // Laces
         new byte[] {0x7F, 'X', 'o', 'r', 'b', 'i', 's'});
     assertFalse(sniff(data));
   }
 
   public void testSniffFailsEOF() throws Exception {
-    byte[] data = TestData.buildOggHeader(0x02, 0, 1000, 0x00);
+    byte[] data = OggTestData.buildOggHeader(0x02, 0, 1000, 0x00);
     assertFalse(sniff(data));
   }
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
index 991d31ff03..186b842bab 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
@@ -18,6 +18,7 @@
 import android.test.InstrumentationTestCase;
 import android.test.MoreAsserts;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
@@ -47,20 +48,20 @@ public void testReadPacketsWithEmptyPage() throws Exception {
     byte[] thirdPacket = TestUtil.buildTestData(256, random);
     byte[] fourthPacket = TestUtil.buildTestData(271, random);
 
-    FakeExtractorInput input = TestData.createInput(
+    FakeExtractorInput input = OggTestData.createInput(
         TestUtil.joinByteArrays(
             // First page with a single packet.
-            TestData.buildOggHeader(0x02,  0, 1000, 0x01),
+            OggTestData.buildOggHeader(0x02,  0, 1000, 0x01),
             TestUtil.createByteArray(0x08), // Laces
             firstPacket,
             // Second page with a single packet.
-            TestData.buildOggHeader(0x00,  16, 1001, 0x02),
+            OggTestData.buildOggHeader(0x00,  16, 1001, 0x02),
             TestUtil.createByteArray(0xFF, 0x11), // Laces
             secondPacket,
             // Third page with zero packets.
-            TestData.buildOggHeader(0x00,  16, 1002, 0x00),
+            OggTestData.buildOggHeader(0x00,  16, 1002, 0x00),
             // Fourth page with two packets.
-            TestData.buildOggHeader(0x04,  128, 1003, 0x04),
+            OggTestData.buildOggHeader(0x04,  128, 1003, 0x04),
             TestUtil.createByteArray(0xFF, 0x01, 0xFF, 0x10), // Laces
             thirdPacket,
             fourthPacket), true);
@@ -107,9 +108,9 @@ public void testReadPacketWithZeroSizeTerminator() throws Exception {
     byte[] firstPacket = TestUtil.buildTestData(255, random);
     byte[] secondPacket = TestUtil.buildTestData(8, random);
 
-    FakeExtractorInput input = TestData.createInput(
+    FakeExtractorInput input = OggTestData.createInput(
         TestUtil.joinByteArrays(
-            TestData.buildOggHeader(0x06, 0, 1000, 0x04),
+            OggTestData.buildOggHeader(0x06, 0, 1000, 0x04),
             TestUtil.createByteArray(0xFF, 0x00, 0x00, 0x08), // Laces.
             firstPacket,
             secondPacket), true);
@@ -122,14 +123,14 @@ public void testReadPacketWithZeroSizeTerminator() throws Exception {
   public void testReadContinuedPacketOverTwoPages() throws Exception {
     byte[] firstPacket = TestUtil.buildTestData(518);
 
-    FakeExtractorInput input = TestData.createInput(
+    FakeExtractorInput input = OggTestData.createInput(
         TestUtil.joinByteArrays(
             // First page.
-            TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+            OggTestData.buildOggHeader(0x02, 0, 1000, 0x02),
             TestUtil.createByteArray(0xFF, 0xFF), // Laces.
             Arrays.copyOf(firstPacket, 510),
             // Second page (continued packet).
-            TestData.buildOggHeader(0x05, 10, 1001, 0x01),
+            OggTestData.buildOggHeader(0x05, 10, 1001, 0x01),
             TestUtil.createByteArray(0x08), // Laces.
             Arrays.copyOfRange(firstPacket, 510, 510 + 8)), true);
 
@@ -144,22 +145,22 @@ public void testReadContinuedPacketOverTwoPages() throws Exception {
   public void testReadContinuedPacketOverFourPages() throws Exception {
     byte[] firstPacket = TestUtil.buildTestData(1028);
 
-    FakeExtractorInput input = TestData.createInput(
+    FakeExtractorInput input = OggTestData.createInput(
         TestUtil.joinByteArrays(
             // First page.
-            TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+            OggTestData.buildOggHeader(0x02, 0, 1000, 0x02),
             TestUtil.createByteArray(0xFF, 0xFF), // Laces.
             Arrays.copyOf(firstPacket, 510),
             // Second page (continued packet).
-            TestData.buildOggHeader(0x01, 10, 1001, 0x01),
+            OggTestData.buildOggHeader(0x01, 10, 1001, 0x01),
             TestUtil.createByteArray(0xFF), // Laces.
             Arrays.copyOfRange(firstPacket, 510, 510 + 255),
             // Third page (continued packet).
-            TestData.buildOggHeader(0x01, 10, 1002, 0x01),
+            OggTestData.buildOggHeader(0x01, 10, 1002, 0x01),
             TestUtil.createByteArray(0xFF), // Laces.
             Arrays.copyOfRange(firstPacket, 510 + 255, 510 + 255 + 255),
             // Fourth page (continued packet).
-            TestData.buildOggHeader(0x05, 10, 1003, 0x01),
+            OggTestData.buildOggHeader(0x05, 10, 1003, 0x01),
             TestUtil.createByteArray(0x08), // Laces.
             Arrays.copyOfRange(firstPacket, 510 + 255 + 255, 510 + 255 + 255 + 8)), true);
 
@@ -174,10 +175,10 @@ public void testReadContinuedPacketOverFourPages() throws Exception {
   public void testReadDiscardContinuedPacketAtStart() throws Exception {
     byte[] pageBody = TestUtil.buildTestData(256 + 8);
 
-    FakeExtractorInput input = TestData.createInput(
+    FakeExtractorInput input = OggTestData.createInput(
         TestUtil.joinByteArrays(
             // Page with a continued packet at start.
-            TestData.buildOggHeader(0x01, 10, 1001, 0x03),
+            OggTestData.buildOggHeader(0x01, 10, 1001, 0x03),
             TestUtil.createByteArray(255, 1, 8), // Laces.
             pageBody), true);
 
@@ -191,15 +192,15 @@ public void testReadZeroSizedPacketsAtEndOfStream() throws Exception {
     byte[] secondPacket = TestUtil.buildTestData(8, random);
     byte[] thirdPacket = TestUtil.buildTestData(8, random);
 
-    FakeExtractorInput input = TestData.createInput(
+    FakeExtractorInput input = OggTestData.createInput(
         TestUtil.joinByteArrays(
-            TestData.buildOggHeader(0x02, 0, 1000, 0x01),
+            OggTestData.buildOggHeader(0x02, 0, 1000, 0x01),
             TestUtil.createByteArray(0x08), // Laces.
             firstPacket,
-            TestData.buildOggHeader(0x04, 0, 1001, 0x03),
+            OggTestData.buildOggHeader(0x04, 0, 1001, 0x03),
             TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
             secondPacket,
-            TestData.buildOggHeader(0x04, 0, 1002, 0x03),
+            OggTestData.buildOggHeader(0x04, 0, 1002, 0x03),
             TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
             thirdPacket), true);
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
index d5d187ee7c..6d839a8355 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.util.ArrayList;
 import java.util.Random;
@@ -68,7 +69,7 @@ public static OggTestFile generate(Random random, int pageCount) {
       }
       granule += random.nextInt(MAX_GRANULES_IN_PAGE - 1) + 1;
       int pageSegmentCount = random.nextInt(MAX_SEGMENT_COUNT);
-      byte[] header = TestData.buildOggHeader(headerType, granule, 0, pageSegmentCount);
+      byte[] header = OggTestData.buildOggHeader(headerType, granule, 0, pageSegmentCount);
       fileData.add(header);
       fileSize += header.length;
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
deleted file mode 100644
index a24cb1599b..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.extractor.ogg;
-
-import com.google.android.exoplayer2.testutil.TestUtil;
-import junit.framework.TestCase;
-
-/**
- * Unit test for {@link VorbisBitArray}.
- */
-public final class VorbisBitArrayTest extends TestCase {
-
-  public void testReadBit() {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x5c, 0x50));
-    assertFalse(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-  }
-
-  public void testSkipBits() {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));
-    bitArray.skipBits(10);
-    assertEquals(10, bitArray.getPosition());
-    assertTrue(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-    bitArray.skipBits(1);
-    assertEquals(14, bitArray.getPosition());
-    assertFalse(bitArray.readBit());
-    assertFalse(bitArray.readBit());
-  }
-
-  public void testGetPosition() throws Exception {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));
-    assertEquals(0, bitArray.getPosition());
-    bitArray.readBit();
-    assertEquals(1, bitArray.getPosition());
-    bitArray.readBit();
-    bitArray.readBit();
-    bitArray.skipBits(4);
-    assertEquals(7, bitArray.getPosition());
-  }
-
-  public void testSetPosition() throws Exception {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));
-    assertEquals(0, bitArray.getPosition());
-    bitArray.setPosition(4);
-    assertEquals(4, bitArray.getPosition());
-    bitArray.setPosition(15);
-    assertFalse(bitArray.readBit());
-  }
-
-  public void testReadInt32() {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F, 0xF0, 0x0F));
-    assertEquals(0x0FF00FF0, bitArray.readBits(32));
-    bitArray = new VorbisBitArray(TestUtil.createByteArray(0x0F, 0xF0, 0x0F, 0xF0));
-    assertEquals(0xF00FF00F, bitArray.readBits(32));
-  }
-
-  public void testReadBits() throws Exception {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x03, 0x22));
-    assertEquals(3, bitArray.readBits(2));
-    bitArray.skipBits(6);
-    assertEquals(2, bitArray.readBits(2));
-    bitArray.skipBits(2);
-    assertEquals(2, bitArray.readBits(2));
-    bitArray.reset();
-    assertEquals(0x2203, bitArray.readBits(16));
-  }
-
-  public void testRead4BitsBeyondBoundary() throws Exception {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x2e, 0x10));
-    assertEquals(0x2e, bitArray.readBits(7));
-    assertEquals(7, bitArray.getPosition());
-    assertEquals(0x0, bitArray.readBits(4));
-  }
-
-  public void testReadBitsBeyondByteBoundaries() throws Exception {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xFF, 0x0F, 0xFF, 0x0F));
-    assertEquals(0x0FFF0FFF, bitArray.readBits(32));
-
-    bitArray.reset();
-    bitArray.skipBits(4);
-    assertEquals(0xF0FF, bitArray.readBits(16));
-
-    bitArray.reset();
-    bitArray.skipBits(6);
-    assertEquals(0xc3F, bitArray.readBits(12));
-
-    bitArray.reset();
-    bitArray.skipBits(6);
-    assertTrue(bitArray.readBit());
-    assertTrue(bitArray.readBit());
-    assertEquals(24, bitArray.bitsLeft());
-
-    bitArray.reset();
-    bitArray.skipBits(10);
-    assertEquals(3, bitArray.readBits(5));
-    assertEquals(15, bitArray.getPosition());
-  }
-
-  public void testReadBitsIllegalLengths() throws Exception {
-    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x03, 0x22, 0x30));
-
-    // reading zero bits gets 0 without advancing position
-    // (like a zero-bit read is defined to yield zer0)
-    assertEquals(0, bitArray.readBits(0));
-    assertEquals(0, bitArray.getPosition());
-    bitArray.readBit();
-    assertEquals(1, bitArray.getPosition());
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
deleted file mode 100644
index c3165b34f6..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.extractor.ogg;
-
-import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.ogg.VorbisReader.VorbisSetup;
-import com.google.android.exoplayer2.testutil.FakeExtractorInput;
-import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
-import com.google.android.exoplayer2.util.ParsableByteArray;
-import java.io.IOException;
-import junit.framework.TestCase;
-
-/**
- * Unit test for {@link VorbisReader}.
- */
-public final class VorbisReaderTest extends TestCase {
-
-  public void testReadBits() throws Exception {
-    assertEquals(0, VorbisReader.readBits((byte) 0x00, 2, 2));
-    assertEquals(1, VorbisReader.readBits((byte) 0x02, 1, 1));
-    assertEquals(15, VorbisReader.readBits((byte) 0xF0, 4, 4));
-    assertEquals(1, VorbisReader.readBits((byte) 0x80, 1, 7));
-  }
-
-  public void testAppendNumberOfSamples() throws Exception {
-    ParsableByteArray buffer = new ParsableByteArray(4);
-    buffer.setLimit(0);
-    VorbisReader.appendNumberOfSamples(buffer, 0x01234567);
-    assertEquals(4, buffer.limit());
-    assertEquals(0x67, buffer.data[0]);
-    assertEquals(0x45, buffer.data[1]);
-    assertEquals(0x23, buffer.data[2]);
-    assertEquals(0x01, buffer.data[3]);
-  }
-
-  public void testReadSetupHeadersWithIOExceptions() throws IOException, InterruptedException {
-    byte[] data = TestData.getVorbisHeaderPages();
-    ExtractorInput input = new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
-        .setSimulateUnknownLength(true).setSimulatePartialReads(true).build();
-
-    VorbisReader reader = new VorbisReader();
-    VorbisReader.VorbisSetup vorbisSetup = readSetupHeaders(reader, input);
-
-    assertNotNull(vorbisSetup.idHeader);
-    assertNotNull(vorbisSetup.commentHeader);
-    assertNotNull(vorbisSetup.setupHeaderData);
-    assertNotNull(vorbisSetup.modes);
-
-    assertEquals(45, vorbisSetup.commentHeader.length);
-    assertEquals(30, vorbisSetup.idHeader.data.length);
-    assertEquals(3597, vorbisSetup.setupHeaderData.length);
-
-    assertEquals(-1, vorbisSetup.idHeader.bitrateMax);
-    assertEquals(-1, vorbisSetup.idHeader.bitrateMin);
-    assertEquals(66666, vorbisSetup.idHeader.bitrateNominal);
-    assertEquals(512, vorbisSetup.idHeader.blockSize0);
-    assertEquals(1024, vorbisSetup.idHeader.blockSize1);
-    assertEquals(2, vorbisSetup.idHeader.channels);
-    assertTrue(vorbisSetup.idHeader.framingFlag);
-    assertEquals(22050, vorbisSetup.idHeader.sampleRate);
-    assertEquals(0, vorbisSetup.idHeader.version);
-
-    assertEquals("Xiph.Org libVorbis I 20030909", vorbisSetup.commentHeader.vendor);
-    assertEquals(1, vorbisSetup.iLogModes);
-
-    assertEquals(data[data.length - 1],
-        vorbisSetup.setupHeaderData[vorbisSetup.setupHeaderData.length - 1]);
-
-    assertFalse(vorbisSetup.modes[0].blockFlag);
-    assertTrue(vorbisSetup.modes[1].blockFlag);
-  }
-
-  private static VorbisSetup readSetupHeaders(VorbisReader reader, ExtractorInput input)
-      throws IOException, InterruptedException {
-    OggPacket oggPacket = new OggPacket();
-    while (true) {
-      try {
-        if (!oggPacket.populate(input)) {
-          fail();
-        }
-        VorbisSetup vorbisSetup = reader.readSetupHeaders(oggPacket.getPayload());
-        if (vorbisSetup != null) {
-          return vorbisSetup;
-        }
-      } catch (SimulatedIOException e) {
-        // Ignore.
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
deleted file mode 100644
index ddbfee8446..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.extractor.ogg;
-
-import com.google.android.exoplayer2.ParserException;
-import com.google.android.exoplayer2.util.ParsableByteArray;
-import junit.framework.TestCase;
-
-/**
- * Unit test for {@link VorbisUtil}.
- */
-public final class VorbisUtilTest extends TestCase {
-
-  public void testILog() throws Exception {
-    assertEquals(0, VorbisUtil.iLog(0));
-    assertEquals(1, VorbisUtil.iLog(1));
-    assertEquals(2, VorbisUtil.iLog(2));
-    assertEquals(2, VorbisUtil.iLog(3));
-    assertEquals(3, VorbisUtil.iLog(4));
-    assertEquals(3, VorbisUtil.iLog(5));
-    assertEquals(4, VorbisUtil.iLog(8));
-    assertEquals(0, VorbisUtil.iLog(-1));
-    assertEquals(0, VorbisUtil.iLog(-122));
-  }
-
-  public void testReadIdHeader() throws Exception {
-    byte[] data = TestData.getIdentificationHeaderData();
-    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
-    VorbisUtil.VorbisIdHeader vorbisIdHeader =
-        VorbisUtil.readVorbisIdentificationHeader(headerData);
-
-    assertEquals(22050, vorbisIdHeader.sampleRate);
-    assertEquals(0, vorbisIdHeader.version);
-    assertTrue(vorbisIdHeader.framingFlag);
-    assertEquals(2, vorbisIdHeader.channels);
-    assertEquals(512, vorbisIdHeader.blockSize0);
-    assertEquals(1024, vorbisIdHeader.blockSize1);
-    assertEquals(-1, vorbisIdHeader.bitrateMax);
-    assertEquals(-1, vorbisIdHeader.bitrateMin);
-    assertEquals(66666, vorbisIdHeader.bitrateNominal);
-    assertEquals(66666, vorbisIdHeader.getApproximateBitrate());
-  }
-
-  public void testReadCommentHeader() throws ParserException {
-    byte[] data = TestData.getCommentHeaderDataUTF8();
-    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
-    VorbisUtil.CommentHeader commentHeader = VorbisUtil.readVorbisCommentHeader(headerData);
-
-    assertEquals("Xiph.Org libVorbis I 20120203 (Omnipresent)", commentHeader.vendor);
-    assertEquals(3, commentHeader.comments.length);
-    assertEquals("ALBUM=äö", commentHeader.comments[0]);
-    assertEquals("TITLE=A sample song", commentHeader.comments[1]);
-    assertEquals("ARTIST=Google", commentHeader.comments[2]);
-  }
-
-  public void testReadVorbisModes() throws ParserException {
-    byte[] data = TestData.getSetupHeaderData();
-    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
-    VorbisUtil.Mode[] modes = VorbisUtil.readVorbisModes(headerData, 2);
-
-    assertEquals(2, modes.length);
-    assertEquals(false, modes[0].blockFlag);
-    assertEquals(0, modes[0].mapping);
-    assertEquals(0, modes[0].transformType);
-    assertEquals(0, modes[0].windowType);
-    assertEquals(true, modes[1].blockFlag);
-    assertEquals(1, modes[1].mapping);
-    assertEquals(0, modes[1].transformType);
-    assertEquals(0, modes[1].windowType);
-  }
-
-  public void testVerifyVorbisHeaderCapturePattern() throws ParserException {
-    ParsableByteArray header = new ParsableByteArray(
-        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
-    assertEquals(true, VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, false));
-  }
-
-  public void testVerifyVorbisHeaderCapturePatternInvalidHeader() {
-    ParsableByteArray header = new ParsableByteArray(
-        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
-    try {
-      VorbisUtil.verifyVorbisHeaderCapturePattern(0x99, header, false);
-      fail();
-    } catch (ParserException e) {
-      assertEquals("expected header type 99", e.getMessage());
-    }
-  }
-
-  public void testVerifyVorbisHeaderCapturePatternInvalidHeaderQuite() throws ParserException {
-    ParsableByteArray header = new ParsableByteArray(
-        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
-    assertFalse(VorbisUtil.verifyVorbisHeaderCapturePattern(0x99, header, true));
-  }
-
-  public void testVerifyVorbisHeaderCapturePatternInvalidPattern() {
-    ParsableByteArray header = new ParsableByteArray(
-        new byte[] {0x01, 'x', 'v', 'o', 'r', 'b', 'i', 's'});
-    try {
-      VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, false);
-      fail();
-    } catch (ParserException e) {
-      assertEquals("expected characters 'vorbis'", e.getMessage());
-    }
-  }
-
-  public void testVerifyVorbisHeaderCapturePatternQuiteInvalidPatternQuite()
-      throws ParserException {
-    ParsableByteArray header = new ParsableByteArray(
-        new byte[] {0x01, 'x', 'v', 'o', 'r', 'b', 'i', 's'});
-    assertFalse(VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, true));
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index bcfa90a565..6a31250e15 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
@@ -154,20 +155,20 @@ public void testMultiPacketConsumed() throws Exception {
     }
   }
 
-  public void testAdtsDataOnly() throws Exception {
+  public void testAdtsDataOnly() throws ParserException {
     data.setPosition(ID3_DATA_1.length + ID3_DATA_2.length);
     feed();
     assertSampleCounts(0, 1);
     adtsOutput.assertSample(0, ADTS_CONTENT, 0, C.BUFFER_FLAG_KEY_FRAME, null);
   }
 
-  private void feedLimited(int limit) {
+  private void feedLimited(int limit) throws ParserException {
     maybeStartPacket();
     data.setLimit(limit);
     feed();
   }
 
-  private void feed() {
+  private void feed() throws ParserException {
     maybeStartPacket();
     adtsReader.consume(data);
   }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
index 66b0337450..5e615dbc7f 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -109,13 +109,14 @@ public void testWindowAndPeriodIndices() {
         TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
     TimelineAsserts.assertWindowIds(clippedTimeline, 111);
     TimelineAsserts.assertPeriodCounts(clippedTimeline, 1);
-    TimelineAsserts.assertPreviousWindowIndices(
-        clippedTimeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, 0);
-    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, 0);
+    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, false, 0);
+    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, false, 0);
   }
 
   /**
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
index 3bf89f9bcc..6f6556225e 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
@@ -18,7 +18,9 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -30,26 +32,47 @@
  */
 public final class ConcatenatingMediaSourceTest extends TestCase {
 
+  public void testEmptyConcatenation() {
+    for (boolean atomic : new boolean[] {false, true}) {
+      Timeline timeline = getConcatenatedTimeline(atomic);
+      TimelineAsserts.assertEmpty(timeline);
+
+      timeline = getConcatenatedTimeline(atomic, Timeline.EMPTY);
+      TimelineAsserts.assertEmpty(timeline);
+
+      timeline = getConcatenatedTimeline(atomic, Timeline.EMPTY, Timeline.EMPTY, Timeline.EMPTY);
+      TimelineAsserts.assertEmpty(timeline);
+    }
+  }
+
   public void testSingleMediaSource() {
     Timeline timeline = getConcatenatedTimeline(false, createFakeTimeline(3, 111));
     TimelineAsserts.assertWindowIds(timeline, 111);
     TimelineAsserts.assertPeriodCounts(timeline, 3);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+    }
 
     timeline = getConcatenatedTimeline(true, createFakeTimeline(3, 111));
     TimelineAsserts.assertWindowIds(timeline, 111);
     TimelineAsserts.assertPeriodCounts(timeline, 3);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 0);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+    }
   }
 
   public void testMultipleMediaSources() {
@@ -58,24 +81,44 @@ public void testMultipleMediaSources() {
     Timeline timeline = getConcatenatedTimeline(false, timelines);
     TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 3, 1, 3);
-    TimelineAsserts.assertPreviousWindowIndices(
-        timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, 1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    assertEquals(0, timeline.getFirstWindowIndex(false));
+    assertEquals(2, timeline.getLastWindowIndex(false));
+    assertEquals(2, timeline.getFirstWindowIndex(true));
+    assertEquals(0, timeline.getLastWindowIndex(true));
 
     timeline = getConcatenatedTimeline(true, timelines);
     TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 3, 1, 3);
-    TimelineAsserts.assertPreviousWindowIndices(
-        timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 2, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, 1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 1, 2, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 1, 2, 0);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          1, 2, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 1, 2, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+      assertEquals(0, timeline.getFirstWindowIndex(shuffled));
+      assertEquals(2, timeline.getLastWindowIndex(shuffled));
+    }
   }
 
   public void testNestedMediaSources() {
@@ -84,14 +127,99 @@ public void testNestedMediaSources() {
         getConcatenatedTimeline(true, createFakeTimeline(1, 333), createFakeTimeline(1, 444)));
     TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 444);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1);
-    TimelineAsserts.assertPreviousWindowIndices(
-        timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 3, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 3, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(
-        timeline, Player.REPEAT_MODE_OFF, 1, 2, 3, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 3, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 1, 2, 3, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false,
+        0, 1, 3, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false,
+        3, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        1, 2, 3, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 3, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 3, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        1, 3, C.INDEX_UNSET, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true,
+        0, 1, 3, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true,
+        1, 3, 0, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        C.INDEX_UNSET, 0, 3, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 3, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 3, 1);
+  }
+
+  public void testEmptyTimelineMediaSources() {
+    // Empty timelines in the front, back, and the middle (single and multiple in a row).
+    Timeline[] timelines = { Timeline.EMPTY, createFakeTimeline(1, 111), Timeline.EMPTY,
+        Timeline.EMPTY, createFakeTimeline(2, 222), Timeline.EMPTY, createFakeTimeline(3, 333),
+        Timeline.EMPTY };
+    Timeline timeline = getConcatenatedTimeline(false, timelines);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    assertEquals(0, timeline.getFirstWindowIndex(false));
+    assertEquals(2, timeline.getLastWindowIndex(false));
+    assertEquals(2, timeline.getFirstWindowIndex(true));
+    assertEquals(0, timeline.getLastWindowIndex(true));
+
+    timeline = getConcatenatedTimeline(true, timelines);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          1, 2, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 1, 2, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+      assertEquals(0, timeline.getFirstWindowIndex(shuffled));
+      assertEquals(2, timeline.getLastWindowIndex(shuffled));
+    }
+  }
+
+  public void testPeriodCreationWithAds() throws InterruptedException {
+    // Create media source with ad child source.
+    Timeline timelineContentOnly = new FakeTimeline(
+        new TimelineWindowDefinition(2, 111, true, false, 10 * C.MICROS_PER_SECOND));
+    Timeline timelineWithAds = new FakeTimeline(
+        new TimelineWindowDefinition(2, 222, true, false, 10 * C.MICROS_PER_SECOND, 1, 1));
+    FakeMediaSource mediaSourceContentOnly = new FakeMediaSource(timelineContentOnly, null);
+    FakeMediaSource mediaSourceWithAds = new FakeMediaSource(timelineWithAds, null);
+    ConcatenatingMediaSource mediaSource = new ConcatenatingMediaSource(mediaSourceContentOnly,
+        mediaSourceWithAds);
+
+    // Prepare and assert timeline contains ad groups.
+    Timeline timeline = TestUtil.extractTimelineFromMediaSource(mediaSource);
+    TimelineAsserts.assertAdGroupCounts(timeline, 0, 0, 1, 1);
+
+    // Create all periods and assert period creation of child media sources has been called.
+    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline, 10_000);
+    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(0));
+    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(1));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0, 0, 0));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1, 0, 0));
   }
 
   /**
@@ -104,8 +232,9 @@ private static Timeline getConcatenatedTimeline(boolean isRepeatOneAtomic,
     for (int i = 0; i < timelines.length; i++) {
       mediaSources[i] = new FakeMediaSource(timelines[i], null);
     }
-    return TestUtil.extractTimelineFromMediaSource(
-        new ConcatenatingMediaSource(isRepeatOneAtomic, mediaSources));
+    ConcatenatingMediaSource mediaSource = new ConcatenatingMediaSource(isRepeatOneAtomic,
+        new FakeShuffleOrder(mediaSources.length), mediaSources);
+    return TestUtil.extractTimelineFromMediaSource(mediaSource);
   }
 
   private static FakeTimeline createFakeTimeline(int periodCount, int windowId) {
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
index f8636b9990..e506d0a4b3 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
@@ -15,6 +15,11 @@
  */
 package com.google.android.exoplayer2.source;
 
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
@@ -25,8 +30,12 @@
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.source.MediaSource.Listener;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.testutil.FakeMediaPeriod;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
 import com.google.android.exoplayer2.testutil.TimelineAsserts;
@@ -35,6 +44,7 @@
 import java.io.IOException;
 import java.util.Arrays;
 import junit.framework.TestCase;
+import org.mockito.Mockito;
 
 /**
  * Unit tests for {@link DynamicConcatenatingMediaSource}
@@ -45,19 +55,21 @@
 
   private Timeline timeline;
   private boolean timelineUpdated;
+  private boolean customRunnableCalled;
 
   public void testPlaylistChangesAfterPreparation() throws InterruptedException {
     timeline = null;
     FakeMediaSource[] childSources = createMediaSources(7);
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource(
+        new FakeShuffleOrder(0));
     prepareAndListenToTimelineUpdates(mediaSource);
+    assertNotNull(timeline);
     waitForTimelineUpdate();
     TimelineAsserts.assertEmpty(timeline);
 
     // Add first source.
     mediaSource.addMediaSource(childSources[0]);
     waitForTimelineUpdate();
-    assertNotNull(timeline);
     TimelineAsserts.assertPeriodCounts(timeline, 1);
     TimelineAsserts.assertWindowIds(timeline, 111);
 
@@ -120,13 +132,30 @@ public void testPlaylistChangesAfterPreparation() throws InterruptedException {
     }
 
     // Assert correct next and previous indices behavior after some insertions and removals.
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, 1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 1, 2, 0);
-    TimelineAsserts.assertPreviousWindowIndices(
-        timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    assertEquals(0, timeline.getFirstWindowIndex(false));
+    assertEquals(timeline.getWindowCount() - 1, timeline.getLastWindowIndex(false));
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    assertEquals(timeline.getWindowCount() - 1, timeline.getFirstWindowIndex(true));
+    assertEquals(0, timeline.getLastWindowIndex(true));
+
+    // Assert all periods can be prepared.
+    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
+        TIMEOUT_MS);
 
     // Remove at front of queue.
     mediaSource.removeMediaSource(0);
@@ -152,7 +181,8 @@ public void testPlaylistChangesAfterPreparation() throws InterruptedException {
   public void testPlaylistChangesBeforePreparation() throws InterruptedException {
     timeline = null;
     FakeMediaSource[] childSources = createMediaSources(4);
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource(
+        new FakeShuffleOrder(0));
     mediaSource.addMediaSource(childSources[0]);
     mediaSource.addMediaSource(childSources[1]);
     mediaSource.addMediaSource(0, childSources[2]);
@@ -167,7 +197,17 @@ public void testPlaylistChangesBeforePreparation() throws InterruptedException {
     assertNotNull(timeline);
     TimelineAsserts.assertPeriodCounts(timeline, 3, 4, 2);
     TimelineAsserts.assertWindowIds(timeline, 333, 444, 222);
-
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        1, 2, C.INDEX_UNSET);
+
+    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
+        TIMEOUT_MS);
     mediaSource.releaseSource();
     for (int i = 1; i < 4; i++) {
       childSources[i].assertReleased();
@@ -201,8 +241,10 @@ public void testPlaylistWithLazyMediaSource() throws InterruptedException {
     TimelineAsserts.assertPeriodCounts(timeline, 1, 9);
     TimelineAsserts.assertWindowIds(timeline, 111, 999);
     TimelineAsserts.assertWindowIsDynamic(timeline, false, false);
+    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
+        TIMEOUT_MS);
 
-    //Add lazy sources after preparation
+    //Add lazy sources after preparation (and also try to prepare media period from lazy source).
     mediaSource.addMediaSource(1, lazySources[2]);
     waitForTimelineUpdate();
     mediaSource.addMediaSource(2, childSources[1]);
@@ -215,17 +257,91 @@ public void testPlaylistWithLazyMediaSource() throws InterruptedException {
     TimelineAsserts.assertWindowIds(timeline, null, 111, 222, 999);
     TimelineAsserts.assertWindowIsDynamic(timeline, true, false, false, false);
 
+    MediaPeriod lazyPeriod = mediaSource.createPeriod(new MediaPeriodId(0), null);
+    assertNotNull(lazyPeriod);
+    final ConditionVariable lazyPeriodPrepared = new ConditionVariable();
+    lazyPeriod.prepare(new Callback() {
+      @Override
+      public void onPrepared(MediaPeriod mediaPeriod) {
+        lazyPeriodPrepared.open();
+      }
+      @Override
+      public void onContinueLoadingRequested(MediaPeriod source) {}
+    }, 0);
+    assertFalse(lazyPeriodPrepared.block(1));
+    MediaPeriod secondLazyPeriod = mediaSource.createPeriod(new MediaPeriodId(0), null);
+    assertNotNull(secondLazyPeriod);
+    mediaSource.releasePeriod(secondLazyPeriod);
+
     lazySources[3].triggerTimelineUpdate(createFakeTimeline(7));
     waitForTimelineUpdate();
     TimelineAsserts.assertPeriodCounts(timeline, 8, 1, 2, 9);
     TimelineAsserts.assertWindowIds(timeline, 888, 111, 222, 999);
     TimelineAsserts.assertWindowIsDynamic(timeline, false, false, false, false);
+    assertTrue(lazyPeriodPrepared.block(TIMEOUT_MS));
+    mediaSource.releasePeriod(lazyPeriod);
 
     mediaSource.releaseSource();
     childSources[0].assertReleased();
     childSources[1].assertReleased();
   }
 
+  public void testEmptyTimelineMediaSource() throws InterruptedException {
+    timeline = null;
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource(
+        new FakeShuffleOrder(0));
+    prepareAndListenToTimelineUpdates(mediaSource);
+    assertNotNull(timeline);
+    waitForTimelineUpdate();
+    TimelineAsserts.assertEmpty(timeline);
+
+    mediaSource.addMediaSource(new FakeMediaSource(Timeline.EMPTY, null));
+    waitForTimelineUpdate();
+    TimelineAsserts.assertEmpty(timeline);
+
+    mediaSource.addMediaSources(Arrays.asList(new MediaSource[] {
+        new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null),
+        new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null),
+        new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null)
+    }));
+    waitForTimelineUpdate();
+    TimelineAsserts.assertEmpty(timeline);
+
+    // Insert non-empty media source to leave empty sources at the start, the end, and the middle
+    // (with single and multiple empty sources in a row).
+    MediaSource[] mediaSources = createMediaSources(3);
+    mediaSource.addMediaSource(1, mediaSources[0]);
+    waitForTimelineUpdate();
+    mediaSource.addMediaSource(4, mediaSources[1]);
+    waitForTimelineUpdate();
+    mediaSource.addMediaSource(6, mediaSources[2]);
+    waitForTimelineUpdate();
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
+        C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    assertEquals(0, timeline.getFirstWindowIndex(false));
+    assertEquals(2, timeline.getLastWindowIndex(false));
+    assertEquals(2, timeline.getFirstWindowIndex(true));
+    assertEquals(0, timeline.getLastWindowIndex(true));
+    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
+        TIMEOUT_MS);
+  }
+
   public void testIllegalArguments() {
     DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
     MediaSource validSource = new FakeMediaSource(createFakeTimeline(1), null);
@@ -265,10 +381,213 @@ public void testIllegalArguments() {
     }
   }
 
+  public void testCustomCallbackBeforePreparationAddSingle() {
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSource(createFakeMediaSource(), runnable);
+    verify(runnable).run();
+  }
+
+  public void testCustomCallbackBeforePreparationAddMultiple() {
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSources(Arrays.asList(
+        new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}), runnable);
+    verify(runnable).run();
+  }
+
+  public void testCustomCallbackBeforePreparationAddSingleWithIndex() {
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), runnable);
+    verify(runnable).run();
+  }
+
+  public void testCustomCallbackBeforePreparationAddMultipleWithIndex() {
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSources(/* index */ 0, Arrays.asList(
+        new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}), runnable);
+    verify(runnable).run();
+  }
+
+  public void testCustomCallbackBeforePreparationRemove() throws InterruptedException {
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    Runnable runnable = Mockito.mock(Runnable.class);
+    mediaSource.addMediaSource(createFakeMediaSource());
+
+    mediaSource.removeMediaSource(/* index */ 0, runnable);
+    verify(runnable).run();
+  }
+
+  public void testCustomCallbackBeforePreparationMove() throws InterruptedException {
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    Runnable runnable = Mockito.mock(Runnable.class);
+    mediaSource.addMediaSources(Arrays.asList(
+        new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}));
+
+    mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, runnable);
+    verify(runnable).run();
+  }
+
+  public void testCustomCallbackAfterPreparationAddSingle() throws InterruptedException {
+    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
+        setUpDynamicMediaSourceOnHandlerThread();
+    final Runnable runnable = createCustomRunnable();
+
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.addMediaSource(createFakeMediaSource(), runnable);
+      }
+    });
+    waitForCustomRunnable();
+  }
+
+  public void testCustomCallbackAfterPreparationAddMultiple() throws InterruptedException {
+    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
+        setUpDynamicMediaSourceOnHandlerThread();
+    final Runnable runnable = createCustomRunnable();
+
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.addMediaSources(Arrays.asList(
+            new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}), runnable);
+      }
+    });
+    waitForCustomRunnable();
+  }
+
+  public void testCustomCallbackAfterPreparationAddSingleWithIndex() throws InterruptedException {
+    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
+        setUpDynamicMediaSourceOnHandlerThread();
+    final Runnable runnable = createCustomRunnable();
+
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(),
+            runnable);
+      }
+    });
+    waitForCustomRunnable();
+  }
+
+  public void testCustomCallbackAfterPreparationAddMultipleWithIndex() throws InterruptedException {
+    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
+        setUpDynamicMediaSourceOnHandlerThread();
+    final Runnable runnable = createCustomRunnable();
+
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.addMediaSources(/* index */ 0, Arrays.asList(
+            new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}), runnable);
+      }
+    });
+    waitForCustomRunnable();
+  }
+
+  public void testCustomCallbackAfterPreparationRemove() throws InterruptedException {
+    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
+        setUpDynamicMediaSourceOnHandlerThread();
+    final Runnable runnable = createCustomRunnable();
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.addMediaSource(createFakeMediaSource());
+      }
+    });
+    waitForTimelineUpdate();
+
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.removeMediaSource(/* index */ 0, runnable);
+      }
+    });
+    waitForCustomRunnable();
+  }
+
+  public void testCustomCallbackAfterPreparationMove() throws InterruptedException {
+    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
+        setUpDynamicMediaSourceOnHandlerThread();
+    final Runnable runnable = createCustomRunnable();
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.addMediaSources(Arrays.asList(
+            new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}));
+      }
+    });
+    waitForTimelineUpdate();
+
+    sourceHandlerPair.handler.post(new Runnable() {
+      @Override
+      public void run() {
+        sourceHandlerPair.mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0,
+            runnable);
+      }
+    });
+    waitForCustomRunnable();
+  }
+
+  public void testPeriodCreationWithAds() throws InterruptedException {
+    // Create dynamic media source with ad child source.
+    Timeline timelineContentOnly = new FakeTimeline(
+        new TimelineWindowDefinition(2, 111, true, false, 10 * C.MICROS_PER_SECOND));
+    Timeline timelineWithAds = new FakeTimeline(
+        new TimelineWindowDefinition(2, 222, true, false, 10 * C.MICROS_PER_SECOND, 1, 1));
+    FakeMediaSource mediaSourceContentOnly = new FakeMediaSource(timelineContentOnly, null);
+    FakeMediaSource mediaSourceWithAds = new FakeMediaSource(timelineWithAds, null);
+    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    mediaSource.addMediaSource(mediaSourceContentOnly);
+    mediaSource.addMediaSource(mediaSourceWithAds);
+    assertNull(timeline);
+
+    // Prepare and assert timeline contains ad groups.
+    prepareAndListenToTimelineUpdates(mediaSource);
+    waitForTimelineUpdate();
+    TimelineAsserts.assertAdGroupCounts(timeline, 0, 0, 1, 1);
+
+    // Create all periods and assert period creation of child media sources has been called.
+    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
+        TIMEOUT_MS);
+    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(0));
+    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(1));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0, 0, 0));
+    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1, 0, 0));
+  }
+
+  private DynamicConcatenatingMediaSourceAndHandler setUpDynamicMediaSourceOnHandlerThread()
+      throws InterruptedException {
+    HandlerThread handlerThread = new HandlerThread("TestCustomCallbackExecutionThread");
+    handlerThread.start();
+    Handler.Callback handlerCallback = Mockito.mock(Handler.Callback.class);
+    when(handlerCallback.handleMessage(any(Message.class))).thenReturn(false);
+    Handler handler = new Handler(handlerThread.getLooper(), handlerCallback);
+    final DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        prepareAndListenToTimelineUpdates(mediaSource);
+      }
+    });
+    waitForTimelineUpdate();
+    return new DynamicConcatenatingMediaSourceAndHandler(mediaSource, handler);
+  }
+
   private void prepareAndListenToTimelineUpdates(MediaSource mediaSource) {
     mediaSource.prepareSource(new StubExoPlayer(), true, new Listener() {
       @Override
-      public void onSourceInfoRefreshed(Timeline newTimeline, Object manifest) {
+      public void onSourceInfoRefreshed(MediaSource source, Timeline newTimeline, Object manifest) {
         timeline = newTimeline;
         synchronized (DynamicConcatenatingMediaSourceTest.this) {
           timelineUpdated = true;
@@ -279,16 +598,41 @@ public void onSourceInfoRefreshed(Timeline newTimeline, Object manifest) {
   }
 
   private synchronized void waitForTimelineUpdate() throws InterruptedException {
-    long timeoutMs = System.currentTimeMillis() + TIMEOUT_MS;
+    long deadlineMs = System.currentTimeMillis() + TIMEOUT_MS;
     while (!timelineUpdated) {
       wait(TIMEOUT_MS);
-      if (System.currentTimeMillis() >= timeoutMs) {
+      if (System.currentTimeMillis() >= deadlineMs) {
         fail("No timeline update occurred within timeout.");
       }
     }
     timelineUpdated = false;
   }
 
+  private Runnable createCustomRunnable() {
+    return new Runnable() {
+      @Override
+      public void run() {
+        synchronized (DynamicConcatenatingMediaSourceTest.this) {
+          assertTrue(timelineUpdated);
+          timelineUpdated = false;
+          customRunnableCalled = true;
+          DynamicConcatenatingMediaSourceTest.this.notify();
+        }
+      }
+    };
+  }
+
+  private synchronized void waitForCustomRunnable() throws InterruptedException {
+    long deadlineMs = System.currentTimeMillis() + TIMEOUT_MS;
+    while (!customRunnableCalled) {
+      wait(TIMEOUT_MS);
+      if (System.currentTimeMillis() >= deadlineMs) {
+        fail("No custom runnable call occurred within timeout.");
+      }
+    }
+    customRunnableCalled = false;
+  }
+
   private static FakeMediaSource[] createMediaSources(int count) {
     FakeMediaSource[] sources = new FakeMediaSource[count];
     for (int i = 0; i < count; i++) {
@@ -297,16 +641,33 @@ private synchronized void waitForTimelineUpdate() throws InterruptedException {
     return sources;
   }
 
+  private static FakeMediaSource createFakeMediaSource() {
+    return new FakeMediaSource(createFakeTimeline(/* index */ 0), null);
+  }
+
   private static FakeTimeline createFakeTimeline(int index) {
     return new FakeTimeline(new TimelineWindowDefinition(index + 1, (index + 1) * 111));
   }
 
+  private static class DynamicConcatenatingMediaSourceAndHandler {
+
+    public final DynamicConcatenatingMediaSource mediaSource;
+    public final Handler handler;
+
+    public DynamicConcatenatingMediaSourceAndHandler(DynamicConcatenatingMediaSource mediaSource,
+        Handler handler) {
+      this.mediaSource = mediaSource;
+      this.handler = handler;
+    }
+
+  }
+
   private static class LazyMediaSource implements MediaSource {
 
     private Listener listener;
 
     public void triggerTimelineUpdate(Timeline timeline) {
-      listener.onSourceInfoRefreshed(timeline, null);
+      listener.onSourceInfoRefreshed(this, timeline, null);
     }
 
     @Override
@@ -320,7 +681,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
     @Override
     public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-      return null;
+      return new FakeMediaPeriod(TrackGroupArray.EMPTY);
     }
 
     @Override
@@ -396,6 +757,16 @@ public int getRepeatMode() {
       throw new UnsupportedOperationException();
     }
 
+    @Override
+    public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean getShuffleModeEnabled() {
+      throw new UnsupportedOperationException();
+    }
+
     @Override
     public boolean isLoading() {
       throw new UnsupportedOperationException();
@@ -491,6 +862,16 @@ public int getCurrentWindowIndex() {
       throw new UnsupportedOperationException();
     }
 
+    @Override
+    public int getNextWindowIndex() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getPreviousWindowIndex() {
+      throw new UnsupportedOperationException();
+    }
+
     @Override
     public long getDuration() {
       throw new UnsupportedOperationException();
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
index d2045c29a5..2c8deb74b4 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
@@ -42,43 +42,66 @@ public void testSingleLoop() {
     Timeline timeline = getLoopingTimeline(multiWindowTimeline, 1);
     TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
-    TimelineAsserts.assertPreviousWindowIndices(
-        timeline, Player.REPEAT_MODE_OFF, C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, 1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 1, 2, 0);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
+          0, 1, 2);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          1, 2, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+    }
   }
 
   public void testMultiLoop() {
     Timeline timeline = getLoopingTimeline(multiWindowTimeline, 3);
     TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 111, 222, 333, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1, 1, 1, 1, 1, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF,
-        C.INDEX_UNSET, 0, 1, 2, 3, 4, 5, 6, 7, 8);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE,
-        0, 1, 2, 3, 4, 5, 6, 7, 8);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL,
-        8, 0, 1, 2, 3, 4, 5, 6, 7);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF,
-        1, 2, 3, 4, 5, 6, 7, 8, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE,
-        0, 1, 2, 3, 4, 5, 6, 7, 8);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL,
-        1, 2, 3, 4, 5, 6, 7, 8, 0);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          C.INDEX_UNSET, 0, 1, 2, 3, 4, 5, 6, 7, 8);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
+          0, 1, 2, 3, 4, 5, 6, 7, 8);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
+          8, 0, 1, 2, 3, 4, 5, 6, 7);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          1, 2, 3, 4, 5, 6, 7, 8, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
+          0, 1, 2, 3, 4, 5, 6, 7, 8);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
+          1, 2, 3, 4, 5, 6, 7, 8, 0);
+    }
   }
 
   public void testInfiniteLoop() {
     Timeline timeline = getLoopingTimeline(multiWindowTimeline, Integer.MAX_VALUE);
     TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
     TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, 2, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, 1, 2, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, 1, 2, 0);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
+          0, 1, 2);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
+          2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+    }
+  }
+
+  public void testEmptyTimelineLoop() {
+    Timeline timeline = getLoopingTimeline(Timeline.EMPTY, 1);
+    TimelineAsserts.assertEmpty(timeline);
+
+    timeline = getLoopingTimeline(Timeline.EMPTY, 3);
+    TimelineAsserts.assertEmpty(timeline);
+
+    timeline = getLoopingTimeline(Timeline.EMPTY, Integer.MAX_VALUE);
+    TimelineAsserts.assertEmpty(timeline);
   }
 
   /**
@@ -92,3 +115,4 @@ private static Timeline getLoopingTimeline(Timeline timeline, int loopCount) {
   }
 
 }
+
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
deleted file mode 100644
index 1690371a47..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.text.ttml;
-
-import android.graphics.Color;
-import android.test.InstrumentationTestCase;
-
-/**
- * Unit test for {@link TtmlStyle}.
- */
-public final class TtmlStyleTest extends InstrumentationTestCase {
-
-    private static final String FONT_FAMILY = "serif";
-    private static final String ID = "id";
-    public static final int FOREGROUND_COLOR = Color.WHITE;
-    public static final int BACKGROUND_COLOR = Color.BLACK;
-    private TtmlStyle style;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        style = new TtmlStyle();
-    }
-
-    public void testInheritStyle() {
-        style.inherit(createAncestorStyle());
-        assertNull("id must not be inherited", style.getId());
-        assertTrue(style.isUnderline());
-        assertTrue(style.isLinethrough());
-        assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
-        assertEquals(FONT_FAMILY, style.getFontFamily());
-        assertEquals(Color.WHITE, style.getFontColor());
-        assertFalse("do not inherit backgroundColor", style.hasBackgroundColor());
-    }
-
-    public void testChainStyle() {
-        style.chain(createAncestorStyle());
-        assertNull("id must not be inherited", style.getId());
-        assertTrue(style.isUnderline());
-        assertTrue(style.isLinethrough());
-        assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
-        assertEquals(FONT_FAMILY, style.getFontFamily());
-        assertEquals(FOREGROUND_COLOR, style.getFontColor());
-        // do inherit backgroundColor when chaining
-        assertEquals("do not inherit backgroundColor when chaining",
-            BACKGROUND_COLOR, style.getBackgroundColor());
-    }
-
-    private TtmlStyle createAncestorStyle() {
-        TtmlStyle ancestor = new TtmlStyle();
-        ancestor.setId(ID);
-        ancestor.setItalic(true);
-        ancestor.setBold(true);
-        ancestor.setBackgroundColor(BACKGROUND_COLOR);
-        ancestor.setFontColor(FOREGROUND_COLOR);
-        ancestor.setLinethrough(true);
-        ancestor.setUnderline(true);
-        ancestor.setFontFamily(FONT_FAMILY);
-        return ancestor;
-    }
-
-    public void testStyle() {
-        assertEquals(TtmlStyle.UNSPECIFIED, style.getStyle());
-        style.setItalic(true);
-        assertEquals(TtmlStyle.STYLE_ITALIC, style.getStyle());
-        style.setBold(true);
-        assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
-        style.setItalic(false);
-        assertEquals(TtmlStyle.STYLE_BOLD, style.getStyle());
-        style.setBold(false);
-        assertEquals(TtmlStyle.STYLE_NORMAL, style.getStyle());
-    }
-
-    public void testLinethrough() {
-        assertFalse(style.isLinethrough());
-        style.setLinethrough(true);
-        assertTrue(style.isLinethrough());
-        style.setLinethrough(false);
-        assertFalse(style.isLinethrough());
-    }
-
-    public void testUnderline() {
-        assertFalse(style.isUnderline());
-        style.setUnderline(true);
-        assertTrue(style.isUnderline());
-        style.setUnderline(false);
-        assertFalse(style.isUnderline());
-    }
-
-    public void testFontFamily() {
-        assertNull(style.getFontFamily());
-        style.setFontFamily(FONT_FAMILY);
-        assertEquals(FONT_FAMILY, style.getFontFamily());
-        style.setFontFamily(null);
-        assertNull(style.getFontFamily());
-    }
-
-    public void testColor() {
-        assertFalse(style.hasFontColor());
-        style.setFontColor(Color.BLACK);
-        assertEquals(Color.BLACK, style.getFontColor());
-        assertTrue(style.hasFontColor());
-    }
-
-    public void testBackgroundColor() {
-        assertFalse(style.hasBackgroundColor());
-        style.setBackgroundColor(Color.BLACK);
-        assertEquals(Color.BLACK, style.getBackgroundColor());
-        assertTrue(style.hasBackgroundColor());
-    }
-
-    public void testId() {
-        assertNull(style.getId());
-        style.setId(ID);
-        assertEquals(ID, style.getId());
-        style.setId(null);
-        assertNull(style.getId());
-    }
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
index e48a2b8b03..7d3c06b42e 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
@@ -36,6 +36,7 @@
 public class WebvttDecoderTest extends InstrumentationTestCase {
 
   private static final String TYPICAL_FILE = "webvtt/typical";
+  private static final String TYPICAL_WITH_BAD_TIMESTAMPS = "webvtt/typical_with_bad_timestamps";
   private static final String TYPICAL_WITH_IDS_FILE = "webvtt/typical_with_identifiers";
   private static final String TYPICAL_WITH_COMMENTS_FILE = "webvtt/typical_with_comments";
   private static final String WITH_POSITIONING_FILE = "webvtt/with_positioning";
@@ -67,6 +68,17 @@ public void testDecodeTypical() throws IOException, SubtitleDecoderException {
     assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
   }
 
+  public void testDecodeTypicalWithBadTimestamps() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_BAD_TIMESTAMPS);
+
+    // Test event count.
+    assertEquals(4, subtitle.getEventTimeCount());
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+  }
+
   public void testDecodeTypicalWithIds() throws IOException, SubtitleDecoderException {
     WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_IDS_FILE);
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
deleted file mode 100644
index c31c651384..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.trackselection;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.RendererCapabilities;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.util.MimeTypes;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link MappingTrackSelector}.
- */
-public final class MappingTrackSelectorTest extends TestCase {
-
-  private static final RendererCapabilities VIDEO_CAPABILITIES =
-      new FakeRendererCapabilities(C.TRACK_TYPE_VIDEO);
-  private static final RendererCapabilities AUDIO_CAPABILITIES =
-      new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO);
-  private static final RendererCapabilities[] RENDERER_CAPABILITIES = new RendererCapabilities[] {
-      VIDEO_CAPABILITIES, AUDIO_CAPABILITIES
-  };
-
-  private static final TrackGroup VIDEO_TRACK_GROUP = new TrackGroup(
-      Format.createVideoSampleFormat("video", MimeTypes.VIDEO_H264, null, Format.NO_VALUE,
-          Format.NO_VALUE, 1024, 768, Format.NO_VALUE, null, null));
-  private static final TrackGroup AUDIO_TRACK_GROUP = new TrackGroup(
-      Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-          Format.NO_VALUE, 2, 44100, null, null, 0, null));
-  private static final TrackGroupArray TRACK_GROUPS = new TrackGroupArray(
-      VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);
-
-  private static final TrackSelection[] TRACK_SELECTIONS = new TrackSelection[] {
-      new FixedTrackSelection(VIDEO_TRACK_GROUP, 0),
-      new FixedTrackSelection(AUDIO_TRACK_GROUP, 0)
-  };
-
-  /**
-   * Tests that the video and audio track groups are mapped onto the correct renderers.
-   */
-  public void testMapping() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
-    trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP);
-    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
-  }
-
-  /**
-   * Tests that the video and audio track groups are mapped onto the correct renderers when the
-   * renderer ordering is reversed.
-   */
-  public void testMappingReverseOrder() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
-    RendererCapabilities[] reverseOrderRendererCapabilities = new RendererCapabilities[] {
-        AUDIO_CAPABILITIES, VIDEO_CAPABILITIES};
-    trackSelector.selectTracks(reverseOrderRendererCapabilities, TRACK_GROUPS);
-    trackSelector.assertMappedTrackGroups(0, AUDIO_TRACK_GROUP);
-    trackSelector.assertMappedTrackGroups(1, VIDEO_TRACK_GROUP);
-  }
-
-  /**
-   * Tests video and audio track groups are mapped onto the correct renderers when there are
-   * multiple track groups of the same type.
-   */
-  public void testMappingMulti() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
-    TrackGroupArray multiTrackGroups = new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP,
-        VIDEO_TRACK_GROUP);
-    trackSelector.selectTracks(RENDERER_CAPABILITIES, multiTrackGroups);
-    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP, VIDEO_TRACK_GROUP);
-    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
-  }
-
-  /**
-   * Tests the result of {@link MappingTrackSelector#selectTracks(RendererCapabilities[],
-   * TrackGroupArray[], int[][][])} is propagated correctly to the result of
-   * {@link MappingTrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)}.
-   */
-  public void testSelectTracks() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
-    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
-  }
-
-  /**
-   * Tests that a null override clears a track selection.
-   */
-  public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
-    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertNull(result.selections.get(0));
-    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
-  }
-
-  /**
-   * Tests that a null override can be cleared.
-   */
-  public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
-    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
-    trackSelector.clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP));
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
-    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
-    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
-  }
-
-  /**
-   * Tests that an override is not applied for a different set of available track groups.
-   */
-  public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {
-    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
-    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
-    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES,
-        new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP));
-    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
-    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
-  }
-
-  /**
-   * A {@link MappingTrackSelector} that returns a fixed result from
-   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray[], int[][][])}.
-   */
-  private static final class FakeMappingTrackSelector extends MappingTrackSelector {
-
-    private final TrackSelection[] result;
-    private TrackGroupArray[] lastRendererTrackGroupArrays;
-
-    public FakeMappingTrackSelector(TrackSelection... result) {
-      this.result = result.length == 0 ? null : result;
-    }
-
-    @Override
-    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
-        TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
-        throws ExoPlaybackException {
-      lastRendererTrackGroupArrays = rendererTrackGroupArrays;
-      return result == null ? new TrackSelection[rendererCapabilities.length] : result;
-    }
-
-    public void assertMappedTrackGroups(int rendererIndex, TrackGroup... expected) {
-      assertEquals(expected.length, lastRendererTrackGroupArrays[rendererIndex].length);
-      for (int i = 0; i < expected.length; i++) {
-        assertEquals(expected[i], lastRendererTrackGroupArrays[rendererIndex].get(i));
-      }
-    }
-
-  }
-
-  /**
-   * A {@link RendererCapabilities} that advertises adaptive support for all tracks of a given type.
-   */
-  private static final class FakeRendererCapabilities implements RendererCapabilities {
-
-    private final int trackType;
-
-    public FakeRendererCapabilities(int trackType) {
-      this.trackType = trackType;
-    }
-
-    @Override
-    public int getTrackType() {
-      return trackType;
-    }
-
-    @Override
-    public int supportsFormat(Format format) throws ExoPlaybackException {
-      return MimeTypes.getTrackType(format.sampleMimeType) == trackType
-          ? (FORMAT_HANDLED | ADAPTIVE_SEAMLESS) : FORMAT_UNSUPPORTED_TYPE;
-    }
-
-    @Override
-    public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
-      return ADAPTIVE_SEAMLESS;
-    }
-
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
index 102c89ec2b..d582d25ab1 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
@@ -30,14 +30,14 @@ public void testReadFileUri() throws Exception {
     AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
     DataSpec dataSpec = new DataSpec(Uri.parse("file:///android_asset/" + DATA_PATH));
     TestUtil.assertDataSourceContent(dataSource, dataSpec,
-        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
+        TestUtil.getByteArray(getInstrumentation(), DATA_PATH), true);
   }
 
   public void testReadAssetUri() throws Exception {
     AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
     DataSpec dataSpec = new DataSpec(Uri.parse("asset:///" + DATA_PATH));
     TestUtil.assertDataSourceContent(dataSource, dataSpec,
-        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
+        TestUtil.getByteArray(getInstrumentation(), DATA_PATH), true);
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
index 2b70c83ca5..e19f7ad033 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
@@ -15,18 +15,22 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.app.Instrumentation;
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.res.AssetFileDescriptor;
 import android.database.Cursor;
 import android.net.Uri;
+import android.os.Bundle;
+import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.test.InstrumentationTestCase;
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
 
@@ -38,26 +42,33 @@
   private static final String AUTHORITY = "com.google.android.exoplayer2.core.test";
   private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";
 
-  private static final int TEST_DATA_OFFSET = 1;
-  private static final int TEST_DATA_LENGTH = 1023;
+  public void testRead() throws Exception {
+    assertData(getInstrumentation(), 0, C.LENGTH_UNSET, false);
+  }
 
-  public void testReadValidUri() throws Exception {
-    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
-    Uri contentUri = new Uri.Builder()
-        .scheme(ContentResolver.SCHEME_CONTENT)
-        .authority(AUTHORITY)
-        .path(DATA_PATH).build();
-    DataSpec dataSpec = new DataSpec(contentUri);
-    TestUtil.assertDataSourceContent(dataSource, dataSpec,
-        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
+  public void testReadPipeMode() throws Exception {
+    assertData(getInstrumentation(), 0, C.LENGTH_UNSET, true);
+  }
+
+  public void testReadFixedLength() throws Exception {
+    assertData(getInstrumentation(), 0, 100, false);
+  }
+
+  public void testReadFromOffsetToEndOfInput() throws Exception {
+    assertData(getInstrumentation(), 1, C.LENGTH_UNSET, false);
+  }
+
+  public void testReadFromOffsetToEndOfInputPipeMode() throws Exception {
+    assertData(getInstrumentation(), 1, C.LENGTH_UNSET, true);
+  }
+
+  public void testReadFromOffsetFixedLength() throws Exception {
+    assertData(getInstrumentation(), 1, 100, false);
   }
 
   public void testReadInvalidUri() throws Exception {
     ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
-    Uri contentUri = new Uri.Builder()
-        .scheme(ContentResolver.SCHEME_CONTENT)
-        .authority(AUTHORITY)
-        .build();
+    Uri contentUri = TestContentProvider.buildUri("does/not.exist", false);
     DataSpec dataSpec = new DataSpec(contentUri);
     try {
       dataSource.open(dataSpec);
@@ -70,22 +81,16 @@ public void testReadInvalidUri() throws Exception {
     }
   }
 
-  public void testReadFromOffsetToEndOfInput() throws Exception {
-    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
-    Uri contentUri = new Uri.Builder()
-        .scheme(ContentResolver.SCHEME_CONTENT)
-        .authority(AUTHORITY)
-        .path(DATA_PATH).build();
+  private static void assertData(Instrumentation instrumentation, int offset, int length,
+      boolean pipeMode) throws IOException {
+    Uri contentUri = TestContentProvider.buildUri(DATA_PATH, pipeMode);
+    ContentDataSource dataSource = new ContentDataSource(instrumentation.getContext());
     try {
-      DataSpec dataSpec = new DataSpec(contentUri, TEST_DATA_OFFSET, C.LENGTH_UNSET, null);
-      long length = dataSource.open(dataSpec);
-      assertEquals(TEST_DATA_LENGTH, length);
-      byte[] expectedData = Arrays.copyOfRange(
-          TestUtil.getByteArray(getInstrumentation(), DATA_PATH), TEST_DATA_OFFSET,
-          TEST_DATA_OFFSET + TEST_DATA_LENGTH);
-      byte[] readData = TestUtil.readToEnd(dataSource);
-      MoreAsserts.assertEquals(expectedData, readData);
-      assertEquals(C.RESULT_END_OF_INPUT, dataSource.read(new byte[1], 0, 1));
+      DataSpec dataSpec = new DataSpec(contentUri, offset, length, null);
+      byte[] completeData = TestUtil.getByteArray(instrumentation, DATA_PATH);
+      byte[] expectedData = Arrays.copyOfRange(completeData, offset,
+          length == C.LENGTH_UNSET ? completeData.length : offset + length);
+      TestUtil.assertDataSourceContent(dataSource, dataSpec, expectedData, !pipeMode);
     } finally {
       dataSource.close();
     }
@@ -94,7 +99,21 @@ public void testReadFromOffsetToEndOfInput() throws Exception {
   /**
    * A {@link ContentProvider} for the test.
    */
-  public static final class TestContentProvider extends ContentProvider {
+  public static final class TestContentProvider extends ContentProvider
+      implements ContentProvider.PipeDataWriter<Object> {
+
+    private static final String PARAM_PIPE_MODE = "pipe-mode";
+
+    public static Uri buildUri(String filePath, boolean pipeMode) {
+      Uri.Builder builder = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_CONTENT)
+          .authority(AUTHORITY)
+          .path(filePath);
+      if (pipeMode) {
+        builder.appendQueryParameter(TestContentProvider.PARAM_PIPE_MODE, "1");
+      }
+      return builder.build();
+    }
 
     @Override
     public boolean onCreate() {
@@ -114,7 +133,14 @@ public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode)
         return null;
       }
       try {
-        return getContext().getAssets().openFd(uri.getPath().replaceFirst("/", ""));
+        String fileName = getFileName(uri);
+        boolean pipeMode = uri.getQueryParameter(PARAM_PIPE_MODE) != null;
+        if (pipeMode) {
+          ParcelFileDescriptor fileDescriptor = openPipeHelper(uri, null, null, null, this);
+          return new AssetFileDescriptor(fileDescriptor, 0, C.LENGTH_UNSET);
+        } else {
+          return getContext().getAssets().openFd(fileName);
+        }
       } catch (IOException e) {
         FileNotFoundException exception = new FileNotFoundException(e.getMessage());
         exception.initCause(e);
@@ -133,17 +159,33 @@ public Uri insert(@NonNull Uri uri, ContentValues values) {
     }
 
     @Override
-    public int delete(@NonNull Uri uri, String selection,
-        String[] selectionArgs) {
+    public int delete(@NonNull Uri uri, String selection, String[] selectionArgs) {
       throw new UnsupportedOperationException();
     }
 
     @Override
-    public int update(@NonNull Uri uri, ContentValues values,
-        String selection, String[] selectionArgs) {
+    public int update(@NonNull Uri uri, ContentValues values, String selection,
+        String[] selectionArgs) {
       throw new UnsupportedOperationException();
     }
 
+    @Override
+    public void writeDataToPipe(@NonNull ParcelFileDescriptor output, @NonNull Uri uri,
+        @NonNull String mimeType, @Nullable Bundle opts, @Nullable Object args) {
+      try {
+        byte[] data = TestUtil.getByteArray(getContext(), getFileName(uri));
+        FileOutputStream outputStream = new FileOutputStream(output.getFileDescriptor());
+        outputStream.write(data);
+        outputStream.close();
+      } catch (IOException e) {
+        throw new RuntimeException("Error writing to pipe", e);
+      }
+    }
+
+    private static String getFileName(Uri uri) {
+      return uri.getPath().replaceFirst("/", "");
+    }
+
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
index f2e199578c..472b5c724b 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -17,11 +17,11 @@
 
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
-import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.IOException;
 import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 
 /**
  * Tests for {@link CachedRegionTracker}.
@@ -46,10 +46,9 @@
 
   @Override
   protected void setUp() throws Exception {
-    TestUtil.setUpMockito(this);
+    setUpMockito(this);
 
     tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
-
     cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     index = new CachedContentIndex(cacheDir);
   }
@@ -124,4 +123,14 @@ private CacheSpan newCacheSpan(int position, int length) throws IOException {
     return SimpleCacheSpanTest.createCacheSpan(index, cacheDir, CACHE_KEY, position, length, 0);
   }
 
+  /**
+   * Sets up Mockito for an instrumentation test.
+   */
+  private static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
+    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
+    System.setProperty("dexmaker.dexcache",
+        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
+    MockitoAnnotations.initMocks(instrumentationTestCase);
+  }
+
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ColorParserTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ColorParserTest.java
deleted file mode 100644
index 641b58b0ce..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ColorParserTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.util;
-
-import android.graphics.Color;
-import android.test.InstrumentationTestCase;
-
-/**
- * Unit test for <code>ColorParser</code>.
- */
-public class ColorParserTest extends InstrumentationTestCase {
-
-  // Negative tests.
-
-  public void testParseUnknownColor() {
-    try {
-      ColorParser.parseTtmlColor("colorOfAnElectron");
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
-  }
-
-  public void testParseNull() {
-    try {
-      ColorParser.parseTtmlColor(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
-  }
-
-  public void testParseEmpty() {
-    try {
-      ColorParser.parseTtmlColor("");
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
-  }
-
-  public void testRgbColorParsingRgbValuesNegative() {
-    try {
-      ColorParser.parseTtmlColor("rgb(-4, 55, 209)");
-      fail();
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
-  }
-
-  // Positive tests.
-
-  public void testHexCodeParsing() {
-    assertEquals(Color.WHITE, ColorParser.parseTtmlColor("#FFFFFF"));
-    assertEquals(Color.WHITE, ColorParser.parseTtmlColor("#FFFFFFFF"));
-    assertEquals(Color.parseColor("#FF123456"), ColorParser.parseTtmlColor("#123456"));
-    // Hex colors in ColorParser are RGBA, where-as {@link Color#parseColor} takes ARGB.
-    assertEquals(Color.parseColor("#00FFFFFF"), ColorParser.parseTtmlColor("#FFFFFF00"));
-    assertEquals(Color.parseColor("#78123456"), ColorParser.parseTtmlColor("#12345678"));
-  }
-
-  public void testRgbColorParsing() {
-    assertEquals(Color.WHITE, ColorParser.parseTtmlColor("rgb(255,255,255)"));
-    // Spaces are ignored.
-    assertEquals(Color.WHITE, ColorParser.parseTtmlColor("   rgb (      255, 255, 255)"));
-  }
-
-  public void testRgbColorParsingRgbValuesOutOfBounds() {
-    int outOfBounds = ColorParser.parseTtmlColor("rgb(999, 999, 999)");
-    int color = Color.rgb(999, 999, 999);
-    // Behave like the framework does.
-    assertEquals(color, outOfBounds);
-  }
-
-  public void testRgbaColorParsing() {
-    assertEquals(Color.WHITE, ColorParser.parseTtmlColor("rgba(255,255,255,255)"));
-    assertEquals(Color.argb(255, 255, 255, 255),
-        ColorParser.parseTtmlColor("rgba(255,255,255,255)"));
-    assertEquals(Color.BLACK, ColorParser.parseTtmlColor("rgba(0, 0, 0, 255)"));
-    assertEquals(Color.argb(0, 0, 0, 255), ColorParser.parseTtmlColor("rgba(0, 0, 255, 0)"));
-    assertEquals(Color.RED, ColorParser.parseTtmlColor("rgba(255, 0, 0, 255)"));
-    assertEquals(Color.argb(0, 255, 0, 255), ColorParser.parseTtmlColor("rgba(255, 0, 255, 0)"));
-    assertEquals(Color.argb(205, 255, 0, 0), ColorParser.parseTtmlColor("rgba(255, 0, 0, 205)"));
-  }
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
deleted file mode 100644
index cfb9cd78be..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.util;
-
-import android.test.MoreAsserts;
-
-import junit.framework.TestCase;
-
-/**
- * Tests for {@link ParsableBitArray}.
- */
-public final class ParsableBitArrayTest extends TestCase {
-
-  private static final byte[] TEST_DATA = new byte[] {0x3C, (byte) 0xD2, (byte) 0x5F, (byte) 0x01,
-      (byte) 0xFF, (byte) 0x14, (byte) 0x60, (byte) 0x99};
-
-  public void testReadAllBytes() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    byte[] bytesRead = new byte[TEST_DATA.length];
-    testArray.readBytes(bytesRead, 0, TEST_DATA.length);
-    MoreAsserts.assertEquals(TEST_DATA, bytesRead);
-    assertEquals(TEST_DATA.length * 8, testArray.getPosition());
-    assertEquals(TEST_DATA.length, testArray.getBytePosition());
-  }
-
-  public void testReadBit() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    assertReadBitsToEnd(0, testArray);
-  }
-
-  public void testReadBits() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    assertEquals(getTestDataBits(0, 5), testArray.readBits(5));
-    assertEquals(getTestDataBits(5, 3), testArray.readBits(3));
-    assertEquals(getTestDataBits(8, 16), testArray.readBits(16));
-    assertEquals(getTestDataBits(24, 3), testArray.readBits(3));
-    assertEquals(getTestDataBits(27, 18), testArray.readBits(18));
-    assertEquals(getTestDataBits(45, 5), testArray.readBits(5));
-    assertEquals(getTestDataBits(50, 14), testArray.readBits(14));
-  }
-
-  public void testRead32BitsByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    assertEquals(getTestDataBits(0, 32), testArray.readBits(32));
-    assertEquals(getTestDataBits(32, 32), testArray.readBits(32));
-  }
-
-  public void testRead32BitsNonByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    assertEquals(getTestDataBits(0, 5), testArray.readBits(5));
-    assertEquals(getTestDataBits(5, 32), testArray.readBits(32));
-  }
-
-  public void testSkipBytes() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.skipBytes(2);
-    assertReadBitsToEnd(16, testArray);
-  }
-
-  public void testSkipBitsByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.skipBits(16);
-    assertReadBitsToEnd(16, testArray);
-  }
-
-  public void testSkipBitsNonByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.skipBits(5);
-    assertReadBitsToEnd(5, testArray);
-  }
-
-  public void testSetPositionByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.setPosition(16);
-    assertReadBitsToEnd(16, testArray);
-  }
-
-  public void testSetPositionNonByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.setPosition(5);
-    assertReadBitsToEnd(5, testArray);
-  }
-
-  public void testByteAlignFromNonByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.setPosition(11);
-    testArray.byteAlign();
-    assertEquals(2, testArray.getBytePosition());
-    assertEquals(16, testArray.getPosition());
-    assertReadBitsToEnd(16, testArray);
-  }
-
-  public void testByteAlignFromByteAligned() {
-    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
-    testArray.setPosition(16);
-    testArray.byteAlign(); // Should be a no-op.
-    assertEquals(2, testArray.getBytePosition());
-    assertEquals(16, testArray.getPosition());
-    assertReadBitsToEnd(16, testArray);
-  }
-
-  private static void assertReadBitsToEnd(int expectedStartPosition, ParsableBitArray testArray) {
-    int position = testArray.getPosition();
-    assertEquals(expectedStartPosition, position);
-    for (int i = position; i < TEST_DATA.length * 8; i++) {
-      assertEquals(getTestDataBit(i), testArray.readBit());
-      assertEquals(i + 1, testArray.getPosition());
-    }
-  }
-
-  private static int getTestDataBits(int bitPosition, int length) {
-    int result = 0;
-    for (int i = 0; i < length; i++) {
-      result = result << 1;
-      if (getTestDataBit(bitPosition++)) {
-        result |= 0x1;
-      }
-    }
-    return result;
-  }
-
-  private static boolean getTestDataBit(int bitPosition) {
-    return (TEST_DATA[bitPosition / 8] & (0x80 >>> (bitPosition % 8))) != 0;
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/UriUtilTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/util/UriUtilTest.java
deleted file mode 100644
index 1755c6f70d..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/UriUtilTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.util;
-
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link UriUtil}.
- */
-public class UriUtilTest extends TestCase {
-
-  /**
-   * Tests normal usage of {@link UriUtil#resolve(String, String)}.
-   * <p>
-   * The test cases are taken from RFC-3986 5.4.1.
-   */
-  public void testResolveNormal() {
-    String base = "http://a/b/c/d;p?q";
-
-    assertEquals("g:h", UriUtil.resolve(base, "g:h"));
-    assertEquals("http://a/b/c/g", UriUtil.resolve(base, "g"));
-    assertEquals("http://a/b/c/g/", UriUtil.resolve(base, "g/"));
-    assertEquals("http://a/g", UriUtil.resolve(base, "/g"));
-    assertEquals("http://g", UriUtil.resolve(base, "//g"));
-    assertEquals("http://a/b/c/d;p?y", UriUtil.resolve(base, "?y"));
-    assertEquals("http://a/b/c/g?y", UriUtil.resolve(base, "g?y"));
-    assertEquals("http://a/b/c/d;p?q#s", UriUtil.resolve(base, "#s"));
-    assertEquals("http://a/b/c/g#s", UriUtil.resolve(base, "g#s"));
-    assertEquals("http://a/b/c/g?y#s", UriUtil.resolve(base, "g?y#s"));
-    assertEquals("http://a/b/c/;x", UriUtil.resolve(base, ";x"));
-    assertEquals("http://a/b/c/g;x", UriUtil.resolve(base, "g;x"));
-    assertEquals("http://a/b/c/g;x?y#s", UriUtil.resolve(base, "g;x?y#s"));
-    assertEquals("http://a/b/c/d;p?q", UriUtil.resolve(base, ""));
-    assertEquals("http://a/b/c/", UriUtil.resolve(base, "."));
-    assertEquals("http://a/b/c/", UriUtil.resolve(base, "./"));
-    assertEquals("http://a/b/", UriUtil.resolve(base, ".."));
-    assertEquals("http://a/b/", UriUtil.resolve(base, "../"));
-    assertEquals("http://a/b/g", UriUtil.resolve(base, "../g"));
-    assertEquals("http://a/", UriUtil.resolve(base, "../.."));
-    assertEquals("http://a/", UriUtil.resolve(base, "../../"));
-    assertEquals("http://a/g", UriUtil.resolve(base, "../../g"));
-  }
-
-  /**
-   * Tests abnormal usage of {@link UriUtil#resolve(String, String)}.
-   * <p>
-   * The test cases are taken from RFC-3986 5.4.2.
-   */
-  public void testResolveAbnormal() {
-    String base = "http://a/b/c/d;p?q";
-
-    assertEquals("http://a/g", UriUtil.resolve(base, "../../../g"));
-    assertEquals("http://a/g", UriUtil.resolve(base, "../../../../g"));
-
-    assertEquals("http://a/g", UriUtil.resolve(base, "/./g"));
-    assertEquals("http://a/g", UriUtil.resolve(base, "/../g"));
-    assertEquals("http://a/b/c/g.", UriUtil.resolve(base, "g."));
-    assertEquals("http://a/b/c/.g", UriUtil.resolve(base, ".g"));
-    assertEquals("http://a/b/c/g..", UriUtil.resolve(base, "g.."));
-    assertEquals("http://a/b/c/..g", UriUtil.resolve(base, "..g"));
-
-    assertEquals("http://a/b/g", UriUtil.resolve(base, "./../g"));
-    assertEquals("http://a/b/c/g/", UriUtil.resolve(base, "./g/."));
-    assertEquals("http://a/b/c/g/h", UriUtil.resolve(base, "g/./h"));
-    assertEquals("http://a/b/c/h", UriUtil.resolve(base, "g/../h"));
-    assertEquals("http://a/b/c/g;x=1/y", UriUtil.resolve(base, "g;x=1/./y"));
-    assertEquals("http://a/b/c/y", UriUtil.resolve(base, "g;x=1/../y"));
-
-    assertEquals("http://a/b/c/g?y/./x", UriUtil.resolve(base, "g?y/./x"));
-    assertEquals("http://a/b/c/g?y/../x", UriUtil.resolve(base, "g?y/../x"));
-    assertEquals("http://a/b/c/g#s/./x", UriUtil.resolve(base, "g#s/./x"));
-    assertEquals("http://a/b/c/g#s/../x", UriUtil.resolve(base, "g#s/../x"));
-
-    assertEquals("http:g", UriUtil.resolve(base, "http:g"));
-  }
-
-  /**
-   * Tests additional abnormal usage of {@link UriUtil#resolve(String, String)}.
-   */
-  public void testResolveAbnormalAdditional() {
-    assertEquals("c:e", UriUtil.resolve("http://a/b", "c:d/../e"));
-    assertEquals("a:c", UriUtil.resolve("a:b", "../c"));
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
deleted file mode 100644
index 1d9aff0723..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.util;
-
-import com.google.android.exoplayer2.testutil.TestUtil;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link Util}.
- */
-public class UtilTest extends TestCase {
-
-  public void testArrayBinarySearchFloor() {
-    long[] values = new long[0];
-    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
-    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
-
-    values = new long[] {1, 3, 5};
-    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
-    assertEquals(-1, Util.binarySearchFloor(values, 0, true, false));
-    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
-    assertEquals(0, Util.binarySearchFloor(values, 0, true, true));
-
-    assertEquals(-1, Util.binarySearchFloor(values, 1, false, false));
-    assertEquals(0, Util.binarySearchFloor(values, 1, true, false));
-    assertEquals(0, Util.binarySearchFloor(values, 1, false, true));
-    assertEquals(0, Util.binarySearchFloor(values, 1, true, true));
-
-    assertEquals(1, Util.binarySearchFloor(values, 4, false, false));
-    assertEquals(1, Util.binarySearchFloor(values, 4, true, false));
-
-    assertEquals(1, Util.binarySearchFloor(values, 5, false, false));
-    assertEquals(2, Util.binarySearchFloor(values, 5, true, false));
-
-    assertEquals(2, Util.binarySearchFloor(values, 6, false, false));
-    assertEquals(2, Util.binarySearchFloor(values, 6, true, false));
-  }
-
-  public void testListBinarySearchFloor() {
-    List<Integer> values = new ArrayList<>();
-    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
-    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
-
-    values.add(1);
-    values.add(3);
-    values.add(5);
-    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
-    assertEquals(-1, Util.binarySearchFloor(values, 0, true, false));
-    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
-    assertEquals(0, Util.binarySearchFloor(values, 0, true, true));
-
-    assertEquals(-1, Util.binarySearchFloor(values, 1, false, false));
-    assertEquals(0, Util.binarySearchFloor(values, 1, true, false));
-    assertEquals(0, Util.binarySearchFloor(values, 1, false, true));
-    assertEquals(0, Util.binarySearchFloor(values, 1, true, true));
-
-    assertEquals(1, Util.binarySearchFloor(values, 4, false, false));
-    assertEquals(1, Util.binarySearchFloor(values, 4, true, false));
-
-    assertEquals(1, Util.binarySearchFloor(values, 5, false, false));
-    assertEquals(2, Util.binarySearchFloor(values, 5, true, false));
-
-    assertEquals(2, Util.binarySearchFloor(values, 6, false, false));
-    assertEquals(2, Util.binarySearchFloor(values, 6, true, false));
-  }
-
-  public void testArrayBinarySearchCeil() {
-    long[] values = new long[0];
-    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
-    assertEquals(-1, Util.binarySearchCeil(values, 0, false, true));
-
-    values = new long[] {1, 3, 5};
-    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
-    assertEquals(0, Util.binarySearchCeil(values, 0, true, false));
-
-    assertEquals(1, Util.binarySearchCeil(values, 1, false, false));
-    assertEquals(0, Util.binarySearchCeil(values, 1, true, false));
-
-    assertEquals(1, Util.binarySearchCeil(values, 2, false, false));
-    assertEquals(1, Util.binarySearchCeil(values, 2, true, false));
-
-    assertEquals(3, Util.binarySearchCeil(values, 5, false, false));
-    assertEquals(2, Util.binarySearchCeil(values, 5, true, false));
-    assertEquals(2, Util.binarySearchCeil(values, 5, false, true));
-    assertEquals(2, Util.binarySearchCeil(values, 5, true, true));
-
-    assertEquals(3, Util.binarySearchCeil(values, 6, false, false));
-    assertEquals(3, Util.binarySearchCeil(values, 6, true, false));
-    assertEquals(2, Util.binarySearchCeil(values, 6, false, true));
-    assertEquals(2, Util.binarySearchCeil(values, 6, true, true));
-  }
-
-  public void testListBinarySearchCeil() {
-    List<Integer> values = new ArrayList<>();
-    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
-    assertEquals(-1, Util.binarySearchCeil(values, 0, false, true));
-
-    values.add(1);
-    values.add(3);
-    values.add(5);
-    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
-    assertEquals(0, Util.binarySearchCeil(values, 0, true, false));
-
-    assertEquals(1, Util.binarySearchCeil(values, 1, false, false));
-    assertEquals(0, Util.binarySearchCeil(values, 1, true, false));
-
-    assertEquals(1, Util.binarySearchCeil(values, 2, false, false));
-    assertEquals(1, Util.binarySearchCeil(values, 2, true, false));
-
-    assertEquals(3, Util.binarySearchCeil(values, 5, false, false));
-    assertEquals(2, Util.binarySearchCeil(values, 5, true, false));
-    assertEquals(2, Util.binarySearchCeil(values, 5, false, true));
-    assertEquals(2, Util.binarySearchCeil(values, 5, true, true));
-
-    assertEquals(3, Util.binarySearchCeil(values, 6, false, false));
-    assertEquals(3, Util.binarySearchCeil(values, 6, true, false));
-    assertEquals(2, Util.binarySearchCeil(values, 6, false, true));
-    assertEquals(2, Util.binarySearchCeil(values, 6, true, true));
-  }
-
-  public void testParseXsDuration() {
-    assertEquals(150279L, Util.parseXsDuration("PT150.279S"));
-    assertEquals(1500L, Util.parseXsDuration("PT1.500S"));
-  }
-
-  public void testParseXsDateTime() throws Exception {
-    assertEquals(1403219262000L, Util.parseXsDateTime("2014-06-19T23:07:42"));
-    assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00Z"));
-    assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00,000Z"));
-    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-08:00"));
-    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-0800"));
-    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55.000-0800"));
-    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55.000-800"));
-  }
-
-  public void testUnescapeInvalidFileName() {
-    assertNull(Util.unescapeFileName("%a"));
-    assertNull(Util.unescapeFileName("%xyz"));
-  }
-
-  public void testEscapeUnescapeFileName() {
-    assertEscapeUnescapeFileName("just+a regular+fileName", "just+a regular+fileName");
-    assertEscapeUnescapeFileName("key:value", "key%3avalue");
-    assertEscapeUnescapeFileName("<>:\"/\\|?*%", "%3c%3e%3a%22%2f%5c%7c%3f%2a%25");
-
-    Random random = new Random(0);
-    for (int i = 0; i < 1000; i++) {
-      String string = TestUtil.buildTestString(1000, random);
-      assertEscapeUnescapeFileName(string);
-    }
-  }
-
-  private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
-    assertEquals(escapedFileName, Util.escapeFileName(fileName));
-    assertEquals(fileName, Util.unescapeFileName(escapedFileName));
-  }
-
-  private static void assertEscapeUnescapeFileName(String fileName) {
-    String escapedFileName = Util.escapeFileName(fileName);
-    assertEquals(fileName, Util.unescapeFileName(escapedFileName));
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index a88a1dd615..a4103787d1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
@@ -296,9 +299,10 @@ protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buf
    * {@code positionUs} is beyond it.
    *
    * @param positionUs The position in microseconds.
+   * @return The number of samples that were skipped.
    */
-  protected void skipSource(long positionUs) {
-    stream.skipData(positionUs - streamOffsetUs);
+  protected int skipSource(long positionUs) {
+    return stream.skipData(positionUs - streamOffsetUs);
   }
 
   /**
@@ -308,4 +312,25 @@ protected final boolean isSourceReady() {
     return readEndOfStream ? streamIsFinal : stream.isReady();
   }
 
+  /**
+   * Returns whether {@code drmSessionManager} supports the specified {@code drmInitData}, or true
+   * if {@code drmInitData} is null.
+   *
+   * @param drmSessionManager The drm session manager.
+   * @param drmInitData {@link DrmInitData} of the format to check for support.
+   * @return Whether {@code drmSessionManager} supports the specified {@code drmInitData}, or
+   *     true if {@code drmInitData} is null.
+   */
+  protected static boolean supportsFormatDrm(@Nullable DrmSessionManager<?> drmSessionManager,
+      @Nullable DrmInitData drmInitData) {
+    if (drmInitData == null) {
+      // Content is unencrypted.
+      return true;
+    } else if (drmSessionManager == null) {
+      // Content is encrypted, but no drm session manager is available.
+      return false;
+    }
+    return drmSessionManager.canAcquireSession(drmInitData);
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index d7d0ed40aa..9d4049ada9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -73,6 +73,10 @@ private C() {}
    */
   public static final long NANOS_PER_SECOND = 1000000000L;
 
+  /**
+   * The name of the ASCII charset.
+   */
+  public static final String ASCII_NAME = "US-ASCII";
   /**
    * The name of the UTF-8 charset.
    */
@@ -515,6 +519,10 @@ private C() {}
    * A type constant for metadata tracks.
    */
   public static final int TRACK_TYPE_METADATA = 4;
+  /**
+   * A type constant for a dummy or empty track.
+   */
+  public static final int TRACK_TYPE_NONE = 5;
   /**
    * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
    * equal to this value.
@@ -604,12 +612,19 @@ private C() {}
    */
   public static final UUID UUID_NIL = new UUID(0L, 0L);
 
+  /**
+   * UUID for the W3C
+   * <a href="https://w3c.github.io/encrypted-media/format-registry/initdata/cenc.html">Common PSSH
+   * box</a>.
+   */
+  public static final UUID COMMON_PSSH_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
+
   /**
    * UUID for the ClearKey DRM scheme.
    * <p>
    * ClearKey is supported on Android devices running Android 5.0 (API Level 21) and up.
    */
-  public static final UUID CLEARKEY_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
+  public static final UUID CLEARKEY_UUID = new UUID(0xE2719D58A985B3C9L, 0x781AB030AF78D30EL);
 
   /**
    * UUID for the Widevine DRM scheme.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ControlDispatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/ControlDispatcher.java
new file mode 100644
index 0000000000..21c596e6d4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ControlDispatcher.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.Player.RepeatMode;
+
+/**
+ * Dispatches operations to the {@link Player}.
+ * <p>
+ * Implementations may choose to suppress (e.g. prevent playback from resuming if audio focus is
+ * denied) or modify (e.g. change the seek position to prevent a user from seeking past a
+ * non-skippable advert) operations.
+ */
+public interface ControlDispatcher {
+
+  /**
+   * Dispatches a {@link Player#setPlayWhenReady(boolean)} operation.
+   *
+   * @param player The {@link Player} to which the operation should be dispatched.
+   * @param playWhenReady Whether playback should proceed when ready.
+   * @return True if the operation was dispatched. False if suppressed.
+   */
+  boolean dispatchSetPlayWhenReady(Player player, boolean playWhenReady);
+
+  /**
+   * Dispatches a {@link Player#seekTo(int, long)} operation.
+   *
+   * @param player The {@link Player} to which the operation should be dispatched.
+   * @param windowIndex The index of the window.
+   * @param positionMs The seek position in the specified window, or {@link C#TIME_UNSET} to seek to
+   *     the window's default position.
+   * @return True if the operation was dispatched. False if suppressed.
+   */
+  boolean dispatchSeekTo(Player player, int windowIndex, long positionMs);
+
+  /**
+   * Dispatches a {@link Player#setRepeatMode(int)} operation.
+   *
+   * @param player The {@link Player} to which the operation should be dispatched.
+   * @param repeatMode The repeat mode.
+   * @return True if the operation was dispatched. False if suppressed.
+   */
+  boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode);
+
+  /**
+   * Dispatches a {@link Player#setShuffleModeEnabled(boolean)} operation.
+   *
+   * @param player The {@link Player} to which the operation should be dispatched.
+   * @param shuffleModeEnabled Whether shuffling is enabled.
+   * @return True if the operation was dispatched. False if suppressed.
+   */
+  boolean dispatchSetShuffleModeEnabled(Player player, boolean shuffleModeEnabled);
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultControlDispatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultControlDispatcher.java
new file mode 100644
index 0000000000..84711d752a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultControlDispatcher.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.Player.RepeatMode;
+
+/**
+ * Default {@link ControlDispatcher} that dispatches all operations to the player without
+ * modification.
+ */
+public class DefaultControlDispatcher implements ControlDispatcher {
+
+  @Override
+  public boolean dispatchSetPlayWhenReady(Player player, boolean playWhenReady) {
+    player.setPlayWhenReady(playWhenReady);
+    return true;
+  }
+
+  @Override
+  public boolean dispatchSeekTo(Player player, int windowIndex, long positionMs) {
+    player.seekTo(windowIndex, positionMs);
+    return true;
+  }
+
+  @Override
+  public boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode) {
+    player.setRepeatMode(repeatMode);
+    return true;
+  }
+
+  @Override
+  public boolean dispatchSetShuffleModeEnabled(Player player, boolean shuffleModeEnabled) {
+    player.setShuffleModeEnabled(shuffleModeEnabled);
+    return true;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 3e7cb8a68b..2272306117 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -19,6 +19,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioProcessor;
@@ -27,7 +28,9 @@
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
@@ -79,7 +82,7 @@
   protected static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
 
   private final Context context;
-  private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
+  @Nullable private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
   private final @ExtensionRendererMode int extensionRendererMode;
   private final long allowedVideoJoiningTimeMs;
 
@@ -96,29 +99,28 @@ public DefaultRenderersFactory(Context context) {
    *     playbacks are not required.
    */
   public DefaultRenderersFactory(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     this(context, drmSessionManager, EXTENSION_RENDERER_MODE_OFF);
   }
 
   /**
    * @param context A {@link Context}.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if DRM protected
-   *     playbacks are not required..
+   *     playbacks are not required.
    * @param extensionRendererMode The extension renderer mode, which determines if and how
    *     available extension renderers are used. Note that extensions must be included in the
    *     application build for them to be considered available.
    */
   public DefaultRenderersFactory(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @ExtensionRendererMode int extensionRendererMode) {
-    this(context, drmSessionManager, extensionRendererMode,
-        DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
+    this(context, drmSessionManager, extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
   }
 
   /**
    * @param context A {@link Context}.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if DRM protected
-   *     playbacks are not required..
+   *     playbacks are not required.
    * @param extensionRendererMode The extension renderer mode, which determines if and how
    *     available extension renderers are used. Note that extensions must be included in the
    *     application build for them to be considered available.
@@ -126,7 +128,7 @@ public DefaultRenderersFactory(Context context,
    *     to seamlessly join an ongoing playback.
    */
   public DefaultRenderersFactory(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs) {
     this.context = context;
     this.drmSessionManager = drmSessionManager;
@@ -138,7 +140,7 @@ public DefaultRenderersFactory(Context context,
   public Renderer[] createRenderers(Handler eventHandler,
       VideoRendererEventListener videoRendererEventListener,
       AudioRendererEventListener audioRendererEventListener,
-      TextRenderer.Output textRendererOutput, MetadataRenderer.Output metadataRendererOutput) {
+      TextOutput textRendererOutput, MetadataOutput metadataRendererOutput) {
     ArrayList<Renderer> renderersList = new ArrayList<>();
     buildVideoRenderers(context, drmSessionManager, allowedVideoJoiningTimeMs,
         eventHandler, videoRendererEventListener, extensionRendererMode, renderersList);
@@ -166,9 +168,10 @@ public DefaultRenderersFactory(Context context,
    * @param out An array to which the built renderers should be appended.
    */
   protected void buildVideoRenderers(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, long allowedVideoJoiningTimeMs,
-      Handler eventHandler, VideoRendererEventListener eventListener,
-      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      long allowedVideoJoiningTimeMs, Handler eventHandler,
+      VideoRendererEventListener eventListener, @ExtensionRendererMode int extensionRendererMode,
+      ArrayList<Renderer> out) {
     out.add(new MediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
         allowedVideoJoiningTimeMs, drmSessionManager, false, eventHandler, eventListener,
         MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
@@ -211,7 +214,7 @@ protected void buildVideoRenderers(Context context,
    * @param out An array to which the built renderers should be appended.
    */
   protected void buildAudioRenderers(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       AudioProcessor[] audioProcessors, Handler eventHandler,
       AudioRendererEventListener eventListener, @ExtensionRendererMode int extensionRendererMode,
       ArrayList<Renderer> out) {
@@ -282,8 +285,8 @@ protected void buildAudioRenderers(Context context,
    * @param extensionRendererMode The extension renderer mode.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildTextRenderers(Context context, TextRenderer.Output output,
-      Looper outputLooper, @ExtensionRendererMode int extensionRendererMode,
+  protected void buildTextRenderers(Context context, TextOutput output, Looper outputLooper,
+      @ExtensionRendererMode int extensionRendererMode,
       ArrayList<Renderer> out) {
     out.add(new TextRenderer(output, outputLooper));
   }
@@ -298,9 +301,8 @@ protected void buildTextRenderers(Context context, TextRenderer.Output output,
    * @param extensionRendererMode The extension renderer mode.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildMetadataRenderers(Context context, MetadataRenderer.Output output,
-      Looper outputLooper, @ExtensionRendererMode int extensionRendererMode,
-      ArrayList<Renderer> out) {
+  protected void buildMetadataRenderers(Context context, MetadataOutput output, Looper outputLooper,
+      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
     out.add(new MetadataRenderer(output, outputLooper));
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index b096b5ae12..915a083657 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -211,12 +211,18 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
   /**
    * Prepares the player to play the provided {@link MediaSource}. Equivalent to
    * {@code prepare(mediaSource, true, true)}.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to prepare a
+   * player more than once with the same piece of media, use a new instance each time.
    */
   void prepare(MediaSource mediaSource);
 
   /**
    * Prepares the player to play the provided {@link MediaSource}, optionally resetting the playback
    * position the default position in the first {@link Timeline.Window}.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to prepare a
+   * player more than once with the same piece of media, use a new instance each time.
    *
    * @param mediaSource The {@link MediaSource} to play.
    * @param resetPosition Whether the playback position should be reset to the default position in
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 97a310c3da..b647e541bc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2;
 
 import android.content.Context;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
@@ -54,7 +55,8 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    */
   @Deprecated
   public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+      LoadControl loadControl,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context, drmSessionManager);
     return newSimpleInstance(renderersFactory, trackSelector, loadControl);
   }
@@ -74,7 +76,7 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    */
   @Deprecated
   public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      LoadControl loadControl, @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context, drmSessionManager,
         extensionRendererMode);
@@ -98,7 +100,7 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    */
   @Deprecated
   public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      LoadControl loadControl, @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context, drmSessionManager,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index b53cce1f74..349751eb59 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -21,8 +21,6 @@
 import android.os.Message;
 import android.support.annotation.Nullable;
 import android.util.Log;
-import com.google.android.exoplayer2.ExoPlayerImplInternal.PlaybackInfo;
-import com.google.android.exoplayer2.ExoPlayerImplInternal.SourceInfo;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -53,12 +51,11 @@
   private boolean tracksSelected;
   private boolean playWhenReady;
   private @RepeatMode int repeatMode;
+  private boolean shuffleModeEnabled;
   private int playbackState;
   private int pendingSeekAcks;
   private int pendingPrepareAcks;
   private boolean isLoading;
-  private Timeline timeline;
-  private Object manifest;
   private TrackGroupArray trackGroups;
   private TrackSelectionArray trackSelections;
   private PlaybackParameters playbackParameters;
@@ -87,10 +84,10 @@ public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadCont
     this.trackSelector = Assertions.checkNotNull(trackSelector);
     this.playWhenReady = false;
     this.repeatMode = Player.REPEAT_MODE_OFF;
+    this.shuffleModeEnabled = false;
     this.playbackState = Player.STATE_IDLE;
     this.listeners = new CopyOnWriteArraySet<>();
     emptyTrackSelections = new TrackSelectionArray(new TrackSelection[renderers.length]);
-    timeline = Timeline.EMPTY;
     window = new Timeline.Window();
     period = new Timeline.Period();
     trackGroups = TrackGroupArray.EMPTY;
@@ -103,9 +100,9 @@ public void handleMessage(Message msg) {
         ExoPlayerImpl.this.handleEvent(msg);
       }
     };
-    playbackInfo = new ExoPlayerImplInternal.PlaybackInfo(0, 0);
+    playbackInfo = new PlaybackInfo(Timeline.EMPTY, null, 0, 0);
     internalPlayer = new ExoPlayerImplInternal(renderers, trackSelector, loadControl, playWhenReady,
-        repeatMode, eventHandler, playbackInfo, this);
+        repeatMode, shuffleModeEnabled, eventHandler, this);
   }
 
   @Override
@@ -135,12 +132,20 @@ public void prepare(MediaSource mediaSource) {
 
   @Override
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    if (!resetPosition) {
+      maskingWindowIndex = getCurrentWindowIndex();
+      maskingPeriodIndex = getCurrentPeriodIndex();
+      maskingWindowPositionMs = getCurrentPosition();
+    } else {
+      maskingWindowIndex = 0;
+      maskingPeriodIndex = 0;
+      maskingWindowPositionMs = 0;
+    }
     if (resetState) {
-      if (!timeline.isEmpty() || manifest != null) {
-        timeline = Timeline.EMPTY;
-        manifest = null;
+      if (!playbackInfo.timeline.isEmpty() || playbackInfo.manifest != null) {
+        playbackInfo = playbackInfo.copyWithTimeline(Timeline.EMPTY, null);
         for (Player.EventListener listener : listeners) {
-          listener.onTimelineChanged(timeline, manifest);
+          listener.onTimelineChanged(playbackInfo.timeline, playbackInfo.manifest);
         }
       }
       if (tracksSelected) {
@@ -189,6 +194,22 @@ public void setRepeatMode(@RepeatMode int repeatMode) {
     return repeatMode;
   }
 
+  @Override
+  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    if (this.shuffleModeEnabled != shuffleModeEnabled) {
+      this.shuffleModeEnabled = shuffleModeEnabled;
+      internalPlayer.setShuffleModeEnabled(shuffleModeEnabled);
+      for (Player.EventListener listener : listeners) {
+        listener.onShuffleModeEnabledChanged(shuffleModeEnabled);
+      }
+    }
+  }
+
+  @Override
+  public boolean getShuffleModeEnabled() {
+    return shuffleModeEnabled;
+  }
+
   @Override
   public boolean isLoading() {
     return isLoading;
@@ -211,36 +232,45 @@ public void seekTo(long positionMs) {
 
   @Override
   public void seekTo(int windowIndex, long positionMs) {
+    Timeline timeline = playbackInfo.timeline;
     if (windowIndex < 0 || (!timeline.isEmpty() && windowIndex >= timeline.getWindowCount())) {
       throw new IllegalSeekPositionException(timeline, windowIndex, positionMs);
     }
+    if (isPlayingAd()) {
+      // TODO: Investigate adding support for seeking during ads. This is complicated to do in
+      // general because the midroll ad preceding the seek destination must be played before the
+      // content position can be played, if a different ad is playing at the moment.
+      Log.w(TAG, "seekTo ignored because an ad is playing");
+      if (pendingSeekAcks == 0) {
+        for (Player.EventListener listener : listeners) {
+          listener.onSeekProcessed();
+        }
+      }
+      return;
+    }
     pendingSeekAcks++;
     maskingWindowIndex = windowIndex;
     if (timeline.isEmpty()) {
+      maskingWindowPositionMs = positionMs == C.TIME_UNSET ? 0 : positionMs;
       maskingPeriodIndex = 0;
     } else {
       timeline.getWindow(windowIndex, window);
-      long resolvedPositionUs =
-          positionMs == C.TIME_UNSET ? window.getDefaultPositionUs() : C.msToUs(positionMs);
+      long windowPositionUs = positionMs == C.TIME_UNSET ? window.getDefaultPositionUs()
+          : C.msToUs(positionMs);
       int periodIndex = window.firstPeriodIndex;
-      long periodPositionUs = window.getPositionInFirstPeriodUs() + resolvedPositionUs;
+      long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;
       long periodDurationUs = timeline.getPeriod(periodIndex, period).getDurationUs();
       while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs
           && periodIndex < window.lastPeriodIndex) {
         periodPositionUs -= periodDurationUs;
         periodDurationUs = timeline.getPeriod(++periodIndex, period).getDurationUs();
       }
+      maskingWindowPositionMs = C.usToMs(windowPositionUs);
       maskingPeriodIndex = periodIndex;
     }
-    if (positionMs == C.TIME_UNSET) {
-      maskingWindowPositionMs = 0;
-      internalPlayer.seekTo(timeline, windowIndex, C.TIME_UNSET);
-    } else {
-      maskingWindowPositionMs = positionMs;
-      internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
-      for (Player.EventListener listener : listeners) {
-        listener.onPositionDiscontinuity();
-      }
+    internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
+    for (Player.EventListener listener : listeners) {
+      listener.onPositionDiscontinuity(DISCONTINUITY_REASON_SEEK);
     }
   }
 
@@ -283,7 +313,7 @@ public void blockingSendMessages(ExoPlayerMessage... messages) {
 
   @Override
   public int getCurrentPeriodIndex() {
-    if (timeline.isEmpty() || pendingSeekAcks > 0) {
+    if (shouldMaskPosition()) {
       return maskingPeriodIndex;
     } else {
       return playbackInfo.periodId.periodIndex;
@@ -292,15 +322,30 @@ public int getCurrentPeriodIndex() {
 
   @Override
   public int getCurrentWindowIndex() {
-    if (timeline.isEmpty() || pendingSeekAcks > 0) {
+    if (shouldMaskPosition()) {
       return maskingWindowIndex;
     } else {
-      return timeline.getPeriod(playbackInfo.periodId.periodIndex, period).windowIndex;
+      return playbackInfo.timeline.getPeriod(playbackInfo.periodId.periodIndex, period).windowIndex;
     }
   }
 
+  @Override
+  public int getNextWindowIndex() {
+    Timeline timeline = playbackInfo.timeline;
+    return timeline.isEmpty() ? C.INDEX_UNSET
+        : timeline.getNextWindowIndex(getCurrentWindowIndex(), repeatMode, shuffleModeEnabled);
+  }
+
+  @Override
+  public int getPreviousWindowIndex() {
+    Timeline timeline = playbackInfo.timeline;
+    return timeline.isEmpty() ? C.INDEX_UNSET
+        : timeline.getPreviousWindowIndex(getCurrentWindowIndex(), repeatMode, shuffleModeEnabled);
+  }
+
   @Override
   public long getDuration() {
+    Timeline timeline = playbackInfo.timeline;
     if (timeline.isEmpty()) {
       return C.TIME_UNSET;
     }
@@ -316,7 +361,7 @@ public long getDuration() {
 
   @Override
   public long getCurrentPosition() {
-    if (timeline.isEmpty() || pendingSeekAcks > 0) {
+    if (shouldMaskPosition()) {
       return maskingWindowPositionMs;
     } else {
       return playbackInfoPositionUsToWindowPositionMs(playbackInfo.positionUs);
@@ -326,7 +371,7 @@ public long getCurrentPosition() {
   @Override
   public long getBufferedPosition() {
     // TODO - Implement this properly.
-    if (timeline.isEmpty() || pendingSeekAcks > 0) {
+    if (shouldMaskPosition()) {
       return maskingWindowPositionMs;
     } else {
       return playbackInfoPositionUsToWindowPositionMs(playbackInfo.bufferedPositionUs);
@@ -335,9 +380,6 @@ public long getBufferedPosition() {
 
   @Override
   public int getBufferedPercentage() {
-    if (timeline.isEmpty()) {
-      return 0;
-    }
     long position = getBufferedPosition();
     long duration = getDuration();
     return position == C.TIME_UNSET || duration == C.TIME_UNSET ? 0
@@ -346,33 +388,35 @@ public int getBufferedPercentage() {
 
   @Override
   public boolean isCurrentWindowDynamic() {
+    Timeline timeline = playbackInfo.timeline;
     return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
   }
 
   @Override
   public boolean isCurrentWindowSeekable() {
+    Timeline timeline = playbackInfo.timeline;
     return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
   }
 
   @Override
   public boolean isPlayingAd() {
-    return pendingSeekAcks == 0 && playbackInfo.periodId.isAd();
+    return !shouldMaskPosition() && playbackInfo.periodId.isAd();
   }
 
   @Override
   public int getCurrentAdGroupIndex() {
-    return pendingSeekAcks == 0 ? playbackInfo.periodId.adGroupIndex : C.INDEX_UNSET;
+    return isPlayingAd() ? playbackInfo.periodId.adGroupIndex : C.INDEX_UNSET;
   }
 
   @Override
   public int getCurrentAdIndexInAdGroup() {
-    return pendingSeekAcks == 0 ? playbackInfo.periodId.adIndexInAdGroup : C.INDEX_UNSET;
+    return isPlayingAd() ? playbackInfo.periodId.adIndexInAdGroup : C.INDEX_UNSET;
   }
 
   @Override
   public long getContentPosition() {
     if (isPlayingAd()) {
-      timeline.getPeriod(playbackInfo.periodId.periodIndex, period);
+      playbackInfo.timeline.getPeriod(playbackInfo.periodId.periodIndex, period);
       return period.getPositionInWindowMs() + C.usToMs(playbackInfo.contentPositionUs);
     } else {
       return getCurrentPosition();
@@ -401,21 +445,17 @@ public TrackSelectionArray getCurrentTrackSelections() {
 
   @Override
   public Timeline getCurrentTimeline() {
-    return timeline;
+    return playbackInfo.timeline;
   }
 
   @Override
   public Object getCurrentManifest() {
-    return manifest;
+    return playbackInfo.manifest;
   }
 
   // Not private so it can be called from an inner class without going through a thunk method.
   /* package */ void handleEvent(Message msg) {
     switch (msg.what) {
-      case ExoPlayerImplInternal.MSG_PREPARE_ACK: {
-        pendingPrepareAcks--;
-        break;
-      }
       case ExoPlayerImplInternal.MSG_STATE_CHANGED: {
         playbackState = msg.arg1;
         for (Player.EventListener listener : listeners) {
@@ -430,6 +470,13 @@ public Object getCurrentManifest() {
         }
         break;
       }
+      case ExoPlayerImplInternal.MSG_SOURCE_INFO_REFRESHED: {
+        int prepareAcks = msg.arg1;
+        int seekAcks = msg.arg2;
+        handlePlaybackInfo((PlaybackInfo) msg.obj, prepareAcks, seekAcks, false,
+            /* ignored */ DISCONTINUITY_REASON_INTERNAL);
+        break;
+      }
       case ExoPlayerImplInternal.MSG_TRACKS_CHANGED: {
         if (pendingPrepareAcks == 0) {
           TrackSelectorResult trackSelectorResult = (TrackSelectorResult) msg.obj;
@@ -444,48 +491,14 @@ public Object getCurrentManifest() {
         break;
       }
       case ExoPlayerImplInternal.MSG_SEEK_ACK: {
-        if (--pendingSeekAcks == 0) {
-          playbackInfo = (ExoPlayerImplInternal.PlaybackInfo) msg.obj;
-          if (timeline.isEmpty()) {
-            // Update the masking variables, which are used when the timeline is empty.
-            maskingPeriodIndex = 0;
-            maskingWindowIndex = 0;
-            maskingWindowPositionMs = 0;
-          }
-          if (msg.arg1 != 0) {
-            for (Player.EventListener listener : listeners) {
-              listener.onPositionDiscontinuity();
-            }
-          }
-        }
+        boolean seekPositionAdjusted = msg.arg1 != 0;
+        handlePlaybackInfo((PlaybackInfo) msg.obj, 0, 1, seekPositionAdjusted,
+            DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
         break;
       }
       case ExoPlayerImplInternal.MSG_POSITION_DISCONTINUITY: {
-        if (pendingSeekAcks == 0) {
-          playbackInfo = (ExoPlayerImplInternal.PlaybackInfo) msg.obj;
-          for (Player.EventListener listener : listeners) {
-            listener.onPositionDiscontinuity();
-          }
-        }
-        break;
-      }
-      case ExoPlayerImplInternal.MSG_SOURCE_INFO_REFRESHED: {
-        SourceInfo sourceInfo = (SourceInfo) msg.obj;
-        pendingSeekAcks -= sourceInfo.seekAcks;
-        if (pendingPrepareAcks == 0) {
-          timeline = sourceInfo.timeline;
-          manifest = sourceInfo.manifest;
-          playbackInfo = sourceInfo.playbackInfo;
-          if (pendingSeekAcks == 0 && timeline.isEmpty()) {
-            // Update the masking variables, which are used when the timeline is empty.
-            maskingPeriodIndex = 0;
-            maskingWindowIndex = 0;
-            maskingWindowPositionMs = 0;
-          }
-          for (Player.EventListener listener : listeners) {
-            listener.onTimelineChanged(timeline, manifest);
-          }
-        }
+        @DiscontinuityReason int discontinuityReason = msg.arg1;
+        handlePlaybackInfo((PlaybackInfo) msg.obj, 0, 0, true, discontinuityReason);
         break;
       }
       case ExoPlayerImplInternal.MSG_PLAYBACK_PARAMETERS_CHANGED: {
@@ -510,13 +523,50 @@ public Object getCurrentManifest() {
     }
   }
 
+  private void handlePlaybackInfo(PlaybackInfo playbackInfo, int prepareAcks, int seekAcks,
+      boolean positionDiscontinuity, @DiscontinuityReason int positionDiscontinuityReason) {
+    Assertions.checkNotNull(playbackInfo.timeline);
+    pendingPrepareAcks -= prepareAcks;
+    pendingSeekAcks -= seekAcks;
+    if (pendingPrepareAcks == 0 && pendingSeekAcks == 0) {
+      boolean timelineOrManifestChanged = this.playbackInfo.timeline != playbackInfo.timeline
+          || this.playbackInfo.manifest != playbackInfo.manifest;
+      this.playbackInfo = playbackInfo;
+      if (playbackInfo.timeline.isEmpty()) {
+        // Update the masking variables, which are used when the timeline is empty.
+        maskingPeriodIndex = 0;
+        maskingWindowIndex = 0;
+        maskingWindowPositionMs = 0;
+      }
+      if (timelineOrManifestChanged) {
+        for (Player.EventListener listener : listeners) {
+          listener.onTimelineChanged(playbackInfo.timeline, playbackInfo.manifest);
+        }
+      }
+      if (positionDiscontinuity) {
+        for (Player.EventListener listener : listeners) {
+          listener.onPositionDiscontinuity(positionDiscontinuityReason);
+        }
+      }
+    }
+    if (pendingSeekAcks == 0 && seekAcks > 0) {
+      for (Player.EventListener listener : listeners) {
+        listener.onSeekProcessed();
+      }
+    }
+  }
+
   private long playbackInfoPositionUsToWindowPositionMs(long positionUs) {
     long positionMs = C.usToMs(positionUs);
     if (!playbackInfo.periodId.isAd()) {
-      timeline.getPeriod(playbackInfo.periodId.periodIndex, period);
+      playbackInfo.timeline.getPeriod(playbackInfo.periodId.periodIndex, period);
       positionMs += period.getPositionInWindowMs();
     }
     return positionMs;
   }
 
+  private boolean shouldMaskPosition() {
+    return playbackInfo.timeline.isEmpty() || pendingSeekAcks > 0 || pendingPrepareAcks > 0;
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index b8274126b5..4d1767b64c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -21,11 +21,13 @@
 import android.os.Message;
 import android.os.Process;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.ExoPlayer.ExoPlayerMessage;
 import com.google.android.exoplayer2.MediaPeriodInfoSequence.MediaPeriodInfo;
 import com.google.android.exoplayer2.source.ClippingMediaPeriod;
+import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
@@ -46,73 +48,17 @@
 /* package */ final class ExoPlayerImplInternal implements Handler.Callback,
     MediaPeriod.Callback, TrackSelector.InvalidationListener, MediaSource.Listener {
 
-  /**
-   * Playback position information which is read on the application's thread by
-   * {@link ExoPlayerImpl} and read/written internally on the player's thread.
-   */
-  public static final class PlaybackInfo {
-
-    public final MediaPeriodId periodId;
-    public final long startPositionUs;
-    public final long contentPositionUs;
-
-    public volatile long positionUs;
-    public volatile long bufferedPositionUs;
-
-    public PlaybackInfo(int periodIndex, long startPositionUs) {
-      this(new MediaPeriodId(periodIndex), startPositionUs);
-    }
-
-    public PlaybackInfo(MediaPeriodId periodId, long startPositionUs) {
-      this(periodId, startPositionUs, C.TIME_UNSET);
-    }
-
-    public PlaybackInfo(MediaPeriodId periodId, long startPositionUs, long contentPositionUs) {
-      this.periodId = periodId;
-      this.startPositionUs = startPositionUs;
-      this.contentPositionUs = contentPositionUs;
-      positionUs = startPositionUs;
-      bufferedPositionUs = startPositionUs;
-    }
-
-    public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
-      PlaybackInfo playbackInfo = new PlaybackInfo(periodId.copyWithPeriodIndex(periodIndex),
-          startPositionUs, contentPositionUs);
-      playbackInfo.positionUs = positionUs;
-      playbackInfo.bufferedPositionUs = bufferedPositionUs;
-      return playbackInfo;
-    }
-
-  }
-
-  public static final class SourceInfo {
-
-    public final Timeline timeline;
-    public final Object manifest;
-    public final PlaybackInfo playbackInfo;
-    public final int seekAcks;
-
-    public SourceInfo(Timeline timeline, Object manifest, PlaybackInfo playbackInfo, int seekAcks) {
-      this.timeline = timeline;
-      this.manifest = manifest;
-      this.playbackInfo = playbackInfo;
-      this.seekAcks = seekAcks;
-    }
-
-  }
-
   private static final String TAG = "ExoPlayerImplInternal";
 
   // External messages
-  public static final int MSG_PREPARE_ACK = 0;
-  public static final int MSG_STATE_CHANGED = 1;
-  public static final int MSG_LOADING_CHANGED = 2;
-  public static final int MSG_TRACKS_CHANGED = 3;
-  public static final int MSG_SEEK_ACK = 4;
-  public static final int MSG_POSITION_DISCONTINUITY = 5;
-  public static final int MSG_SOURCE_INFO_REFRESHED = 6;
-  public static final int MSG_PLAYBACK_PARAMETERS_CHANGED = 7;
-  public static final int MSG_ERROR = 8;
+  public static final int MSG_STATE_CHANGED = 0;
+  public static final int MSG_LOADING_CHANGED = 1;
+  public static final int MSG_TRACKS_CHANGED = 2;
+  public static final int MSG_SEEK_ACK = 3;
+  public static final int MSG_POSITION_DISCONTINUITY = 4;
+  public static final int MSG_SOURCE_INFO_REFRESHED = 5;
+  public static final int MSG_PLAYBACK_PARAMETERS_CHANGED = 6;
+  public static final int MSG_ERROR = 7;
 
   // Internal messages
   private static final int MSG_PREPARE = 0;
@@ -128,6 +74,7 @@ public SourceInfo(Timeline timeline, Object manifest, PlaybackInfo playbackInfo,
   private static final int MSG_TRACK_SELECTION_INVALIDATED = 10;
   private static final int MSG_CUSTOM = 11;
   private static final int MSG_SET_REPEAT_MODE = 12;
+  private static final int MSG_SET_SHUFFLE_ENABLED = 13;
 
   private static final int PREPARING_SOURCE_INTERVAL_MS = 10;
   private static final int RENDERING_INTERVAL_MS = 10;
@@ -173,10 +120,12 @@ public SourceInfo(Timeline timeline, Object manifest, PlaybackInfo playbackInfo,
   private boolean isLoading;
   private int state;
   private @Player.RepeatMode int repeatMode;
+  private boolean shuffleModeEnabled;
   private int customMessagesSent;
   private int customMessagesProcessed;
   private long elapsedRealtimeUs;
 
+  private int pendingPrepareCount;
   private int pendingInitialSeekCount;
   private SeekPosition pendingSeekPosition;
   private long rendererPositionUs;
@@ -185,21 +134,20 @@ public SourceInfo(Timeline timeline, Object manifest, PlaybackInfo playbackInfo,
   private MediaPeriodHolder readingPeriodHolder;
   private MediaPeriodHolder playingPeriodHolder;
 
-  private Timeline timeline;
-
   public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl, boolean playWhenReady, @Player.RepeatMode int repeatMode,
-      Handler eventHandler, PlaybackInfo playbackInfo, ExoPlayer player) {
+      boolean shuffleModeEnabled, Handler eventHandler, ExoPlayer player) {
     this.renderers = renderers;
     this.trackSelector = trackSelector;
     this.loadControl = loadControl;
     this.playWhenReady = playWhenReady;
     this.repeatMode = repeatMode;
+    this.shuffleModeEnabled = shuffleModeEnabled;
     this.eventHandler = eventHandler;
     this.state = Player.STATE_IDLE;
-    this.playbackInfo = playbackInfo;
     this.player = player;
 
+    playbackInfo = new PlaybackInfo(null, null, 0, C.TIME_UNSET);
     rendererCapabilities = new RendererCapabilities[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
       renderers[i].setIndex(i);
@@ -234,6 +182,10 @@ public void setRepeatMode(@Player.RepeatMode int repeatMode) {
     handler.obtainMessage(MSG_SET_REPEAT_MODE, repeatMode, 0).sendToTarget();
   }
 
+  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    handler.obtainMessage(MSG_SET_SHUFFLE_ENABLED, shuffleModeEnabled ? 1 : 0, 0).sendToTarget();
+  }
+
   public void seekTo(Timeline timeline, int windowIndex, long positionUs) {
     handler.obtainMessage(MSG_SEEK_TO, new SeekPosition(timeline, windowIndex, positionUs))
         .sendToTarget();
@@ -294,7 +246,6 @@ public synchronized void release() {
       // Restore the interrupted status.
       Thread.currentThread().interrupt();
     }
-    internalPlaybackThread.quit();
   }
 
   public Looper getPlaybackLooper() {
@@ -304,8 +255,9 @@ public Looper getPlaybackLooper() {
   // MediaSource.Listener implementation.
 
   @Override
-  public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
-    handler.obtainMessage(MSG_REFRESH_SOURCE_INFO, Pair.create(timeline, manifest)).sendToTarget();
+  public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
+    handler.obtainMessage(MSG_REFRESH_SOURCE_INFO,
+        new MediaSourceRefreshInfo(source, timeline, manifest)).sendToTarget();
   }
 
   // MediaPeriod.Callback implementation.
@@ -346,6 +298,10 @@ public boolean handleMessage(Message msg) {
           setRepeatModeInternal(msg.arg1);
           return true;
         }
+        case MSG_SET_SHUFFLE_ENABLED: {
+          setShuffleModeEnabledInternal(msg.arg1 != 0);
+          return true;
+        }
         case MSG_DO_SOME_WORK: {
           doSomeWork();
           return true;
@@ -371,7 +327,7 @@ public boolean handleMessage(Message msg) {
           return true;
         }
         case MSG_REFRESH_SOURCE_INFO: {
-          handleSourceInfoRefreshed((Pair<Timeline, Object>) msg.obj);
+          handleSourceInfoRefreshed((MediaSourceRefreshInfo) msg.obj);
           return true;
         }
         case MSG_SOURCE_CONTINUE_LOADING_REQUESTED: {
@@ -425,11 +381,15 @@ private void setIsLoading(boolean isLoading) {
   }
 
   private void prepareInternal(MediaSource mediaSource, boolean resetPosition) {
-    eventHandler.sendEmptyMessage(MSG_PREPARE_ACK);
+    pendingPrepareCount++;
     resetInternal(true);
     loadControl.onPrepared();
     if (resetPosition) {
-      playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
+      playbackInfo = new PlaybackInfo(null, null, 0, C.TIME_UNSET);
+    } else {
+      // The new start position is the current playback position.
+      playbackInfo = new PlaybackInfo(null, null, playbackInfo.periodId, playbackInfo.positionUs,
+          playbackInfo.contentPositionUs);
     }
     this.mediaSource = mediaSource;
     mediaSource.prepareSource(player, true, this);
@@ -457,7 +417,17 @@ private void setRepeatModeInternal(@Player.RepeatMode int repeatMode)
       throws ExoPlaybackException {
     this.repeatMode = repeatMode;
     mediaPeriodInfoSequence.setRepeatMode(repeatMode);
+    validateExistingPeriodHolders();
+  }
+
+  private void setShuffleModeEnabledInternal(boolean shuffleModeEnabled)
+      throws ExoPlaybackException {
+    this.shuffleModeEnabled = shuffleModeEnabled;
+    mediaPeriodInfoSequence.setShuffleModeEnabled(shuffleModeEnabled);
+    validateExistingPeriodHolders();
+  }
 
+  private void validateExistingPeriodHolders() throws ExoPlaybackException {
     // Find the last existing period holder that matches the new period order.
     MediaPeriodHolder lastValidPeriodHolder = playingPeriodHolder != null
         ? playingPeriodHolder : loadingPeriodHolder;
@@ -465,8 +435,9 @@ private void setRepeatModeInternal(@Player.RepeatMode int repeatMode)
       return;
     }
     while (true) {
-      int nextPeriodIndex = timeline.getNextPeriodIndex(lastValidPeriodHolder.info.id.periodIndex,
-          period, window, repeatMode);
+      int nextPeriodIndex = playbackInfo.timeline.getNextPeriodIndex(
+          lastValidPeriodHolder.info.id.periodIndex, period, window, repeatMode,
+          shuffleModeEnabled);
       while (lastValidPeriodHolder.next != null
           && !lastValidPeriodHolder.info.isLastInTimelinePeriod) {
         lastValidPeriodHolder = lastValidPeriodHolder.next;
@@ -503,7 +474,12 @@ private void setRepeatModeInternal(@Player.RepeatMode int repeatMode)
       // position of the playing period to make sure none of the removed period is played.
       MediaPeriodId periodId = playingPeriodHolder.info.id;
       long newPositionUs = seekToPeriodPosition(periodId, playbackInfo.positionUs);
-      playbackInfo = new PlaybackInfo(periodId, newPositionUs, playbackInfo.contentPositionUs);
+      if (newPositionUs != playbackInfo.positionUs) {
+        playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs,
+            playbackInfo.contentPositionUs);
+        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,
+            0, playbackInfo).sendToTarget();
+      }
     }
   }
 
@@ -531,12 +507,22 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
     long periodPositionUs = playingPeriodHolder.mediaPeriod.readDiscontinuity();
     if (periodPositionUs != C.TIME_UNSET) {
       resetRendererPosition(periodPositionUs);
+      playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
+          playbackInfo.contentPositionUs);
+      eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,
+          0, playbackInfo).sendToTarget();
     } else {
-      if (rendererMediaClockSource != null && !rendererMediaClockSource.isEnded()) {
+      // Use the standalone clock if there's no renderer clock, or if the providing renderer has
+      // ended or needs the next sample stream to reenter the ready state. The latter case uses the
+      // standalone clock to avoid getting stuck if tracks in the current period have uneven
+      // durations. See: https://github.com/google/ExoPlayer/issues/1874.
+      if (rendererMediaClockSource == null || rendererMediaClockSource.isEnded()
+          || (!rendererMediaClockSource.isReady()
+              && rendererWaitingForNextStream(rendererMediaClockSource))) {
+        rendererPositionUs = standaloneMediaClock.getPositionUs();
+      } else {
         rendererPositionUs = rendererMediaClock.getPositionUs();
         standaloneMediaClock.setPositionUs(rendererPositionUs);
-      } else {
-        rendererPositionUs = standaloneMediaClock.getPositionUs();
       }
       periodPositionUs = playingPeriodHolder.toPeriodTime(rendererPositionUs);
     }
@@ -573,9 +559,12 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
       // invocation of this method.
       renderer.render(rendererPositionUs, elapsedRealtimeUs);
       allRenderersEnded = allRenderersEnded && renderer.isEnded();
-      // Determine whether the renderer is ready (or ended). If it's not, throw an error that's
-      // preventing the renderer from making progress, if such an error exists.
-      boolean rendererReadyOrEnded = renderer.isReady() || renderer.isEnded();
+      // Determine whether the renderer is ready (or ended). We override to assume the renderer is
+      // ready if it needs the next sample stream. This is necessary to avoid getting stuck if
+      // tracks in the current period have uneven durations. See:
+      // https://github.com/google/ExoPlayer/issues/1874
+      boolean rendererReadyOrEnded = renderer.isReady() || renderer.isEnded()
+          || rendererWaitingForNextStream(renderer);
       if (!rendererReadyOrEnded) {
         renderer.maybeThrowStreamError();
       }
@@ -593,7 +582,7 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
         // TODO: Make LoadControl, period transition position projection, adaptive track selection
         // and potentially any time-related code in renderers take into account the playback speed.
         this.playbackParameters = playbackParameters;
-        standaloneMediaClock.synchronize(rendererMediaClock);
+        standaloneMediaClock.setPlaybackParameters(playbackParameters);
         eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters)
             .sendToTarget();
       }
@@ -656,6 +645,7 @@ private void scheduleNextWork(long thisOperationStartTimeMs, long intervalMs) {
   }
 
   private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackException {
+    Timeline timeline = playbackInfo.timeline;
     if (timeline == null) {
       pendingInitialSeekCount++;
       pendingSeekPosition = seekPosition;
@@ -664,14 +654,16 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
 
     Pair<Integer, Long> periodPosition = resolveSeekPosition(seekPosition);
     if (periodPosition == null) {
+      int firstPeriodIndex = timeline.isEmpty() ? 0 : timeline.getWindow(
+          timeline.getFirstWindowIndex(shuffleModeEnabled), window).firstPeriodIndex;
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed and a suitable seek position could not be resolved in the new one.
-      playbackInfo = new PlaybackInfo(0, 0);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, 1, 0, playbackInfo).sendToTarget();
-      // Set the internal position to (0,TIME_UNSET) so that a subsequent seek to (0,0) isn't
-      // ignored.
-      playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
+      // Set the internal position to (firstPeriodIndex,TIME_UNSET) so that a subsequent seek to
+      // (firstPeriodIndex,0) isn't ignored.
+      playbackInfo = playbackInfo.fromNewPosition(firstPeriodIndex, C.TIME_UNSET, C.TIME_UNSET);
       setState(Player.STATE_ENDED);
+      eventHandler.obtainMessage(MSG_SEEK_ACK, 1, 0,
+          playbackInfo.fromNewPosition(firstPeriodIndex, 0, C.TIME_UNSET)).sendToTarget();
       // Reset, but retain the source so that it can still be used should a seek occur.
       resetInternal(false);
       return;
@@ -697,7 +689,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       seekPositionAdjusted |= periodPositionUs != newPeriodPositionUs;
       periodPositionUs = newPeriodPositionUs;
     } finally {
-      playbackInfo = new PlaybackInfo(periodId, periodPositionUs, contentPositionUs);
+      playbackInfo = playbackInfo.fromNewPosition(periodId, periodPositionUs, contentPositionUs);
       eventHandler.obtainMessage(MSG_SEEK_ACK, seekPositionAdjusted ? 1 : 0, 0, playbackInfo)
           .sendToTarget();
     }
@@ -719,7 +711,8 @@ private long seekToPeriodPosition(MediaPeriodId periodId, long periodPositionUs)
       // Clear the timeline, but keep the requested period if it is already prepared.
       MediaPeriodHolder periodHolder = playingPeriodHolder;
       while (periodHolder != null) {
-        if (shouldKeepPeriodHolder(periodId, periodPositionUs, periodHolder)) {
+        if (newPlayingPeriodHolder == null
+            && shouldKeepPeriodHolder(periodId, periodPositionUs, periodHolder)) {
           newPlayingPeriodHolder = periodHolder;
         } else {
           periodHolder.release();
@@ -733,11 +726,9 @@ private long seekToPeriodPosition(MediaPeriodId periodId, long periodPositionUs)
     if (playingPeriodHolder != newPlayingPeriodHolder
         || playingPeriodHolder != readingPeriodHolder) {
       for (Renderer renderer : enabledRenderers) {
-        renderer.disable();
+        disableRenderer(renderer);
       }
       enabledRenderers = new Renderer[0];
-      rendererMediaClock = null;
-      rendererMediaClockSource = null;
       playingPeriodHolder = null;
     }
 
@@ -766,7 +757,7 @@ private long seekToPeriodPosition(MediaPeriodId periodId, long periodPositionUs)
   private boolean shouldKeepPeriodHolder(MediaPeriodId seekPeriodId, long positionUs,
       MediaPeriodHolder holder) {
     if (seekPeriodId.equals(holder.info.id) && holder.prepared) {
-      timeline.getPeriod(holder.info.id.periodIndex, period);
+      playbackInfo.timeline.getPeriod(holder.info.id.periodIndex, period);
       int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(positionUs);
       if (nextAdGroupIndex == C.INDEX_UNSET
           || period.getAdGroupTimeUs(nextAdGroupIndex) == holder.info.endPositionUs) {
@@ -787,9 +778,10 @@ private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackExce
   }
 
   private void setPlaybackParametersInternal(PlaybackParameters playbackParameters) {
-    playbackParameters = rendererMediaClock != null
-        ? rendererMediaClock.setPlaybackParameters(playbackParameters)
-        : standaloneMediaClock.setPlaybackParameters(playbackParameters);
+    if (rendererMediaClock != null) {
+      playbackParameters = rendererMediaClock.setPlaybackParameters(playbackParameters);
+    }
+    standaloneMediaClock.setPlaybackParameters(playbackParameters);
     this.playbackParameters = playbackParameters;
     eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters).sendToTarget();
   }
@@ -804,6 +796,7 @@ private void releaseInternal() {
     resetInternal(true);
     loadControl.onReleased();
     setState(Player.STATE_IDLE);
+    internalPlaybackThread.quit();
     synchronized (this) {
       released = true;
       notifyAll();
@@ -814,13 +807,10 @@ private void resetInternal(boolean releaseMediaSource) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
     standaloneMediaClock.stop();
-    rendererMediaClock = null;
-    rendererMediaClockSource = null;
     rendererPositionUs = RENDERER_TIMESTAMP_OFFSET_US;
     for (Renderer renderer : enabledRenderers) {
       try {
-        ensureStopped(renderer);
-        renderer.disable();
+        disableRenderer(renderer);
       } catch (ExoPlaybackException | RuntimeException e) {
         // There's nothing we can do.
         Log.e(TAG, "Stop failed.", e);
@@ -839,7 +829,7 @@ private void resetInternal(boolean releaseMediaSource) {
         mediaSource = null;
       }
       mediaPeriodInfoSequence.setTimeline(null);
-      timeline = null;
+      playbackInfo = playbackInfo.copyWithTimeline(null, null);
     }
   }
 
@@ -866,6 +856,15 @@ private void ensureStopped(Renderer renderer) throws ExoPlaybackException {
     }
   }
 
+  private void disableRenderer(Renderer renderer) throws ExoPlaybackException {
+    if (renderer == rendererMediaClockSource) {
+      rendererMediaClock = null;
+      rendererMediaClockSource = null;
+    }
+    ensureStopped(renderer);
+    renderer.disable();
+  }
+
   private void reselectTracksInternal() throws ExoPlaybackException {
     if (playingPeriodHolder == null) {
       // We don't have tracks yet, so we don't care.
@@ -901,8 +900,11 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       boolean[] streamResetFlags = new boolean[renderers.length];
       long periodPositionUs = playingPeriodHolder.updatePeriodTrackSelection(
           playbackInfo.positionUs, recreateStreams, streamResetFlags);
-      if (periodPositionUs != playbackInfo.positionUs) {
-        playbackInfo.positionUs = periodPositionUs;
+      if (state != Player.STATE_ENDED && periodPositionUs != playbackInfo.positionUs) {
+        playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
+            playbackInfo.contentPositionUs);
+        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,
+            0, playbackInfo).sendToTarget();
         resetRendererPosition(periodPositionUs);
       }
 
@@ -918,18 +920,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
         if (rendererWasEnabledFlags[i]) {
           if (sampleStream != renderer.getStream()) {
             // We need to disable the renderer.
-            if (renderer == rendererMediaClockSource) {
-              // The renderer is providing the media clock.
-              if (sampleStream == null) {
-                // The renderer won't be re-enabled. Sync standaloneMediaClock so that it can take
-                // over timing responsibilities.
-                standaloneMediaClock.synchronize(rendererMediaClock);
-              }
-              rendererMediaClock = null;
-              rendererMediaClockSource = null;
-            }
-            ensureStopped(renderer);
-            renderer.disable();
+            disableRenderer(renderer);
           } else if (streamResetFlags[i]) {
             // The renderer will continue to consume from its current stream, but needs to be reset.
             renderer.resetPosition(rendererPositionUs);
@@ -954,9 +945,11 @@ private void reselectTracksInternal() throws ExoPlaybackException {
         loadingPeriodHolder.updatePeriodTrackSelection(loadingPeriodPositionUs, false);
       }
     }
-    maybeContinueLoading();
-    updatePlaybackPositions();
-    handler.sendEmptyMessage(MSG_DO_SOME_WORK);
+    if (state != Player.STATE_ENDED) {
+      maybeContinueLoading();
+      updatePlaybackPositions();
+      handler.sendEmptyMessage(MSG_DO_SOME_WORK);
+    }
   }
 
   private boolean isTimelineReady(long playingPeriodDurationUs) {
@@ -978,14 +971,22 @@ private void maybeThrowPeriodPrepareError() throws IOException {
     }
   }
 
-  private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifest)
+  private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       throws ExoPlaybackException {
-    Timeline oldTimeline = timeline;
-    timeline = timelineAndManifest.first;
+    if (sourceRefreshInfo.source != mediaSource) {
+      // Stale event.
+      return;
+    }
+
+    Timeline oldTimeline = playbackInfo.timeline;
+    Timeline timeline = sourceRefreshInfo.timeline;
+    Object manifest = sourceRefreshInfo.manifest;
     mediaPeriodInfoSequence.setTimeline(timeline);
-    Object manifest = timelineAndManifest.second;
+    playbackInfo = playbackInfo.copyWithTimeline(timeline, manifest);
 
     if (oldTimeline == null) {
+      int processedPrepareAcks = pendingPrepareCount;
+      pendingPrepareCount = 0;
       if (pendingInitialSeekCount > 0) {
         Pair<Integer, Long> periodPosition = resolveSeekPosition(pendingSeekPosition);
         int processedInitialSeekCount = pendingInitialSeekCount;
@@ -994,30 +995,32 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
         if (periodPosition == null) {
           // The seek position was valid for the timeline that it was performed into, but the
           // timeline has changed and a suitable seek position could not be resolved in the new one.
-          handleSourceInfoRefreshEndedPlayback(manifest, processedInitialSeekCount);
+          handleSourceInfoRefreshEndedPlayback(processedPrepareAcks, processedInitialSeekCount);
         } else {
           int periodIndex = periodPosition.first;
           long positionUs = periodPosition.second;
           MediaPeriodId periodId =
               mediaPeriodInfoSequence.resolvePeriodPositionForAds(periodIndex, positionUs);
-          playbackInfo = new PlaybackInfo(periodId, periodId.isAd() ? 0 : positionUs, positionUs);
-          notifySourceInfoRefresh(manifest, processedInitialSeekCount);
+          playbackInfo = playbackInfo.fromNewPosition(periodId, periodId.isAd() ? 0 : positionUs,
+              positionUs);
+          notifySourceInfoRefresh(processedPrepareAcks, processedInitialSeekCount);
         }
       } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {
         if (timeline.isEmpty()) {
-          handleSourceInfoRefreshEndedPlayback(manifest);
+          handleSourceInfoRefreshEndedPlayback(processedPrepareAcks, 0);
         } else {
-          Pair<Integer, Long> defaultPosition = getPeriodPosition(0, C.TIME_UNSET);
+          Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline,
+              timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
           int periodIndex = defaultPosition.first;
           long startPositionUs = defaultPosition.second;
           MediaPeriodId periodId = mediaPeriodInfoSequence.resolvePeriodPositionForAds(periodIndex,
               startPositionUs);
-          playbackInfo = new PlaybackInfo(periodId, periodId.isAd() ? 0 : startPositionUs,
-              startPositionUs);
-          notifySourceInfoRefresh(manifest);
+          playbackInfo = playbackInfo.fromNewPosition(periodId,
+              periodId.isAd() ? 0 : startPositionUs, startPositionUs);
+          notifySourceInfoRefresh(processedPrepareAcks, 0);
         }
       } else {
-        notifySourceInfoRefresh(manifest);
+        notifySourceInfoRefresh(processedPrepareAcks, 0);
       }
       return;
     }
@@ -1026,7 +1029,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
     MediaPeriodHolder periodHolder = playingPeriodHolder != null ? playingPeriodHolder
         : loadingPeriodHolder;
     if (periodHolder == null && playingPeriodIndex >= oldTimeline.getPeriodCount()) {
-      notifySourceInfoRefresh(manifest);
+      notifySourceInfoRefresh();
       return;
     }
     Object playingPeriodUid = periodHolder == null
@@ -1038,11 +1041,11 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       int newPeriodIndex = resolveSubsequentPeriod(playingPeriodIndex, oldTimeline, timeline);
       if (newPeriodIndex == C.INDEX_UNSET) {
         // We failed to resolve a suitable restart position.
-        handleSourceInfoRefreshEndedPlayback(manifest);
+        handleSourceInfoRefreshEndedPlayback();
         return;
       }
       // We resolved a subsequent period. Seek to the default position in the corresponding window.
-      Pair<Integer, Long> defaultPosition = getPeriodPosition(
+      Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline,
           timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);
       newPeriodIndex = defaultPosition.first;
       long newPositionUs = defaultPosition.second;
@@ -1065,8 +1068,8 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       // Actually do the seek.
       MediaPeriodId periodId = new MediaPeriodId(newPeriodIndex);
       newPositionUs = seekToPeriodPosition(periodId, newPositionUs);
-      playbackInfo = new PlaybackInfo(periodId, newPositionUs);
-      notifySourceInfoRefresh(manifest);
+      playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs, C.TIME_UNSET);
+      notifySourceInfoRefresh();
       return;
     }
 
@@ -1082,15 +1085,15 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       if (!periodId.isAd() || periodId.adIndexInAdGroup != playbackInfo.periodId.adIndexInAdGroup) {
         long newPositionUs = seekToPeriodPosition(periodId, playbackInfo.contentPositionUs);
         long contentPositionUs = periodId.isAd() ? playbackInfo.contentPositionUs : C.TIME_UNSET;
-        playbackInfo = new PlaybackInfo(periodId, newPositionUs, contentPositionUs);
-        notifySourceInfoRefresh(manifest);
+        playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs, contentPositionUs);
+        notifySourceInfoRefresh();
         return;
       }
     }
 
     if (periodHolder == null) {
       // We don't have any period holders, so we're done.
-      notifySourceInfoRefresh(manifest);
+      notifySourceInfoRefresh();
       return;
     }
 
@@ -1100,7 +1103,8 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
     while (periodHolder.next != null) {
       MediaPeriodHolder previousPeriodHolder = periodHolder;
       periodHolder = periodHolder.next;
-      periodIndex = timeline.getNextPeriodIndex(periodIndex, period, window, repeatMode);
+      periodIndex = timeline.getNextPeriodIndex(periodIndex, period, window, repeatMode,
+          shuffleModeEnabled);
       if (periodIndex != C.INDEX_UNSET
           && periodHolder.uid.equals(timeline.getPeriod(periodIndex, period, true).uid)) {
         // The holder is consistent with the new timeline. Update its index and continue.
@@ -1114,7 +1118,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
           // position of the playing period to make sure none of the removed period is played.
           long newPositionUs =
               seekToPeriodPosition(playingPeriodHolder.info.id, playbackInfo.positionUs);
-          playbackInfo = new PlaybackInfo(playingPeriodHolder.info.id, newPositionUs,
+          playbackInfo = playbackInfo.fromNewPosition(playingPeriodHolder.info.id, newPositionUs,
               playbackInfo.contentPositionUs);
         } else {
           // Update the loading period to be the last period that's still valid, and release all
@@ -1128,7 +1132,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       }
     }
 
-    notifySourceInfoRefresh(manifest);
+    notifySourceInfoRefresh();
   }
 
   private MediaPeriodHolder updatePeriodInfo(MediaPeriodHolder periodHolder, int periodIndex) {
@@ -1142,29 +1146,36 @@ private MediaPeriodHolder updatePeriodInfo(MediaPeriodHolder periodHolder, int p
     }
   }
 
-  private void handleSourceInfoRefreshEndedPlayback(Object manifest) {
-    handleSourceInfoRefreshEndedPlayback(manifest, 0);
+  private void handleSourceInfoRefreshEndedPlayback() {
+    handleSourceInfoRefreshEndedPlayback(0, 0);
   }
 
-  private void handleSourceInfoRefreshEndedPlayback(Object manifest,
-      int processedInitialSeekCount) {
-    // Set the playback position to (0,0) for notifying the eventHandler.
-    playbackInfo = new PlaybackInfo(0, 0);
-    notifySourceInfoRefresh(manifest, processedInitialSeekCount);
-    // Set the internal position to (0,TIME_UNSET) so that a subsequent seek to (0,0) isn't ignored.
-    playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
+  private void handleSourceInfoRefreshEndedPlayback(int prepareAcks, int seekAcks) {
+    Timeline timeline = playbackInfo.timeline;
+    int firstPeriodIndex = timeline.isEmpty() ? 0 : timeline.getWindow(
+        timeline.getFirstWindowIndex(shuffleModeEnabled), window).firstPeriodIndex;
+    // Set the internal position to (firstPeriodIndex,TIME_UNSET) so that a subsequent seek to
+    // (firstPeriodIndex,0) isn't ignored.
+    playbackInfo = playbackInfo.fromNewPosition(firstPeriodIndex, C.TIME_UNSET, C.TIME_UNSET);
     setState(Player.STATE_ENDED);
+    // Set the playback position to (firstPeriodIndex,0) for notifying the eventHandler.
+    notifySourceInfoRefresh(prepareAcks, seekAcks,
+        playbackInfo.fromNewPosition(firstPeriodIndex, 0, C.TIME_UNSET));
     // Reset, but retain the source so that it can still be used should a seek occur.
     resetInternal(false);
   }
 
-  private void notifySourceInfoRefresh(Object manifest) {
-    notifySourceInfoRefresh(manifest, 0);
+  private void notifySourceInfoRefresh() {
+    notifySourceInfoRefresh(0, 0);
   }
 
-  private void notifySourceInfoRefresh(Object manifest, int processedInitialSeekCount) {
-    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED,
-        new SourceInfo(timeline, manifest, playbackInfo, processedInitialSeekCount)).sendToTarget();
+  private void notifySourceInfoRefresh(int prepareAcks, int seekAcks) {
+    notifySourceInfoRefresh(prepareAcks, seekAcks, playbackInfo);
+  }
+
+  private void notifySourceInfoRefresh(int prepareAcks, int seekAcks, PlaybackInfo playbackInfo) {
+    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED, prepareAcks, seekAcks, playbackInfo)
+        .sendToTarget();
   }
 
   /**
@@ -1182,7 +1193,8 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
     int newPeriodIndex = C.INDEX_UNSET;
     int maxIterations = oldTimeline.getPeriodCount();
     for (int i = 0; i < maxIterations && newPeriodIndex == C.INDEX_UNSET; i++) {
-      oldPeriodIndex = oldTimeline.getNextPeriodIndex(oldPeriodIndex, period, window, repeatMode);
+      oldPeriodIndex = oldTimeline.getNextPeriodIndex(oldPeriodIndex, period, window, repeatMode,
+          shuffleModeEnabled);
       if (oldPeriodIndex == C.INDEX_UNSET) {
         // We've reached the end of the old timeline.
         break;
@@ -1203,6 +1215,7 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    *     bounds of the timeline.
    */
   private Pair<Integer, Long> resolveSeekPosition(SeekPosition seekPosition) {
+    Timeline timeline = playbackInfo.timeline;
     Timeline seekTimeline = seekPosition.timeline;
     if (seekTimeline.isEmpty()) {
       // The application performed a blind seek without a non-empty timeline (most likely based on
@@ -1234,7 +1247,8 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
     periodIndex = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
     if (periodIndex != C.INDEX_UNSET) {
       // We found one. Map the SeekPosition onto the corresponding default position.
-      return getPeriodPosition(timeline.getPeriod(periodIndex, period).windowIndex, C.TIME_UNSET);
+      return getPeriodPosition(timeline, timeline.getPeriod(periodIndex, period).windowIndex,
+          C.TIME_UNSET);
     }
     // We didn't find one. Give up.
     return null;
@@ -1244,12 +1258,13 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * Calls {@link Timeline#getPeriodPosition(Timeline.Window, Timeline.Period, int, long)} using the
    * current timeline.
    */
-  private Pair<Integer, Long> getPeriodPosition(int windowIndex, long windowPositionUs) {
+  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
+      long windowPositionUs) {
     return timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs);
   }
 
   private void updatePeriods() throws ExoPlaybackException, IOException {
-    if (timeline == null) {
+    if (playbackInfo.timeline == null) {
       // We're waiting to get information about periods.
       mediaSource.maybeThrowSourceInfoRefreshError();
       return;
@@ -1268,17 +1283,18 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       return;
     }
 
-    // Update the playing and reading periods.
-    while (playingPeriodHolder != readingPeriodHolder
+    // Advance the playing period if necessary.
+    while (playWhenReady && playingPeriodHolder != readingPeriodHolder
         && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
       // All enabled renderers' streams have been read to the end, and the playback position reached
       // the end of the playing period, so advance playback to the next period.
       playingPeriodHolder.release();
       setPlayingPeriodHolder(playingPeriodHolder.next);
-      playbackInfo = new PlaybackInfo(playingPeriodHolder.info.id,
+      playbackInfo = playbackInfo.fromNewPosition(playingPeriodHolder.info.id,
           playingPeriodHolder.info.startPositionUs, playingPeriodHolder.info.contentPositionUs);
       updatePlaybackPositions();
-      eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
+      eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,
+          Player.DISCONTINUITY_REASON_PERIOD_TRANSITION, 0, playbackInfo).sendToTarget();
     }
 
     if (readingPeriodHolder.info.isFinal) {
@@ -1295,50 +1311,60 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       return;
     }
 
+    // Advance the reading period if necessary.
+    if (readingPeriodHolder.next == null || !readingPeriodHolder.next.prepared) {
+      // We don't have a successor to advance the reading period to.
+      return;
+    }
+
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
       if (renderer.getStream() != sampleStream
           || (sampleStream != null && !renderer.hasReadStreamToEnd())) {
+        // The current reading period is still being read by at least one renderer.
         return;
       }
     }
 
-    if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
-      TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
-      readingPeriodHolder = readingPeriodHolder.next;
-      TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
+    TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
+    readingPeriodHolder = readingPeriodHolder.next;
+    TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
 
-      boolean initialDiscontinuity =
-          readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
-      for (int i = 0; i < renderers.length; i++) {
-        Renderer renderer = renderers[i];
-        TrackSelection oldSelection = oldTrackSelectorResult.selections.get(i);
-        if (oldSelection == null) {
-          // The renderer has no current stream and will be enabled when we play the next period.
-        } else if (initialDiscontinuity) {
-          // The new period starts with a discontinuity, so the renderer will play out all data then
-          // be disabled and re-enabled when it starts playing the next period.
+    boolean initialDiscontinuity =
+        readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
+    for (int i = 0; i < renderers.length; i++) {
+      Renderer renderer = renderers[i];
+      boolean rendererWasEnabled = oldTrackSelectorResult.renderersEnabled[i];
+      if (!rendererWasEnabled) {
+        // The renderer was disabled and will be enabled when we play the next period.
+      } else if (initialDiscontinuity) {
+        // The new period starts with a discontinuity, so the renderer will play out all data then
+        // be disabled and re-enabled when it starts playing the next period.
+        renderer.setCurrentStreamFinal();
+      } else if (!renderer.isCurrentStreamFinal()) {
+        TrackSelection newSelection = newTrackSelectorResult.selections.get(i);
+        boolean newRendererEnabled = newTrackSelectorResult.renderersEnabled[i];
+        boolean isNoSampleRenderer = rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE;
+        RendererConfiguration oldConfig = oldTrackSelectorResult.rendererConfigurations[i];
+        RendererConfiguration newConfig = newTrackSelectorResult.rendererConfigurations[i];
+        if (newRendererEnabled && newConfig.equals(oldConfig) && !isNoSampleRenderer) {
+          // Replace the renderer's SampleStream so the transition to playing the next period can
+          // be seamless.
+          // This should be avoided for no-sample renderer, because skipping ahead for such
+          // renderer doesn't have any benefit (the renderer does not consume the sample stream),
+          // and it will change the provided rendererOffsetUs while the renderer is still
+          // rendering from the playing media period.
+          Format[] formats = getFormats(newSelection);
+          renderer.replaceStream(formats, readingPeriodHolder.sampleStreams[i],
+              readingPeriodHolder.getRendererOffset());
+        } else {
+          // The renderer will be disabled when transitioning to playing the next period, because
+          // there's no new selection, or because a configuration change is required, or because
+          // it's a no-sample renderer for which rendererOffsetUs should be updated only when
+          // starting to play the next period. Mark the SampleStream as final to play out any
+          // remaining data.
           renderer.setCurrentStreamFinal();
-        } else if (!renderer.isCurrentStreamFinal()) {
-          TrackSelection newSelection = newTrackSelectorResult.selections.get(i);
-          RendererConfiguration oldConfig = oldTrackSelectorResult.rendererConfigurations[i];
-          RendererConfiguration newConfig = newTrackSelectorResult.rendererConfigurations[i];
-          if (newSelection != null && newConfig.equals(oldConfig)) {
-            // Replace the renderer's SampleStream so the transition to playing the next period can
-            // be seamless.
-            Format[] formats = new Format[newSelection.length()];
-            for (int j = 0; j < formats.length; j++) {
-              formats[j] = newSelection.getFormat(j);
-            }
-            renderer.replaceStream(formats, readingPeriodHolder.sampleStreams[i],
-                readingPeriodHolder.getRendererOffset());
-          } else {
-            // The renderer will be disabled when transitioning to playing the next period, either
-            // because there's no new selection or because a configuration change is required. Mark
-            // the SampleStream as final to play out any remaining data.
-            renderer.setCurrentStreamFinal();
-          }
         }
       }
     }
@@ -1372,7 +1398,7 @@ private void maybeUpdateLoadingPeriod() throws IOException {
         ? RENDERER_TIMESTAMP_OFFSET_US
         : (loadingPeriodHolder.getRendererOffset() + loadingPeriodHolder.info.durationUs);
     int holderIndex = loadingPeriodHolder == null ? 0 : loadingPeriodHolder.index + 1;
-    Object uid = timeline.getPeriod(info.id.periodIndex, period, true).uid;
+    Object uid = playbackInfo.timeline.getPeriod(info.id.periodIndex, period, true).uid;
     MediaPeriodHolder newPeriodHolder = new MediaPeriodHolder(renderers, rendererCapabilities,
         rendererPositionOffsetUs, trackSelector, loadControl, mediaSource, uid, holderIndex, info);
     if (loadingPeriodHolder != null) {
@@ -1431,24 +1457,16 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       rendererWasEnabledFlags[i] = renderer.getState() != Renderer.STATE_DISABLED;
-      TrackSelection newSelection = periodHolder.trackSelectorResult.selections.get(i);
-      if (newSelection != null) {
+      if (periodHolder.trackSelectorResult.renderersEnabled[i]) {
         enabledRendererCount++;
       }
-      if (rendererWasEnabledFlags[i] && (newSelection == null
+      if (rendererWasEnabledFlags[i] && (!periodHolder.trackSelectorResult.renderersEnabled[i]
           || (renderer.isCurrentStreamFinal()
           && renderer.getStream() == playingPeriodHolder.sampleStreams[i]))) {
         // The renderer should be disabled before playing the next period, either because it's not
         // needed to play the next period, or because we need to re-enable it as its current stream
         // is final and it's not reading ahead.
-        if (renderer == rendererMediaClockSource) {
-          // Sync standaloneMediaClock so that it can take over timing responsibilities.
-          standaloneMediaClock.synchronize(rendererMediaClock);
-          rendererMediaClock = null;
-          rendererMediaClockSource = null;
-        }
-        ensureStopped(renderer);
-        renderer.disable();
+        disableRenderer(renderer);
       }
     }
 
@@ -1457,49 +1475,68 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
 
-  private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRendererCount)
+  private void enableRenderers(boolean[] rendererWasEnabledFlags, int totalEnabledRendererCount)
       throws ExoPlaybackException {
-    enabledRenderers = new Renderer[enabledRendererCount];
-    enabledRendererCount = 0;
+    enabledRenderers = new Renderer[totalEnabledRendererCount];
+    int enabledRendererCount = 0;
     for (int i = 0; i < renderers.length; i++) {
-      Renderer renderer = renderers[i];
-      TrackSelection newSelection = playingPeriodHolder.trackSelectorResult.selections.get(i);
-      if (newSelection != null) {
-        enabledRenderers[enabledRendererCount++] = renderer;
-        if (renderer.getState() == Renderer.STATE_DISABLED) {
-          RendererConfiguration rendererConfiguration =
-              playingPeriodHolder.trackSelectorResult.rendererConfigurations[i];
-          // The renderer needs enabling with its new track selection.
-          boolean playing = playWhenReady && state == Player.STATE_READY;
-          // Consider as joining only if the renderer was previously disabled.
-          boolean joining = !rendererWasEnabledFlags[i] && playing;
-          // Build an array of formats contained by the selection.
-          Format[] formats = new Format[newSelection.length()];
-          for (int j = 0; j < formats.length; j++) {
-            formats[j] = newSelection.getFormat(j);
-          }
-          // Enable the renderer.
-          renderer.enable(rendererConfiguration, formats, playingPeriodHolder.sampleStreams[i],
-              rendererPositionUs, joining, playingPeriodHolder.getRendererOffset());
-          MediaClock mediaClock = renderer.getMediaClock();
-          if (mediaClock != null) {
-            if (rendererMediaClock != null) {
-              throw ExoPlaybackException.createForUnexpected(
-                  new IllegalStateException("Multiple renderer media clocks enabled."));
-            }
-            rendererMediaClock = mediaClock;
-            rendererMediaClockSource = renderer;
-            rendererMediaClock.setPlaybackParameters(playbackParameters);
-          }
-          // Start the renderer if playing.
-          if (playing) {
-            renderer.start();
-          }
+      if (playingPeriodHolder.trackSelectorResult.renderersEnabled[i]) {
+        enableRenderer(i, rendererWasEnabledFlags[i], enabledRendererCount++);
+      }
+    }
+  }
+
+  private void enableRenderer(int rendererIndex, boolean wasRendererEnabled,
+      int enabledRendererIndex) throws ExoPlaybackException {
+    Renderer renderer = renderers[rendererIndex];
+    enabledRenderers[enabledRendererIndex] = renderer;
+    if (renderer.getState() == Renderer.STATE_DISABLED) {
+      RendererConfiguration rendererConfiguration =
+          playingPeriodHolder.trackSelectorResult.rendererConfigurations[rendererIndex];
+      TrackSelection newSelection = playingPeriodHolder.trackSelectorResult.selections.get(
+          rendererIndex);
+      Format[] formats = getFormats(newSelection);
+      // The renderer needs enabling with its new track selection.
+      boolean playing = playWhenReady && state == Player.STATE_READY;
+      // Consider as joining only if the renderer was previously disabled.
+      boolean joining = !wasRendererEnabled && playing;
+      // Enable the renderer.
+      renderer.enable(rendererConfiguration, formats,
+          playingPeriodHolder.sampleStreams[rendererIndex], rendererPositionUs,
+          joining, playingPeriodHolder.getRendererOffset());
+      MediaClock mediaClock = renderer.getMediaClock();
+      if (mediaClock != null) {
+        if (rendererMediaClock != null) {
+          throw ExoPlaybackException.createForUnexpected(
+              new IllegalStateException("Multiple renderer media clocks enabled."));
         }
+        rendererMediaClock = mediaClock;
+        rendererMediaClockSource = renderer;
+        rendererMediaClock.setPlaybackParameters(playbackParameters);
+      }
+      // Start the renderer if playing.
+      if (playing) {
+        renderer.start();
       }
     }
   }
 
+  private boolean rendererWaitingForNextStream(Renderer renderer) {
+    return readingPeriodHolder.next != null && readingPeriodHolder.next.prepared
+        && renderer.hasReadStreamToEnd();
+  }
+
+  @NonNull
+  private static Format[] getFormats(TrackSelection newSelection) {
+    // Build an array of formats contained by the selection.
+    int length = newSelection != null ? newSelection.length() : 0;
+    Format[] formats = new Format[length];
+    for (int i = 0; i < length; i++) {
+      formats[i] = newSelection.getFormat(i);
+    }
+    return formats;
+  }
+
   /**
    * Holds a {@link MediaPeriod} with information required to play it as part of a timeline.
    */
@@ -1626,17 +1663,24 @@ public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStr
             && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
       }
 
+      // Undo the effect of previous call to associate no-sample renderers with empty tracks
+      // so the mediaPeriod receives back whatever it sent us before.
+      disassociateNoSampleRenderersWithEmptySampleStream(sampleStreams);
       // Disable streams on the period and get new streams for updated/newly-enabled tracks.
       positionUs = mediaPeriod.selectTracks(trackSelections.getAll(), mayRetainStreamFlags,
           sampleStreams, streamResetFlags, positionUs);
+      associateNoSampleRenderersWithEmptySampleStream(sampleStreams);
       periodTrackSelectorResult = trackSelectorResult;
 
       // Update whether we have enabled tracks and sanity check the expected streams are non-null.
       hasEnabledTracks = false;
       for (int i = 0; i < sampleStreams.length; i++) {
         if (sampleStreams[i] != null) {
-          Assertions.checkState(trackSelections.get(i) != null);
-          hasEnabledTracks = true;
+          Assertions.checkState(trackSelectorResult.renderersEnabled[i]);
+          // hasEnabledTracks should be true only when non-empty streams exists.
+          if (rendererCapabilities[i].getTrackType() != C.TRACK_TYPE_NONE) {
+            hasEnabledTracks = true;
+          }
         } else {
           Assertions.checkState(trackSelections.get(i) == null);
         }
@@ -1660,6 +1704,31 @@ public void release() {
       }
     }
 
+    /**
+     * For each renderer of type {@link C#TRACK_TYPE_NONE}, we will remove the dummy
+     * {@link EmptySampleStream} that was associated with it.
+     */
+    private void disassociateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
+      for (int i = 0; i < rendererCapabilities.length; i++) {
+        if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE) {
+          sampleStreams[i] = null;
+        }
+      }
+    }
+
+    /**
+     * For each renderer of type {@link C#TRACK_TYPE_NONE} that was enabled, we will
+     * associate it with a dummy {@link EmptySampleStream}.
+     */
+    private void associateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
+      for (int i = 0; i < rendererCapabilities.length; i++) {
+        if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE
+            && trackSelectorResult.renderersEnabled[i]) {
+          sampleStreams[i] = new EmptySampleStream();
+        }
+      }
+    }
+
   }
 
   private static final class SeekPosition {
@@ -1676,4 +1745,18 @@ public SeekPosition(Timeline timeline, int windowIndex, long windowPositionUs) {
 
   }
 
+  private static final class MediaSourceRefreshInfo {
+
+    public final MediaSource source;
+    public final Timeline timeline;
+    public final Object manifest;
+
+    public MediaSourceRefreshInfo(MediaSource source, Timeline timeline, Object manifest) {
+      this.source = source;
+      this.timeline = timeline;
+      this.manifest = manifest;
+    }
+
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 90385ed6c0..f13a7de0ca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -31,13 +31,13 @@
    * The version of the library expressed as a string, for example "1.2.3".
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.5.3";
+  public static final String VERSION = "2.6.0";
 
   /**
    * The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}.
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.5.3";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.6.0";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -47,7 +47,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2005003;
+  public static final int VERSION_INT = 2006000;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 4e387ac7ce..4bd23e2cb6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -21,6 +21,7 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -428,28 +429,28 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
   }
 
   public Format copyWithMaxInputSize(int maxInputSize) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
-        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
-        stereoMode, colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay,
-        encoderPadding, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, metadata);
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
-        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
-        stereoMode, colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay,
-        encoderPadding, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, metadata);
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithContainerInfo(String id, String codecs, int bitrate, int width, int height,
       @C.SelectionFlags int selectionFlags, String language) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
-        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
-        stereoMode, colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay,
-        encoderPadding, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, metadata);
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   @SuppressWarnings("ReferenceEquality")
@@ -464,8 +465,8 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
     float frameRate = this.frameRate == NO_VALUE ? manifestFormat.frameRate : this.frameRate;
     @C.SelectionFlags int selectionFlags = this.selectionFlags |  manifestFormat.selectionFlags;
     String language = this.language == null ? manifestFormat.language : this.language;
-    DrmInitData drmInitData = manifestFormat.drmInitData != null ? manifestFormat.drmInitData
-        : this.drmInitData;
+    DrmInitData drmInitData = manifestFormat.drmInitData != null
+        ? getFilledManifestDrmData(manifestFormat.drmInitData) : this.drmInitData;
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
         colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
@@ -474,27 +475,35 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
   }
 
   public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
-        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
-        stereoMode, colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay,
-        encoderPadding, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, metadata);
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithDrmInitData(DrmInitData drmInitData) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
-        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
-        stereoMode, colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay,
-        encoderPadding, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, metadata);
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithMetadata(Metadata metadata) {
-    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
-        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
-        stereoMode, colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay,
-        encoderPadding, selectionFlags, language, accessibilityChannel, subsampleOffsetUs,
-        initializationData, drmInitData, metadata);
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
+  }
+
+  public Format copyWithRotationDegrees(int rotationDegrees) {
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
+        height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+        colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   /**
@@ -521,8 +530,6 @@ public final MediaFormat getFrameworkMediaFormatV16() {
     maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
     maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
     maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
-    maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
-    maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
     for (int i = 0; i < initializationData.size(); i++) {
       format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
     }
@@ -725,4 +732,42 @@ public Format createFromParcel(Parcel in) {
 
   };
 
+  private DrmInitData getFilledManifestDrmData(DrmInitData manifestDrmData) {
+    // All exposed SchemeDatas must include key request information.
+    ArrayList<SchemeData> exposedSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeData> emptySchemeDatas = new ArrayList<>();
+    for (int i = 0; i < manifestDrmData.schemeDataCount; i++) {
+      SchemeData schemeData = manifestDrmData.get(i);
+      if (schemeData.hasData()) {
+        exposedSchemeDatas.add(schemeData);
+      } else /* needs initialization data filling */ {
+        emptySchemeDatas.add(schemeData);
+      }
+    }
+
+    if (emptySchemeDatas.isEmpty()) {
+      // Manifest DRM information is complete.
+      return manifestDrmData;
+    } else if (drmInitData == null) {
+      // The manifest DRM data needs filling but this format does not include enough information to
+      // do it. A subset of the manifest's scheme datas should not be exposed because a
+      // DrmSessionManager could decide it does not support the format, while the missing
+      // information comes in a format feed immediately after.
+      return null;
+    }
+
+    int needFillingCount = emptySchemeDatas.size();
+    for (int i = 0; i < drmInitData.schemeDataCount; i++) {
+      SchemeData mediaSchemeData = drmInitData.get(i);
+      for (int j = 0; j < needFillingCount; j++) {
+        if (mediaSchemeData.canReplace(emptySchemeDatas.get(j))) {
+          exposedSchemeDatas.add(mediaSchemeData);
+          break;
+        }
+      }
+    }
+    return exposedSchemeDatas.isEmpty() ? null : new DrmInitData(manifestDrmData.schemeType,
+        exposedSchemeDatas.toArray(new SchemeData[exposedSchemeDatas.size()]));
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java
index 0e9c65421c..6cb76e5471 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2;
 
 import android.util.Pair;
-import com.google.android.exoplayer2.ExoPlayerImplInternal.PlaybackInfo;
 import com.google.android.exoplayer2.Player.RepeatMode;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
@@ -102,8 +101,8 @@ public MediaPeriodInfo copyWithStartPositionUs(long startPositionUs) {
   private final Timeline.Window window;
 
   private Timeline timeline;
-  @RepeatMode
-  private int repeatMode;
+  private @RepeatMode int repeatMode;
+  private boolean shuffleModeEnabled;
 
   /**
    * Creates a new media period info sequence.
@@ -129,6 +128,14 @@ public void setRepeatMode(@RepeatMode int repeatMode) {
     this.repeatMode = repeatMode;
   }
 
+  /**
+   * Sets whether shuffling is enabled. Call {@link #getUpdatedMediaPeriodInfo} to update period
+   * information taking into account the shuffle mode.
+   */
+  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    this.shuffleModeEnabled = shuffleModeEnabled;
+  }
+
   /**
    * Returns the first {@link MediaPeriodInfo} to play, based on the specified playback position.
    */
@@ -154,7 +161,7 @@ public MediaPeriodInfo getNextMediaPeriodInfo(MediaPeriodInfo currentMediaPeriod
     // timeline is updated, to avoid repeatedly checking the same timeline.
     if (currentMediaPeriodInfo.isLastInTimelinePeriod) {
       int nextPeriodIndex = timeline.getNextPeriodIndex(currentMediaPeriodInfo.id.periodIndex,
-          period, window, repeatMode);
+          period, window, repeatMode, shuffleModeEnabled);
       if (nextPeriodIndex == C.INDEX_UNSET) {
         // We can't create a next period yet.
         return null;
@@ -345,7 +352,7 @@ private boolean isLastInPeriod(MediaPeriodId id, long endPositionUs) {
   private boolean isLastInTimeline(MediaPeriodId id, boolean isLastMediaPeriodInPeriod) {
     int windowIndex = timeline.getPeriod(id.periodIndex, period).windowIndex;
     return !timeline.getWindow(windowIndex, window).isDynamic
-        && timeline.isLastPeriod(id.periodIndex, period, window, repeatMode)
+        && timeline.isLastPeriod(id.periodIndex, period, window, repeatMode, shuffleModeEnabled)
         && isLastMediaPeriodInPeriod;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
new file mode 100644
index 0000000000..978f4f7a97
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MediaClock;
+import java.io.IOException;
+
+/**
+ * A {@link Renderer} implementation whose track type is {@link C#TRACK_TYPE_NONE} and does not
+ * consume data from its {@link SampleStream}.
+ */
+public abstract class NoSampleRenderer implements Renderer, RendererCapabilities {
+
+  private RendererConfiguration configuration;
+  private int index;
+  private int state;
+  private SampleStream stream;
+  private boolean streamIsFinal;
+
+  @Override
+  public final int getTrackType() {
+    return C.TRACK_TYPE_NONE;
+  }
+
+  @Override
+  public final RendererCapabilities getCapabilities() {
+    return this;
+  }
+
+  @Override
+  public final void setIndex(int index) {
+    this.index = index;
+  }
+
+  @Override
+  public MediaClock getMediaClock() {
+    return null;
+  }
+
+  @Override
+  public final int getState() {
+    return state;
+  }
+
+  /**
+   * Replaces the {@link SampleStream} that will be associated with this renderer.
+   * <p>
+   * This method may be called when the renderer is in the following states:
+   * {@link #STATE_DISABLED}.
+   *
+   * @param configuration The renderer configuration.
+   * @param formats The enabled formats. Should be empty.
+   * @param stream The {@link SampleStream} from which the renderer should consume.
+   * @param positionUs The player's current position.
+   * @param joining Whether this renderer is being enabled to join an ongoing playback.
+   * @param offsetUs The offset that should be subtracted from {@code positionUs}
+   *     to get the playback position with respect to the media.
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  @Override
+  public final void enable(RendererConfiguration configuration, Format[] formats,
+      SampleStream stream, long positionUs, boolean joining, long offsetUs)
+      throws ExoPlaybackException {
+    Assertions.checkState(state == STATE_DISABLED);
+    this.configuration = configuration;
+    state = STATE_ENABLED;
+    onEnabled(joining);
+    replaceStream(formats, stream, offsetUs);
+    onPositionReset(positionUs, joining);
+  }
+
+  @Override
+  public final void start() throws ExoPlaybackException {
+    Assertions.checkState(state == STATE_ENABLED);
+    state = STATE_STARTED;
+    onStarted();
+  }
+
+  /**
+   * Replaces the {@link SampleStream} that will be associated with this renderer.
+   * <p>
+   * This method may be called when the renderer is in the following states:
+   * {@link #STATE_ENABLED}, {@link #STATE_STARTED}.
+   *
+   * @param formats The enabled formats. Should be empty.
+   * @param stream The {@link SampleStream} to be associated with this renderer.
+   * @param offsetUs The offset that should be subtracted from {@code positionUs} in
+   *     {@link #render(long, long)} to get the playback position with respect to the media.
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  @Override
+  public final void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
+      throws ExoPlaybackException {
+    Assertions.checkState(!streamIsFinal);
+    this.stream = stream;
+    onRendererOffsetChanged(offsetUs);
+  }
+
+  @Override
+  public final SampleStream getStream() {
+    return stream;
+  }
+
+  @Override
+  public final boolean hasReadStreamToEnd() {
+    return true;
+  }
+
+  @Override
+  public final void setCurrentStreamFinal() {
+    streamIsFinal = true;
+  }
+
+  @Override
+  public final boolean isCurrentStreamFinal() {
+    return streamIsFinal;
+  }
+
+  @Override
+  public final void maybeThrowStreamError() throws IOException {
+  }
+
+  @Override
+  public final void resetPosition(long positionUs) throws ExoPlaybackException {
+    streamIsFinal = false;
+    onPositionReset(positionUs, false);
+  }
+
+  @Override
+  public final void stop() throws ExoPlaybackException {
+    Assertions.checkState(state == STATE_STARTED);
+    state = STATE_ENABLED;
+    onStopped();
+  }
+
+  @Override
+  public final void disable() {
+    Assertions.checkState(state == STATE_ENABLED);
+    state = STATE_DISABLED;
+    stream = null;
+    streamIsFinal = false;
+    onDisabled();
+  }
+
+  @Override
+  public boolean isReady() {
+    return true;
+  }
+
+  @Override
+  public boolean isEnded() {
+    return true;
+  }
+
+  // RendererCapabilities implementation.
+
+  @Override
+  public int supportsFormat(Format format) throws ExoPlaybackException {
+    return FORMAT_UNSUPPORTED_TYPE;
+  }
+
+  @Override
+  public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+    return ADAPTIVE_NOT_SUPPORTED;
+  }
+
+  // ExoPlayerComponent implementation.
+
+  @Override
+  public void handleMessage(int what, Object object) throws ExoPlaybackException {
+    // Do nothing.
+  }
+
+  // Methods to be overridden by subclasses.
+
+  /**
+   * Called when the renderer is enabled.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param joining Whether this renderer is being enabled to join an ongoing playback.
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  protected void onEnabled(boolean joining) throws ExoPlaybackException {
+    // Do nothing.
+  }
+
+  /**
+   * Called when the renderer's offset has been changed.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param offsetUs The offset that should be subtracted from {@code positionUs} in
+   *     {@link #render(long, long)} to get the playback position with respect to the media.
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  protected void onRendererOffsetChanged(long offsetUs) throws ExoPlaybackException {
+    // Do nothing.
+  }
+
+  /**
+   * Called when the position is reset. This occurs when the renderer is enabled after
+   * {@link #onRendererOffsetChanged(long)} has been called, and also when a position
+   * discontinuity is encountered.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param positionUs The new playback position in microseconds.
+   * @param joining Whether this renderer is being enabled to join an ongoing playback.
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+    // Do nothing.
+  }
+
+  /**
+   * Called when the renderer is started.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  protected void onStarted() throws ExoPlaybackException {
+    // Do nothing.
+  }
+
+  /**
+   * Called when the renderer is stopped.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @throws ExoPlaybackException If an error occurs.
+   */
+  protected void onStopped() throws ExoPlaybackException {
+    // Do nothing.
+  }
+
+  /**
+   * Called when the renderer is disabled.
+   * <p>
+   * The default implementation is a no-op.
+   */
+  protected void onDisabled() {
+    // Do nothing.
+  }
+
+  // Methods to be called by subclasses.
+
+  /**
+   * Returns the configuration set when the renderer was most recently enabled.
+   */
+  protected final RendererConfiguration getConfiguration() {
+    return configuration;
+  }
+
+  /**
+   * Returns the index of the renderer within the player.
+   */
+  protected final int getIndex() {
+    return index;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
new file mode 100644
index 0000000000..a2ffa43c4b
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+
+/**
+ * Information about an ongoing playback.
+ */
+/* package */ final class PlaybackInfo {
+
+  public final Timeline timeline;
+  public final Object manifest;
+  public final MediaPeriodId periodId;
+  public final long startPositionUs;
+  public final long contentPositionUs;
+
+  public volatile long positionUs;
+  public volatile long bufferedPositionUs;
+
+  public PlaybackInfo(Timeline timeline, Object manifest, int periodIndex, long startPositionUs) {
+    this(timeline, manifest, new MediaPeriodId(periodIndex), startPositionUs, C.TIME_UNSET);
+  }
+
+  public PlaybackInfo(Timeline timeline, Object manifest, MediaPeriodId periodId,
+      long startPositionUs, long contentPositionUs) {
+    this.timeline = timeline;
+    this.manifest = manifest;
+    this.periodId = periodId;
+    this.startPositionUs = startPositionUs;
+    this.contentPositionUs = contentPositionUs;
+    positionUs = startPositionUs;
+    bufferedPositionUs = startPositionUs;
+  }
+
+  public PlaybackInfo fromNewPosition(int periodIndex, long startPositionUs,
+      long contentPositionUs) {
+    return fromNewPosition(new MediaPeriodId(periodIndex), startPositionUs, contentPositionUs);
+  }
+
+  public PlaybackInfo fromNewPosition(MediaPeriodId periodId, long startPositionUs,
+      long contentPositionUs) {
+    return new PlaybackInfo(timeline, manifest, periodId, startPositionUs, contentPositionUs);
+  }
+
+  public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
+    PlaybackInfo playbackInfo = new PlaybackInfo(timeline, manifest,
+        periodId.copyWithPeriodIndex(periodIndex), startPositionUs, contentPositionUs);
+    copyMutablePositions(this, playbackInfo);
+    return playbackInfo;
+  }
+
+  public PlaybackInfo copyWithTimeline(Timeline timeline, Object manifest) {
+    PlaybackInfo playbackInfo = new PlaybackInfo(timeline, manifest, periodId, startPositionUs,
+        contentPositionUs);
+    copyMutablePositions(this, playbackInfo);
+    return playbackInfo;
+  }
+
+  private static void copyMutablePositions(PlaybackInfo from, PlaybackInfo to) {
+    to.positionUs = from.positionUs;
+    to.bufferedPositionUs = from.bufferedPositionUs;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index d2480c5b3a..dc703f924a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -55,7 +55,7 @@
      * Note that if the timeline has changed then a position discontinuity may also have occurred.
      * For example, the current period index may have changed as a result of periods being added or
      * removed from the timeline. This will <em>not</em> be reported via a separate call to
-     * {@link #onPositionDiscontinuity()}.
+     * {@link #onPositionDiscontinuity(int)}.
      *
      * @param timeline The latest timeline. Never null, but may be empty.
      * @param manifest The latest manifest. May be null.
@@ -94,6 +94,13 @@
      */
     void onRepeatModeChanged(@RepeatMode int repeatMode);
 
+    /**
+     * Called when the value of {@link #getShuffleModeEnabled()} changes.
+     *
+     * @param shuffleModeEnabled Whether shuffling of windows is enabled.
+     */
+    void onShuffleModeEnabledChanged(boolean shuffleModeEnabled);
+
     /**
      * Called when an error occurs. The playback state will transition to {@link #STATE_IDLE}
      * immediately after this method is called. The player instance can still be used, and
@@ -112,8 +119,10 @@
      * <p>
      * When a position discontinuity occurs as a result of a change to the timeline this method is
      * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object)} is called in this case.
+     *
+     * @param reason The {@link DiscontinuityReason} responsible for the discontinuity.
      */
-    void onPositionDiscontinuity();
+    void onPositionDiscontinuity(@DiscontinuityReason int reason);
 
     /**
      * Called when the current playback parameters change. The playback parameters may change due to
@@ -125,6 +134,70 @@
      */
     void onPlaybackParametersChanged(PlaybackParameters playbackParameters);
 
+    /**
+     * Called when all pending seek requests have been processed by the player. This is guaranteed
+     * to happen after any necessary changes to the player state were reported to
+     * {@link #onPlayerStateChanged(boolean, int)}.
+     */
+    void onSeekProcessed();
+
+  }
+
+  /**
+   * {@link EventListener} allowing selective overrides. All methods are implemented as no-ops.
+   */
+  abstract class DefaultEventListener implements EventListener {
+
+    @Override
+    public void onTimelineChanged(Timeline timeline, Object manifest) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadingChanged(boolean isLoading) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onRepeatModeChanged(@RepeatMode int repeatMode) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException error) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onSeekProcessed() {
+      // Do nothing.
+    }
+
   }
 
   /**
@@ -165,6 +238,32 @@
    */
   int REPEAT_MODE_ALL = 2;
 
+  /**
+   * Reasons for position discontinuities.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({DISCONTINUITY_REASON_PERIOD_TRANSITION, DISCONTINUITY_REASON_SEEK,
+      DISCONTINUITY_REASON_SEEK_ADJUSTMENT, DISCONTINUITY_REASON_INTERNAL})
+  public @interface DiscontinuityReason {}
+  /**
+   * Automatic playback transition from one period in the timeline to the next. The period index may
+   * be the same as it was before the discontinuity in case the current period is repeated.
+   */
+  int DISCONTINUITY_REASON_PERIOD_TRANSITION = 0;
+  /**
+   * Seek within the current period or to another period.
+   */
+  int DISCONTINUITY_REASON_SEEK = 1;
+  /**
+   * Seek adjustment due to being unable to seek to the requested position or because the seek was
+   * permitted to be inexact.
+   */
+  int DISCONTINUITY_REASON_SEEK_ADJUSTMENT = 2;
+  /**
+   * Discontinuity introduced internally by the source.
+   */
+  int DISCONTINUITY_REASON_INTERNAL = 3;
+
   /**
    * Register a listener to receive events from the player. The listener's methods will be called on
    * the thread that was used to construct the player. However, if the thread used to construct the
@@ -219,6 +318,18 @@
    */
   @RepeatMode int getRepeatMode();
 
+  /**
+   * Sets whether shuffling of windows is enabled.
+   *
+   * @param shuffleModeEnabled Whether shuffling is enabled.
+   */
+  void setShuffleModeEnabled(boolean shuffleModeEnabled);
+
+  /**
+   * Returns whether shuffling of windows is enabled.
+   */
+  boolean getShuffleModeEnabled();
+
   /**
    * Whether the player is currently loading the source.
    *
@@ -344,6 +455,20 @@
    */
   int getCurrentWindowIndex();
 
+  /**
+   * Returns the index of the next timeline window to be played, which may depend on the current
+   * repeat mode and whether shuffle mode is enabled. Returns {@link C#INDEX_UNSET} if the window
+   * currently being played is the last window.
+   */
+  int getNextWindowIndex();
+
+  /**
+   * Returns the index of the previous timeline window to be played, which may depend on the current
+   * repeat mode and whether shuffle mode is enabled. Returns {@link C#INDEX_UNSET} if the window
+   * currently being played is the first window.
+   */
+  int getPreviousWindowIndex();
+
   /**
    * Returns the duration of the current window in milliseconds, or {@link C#TIME_UNSET} if the
    * duration is not known.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
index e16caec980..6def1591da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -226,7 +226,7 @@ void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
 
   /**
    * Whether the renderer is ready for the {@link ExoPlayer} instance to transition to
-   * {@link ExoPlayer#STATE_ENDED}. The player will make this transition as soon as {@code true} is
+   * {@link Player#STATE_ENDED}. The player will make this transition as soon as {@code true} is
    * returned by all of its {@link Renderer}s.
    * <p>
    * This method may be called when the renderer is in the following states:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java b/library/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
index 3f1be20cfb..de0d481386 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
@@ -34,7 +34,9 @@
   int FORMAT_HANDLED = 0b100;
   /**
    * The {@link Renderer} is capable of rendering formats with the same mime type, but the
-   * properties of the format exceed the renderer's capability.
+   * properties of the format exceed the renderer's capabilities. There is a chance the renderer
+   * will be able to play the format in practice because some renderers report their capabilities
+   * conservatively, but the expected outcome is that playback will fail.
    * <p>
    * Example: The {@link Renderer} is capable of rendering H264 and the format's mime type is
    * {@link MimeTypes#VIDEO_H264}, but the format's resolution exceeds the maximum limit supported
@@ -42,12 +44,12 @@
    */
   int FORMAT_EXCEEDS_CAPABILITIES = 0b011;
   /**
-   * The {@link Renderer} is capable of rendering formats with the same mime type, but the
-   * drm scheme used is not supported.
+   * The {@link Renderer} is capable of rendering formats with the same mime type, but is not
+   * capable of rendering the format because the format's drm protection is not supported.
    * <p>
    * Example: The {@link Renderer} is capable of rendering H264 and the format's mime type is
-   * {@link MimeTypes#VIDEO_H264}, but the format indicates cbcs encryption, which is not supported
-   * by the underlying content decryption module.
+   * {@link MimeTypes#VIDEO_H264}, but the format indicates PlayReady drm protection where-as the
+   * renderer only supports Widevine.
    */
   int FORMAT_UNSUPPORTED_DRM = 0b010;
   /**
@@ -121,9 +123,11 @@
    * {@link #FORMAT_UNSUPPORTED_SUBTYPE} and {@link #FORMAT_UNSUPPORTED_TYPE}.</li>
    * <li>The level of support for adapting from the format to another format of the same mime type.
    * One of {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and
-   * {@link #ADAPTIVE_NOT_SUPPORTED}.</li>
+   * {@link #ADAPTIVE_NOT_SUPPORTED}. Only set if the level of support for the format itself is
+   * {@link #FORMAT_HANDLED} or {@link #FORMAT_EXCEEDS_CAPABILITIES}.</li>
    * <li>The level of support for tunneling. One of {@link #TUNNELING_SUPPORTED} and
-   * {@link #TUNNELING_NOT_SUPPORTED}.</li>
+   * {@link #TUNNELING_NOT_SUPPORTED}. Only set if the level of support for the format itself is
+   * {@link #FORMAT_HANDLED} or {@link #FORMAT_EXCEEDS_CAPABILITIES}.</li>
    * </ul>
    * The individual properties can be retrieved by performing a bitwise AND with
    * {@link #FORMAT_SUPPORT_MASK}, {@link #ADAPTIVE_SUPPORT_MASK} and
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java
index 728cfa387a..944a6a9e5e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/RenderersFactory.java
@@ -17,8 +17,8 @@
 
 import android.os.Handler;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.metadata.MetadataRenderer;
-import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
+import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 
 /**
@@ -31,14 +31,14 @@
    *
    * @param eventHandler A handler to use when invoking event listeners and outputs.
    * @param videoRendererEventListener An event listener for video renderers.
-   * @param videoRendererEventListener An event listener for audio renderers.
+   * @param audioRendererEventListener An event listener for audio renderers.
    * @param textRendererOutput An output for text renderers.
    * @param metadataRendererOutput An output for metadata renderers.
    * @return The {@link Renderer instances}.
    */
   Renderer[] createRenderers(Handler eventHandler,
       VideoRendererEventListener videoRendererEventListener,
-      AudioRendererEventListener audioRendererEventListener,
-      TextRenderer.Output textRendererOutput, MetadataRenderer.Output metadataRendererOutput);
+      AudioRendererEventListener audioRendererEventListener, TextOutput textRendererOutput,
+      MetadataOutput metadataRendererOutput);
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 1887e0d243..5a5a948d58 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -31,11 +31,11 @@
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
-import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.util.Util;
@@ -89,8 +89,8 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private final ExoPlayer player;
   private final ComponentListener componentListener;
   private final CopyOnWriteArraySet<VideoListener> videoListeners;
-  private final CopyOnWriteArraySet<TextRenderer.Output> textOutputs;
-  private final CopyOnWriteArraySet<MetadataRenderer.Output> metadataOutputs;
+  private final CopyOnWriteArraySet<TextOutput> textOutputs;
+  private final CopyOnWriteArraySet<MetadataOutput> metadataOutputs;
   private final int videoRendererCount;
   private final int audioRendererCount;
 
@@ -145,7 +145,7 @@ protected SimpleExoPlayer(RenderersFactory renderersFactory, TrackSelector track
     videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
 
     // Build the player and associated objects.
-    player = new ExoPlayerImpl(renderers, trackSelector, loadControl);
+    player = createExoPlayerImpl(renderers, trackSelector, loadControl);
   }
 
   /**
@@ -491,7 +491,7 @@ public void clearVideoListener(VideoListener listener) {
    *
    * @param listener The output to register.
    */
-  public void addTextOutput(TextRenderer.Output listener) {
+  public void addTextOutput(TextOutput listener) {
     textOutputs.add(listener);
   }
 
@@ -500,7 +500,7 @@ public void addTextOutput(TextRenderer.Output listener) {
    *
    * @param listener The output to remove.
    */
-  public void removeTextOutput(TextRenderer.Output listener) {
+  public void removeTextOutput(TextOutput listener) {
     textOutputs.remove(listener);
   }
 
@@ -508,10 +508,10 @@ public void removeTextOutput(TextRenderer.Output listener) {
    * Sets an output to receive text events, removing all existing outputs.
    *
    * @param output The output.
-   * @deprecated Use {@link #addTextOutput(TextRenderer.Output)}.
+   * @deprecated Use {@link #addTextOutput(TextOutput)}.
    */
   @Deprecated
-  public void setTextOutput(TextRenderer.Output output) {
+  public void setTextOutput(TextOutput output) {
     textOutputs.clear();
     if (output != null) {
       addTextOutput(output);
@@ -519,13 +519,13 @@ public void setTextOutput(TextRenderer.Output output) {
   }
 
   /**
-   * Equivalent to {@link #removeTextOutput(TextRenderer.Output)}.
+   * Equivalent to {@link #removeTextOutput(TextOutput)}.
    *
    * @param output The output to clear.
-   * @deprecated Use {@link #removeTextOutput(TextRenderer.Output)}.
+   * @deprecated Use {@link #removeTextOutput(TextOutput)}.
    */
   @Deprecated
-  public void clearTextOutput(TextRenderer.Output output) {
+  public void clearTextOutput(TextOutput output) {
     removeTextOutput(output);
   }
 
@@ -534,7 +534,7 @@ public void clearTextOutput(TextRenderer.Output output) {
    *
    * @param listener The output to register.
    */
-  public void addMetadataOutput(MetadataRenderer.Output listener) {
+  public void addMetadataOutput(MetadataOutput listener) {
     metadataOutputs.add(listener);
   }
 
@@ -543,7 +543,7 @@ public void addMetadataOutput(MetadataRenderer.Output listener) {
    *
    * @param listener The output to remove.
    */
-  public void removeMetadataOutput(MetadataRenderer.Output listener) {
+  public void removeMetadataOutput(MetadataOutput listener) {
     metadataOutputs.remove(listener);
   }
 
@@ -551,10 +551,10 @@ public void removeMetadataOutput(MetadataRenderer.Output listener) {
    * Sets an output to receive metadata events, removing all existing outputs.
    *
    * @param output The output.
-   * @deprecated Use {@link #addMetadataOutput(MetadataRenderer.Output)}.
+   * @deprecated Use {@link #addMetadataOutput(MetadataOutput)}.
    */
   @Deprecated
-  public void setMetadataOutput(MetadataRenderer.Output output) {
+  public void setMetadataOutput(MetadataOutput output) {
     metadataOutputs.clear();
     if (output != null) {
       addMetadataOutput(output);
@@ -562,13 +562,13 @@ public void setMetadataOutput(MetadataRenderer.Output output) {
   }
 
   /**
-   * Equivalent to {@link #removeMetadataOutput(MetadataRenderer.Output)}.
+   * Equivalent to {@link #removeMetadataOutput(MetadataOutput)}.
    *
    * @param output The output to clear.
-   * @deprecated Use {@link #removeMetadataOutput(MetadataRenderer.Output)}.
+   * @deprecated Use {@link #removeMetadataOutput(MetadataOutput)}.
    */
   @Deprecated
-  public void clearMetadataOutput(MetadataRenderer.Output output) {
+  public void clearMetadataOutput(MetadataOutput output) {
     removeMetadataOutput(output);
   }
 
@@ -642,6 +642,16 @@ public void setRepeatMode(@RepeatMode int repeatMode) {
     player.setRepeatMode(repeatMode);
   }
 
+  @Override
+  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    player.setShuffleModeEnabled(shuffleModeEnabled);
+  }
+
+  @Override
+  public boolean getShuffleModeEnabled() {
+    return player.getShuffleModeEnabled();
+  }
+
   @Override
   public boolean isLoading() {
     return player.isLoading();
@@ -744,6 +754,16 @@ public int getCurrentWindowIndex() {
     return player.getCurrentWindowIndex();
   }
 
+  @Override
+  public int getNextWindowIndex() {
+    return player.getNextWindowIndex();
+  }
+
+  @Override
+  public int getPreviousWindowIndex() {
+    return player.getPreviousWindowIndex();
+  }
+
   @Override
   public long getDuration() {
     return player.getDuration();
@@ -796,6 +816,19 @@ public long getContentPosition() {
 
   // Internal methods.
 
+  /**
+   * Creates the ExoPlayer implementation used by this {@link SimpleExoPlayer}.
+   *
+   * @param renderers The {@link Renderer}s that will be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @return A new {@link ExoPlayer} instance.
+   */
+  protected ExoPlayer createExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector,
+      LoadControl loadControl) {
+    return new ExoPlayerImpl(renderers, trackSelector, loadControl);
+  }
+
   private void removeSurfaceCallbacks() {
     if (textureView != null) {
       if (textureView.getSurfaceTextureListener() != componentListener) {
@@ -836,8 +869,8 @@ private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
   }
 
   private final class ComponentListener implements VideoRendererEventListener,
-      AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output,
-      SurfaceHolder.Callback, TextureView.SurfaceTextureListener {
+      AudioRendererEventListener, TextOutput, MetadataOutput, SurfaceHolder.Callback,
+      TextureView.SurfaceTextureListener {
 
     // VideoRendererEventListener implementation
 
@@ -943,10 +976,10 @@ public void onAudioInputFormatChanged(Format format) {
     }
 
     @Override
-    public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+    public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs,
         long elapsedSinceLastFeedMs) {
       if (audioDebugListener != null) {
-        audioDebugListener.onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+        audioDebugListener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
       }
     }
 
@@ -960,20 +993,20 @@ public void onAudioDisabled(DecoderCounters counters) {
       audioSessionId = C.AUDIO_SESSION_ID_UNSET;
     }
 
-    // TextRenderer.Output implementation
+    // TextOutput implementation
 
     @Override
     public void onCues(List<Cue> cues) {
-      for (TextRenderer.Output textOutput : textOutputs) {
+      for (TextOutput textOutput : textOutputs) {
         textOutput.onCues(cues);
       }
     }
 
-    // MetadataRenderer.Output implementation
+    // MetadataOutput implementation
 
     @Override
     public void onMetadata(Metadata metadata) {
-      for (MetadataRenderer.Output metadataOutput : metadataOutputs) {
+      for (MetadataOutput metadataOutput : metadataOutputs) {
         metadataOutput.onMetadata(metadata);
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 7d4c1995eb..783278a121 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -553,20 +553,24 @@ public final boolean isEmpty() {
 
   /**
    * Returns the index of the window after the window at index {@code windowIndex} depending on the
-   * {@code repeatMode}.
+   * {@code repeatMode} and whether shuffling is enabled.
    *
    * @param windowIndex Index of a window in the timeline.
    * @param repeatMode A repeat mode.
+   * @param shuffleModeEnabled Whether shuffling is enabled.
    * @return The index of the next window, or {@link C#INDEX_UNSET} if this is the last window.
    */
-  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
+  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled) {
     switch (repeatMode) {
       case Player.REPEAT_MODE_OFF:
-        return windowIndex == getWindowCount() - 1 ? C.INDEX_UNSET : windowIndex + 1;
+        return windowIndex == getLastWindowIndex(shuffleModeEnabled) ? C.INDEX_UNSET
+            : windowIndex + 1;
       case Player.REPEAT_MODE_ONE:
         return windowIndex;
       case Player.REPEAT_MODE_ALL:
-        return windowIndex == getWindowCount() - 1 ? 0 : windowIndex + 1;
+        return windowIndex == getLastWindowIndex(shuffleModeEnabled)
+            ? getFirstWindowIndex(shuffleModeEnabled) : windowIndex + 1;
       default:
         throw new IllegalStateException();
     }
@@ -574,25 +578,53 @@ public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode
 
   /**
    * Returns the index of the window before the window at index {@code windowIndex} depending on the
-   * {@code repeatMode}.
+   * {@code repeatMode} and whether shuffling is enabled.
    *
    * @param windowIndex Index of a window in the timeline.
    * @param repeatMode A repeat mode.
+   * @param shuffleModeEnabled Whether shuffling is enabled.
    * @return The index of the previous window, or {@link C#INDEX_UNSET} if this is the first window.
    */
-  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
+  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled) {
     switch (repeatMode) {
       case Player.REPEAT_MODE_OFF:
-        return windowIndex == 0 ? C.INDEX_UNSET : windowIndex - 1;
+        return windowIndex == getFirstWindowIndex(shuffleModeEnabled) ? C.INDEX_UNSET
+            : windowIndex - 1;
       case Player.REPEAT_MODE_ONE:
         return windowIndex;
       case Player.REPEAT_MODE_ALL:
-        return windowIndex == 0 ? getWindowCount() - 1 : windowIndex - 1;
+        return windowIndex == getFirstWindowIndex(shuffleModeEnabled)
+            ? getLastWindowIndex(shuffleModeEnabled) : windowIndex - 1;
       default:
         throw new IllegalStateException();
     }
   }
 
+  /**
+   * Returns the index of the last window in the playback order depending on whether shuffling is
+   * enabled.
+   *
+   * @param shuffleModeEnabled Whether shuffling is enabled.
+   * @return The index of the last window in the playback order, or {@link C#INDEX_UNSET} if the
+   *     timeline is empty.
+   */
+  public int getLastWindowIndex(boolean shuffleModeEnabled) {
+    return isEmpty() ? C.INDEX_UNSET : getWindowCount() - 1;
+  }
+
+  /**
+   * Returns the index of the first window in the playback order depending on whether shuffling is
+   * enabled.
+   *
+   * @param shuffleModeEnabled Whether shuffling is enabled.
+   * @return The index of the first window in the playback order, or {@link C#INDEX_UNSET} if the
+   *     timeline is empty.
+   */
+  public int getFirstWindowIndex(boolean shuffleModeEnabled) {
+    return isEmpty() ? C.INDEX_UNSET : 0;
+  }
+
   /**
    * Populates a {@link Window} with data for the window at the specified index. Does not populate
    * {@link Window#id}.
@@ -614,7 +646,7 @@ public final Window getWindow(int windowIndex, Window window) {
    *     null. The caller should pass false for efficiency reasons unless the field is required.
    * @return The populated {@link Window}, for convenience.
    */
-  public Window getWindow(int windowIndex, Window window, boolean setIds) {
+  public final Window getWindow(int windowIndex, Window window, boolean setIds) {
     return getWindow(windowIndex, window, setIds, 0);
   }
 
@@ -639,19 +671,20 @@ public abstract Window getWindow(int windowIndex, Window window, boolean setIds,
 
   /**
    * Returns the index of the period after the period at index {@code periodIndex} depending on the
-   * {@code repeatMode}.
+   * {@code repeatMode} and whether shuffling is enabled.
    *
    * @param periodIndex Index of a period in the timeline.
    * @param period A {@link Period} to be used internally. Must not be null.
    * @param window A {@link Window} to be used internally. Must not be null.
    * @param repeatMode A repeat mode.
+   * @param shuffleModeEnabled Whether shuffling is enabled.
    * @return The index of the next period, or {@link C#INDEX_UNSET} if this is the last period.
    */
   public final int getNextPeriodIndex(int periodIndex, Period period, Window window,
-      @Player.RepeatMode int repeatMode) {
+      @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {
     int windowIndex = getPeriod(periodIndex, period).windowIndex;
     if (getWindow(windowIndex, window).lastPeriodIndex == periodIndex) {
-      int nextWindowIndex = getNextWindowIndex(windowIndex, repeatMode);
+      int nextWindowIndex = getNextWindowIndex(windowIndex, repeatMode, shuffleModeEnabled);
       if (nextWindowIndex == C.INDEX_UNSET) {
         return C.INDEX_UNSET;
       }
@@ -662,17 +695,19 @@ public final int getNextPeriodIndex(int periodIndex, Period period, Window windo
 
   /**
    * Returns whether the given period is the last period of the timeline depending on the
-   * {@code repeatMode}.
+   * {@code repeatMode} and whether shuffling is enabled.
    *
    * @param periodIndex A period index.
    * @param period A {@link Period} to be used internally. Must not be null.
    * @param window A {@link Window} to be used internally. Must not be null.
    * @param repeatMode A repeat mode.
+   * @param shuffleModeEnabled Whether shuffling is enabled.
    * @return Whether the period of the given index is the last period of the timeline.
    */
   public final boolean isLastPeriod(int periodIndex, Period period, Window window,
-      @Player.RepeatMode int repeatMode) {
-    return getNextPeriodIndex(periodIndex, period, window, repeatMode) == C.INDEX_UNSET;
+      @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {
+    return getNextPeriodIndex(periodIndex, period, window, repeatMode, shuffleModeEnabled)
+        == C.INDEX_UNSET;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index 4b64ffb030..e1a70e2579 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -33,11 +33,33 @@
    */
   public static final class Ac3SyncFrameInfo {
 
+    /**
+     * Undefined AC3 stream type.
+     */
+    public static final int STREAM_TYPE_UNDEFINED = -1;
+    /**
+     * Type 0 AC3 stream type. See ETSI TS 102 366 E.1.3.1.1.
+     */
+    public static final int STREAM_TYPE_TYPE0 = 0;
+    /**
+     * Type 1 AC3 stream type. See ETSI TS 102 366 E.1.3.1.1.
+     */
+    public static final int STREAM_TYPE_TYPE1 = 1;
+    /**
+     * Type 2 AC3 stream type. See ETSI TS 102 366 E.1.3.1.1.
+     */
+    public static final int STREAM_TYPE_TYPE2 = 2;
+
     /**
      * The sample mime type of the bitstream. One of {@link MimeTypes#AUDIO_AC3} and
      * {@link MimeTypes#AUDIO_E_AC3}.
      */
     public final String mimeType;
+    /**
+     * The type of the stream if {@link #mimeType} is {@link MimeTypes#AUDIO_E_AC3}, or
+     * {@link #STREAM_TYPE_UNDEFINED} otherwise.
+     */
+    public final int streamType;
     /**
      * The audio sampling rate in Hz.
      */
@@ -55,9 +77,10 @@
      */
     public final int sampleCount;
 
-    private Ac3SyncFrameInfo(String mimeType, int channelCount, int sampleRate, int frameSize,
-        int sampleCount) {
+    private Ac3SyncFrameInfo(String mimeType, int streamType, int channelCount, int sampleRate,
+        int frameSize, int sampleCount) {
       this.mimeType = mimeType;
+      this.streamType = streamType;
       this.channelCount = channelCount;
       this.sampleRate = sampleRate;
       this.frameSize = frameSize;
@@ -138,8 +161,7 @@ public static Format parseEAc3AnnexFFormat(ParsableByteArray data, String trackI
       String language, DrmInitData drmInitData) {
     data.skipBytes(2); // data_rate, num_ind_sub
 
-    // Read only the first substream.
-    // TODO: Read later substreams?
+    // Read the first independent substream.
     int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
     int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     int nextByte = data.readUnsignedByte();
@@ -147,6 +169,18 @@ public static Format parseEAc3AnnexFFormat(ParsableByteArray data, String trackI
     if ((nextByte & 0x01) != 0) { // lfeon
       channelCount++;
     }
+
+    // Read the first dependent substream.
+    nextByte = data.readUnsignedByte();
+    int numDepSub = ((nextByte & 0x1E) >> 1);
+    if (numDepSub > 0) {
+      int lowByteChanLoc = data.readUnsignedByte();
+      // Read Lrs/Rrs pair
+      // TODO: Read other channel configuration
+      if ((lowByteChanLoc & 0x02) != 0) {
+        channelCount += 2;
+      }
+    }
     return Format.createAudioSampleFormat(trackId, MimeTypes.AUDIO_E_AC3, null, Format.NO_VALUE,
         Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0, language);
   }
@@ -164,13 +198,16 @@ public static Ac3SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
     boolean isEac3 = data.readBits(5) == 16;
     data.setPosition(initialPosition);
     String mimeType;
+    int streamType = Ac3SyncFrameInfo.STREAM_TYPE_UNDEFINED;
     int sampleRate;
     int acmod;
     int frameSize;
     int sampleCount;
     if (isEac3) {
       mimeType = MimeTypes.AUDIO_E_AC3;
-      data.skipBits(16 + 2 + 3); // syncword, strmtype, substreamid
+      data.skipBits(16); // syncword
+      streamType = data.readBits(2);
+      data.skipBits(3); // substreamid
       frameSize = (data.readBits(11) + 1) * 2;
       int fscod = data.readBits(2);
       int audioBlocks;
@@ -206,7 +243,8 @@ public static Ac3SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
     }
     boolean lfeon = data.readBit();
     int channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);
-    return new Ac3SyncFrameInfo(mimeType, channelCount, sampleRate, frameSize, sampleCount);
+    return new Ac3SyncFrameInfo(mimeType, streamType, channelCount, sampleRate, frameSize,
+        sampleCount);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
index eced040812..8a3d624222 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
@@ -20,7 +20,15 @@
 import java.nio.ByteOrder;
 
 /**
- * Interface for audio processors.
+ * Interface for audio processors, which take audio data as input and transform it, potentially
+ * modifying its channel count, encoding and/or sample rate.
+ * <p>
+ * Call {@link #configure(int, int, int)} to configure the processor to receive input audio, then
+ * call {@link #isActive()} to determine whether the processor is active.
+ * {@link #queueInput(ByteBuffer)}, {@link #queueEndOfStream()}, {@link #getOutput()},
+ * {@link #isEnded()}, {@link #getOutputChannelCount()}, {@link #getOutputEncoding()} and
+ * {@link #getOutputSampleRateHz()} may only be called if the processor is active. Call
+ * {@link #reset()} to reset the processor to its unconfigured state.
  */
 public interface AudioProcessor {
 
@@ -46,8 +54,9 @@ public UnhandledFormatException(int sampleRateHz, int channelCount, @C.Encoding
    * method, {@link #isActive()} returns whether the processor needs to handle buffers; if not, the
    * processor will not accept any buffers until it is reconfigured. Returns {@code true} if the
    * processor must be flushed, or if the value returned by {@link #isActive()} has changed as a
-   * result of the call. If it's active, {@link #getOutputChannelCount()} and
-   * {@link #getOutputEncoding()} return the processor's output format.
+   * result of the call. If it's active, {@link #getOutputSampleRateHz()},
+   * {@link #getOutputChannelCount()} and {@link #getOutputEncoding()} return the processor's output
+   * format.
    *
    * @param sampleRateHz The sample rate of input audio in Hz.
    * @param channelCount The number of interleaved channels in input audio.
@@ -65,16 +74,27 @@ boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
   boolean isActive();
 
   /**
-   * Returns the number of audio channels in the data output by the processor.
+   * Returns the number of audio channels in the data output by the processor. The value may change
+   * as a result of calling {@link #configure(int, int, int)} and is undefined if the instance is
+   * not active.
    */
   int getOutputChannelCount();
 
   /**
-   * Returns the audio encoding used in the data output by the processor.
+   * Returns the audio encoding used in the data output by the processor. The value may change as a
+   * result of calling {@link #configure(int, int, int)} and is undefined if the instance is not
+   * active.
    */
   @C.Encoding
   int getOutputEncoding();
 
+  /**
+   * Returns the sample rate of audio output by the processor, in hertz. The value may change as a
+   * result of calling {@link #configure(int, int, int)} and is undefined if the instance is not
+   * active.
+   */
+  int getOutputSampleRateHz();
+
   /**
    * Queues audio data between the position and limit of the input {@code buffer} for processing.
    * {@code buffer} must be a direct byte buffer with native byte order. Its contents are treated as
@@ -116,7 +136,7 @@ boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
   void flush();
 
   /**
-   * Resets the processor to its initial state.
+   * Resets the processor to its unconfigured state.
    */
   void reset();
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
index 612018917b..7a4958a61a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
@@ -17,6 +17,7 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Renderer;
@@ -62,15 +63,15 @@ void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
   void onAudioInputFormatChanged(Format format);
 
   /**
-   * Called when an {@link AudioTrack} underrun occurs.
+   * Called when an {@link AudioSink} underrun occurs.
    *
-   * @param bufferSize The size of the {@link AudioTrack}'s buffer, in bytes.
-   * @param bufferSizeMs The size of the {@link AudioTrack}'s buffer, in milliseconds, if it is
+   * @param bufferSize The size of the {@link AudioSink}'s buffer, in bytes.
+   * @param bufferSizeMs The size of the {@link AudioSink}'s buffer, in milliseconds, if it is
    *     configured for PCM output. {@link C#TIME_UNSET} if it is configured for passthrough output,
    *     as the buffered media can have a variable bitrate so the duration may be unknown.
-   * @param elapsedSinceLastFeedMs The time since the {@link AudioTrack} was last fed data.
+   * @param elapsedSinceLastFeedMs The time since the {@link AudioSink} was last fed data.
    */
-  void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+  void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
 
   /**
    * Called when the renderer is disabled.
@@ -84,15 +85,16 @@ void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
    */
   final class EventDispatcher {
 
-    private final Handler handler;
-    private final AudioRendererEventListener listener;
+    @Nullable private final Handler handler;
+    @Nullable private final AudioRendererEventListener listener;
 
     /**
      * @param handler A handler for dispatching events, or null if creating a dummy instance.
      * @param listener The listener to which events should be dispatched, or null if creating a
      *     dummy instance.
      */
-    public EventDispatcher(Handler handler, AudioRendererEventListener listener) {
+    public EventDispatcher(@Nullable Handler handler,
+        @Nullable AudioRendererEventListener listener) {
       this.handler = listener != null ? Assertions.checkNotNull(handler) : null;
       this.listener = listener;
     }
@@ -142,7 +144,7 @@ public void run() {
     }
 
     /**
-     * Invokes {@link AudioRendererEventListener#onAudioTrackUnderrun(int, long, long)}.
+     * Invokes {@link AudioRendererEventListener#onAudioSinkUnderrun(int, long, long)}.
      */
     public void audioTrackUnderrun(final int bufferSize, final long bufferSizeMs,
         final long elapsedSinceLastFeedMs) {
@@ -150,7 +152,7 @@ public void audioTrackUnderrun(final int bufferSize, final long bufferSizeMs,
         handler.post(new Runnable()  {
           @Override
           public void run() {
-            listener.onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+            listener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
           }
         });
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
new file mode 100644
index 0000000000..5408032907
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import android.media.AudioTrack;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.PlaybackParameters;
+import java.nio.ByteBuffer;
+
+/**
+ * A sink that consumes audio data.
+ * <p>
+ * Before starting playback, specify the input audio format by calling
+ * {@link #configure(String, int, int, int, int, int[], int, int)}.
+ * <p>
+ * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
+ * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
+ * <p>
+ * Call {@link #configure(String, int, int, int, int, int[], int, int)} whenever the input format
+ * changes. The sink will be reinitialized on the next call to
+ * {@link #handleBuffer(ByteBuffer, long)}.
+ * <p>
+ * Call {@link #reset()} to prepare the sink to receive audio data from a new playback position.
+ * <p>
+ * Call {@link #playToEndOfStream()} repeatedly to play out all data when no more input buffers will
+ * be provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #reset()}. Call
+ * {@link #release()} when the instance is no longer required.
+ * <p>
+ * The implementation may be backed by a platform {@link AudioTrack}. In this case,
+ * {@link #setAudioSessionId(int)}, {@link #setAudioAttributes(AudioAttributes)},
+ * {@link #enableTunnelingV21(int)} and/or {@link #disableTunneling()} may be called before writing
+ * data to the sink. These methods may also be called after writing data to the sink, in which case
+ * it will be reinitialized as required. For implementations that are not based on platform
+ * {@link AudioTrack}s, calling methods relating to audio sessions, audio attributes, and tunneling
+ * may have no effect.
+ */
+public interface AudioSink {
+
+  /**
+   * Listener for audio sink events.
+   */
+  interface Listener {
+
+    /**
+     * Called if the audio sink has started rendering audio to a new platform audio session.
+     *
+     * @param audioSessionId The newly generated audio session's identifier.
+     */
+    void onAudioSessionId(int audioSessionId);
+
+    /**
+     * Called when the audio sink handles a buffer whose timestamp is discontinuous with the last
+     * buffer handled since it was reset.
+     */
+    void onPositionDiscontinuity();
+
+    /**
+     * Called when the audio sink runs out of data.
+     * <p>
+     * An audio sink implementation may never call this method (for example, if audio data is
+     * consumed in batches rather than based on the sink's own clock).
+     *
+     * @param bufferSize The size of the sink's buffer, in bytes.
+     * @param bufferSizeMs The size of the sink's buffer, in milliseconds, if it is configured for
+     *     PCM output. {@link C#TIME_UNSET} if it is configured for passthrough output, as the
+     *     buffered media can have a variable bitrate so the duration may be unknown.
+     * @param elapsedSinceLastFeedMs The time since the sink was last fed data, in milliseconds.
+     */
+    void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+
+  }
+
+  /**
+   * Thrown when a failure occurs configuring the sink.
+   */
+  final class ConfigurationException extends Exception {
+
+    /**
+     * Creates a new configuration exception with the specified {@code cause} and no message.
+     */
+    public ConfigurationException(Throwable cause) {
+      super(cause);
+    }
+
+    /**
+     * Creates a new configuration exception with the specified {@code message} and no cause.
+     */
+    public ConfigurationException(String message) {
+      super(message);
+    }
+
+  }
+
+  /**
+   * Thrown when a failure occurs initializing the sink.
+   */
+  final class InitializationException extends Exception {
+
+    /**
+     * The underlying {@link AudioTrack}'s state, if applicable.
+     */
+    public final int audioTrackState;
+
+    /**
+     * @param audioTrackState The underlying {@link AudioTrack}'s state, if applicable.
+     * @param sampleRate The requested sample rate in Hz.
+     * @param channelConfig The requested channel configuration.
+     * @param bufferSize The requested buffer size in bytes.
+     */
+    public InitializationException(int audioTrackState, int sampleRate, int channelConfig,
+        int bufferSize) {
+      super("AudioTrack init failed: " + audioTrackState + ", Config(" + sampleRate + ", "
+          + channelConfig + ", " + bufferSize + ")");
+      this.audioTrackState = audioTrackState;
+    }
+
+  }
+
+  /**
+   * Thrown when a failure occurs writing to the sink.
+   */
+  final class WriteException extends Exception {
+
+    /**
+     * The error value returned from the sink implementation. If the sink writes to a platform
+     * {@link AudioTrack}, this will be the error value returned from
+     * {@link AudioTrack#write(byte[], int, int)} or {@link AudioTrack#write(ByteBuffer, int, int)}.
+     * Otherwise, the meaning of the error code depends on the sink implementation.
+     */
+    public final int errorCode;
+
+    /**
+     * @param errorCode The error value returned from the sink implementation.
+     */
+    public WriteException(int errorCode) {
+      super("AudioTrack write failed: " + errorCode);
+      this.errorCode = errorCode;
+    }
+
+  }
+
+  /**
+   * Returned by {@link #getCurrentPositionUs(boolean)} when the position is not set.
+   */
+  long CURRENT_POSITION_NOT_SET = Long.MIN_VALUE;
+
+  /**
+   * Sets the listener for sink events, which should be the audio renderer.
+   *
+   * @param listener The listener for sink events, which should be the audio renderer.
+   */
+  void setListener(Listener listener);
+
+  /**
+   * Returns whether it's possible to play audio in the specified format using encoded audio
+   * passthrough.
+   *
+   * @param mimeType The format mime type.
+   * @return Whether it's possible to play audio in the format using encoded audio passthrough.
+   */
+  boolean isPassthroughSupported(String mimeType);
+
+  /**
+   * Returns the playback position in the stream starting at zero, in microseconds, or
+   * {@link #CURRENT_POSITION_NOT_SET} if it is not yet available.
+   *
+   * @param sourceEnded Specify {@code true} if no more input buffers will be provided.
+   * @return The playback position relative to the start of playback, in microseconds.
+   */
+  long getCurrentPositionUs(boolean sourceEnded);
+
+  /**
+   * Configures (or reconfigures) the sink.
+   *
+   * @param inputMimeType The MIME type of audio data provided in the input buffers.
+   * @param inputChannelCount The number of channels.
+   * @param inputSampleRate The sample rate in Hz.
+   * @param inputPcmEncoding For PCM formats, the encoding used. One of
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT}
+   *     and {@link C#ENCODING_PCM_32BIT}.
+   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
+   *     suitable buffer size.
+   * @param outputChannels A mapping from input to output channels that is applied to this sink's
+   *     input as a preprocessing step, if handling PCM input. Specify {@code null} to leave the
+   *     input unchanged. Otherwise, the element at index {@code i} specifies index of the input
+   *     channel to map to output channel {@code i} when preprocessing input buffers. After the
+   *     map is applied the audio data will have {@code outputChannels.length} channels.
+   * @param trimStartSamples The number of audio samples to trim from the start of data written to
+   *     the sink after this call.
+   * @param trimEndSamples The number of audio samples to trim from data written to the sink
+   *     immediately preceding the next call to {@link #reset()} or this method.
+   * @throws ConfigurationException If an error occurs configuring the sink.
+   */
+  void configure(String inputMimeType, int inputChannelCount, int inputSampleRate,
+      @C.PcmEncoding int inputPcmEncoding, int specifiedBufferSize, @Nullable int[] outputChannels,
+      int trimStartSamples, int trimEndSamples) throws ConfigurationException;
+
+  /**
+   * Starts or resumes consuming audio if initialized.
+   */
+  void play();
+
+  /**
+   * Signals to the sink that the next buffer is discontinuous with the previous buffer.
+   */
+  void handleDiscontinuity();
+
+  /**
+   * Attempts to process data from a {@link ByteBuffer}, starting from its current position and
+   * ending at its limit (exclusive). The position of the {@link ByteBuffer} is advanced by the
+   * number of bytes that were handled. {@link Listener#onPositionDiscontinuity()} will be called if
+   * {@code presentationTimeUs} is discontinuous with the last buffer handled since the last reset.
+   * <p>
+   * Returns whether the data was handled in full. If the data was not handled in full then the same
+   * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
+   * except in the case of an intervening call to {@link #reset()} (or to
+   * {@link #configure(String, int, int, int, int, int[], int, int)} that causes the sink to be
+   * reset).
+   *
+   * @param buffer The buffer containing audio data.
+   * @param presentationTimeUs The presentation timestamp of the buffer in microseconds.
+   * @return Whether the buffer was handled fully.
+   * @throws InitializationException If an error occurs initializing the sink.
+   * @throws WriteException If an error occurs writing the audio data.
+   */
+  boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
+      throws InitializationException, WriteException;
+
+  /**
+   * Processes any remaining data. {@link #isEnded()} will return {@code true} when no data remains.
+   *
+   * @throws WriteException If an error occurs draining data to the sink.
+   */
+  void playToEndOfStream() throws WriteException;
+
+  /**
+   * Returns whether {@link #playToEndOfStream} has been called and all buffers have been processed.
+   */
+  boolean isEnded();
+
+  /**
+   * Returns whether the sink has data pending that has not been consumed yet.
+   */
+  boolean hasPendingData();
+
+  /**
+   * Attempts to set the playback parameters and returns the active playback parameters, which may
+   * differ from those passed in.
+   *
+   * @param playbackParameters The new playback parameters to attempt to set.
+   * @return The active playback parameters.
+   */
+  PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters);
+
+  /**
+   * Gets the active {@link PlaybackParameters}.
+   */
+  PlaybackParameters getPlaybackParameters();
+
+  /**
+   * Sets attributes for audio playback. If the attributes have changed and if the sink is not
+   * configured for use with tunneling, then it is reset and the audio session id is cleared.
+   * <p>
+   * If the sink is configured for use with tunneling then the audio attributes are ignored. The
+   * sink is not reset and the audio session id is not cleared. The passed attributes will be used
+   * if the sink is later re-configured into non-tunneled mode.
+   *
+   * @param audioAttributes The attributes for audio playback.
+   */
+  void setAudioAttributes(AudioAttributes audioAttributes);
+
+  /**
+   * Sets the audio session id.
+   */
+  void setAudioSessionId(int audioSessionId);
+
+  /**
+   * Enables tunneling, if possible. The sink is reset if tunneling was previously disabled or if
+   * the audio session id has changed. Enabling tunneling is only possible if the sink is based on a
+   * platform {@link AudioTrack}, and requires platform API version 21 onwards.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use.
+   * @throws IllegalStateException Thrown if enabling tunneling on platform API version &lt; 21.
+   */
+  void enableTunnelingV21(int tunnelingAudioSessionId);
+
+  /**
+   * Disables tunneling. If tunneling was previously enabled then the sink is reset and any audio
+   * session id is cleared.
+   */
+  void disableTunneling();
+
+  /**
+   * Sets the playback volume.
+   *
+   * @param volume A volume in the range [0.0, 1.0].
+   */
+  void setVolume(float volume);
+
+  /**
+   * Pauses playback.
+   */
+  void pause();
+
+  /**
+   * Resets the sink, after which it is ready to receive buffers from a new playback position.
+   * <p>
+   * The audio session may remain active until {@link #release()} is called.
+   */
+  void reset();
+
+  /**
+   * Releases any resources associated with this instance.
+   */
+  void release();
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
index b755776f1e..c3f3e32526 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
@@ -52,7 +52,7 @@ public ChannelMappingAudioProcessor() {
    * Resets the channel mapping. After calling this method, call {@link #configure(int, int, int)}
    * to start using the new channel map.
    *
-   * @see AudioTrack#configure(String, int, int, int, int, int[])
+   * @see AudioSink#configure(String, int, int, int, int, int[], int, int)
    */
   public void setChannelMap(int[] outputChannels) {
     pendingOutputChannels = outputChannels;
@@ -103,6 +103,11 @@ public int getOutputEncoding() {
     return C.ENCODING_PCM_16BIT;
   }
 
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
     int position = inputBuffer.position();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
similarity index 73%
rename from library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
rename to library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 79cb26bf39..73c0bc20be 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -20,14 +20,19 @@
 import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.AudioTimestamp;
+import android.media.AudioTrack;
 import android.os.ConditionVariable;
 import android.os.SystemClock;
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -35,129 +40,19 @@
 import java.util.LinkedList;
 
 /**
- * Plays audio data. The implementation delegates to an {@link android.media.AudioTrack} and handles
- * playback position smoothing, non-blocking writes and reconfiguration.
+ * Plays audio data. The implementation delegates to an {@link AudioTrack} and handles playback
+ * position smoothing, non-blocking writes and reconfiguration.
  * <p>
- * Before starting playback, specify the input format by calling
- * {@link #configure(String, int, int, int, int)}. Optionally call {@link #setAudioSessionId(int)},
- * {@link #setAudioAttributes(AudioAttributes)}, {@link #enableTunnelingV21(int)} and
- * {@link #disableTunneling()} to configure audio playback. These methods may be called after
- * writing data to the track, in which case it will be reinitialized as required.
- * <p>
- * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
- * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
- * <p>
- * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. The track
- * will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long)}.
- * <p>
- * Calling {@link #reset()} releases the underlying {@link android.media.AudioTrack} (and so does
- * calling {@link #configure(String, int, int, int, int)} unless the format is unchanged). It is
- * safe to call {@link #handleBuffer(ByteBuffer, long)} after {@link #reset()} without calling
- * {@link #configure(String, int, int, int, int)}.
- * <p>
- * Call {@link #playToEndOfStream()} repeatedly to play out all data when no more input buffers will
- * be provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #reset}. Call
- * {@link #release()} when the instance is no longer required.
+ * If tunneling mode is enabled, care must be taken that audio processors do not output buffers with
+ * a different duration than their input, and buffer processors must produce output corresponding to
+ * their last input immediately after that input is queued. This means that, for example, speed
+ * adjustment is not possible while using tunneling.
  */
-public final class AudioTrack {
-
-  /**
-   * Listener for audio track events.
-   */
-  public interface Listener {
-
-    /**
-     * Called when the audio track has been initialized with a newly generated audio session id.
-     *
-     * @param audioSessionId The newly generated audio session id.
-     */
-    void onAudioSessionId(int audioSessionId);
-
-    /**
-     * Called when the audio track handles a buffer whose timestamp is discontinuous with the last
-     * buffer handled since it was reset.
-     */
-    void onPositionDiscontinuity();
-
-    /**
-     * Called when the audio track underruns.
-     *
-     * @param bufferSize The size of the track's buffer, in bytes.
-     * @param bufferSizeMs The size of the track's buffer, in milliseconds, if it is configured for
-     *     PCM output. {@link C#TIME_UNSET} if it is configured for passthrough output, as the
-     *     buffered media can have a variable bitrate so the duration may be unknown.
-     * @param elapsedSinceLastFeedMs The time since the track was last fed data, in milliseconds.
-     */
-    void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
-
-  }
-
-  /**
-   * Thrown when a failure occurs configuring the track.
-   */
-  public static final class ConfigurationException extends Exception {
-
-    public ConfigurationException(Throwable cause) {
-      super(cause);
-    }
-
-    public ConfigurationException(String message) {
-      super(message);
-    }
-
-  }
-
-  /**
-   * Thrown when a failure occurs initializing an {@link android.media.AudioTrack}.
-   */
-  public static final class InitializationException extends Exception {
-
-    /**
-     * The state as reported by {@link android.media.AudioTrack#getState()}.
-     */
-    public final int audioTrackState;
-
-    /**
-     * @param audioTrackState The state as reported by {@link android.media.AudioTrack#getState()}.
-     * @param sampleRate The requested sample rate in Hz.
-     * @param channelConfig The requested channel configuration.
-     * @param bufferSize The requested buffer size in bytes.
-     */
-    public InitializationException(int audioTrackState, int sampleRate, int channelConfig,
-        int bufferSize) {
-      super("AudioTrack init failed: " + audioTrackState + ", Config(" + sampleRate + ", "
-          + channelConfig + ", " + bufferSize + ")");
-      this.audioTrackState = audioTrackState;
-    }
-
-  }
-
-  /**
-   * Thrown when a failure occurs writing to an {@link android.media.AudioTrack}.
-   */
-  public static final class WriteException extends Exception {
-
-    /**
-     * The error value returned from {@link android.media.AudioTrack#write(byte[], int, int)} or
-     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
-     */
-    public final int errorCode;
-
-    /**
-     * @param errorCode The error value returned from
-     *     {@link android.media.AudioTrack#write(byte[], int, int)} or
-     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
-     */
-    public WriteException(int errorCode) {
-      super("AudioTrack write failed: " + errorCode);
-      this.errorCode = errorCode;
-    }
-
-  }
+public final class DefaultAudioSink implements AudioSink {
 
   /**
-   * Thrown when {@link android.media.AudioTrack#getTimestamp} returns a spurious timestamp, if
-   * {@code AudioTrack#failOnSpuriousAudioTimestamp} is set.
+   * Thrown when {@link AudioTrack#getTimestamp} returns a spurious timestamp, if
+   * {@link #failOnSpuriousAudioTimestamp} is set.
    */
   public static final class InvalidAudioTrackTimestampException extends RuntimeException {
 
@@ -171,61 +66,56 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   }
 
   /**
-   * Returned by {@link #getCurrentPositionUs(boolean)} when the position is not set.
-   */
-  public static final long CURRENT_POSITION_NOT_SET = Long.MIN_VALUE;
-
-  /**
-   * A minimum length for the {@link android.media.AudioTrack} buffer, in microseconds.
+   * A minimum length for the {@link AudioTrack} buffer, in microseconds.
    */
   private static final long MIN_BUFFER_DURATION_US = 250000;
   /**
-   * A maximum length for the {@link android.media.AudioTrack} buffer, in microseconds.
+   * A maximum length for the {@link AudioTrack} buffer, in microseconds.
    */
   private static final long MAX_BUFFER_DURATION_US = 750000;
   /**
-   * The length for passthrough {@link android.media.AudioTrack} buffers, in microseconds.
+   * The length for passthrough {@link AudioTrack} buffers, in microseconds.
    */
   private static final long PASSTHROUGH_BUFFER_DURATION_US = 250000;
   /**
    * A multiplication factor to apply to the minimum buffer size requested by the underlying
-   * {@link android.media.AudioTrack}.
+   * {@link AudioTrack}.
    */
   private static final int BUFFER_MULTIPLICATION_FACTOR = 4;
 
   /**
-   * @see android.media.AudioTrack#PLAYSTATE_STOPPED
+   * @see AudioTrack#PLAYSTATE_STOPPED
    */
-  private static final int PLAYSTATE_STOPPED = android.media.AudioTrack.PLAYSTATE_STOPPED;
+  private static final int PLAYSTATE_STOPPED = AudioTrack.PLAYSTATE_STOPPED;
   /**
-   * @see android.media.AudioTrack#PLAYSTATE_PAUSED
+   * @see AudioTrack#PLAYSTATE_PAUSED
    */
-  private static final int PLAYSTATE_PAUSED = android.media.AudioTrack.PLAYSTATE_PAUSED;
+  private static final int PLAYSTATE_PAUSED = AudioTrack.PLAYSTATE_PAUSED;
   /**
-   * @see android.media.AudioTrack#PLAYSTATE_PLAYING
+   * @see AudioTrack#PLAYSTATE_PLAYING
    */
-  private static final int PLAYSTATE_PLAYING = android.media.AudioTrack.PLAYSTATE_PLAYING;
+  private static final int PLAYSTATE_PLAYING = AudioTrack.PLAYSTATE_PLAYING;
   /**
-   * @see android.media.AudioTrack#ERROR_BAD_VALUE
+   * @see AudioTrack#ERROR_BAD_VALUE
    */
-  private static final int ERROR_BAD_VALUE = android.media.AudioTrack.ERROR_BAD_VALUE;
+  private static final int ERROR_BAD_VALUE = AudioTrack.ERROR_BAD_VALUE;
   /**
-   * @see android.media.AudioTrack#MODE_STATIC
+   * @see AudioTrack#MODE_STATIC
    */
-  private static final int MODE_STATIC = android.media.AudioTrack.MODE_STATIC;
+  private static final int MODE_STATIC = AudioTrack.MODE_STATIC;
   /**
-   * @see android.media.AudioTrack#MODE_STREAM
+   * @see AudioTrack#MODE_STREAM
    */
-  private static final int MODE_STREAM = android.media.AudioTrack.MODE_STREAM;
+  private static final int MODE_STREAM = AudioTrack.MODE_STREAM;
   /**
-   * @see android.media.AudioTrack#STATE_INITIALIZED
+   * @see AudioTrack#STATE_INITIALIZED
    */
-  private static final int STATE_INITIALIZED = android.media.AudioTrack.STATE_INITIALIZED;
+  private static final int STATE_INITIALIZED = AudioTrack.STATE_INITIALIZED;
   /**
-   * @see android.media.AudioTrack#WRITE_NON_BLOCKING
+   * @see AudioTrack#WRITE_NON_BLOCKING
    */
   @SuppressLint("InlinedApi")
-  private static final int WRITE_NON_BLOCKING = android.media.AudioTrack.WRITE_NON_BLOCKING;
+  private static final int WRITE_NON_BLOCKING = AudioTrack.WRITE_NON_BLOCKING;
 
   private static final String TAG = "AudioTrack";
 
@@ -244,6 +134,12 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
    */
   private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;
 
+  /**
+   * Represents states of the {@link #startMediaTimeUs} value.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({START_NOT_SET, START_IN_SYNC, START_NEED_SYNC})
+  private @interface StartMediaTimeState {}
   private static final int START_NOT_SET = 0;
   private static final int START_IN_SYNC = 1;
   private static final int START_NEED_SYNC = 2;
@@ -252,13 +148,6 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private static final int MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US = 30000;
   private static final int MIN_TIMESTAMP_SAMPLE_INTERVAL_US = 500000;
 
-  /**
-   * The minimum number of output bytes from {@link #sonicAudioProcessor} at which the speedup is
-   * calculated using the input/output byte counts from the processor, rather than using the
-   * current playback parameters speed.
-   */
-  private static final int SONIC_MIN_BYTES_FOR_SPEEDUP = 1024;
-
   /**
    * Whether to enable a workaround for an issue where an audio effect does not keep its session
    * active across releasing/initializing a new audio track, on platform builds where
@@ -270,35 +159,34 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
 
   /**
    * Whether to throw an {@link InvalidAudioTrackTimestampException} when a spurious timestamp is
-   * reported from {@link android.media.AudioTrack#getTimestamp}.
+   * reported from {@link AudioTrack#getTimestamp}.
    * <p>
    * The flag must be set before creating a player. Should be set to {@code true} for testing and
    * debugging purposes only.
    */
   public static boolean failOnSpuriousAudioTimestamp = false;
 
-  private final AudioCapabilities audioCapabilities;
+  @Nullable private final AudioCapabilities audioCapabilities;
   private final ChannelMappingAudioProcessor channelMappingAudioProcessor;
+  private final TrimmingAudioProcessor trimmingAudioProcessor;
   private final SonicAudioProcessor sonicAudioProcessor;
   private final AudioProcessor[] availableAudioProcessors;
-  private final Listener listener;
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
   private final LinkedList<PlaybackParametersCheckpoint> playbackParametersCheckpoints;
 
+  @Nullable private Listener listener;
   /**
    * Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}).
    */
-  private android.media.AudioTrack keepSessionIdAudioTrack;
-
-  private android.media.AudioTrack audioTrack;
+  private AudioTrack keepSessionIdAudioTrack;
+  private AudioTrack audioTrack;
+  private int inputSampleRate;
   private int sampleRate;
   private int channelConfig;
-  @C.Encoding
-  private int encoding;
-  @C.Encoding
-  private int outputEncoding;
+  private @C.Encoding int encoding;
+  private @C.Encoding int outputEncoding;
   private AudioAttributes audioAttributes;
   private boolean passthrough;
   private int bufferSize;
@@ -327,7 +215,7 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private long writtenPcmBytes;
   private long writtenEncodedFrames;
   private int framesPerEncodedSample;
-  private int startMediaTimeState;
+  private @StartMediaTimeState int startMediaTimeState;
   private long startMediaTimeUs;
   private long resumeSystemTimeUs;
   private long latencyUs;
@@ -353,17 +241,15 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
    *     default capabilities (no encoded audio passthrough support) should be assumed.
    * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio before
    *     output. May be empty.
-   * @param listener Listener for audio track events.
    */
-  public AudioTrack(AudioCapabilities audioCapabilities, AudioProcessor[] audioProcessors,
-      Listener listener) {
+  public DefaultAudioSink(@Nullable AudioCapabilities audioCapabilities,
+      AudioProcessor[] audioProcessors) {
     this.audioCapabilities = audioCapabilities;
-    this.listener = listener;
     releasingConditionVariable = new ConditionVariable(true);
     if (Util.SDK_INT >= 18) {
       try {
         getLatencyMethod =
-            android.media.AudioTrack.class.getMethod("getLatency", (Class<?>[]) null);
+            AudioTrack.class.getMethod("getLatency", (Class<?>[]) null);
       } catch (NoSuchMethodException e) {
         // There's no guarantee this method exists. Do nothing.
       }
@@ -374,12 +260,14 @@ public AudioTrack(AudioCapabilities audioCapabilities, AudioProcessor[] audioPro
       audioTrackUtil = new AudioTrackUtil();
     }
     channelMappingAudioProcessor = new ChannelMappingAudioProcessor();
+    trimmingAudioProcessor = new TrimmingAudioProcessor();
     sonicAudioProcessor = new SonicAudioProcessor();
-    availableAudioProcessors = new AudioProcessor[3 + audioProcessors.length];
+    availableAudioProcessors = new AudioProcessor[4 + audioProcessors.length];
     availableAudioProcessors[0] = new ResamplingAudioProcessor();
     availableAudioProcessors[1] = channelMappingAudioProcessor;
-    System.arraycopy(audioProcessors, 0, availableAudioProcessors, 2, audioProcessors.length);
-    availableAudioProcessors[2 + audioProcessors.length] = sonicAudioProcessor;
+    availableAudioProcessors[2] = trimmingAudioProcessor;
+    System.arraycopy(audioProcessors, 0, availableAudioProcessors, 3, audioProcessors.length);
+    availableAudioProcessors[3 + audioProcessors.length] = sonicAudioProcessor;
     playheadOffsets = new long[MAX_PLAYHEAD_OFFSET_COUNT];
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
@@ -392,28 +280,18 @@ public AudioTrack(AudioCapabilities audioCapabilities, AudioProcessor[] audioPro
     playbackParametersCheckpoints = new LinkedList<>();
   }
 
-  /**
-   * Returns whether it's possible to play audio in the specified format using encoded passthrough.
-   *
-   * @param mimeType The format mime type.
-   * @return Whether it's possible to play audio in the format using encoded passthrough.
-   */
+  @Override
+  public void setListener(Listener listener) {
+    this.listener = listener;
+  }
+
+  @Override
   public boolean isPassthroughSupported(String mimeType) {
     return audioCapabilities != null
         && audioCapabilities.supportsEncoding(getEncodingForMimeType(mimeType));
   }
 
-  /**
-   * Returns the playback position in the stream starting at zero, in microseconds, or
-   * {@link #CURRENT_POSITION_NOT_SET} if it is not yet available.
-   *
-   * <p>If the device supports it, the method uses the playback timestamp from
-   * {@link android.media.AudioTrack#getTimestamp}. Otherwise, it derives a smoothed position by
-   * sampling the {@link android.media.AudioTrack}'s frame position.
-   *
-   * @param sourceEnded Specify {@code true} if no more input buffers will be provided.
-   * @return The playback position relative to the start of playback, in microseconds.
-   */
+  @Override
   public long getCurrentPositionUs(boolean sourceEnded) {
     if (!hasCurrentPositionUs()) {
       return CURRENT_POSITION_NOT_SET;
@@ -423,6 +301,8 @@ public long getCurrentPositionUs(boolean sourceEnded) {
       maybeSampleSyncParams();
     }
 
+    // If the device supports it, use the playback timestamp from AudioTrack.getTimestamp.
+    // Otherwise, derive a smoothed position by sampling the track's frame position.
     long systemClockUs = System.nanoTime() / 1000;
     long positionUs;
     if (audioTimestampSet) {
@@ -446,53 +326,24 @@ public long getCurrentPositionUs(boolean sourceEnded) {
       }
     }
 
+    positionUs = Math.min(positionUs, framesToDurationUs(getWrittenFrames()));
     return startMediaTimeUs + applySpeedup(positionUs);
   }
 
-  /**
-   * Configures (or reconfigures) the audio track.
-   *
-   * @param mimeType The mime type.
-   * @param channelCount The number of channels.
-   * @param sampleRate The sample rate in Hz.
-   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
-   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
-   *     {@link C#ENCODING_PCM_32BIT}.
-   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
-   *     suitable buffer size automatically.
-   * @throws ConfigurationException If an error occurs configuring the track.
-   */
-  public void configure(String mimeType, int channelCount, int sampleRate,
-      @C.PcmEncoding int pcmEncoding, int specifiedBufferSize) throws ConfigurationException {
-    configure(mimeType, channelCount, sampleRate, pcmEncoding, specifiedBufferSize, null);
-  }
-
-  /**
-   * Configures (or reconfigures) the audio track.
-   *
-   * @param mimeType The mime type.
-   * @param channelCount The number of channels.
-   * @param sampleRate The sample rate in Hz.
-   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
-   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
-   *     {@link C#ENCODING_PCM_32BIT}.
-   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
-   *     suitable buffer size automatically.
-   * @param outputChannels A mapping from input to output channels that is applied to this track's
-   *     input as a preprocessing step, if handling PCM input. Specify {@code null} to leave the
-   *     input unchanged. Otherwise, the element at index {@code i} specifies index of the input
-   *     channel to map to output channel {@code i} when preprocessing input buffers. After the
-   *     map is applied the audio data will have {@code outputChannels.length} channels.
-   * @throws ConfigurationException If an error occurs configuring the track.
-   */
-  public void configure(String mimeType, int channelCount, int sampleRate,
-      @C.PcmEncoding int pcmEncoding, int specifiedBufferSize, int[] outputChannels)
-      throws ConfigurationException {
-    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
-    @C.Encoding int encoding = passthrough ? getEncodingForMimeType(mimeType) : pcmEncoding;
+  @Override
+  public void configure(String inputMimeType, int inputChannelCount, int inputSampleRate,
+      @C.PcmEncoding int inputPcmEncoding, int specifiedBufferSize, @Nullable int[] outputChannels,
+      int trimStartSamples, int trimEndSamples) throws ConfigurationException {
+    this.inputSampleRate = inputSampleRate;
+    int channelCount = inputChannelCount;
+    int sampleRate = inputSampleRate;
+    @C.Encoding int encoding;
+    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(inputMimeType);
     boolean flush = false;
     if (!passthrough) {
-      pcmFrameSize = Util.getPcmFrameSize(pcmEncoding, channelCount);
+      encoding = inputPcmEncoding;
+      pcmFrameSize = Util.getPcmFrameSize(inputPcmEncoding, channelCount);
+      trimmingAudioProcessor.setTrimSampleCount(trimStartSamples, trimEndSamples);
       channelMappingAudioProcessor.setChannelMap(outputChannels);
       for (AudioProcessor audioProcessor : availableAudioProcessors) {
         try {
@@ -502,12 +353,15 @@ public void configure(String mimeType, int channelCount, int sampleRate,
         }
         if (audioProcessor.isActive()) {
           channelCount = audioProcessor.getOutputChannelCount();
+          sampleRate = audioProcessor.getOutputSampleRateHz();
           encoding = audioProcessor.getOutputEncoding();
         }
       }
       if (flush) {
         resetAudioProcessors();
       }
+    } else {
+      encoding = getEncodingForMimeType(inputMimeType);
     }
 
     int channelConfig;
@@ -589,8 +443,7 @@ public void configure(String mimeType, int channelCount, int sampleRate,
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
       }
     } else {
-      int minBufferSize =
-          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, outputEncoding);
+      int minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, outputEncoding);
       Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
       int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
@@ -650,7 +503,9 @@ private void initialize() throws InitializationException {
     }
     if (this.audioSessionId != audioSessionId) {
       this.audioSessionId = audioSessionId;
-      listener.onAudioSessionId(audioSessionId);
+      if (listener != null) {
+        listener.onAudioSessionId(audioSessionId);
+      }
     }
 
     audioTrackUtil.reconfigure(audioTrack, needsPassthroughWorkarounds());
@@ -658,9 +513,7 @@ private void initialize() throws InitializationException {
     hasData = false;
   }
 
-  /**
-   * Starts or resumes playing audio if the audio track has been initialized.
-   */
+  @Override
   public void play() {
     playing = true;
     if (isInitialized()) {
@@ -669,9 +522,7 @@ public void play() {
     }
   }
 
-  /**
-   * Signals to the audio track that the next buffer is discontinuous with the previous buffer.
-   */
+  @Override
   public void handleDiscontinuity() {
     // Force resynchronization after a skipped buffer.
     if (startMediaTimeState == START_IN_SYNC) {
@@ -679,23 +530,7 @@ public void handleDiscontinuity() {
     }
   }
 
-  /**
-   * Attempts to process data from a {@link ByteBuffer}, starting from its current position and
-   * ending at its limit (exclusive). The position of the {@link ByteBuffer} is advanced by the
-   * number of bytes that were handled. {@link Listener#onPositionDiscontinuity()} will be called if
-   * {@code presentationTimeUs} is discontinuous with the last buffer handled since the last reset.
-   * <p>
-   * Returns whether the data was handled in full. If the data was not handled in full then the same
-   * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
-   * except in the case of an interleaving call to {@link #reset()} (or an interleaving call to
-   * {@link #configure(String, int, int, int, int)} that caused the track to be reset).
-   *
-   * @param buffer The buffer containing audio data.
-   * @param presentationTimeUs The presentation timestamp of the buffer in microseconds.
-   * @return Whether the buffer was handled fully.
-   * @throws InitializationException If an error occurs initializing the track.
-   * @throws WriteException If an error occurs writing the audio data.
-   */
+  @Override
   @SuppressWarnings("ReferenceEquality")
   public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       throws InitializationException, WriteException {
@@ -727,7 +562,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
 
     boolean hadData = hasData;
     hasData = hasPendingData();
-    if (hadData && !hasData && audioTrack.getPlayState() != PLAYSTATE_STOPPED) {
+    if (hadData && !hasData && audioTrack.getPlayState() != PLAYSTATE_STOPPED && listener != null) {
       long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
       listener.onUnderrun(bufferSize, C.usToMs(bufferSizeUs), elapsedSinceLastFeedMs);
     }
@@ -764,8 +599,8 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         startMediaTimeState = START_IN_SYNC;
       } else {
         // Sanity check that presentationTimeUs is consistent with the expected value.
-        long expectedPresentationTimeUs = startMediaTimeUs
-            + framesToDurationUs(getSubmittedFrames());
+        long expectedPresentationTimeUs =
+            startMediaTimeUs + inputFramesToDurationUs(getSubmittedFrames());
         if (startMediaTimeState == START_IN_SYNC
             && Math.abs(expectedPresentationTimeUs - presentationTimeUs) > 200000) {
           Log.e(TAG, "Discontinuity detected [expected " + expectedPresentationTimeUs + ", got "
@@ -777,7 +612,9 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
           // number of bytes submitted.
           startMediaTimeUs += (presentationTimeUs - expectedPresentationTimeUs);
           startMediaTimeState = START_IN_SYNC;
-          listener.onPositionDiscontinuity();
+          if (listener != null) {
+            listener.onPositionDiscontinuity();
+          }
         }
       }
 
@@ -801,6 +638,13 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       inputBuffer = null;
       return true;
     }
+
+    if (audioTrackUtil.needsReset(getWrittenFrames())) {
+      Log.w(TAG, "Resetting stalled audio track");
+      reset();
+      return true;
+    }
+
     return false;
   }
 
@@ -897,11 +741,7 @@ private boolean writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs)
     return false;
   }
 
-  /**
-   * Plays out remaining audio. {@link #isEnded()} will return {@code true} when playback has ended.
-   *
-   * @throws WriteException If an error occurs draining data to the track.
-   */
+  @Override
   public void playToEndOfStream() throws WriteException {
     if (handledEndOfStream || !isInitialized()) {
       return;
@@ -945,30 +785,19 @@ private boolean drainAudioProcessorsToEndOfStream() throws WriteException {
     return true;
   }
 
-  /**
-   * Returns whether all buffers passed to {@link #handleBuffer(ByteBuffer, long)} have been
-   * completely processed and played.
-   */
+  @Override
   public boolean isEnded() {
     return !isInitialized() || (handledEndOfStream && !hasPendingData());
   }
 
-  /**
-   * Returns whether the audio track has more data pending that will be played back.
-   */
+  @Override
   public boolean hasPendingData() {
     return isInitialized()
         && (getWrittenFrames() > audioTrackUtil.getPlaybackHeadPosition()
         || overrideHasPendingData());
   }
 
-  /**
-   * Attempts to set the playback parameters and returns the active playback parameters, which may
-   * differ from those passed in.
-   *
-   * @param playbackParameters The new playback parameters to attempt to set.
-   * @return The active playback parameters.
-   */
+  @Override
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
     if (passthrough) {
       // The playback parameters are always the default in passthrough mode.
@@ -995,24 +824,12 @@ public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParam
     return this.playbackParameters;
   }
 
-  /**
-   * Gets the {@link PlaybackParameters}.
-   */
+  @Override
   public PlaybackParameters getPlaybackParameters() {
     return playbackParameters;
   }
 
-  /**
-   * Sets the attributes for audio playback. If the attributes have changed and if the audio track
-   * is not configured for use with tunneling, then the audio track is reset and the audio session
-   * id is cleared.
-   * <p>
-   * If the audio track is configured for use with tunneling then the audio attributes are ignored.
-   * The audio track is not reset and the audio session id is not cleared. The passed attributes
-   * will be used if the audio track is later re-configured into non-tunneled mode.
-   *
-   * @param audioAttributes The attributes for audio playback.
-   */
+  @Override
   public void setAudioAttributes(AudioAttributes audioAttributes) {
     if (this.audioAttributes.equals(audioAttributes)) {
       return;
@@ -1026,9 +843,7 @@ public void setAudioAttributes(AudioAttributes audioAttributes) {
     audioSessionId = C.AUDIO_SESSION_ID_UNSET;
   }
 
-  /**
-   * Sets the audio session id. The audio track is reset if the audio session id has changed.
-   */
+  @Override
   public void setAudioSessionId(int audioSessionId) {
     if (this.audioSessionId != audioSessionId) {
       this.audioSessionId = audioSessionId;
@@ -1036,18 +851,7 @@ public void setAudioSessionId(int audioSessionId) {
     }
   }
 
-  /**
-   * Enables tunneling. The audio track is reset if tunneling was previously disabled or if the
-   * audio session id has changed. Enabling tunneling requires platform API version 21 onwards.
-   * <p>
-   * If this instance has {@link AudioProcessor}s and tunneling is enabled, care must be taken that
-   * audio processors do not output buffers with a different duration than their input, and buffer
-   * processors must produce output corresponding to their last input immediately after that input
-   * is queued.
-   *
-   * @param tunnelingAudioSessionId The audio session id to use.
-   * @throws IllegalStateException Thrown if enabling tunneling on platform API version &lt; 21.
-   */
+  @Override
   public void enableTunnelingV21(int tunnelingAudioSessionId) {
     Assertions.checkState(Util.SDK_INT >= 21);
     if (!tunneling || audioSessionId != tunnelingAudioSessionId) {
@@ -1057,10 +861,7 @@ public void enableTunnelingV21(int tunnelingAudioSessionId) {
     }
   }
 
-  /**
-   * Disables tunneling. If tunneling was previously enabled then the audio track is reset and the
-   * audio session id is cleared.
-   */
+  @Override
   public void disableTunneling() {
     if (tunneling) {
       tunneling = false;
@@ -1069,11 +870,7 @@ public void disableTunneling() {
     }
   }
 
-  /**
-   * Sets the playback volume.
-   *
-   * @param volume A volume in the range [0.0, 1.0].
-   */
+  @Override
   public void setVolume(float volume) {
     if (this.volume != volume) {
       this.volume = volume;
@@ -1091,9 +888,7 @@ private void setVolumeInternal() {
     }
   }
 
-  /**
-   * Pauses playback.
-   */
+  @Override
   public void pause() {
     playing = false;
     if (isInitialized()) {
@@ -1102,13 +897,7 @@ public void pause() {
     }
   }
 
-  /**
-   * Releases the underlying audio track asynchronously.
-   * <p>
-   * Calling {@link #handleBuffer(ByteBuffer, long)} will block until the audio track has been
-   * released, so it is safe to use the audio track immediately after a reset. The audio session may
-   * remain active until {@link #release()} is called.
-   */
+  @Override
   public void reset() {
     if (isInitialized()) {
       submittedPcmBytes = 0;
@@ -1144,7 +933,7 @@ public void reset() {
         audioTrack.pause();
       }
       // AudioTrack.release can take some time, so we call it on a background thread.
-      final android.media.AudioTrack toRelease = audioTrack;
+      final AudioTrack toRelease = audioTrack;
       audioTrack = null;
       audioTrackUtil.reconfigure(null, false);
       releasingConditionVariable.close();
@@ -1162,9 +951,7 @@ public void run() {
     }
   }
 
-  /**
-   * Releases all resources associated with this instance.
-   */
+  @Override
   public void release() {
     reset();
     releaseKeepSessionIdAudioTrack();
@@ -1184,7 +971,7 @@ private void releaseKeepSessionIdAudioTrack() {
     }
 
     // AudioTrack.release can take some time, so we call it on a background thread.
-    final android.media.AudioTrack toRelease = keepSessionIdAudioTrack;
+    final AudioTrack toRelease = keepSessionIdAudioTrack;
     keepSessionIdAudioTrack = null;
     new Thread() {
       @Override
@@ -1218,15 +1005,11 @@ private long applySpeedup(long positionUs) {
       return positionUs + playbackParametersOffsetUs - playbackParametersPositionUs;
     }
 
-    if (playbackParametersCheckpoints.isEmpty()
-        && sonicAudioProcessor.getOutputByteCount() >= SONIC_MIN_BYTES_FOR_SPEEDUP) {
+    if (playbackParametersCheckpoints.isEmpty()) {
       return playbackParametersOffsetUs
-          + Util.scaleLargeTimestamp(positionUs - playbackParametersPositionUs,
-          sonicAudioProcessor.getInputByteCount(), sonicAudioProcessor.getOutputByteCount());
+          + sonicAudioProcessor.scaleDurationForSpeedup(positionUs - playbackParametersPositionUs);
     }
-
-    // We are playing drained data at a previous playback speed, or don't have enough bytes to
-    // calculate an accurate speedup, so fall back to multiplying by the speed.
+    // We are playing data at a previous playback speed, so fall back to multiplying by the speed.
     return playbackParametersOffsetUs
         + (long) ((double) playbackParameters.speed * (positionUs - playbackParametersPositionUs));
   }
@@ -1319,6 +1102,10 @@ private boolean isInitialized() {
     return audioTrack != null;
   }
 
+  private long inputFramesToDurationUs(long frameCount) {
+    return (frameCount * C.MICROS_PER_SECOND) / inputSampleRate;
+  }
+
   private long framesToDurationUs(long frameCount) {
     return (frameCount * C.MICROS_PER_SECOND) / sampleRate;
   }
@@ -1365,19 +1152,19 @@ private boolean overrideHasPendingData() {
         && audioTrack.getPlaybackHeadPosition() == 0;
   }
 
-  private android.media.AudioTrack initializeAudioTrack() throws InitializationException {
-    android.media.AudioTrack audioTrack;
+  private AudioTrack initializeAudioTrack() throws InitializationException {
+    AudioTrack audioTrack;
     if (Util.SDK_INT >= 21) {
       audioTrack = createAudioTrackV21();
     } else {
       int streamType = Util.getStreamTypeForAudioUsage(audioAttributes.usage);
       if (audioSessionId == C.AUDIO_SESSION_ID_UNSET) {
-        audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-            outputEncoding, bufferSize, MODE_STREAM);
+        audioTrack = new AudioTrack(streamType, sampleRate, channelConfig, outputEncoding,
+            bufferSize, MODE_STREAM);
       } else {
         // Re-attach to the same audio session.
-        audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-            outputEncoding, bufferSize, MODE_STREAM, audioSessionId);
+        audioTrack = new AudioTrack(streamType, sampleRate, channelConfig, outputEncoding,
+            bufferSize, MODE_STREAM, audioSessionId);
       }
     }
 
@@ -1395,7 +1182,7 @@ private boolean overrideHasPendingData() {
   }
 
   @TargetApi(21)
-  private android.media.AudioTrack createAudioTrackV21() {
+  private AudioTrack createAudioTrackV21() {
     android.media.AudioAttributes attributes;
     if (tunneling) {
       attributes = new android.media.AudioAttributes.Builder()
@@ -1413,17 +1200,16 @@ private boolean overrideHasPendingData() {
         .build();
     int audioSessionId = this.audioSessionId != C.AUDIO_SESSION_ID_UNSET ? this.audioSessionId
         : AudioManager.AUDIO_SESSION_ID_GENERATE;
-    return new android.media.AudioTrack(attributes, format, bufferSize, MODE_STREAM,
-        audioSessionId);
+    return new AudioTrack(attributes, format, bufferSize, MODE_STREAM, audioSessionId);
   }
 
-  private android.media.AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
-    int sampleRate = 4000; // Equal to private android.media.AudioTrack.MIN_SAMPLE_RATE.
+  private AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
+    int sampleRate = 4000; // Equal to private AudioTrack.MIN_SAMPLE_RATE.
     int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
     @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;
     int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
-    return new android.media.AudioTrack(C.STREAM_TYPE_DEFAULT, sampleRate, channelConfig, encoding,
-        bufferSize, MODE_STATIC, audioSessionId);
+    return new AudioTrack(C.STREAM_TYPE_DEFAULT, sampleRate, channelConfig, encoding, bufferSize,
+        MODE_STATIC, audioSessionId);
   }
 
   @C.Encoding
@@ -1455,14 +1241,13 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
   }
 
   @TargetApi(21)
-  private static int writeNonBlockingV21(android.media.AudioTrack audioTrack, ByteBuffer buffer,
-      int size) {
+  private static int writeNonBlockingV21(AudioTrack audioTrack, ByteBuffer buffer, int size) {
     return audioTrack.write(buffer, size, WRITE_NON_BLOCKING);
   }
 
   @TargetApi(21)
-  private int writeNonBlockingWithAvSyncV21(android.media.AudioTrack audioTrack,
-      ByteBuffer buffer, int size, long presentationTimeUs) {
+  private int writeNonBlockingWithAvSyncV21(AudioTrack audioTrack, ByteBuffer buffer, int size,
+      long presentationTimeUs) {
     // TODO: Uncomment this when [Internal ref: b/33627517] is clarified or fixed.
     // if (Util.SDK_INT >= 23) {
     //   // The underlying platform AudioTrack writes AV sync headers directly.
@@ -1500,21 +1285,23 @@ private int writeNonBlockingWithAvSyncV21(android.media.AudioTrack audioTrack,
   }
 
   @TargetApi(21)
-  private static void setVolumeInternalV21(android.media.AudioTrack audioTrack, float volume) {
+  private static void setVolumeInternalV21(AudioTrack audioTrack, float volume) {
     audioTrack.setVolume(volume);
   }
 
   @SuppressWarnings("deprecation")
-  private static void setVolumeInternalV3(android.media.AudioTrack audioTrack, float volume) {
+  private static void setVolumeInternalV3(AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
   /**
-   * Wraps an {@link android.media.AudioTrack} to expose useful utility methods.
+   * Wraps an {@link AudioTrack} to expose useful utility methods.
    */
   private static class AudioTrackUtil {
 
-    protected android.media.AudioTrack audioTrack;
+    private static final long FORCE_RESET_WORKAROUND_TIMEOUT_MS = 200;
+
+    protected AudioTrack audioTrack;
     private boolean needsPassthroughWorkaround;
     private int sampleRate;
     private long lastRawPlaybackHeadPosition;
@@ -1522,6 +1309,7 @@ private static void setVolumeInternalV3(android.media.AudioTrack audioTrack, flo
     private long passthroughWorkaroundPauseOffset;
 
     private long stopTimestampUs;
+    private long forceResetWorkaroundTimeMs;
     private long stopPlaybackHeadPosition;
     private long endPlaybackHeadPosition;
 
@@ -1532,11 +1320,11 @@ private static void setVolumeInternalV3(android.media.AudioTrack audioTrack, flo
      * @param needsPassthroughWorkaround Whether to workaround issues with pausing AC-3 passthrough
      *     audio tracks on platform API version 21/22.
      */
-    public void reconfigure(android.media.AudioTrack audioTrack,
-        boolean needsPassthroughWorkaround) {
+    public void reconfigure(AudioTrack audioTrack, boolean needsPassthroughWorkaround) {
       this.audioTrack = audioTrack;
       this.needsPassthroughWorkaround = needsPassthroughWorkaround;
       stopTimestampUs = C.TIME_UNSET;
+      forceResetWorkaroundTimeMs = C.TIME_UNSET;
       lastRawPlaybackHeadPosition = 0;
       rawPlaybackHeadWrapCount = 0;
       passthroughWorkaroundPauseOffset = 0;
@@ -1572,9 +1360,20 @@ public void pause() {
     }
 
     /**
-     * {@link android.media.AudioTrack#getPlaybackHeadPosition()} returns a value intended to be
-     * interpreted as an unsigned 32 bit integer, which also wraps around periodically. This method
-     * returns the playback head position as a long that will only wrap around if the value exceeds
+     * Returns whether the track is in an invalid state and must be reset.
+     *
+     * @see #getPlaybackHeadPosition()
+     */
+    public boolean needsReset(long writtenFrames) {
+      return forceResetWorkaroundTimeMs != C.TIME_UNSET && writtenFrames > 0
+          && SystemClock.elapsedRealtime() - forceResetWorkaroundTimeMs
+              >= FORCE_RESET_WORKAROUND_TIMEOUT_MS;
+    }
+
+    /**
+     * {@link AudioTrack#getPlaybackHeadPosition()} returns a value intended to be interpreted as an
+     * unsigned 32 bit integer, which also wraps around periodically. This method returns the
+     * playback head position as a long that will only wrap around if the value exceeds
      * {@link Long#MAX_VALUE} (which in practice will never happen).
      *
      * @return The playback head position, in frames.
@@ -1603,6 +1402,24 @@ public long getPlaybackHeadPosition() {
         }
         rawPlaybackHeadPosition += passthroughWorkaroundPauseOffset;
       }
+
+      if (Util.SDK_INT <= 26) {
+        if (rawPlaybackHeadPosition == 0 && lastRawPlaybackHeadPosition > 0
+            && state == PLAYSTATE_PLAYING) {
+          // If connecting a Bluetooth audio device fails, the AudioTrack may be left in a state
+          // where its Java API is in the playing state, but the native track is stopped. When this
+          // happens the playback head position gets stuck at zero. In this case, return the old
+          // playback head position and force the track to be reset after
+          // {@link #FORCE_RESET_WORKAROUND_TIMEOUT_MS} has elapsed.
+          if (forceResetWorkaroundTimeMs == C.TIME_UNSET) {
+            forceResetWorkaroundTimeMs = SystemClock.elapsedRealtime();
+          }
+          return lastRawPlaybackHeadPosition;
+        } else {
+          forceResetWorkaroundTimeMs = C.TIME_UNSET;
+        }
+      }
+
       if (lastRawPlaybackHeadPosition > rawPlaybackHeadPosition) {
         // The value must have wrapped around.
         rawPlaybackHeadWrapCount++;
@@ -1674,8 +1491,7 @@ public AudioTrackUtilV19() {
     }
 
     @Override
-    public void reconfigure(android.media.AudioTrack audioTrack,
-        boolean needsPassthroughWorkaround) {
+    public void reconfigure(AudioTrack audioTrack, boolean needsPassthroughWorkaround) {
       super.reconfigure(audioTrack, needsPassthroughWorkaround);
       rawTimestampFramePositionWrapCount = 0;
       lastRawTimestampFramePosition = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 4d97c292ac..f8206e94cf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -21,11 +21,13 @@
 import android.media.MediaFormat;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener.EventDispatcher;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
@@ -38,19 +40,21 @@
 import java.nio.ByteBuffer;
 
 /**
- * Decodes and renders audio using {@link MediaCodec} and {@link AudioTrack}.
+ * Decodes and renders audio using {@link MediaCodec} and an {@link AudioSink}.
  */
 @TargetApi(16)
 public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock {
 
   private final EventDispatcher eventDispatcher;
-  private final AudioTrack audioTrack;
+  private final AudioSink audioSink;
 
   private boolean passthroughEnabled;
   private boolean codecNeedsDiscardChannelsWorkaround;
   private android.media.MediaFormat passthroughMediaFormat;
   private int pcmEncoding;
   private int channelCount;
+  private int encoderDelay;
+  private int encoderPadding;
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
 
@@ -72,7 +76,7 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector) {
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    */
   public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys) {
     this(mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, null, null);
   }
@@ -83,8 +87,8 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector, Handler eventHandler,
-      AudioRendererEventListener eventListener) {
+  public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
+      @Nullable Handler eventHandler, @Nullable AudioRendererEventListener eventListener) {
     this(mediaCodecSelector, null, true, eventHandler, eventListener);
   }
 
@@ -102,11 +106,11 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector, Handler ev
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
   public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler,
-      AudioRendererEventListener eventListener) {
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener) {
     this(mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
-        eventListener, null);
+        eventListener, (AudioCapabilities) null);
   }
 
   /**
@@ -127,29 +131,67 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
    *     output.
    */
   public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler,
-      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities,
-      AudioProcessor... audioProcessors) {
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      @Nullable AudioCapabilities audioCapabilities, AudioProcessor... audioProcessors) {
+    this(mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys,
+        eventHandler, eventListener, new DefaultAudioSink(audioCapabilities, audioProcessors));
+  }
+
+  /**
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
+   *     content is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioSink The sink to which audio will be output.
+   */
+  public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener, AudioSink audioSink) {
     super(C.TRACK_TYPE_AUDIO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
-    audioTrack = new AudioTrack(audioCapabilities, audioProcessors, new AudioTrackListener());
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    this.audioSink = audioSink;
+    audioSink.setListener(new AudioSinkListener());
   }
 
   @Override
-  protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format format)
+  protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, Format format)
       throws DecoderQueryException {
     String mimeType = format.sampleMimeType;
     if (!MimeTypes.isAudio(mimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
     int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
-    if (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
+    boolean supportsFormatDrm = supportsFormatDrm(drmSessionManager, format.drmInitData);
+    if (supportsFormatDrm && allowPassthrough(mimeType)
+        && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
       return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
-    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType, false);
+    boolean requiresSecureDecryption = false;
+    DrmInitData drmInitData = format.drmInitData;
+    if (drmInitData != null) {
+      for (int i = 0; i < drmInitData.schemeDataCount; i++) {
+        requiresSecureDecryption |= drmInitData.get(i).requiresSecureDecryption;
+      }
+    }
+    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType,
+        requiresSecureDecryption);
     if (decoderInfo == null) {
-      return FORMAT_UNSUPPORTED_SUBTYPE;
+      return requiresSecureDecryption && mediaCodecSelector.getDecoderInfo(mimeType, false) != null
+          ? FORMAT_UNSUPPORTED_DRM : FORMAT_UNSUPPORTED_SUBTYPE;
+    }
+    if (!supportsFormatDrm) {
+      return FORMAT_UNSUPPORTED_DRM;
     }
     // Note: We assume support for unknown sampleRate and channelCount.
     boolean decoderCapable = Util.SDK_INT < 21
@@ -177,14 +219,14 @@ protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
 
   /**
    * Returns whether encoded audio passthrough should be used for playing back the input format.
-   * This implementation returns true if the {@link AudioTrack}'s audio capabilities indicate that
-   * passthrough is supported.
+   * This implementation returns true if the {@link AudioSink} indicates that passthrough is
+   * supported.
    *
    * @param mimeType The type of input media.
-   * @return Whether passthrough playback should be used.
+   * @return Whether passthrough playback is supported.
    */
   protected boolean allowPassthrough(String mimeType) {
-    return audioTrack.isPassthroughSupported(mimeType);
+    return audioSink.isPassthroughSupported(mimeType);
   }
 
   @Override
@@ -223,6 +265,8 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     pcmEncoding = MimeTypes.AUDIO_RAW.equals(newFormat.sampleMimeType) ? newFormat.pcmEncoding
         : C.ENCODING_PCM_16BIT;
     channelCount = newFormat.channelCount;
+    encoderDelay = newFormat.encoderDelay != Format.NO_VALUE ? newFormat.encoderDelay : 0;
+    encoderPadding = newFormat.encoderPadding != Format.NO_VALUE ? newFormat.encoderPadding : 0;
   }
 
   @Override
@@ -245,8 +289,9 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     }
 
     try {
-      audioTrack.configure(mimeType, channelCount, sampleRate, pcmEncoding, 0, channelMap);
-    } catch (AudioTrack.ConfigurationException e) {
+      audioSink.configure(mimeType, channelCount, sampleRate, pcmEncoding, 0, channelMap,
+          encoderDelay, encoderPadding);
+    } catch (AudioSink.ConfigurationException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
   }
@@ -257,21 +302,21 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
    * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
    * should be released in {@link #onDisabled()} (if not before).
    *
-   * @see AudioTrack.Listener#onAudioSessionId(int)
+   * @see AudioSink.Listener#onAudioSessionId(int)
    */
   protected void onAudioSessionId(int audioSessionId) {
     // Do nothing.
   }
 
   /**
-   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   * @see AudioSink.Listener#onPositionDiscontinuity()
    */
   protected void onAudioTrackPositionDiscontinuity() {
     // Do nothing.
   }
 
   /**
-   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   * @see AudioSink.Listener#onUnderrun(int, long, long)
    */
   protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
       long elapsedSinceLastFeedMs) {
@@ -284,16 +329,16 @@ protected void onEnabled(boolean joining) throws ExoPlaybackException {
     eventDispatcher.enabled(decoderCounters);
     int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
     if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
-      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+      audioSink.enableTunnelingV21(tunnelingAudioSessionId);
     } else {
-      audioTrack.disableTunneling();
+      audioSink.disableTunneling();
     }
   }
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     super.onPositionReset(positionUs, joining);
-    audioTrack.reset();
+    audioSink.reset();
     currentPositionUs = positionUs;
     allowPositionDiscontinuity = true;
   }
@@ -301,19 +346,19 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
   @Override
   protected void onStarted() {
     super.onStarted();
-    audioTrack.play();
+    audioSink.play();
   }
 
   @Override
   protected void onStopped() {
-    audioTrack.pause();
+    audioSink.pause();
     super.onStopped();
   }
 
   @Override
   protected void onDisabled() {
     try {
-      audioTrack.release();
+      audioSink.release();
     } finally {
       try {
         super.onDisabled();
@@ -326,18 +371,18 @@ protected void onDisabled() {
 
   @Override
   public boolean isEnded() {
-    return super.isEnded() && audioTrack.isEnded();
+    return super.isEnded() && audioSink.isEnded();
   }
 
   @Override
   public boolean isReady() {
-    return audioTrack.hasPendingData() || super.isReady();
+    return audioSink.hasPendingData() || super.isReady();
   }
 
   @Override
   public long getPositionUs() {
-    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
-    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+    long newCurrentPositionUs = audioSink.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) {
       currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
           : Math.max(currentPositionUs, newCurrentPositionUs);
       allowPositionDiscontinuity = false;
@@ -347,12 +392,12 @@ public long getPositionUs() {
 
   @Override
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
-    return audioTrack.setPlaybackParameters(playbackParameters);
+    return audioSink.setPlaybackParameters(playbackParameters);
   }
 
   @Override
   public PlaybackParameters getPlaybackParameters() {
-    return audioTrack.getPlaybackParameters();
+    return audioSink.getPlaybackParameters();
   }
 
   @Override
@@ -368,17 +413,17 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (shouldSkip) {
       codec.releaseOutputBuffer(bufferIndex, false);
       decoderCounters.skippedOutputBufferCount++;
-      audioTrack.handleDiscontinuity();
+      audioSink.handleDiscontinuity();
       return true;
     }
 
     try {
-      if (audioTrack.handleBuffer(buffer, bufferPresentationTimeUs)) {
+      if (audioSink.handleBuffer(buffer, bufferPresentationTimeUs)) {
         codec.releaseOutputBuffer(bufferIndex, false);
         decoderCounters.renderedOutputBufferCount++;
         return true;
       }
-    } catch (AudioTrack.InitializationException | AudioTrack.WriteException e) {
+    } catch (AudioSink.InitializationException | AudioSink.WriteException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
     return false;
@@ -387,8 +432,8 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
   @Override
   protected void renderToEndOfStream() throws ExoPlaybackException {
     try {
-      audioTrack.playToEndOfStream();
-    } catch (AudioTrack.WriteException e) {
+      audioSink.playToEndOfStream();
+    } catch (AudioSink.WriteException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
   }
@@ -397,11 +442,11 @@ protected void renderToEndOfStream() throws ExoPlaybackException {
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     switch (messageType) {
       case C.MSG_SET_VOLUME:
-        audioTrack.setVolume((Float) message);
+        audioSink.setVolume((Float) message);
         break;
       case C.MSG_SET_AUDIO_ATTRIBUTES:
         AudioAttributes audioAttributes = (AudioAttributes) message;
-        audioTrack.setAudioAttributes(audioAttributes);
+        audioSink.setAudioAttributes(audioAttributes);
         break;
       default:
         super.handleMessage(messageType, message);
@@ -423,7 +468,7 @@ private static boolean codecNeedsDiscardChannelsWorkaround(String codecName) {
         || Util.DEVICE.startsWith("heroqlte"));
   }
 
-  private final class AudioTrackListener implements AudioTrack.Listener {
+  private final class AudioSinkListener implements AudioSink.Listener {
 
     @Override
     public void onAudioSessionId(int audioSessionId) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
index 0dd062150d..a78adbcee3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
@@ -79,6 +79,11 @@ public int getOutputEncoding() {
     return C.ENCODING_PCM_16BIT;
   }
 
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
     // Prepare the output buffer.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index c4a55eeb02..98a84fdff8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -72,12 +72,14 @@
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
   private final EventDispatcher eventDispatcher;
-  private final AudioTrack audioTrack;
+  private final AudioSink audioSink;
   private final FormatHolder formatHolder;
   private final DecoderInputBuffer flagsOnlyBuffer;
 
   private DecoderCounters decoderCounters;
   private Format inputFormat;
+  private int encoderDelay;
+  private int encoderPadding;
   private SimpleDecoder<DecoderInputBuffer, ? extends SimpleOutputBuffer,
         ? extends AudioDecoderException> decoder;
   private DecoderInputBuffer inputBuffer;
@@ -105,8 +107,8 @@ public SimpleDecoderAudioRenderer() {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler,
-      AudioRendererEventListener eventListener, AudioProcessor... audioProcessors) {
+  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+      AudioProcessor... audioProcessors) {
     this(eventHandler, eventListener, null, null, false, audioProcessors);
   }
 
@@ -117,8 +119,8 @@ public SimpleDecoderAudioRenderer(Handler eventHandler,
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler,
-      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities) {
+  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+      AudioCapabilities audioCapabilities) {
     this(eventHandler, eventListener, audioCapabilities, null, false);
   }
 
@@ -137,15 +139,35 @@ public SimpleDecoderAudioRenderer(Handler eventHandler,
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
-  public SimpleDecoderAudioRenderer(Handler eventHandler,
-      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities,
+  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+      AudioCapabilities audioCapabilities, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys, AudioProcessor... audioProcessors) {
+    this(eventHandler, eventListener, drmSessionManager,
+        playClearSamplesWithoutKeys, new DefaultAudioSink(audioCapabilities, audioProcessors));
+  }
+
+  /**
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
+   *     media is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param audioSink The sink to which audio will be output.
+   */
+  public SimpleDecoderAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
       DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys,
-      AudioProcessor... audioProcessors) {
+      AudioSink audioSink) {
     super(C.TRACK_TYPE_AUDIO);
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    audioTrack = new AudioTrack(audioCapabilities, audioProcessors, new AudioTrackListener());
+    this.audioSink = audioSink;
+    audioSink.setListener(new AudioSinkListener());
     formatHolder = new FormatHolder();
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
@@ -159,8 +181,8 @@ public MediaClock getMediaClock() {
 
   @Override
   public final int supportsFormat(Format format) {
-    int formatSupport = supportsFormatInternal(format);
-    if (formatSupport == FORMAT_UNSUPPORTED_TYPE || formatSupport == FORMAT_UNSUPPORTED_SUBTYPE) {
+    int formatSupport = supportsFormatInternal(drmSessionManager, format);
+    if (formatSupport <= FORMAT_UNSUPPORTED_DRM) {
       return formatSupport;
     }
     int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
@@ -171,17 +193,19 @@ public final int supportsFormat(Format format) {
    * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for
    * {@link #supportsFormat(Format)}.
    *
+   * @param drmSessionManager The renderer's {@link DrmSessionManager}.
    * @param format The format.
    * @return The extent to which the renderer supports the format itself.
    */
-  protected abstract int supportsFormatInternal(Format format);
+  protected abstract int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      Format format);
 
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
       try {
-        audioTrack.playToEndOfStream();
-      } catch (AudioTrack.WriteException e) {
+        audioSink.playToEndOfStream();
+      } catch (AudioSink.WriteException e) {
         throw ExoPlaybackException.createForRenderer(e, getIndex());
       }
       return;
@@ -216,8 +240,8 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
         while (drainOutputBuffer()) {}
         while (feedInputBuffer()) {}
         TraceUtil.endSection();
-      } catch (AudioDecoderException | AudioTrack.ConfigurationException
-          | AudioTrack.InitializationException | AudioTrack.WriteException e) {
+      } catch (AudioDecoderException | AudioSink.ConfigurationException
+          | AudioSink.InitializationException | AudioSink.WriteException e) {
         throw ExoPlaybackException.createForRenderer(e, getIndex());
       }
       decoderCounters.ensureUpdated();
@@ -230,21 +254,21 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
    * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
    * should be released in {@link #onDisabled()} (if not before).
    *
-   * @see AudioTrack.Listener#onAudioSessionId(int)
+   * @see AudioSink.Listener#onAudioSessionId(int)
    */
   protected void onAudioSessionId(int audioSessionId) {
     // Do nothing.
   }
 
   /**
-   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   * @see AudioSink.Listener#onPositionDiscontinuity()
    */
   protected void onAudioTrackPositionDiscontinuity() {
     // Do nothing.
   }
 
   /**
-   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   * @see AudioSink.Listener#onUnderrun(int, long, long)
    */
   protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
       long elapsedSinceLastFeedMs) {
@@ -278,8 +302,8 @@ protected Format getOutputFormat() {
   }
 
   private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderException,
-      AudioTrack.ConfigurationException, AudioTrack.InitializationException,
-      AudioTrack.WriteException {
+      AudioSink.ConfigurationException, AudioSink.InitializationException,
+      AudioSink.WriteException {
     if (outputBuffer == null) {
       outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
@@ -305,12 +329,12 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
 
     if (audioTrackNeedsConfigure) {
       Format outputFormat = getOutputFormat();
-      audioTrack.configure(outputFormat.sampleMimeType, outputFormat.channelCount,
-          outputFormat.sampleRate, outputFormat.pcmEncoding, 0);
+      audioSink.configure(outputFormat.sampleMimeType, outputFormat.channelCount,
+          outputFormat.sampleRate, outputFormat.pcmEncoding, 0, null, encoderDelay, encoderPadding);
       audioTrackNeedsConfigure = false;
     }
 
-    if (audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs)) {
+    if (audioSink.handleBuffer(outputBuffer.data, outputBuffer.timeUs)) {
       decoderCounters.renderedOutputBufferCount++;
       outputBuffer.release();
       outputBuffer = null;
@@ -390,8 +414,8 @@ private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackExc
   private void processEndOfStream() throws ExoPlaybackException {
     outputStreamEnded = true;
     try {
-      audioTrack.playToEndOfStream();
-    } catch (AudioTrack.WriteException e) {
+      audioSink.playToEndOfStream();
+    } catch (AudioSink.WriteException e) {
       throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
     }
   }
@@ -414,19 +438,19 @@ private void flushDecoder() throws ExoPlaybackException {
 
   @Override
   public boolean isEnded() {
-    return outputStreamEnded && audioTrack.isEnded();
+    return outputStreamEnded && audioSink.isEnded();
   }
 
   @Override
   public boolean isReady() {
-    return audioTrack.hasPendingData()
+    return audioSink.hasPendingData()
         || (inputFormat != null && !waitingForKeys && (isSourceReady() || outputBuffer != null));
   }
 
   @Override
   public long getPositionUs() {
-    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
-    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+    long newCurrentPositionUs = audioSink.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) {
       currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
           : Math.max(currentPositionUs, newCurrentPositionUs);
       allowPositionDiscontinuity = false;
@@ -436,12 +460,12 @@ public long getPositionUs() {
 
   @Override
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
-    return audioTrack.setPlaybackParameters(playbackParameters);
+    return audioSink.setPlaybackParameters(playbackParameters);
   }
 
   @Override
   public PlaybackParameters getPlaybackParameters() {
-    return audioTrack.getPlaybackParameters();
+    return audioSink.getPlaybackParameters();
   }
 
   @Override
@@ -450,15 +474,15 @@ protected void onEnabled(boolean joining) throws ExoPlaybackException {
     eventDispatcher.enabled(decoderCounters);
     int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
     if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
-      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+      audioSink.enableTunnelingV21(tunnelingAudioSessionId);
     } else {
-      audioTrack.disableTunneling();
+      audioSink.disableTunneling();
     }
   }
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
-    audioTrack.reset();
+    audioSink.reset();
     currentPositionUs = positionUs;
     allowPositionDiscontinuity = true;
     inputStreamEnded = false;
@@ -470,12 +494,12 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
 
   @Override
   protected void onStarted() {
-    audioTrack.play();
+    audioSink.play();
   }
 
   @Override
   protected void onStopped() {
-    audioTrack.pause();
+    audioSink.pause();
   }
 
   @Override
@@ -485,7 +509,7 @@ protected void onDisabled() {
     waitingForKeys = false;
     try {
       releaseDecoder();
-      audioTrack.release();
+      audioSink.release();
     } finally {
       try {
         if (drmSession != null) {
@@ -585,6 +609,9 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
       audioTrackNeedsConfigure = true;
     }
 
+    encoderDelay = newFormat.encoderDelay == Format.NO_VALUE ? 0 : newFormat.encoderDelay;
+    encoderPadding = newFormat.encoderPadding == Format.NO_VALUE ? 0 : newFormat.encoderPadding;
+
     eventDispatcher.inputFormatChanged(newFormat);
   }
 
@@ -592,11 +619,11 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     switch (messageType) {
       case C.MSG_SET_VOLUME:
-        audioTrack.setVolume((Float) message);
+        audioSink.setVolume((Float) message);
         break;
       case C.MSG_SET_AUDIO_ATTRIBUTES:
         AudioAttributes audioAttributes = (AudioAttributes) message;
-        audioTrack.setAudioAttributes(audioAttributes);
+        audioSink.setAudioAttributes(audioAttributes);
         break;
       default:
         super.handleMessage(messageType, message);
@@ -604,7 +631,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
-  private final class AudioTrackListener implements AudioTrack.Listener {
+  private final class AudioSinkListener implements AudioSink.Listener {
 
     @Override
     public void onAudioSessionId(int audioSessionId) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java
index 5c5ac06da3..daab04e4ab 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java
@@ -27,13 +27,15 @@
  */
 /* package */ final class Sonic {
 
-  private static final boolean USE_CHORD_PITCH = false;
   private static final int MINIMUM_PITCH = 65;
   private static final int MAXIMUM_PITCH = 400;
   private static final int AMDF_FREQUENCY = 4000;
 
-  private final int sampleRate;
+  private final int inputSampleRateHz;
   private final int numChannels;
+  private final float speed;
+  private final float pitch;
+  private final float rate;
   private final int minPeriod;
   private final int maxPeriod;
   private final int maxRequired;
@@ -47,8 +49,6 @@
   private short[] pitchBuffer;
   private int oldRatePosition;
   private int newRatePosition;
-  private float speed;
-  private float pitch;
   private int numInputSamples;
   private int numOutputSamples;
   private int numPitchSamples;
@@ -61,14 +61,18 @@
   /**
    * Creates a new Sonic audio stream processor.
    *
-   * @param sampleRate The sample rate of input audio.
+   * @param inputSampleRateHz The sample rate of input audio, in hertz.
    * @param numChannels The number of channels in the input audio.
+   * @param speed The speedup factor for output audio.
+   * @param pitch The pitch factor for output audio.
+   * @param outputSampleRateHz The sample rate for output audio, in hertz.
    */
-  public Sonic(int sampleRate, int numChannels) {
-    this.sampleRate = sampleRate;
+  public Sonic(int inputSampleRateHz, int numChannels, float speed, float pitch,
+      int outputSampleRateHz) {
+    this.inputSampleRateHz = inputSampleRateHz;
     this.numChannels = numChannels;
-    minPeriod = sampleRate / MAXIMUM_PITCH;
-    maxPeriod = sampleRate / MINIMUM_PITCH;
+    minPeriod = inputSampleRateHz / MAXIMUM_PITCH;
+    maxPeriod = inputSampleRateHz / MINIMUM_PITCH;
     maxRequired = 2 * maxPeriod;
     downSampleBuffer = new short[maxRequired];
     inputBufferSize = maxRequired;
@@ -80,36 +84,9 @@ public Sonic(int sampleRate, int numChannels) {
     oldRatePosition = 0;
     newRatePosition = 0;
     prevPeriod = 0;
-    speed = 1.0f;
-    pitch = 1.0f;
-  }
-
-  /**
-   * Sets the output speed.
-   */
-  public void setSpeed(float speed) {
     this.speed = speed;
-  }
-
-  /**
-   * Gets the output speed.
-   */
-  public float getSpeed() {
-    return speed;
-  }
-
-  /**
-   * Sets the output pitch.
-   */
-  public void setPitch(float pitch) {
     this.pitch = pitch;
-  }
-
-  /**
-   * Gets the output pitch.
-   */
-  public float getPitch() {
-    return pitch;
+    this.rate = (float) inputSampleRateHz / outputSampleRateHz;
   }
 
   /**
@@ -148,8 +125,9 @@ public void getOutput(ShortBuffer buffer) {
   public void queueEndOfStream() {
     int remainingSamples = numInputSamples;
     float s = speed / pitch;
+    float r = rate * pitch;
     int expectedOutputSamples =
-        numOutputSamples + (int) ((remainingSamples / s + numPitchSamples) / pitch + 0.5f);
+        numOutputSamples + (int) ((remainingSamples / s + numPitchSamples) / r + 0.5f);
 
     // Add enough silence to flush both input and pitch buffers.
     enlargeInputBufferIfNeeded(remainingSamples + 2 * maxRequired);
@@ -292,7 +270,7 @@ private int findPitchPeriod(short[] samples, int position, boolean preferNewPeri
     // sampling.
     int period;
     int retPeriod;
-    int skip = sampleRate > AMDF_FREQUENCY ? sampleRate / AMDF_FREQUENCY : 1;
+    int skip = inputSampleRateHz > AMDF_FREQUENCY ? inputSampleRateHz / AMDF_FREQUENCY : 1;
     if (numChannels == 1 && skip == 1) {
       period = findPitchPeriodInRange(samples, position, minPeriod, maxPeriod);
     } else {
@@ -347,32 +325,6 @@ private void removePitchSamples(int numSamples) {
     numPitchSamples -= numSamples;
   }
 
-  private void adjustPitch(int originalNumOutputSamples) {
-    // Latency due to pitch changes could be reduced by looking at past samples to determine pitch,
-    // rather than future.
-    if (numOutputSamples == originalNumOutputSamples) {
-      return;
-    }
-    moveNewSamplesToPitchBuffer(originalNumOutputSamples);
-    int position = 0;
-    while (numPitchSamples - position >= maxRequired) {
-      int period = findPitchPeriod(pitchBuffer, position, false);
-      int newPeriod = (int) (period / pitch);
-      enlargeOutputBufferIfNeeded(newPeriod);
-      if (pitch >= 1.0f) {
-        overlapAdd(newPeriod, numChannels, outputBuffer, numOutputSamples, pitchBuffer, position,
-            pitchBuffer, position + period - newPeriod);
-      } else {
-        int separation = newPeriod - period;
-        overlapAddWithSeparation(period, numChannels, separation, outputBuffer, numOutputSamples,
-            pitchBuffer, position, pitchBuffer, position);
-      }
-      numOutputSamples += newPeriod;
-      position += period;
-    }
-    removePitchSamples(position);
-  }
-
   private short interpolate(short[] in, int inPos, int oldSampleRate, int newSampleRate) {
     short left = in[inPos];
     short right = in[inPos + numChannels];
@@ -388,8 +340,8 @@ private void adjustRate(float rate, int originalNumOutputSamples) {
     if (numOutputSamples == originalNumOutputSamples) {
       return;
     }
-    int newSampleRate = (int) (sampleRate / rate);
-    int oldSampleRate = sampleRate;
+    int newSampleRate = (int) (inputSampleRateHz / rate);
+    int oldSampleRate = inputSampleRateHz;
     // Set these values to help with the integer math.
     while (newSampleRate > (1 << 14) || oldSampleRate > (1 << 14)) {
       newSampleRate /= 2;
@@ -476,18 +428,15 @@ private void processStreamInput() {
     // Resample as many pitch periods as we have buffered on the input.
     int originalNumOutputSamples = numOutputSamples;
     float s = speed / pitch;
+    float r = rate * pitch;
     if (s > 1.00001 || s < 0.99999) {
       changeSpeed(s);
     } else {
       copyToOutput(inputBuffer, 0, numInputSamples);
       numInputSamples = 0;
     }
-    if (USE_CHORD_PITCH) {
-      if (pitch != 1.0f) {
-        adjustPitch(originalNumOutputSamples);
-      }
-    } else if (!USE_CHORD_PITCH && pitch != 1.0f) {
-      adjustRate(pitch, originalNumOutputSamples);
+    if (r != 1.0f) {
+      adjustRate(r, originalNumOutputSamples);
     }
   }
 
@@ -506,29 +455,4 @@ private static void overlapAdd(int numSamples, int numChannels, short[] out, int
     }
   }
 
-  private static void overlapAddWithSeparation(int numSamples, int numChannels, int separation,
-      short[] out, int outPos, short[] rampDown, int rampDownPos, short[] rampUp, int rampUpPos) {
-    for (int i = 0; i < numChannels; i++) {
-      int o = outPos * numChannels + i;
-      int u = rampUpPos * numChannels + i;
-      int d = rampDownPos * numChannels + i;
-      for (int t = 0; t < numSamples + separation; t++) {
-        if (t < separation) {
-          out[o] = (short) (rampDown[d] * (numSamples - t) / numSamples);
-          d += numChannels;
-        } else if (t < numSamples) {
-          out[o] =
-              (short) ((rampDown[d] * (numSamples - t) + rampUp[u] * (t - separation))
-                  / numSamples);
-          d += numChannels;
-          u += numChannels;
-        } else {
-          out[o] = (short) (rampUp[u] * (t - separation) / numSamples);
-          u += numChannels;
-        }
-        o += numChannels;
-      }
-    }
-  }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
index df20139255..370ddb2809 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
@@ -24,7 +24,7 @@
 import java.nio.ShortBuffer;
 
 /**
- * An {@link AudioProcessor} that uses the Sonic library to modify the speed/pitch of audio.
+ * An {@link AudioProcessor} that uses the Sonic library to modify audio speed/pitch/sample rate.
  */
 public final class SonicAudioProcessor implements AudioProcessor {
 
@@ -44,18 +44,30 @@
    * The minimum allowed pitch in {@link #setPitch(float)}.
    */
   public static final float MINIMUM_PITCH = 0.1f;
+  /**
+   * Indicates that the output sample rate should be the same as the input.
+   */
+  public static final int SAMPLE_RATE_NO_CHANGE = -1;
 
   /**
    * The threshold below which the difference between two pitch/speed factors is negligible.
    */
   private static final float CLOSE_THRESHOLD = 0.01f;
 
+  /**
+   * The minimum number of output bytes at which the speedup is calculated using the input/output
+   * byte counts, rather than using the current playback parameters speed.
+   */
+  private static final int MIN_BYTES_FOR_SPEEDUP_CALCULATION = 1024;
+
+  private int pendingOutputSampleRateHz;
   private int channelCount;
   private int sampleRateHz;
 
   private Sonic sonic;
   private float speed;
   private float pitch;
+  private int outputSampleRateHz;
 
   private ByteBuffer buffer;
   private ShortBuffer shortBuffer;
@@ -72,9 +84,11 @@ public SonicAudioProcessor() {
     pitch = 1f;
     channelCount = Format.NO_VALUE;
     sampleRateHz = Format.NO_VALUE;
+    outputSampleRateHz = Format.NO_VALUE;
     buffer = EMPTY_BUFFER;
     shortBuffer = buffer.asShortBuffer();
     outputBuffer = EMPTY_BUFFER;
+    pendingOutputSampleRateHz = SAMPLE_RATE_NO_CHANGE;
   }
 
   /**
@@ -100,17 +114,34 @@ public float setPitch(float pitch) {
   }
 
   /**
-   * Returns the number of bytes of input queued since the last call to {@link #flush()}.
+   * Sets the sample rate for output audio, in hertz. Pass {@link #SAMPLE_RATE_NO_CHANGE} to output
+   * audio at the same sample rate as the input. After calling this method, call
+   * {@link #configure(int, int, int)} to start using the new sample rate.
+   *
+   * @param sampleRateHz The sample rate for output audio, in hertz.
+   * @see #configure(int, int, int)
    */
-  public long getInputByteCount() {
-    return inputBytes;
+  public void setOutputSampleRateHz(int sampleRateHz) {
+    pendingOutputSampleRateHz = sampleRateHz;
   }
 
   /**
-   * Returns the number of bytes of output dequeued since the last call to {@link #flush()}.
+   * Returns the specified duration scaled to take into account the speedup factor of this instance,
+   * in the same units as {@code duration}.
+   *
+   * @param duration The duration to scale taking into account speedup.
+   * @return The specified duration scaled to take into account speedup, in the same units as
+   *     {@code duration}.
    */
-  public long getOutputByteCount() {
-    return outputBytes;
+  public long scaleDurationForSpeedup(long duration) {
+    if (outputBytes >= MIN_BYTES_FOR_SPEEDUP_CALCULATION) {
+      return outputSampleRateHz == sampleRateHz
+          ? Util.scaleLargeTimestamp(duration, inputBytes, outputBytes)
+          : Util.scaleLargeTimestamp(duration, inputBytes * outputSampleRateHz,
+              outputBytes * sampleRateHz);
+    } else {
+      return (long) ((double) speed * duration);
+    }
   }
 
   @Override
@@ -119,17 +150,22 @@ public boolean configure(int sampleRateHz, int channelCount, @Encoding int encod
     if (encoding != C.ENCODING_PCM_16BIT) {
       throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
     }
-    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount) {
+    int outputSampleRateHz = pendingOutputSampleRateHz == SAMPLE_RATE_NO_CHANGE
+        ? sampleRateHz : pendingOutputSampleRateHz;
+    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount
+        && this.outputSampleRateHz == outputSampleRateHz) {
       return false;
     }
     this.sampleRateHz = sampleRateHz;
     this.channelCount = channelCount;
+    this.outputSampleRateHz = outputSampleRateHz;
     return true;
   }
 
   @Override
   public boolean isActive() {
-    return Math.abs(speed - 1f) >= CLOSE_THRESHOLD || Math.abs(pitch - 1f) >= CLOSE_THRESHOLD;
+    return Math.abs(speed - 1f) >= CLOSE_THRESHOLD || Math.abs(pitch - 1f) >= CLOSE_THRESHOLD
+        || outputSampleRateHz != sampleRateHz;
   }
 
   @Override
@@ -142,6 +178,11 @@ public int getOutputEncoding() {
     return C.ENCODING_PCM_16BIT;
   }
 
+  @Override
+  public int getOutputSampleRateHz() {
+    return outputSampleRateHz;
+  }
+
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
     if (inputBuffer.hasRemaining()) {
@@ -187,9 +228,7 @@ public boolean isEnded() {
 
   @Override
   public void flush() {
-    sonic = new Sonic(sampleRateHz, channelCount);
-    sonic.setSpeed(speed);
-    sonic.setPitch(pitch);
+    sonic = new Sonic(sampleRateHz, channelCount, speed, pitch, outputSampleRateHz);
     outputBuffer = EMPTY_BUFFER;
     inputBytes = 0;
     outputBytes = 0;
@@ -204,9 +243,11 @@ public void reset() {
     outputBuffer = EMPTY_BUFFER;
     channelCount = Format.NO_VALUE;
     sampleRateHz = Format.NO_VALUE;
+    outputSampleRateHz = Format.NO_VALUE;
     inputBytes = 0;
     outputBytes = 0;
     inputEnded = false;
+    pendingOutputSampleRateHz = SAMPLE_RATE_NO_CHANGE;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
new file mode 100644
index 0000000000..9ff1c158dd
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.C.Encoding;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Audio processor for trimming samples from the start/end of data.
+ */
+/* package */ final class TrimmingAudioProcessor implements AudioProcessor {
+
+  private boolean isActive;
+  private int trimStartSamples;
+  private int trimEndSamples;
+  private int channelCount;
+  private int sampleRateHz;
+
+  private int pendingTrimStartBytes;
+  private ByteBuffer buffer;
+  private ByteBuffer outputBuffer;
+  private byte[] endBuffer;
+  private int endBufferSize;
+  private boolean inputEnded;
+
+  /**
+   * Creates a new audio processor for trimming samples from the start/end of data.
+   */
+  public TrimmingAudioProcessor() {
+    buffer = EMPTY_BUFFER;
+    outputBuffer = EMPTY_BUFFER;
+    channelCount = Format.NO_VALUE;
+  }
+
+  /**
+   * Sets the number of audio samples to trim from the start and end of audio passed to this
+   * processor. After calling this method, call {@link #configure(int, int, int)} to apply the new
+   * trimming sample counts.
+   *
+   * @param trimStartSamples The number of audio samples to trim from the start of audio.
+   * @param trimEndSamples The number of audio samples to trim from the end of audio.
+   * @see AudioSink#configure(int, int, int, int, int[], int, int)
+   */
+  public void setTrimSampleCount(int trimStartSamples, int trimEndSamples) {
+    this.trimStartSamples = trimStartSamples;
+    this.trimEndSamples = trimEndSamples;
+  }
+
+  @Override
+  public boolean configure(int sampleRateHz, int channelCount, @Encoding int encoding)
+      throws UnhandledFormatException {
+    if (encoding != C.ENCODING_PCM_16BIT) {
+      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+    }
+    this.channelCount = channelCount;
+    this.sampleRateHz = sampleRateHz;
+    endBuffer = new byte[trimEndSamples * channelCount * 2];
+    endBufferSize = 0;
+    pendingTrimStartBytes = trimStartSamples * channelCount * 2;
+    boolean wasActive = isActive;
+    isActive = trimStartSamples != 0 || trimEndSamples != 0;
+    return wasActive != isActive;
+  }
+
+  @Override
+  public boolean isActive() {
+    return isActive;
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return channelCount;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return C.ENCODING_PCM_16BIT;
+  }
+
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
+  @Override
+  public void queueInput(ByteBuffer inputBuffer) {
+    int position = inputBuffer.position();
+    int limit = inputBuffer.limit();
+    int remaining = limit - position;
+
+    // Trim any pending start bytes from the input buffer.
+    int trimBytes = Math.min(remaining, pendingTrimStartBytes);
+    pendingTrimStartBytes -= trimBytes;
+    inputBuffer.position(position + trimBytes);
+    if (pendingTrimStartBytes > 0) {
+      // Nothing to output yet.
+      return;
+    }
+    remaining -= trimBytes;
+
+    // endBuffer must be kept as full as possible, so that we trim the right amount of media if we
+    // don't receive any more input. After taking into account the number of bytes needed to keep
+    // endBuffer as full as possible, the output should be any surplus bytes currently in endBuffer
+    // followed by any surplus bytes in the new inputBuffer.
+    int remainingBytesToOutput = endBufferSize + remaining - endBuffer.length;
+    if (buffer.capacity() < remainingBytesToOutput) {
+      buffer = ByteBuffer.allocateDirect(remainingBytesToOutput).order(ByteOrder.nativeOrder());
+    } else {
+      buffer.clear();
+    }
+
+    // Output from endBuffer.
+    int endBufferBytesToOutput = Util.constrainValue(remainingBytesToOutput, 0, endBufferSize);
+    buffer.put(endBuffer, 0, endBufferBytesToOutput);
+    remainingBytesToOutput -= endBufferBytesToOutput;
+
+    // Output from inputBuffer, restoring its limit afterwards.
+    int inputBufferBytesToOutput = Util.constrainValue(remainingBytesToOutput, 0, remaining);
+    inputBuffer.limit(inputBuffer.position() + inputBufferBytesToOutput);
+    buffer.put(inputBuffer);
+    inputBuffer.limit(limit);
+    remaining -= inputBufferBytesToOutput;
+
+    // Compact endBuffer, then repopulate it using the new input.
+    endBufferSize -= endBufferBytesToOutput;
+    System.arraycopy(endBuffer, endBufferBytesToOutput, endBuffer, 0, endBufferSize);
+    inputBuffer.get(endBuffer, endBufferSize, remaining);
+    endBufferSize += remaining;
+
+    buffer.flip();
+    outputBuffer = buffer;
+  }
+
+  @Override
+  public void queueEndOfStream() {
+    inputEnded = true;
+  }
+
+  @Override
+  public ByteBuffer getOutput() {
+    ByteBuffer outputBuffer = this.outputBuffer;
+    this.outputBuffer = EMPTY_BUFFER;
+    return outputBuffer;
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  @Override
+  public boolean isEnded() {
+    return inputEnded && outputBuffer == EMPTY_BUFFER;
+  }
+
+  @Override
+  public void flush() {
+    outputBuffer = EMPTY_BUFFER;
+    inputEnded = false;
+    // It's no longer necessary to trim any media from the start, but it is necessary to clear the
+    // end buffer and refill it.
+    pendingTrimStartBytes = 0;
+    endBufferSize = 0;
+  }
+
+  @Override
+  public void reset() {
+    flush();
+    buffer = EMPTY_BUFFER;
+    channelCount = Format.NO_VALUE;
+    sampleRateHz = Format.NO_VALUE;
+    endBuffer = null;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderCounters.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderCounters.java
index 3c2d6d96e9..8409bab558 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderCounters.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderCounters.java
@@ -36,6 +36,12 @@
    * The number of queued input buffers.
    */
   public int inputBufferCount;
+  /**
+   * The number of skipped input buffers.
+   * <p>
+   * A skipped input buffer is an input buffer that was deliberately not sent to the decoder.
+   */
+  public int skippedInputBufferCount;
   /**
    * The number of rendered output buffers.
    */
@@ -47,18 +53,26 @@
    */
   public int skippedOutputBufferCount;
   /**
-   * The number of dropped output buffers.
+   * The number of dropped buffers.
    * <p>
-   * A dropped output buffer is an output buffer that was supposed to be rendered, but was instead
+   * A dropped buffer is an buffer that was supposed to be decoded/rendered, but was instead
    * dropped because it could not be rendered in time.
    */
-  public int droppedOutputBufferCount;
+  public int droppedBufferCount;
   /**
-   * The maximum number of dropped output buffers without an interleaving rendered output buffer.
+   * The maximum number of dropped buffers without an interleaving rendered output buffer.
    * <p>
    * Skipped output buffers are ignored for the purposes of calculating this value.
    */
-  public int maxConsecutiveDroppedOutputBufferCount;
+  public int maxConsecutiveDroppedBufferCount;
+  /**
+   * The number of times all buffers to a keyframe were dropped.
+   * <p>
+   * Each time buffers to a keyframe are dropped, this counter is increased by one, and the dropped
+   * buffer counters are increased by one (for the current output buffer) plus the number of buffers
+   * dropped from the source to advance to the keyframe.
+   */
+  public int droppedToKeyframeCount;
 
   /**
    * Should be called to ensure counter values are made visible across threads. The playback thread
@@ -79,11 +93,13 @@ public void merge(DecoderCounters other) {
     decoderInitCount += other.decoderInitCount;
     decoderReleaseCount += other.decoderReleaseCount;
     inputBufferCount += other.inputBufferCount;
+    skippedInputBufferCount += other.skippedInputBufferCount;
     renderedOutputBufferCount += other.renderedOutputBufferCount;
     skippedOutputBufferCount += other.skippedOutputBufferCount;
-    droppedOutputBufferCount += other.droppedOutputBufferCount;
-    maxConsecutiveDroppedOutputBufferCount = Math.max(maxConsecutiveDroppedOutputBufferCount,
-        other.maxConsecutiveDroppedOutputBufferCount);
+    droppedBufferCount += other.droppedBufferCount;
+    maxConsecutiveDroppedBufferCount = Math.max(maxConsecutiveDroppedBufferCount,
+        other.maxConsecutiveDroppedBufferCount);
+    droppedToKeyframeCount += other.droppedToKeyframeCount;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java
new file mode 100644
index 0000000000..ee337dcc51
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ClearKeyUtil.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import android.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Utility methods for ClearKey.
+ */
+/* package */ final class ClearKeyUtil {
+
+  private static final String TAG = "ClearKeyUtil";
+  private static final Pattern REQUEST_KIDS_PATTERN = Pattern.compile("\"kids\":\\[\"(.*?)\"]");
+
+  private ClearKeyUtil() {}
+
+  /**
+   * Adjusts ClearKey request data obtained from the Android ClearKey CDM to be spec compliant.
+   *
+   * @param request The request data.
+   * @return The adjusted request data.
+   */
+  public static byte[] adjustRequestData(byte[] request) {
+    if (Util.SDK_INT >= 27) {
+      return request;
+    }
+    // Prior to O-MR1 the ClearKey CDM encoded the values in the "kids" array using Base64 rather
+    // than Base64Url. See [Internal: b/64388098]. Any "/" characters that ended up in the request
+    // as a result were not escaped as "\/". We know the exact request format from the platform's
+    // InitDataParser.cpp, so we can use a regexp rather than parsing the JSON.
+    String requestString = Util.fromUtf8Bytes(request);
+    Matcher requestKidsMatcher = REQUEST_KIDS_PATTERN.matcher(requestString);
+    if (!requestKidsMatcher.find()) {
+      Log.e(TAG, "Failed to adjust request data: " + requestString);
+      return request;
+    }
+    int kidsStartIndex = requestKidsMatcher.start(1);
+    int kidsEndIndex = requestKidsMatcher.end(1);
+    StringBuilder adjustedRequestBuilder = new StringBuilder(requestString);
+    base64ToBase64Url(adjustedRequestBuilder, kidsStartIndex, kidsEndIndex);
+    return Util.getUtf8Bytes(adjustedRequestBuilder.toString());
+  }
+
+  /**
+   * Adjusts ClearKey response data to be suitable for providing to the Android ClearKey CDM.
+   *
+   * @param response The response data.
+   * @return The adjusted response data.
+   */
+  public static byte[] adjustResponseData(byte[] response) {
+    if (Util.SDK_INT >= 27) {
+      return response;
+    }
+    // Prior to O-MR1 the ClearKey CDM expected Base64 encoding rather than Base64Url encoding for
+    // the "k" and "kid" strings. See [Internal: b/64388098].
+    try {
+      JSONObject responseJson = new JSONObject(Util.fromUtf8Bytes(response));
+      JSONArray keysArray = responseJson.getJSONArray("keys");
+      for (int i = 0; i < keysArray.length(); i++) {
+        JSONObject key = keysArray.getJSONObject(i);
+        key.put("k", base64UrlToBase64(key.getString("k")));
+        key.put("kid", base64UrlToBase64(key.getString("kid")));
+      }
+      return Util.getUtf8Bytes(responseJson.toString());
+    } catch (JSONException e) {
+      Log.e(TAG, "Failed to adjust response data: " + Util.fromUtf8Bytes(response), e);
+      return response;
+    }
+  }
+
+  private static void base64ToBase64Url(StringBuilder base64, int startIndex, int endIndex) {
+    for (int i = startIndex; i < endIndex; i++) {
+      switch (base64.charAt(i)) {
+        case '+':
+          base64.setCharAt(i, '-');
+          break;
+        case '/':
+          base64.setCharAt(i, '_');
+          break;
+        default:
+          break;
+      }
+    }
+  }
+
+  private static String base64UrlToBase64(String base64) {
+    return base64.replace('-', '+').replace('_', '/');
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
new file mode 100644
index 0000000000..25fdaba5b8
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
@@ -0,0 +1,563 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.media.NotProvisionedException;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.drm.ExoMediaDrm.DefaultKeyRequest;
+import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
+import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * A {@link DrmSession} that supports playbacks using {@link ExoMediaDrm}.
+ */
+@TargetApi(18)
+/* package */ class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T> {
+
+  /**
+   * Manages provisioning requests.
+   */
+  public interface ProvisioningManager<T extends ExoMediaCrypto> {
+
+    /**
+     * Called when a session requires provisioning. The manager <em>may</em> call
+     * {@link #provision()} to have this session perform the provisioning operation. The manager
+     * <em>will</em> call {@link DefaultDrmSession#onProvisionCompleted()} when provisioning has
+     * completed, or {@link DefaultDrmSession#onProvisionError} if provisioning fails.
+     *
+     * @param session The session.
+     */
+    void provisionRequired(DefaultDrmSession<T> session);
+
+    /**
+     * Called by a session when it fails to perform a provisioning operation.
+     *
+     * @param error The error that occurred.
+     */
+    void onProvisionError(Exception error);
+
+    /**
+     * Called by a session when it successfully completes a provisioning operation.
+     */
+    void onProvisionCompleted();
+
+  }
+
+  private static final String TAG = "DefaultDrmSession";
+
+  private static final int MSG_PROVISION = 0;
+  private static final int MSG_KEYS = 1;
+  private static final int MAX_LICENSE_DURATION_TO_RENEW = 60;
+
+  private final ExoMediaDrm<T> mediaDrm;
+  private final ProvisioningManager<T> provisioningManager;
+  private final byte[] initData;
+  private final String mimeType;
+  private final @DefaultDrmSessionManager.Mode int mode;
+  private final HashMap<String, String> optionalKeyRequestParameters;
+  private final Handler eventHandler;
+  private final DefaultDrmSessionManager.EventListener eventListener;
+  private final int initialDrmRequestRetryCount;
+
+  /* package */ final MediaDrmCallback callback;
+  /* package */ final UUID uuid;
+  /* package */ final PostResponseHandler postResponseHandler;
+
+  private @DrmSession.State int state;
+  private int openCount;
+  private HandlerThread requestHandlerThread;
+  private PostRequestHandler postRequestHandler;
+  private T mediaCrypto;
+  private DrmSessionException lastException;
+  private byte[] sessionId;
+  private byte[] offlineLicenseKeySetId;
+
+  /**
+   * Instantiates a new DRM session.
+   *
+   * @param uuid The UUID of the drm scheme.
+   * @param mediaDrm The media DRM.
+   * @param provisioningManager The manager for provisioning.
+   * @param initData The DRM init data.
+   * @param mode The DRM mode.
+   * @param offlineLicenseKeySetId The offlineLicense KeySetId.
+   * @param optionalKeyRequestParameters The optional key request parameters.
+   * @param callback The media DRM callback.
+   * @param playbackLooper The playback looper.
+   * @param eventHandler The handler to post listener events.
+   * @param eventListener The DRM session manager event listener.
+   * @param initialDrmRequestRetryCount The number of times to retry for initial provisioning and
+   *     key request before reporting error.
+   */
+  public DefaultDrmSession(UUID uuid, ExoMediaDrm<T> mediaDrm,
+      ProvisioningManager<T> provisioningManager, byte[] initData, String mimeType,
+      @DefaultDrmSessionManager.Mode int mode, byte[] offlineLicenseKeySetId,
+      HashMap<String, String> optionalKeyRequestParameters, MediaDrmCallback callback,
+      Looper playbackLooper, Handler eventHandler,
+      DefaultDrmSessionManager.EventListener eventListener,
+      int initialDrmRequestRetryCount) {
+    this.uuid = uuid;
+    this.provisioningManager = provisioningManager;
+    this.mediaDrm = mediaDrm;
+    this.mode = mode;
+    this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+    this.optionalKeyRequestParameters = optionalKeyRequestParameters;
+    this.callback = callback;
+    this.initialDrmRequestRetryCount = initialDrmRequestRetryCount;
+
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    state = STATE_OPENING;
+
+    postResponseHandler = new PostResponseHandler(playbackLooper);
+    requestHandlerThread = new HandlerThread("DrmRequestHandler");
+    requestHandlerThread.start();
+    postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
+
+    if (offlineLicenseKeySetId == null) {
+      this.initData = initData;
+      this.mimeType = mimeType;
+    } else {
+      this.initData = null;
+      this.mimeType = null;
+    }
+  }
+
+  // Life cycle.
+
+  public void acquire() {
+    if (++openCount == 1) {
+      if (state == STATE_ERROR) {
+        return;
+      }
+      if (openInternal(true)) {
+        doLicense(true);
+      }
+    }
+  }
+
+  /**
+   * @return True if the session is closed and cleaned up, false otherwise.
+   */
+  public boolean release() {
+    if (--openCount == 0) {
+      state = STATE_RELEASED;
+      postResponseHandler.removeCallbacksAndMessages(null);
+      postRequestHandler.removeCallbacksAndMessages(null);
+      postRequestHandler = null;
+      requestHandlerThread.quit();
+      requestHandlerThread = null;
+      mediaCrypto = null;
+      lastException = null;
+      if (sessionId != null) {
+        mediaDrm.closeSession(sessionId);
+        sessionId = null;
+      }
+      return true;
+    }
+    return false;
+  }
+
+  public boolean hasInitData(byte[] initData) {
+    return Arrays.equals(this.initData, initData);
+  }
+
+  public boolean hasSessionId(byte[] sessionId) {
+    return Arrays.equals(this.sessionId, sessionId);
+  }
+
+  // Provisioning implementation.
+
+  public void provision() {
+    ProvisionRequest request = mediaDrm.getProvisionRequest();
+    postRequestHandler.obtainMessage(MSG_PROVISION, request, true).sendToTarget();
+  }
+
+  public void onProvisionCompleted() {
+    if (openInternal(false)) {
+      doLicense(true);
+    }
+  }
+
+  public void onProvisionError(Exception error) {
+    onError(error);
+  }
+
+  // DrmSession implementation.
+
+  @Override
+  @DrmSession.State
+  public final int getState() {
+    return state;
+  }
+
+  @Override
+  public final DrmSessionException getError() {
+    return state == STATE_ERROR ? lastException : null;
+  }
+
+  @Override
+  public final T getMediaCrypto() {
+    return mediaCrypto;
+  }
+
+  @Override
+  public Map<String, String> queryKeyStatus() {
+    return sessionId == null ? null : mediaDrm.queryKeyStatus(sessionId);
+  }
+
+  @Override
+  public byte[] getOfflineLicenseKeySetId() {
+    return offlineLicenseKeySetId;
+  }
+
+  // Internal methods.
+
+  /**
+   *  Try to open a session, do provisioning if necessary.
+   *  @param allowProvisioning if provisioning is allowed, set this to false when calling from
+   *      processing provision response.
+   *  @return true on success, false otherwise.
+   */
+  private boolean openInternal(boolean allowProvisioning) {
+    if (isOpen()) {
+      // Already opened
+      return true;
+    }
+
+    try {
+      sessionId = mediaDrm.openSession();
+      mediaCrypto = mediaDrm.createMediaCrypto(sessionId);
+      state = STATE_OPENED;
+      return true;
+    } catch (NotProvisionedException e) {
+      if (allowProvisioning) {
+        provisioningManager.provisionRequired(this);
+      } else {
+        onError(e);
+      }
+    } catch (Exception e) {
+      onError(e);
+    }
+
+    return false;
+  }
+
+  private void onProvisionResponse(Object response) {
+    if (state != STATE_OPENING && !isOpen()) {
+      // This event is stale.
+      return;
+    }
+
+    if (response instanceof Exception) {
+      provisioningManager.onProvisionError((Exception) response);
+      return;
+    }
+
+    try {
+      mediaDrm.provideProvisionResponse((byte[]) response);
+    } catch (Exception e) {
+      provisioningManager.onProvisionError(e);
+      return;
+    }
+
+    provisioningManager.onProvisionCompleted();
+  }
+
+  private void doLicense(boolean allowRetry) {
+    switch (mode) {
+      case DefaultDrmSessionManager.MODE_PLAYBACK:
+      case DefaultDrmSessionManager.MODE_QUERY:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(ExoMediaDrm.KEY_TYPE_STREAMING, allowRetry);
+        } else if (state == STATE_OPENED_WITH_KEYS || restoreKeys()) {
+          long licenseDurationRemainingSec = getLicenseDurationRemainingSec();
+          if (mode == DefaultDrmSessionManager.MODE_PLAYBACK
+              && licenseDurationRemainingSec <= MAX_LICENSE_DURATION_TO_RENEW) {
+            Log.d(TAG, "Offline license has expired or will expire soon. "
+                + "Remaining seconds: " + licenseDurationRemainingSec);
+            postKeyRequest(ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
+          } else if (licenseDurationRemainingSec <= 0) {
+            onError(new KeysExpiredException());
+          } else {
+            state = STATE_OPENED_WITH_KEYS;
+            if (eventHandler != null && eventListener != null) {
+              eventHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                  eventListener.onDrmKeysRestored();
+                }
+              });
+            }
+          }
+        }
+        break;
+      case DefaultDrmSessionManager.MODE_DOWNLOAD:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
+        } else {
+          // Renew
+          if (restoreKeys()) {
+            postKeyRequest(ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
+          }
+        }
+        break;
+      case DefaultDrmSessionManager.MODE_RELEASE:
+        // It's not necessary to restore the key (and open a session to do that) before releasing it
+        // but this serves as a good sanity/fast-failure check.
+        if (restoreKeys()) {
+          postKeyRequest(ExoMediaDrm.KEY_TYPE_RELEASE, allowRetry);
+        }
+        break;
+      default:
+        break;
+    }
+  }
+
+  private boolean restoreKeys() {
+    try {
+      mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
+      return true;
+    } catch (Exception e) {
+      Log.e(TAG, "Error trying to restore Widevine keys.", e);
+      onError(e);
+    }
+    return false;
+  }
+
+  private long getLicenseDurationRemainingSec() {
+    if (!C.WIDEVINE_UUID.equals(uuid)) {
+      return Long.MAX_VALUE;
+    }
+    Pair<Long, Long> pair = WidevineUtil.getLicenseDurationRemainingSec(this);
+    return Math.min(pair.first, pair.second);
+  }
+
+  private void postKeyRequest(int type, boolean allowRetry) {
+    byte[] scope = type == ExoMediaDrm.KEY_TYPE_RELEASE ? offlineLicenseKeySetId : sessionId;
+    try {
+      KeyRequest request = mediaDrm.getKeyRequest(scope, initData, mimeType, type,
+          optionalKeyRequestParameters);
+      if (C.CLEARKEY_UUID.equals(uuid)) {
+        request = new DefaultKeyRequest(ClearKeyUtil.adjustRequestData(request.getData()),
+            request.getDefaultUrl());
+      }
+      postRequestHandler.obtainMessage(MSG_KEYS, request, allowRetry).sendToTarget();
+    } catch (Exception e) {
+      onKeysError(e);
+    }
+  }
+
+  private void onKeyResponse(Object response) {
+    if (!isOpen()) {
+      // This event is stale.
+      return;
+    }
+
+    if (response instanceof Exception) {
+      onKeysError((Exception) response);
+      return;
+    }
+
+    try {
+      byte[] responseData = (byte[]) response;
+      if (C.CLEARKEY_UUID.equals(uuid)) {
+        responseData = ClearKeyUtil.adjustResponseData(responseData);
+      }
+      if (mode == DefaultDrmSessionManager.MODE_RELEASE) {
+        mediaDrm.provideKeyResponse(offlineLicenseKeySetId, responseData);
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysRemoved();
+            }
+          });
+        }
+      } else {
+        byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, responseData);
+        if ((mode == DefaultDrmSessionManager.MODE_DOWNLOAD
+            || (mode == DefaultDrmSessionManager.MODE_PLAYBACK && offlineLicenseKeySetId != null))
+            && keySetId != null && keySetId.length != 0) {
+          offlineLicenseKeySetId = keySetId;
+        }
+        state = STATE_OPENED_WITH_KEYS;
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysLoaded();
+            }
+          });
+        }
+      }
+    } catch (Exception e) {
+      onKeysError(e);
+    }
+  }
+
+  private void onKeysExpired() {
+    if (state == STATE_OPENED_WITH_KEYS) {
+      state = STATE_OPENED;
+      onError(new KeysExpiredException());
+    }
+  }
+
+  private void onKeysError(Exception e) {
+    if (e instanceof NotProvisionedException) {
+      provisioningManager.provisionRequired(this);
+    } else {
+      onError(e);
+    }
+  }
+
+  private void onError(final Exception e) {
+    lastException = new DrmSessionException(e);
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onDrmSessionManagerError(e);
+        }
+      });
+    }
+    if (state != STATE_OPENED_WITH_KEYS) {
+      state = STATE_ERROR;
+    }
+  }
+
+  private boolean isOpen() {
+    return state == STATE_OPENED || state == STATE_OPENED_WITH_KEYS;
+  }
+
+  @SuppressWarnings("deprecation")
+  public void onMediaDrmEvent(int what) {
+    if (!isOpen()) {
+      return;
+    }
+    switch (what) {
+      case ExoMediaDrm.EVENT_KEY_REQUIRED:
+        doLicense(false);
+        break;
+      case ExoMediaDrm.EVENT_KEY_EXPIRED:
+        // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
+        // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
+        // waiting for key response.
+        onKeysExpired();
+        break;
+      case ExoMediaDrm.EVENT_PROVISION_REQUIRED:
+        state = STATE_OPENED;
+        provisioningManager.provisionRequired(this);
+        break;
+      default:
+        break;
+    }
+
+  }
+
+  @SuppressLint("HandlerLeak")
+  private class PostResponseHandler extends Handler {
+
+    public PostResponseHandler(Looper looper) {
+      super(looper);
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+      switch (msg.what) {
+        case MSG_PROVISION:
+          onProvisionResponse(msg.obj);
+          break;
+        case MSG_KEYS:
+          onKeyResponse(msg.obj);
+          break;
+        default:
+          break;
+
+      }
+    }
+
+  }
+
+  @SuppressLint("HandlerLeak")
+  private class PostRequestHandler extends Handler {
+
+    public PostRequestHandler(Looper backgroundLooper) {
+      super(backgroundLooper);
+    }
+
+    Message obtainMessage(int what, Object object, boolean allowRetry) {
+      return obtainMessage(what, allowRetry ? 1 : 0 /* allow retry*/, 0 /* error count */,
+          object);
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+      Object response;
+      try {
+        switch (msg.what) {
+          case MSG_PROVISION:
+            response = callback.executeProvisionRequest(uuid, (ProvisionRequest) msg.obj);
+            break;
+          case MSG_KEYS:
+            response = callback.executeKeyRequest(uuid, (KeyRequest) msg.obj);
+            break;
+          default:
+            throw new RuntimeException();
+        }
+      } catch (Exception e) {
+        if (maybeRetryRequest(msg)) {
+          return;
+        }
+        response = e;
+      }
+      postResponseHandler.obtainMessage(msg.what, response).sendToTarget();
+    }
+
+    private boolean maybeRetryRequest(Message originalMsg) {
+      boolean allowRetry = originalMsg.arg1 == 1;
+      if (!allowRetry) {
+        return false;
+      }
+      int errorCount = originalMsg.arg2 + 1;
+      if (errorCount > initialDrmRequestRetryCount) {
+        return false;
+      }
+      Message retryMsg = Message.obtain(originalMsg);
+      retryMsg.arg2 = errorCount;
+      sendMessageDelayed(retryMsg, getRetryDelayMillis(errorCount));
+      return true;
+    }
+
+    private long getRetryDelayMillis(int errorCount) {
+      return Math.min((errorCount - 1) * 1000, 5000);
+    }
+
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index cafbe6e8f7..08defdccee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -17,39 +17,35 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
-import android.media.DeniedByServerException;
-import android.media.MediaDrm;
-import android.media.NotProvisionedException;
 import android.os.Handler;
-import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.text.TextUtils;
-import android.util.Log;
-import android.util.Pair;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.drm.DefaultDrmSession.ProvisioningManager;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
-import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.OnEventListener;
-import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.Map;
+import java.util.List;
 import java.util.UUID;
 
 /**
- * A {@link DrmSessionManager} that supports playbacks using {@link MediaDrm}.
+ * A {@link DrmSessionManager} that supports playbacks using {@link ExoMediaDrm}.
  */
 @TargetApi(18)
 public class DefaultDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
-    DrmSession<T> {
+    ProvisioningManager<T> {
 
   /**
    * Listener of {@link DefaultDrmSessionManager} events.
@@ -63,6 +59,13 @@
 
     /**
      * Called when a drm error occurs.
+     * <p>
+     * This method being called does not indicate that playback has failed, or that it will fail.
+     * The player may be able to recover from the error and continue. Hence applications should
+     * <em>not</em> implement this method to display a user visible error or initiate an application
+     * level retry ({@link Player.EventListener#onPlayerError} is the appropriate place to implement
+     * such behavior). This method is called to provide the application with an opportunity to log
+     * the error if it wishes to do so.
      *
      * @param e The corresponding exception.
      */
@@ -84,6 +87,7 @@
    * The key to use when passing CustomData to a PlayReady instance in an optional parameter map.
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
+  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
 
   /** Determines the action to be done after a session acquired. */
   @Retention(RetentionPolicy.SOURCE)
@@ -95,56 +99,40 @@
    */
   public static final int MODE_PLAYBACK = 0;
   /**
-   * Restores an offline license to allow its status to be queried. If the offline license is
-   * expired sets state to {@link #STATE_ERROR}.
+   * Restores an offline license to allow its status to be queried.
    */
   public static final int MODE_QUERY = 1;
   /** Downloads an offline license or renews an existing one. */
   public static final int MODE_DOWNLOAD = 2;
   /** Releases an existing offline license. */
   public static final int MODE_RELEASE = 3;
+  /** Number of times to retry for initial provisioning and key request for reporting error. */
+  public static final int INITIAL_DRM_REQUEST_RETRY_COUNT = 3;
 
-  private static final String TAG = "OfflineDrmSessionMngr";
-  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
-
-  private static final int MSG_PROVISION = 0;
-  private static final int MSG_KEYS = 1;
-
-  private static final int MAX_LICENSE_DURATION_TO_RENEW = 60;
-
-  private final Handler eventHandler;
-  private final EventListener eventListener;
+  private final UUID uuid;
   private final ExoMediaDrm<T> mediaDrm;
+  private final MediaDrmCallback callback;
   private final HashMap<String, String> optionalKeyRequestParameters;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final boolean multiSession;
+  private final int initialDrmRequestRetryCount;
 
-  /* package */ final MediaDrmCallback callback;
-  /* package */ final UUID uuid;
-
-  /* package */ MediaDrmHandler mediaDrmHandler;
-  /* package */ PostResponseHandler postResponseHandler;
+  private final List<DefaultDrmSession<T>> sessions;
+  private final List<DefaultDrmSession<T>> provisioningSessions;
 
   private Looper playbackLooper;
-  private HandlerThread requestHandlerThread;
-  private Handler postRequestHandler;
-
   private int mode;
-  private int openCount;
-  private boolean provisioningInProgress;
-  @DrmSession.State
-  private int state;
-  private T mediaCrypto;
-  private DrmSessionException lastException;
-  private byte[] schemeInitData;
-  private String schemeMimeType;
-  private byte[] sessionId;
   private byte[] offlineLicenseKeySetId;
 
+  /* package */ volatile MediaDrmHandler mediaDrmHandler;
+
   /**
    * Instantiates a new instance using the Widevine scheme.
    *
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
@@ -190,7 +178,7 @@
    * @param uuid The UUID of the drm scheme.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
@@ -200,7 +188,8 @@
       UUID uuid, MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
     return new DefaultDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
-        optionalKeyRequestParameters, eventHandler, eventListener);
+        optionalKeyRequestParameters, eventHandler, eventListener, false,
+        INITIAL_DRM_REQUEST_RETRY_COUNT);
   }
 
   /**
@@ -208,7 +197,7 @@
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
@@ -216,18 +205,68 @@
   public DefaultDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
       HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
       EventListener eventListener) {
+    this(uuid, mediaDrm, callback, optionalKeyRequestParameters, eventHandler, eventListener,
+        false, INITIAL_DRM_REQUEST_RETRY_COUNT);
+  }
+
+  /**
+   * @param uuid The UUID of the drm scheme.
+   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param multiSession A boolean that specify whether multiple key session support is enabled.
+   *     Default is false.
+   */
+  public DefaultDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+      HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
+      EventListener eventListener, boolean multiSession) {
+    this(uuid, mediaDrm, callback, optionalKeyRequestParameters, eventHandler, eventListener,
+        multiSession, INITIAL_DRM_REQUEST_RETRY_COUNT);
+  }
+
+  /**
+   * @param uuid The UUID of the drm scheme.
+   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link ExoMediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param multiSession A boolean that specify whether multiple key session support is enabled.
+   *     Default is false.
+   * @param initialDrmRequestRetryCount The number of times to retry for initial provisioning and
+   *     key request before reporting error.
+   */
+  public DefaultDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+      HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
+      EventListener eventListener, boolean multiSession, int initialDrmRequestRetryCount) {
+    Assertions.checkNotNull(uuid);
+    Assertions.checkNotNull(mediaDrm);
+    Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid), "Use C.CLEARKEY_UUID instead");
     this.uuid = uuid;
     this.mediaDrm = mediaDrm;
     this.callback = callback;
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
-    mediaDrm.setOnEventListener(new MediaDrmEventListener());
+    this.multiSession = multiSession;
+    this.initialDrmRequestRetryCount = initialDrmRequestRetryCount;
     mode = MODE_PLAYBACK;
+    sessions = new ArrayList<>();
+    provisioningSessions = new ArrayList<>();
+    if (multiSession) {
+      mediaDrm.setPropertyString("sessionSharing", "enable");
+    }
+    mediaDrm.setOnEventListener(new MediaDrmEventListener());
   }
 
   /**
-   * Provides access to {@link MediaDrm#getPropertyString(String)}.
+   * Provides access to {@link ExoMediaDrm#getPropertyString(String)}.
    * <p>
    * This method may be called when the manager is in any state.
    *
@@ -239,7 +278,7 @@ public final String getPropertyString(String key) {
   }
 
   /**
-   * Provides access to {@link MediaDrm#setPropertyString(String, String)}.
+   * Provides access to {@link ExoMediaDrm#setPropertyString(String, String)}.
    * <p>
    * This method may be called when the manager is in any state.
    *
@@ -251,7 +290,7 @@ public final void setPropertyString(String key, String value) {
   }
 
   /**
-   * Provides access to {@link MediaDrm#getPropertyByteArray(String)}.
+   * Provides access to {@link ExoMediaDrm#getPropertyByteArray(String)}.
    * <p>
    * This method may be called when the manager is in any state.
    *
@@ -263,7 +302,7 @@ public final void setPropertyString(String key, String value) {
   }
 
   /**
-   * Provides access to {@link MediaDrm#setPropertyByteArray(String, byte[])}.
+   * Provides access to {@link ExoMediaDrm#setPropertyByteArray(String, byte[])}.
    * <p>
    * This method may be called when the manager is in any state.
    *
@@ -297,7 +336,7 @@ public final void setPropertyByteArray(String key, byte[] value) {
    * @param offlineLicenseKeySetId The key set id of the license to be used with the given mode.
    */
   public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
-    Assertions.checkState(openCount == 0);
+    Assertions.checkState(sessions.isEmpty());
     if (mode == MODE_QUERY || mode == MODE_RELEASE) {
       Assertions.checkNotNull(offlineLicenseKeySetId);
     }
@@ -309,12 +348,12 @@ public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
 
   @Override
   public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
-    SchemeData schemeData = drmInitData.get(uuid);
+    SchemeData schemeData = getSchemeData(drmInitData, uuid, true);
     if (schemeData == null) {
       // No data for this manager's scheme.
       return false;
     }
-    String schemeType = schemeData.type;
+    String schemeType = drmInitData.schemeType;
     if (schemeType == null || C.CENC_TYPE_cenc.equals(schemeType)) {
       // If there is no scheme information, assume patternless AES-CTR.
       return true;
@@ -330,295 +369,174 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
   @Override
   public DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitData) {
     Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
-    if (++openCount != 1) {
-      return this;
-    }
-
-    if (this.playbackLooper == null) {
+    if (sessions.isEmpty()) {
       this.playbackLooper = playbackLooper;
-      mediaDrmHandler = new MediaDrmHandler(playbackLooper);
-      postResponseHandler = new PostResponseHandler(playbackLooper);
+      if (mediaDrmHandler == null) {
+        mediaDrmHandler = new MediaDrmHandler(playbackLooper);
+      }
     }
 
-    requestHandlerThread = new HandlerThread("DrmRequestHandler");
-    requestHandlerThread.start();
-    postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
-
+    byte[] initData = null;
+    String mimeType = null;
     if (offlineLicenseKeySetId == null) {
-      SchemeData schemeData = drmInitData.get(uuid);
-      if (schemeData == null) {
-        onError(new IllegalStateException("Media does not support uuid: " + uuid));
-        return this;
-      }
-      schemeInitData = schemeData.data;
-      schemeMimeType = schemeData.mimeType;
-      if (Util.SDK_INT < 21) {
-        // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
-        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData, C.WIDEVINE_UUID);
-        if (psshData == null) {
-          // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
-        } else {
-          schemeInitData = psshData;
+      SchemeData data = getSchemeData(drmInitData, uuid, false);
+      if (data == null) {
+        final IllegalStateException error = new IllegalStateException(
+            "Media does not support uuid: " + uuid);
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmSessionManagerError(error);
+            }
+          });
         }
+        return new ErrorStateDrmSession<>(new DrmSessionException(error));
       }
-      if (Util.SDK_INT < 26 && C.CLEARKEY_UUID.equals(uuid)
-          && (MimeTypes.VIDEO_MP4.equals(schemeMimeType)
-          || MimeTypes.AUDIO_MP4.equals(schemeMimeType))) {
-        // Prior to API level 26 the ClearKey CDM only accepted "cenc" as the scheme for MP4.
-        schemeMimeType = CENC_SCHEME_MIME_TYPE;
+      initData = getSchemeInitData(data, uuid);
+      mimeType = getSchemeMimeType(data, uuid);
+    }
+
+    DefaultDrmSession<T> session;
+    if (!multiSession) {
+      session = sessions.isEmpty() ? null : sessions.get(0);
+    } else {
+      // Only use an existing session if it has matching init data.
+      session = null;
+      for (DefaultDrmSession<T> existingSession : sessions) {
+        if (existingSession.hasInitData(initData)) {
+          session = existingSession;
+          break;
+        }
       }
     }
-    state = STATE_OPENING;
-    openInternal(true);
-    return this;
+
+    if (session == null) {
+      // Create a new session.
+      session = new DefaultDrmSession<>(uuid, mediaDrm, this, initData, mimeType, mode,
+          offlineLicenseKeySetId, optionalKeyRequestParameters, callback, playbackLooper,
+          eventHandler, eventListener, initialDrmRequestRetryCount);
+      sessions.add(session);
+    }
+    session.acquire();
+    return session;
   }
 
   @Override
   public void releaseSession(DrmSession<T> session) {
-    if (--openCount != 0) {
+    if (session instanceof ErrorStateDrmSession) {
+      // Do nothing.
       return;
     }
-    state = STATE_RELEASED;
-    provisioningInProgress = false;
-    mediaDrmHandler.removeCallbacksAndMessages(null);
-    postResponseHandler.removeCallbacksAndMessages(null);
-    postRequestHandler.removeCallbacksAndMessages(null);
-    postRequestHandler = null;
-    requestHandlerThread.quit();
-    requestHandlerThread = null;
-    schemeInitData = null;
-    schemeMimeType = null;
-    mediaCrypto = null;
-    lastException = null;
-    if (sessionId != null) {
-      mediaDrm.closeSession(sessionId);
-      sessionId = null;
-    }
-  }
-
-  // DrmSession implementation.
 
-  @Override
-  @DrmSession.State
-  public final int getState() {
-    return state;
+    DefaultDrmSession<T> drmSession = (DefaultDrmSession<T>) session;
+    if (drmSession.release()) {
+      sessions.remove(drmSession);
+      if (provisioningSessions.size() > 1 && provisioningSessions.get(0) == drmSession) {
+        // Other sessions were waiting for the released session to complete a provision operation.
+        // We need to have one of those sessions perform the provision operation instead.
+        provisioningSessions.get(1).provision();
+      }
+      provisioningSessions.remove(drmSession);
+    }
   }
 
-  @Override
-  public final DrmSessionException getError() {
-    return state == STATE_ERROR ? lastException : null;
-  }
+  // ProvisioningManager implementation.
 
   @Override
-  public final T getMediaCrypto() {
-    return mediaCrypto;
+  public void provisionRequired(DefaultDrmSession<T> session) {
+    provisioningSessions.add(session);
+    if (provisioningSessions.size() == 1) {
+      // This is the first session requesting provisioning, so have it perform the operation.
+      session.provision();
+    }
   }
 
   @Override
-  public Map<String, String> queryKeyStatus() {
-    return sessionId == null ? null : mediaDrm.queryKeyStatus(sessionId);
+  public void onProvisionCompleted() {
+    for (DefaultDrmSession<T> session : provisioningSessions) {
+      session.onProvisionCompleted();
+    }
+    provisioningSessions.clear();
   }
 
   @Override
-  public byte[] getOfflineLicenseKeySetId() {
-    return offlineLicenseKeySetId;
+  public void onProvisionError(Exception error) {
+    for (DefaultDrmSession<T> session : provisioningSessions) {
+      session.onProvisionError(error);
+    }
+    provisioningSessions.clear();
   }
 
   // Internal methods.
 
-  private void openInternal(boolean allowProvisioning) {
-    try {
-      sessionId = mediaDrm.openSession();
-      mediaCrypto = mediaDrm.createMediaCrypto(uuid, sessionId);
-      state = STATE_OPENED;
-      doLicense();
-    } catch (NotProvisionedException e) {
-      if (allowProvisioning) {
-        postProvisionRequest();
-      } else {
-        onError(e);
+  /**
+   * Extracts {@link SchemeData} suitable for the given DRM scheme {@link UUID}.
+   *
+   * @param drmInitData The {@link DrmInitData} from which to extract the {@link SchemeData}.
+   * @param uuid The UUID.
+   * @param allowMissingData Whether a {@link SchemeData} with null {@link SchemeData#data} may be
+   *     returned.
+   * @return The extracted {@link SchemeData}, or null if no suitable data is present.
+   */
+  private static SchemeData getSchemeData(DrmInitData drmInitData, UUID uuid,
+      boolean allowMissingData) {
+    // Look for matching scheme data (matching the Common PSSH box for ClearKey).
+    List<SchemeData> matchingSchemeDatas = new ArrayList<>(drmInitData.schemeDataCount);
+    for (int i = 0; i < drmInitData.schemeDataCount; i++) {
+      SchemeData schemeData = drmInitData.get(i);
+      boolean uuidMatches = schemeData.matches(uuid)
+          || (C.CLEARKEY_UUID.equals(uuid) && schemeData.matches(C.COMMON_PSSH_UUID));
+      if (uuidMatches && (schemeData.data != null || allowMissingData)) {
+        matchingSchemeDatas.add(schemeData);
       }
-    } catch (Exception e) {
-      onError(e);
-    }
-  }
-
-  private void postProvisionRequest() {
-    if (provisioningInProgress) {
-      return;
     }
-    provisioningInProgress = true;
-    ProvisionRequest request = mediaDrm.getProvisionRequest();
-    postRequestHandler.obtainMessage(MSG_PROVISION, request).sendToTarget();
-  }
 
-  private void onProvisionResponse(Object response) {
-    provisioningInProgress = false;
-    if (state != STATE_OPENING && state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS) {
-      // This event is stale.
-      return;
+    if (matchingSchemeDatas.isEmpty()) {
+      return null;
     }
 
-    if (response instanceof Exception) {
-      onError((Exception) response);
-      return;
-    }
-
-    try {
-      mediaDrm.provideProvisionResponse((byte[]) response);
-      if (state == STATE_OPENING) {
-        openInternal(false);
-      } else {
-        doLicense();
-      }
-    } catch (DeniedByServerException e) {
-      onError(e);
-    }
-  }
-
-  private void doLicense() {
-    switch (mode) {
-      case MODE_PLAYBACK:
-      case MODE_QUERY:
-        if (offlineLicenseKeySetId == null) {
-          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_STREAMING);
-        } else {
-          if (restoreKeys()) {
-            long licenseDurationRemainingSec = getLicenseDurationRemainingSec();
-            if (mode == MODE_PLAYBACK
-                && licenseDurationRemainingSec <= MAX_LICENSE_DURATION_TO_RENEW) {
-              Log.d(TAG, "Offline license has expired or will expire soon. "
-                  + "Remaining seconds: " + licenseDurationRemainingSec);
-              postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
-            } else if (licenseDurationRemainingSec <= 0) {
-              onError(new KeysExpiredException());
-            } else {
-              state = STATE_OPENED_WITH_KEYS;
-              if (eventHandler != null && eventListener != null) {
-                eventHandler.post(new Runnable() {
-                  @Override
-                  public void run() {
-                    eventListener.onDrmKeysRestored();
-                  }
-                });
-              }
-            }
-          }
-        }
-        break;
-      case MODE_DOWNLOAD:
-        if (offlineLicenseKeySetId == null) {
-          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
-        } else {
-          // Renew
-          if (restoreKeys()) {
-            postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
-          }
+    // For Widevine PSSH boxes, prefer V1 boxes from API 23 and V0 before.
+    if (C.WIDEVINE_UUID.equals(uuid)) {
+      for (int i = 0; i < matchingSchemeDatas.size(); i++) {
+        SchemeData matchingSchemeData = matchingSchemeDatas.get(i);
+        int version = matchingSchemeData.hasData()
+            ? PsshAtomUtil.parseVersion(matchingSchemeData.data) : -1;
+        if (Util.SDK_INT < 23 && version == 0) {
+          return matchingSchemeData;
+        } else if (Util.SDK_INT >= 23 && version == 1) {
+          return matchingSchemeData;
         }
-        break;
-      case MODE_RELEASE:
-        // It's not necessary to restore the key (and open a session to do that) before releasing it
-        // but this serves as a good sanity/fast-failure check.
-        if (restoreKeys()) {
-          postKeyRequest(offlineLicenseKeySetId, MediaDrm.KEY_TYPE_RELEASE);
-        }
-        break;
-    }
-  }
-
-  private boolean restoreKeys() {
-    try {
-      mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
-      return true;
-    } catch (Exception e) {
-      Log.e(TAG, "Error trying to restore Widevine keys.", e);
-      onError(e);
-    }
-    return false;
-  }
-
-  private long getLicenseDurationRemainingSec() {
-    if (!C.WIDEVINE_UUID.equals(uuid)) {
-      return Long.MAX_VALUE;
+      }
     }
-    Pair<Long, Long> pair = WidevineUtil.getLicenseDurationRemainingSec(this);
-    return Math.min(pair.first, pair.second);
-  }
 
-  private void postKeyRequest(byte[] scope, int keyType) {
-    try {
-      KeyRequest keyRequest = mediaDrm.getKeyRequest(scope, schemeInitData, schemeMimeType, keyType,
-          optionalKeyRequestParameters);
-      postRequestHandler.obtainMessage(MSG_KEYS, keyRequest).sendToTarget();
-    } catch (Exception e) {
-      onKeysError(e);
-    }
+    // If we don't have any special handling, prefer the first matching scheme data.
+    return matchingSchemeDatas.get(0);
   }
 
-  private void onKeyResponse(Object response) {
-    if (state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS) {
-      // This event is stale.
-      return;
-    }
-
-    if (response instanceof Exception) {
-      onKeysError((Exception) response);
-      return;
-    }
-
-    try {
-      if (mode == MODE_RELEASE) {
-        mediaDrm.provideKeyResponse(offlineLicenseKeySetId, (byte[]) response);
-        if (eventHandler != null && eventListener != null) {
-          eventHandler.post(new Runnable() {
-            @Override
-            public void run() {
-              eventListener.onDrmKeysRemoved();
-            }
-          });
-        }
+  private static byte[] getSchemeInitData(SchemeData data, UUID uuid) {
+    byte[] schemeInitData = data.data;
+    if (Util.SDK_INT < 21) {
+      // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
+      byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData, uuid);
+      if (psshData == null) {
+        // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
       } else {
-        byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
-        if ((mode == MODE_DOWNLOAD || (mode == MODE_PLAYBACK && offlineLicenseKeySetId != null))
-            && keySetId != null && keySetId.length != 0) {
-          offlineLicenseKeySetId = keySetId;
-        }
-        state = STATE_OPENED_WITH_KEYS;
-        if (eventHandler != null && eventListener != null) {
-          eventHandler.post(new Runnable() {
-            @Override
-            public void run() {
-              eventListener.onDrmKeysLoaded();
-            }
-          });
-        }
+        schemeInitData = psshData;
       }
-    } catch (Exception e) {
-      onKeysError(e);
-    }
-  }
-
-  private void onKeysError(Exception e) {
-    if (e instanceof NotProvisionedException) {
-      postProvisionRequest();
-    } else {
-      onError(e);
     }
+    return schemeInitData;
   }
 
-  private void onError(final Exception e) {
-    lastException = new DrmSessionException(e);
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          eventListener.onDrmSessionManagerError(e);
-        }
-      });
-    }
-    if (state != STATE_OPENED_WITH_KEYS) {
-      state = STATE_ERROR;
+  private static String getSchemeMimeType(SchemeData data, UUID uuid) {
+    String schemeMimeType = data.mimeType;
+    if (Util.SDK_INT < 26 && C.CLEARKEY_UUID.equals(uuid)
+        && (MimeTypes.VIDEO_MP4.equals(schemeMimeType)
+        || MimeTypes.AUDIO_MP4.equals(schemeMimeType))) {
+      // Prior to API level 26 the ClearKey CDM only accepted "cenc" as the scheme for MP4.
+      schemeMimeType = CENC_SCHEME_MIME_TYPE;
     }
+    return schemeMimeType;
   }
 
   @SuppressLint("HandlerLeak")
@@ -628,29 +546,14 @@ public MediaDrmHandler(Looper looper) {
       super(looper);
     }
 
-    @SuppressWarnings("deprecation")
     @Override
     public void handleMessage(Message msg) {
-      if (openCount == 0 || (state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS)) {
-        return;
-      }
-      switch (msg.what) {
-        case MediaDrm.EVENT_KEY_REQUIRED:
-          doLicense();
-          break;
-        case MediaDrm.EVENT_KEY_EXPIRED:
-          // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
-          // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
-          // waiting for key response.
-          if (state == STATE_OPENED_WITH_KEYS) {
-            state = STATE_OPENED;
-            onError(new KeysExpiredException());
-          }
-          break;
-        case MediaDrm.EVENT_PROVISION_REQUIRED:
-          state = STATE_OPENED;
-          postProvisionRequest();
-          break;
+      byte[] sessionId = (byte[]) msg.obj;
+      for (DefaultDrmSession<T> session : sessions) {
+        if (session.hasSessionId(sessionId)) {
+          session.onMediaDrmEvent(msg.what);
+          return;
+        }
       }
     }
 
@@ -661,59 +564,9 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(ExoMediaDrm<? extends T> md, byte[] sessionId, int event, int extra,
         byte[] data) {
-      if (mode == MODE_PLAYBACK) {
-        mediaDrmHandler.sendEmptyMessage(event);
-      }
-    }
-
-  }
-
-  @SuppressLint("HandlerLeak")
-  private class PostResponseHandler extends Handler {
-
-    public PostResponseHandler(Looper looper) {
-      super(looper);
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
-      switch (msg.what) {
-        case MSG_PROVISION:
-          onProvisionResponse(msg.obj);
-          break;
-        case MSG_KEYS:
-          onKeyResponse(msg.obj);
-          break;
-      }
-    }
-
-  }
-
-  @SuppressLint("HandlerLeak")
-  private class PostRequestHandler extends Handler {
-
-    public PostRequestHandler(Looper backgroundLooper) {
-      super(backgroundLooper);
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
-      Object response;
-      try {
-        switch (msg.what) {
-          case MSG_PROVISION:
-            response = callback.executeProvisionRequest(uuid, (ProvisionRequest) msg.obj);
-            break;
-          case MSG_KEYS:
-            response = callback.executeKeyRequest(uuid, (KeyRequest) msg.obj);
-            break;
-          default:
-            throw new RuntimeException();
-        }
-      } catch (Exception e) {
-        response = e;
+      if (mode == DefaultDrmSessionManager.MODE_PLAYBACK) {
+        mediaDrmHandler.obtainMessage(event, sessionId).sendToTarget();
       }
-      postResponseHandler.obtainMessage(msg.what, response).sendToTarget();
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
index 9fa6547a00..73b443dcec 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
@@ -37,6 +37,11 @@
   // Lazily initialized hashcode.
   private int hashCode;
 
+  /**
+   * The protection scheme type, or null if not applicable or unknown.
+   */
+  @Nullable public final String schemeType;
+
   /**
    * Number of {@link SchemeData}s.
    */
@@ -46,34 +51,47 @@
    * @param schemeDatas Scheme initialization data for possibly multiple DRM schemes.
    */
   public DrmInitData(List<SchemeData> schemeDatas) {
-    this(false, schemeDatas.toArray(new SchemeData[schemeDatas.size()]));
+    this(null, false, schemeDatas.toArray(new SchemeData[schemeDatas.size()]));
+  }
+
+  /**
+   * @param schemeType See {@link #schemeType}.
+   * @param schemeDatas Scheme initialization data for possibly multiple DRM schemes.
+   */
+  public DrmInitData(String schemeType, List<SchemeData> schemeDatas) {
+    this(schemeType, false, schemeDatas.toArray(new SchemeData[schemeDatas.size()]));
   }
 
   /**
    * @param schemeDatas Scheme initialization data for possibly multiple DRM schemes.
    */
   public DrmInitData(SchemeData... schemeDatas) {
-    this(true, schemeDatas);
+    this(null, schemeDatas);
+  }
+
+  /**
+   * @param schemeType See {@link #schemeType}.
+   * @param schemeDatas Scheme initialization data for possibly multiple DRM schemes.
+   */
+  public DrmInitData(@Nullable String schemeType, SchemeData... schemeDatas) {
+    this(schemeType, true, schemeDatas);
   }
 
-  private DrmInitData(boolean cloneSchemeDatas, SchemeData... schemeDatas) {
+  private DrmInitData(@Nullable String schemeType, boolean cloneSchemeDatas,
+      SchemeData... schemeDatas) {
+    this.schemeType = schemeType;
     if (cloneSchemeDatas) {
       schemeDatas = schemeDatas.clone();
     }
-    // Sorting ensures that universal scheme data(i.e. data that applies to all schemes) is matched
+    // Sorting ensures that universal scheme data (i.e. data that applies to all schemes) is matched
     // last. It's also required by the equals and hashcode implementations.
     Arrays.sort(schemeDatas, this);
-    // Check for no duplicates.
-    for (int i = 1; i < schemeDatas.length; i++) {
-      if (schemeDatas[i - 1].uuid.equals(schemeDatas[i].uuid)) {
-        throw new IllegalArgumentException("Duplicate data for uuid: " + schemeDatas[i].uuid);
-      }
-    }
     this.schemeDatas = schemeDatas;
     schemeDataCount = schemeDatas.length;
   }
 
   /* package */ DrmInitData(Parcel in) {
+    schemeType = in.readString();
     schemeDatas = in.createTypedArray(SchemeData.CREATOR);
     schemeDataCount = schemeDatas.length;
   }
@@ -81,9 +99,11 @@ private DrmInitData(boolean cloneSchemeDatas, SchemeData... schemeDatas) {
   /**
    * Retrieves data for a given DRM scheme, specified by its UUID.
    *
+   * @deprecated Use {@link #get(int)} and {@link SchemeData#matches(UUID)} instead.
    * @param uuid The DRM scheme's UUID.
    * @return The initialization data for the scheme, or null if the scheme is not supported.
    */
+  @Deprecated
   public SchemeData get(UUID uuid) {
     for (SchemeData schemeData : schemeDatas) {
       if (schemeData.matches(uuid)) {
@@ -96,44 +116,32 @@ public SchemeData get(UUID uuid) {
   /**
    * Retrieves the {@link SchemeData} at a given index.
    *
-   * @param index index of the scheme to return.
-   * @return The {@link SchemeData} at the index.
+   * @param index The index of the scheme to return. Must not exceed {@link #schemeDataCount}.
+   * @return The {@link SchemeData} at the specified index.
    */
   public SchemeData get(int index) {
     return schemeDatas[index];
   }
 
   /**
-   * Returns a copy of the {@link DrmInitData} instance whose {@link SchemeData}s have been updated
-   * to have the specified scheme type.
+   * Returns a copy with the specified protection scheme type.
    *
    * @param schemeType A protection scheme type. May be null.
-   * @return A copy of the {@link DrmInitData} instance whose {@link SchemeData}s have been updated
-   *     to have the specified scheme type.
+   * @return A copy with the specified protection scheme type.
    */
   public DrmInitData copyWithSchemeType(@Nullable String schemeType) {
-    boolean isCopyRequired = false;
-    for (SchemeData schemeData : schemeDatas) {
-      if (!Util.areEqual(schemeData.type, schemeType)) {
-        isCopyRequired = true;
-        break;
-      }
-    }
-    if (isCopyRequired) {
-      SchemeData[] schemeDatas = new SchemeData[this.schemeDatas.length];
-      for (int i = 0; i < schemeDatas.length; i++) {
-        schemeDatas[i] = this.schemeDatas[i].copyWithSchemeType(schemeType);
-      }
-      return new DrmInitData(schemeDatas);
-    } else {
+    if (Util.areEqual(this.schemeType, schemeType)) {
       return this;
     }
+    return new DrmInitData(schemeType, false, schemeDatas);
   }
 
   @Override
   public int hashCode() {
     if (hashCode == 0) {
-      hashCode = Arrays.hashCode(schemeDatas);
+      int result = (schemeType == null ? 0 : schemeType.hashCode());
+      result = 31 * result + Arrays.hashCode(schemeDatas);
+      hashCode = result;
     }
     return hashCode;
   }
@@ -146,7 +154,9 @@ public boolean equals(Object obj) {
     if (obj == null || getClass() != obj.getClass()) {
       return false;
     }
-    return Arrays.equals(schemeDatas, ((DrmInitData) obj).schemeDatas);
+    DrmInitData other = (DrmInitData) obj;
+    return Util.areEqual(schemeType, other.schemeType)
+        && Arrays.equals(schemeDatas, other.schemeDatas);
   }
 
   @Override
@@ -164,6 +174,7 @@ public int describeContents() {
 
   @Override
   public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(schemeType);
     dest.writeTypedArray(schemeDatas, 0);
   }
 
@@ -195,16 +206,12 @@ public DrmInitData createFromParcel(Parcel in) {
      * applies to all schemes).
      */
     private final UUID uuid;
-    /**
-     * The protection scheme type, or null if not applicable or unknown.
-     */
-    @Nullable public final String type;
     /**
      * The mimeType of {@link #data}.
      */
     public final String mimeType;
     /**
-     * The initialization data.
+     * The initialization data. May be null for scheme support checks only.
      */
     public final byte[] data;
     /**
@@ -215,34 +222,29 @@ public DrmInitData createFromParcel(Parcel in) {
     /**
      * @param uuid The {@link UUID} of the DRM scheme, or {@link C#UUID_NIL} if the data is
      *     universal (i.e. applies to all schemes).
-     * @param type The type of the protection scheme, or null if not applicable or unknown.
-     * @param mimeType The mimeType of the initialization data.
-     * @param data The initialization data.
+     * @param mimeType See {@link #mimeType}.
+     * @param data See {@link #data}.
      */
-    public SchemeData(UUID uuid, @Nullable String type, String mimeType, byte[] data) {
-      this(uuid, type, mimeType, data, false);
+    public SchemeData(UUID uuid, String mimeType, byte[] data) {
+      this(uuid, mimeType, data, false);
     }
 
     /**
      * @param uuid The {@link UUID} of the DRM scheme, or {@link C#UUID_NIL} if the data is
      *     universal (i.e. applies to all schemes).
-     * @param type The type of the protection scheme, or null if not applicable or unknown.
-     * @param mimeType The mimeType of the initialization data.
-     * @param data The initialization data.
-     * @param requiresSecureDecryption Whether secure decryption is required.
+     * @param mimeType See {@link #mimeType}.
+     * @param data See {@link #data}.
+     * @param requiresSecureDecryption See {@link #requiresSecureDecryption}.
      */
-    public SchemeData(UUID uuid, @Nullable String type, String mimeType, byte[] data,
-        boolean requiresSecureDecryption) {
+    public SchemeData(UUID uuid, String mimeType, byte[] data, boolean requiresSecureDecryption) {
       this.uuid = Assertions.checkNotNull(uuid);
-      this.type = type;
       this.mimeType = Assertions.checkNotNull(mimeType);
-      this.data = Assertions.checkNotNull(data);
+      this.data = data;
       this.requiresSecureDecryption = requiresSecureDecryption;
     }
 
     /* package */ SchemeData(Parcel in) {
       uuid = new UUID(in.readLong(), in.readLong());
-      type = in.readString();
       mimeType = in.readString();
       data = in.createByteArray();
       requiresSecureDecryption = in.readByte() != 0;
@@ -259,16 +261,20 @@ public boolean matches(UUID schemeUuid) {
     }
 
     /**
-     * Returns a copy of the {@link SchemeData} instance with the given scheme type.
+     * Returns whether this {@link SchemeData} can be used to replace {@code other}.
      *
-     * @param type A protection scheme type.
-     * @return A copy of the {@link SchemeData} instance with the given scheme type.
+     * @param other A {@link SchemeData}.
+     * @return Whether this {@link SchemeData} can be used to replace {@code other}.
      */
-    public SchemeData copyWithSchemeType(String type) {
-      if (Util.areEqual(this.type, type)) {
-        return this;
-      }
-      return new SchemeData(uuid, type, mimeType, data, requiresSecureDecryption);
+    public boolean canReplace(SchemeData other) {
+      return hasData() && !other.hasData() && matches(other.uuid);
+    }
+
+    /**
+     * Returns whether {@link #data} is non-null.
+     */
+    public boolean hasData() {
+      return data != null;
     }
 
     @Override
@@ -281,14 +287,13 @@ public boolean equals(Object obj) {
       }
       SchemeData other = (SchemeData) obj;
       return mimeType.equals(other.mimeType) && Util.areEqual(uuid, other.uuid)
-          && Util.areEqual(type, other.type) && Arrays.equals(data, other.data);
+          && Arrays.equals(data, other.data);
     }
 
     @Override
     public int hashCode() {
       if (hashCode == 0) {
         int result = uuid.hashCode();
-        result = 31 * result + (type == null ? 0 : type.hashCode());
         result = 31 * result + mimeType.hashCode();
         result = 31 * result + Arrays.hashCode(data);
         hashCode = result;
@@ -307,7 +312,6 @@ public int describeContents() {
     public void writeToParcel(Parcel dest, int flags) {
       dest.writeLong(uuid.getMostSignificantBits());
       dest.writeLong(uuid.getLeastSignificantBits());
-      dest.writeString(type);
       dest.writeString(mimeType);
       dest.writeByteArray(data);
       dest.writeByte((byte) (requiresSecureDecryption ? 1 : 0));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
index e4b7059860..cf3d97d0b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
@@ -17,6 +17,7 @@
 
 import android.annotation.TargetApi;
 import android.os.Looper;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 
 /**
  * Manages a DRM session.
@@ -39,7 +40,8 @@
    * must be returned to {@link #releaseSession(DrmSession)} when it is no longer required.
    *
    * @param playbackLooper The looper associated with the media playback thread.
-   * @param drmInitData DRM initialization data.
+   * @param drmInitData DRM initialization data. All contained {@link SchemeData}s must contain
+   *     non-null {@link SchemeData#data}.
    * @return The DRM session.
    */
   DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitData);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
new file mode 100644
index 0000000000..576f0a08a9
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.Map;
+
+/**
+ * A {@link DrmSession} that's in a terminal error state.
+ */
+/* package */ final class ErrorStateDrmSession<T extends ExoMediaCrypto> implements DrmSession<T> {
+
+  private final DrmSessionException error;
+
+  public ErrorStateDrmSession(DrmSessionException error) {
+    this.error = Assertions.checkNotNull(error);
+  }
+
+  @Override
+  public int getState() {
+    return STATE_ERROR;
+  }
+
+  @Override
+  public DrmSessionException getError() {
+    return error;
+  }
+
+  @Override
+  public T getMediaCrypto() {
+    return null;
+  }
+
+  @Override
+  public Map<String, String> queryKeyStatus() {
+    return null;
+  }
+
+  @Override
+  public byte[] getOfflineLicenseKeySetId() {
+    return null;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
index 3d765dbef5..cecc840511 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
@@ -15,20 +15,56 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import android.annotation.TargetApi;
 import android.media.DeniedByServerException;
 import android.media.MediaCryptoException;
 import android.media.MediaDrm;
+import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
-import android.media.ResourceBusyException;
+import android.os.Handler;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.UUID;
 
 /**
  * Used to obtain keys for decrypting protected media streams. See {@link android.media.MediaDrm}.
  */
+@TargetApi(18)
 public interface ExoMediaDrm<T extends ExoMediaCrypto> {
 
+  /**
+   * @see MediaDrm#EVENT_KEY_REQUIRED
+   */
+  @SuppressWarnings("InlinedApi")
+  int EVENT_KEY_REQUIRED = MediaDrm.EVENT_KEY_REQUIRED;
+  /**
+   * @see MediaDrm#EVENT_KEY_EXPIRED
+   */
+  @SuppressWarnings("InlinedApi")
+  int EVENT_KEY_EXPIRED = MediaDrm.EVENT_KEY_EXPIRED;
+  /**
+   * @see MediaDrm#EVENT_PROVISION_REQUIRED
+   */
+  @SuppressWarnings("InlinedApi")
+  int EVENT_PROVISION_REQUIRED = MediaDrm.EVENT_PROVISION_REQUIRED;
+
+  /**
+   * @see MediaDrm#KEY_TYPE_STREAMING
+   */
+  @SuppressWarnings("InlinedApi")
+  int KEY_TYPE_STREAMING = MediaDrm.KEY_TYPE_STREAMING;
+  /**
+   * @see MediaDrm#KEY_TYPE_OFFLINE
+   */
+  @SuppressWarnings("InlinedApi")
+  int KEY_TYPE_OFFLINE = MediaDrm.KEY_TYPE_OFFLINE;
+  /**
+   * @see MediaDrm#KEY_TYPE_RELEASE
+   */
+  @SuppressWarnings("InlinedApi")
+  int KEY_TYPE_RELEASE = MediaDrm.KEY_TYPE_RELEASE;
+
   /**
    * @see android.media.MediaDrm.OnEventListener
    */
@@ -46,6 +82,56 @@ void onEvent(ExoMediaDrm<? extends T> mediaDrm, byte[] sessionId, int event, int
         byte[] data);
   }
 
+  /**
+   * @see android.media.MediaDrm.OnKeyStatusChangeListener
+   */
+  interface OnKeyStatusChangeListener<T extends ExoMediaCrypto> {
+    /**
+     * Called when the keys in a session change status, such as when the license is renewed or
+     * expires.
+     *
+     * @param mediaDrm the {@link ExoMediaDrm} object on which the event occurred.
+     * @param sessionId the DRM session ID on which the event occurred.
+     * @param exoKeyInfo a list of {@link KeyStatus} that contains key ID and status.
+     * @param hasNewUsableKey true if new key becomes usable.
+     */
+    void onKeyStatusChange(ExoMediaDrm<? extends T> mediaDrm, byte[] sessionId,
+                           List<KeyStatus> exoKeyInfo, boolean hasNewUsableKey);
+  }
+
+  /**
+   * @see android.media.MediaDrm.KeyStatus
+   */
+  interface KeyStatus {
+    int getStatusCode();
+    byte[] getKeyId();
+  }
+
+  /**
+   * Default implementation of {@link KeyStatus}.
+   */
+  final class DefaultKeyStatus implements KeyStatus {
+
+    private final int statusCode;
+    private final byte[] keyId;
+
+    DefaultKeyStatus(int statusCode, byte[] keyId) {
+      this.statusCode = statusCode;
+      this.keyId = keyId;
+    }
+
+    @Override
+    public int getStatusCode() {
+      return statusCode;
+    }
+
+    @Override
+    public byte[] getKeyId() {
+      return keyId;
+    }
+
+  }
+
   /**
    * @see android.media.MediaDrm.KeyRequest
    */
@@ -54,6 +140,31 @@ void onEvent(ExoMediaDrm<? extends T> mediaDrm, byte[] sessionId, int event, int
     String getDefaultUrl();
   }
 
+  /**
+   * Default implementation of {@link KeyRequest}.
+   */
+  final class DefaultKeyRequest implements KeyRequest {
+
+    private final byte[] data;
+    private final String defaultUrl;
+
+    public DefaultKeyRequest(byte[] data, String defaultUrl) {
+      this.data = data;
+      this.defaultUrl = defaultUrl;
+    }
+
+    @Override
+    public byte[] getData() {
+      return data;
+    }
+
+    @Override
+    public String getDefaultUrl() {
+      return defaultUrl;
+    }
+
+  }
+
   /**
    * @see android.media.MediaDrm.ProvisionRequest
    */
@@ -62,15 +173,45 @@ void onEvent(ExoMediaDrm<? extends T> mediaDrm, byte[] sessionId, int event, int
     String getDefaultUrl();
   }
 
+  /**
+   * Default implementation of {@link ProvisionRequest}.
+   */
+  final class DefaultProvisionRequest implements ProvisionRequest {
+
+    private final byte[] data;
+    private final String defaultUrl;
+
+    public DefaultProvisionRequest(byte[] data, String defaultUrl) {
+      this.data = data;
+      this.defaultUrl = defaultUrl;
+    }
+
+    @Override
+    public byte[] getData() {
+      return data;
+    }
+
+    @Override
+    public String getDefaultUrl() {
+      return defaultUrl;
+    }
+
+  }
+
   /**
    * @see MediaDrm#setOnEventListener(MediaDrm.OnEventListener)
    */
   void setOnEventListener(OnEventListener<? super T> listener);
 
+  /**
+   * @see MediaDrm#setOnKeyStatusChangeListener(MediaDrm.OnKeyStatusChangeListener, Handler)
+   */
+  void setOnKeyStatusChangeListener(OnKeyStatusChangeListener<? super T> listener);
+
   /**
    * @see MediaDrm#openSession()
    */
-  byte[] openSession() throws NotProvisionedException, ResourceBusyException;
+  byte[] openSession() throws MediaDrmException;
 
   /**
    * @see MediaDrm#closeSession(byte[])
@@ -137,11 +278,10 @@ KeyRequest getKeyRequest(byte[] scope, byte[] init, String mimeType, int keyType
   /**
    * @see android.media.MediaCrypto#MediaCrypto(UUID, byte[])
    *
-   * @param uuid The UUID of the crypto scheme.
    * @param initData Opaque initialization data specific to the crypto scheme.
    * @return An object extends {@link ExoMediaCrypto}, using opaque crypto scheme specific data.
-   * @throws MediaCryptoException
+   * @throws MediaCryptoException If the instance can't be created.
    */
-  T createMediaCrypto(UUID uuid, byte[] initData) throws MediaCryptoException;
+  T createMediaCrypto(byte[] initData) throws MediaCryptoException;
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
index 5bee85f449..4e58ed6a31 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
@@ -28,12 +28,29 @@
   private final MediaCrypto mediaCrypto;
   private final boolean forceAllowInsecureDecoderComponents;
 
-  /* package */ FrameworkMediaCrypto(MediaCrypto mediaCrypto,
+  /**
+   * @param mediaCrypto The {@link MediaCrypto} to wrap.
+   */
+  public FrameworkMediaCrypto(MediaCrypto mediaCrypto) {
+    this(mediaCrypto, false);
+  }
+
+  /**
+   * @param mediaCrypto The {@link MediaCrypto} to wrap.
+   * @param forceAllowInsecureDecoderComponents Whether to force
+   *     {@link #requiresSecureDecoderComponent(String)} to return {@code false}, rather than
+   *     {@link MediaCrypto#requiresSecureDecoderComponent(String)} of the wrapped
+   *     {@link MediaCrypto}.
+   */
+  public FrameworkMediaCrypto(MediaCrypto mediaCrypto,
       boolean forceAllowInsecureDecoderComponents) {
     this.mediaCrypto = Assertions.checkNotNull(mediaCrypto);
     this.forceAllowInsecureDecoderComponents = forceAllowInsecureDecoderComponents;
   }
 
+  /**
+   * Returns the wrapped {@link MediaCrypto}.
+   */
   public MediaCrypto getWrappedMediaCrypto() {
     return mediaCrypto;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index ed4494559a..f960cd637f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -20,23 +20,27 @@
 import android.media.MediaCrypto;
 import android.media.MediaCryptoException;
 import android.media.MediaDrm;
+import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
-import android.media.ResourceBusyException;
 import android.media.UnsupportedSchemeException;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.UUID;
 
 /**
  * An {@link ExoMediaDrm} implementation that wraps the framework {@link MediaDrm}.
  */
-@TargetApi(18)
+@TargetApi(23)
 public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto> {
 
+  private final UUID uuid;
   private final MediaDrm mediaDrm;
 
   /**
@@ -57,7 +61,12 @@ public static FrameworkMediaDrm newInstance(UUID uuid) throws UnsupportedDrmExce
   }
 
   private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
-    this.mediaDrm = new MediaDrm(Assertions.checkNotNull(uuid));
+    Assertions.checkNotNull(uuid);
+    Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid), "Use C.CLEARKEY_UUID instead");
+    // ClearKey had to be accessed using the Common PSSH UUID prior to API level 27.
+    uuid = Util.SDK_INT < 27 && C.CLEARKEY_UUID.equals(uuid) ? C.COMMON_PSSH_UUID : uuid;
+    this.uuid = uuid;
+    this.mediaDrm = new MediaDrm(uuid);
   }
 
   @Override
@@ -65,7 +74,7 @@ public void setOnEventListener(
       final ExoMediaDrm.OnEventListener<? super FrameworkMediaCrypto> listener) {
     mediaDrm.setOnEventListener(listener == null ? null : new MediaDrm.OnEventListener() {
       @Override
-      public void onEvent(@NonNull MediaDrm md, byte[] sessionId, int event, int extra,
+      public void onEvent(@NonNull MediaDrm md, @Nullable byte[] sessionId, int event, int extra,
           byte[] data) {
         listener.onEvent(FrameworkMediaDrm.this, sessionId, event, extra, data);
       }
@@ -73,7 +82,29 @@ public void onEvent(@NonNull MediaDrm md, byte[] sessionId, int event, int extra
   }
 
   @Override
-  public byte[] openSession() throws NotProvisionedException, ResourceBusyException {
+  public void setOnKeyStatusChangeListener(
+      final ExoMediaDrm.OnKeyStatusChangeListener<? super FrameworkMediaCrypto> listener) {
+    if (Util.SDK_INT < 23) {
+      throw new UnsupportedOperationException();
+    }
+    
+    mediaDrm.setOnKeyStatusChangeListener(listener == null ? null
+        : new MediaDrm.OnKeyStatusChangeListener() {
+          @Override
+          public void onKeyStatusChange(@NonNull MediaDrm md, @NonNull byte[] sessionId,
+              @NonNull List<MediaDrm.KeyStatus> keyInfo, boolean hasNewUsableKey) {
+            List<KeyStatus> exoKeyInfo = new ArrayList<>();
+            for (MediaDrm.KeyStatus keyStatus : keyInfo) {
+              exoKeyInfo.add(new DefaultKeyStatus(keyStatus.getStatusCode(), keyStatus.getKeyId()));
+            }
+            listener.onKeyStatusChange(FrameworkMediaDrm.this, sessionId, exoKeyInfo,
+                hasNewUsableKey);
+          }
+        }, null);
+  }
+
+  @Override
+  public byte[] openSession() throws MediaDrmException {
     return mediaDrm.openSession();
   }
 
@@ -87,17 +118,7 @@ public KeyRequest getKeyRequest(byte[] scope, byte[] init, String mimeType, int
       HashMap<String, String> optionalParameters) throws NotProvisionedException {
     final MediaDrm.KeyRequest request = mediaDrm.getKeyRequest(scope, init, mimeType, keyType,
         optionalParameters);
-    return new KeyRequest() {
-      @Override
-      public byte[] getData() {
-        return request.getData();
-      }
-
-      @Override
-      public String getDefaultUrl() {
-        return request.getDefaultUrl();
-      }
-    };
+    return new DefaultKeyRequest(request.getData(), request.getDefaultUrl());
   }
 
   @Override
@@ -108,18 +129,8 @@ public String getDefaultUrl() {
 
   @Override
   public ProvisionRequest getProvisionRequest() {
-    final MediaDrm.ProvisionRequest provisionRequest = mediaDrm.getProvisionRequest();
-    return new ProvisionRequest() {
-      @Override
-      public byte[] getData() {
-        return provisionRequest.getData();
-      }
-
-      @Override
-      public String getDefaultUrl() {
-        return provisionRequest.getDefaultUrl();
-      }
-    };
+    final MediaDrm.ProvisionRequest request = mediaDrm.getProvisionRequest();
+    return new DefaultProvisionRequest(request.getData(), request.getDefaultUrl());
   }
 
   @Override
@@ -163,8 +174,7 @@ public void setPropertyByteArray(String propertyName, byte[] value) {
   }
 
   @Override
-  public FrameworkMediaCrypto createMediaCrypto(UUID uuid, byte[] initData)
-      throws MediaCryptoException {
+  public FrameworkMediaCrypto createMediaCrypto(byte[] initData) throws MediaCryptoException {
     // Work around a bug prior to Lollipop where L1 Widevine forced into L3 mode would still
     // indicate that it required secure video decoders [Internal ref: b/11428937].
     boolean forceAllowInsecureDecoderComponents = Util.SDK_INT < 21
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/LocalMediaDrmCallback.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/LocalMediaDrmCallback.java
new file mode 100644
index 0000000000..7b9aeca30a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/LocalMediaDrmCallback.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
+import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.UUID;
+
+/**
+ * A {@link MediaDrmCallback} that provides a fixed response to key requests. Provisioning is not
+ * supported. This implementation is primarily useful for providing locally stored keys to decrypt
+ * ClearKey protected content. It is not suitable for use with Widevine or PlayReady protected
+ * content.
+ */
+public final class LocalMediaDrmCallback implements MediaDrmCallback {
+
+  private final byte[] keyResponse;
+
+  /**
+   * @param keyResponse The fixed response for all key requests.
+   */
+  public LocalMediaDrmCallback(byte[] keyResponse) {
+    this.keyResponse = Assertions.checkNotNull(keyResponse);
+  }
+
+  @Override
+  public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public byte[] executeKeyRequest(UUID uuid, KeyRequest request) throws Exception {
+    return keyResponse;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
index 62e7f5ed29..481bea66c3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.android.exoplayer2.drm;
 
 import android.media.MediaDrm;
@@ -28,8 +27,8 @@
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
 import java.util.HashMap;
+import java.util.UUID;
 
 /**
  * Helper class to download, renew and release offline licenses.
@@ -97,7 +96,8 @@
       String defaultLicenseUrl, boolean forceDefaultLicenseUrl, Factory httpDataSourceFactory,
       HashMap<String, String> optionalKeyRequestParameters)
       throws UnsupportedDrmException {
-    return new OfflineLicenseHelper<>(FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID),
+    return new OfflineLicenseHelper<>(C.WIDEVINE_UUID,
+        FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID),
         new HttpMediaDrmCallback(defaultLicenseUrl, forceDefaultLicenseUrl, httpDataSourceFactory),
         optionalKeyRequestParameters);
   }
@@ -105,6 +105,7 @@
   /**
    * Constructs an instance. Call {@link #release()} when the instance is no longer required.
    *
+   * @param uuid The UUID of the drm scheme.
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
@@ -112,7 +113,7 @@
    * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
    *     MediaDrmCallback, HashMap, Handler, EventListener)
    */
-  public OfflineLicenseHelper(ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+  public OfflineLicenseHelper(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
       HashMap<String, String> optionalKeyRequestParameters) {
     handlerThread = new HandlerThread("OfflineLicenseHelper");
     handlerThread.start();
@@ -138,7 +139,7 @@ public void onDrmKeysRemoved() {
         conditionVariable.open();
       }
     };
-    drmSessionManager = new DefaultDrmSessionManager<>(C.WIDEVINE_UUID, mediaDrm, callback,
+    drmSessionManager = new DefaultDrmSessionManager<>(uuid, mediaDrm, callback,
         optionalKeyRequestParameters, new Handler(handlerThread.getLooper()), eventListener);
   }
 
@@ -175,12 +176,9 @@ public synchronized void setPropertyString(String key, String value) {
    *
    * @param drmInitData The {@link DrmInitData} for the content whose license is to be downloaded.
    * @return The key set id for the downloaded license.
-   * @throws IOException If an error occurs reading data from the stream.
-   * @throws InterruptedException If the thread has been interrupted.
    * @throws DrmSessionException Thrown when a DRM session error occurs.
    */
-  public synchronized byte[] downloadLicense(DrmInitData drmInitData) throws IOException,
-      InterruptedException, DrmSessionException {
+  public synchronized byte[] downloadLicense(DrmInitData drmInitData) throws DrmSessionException {
     Assertions.checkArgument(drmInitData != null);
     return blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, null, drmInitData);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
index ccc5c0eb3e..87165e7a9b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
@@ -67,6 +67,7 @@
   }
 
   private @MatroskaExtractor.Flags int matroskaFlags;
+  private @Mp4Extractor.Flags int mp4Flags;
   private @FragmentedMp4Extractor.Flags int fragmentedMp4Flags;
   private @Mp3Extractor.Flags int mp3Flags;
   private @TsExtractor.Mode int tsMode;
@@ -89,6 +90,18 @@ public synchronized DefaultExtractorsFactory setMatroskaExtractorFlags(
     return this;
   }
 
+  /**
+   * Sets flags for {@link Mp4Extractor} instances created by the factory.
+   *
+   * @see Mp4Extractor#Mp4Extractor(int)
+   * @param flags The flags to use.
+   * @return The factory, for convenience.
+   */
+  public synchronized DefaultExtractorsFactory setMp4ExtractorFlags(@Mp4Extractor.Flags int flags) {
+    this.mp4Flags = flags;
+    return this;
+  }
+
   /**
    * Sets flags for {@link FragmentedMp4Extractor} instances created by the factory.
    *
@@ -145,7 +158,7 @@ public synchronized DefaultExtractorsFactory setTsExtractorFlags(
     Extractor[] extractors = new Extractor[FLAC_EXTRACTOR_CONSTRUCTOR == null ? 11 : 12];
     extractors[0] = new MatroskaExtractor(matroskaFlags);
     extractors[1] = new FragmentedMp4Extractor(fragmentedMp4Flags);
-    extractors[2] = new Mp4Extractor();
+    extractors[2] = new Mp4Extractor(mp4Flags);
     extractors[3] = new Mp3Extractor(mp3Flags);
     extractors[4] = new AdtsExtractor();
     extractors[5] = new Ac3Extractor();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
index 2f21898007..ec5ad88aeb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
@@ -18,6 +18,7 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -85,7 +86,7 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) {
+  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     if (audioFormat == AUDIO_FORMAT_MP3) {
       int sampleSize = data.bytesLeft();
       output.sampleData(data, sampleSize);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
index 8a4d314ee0..92db91e20b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
@@ -79,7 +79,8 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   @Override
   protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int packetType = data.readUnsignedByte();
-    int compositionTimeMs = data.readUnsignedInt24();
+    int compositionTimeMs = data.readInt24();
+
     timeUs += compositionTimeMs * 1000L;
     // Parse avc sequence header in case this was not done before.
     if (packetType == AVC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 6c4eb033ce..5aefd041c4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -242,7 +242,7 @@
    * The value by which to divide a time in microseconds to convert it to the unit of the last value
    * in a subrip timecode (milliseconds).
    */
-  private static long SUBRIP_TIMECODE_LAST_VALUE_SCALING_FACTOR = 1000;
+  private static final long SUBRIP_TIMECODE_LAST_VALUE_SCALING_FACTOR = 1000;
   /**
    * The format of a subrip timecode.
    */
@@ -270,7 +270,7 @@
    * The value by which to divide a time in microseconds to convert it to the unit of the last value
    * in an SSA timecode (1/100ths of a second).
    */
-  private static long SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR = 10000;
+  private static final long SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR = 10000;
   /**
    * A special end timecode indicating that an SSA subtitle should be displayed until the next
    * subtitle, or until the end of the media in the case of the last subtitle.
@@ -628,7 +628,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           if (currentTrack.cryptoData == null) {
             throw new ParserException("Encrypted Track found but ContentEncKeyID was not found");
           }
-          currentTrack.drmInitData = new DrmInitData(new SchemeData(C.UUID_NIL, null,
+          currentTrack.drmInitData = new DrmInitData(new SchemeData(C.UUID_NIL,
               MimeTypes.VIDEO_WEBM, currentTrack.cryptoData.encryptionKey));
         }
         break;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index 8d33f95640..a4349ada09 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -112,16 +112,11 @@
   private long samplesRead;
   private int sampleBytesRemaining;
 
-  /**
-   * Constructs a new {@link Mp3Extractor}.
-   */
   public Mp3Extractor() {
     this(0);
   }
 
   /**
-   * Constructs a new {@link Mp3Extractor}.
-   *
    * @param flags Flags that control the extractor's behavior.
    */
   public Mp3Extractor(@Flags int flags) {
@@ -129,8 +124,6 @@ public Mp3Extractor(@Flags int flags) {
   }
 
   /**
-   * Constructs a new {@link Mp3Extractor}.
-   *
    * @param flags Flags that control the extractor's behavior.
    * @param forcedFirstSampleTimestampUs A timestamp to force for the first sample, or
    *     {@link C#TIME_UNSET} if forcing is not required.
@@ -144,6 +137,8 @@ public Mp3Extractor(@Flags int flags, long forcedFirstSampleTimestampUs) {
     basisTimeUs = C.TIME_UNSET;
   }
 
+  // Extractor implementation.
+
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     return synchronize(input, true);
@@ -195,6 +190,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     return readSample(input);
   }
 
+  // Internal methods.
+
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
     if (sampleBytesRemaining == 0) {
       extractorInput.resetPeekPosition();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 9a03311ccf..588282bc9b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -60,11 +60,13 @@
    * @param duration The duration in units of the timescale declared in the mvhd atom, or
    *     {@link C#TIME_UNSET} if the duration should be parsed from the tkhd atom.
    * @param drmInitData {@link DrmInitData} to be included in the format.
+   * @param ignoreEditLists Whether to ignore any edit lists in the trak box.
    * @param isQuickTime True for QuickTime media. False otherwise.
    * @return A {@link Track} instance, or {@code null} if the track's type isn't supported.
    */
   public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long duration,
-      DrmInitData drmInitData, boolean isQuickTime) throws ParserException {
+      DrmInitData drmInitData, boolean ignoreEditLists, boolean isQuickTime)
+      throws ParserException {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
     int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
     if (trackType == C.TRACK_TYPE_UNKNOWN) {
@@ -88,11 +90,17 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long
     Pair<Long, String> mdhdData = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
     StsdData stsdData = parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data, tkhdData.id,
         tkhdData.rotationDegrees, mdhdData.second, drmInitData, isQuickTime);
-    Pair<long[], long[]> edtsData = parseEdts(trak.getContainerAtomOfType(Atom.TYPE_edts));
+    long[] editListDurations = null;
+    long[] editListMediaTimes = null;
+    if (!ignoreEditLists) {
+      Pair<long[], long[]> edtsData = parseEdts(trak.getContainerAtomOfType(Atom.TYPE_edts));
+      editListDurations = edtsData.first;
+      editListMediaTimes = edtsData.second;
+    }
     return stsdData.format == null ? null
         : new Track(tkhdData.id, trackType, mdhdData.first, movieTimescale, durationUs,
             stsdData.format, stsdData.requiredSampleTransformation, stsdData.trackEncryptionBoxes,
-            stsdData.nalUnitLengthFieldLength, edtsData.first, edtsData.second);
+            stsdData.nalUnitLengthFieldLength, editListDurations, editListMediaTimes);
   }
 
   /**
@@ -239,7 +247,13 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         remainingSamplesAtTimestampDelta--;
         if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
           remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
-          timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
+          // The BMFF spec (ISO 14496-12) states that sample deltas should be unsigned integers
+          // in stts boxes, however some streams violate the spec and use signed integers instead.
+          // See https://github.com/google/ExoPlayer/issues/3384. It's safe to always decode sample
+          // deltas as signed integers here, because unsigned integers will still be parsed
+          // correctly (unless their top bit is set, which is never true in practice because sample
+          // deltas are always small).
+          timestampDeltaInTimeUnits = stts.readInt();
           remainingTimestampDeltaChanges--;
         }
 
@@ -395,7 +409,11 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       hasSyncSample |= (editedFlags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0;
     }
     if (!hasSyncSample) {
-      throw new ParserException("The edited sample sequence does not contain a sync sample.");
+      // We don't support edit lists where the edited sample sequence doesn't contain a sync sample.
+      // Such edit lists are often (although not always) broken, so we ignore it and continue.
+      Log.w(TAG, "Ignoring edit list: Edited sample sequence does not contain a sync sample.");
+      Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
     }
 
     return new TrackSampleTable(editedOffsets, editedSizes, editedMaximumSize, editedTimestamps,
@@ -779,7 +797,7 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
    *
    * @param edtsAtom edts (edit box) atom to decode.
    * @return Pair of edit list durations and edit list media times, or a pair of nulls if they are
-   * not present.
+   *     not present.
    */
   private static Pair<long[], long[]> parseEdts(Atom.ContainerAtom edtsAtom) {
     Atom.LeafAtom elst;
@@ -816,7 +834,7 @@ private static float parsePaspFromParent(ParsableByteArray parent, int position)
 
   private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
       int size, int trackId, String language, boolean isQuickTime, DrmInitData drmInitData,
-      StsdData out, int entryIndex) {
+      StsdData out, int entryIndex) throws ParserException {
     parent.setPosition(position + Atom.HEADER_SIZE + StsdData.STSD_HEADER_SIZE);
 
     int quickTimeSoundDescriptionVersion = 0;
@@ -1060,8 +1078,8 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = parent.readInt();
       if (childAtomType == Atom.TYPE_sinf) {
-        Pair<Integer, TrackEncryptionBox> result = parseSinfFromParent(parent, childPosition,
-            childAtomSize);
+        Pair<Integer, TrackEncryptionBox> result = parseCommonEncryptionSinfFromParent(parent,
+            childPosition, childAtomSize);
         if (result != null) {
           return result;
         }
@@ -1071,8 +1089,8 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
     return null;
   }
 
-  private static Pair<Integer, TrackEncryptionBox> parseSinfFromParent(ParsableByteArray parent,
-      int position, int size) {
+  /* package */ static Pair<Integer, TrackEncryptionBox> parseCommonEncryptionSinfFromParent(
+      ParsableByteArray parent, int position, int size) {
     int childPosition = position + Atom.HEADER_SIZE;
     int schemeInformationBoxPosition = C.POSITION_UNSET;
     int schemeInformationBoxSize = 0;
@@ -1086,7 +1104,7 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
         dataFormat = parent.readInt();
       } else if (childAtomType == Atom.TYPE_schm) {
         parent.skipBytes(4);
-        // scheme_type field. Defined in ISO/IEC 23001-7:2016, section 4.1.
+        // Common encryption scheme_type values are defined in ISO/IEC 23001-7:2016, section 4.1.
         schemeType = parent.readString(4);
       } else if (childAtomType == Atom.TYPE_schi) {
         schemeInformationBoxPosition = childPosition;
@@ -1095,7 +1113,8 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
       childPosition += childAtomSize;
     }
 
-    if (schemeType != null) {
+    if (C.CENC_TYPE_cenc.equals(schemeType) || C.CENC_TYPE_cbc1.equals(schemeType)
+        || C.CENC_TYPE_cens.equals(schemeType) || C.CENC_TYPE_cbcs.equals(schemeType)) {
       Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
       Assertions.checkArgument(schemeInformationBoxPosition != C.POSITION_UNSET,
           "schi atom is mandatory");
@@ -1147,7 +1166,7 @@ private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent,
   }
 
   /**
-   * Parses the proj box from sv3d box, as specified by https://github.com/google/spatial-media
+   * Parses the proj box from sv3d box, as specified by https://github.com/google/spatial-media.
    */
   private static byte[] parseProjFromParent(ParsableByteArray parent, int position, int size) {
     int childPosition = position + Atom.HEADER_SIZE;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index c3f2a9fb38..867e4501fa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -74,7 +74,7 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
       FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_ENABLE_CEA608_TRACK,
-      FLAG_SIDELOADED})
+      FLAG_SIDELOADED, FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
   public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -103,6 +103,10 @@
    * container.
    */
   private static final int FLAG_SIDELOADED = 16;
+  /**
+   * Flag to ignore any edit lists in the stream.
+   */
+  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 32;
 
   private static final String TAG = "FragmentedMp4Extractor";
   private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
@@ -120,6 +124,9 @@
   @Flags private final int flags;
   private final Track sideloadedTrack;
 
+  // Manifest DRM data.
+  private final DrmInitData sideloadedDrmInitData;
+
   // Track-linked data bundle, accessible as a whole through trackID.
   private final SparseArray<TrackBundle> trackBundles;
 
@@ -179,7 +186,7 @@ public FragmentedMp4Extractor(@Flags int flags) {
    * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    */
   public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster) {
-    this(flags, timestampAdjuster, null);
+    this(flags, timestampAdjuster, null, null);
   }
 
   /**
@@ -187,12 +194,14 @@ public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjus
    * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    * @param sideloadedTrack Sideloaded track information, in the case that the extractor
    *     will not receive a moov box in the input data.
+   * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks.
    */
   public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster,
-      Track sideloadedTrack) {
+      Track sideloadedTrack, DrmInitData sideloadedDrmInitData) {
     this.flags = flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
     this.timestampAdjuster = timestampAdjuster;
     this.sideloadedTrack = sideloadedTrack;
+    this.sideloadedDrmInitData = sideloadedDrmInitData;
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalPrefix = new ParsableByteArray(5);
@@ -402,7 +411,8 @@ private void onContainerAtomRead(ContainerAtom container) throws ParserException
   private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException {
     Assertions.checkState(sideloadedTrack == null, "Unexpected moov box.");
 
-    DrmInitData drmInitData = getDrmInitDataFromAtoms(moov.leafChildren);
+    DrmInitData drmInitData = sideloadedDrmInitData != null ? sideloadedDrmInitData
+        : getDrmInitDataFromAtoms(moov.leafChildren);
 
     // Read declaration of track fragments in the Moov box.
     ContainerAtom mvex = moov.getContainerAtomOfType(Atom.TYPE_mvex);
@@ -426,7 +436,7 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
       if (atom.type == Atom.TYPE_trak) {
         Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd), duration,
-            drmInitData, false);
+            drmInitData, (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0, false);
         if (track != null) {
           tracks.put(track.id, track);
         }
@@ -456,7 +466,9 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
 
   private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException {
     parseMoof(moof, trackBundles, flags, extendedTypeScratch);
-    DrmInitData drmInitData = getDrmInitDataFromAtoms(moof.leafChildren);
+    // If drm init data is sideloaded, we ignore pssh boxes.
+    DrmInitData drmInitData = sideloadedDrmInitData != null ? null
+        : getDrmInitDataFromAtoms(moof.leafChildren);
     if (drmInitData != null) {
       int trackCount = trackBundles.size();
       for (int i = 0; i < trackCount; i++) {
@@ -1275,7 +1287,7 @@ private static DrmInitData getDrmInitDataFromAtoms(List<Atom.LeafAtom> leafChild
         if (uuid == null) {
           Log.w(TAG, "Skipped pssh atom (failed to extract uuid)");
         } else {
-          schemeDatas.add(new SchemeData(uuid, null, MimeTypes.VIDEO_MP4, psshData));
+          schemeDatas.add(new SchemeData(uuid, MimeTypes.VIDEO_MP4, psshData));
         }
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index d3fe9e0d05..f23af98e7f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -57,6 +57,17 @@
 
   };
 
+  /**
+   * Flags controlling the behavior of the extractor.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
+  public @interface Flags {}
+  /**
+   * Flag to ignore any edit lists in the stream.
+   */
+  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 1;
+
   /**
    * Parser states.
    */
@@ -76,6 +87,8 @@
    */
   private static final long RELOAD_MINIMUM_SEEK_DISTANCE = 256 * 1024;
 
+  private final @Flags int flags;
+
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
   private final ParsableByteArray nalLength;
@@ -98,7 +111,21 @@
   private long durationUs;
   private boolean isQuickTime;
 
+  /**
+   * Creates a new extractor for unfragmented MP4 streams.
+   */
   public Mp4Extractor() {
+    this(0);
+  }
+
+  /**
+   * Creates a new extractor for unfragmented MP4 streams, using the specified flags to control the
+   * extractor's behavior.
+   *
+   * @param flags Flags that control the extractor's behavior.
+   */
+  public Mp4Extractor(@Flags int flags) {
+    this.flags = flags;
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     containerAtoms = new Stack<>();
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
@@ -345,7 +372,7 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
       }
 
       Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd),
-          C.TIME_UNSET, null, isQuickTime);
+          C.TIME_UNSET, null, (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0, isQuickTime);
       if (track == null) {
         continue;
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
index 6d5c372619..55ce41e4b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.util.Log;
-import android.util.Pair;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
 import java.util.UUID;
@@ -31,22 +30,48 @@
   private PsshAtomUtil() {}
 
   /**
-   * Builds a PSSH atom for a given {@link UUID} containing the given scheme specific data.
+   * Builds a version 0 PSSH atom for a given system id, containing the given data.
    *
-   * @param uuid The UUID of the scheme.
+   * @param systemId The system id of the scheme.
    * @param data The scheme specific data.
    * @return The PSSH atom.
    */
-  public static byte[] buildPsshAtom(UUID uuid, byte[] data) {
-    int psshBoxLength = Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */ + data.length;
+  public static byte[] buildPsshAtom(UUID systemId, byte[] data) {
+    return buildPsshAtom(systemId, null, data);
+  }
+
+  /**
+   * Builds a PSSH atom for the given system id, containing the given key ids and data.
+   *
+   * @param systemId The system id of the scheme.
+   * @param keyIds The key ids for a version 1 PSSH atom, or null for a version 0 PSSH atom.
+   * @param data The scheme specific data.
+   * @return The PSSH atom.
+   */
+  public static byte[] buildPsshAtom(UUID systemId, UUID[] keyIds, byte[] data) {
+    boolean buildV1Atom = keyIds != null;
+    int dataLength = data != null ? data.length : 0;
+    int psshBoxLength = Atom.FULL_HEADER_SIZE + 16 /* SystemId */ + 4 /* DataSize */ + dataLength;
+    if (buildV1Atom) {
+      psshBoxLength += 4 /* KID_count */ + (keyIds.length * 16) /* KIDs */;
+    }
     ByteBuffer psshBox = ByteBuffer.allocate(psshBoxLength);
     psshBox.putInt(psshBoxLength);
     psshBox.putInt(Atom.TYPE_pssh);
-    psshBox.putInt(0 /* version=0, flags=0 */);
-    psshBox.putLong(uuid.getMostSignificantBits());
-    psshBox.putLong(uuid.getLeastSignificantBits());
-    psshBox.putInt(data.length);
-    psshBox.put(data);
+    psshBox.putInt(buildV1Atom ? 0x01000000 : 0 /* version=(buildV1Atom ? 1 : 0), flags=0 */);
+    psshBox.putLong(systemId.getMostSignificantBits());
+    psshBox.putLong(systemId.getLeastSignificantBits());
+    if (buildV1Atom) {
+      psshBox.putInt(keyIds.length);
+      for (UUID keyId : keyIds) {
+        psshBox.putLong(keyId.getMostSignificantBits());
+        psshBox.putLong(keyId.getLeastSignificantBits());
+      }
+    }
+    if (dataLength != 0) {
+      psshBox.putInt(data.length);
+      psshBox.put(data);
+    } // Else the last 4 bytes are a 0 DataSize.
     return psshBox.array();
   }
 
@@ -60,11 +85,28 @@ private PsshAtomUtil() {}
    *     an unsupported version.
    */
   public static UUID parseUuid(byte[] atom) {
-    Pair<UUID, byte[]> parsedAtom = parsePsshAtom(atom);
+    PsshAtom parsedAtom = parsePsshAtom(atom);
     if (parsedAtom == null) {
       return null;
     }
-    return parsedAtom.first;
+    return parsedAtom.uuid;
+  }
+
+  /**
+   * Parses the version from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
+   * <p>
+   * The version is only parsed if the data is a valid PSSH atom.
+   *
+   * @param atom The atom to parse.
+   * @return The parsed version. -1 if the input is not a valid PSSH atom, or if the PSSH atom has
+   *     an unsupported version.
+   */
+  public static int parseVersion(byte[] atom) {
+    PsshAtom parsedAtom = parsePsshAtom(atom);
+    if (parsedAtom == null) {
+      return -1;
+    }
+    return parsedAtom.version;
   }
 
   /**
@@ -79,26 +121,26 @@ public static UUID parseUuid(byte[] atom) {
    *     PSSH atom has an unsupported version, or if the PSSH atom does not match the passed UUID.
    */
   public static byte[] parseSchemeSpecificData(byte[] atom, UUID uuid) {
-    Pair<UUID, byte[]> parsedAtom = parsePsshAtom(atom);
+    PsshAtom parsedAtom = parsePsshAtom(atom);
     if (parsedAtom == null) {
       return null;
     }
-    if (uuid != null && !uuid.equals(parsedAtom.first)) {
-      Log.w(TAG, "UUID mismatch. Expected: " + uuid + ", got: " + parsedAtom.first + ".");
+    if (uuid != null && !uuid.equals(parsedAtom.uuid)) {
+      Log.w(TAG, "UUID mismatch. Expected: " + uuid + ", got: " + parsedAtom.uuid + ".");
       return null;
     }
-    return parsedAtom.second;
+    return parsedAtom.schemeData;
   }
 
   /**
-   * Parses the UUID and scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are
-   * supported.
+   * Parses a PSSH atom. Version 0 and 1 PSSH atoms are supported.
    *
    * @param atom The atom to parse.
-   * @return A pair consisting of the parsed UUID and scheme specific data. Null if the input is
-   *     not a valid PSSH atom, or if the PSSH atom has an unsupported version.
+   * @return The parsed PSSH atom. Null if the input is not a valid PSSH atom, or if the PSSH atom
+   *     has an unsupported version.
    */
-  private static Pair<UUID, byte[]> parsePsshAtom(byte[] atom) {
+  // TODO: Support parsing of the key ids for version 1 PSSH atoms.
+  private static PsshAtom parsePsshAtom(byte[] atom) {
     ParsableByteArray atomData = new ParsableByteArray(atom);
     if (atomData.limit() < Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */) {
       // Data too short.
@@ -132,7 +174,22 @@ public static UUID parseUuid(byte[] atom) {
     }
     byte[] data = new byte[dataSize];
     atomData.readBytes(data, 0, dataSize);
-    return Pair.create(uuid, data);
+    return new PsshAtom(uuid, atomVersion, data);
+  }
+
+  // TODO: Consider exposing this and making parsePsshAtom public.
+  private static class PsshAtom {
+
+    private final UUID uuid;
+    private final int version;
+    private final byte[] schemeData;
+
+    public PsshAtom(UUID uuid, int version, byte[] schemeData) {
+      this.uuid = uuid;
+      this.version = version;
+      this.schemeData = schemeData;
+    }
+
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 7ac3158794..3adc5a8972 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -81,12 +81,12 @@
   /**
    * Durations of edit list segments in the movie timescale. Null if there is no edit list.
    */
-  public final long[] editListDurations;
+  @Nullable public final long[] editListDurations;
 
   /**
    * Media times for edit list segments in the track timescale. Null if there is no edit list.
    */
-  public final long[] editListMediaTimes;
+  @Nullable public final long[] editListMediaTimes;
 
   /**
    * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. 0 for
@@ -99,7 +99,7 @@
   public Track(int id, int type, long timescale, long movieTimescale, long durationUs,
       Format format, @Transformation int sampleTransformation,
       @Nullable TrackEncryptionBox[] sampleDescriptionEncryptionBoxes, int nalUnitLengthFieldLength,
-      long[] editListDurations, long[] editListMediaTimes) {
+      @Nullable long[] editListDurations, @Nullable long[] editListMediaTimes) {
     this.id = id;
     this.type = type;
     this.timescale = timescale;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 8bab6b7ed1..4d54600c6d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -29,8 +29,7 @@
 import java.io.IOException;
 
 /**
- * Facilitates the extraction of AC-3 samples from elementary audio files formatted as AC-3
- * bitstreams.
+ * Extracts samples from (E-)AC-3 bitstreams.
  */
 public final class Ac3Extractor implements Extractor {
 
@@ -71,6 +70,8 @@ public Ac3Extractor(long firstSampleTimestampUs) {
     sampleData = new ParsableByteArray(MAX_SYNC_FRAME_SIZE);
   }
 
+  // Extractor implementation.
+
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     // Skip any ID3 headers.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index a1851aa0ea..5ce15952a5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -29,8 +29,7 @@
 import java.io.IOException;
 
 /**
- * Facilitates the extraction of AAC samples from elementary audio files formatted as AAC with ADTS
- * headers.
+ * Extracts samples from AAC bit streams with ADTS framing.
  */
 public final class AdtsExtractor implements Extractor {
 
@@ -70,6 +69,8 @@ public AdtsExtractor(long firstSampleTimestampUs) {
     packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
   }
 
+  // Extractor implementation.
+
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     // Skip any ID3 headers.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index 7277df5bb8..96b964a4c4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -19,6 +19,7 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
@@ -128,7 +129,7 @@ public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
   }
 
   @Override
-  public void consume(ParsableByteArray data) {
+  public void consume(ParsableByteArray data) throws ParserException {
     while (data.bytesLeft() > 0) {
       switch (state) {
         case STATE_FINDING_SAMPLE:
@@ -276,7 +277,7 @@ private void parseId3Header() {
   /**
    * Parses the sample header.
    */
-  private void parseAdtsHeader() {
+  private void parseAdtsHeader() throws ParserException {
     adtsScratch.setPosition(0);
 
     if (!hasOutputFormat) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 40cfd7f8d9..2d16b46895 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -28,7 +28,7 @@
 import java.util.List;
 
 /**
- * Default implementation for {@link TsPayloadReader.Factory}.
+ * Default {@link TsPayloadReader.Factory} implementation.
  */
 public final class DefaultTsPayloadReaderFactory implements TsPayloadReader.Factory {
 
@@ -94,9 +94,12 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
       case TsExtractor.TS_STREAM_TYPE_MPA:
       case TsExtractor.TS_STREAM_TYPE_MPA_LSF:
         return new PesReader(new MpegAudioReader(esInfo.language));
-      case TsExtractor.TS_STREAM_TYPE_AAC:
+      case TsExtractor.TS_STREAM_TYPE_AAC_ADTS:
         return isSet(FLAG_IGNORE_AAC_STREAM)
             ? null : new PesReader(new AdtsReader(false, esInfo.language));
+      case TsExtractor.TS_STREAM_TYPE_AAC_LATM:
+        return isSet(FLAG_IGNORE_AAC_STREAM)
+            ? null : new PesReader(new LatmReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_AC3:
       case TsExtractor.TS_STREAM_TYPE_E_AC3:
         return new PesReader(new Ac3Reader(esInfo.language));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
index 57bcf31fc5..fa7f78c8c0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -50,8 +51,9 @@
    * Consumes (possibly partial) data from the current packet.
    *
    * @param data The data to consume.
+   * @throws ParserException If the data could not be parsed.
    */
-  void consume(ParsableByteArray data);
+  void consume(ParsableByteArray data) throws ParserException;
 
   /**
    * Called when a packet ends.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
new file mode 100644
index 0000000000..d06c6f0cb4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import android.support.annotation.Nullable;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.Collections;
+
+/**
+ * Parses and extracts samples from an AAC/LATM elementary stream.
+ */
+public final class LatmReader implements ElementaryStreamReader {
+
+  private static final int STATE_FINDING_SYNC_1 = 0;
+  private static final int STATE_FINDING_SYNC_2 = 1;
+  private static final int STATE_READING_HEADER = 2;
+  private static final int STATE_READING_SAMPLE = 3;
+
+  private static final int INITIAL_BUFFER_SIZE = 1024;
+  private static final int SYNC_BYTE_FIRST = 0x56;
+  private static final int SYNC_BYTE_SECOND = 0xE0;
+
+  private final String language;
+  private final ParsableByteArray sampleDataBuffer;
+  private final ParsableBitArray sampleBitArray;
+
+  // Track output info.
+  private TrackOutput output;
+  private Format format;
+  private String formatId;
+
+  // Parser state info.
+  private int state;
+  private int bytesRead;
+  private int sampleSize;
+  private int secondHeaderByte;
+  private long timeUs;
+
+  // Container data.
+  private boolean streamMuxRead;
+  private int audioMuxVersion;
+  private int audioMuxVersionA;
+  private int numSubframes;
+  private int frameLengthType;
+  private boolean otherDataPresent;
+  private long otherDataLenBits;
+  private int sampleRateHz;
+  private long sampleDurationUs;
+  private int channelCount;
+
+  /**
+   * @param language Track language.
+   */
+  public LatmReader(@Nullable String language) {
+    this.language = language;
+    sampleDataBuffer = new ParsableByteArray(INITIAL_BUFFER_SIZE);
+    sampleBitArray = new ParsableBitArray(sampleDataBuffer.data);
+  }
+
+  @Override
+  public void seek() {
+    state = STATE_FINDING_SYNC_1;
+    streamMuxRead = false;
+  }
+
+  @Override
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    idGenerator.generateNewId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
+    formatId = idGenerator.getFormatId();
+  }
+
+  @Override
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) throws ParserException {
+    int bytesToRead;
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_SYNC_1:
+          if (data.readUnsignedByte() == SYNC_BYTE_FIRST) {
+            state = STATE_FINDING_SYNC_2;
+          }
+          break;
+        case STATE_FINDING_SYNC_2:
+          int secondByte = data.readUnsignedByte();
+          if ((secondByte & SYNC_BYTE_SECOND) == SYNC_BYTE_SECOND) {
+            secondHeaderByte = secondByte;
+            state = STATE_READING_HEADER;
+          } else if (secondByte != SYNC_BYTE_FIRST) {
+            state = STATE_FINDING_SYNC_1;
+          }
+          break;
+        case STATE_READING_HEADER:
+          sampleSize = ((secondHeaderByte & ~SYNC_BYTE_SECOND) << 8) | data.readUnsignedByte();
+          if (sampleSize > sampleDataBuffer.data.length) {
+            resetBufferForSize(sampleSize);
+          }
+          bytesRead = 0;
+          state = STATE_READING_SAMPLE;
+          break;
+        case STATE_READING_SAMPLE:
+          bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+          data.readBytes(sampleBitArray.data, bytesRead, bytesToRead);
+          bytesRead += bytesToRead;
+          if (bytesRead == sampleSize) {
+            sampleBitArray.setPosition(0);
+            parseAudioMuxElement(sampleBitArray);
+            state = STATE_FINDING_SYNC_1;
+          }
+          break;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Parses an AudioMuxElement as defined in 14496-3:2009, Section 1.7.3.1, Table 1.41.
+   *
+   * @param data A {@link ParsableBitArray} containing the AudioMuxElement's bytes.
+   */
+  private void parseAudioMuxElement(ParsableBitArray data) throws ParserException {
+    boolean useSameStreamMux = data.readBit();
+    if (!useSameStreamMux) {
+      streamMuxRead = true;
+      parseStreamMuxConfig(data);
+    } else if (!streamMuxRead) {
+      return; // Parsing cannot continue without StreamMuxConfig information.
+    }
+
+    if (audioMuxVersionA == 0) {
+      if (numSubframes != 0) {
+        throw new ParserException();
+      }
+      int muxSlotLengthBytes = parsePayloadLengthInfo(data);
+      parsePayloadMux(data, muxSlotLengthBytes);
+      if (otherDataPresent) {
+        data.skipBits((int) otherDataLenBits);
+      }
+    } else {
+      throw new ParserException(); // Not defined by ISO/IEC 14496-3:2009.
+    }
+  }
+
+  /**
+   * Parses a StreamMuxConfig as defined in ISO/IEC 14496-3:2009 Section 1.7.3.1, Table 1.42.
+   */
+  private void parseStreamMuxConfig(ParsableBitArray data) throws ParserException {
+    audioMuxVersion = data.readBits(1);
+    audioMuxVersionA = audioMuxVersion == 1 ? data.readBits(1) : 0;
+    if (audioMuxVersionA == 0) {
+      if (audioMuxVersion == 1) {
+        latmGetValue(data); // Skip taraBufferFullness.
+      }
+      if (!data.readBit()) {
+        throw new ParserException();
+      }
+      numSubframes = data.readBits(6);
+      int numProgram = data.readBits(4);
+      int numLayer = data.readBits(3);
+      if (numProgram != 0 || numLayer != 0) {
+        throw new ParserException();
+      }
+      if (audioMuxVersion == 0) {
+        int startPosition = data.getPosition();
+        int readBits = parseAudioSpecificConfig(data);
+        data.setPosition(startPosition);
+        byte[] initData = new byte[(readBits + 7) / 8];
+        data.readBits(initData, 0, readBits);
+        Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRateHz,
+            Collections.singletonList(initData), null, 0, language);
+        if (!format.equals(this.format)) {
+          this.format = format;
+          sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;
+          output.format(format);
+        }
+      } else {
+        int ascLen = (int) latmGetValue(data);
+        int bitsRead = parseAudioSpecificConfig(data);
+        data.skipBits(ascLen - bitsRead); // fillBits.
+      }
+      parseFrameLength(data);
+      otherDataPresent = data.readBit();
+      otherDataLenBits = 0;
+      if (otherDataPresent) {
+        if (audioMuxVersion == 1) {
+          otherDataLenBits = latmGetValue(data);
+        } else {
+          boolean otherDataLenEsc;
+          do {
+            otherDataLenEsc = data.readBit();
+            otherDataLenBits = (otherDataLenBits << 8) + data.readBits(8);
+          } while (otherDataLenEsc);
+        }
+      }
+      boolean crcCheckPresent = data.readBit();
+      if (crcCheckPresent) {
+        data.skipBits(8); // crcCheckSum.
+      }
+    } else {
+      throw new ParserException(); // This is not defined by ISO/IEC 14496-3:2009.
+    }
+  }
+
+  private void parseFrameLength(ParsableBitArray data) {
+    frameLengthType = data.readBits(3);
+    switch (frameLengthType) {
+      case 0:
+        data.skipBits(8); // latmBufferFullness.
+        break;
+      case 1:
+        data.skipBits(9); // frameLength.
+        break;
+      case 3:
+      case 4:
+      case 5:
+        data.skipBits(6); // CELPframeLengthTableIndex.
+        break;
+      case 6:
+      case 7:
+        data.skipBits(1); // HVXCframeLengthTableIndex.
+        break;
+    }
+  }
+
+  private int parseAudioSpecificConfig(ParsableBitArray data) throws ParserException {
+    int bitsLeft = data.bitsLeft();
+    Pair<Integer, Integer> config = CodecSpecificDataUtil.parseAacAudioSpecificConfig(data, true);
+    sampleRateHz = config.first;
+    channelCount = config.second;
+    return bitsLeft - data.bitsLeft();
+  }
+
+  private int parsePayloadLengthInfo(ParsableBitArray data) throws ParserException {
+    int muxSlotLengthBytes = 0;
+    // Assuming single program and single layer.
+    if (frameLengthType == 0) {
+      int tmp;
+      do {
+        tmp = data.readBits(8);
+        muxSlotLengthBytes += tmp;
+      } while (tmp == 255);
+      return muxSlotLengthBytes;
+    } else {
+      throw new ParserException();
+    }
+  }
+
+  private void parsePayloadMux(ParsableBitArray data, int muxLengthBytes) {
+    // The start of sample data in
+    int bitPosition = data.getPosition();
+    if ((bitPosition & 0x07) == 0) {
+      // Sample data is byte-aligned. We can output it directly.
+      sampleDataBuffer.setPosition(bitPosition >> 3);
+    } else {
+      // Sample data is not byte-aligned and we need align it ourselves before outputting.
+      // Byte alignment is needed because LATM framing is not supported by MediaCodec.
+      data.readBits(sampleDataBuffer.data, 0, muxLengthBytes * 8);
+      sampleDataBuffer.setPosition(0);
+    }
+    output.sampleData(sampleDataBuffer, muxLengthBytes);
+    output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, muxLengthBytes, 0, null);
+    timeUs += sampleDurationUs;
+  }
+
+  private void resetBufferForSize(int newSize) {
+    sampleDataBuffer.reset(newSize);
+    sampleBitArray.reset(sampleDataBuffer.data);
+  }
+
+  private static long latmGetValue(ParsableBitArray data) {
+    int bytesForValue = data.readBits(2);
+    return data.readBits((bytesForValue + 1) * 8);
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
index 59696b9dea..4863df42eb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -17,6 +17,7 @@
 
 import android.util.Log;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -77,7 +78,8 @@ public final void seek() {
   }
 
   @Override
-  public final void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+  public final void consume(ParsableByteArray data, boolean payloadUnitStartIndicator)
+      throws ParserException {
     if (payloadUnitStartIndicator) {
       switch (state) {
         case STATE_FINDING_HEADER:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index 883fb8f880..69c5745eaa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -17,6 +17,7 @@
 
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -30,7 +31,7 @@
 import java.io.IOException;
 
 /**
- * Facilitates the extraction of data from the MPEG-2 TS container format.
+ * Facilitates the extraction of data from the MPEG-2 PS container format.
  */
 public final class PsExtractor implements Extractor {
 
@@ -275,8 +276,9 @@ public void seek() {
      * Consumes the payload of a PS packet.
      *
      * @param data The PES packet. The position will be set to the start of the payload.
+     * @throws ParserException If the payload could not be parsed.
      */
-    public void consume(ParsableByteArray data) {
+    public void consume(ParsableByteArray data) throws ParserException {
       data.readBytes(pesScratch.data, 0, 3);
       pesScratch.setPosition(0);
       parseHeader();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 2929b8a076..213d30d47d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -84,7 +84,8 @@
 
   public static final int TS_STREAM_TYPE_MPA = 0x03;
   public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
-  public static final int TS_STREAM_TYPE_AAC = 0x0F;
+  public static final int TS_STREAM_TYPE_AAC_ADTS = 0x0F;
+  public static final int TS_STREAM_TYPE_AAC_LATM = 0x11;
   public static final int TS_STREAM_TYPE_AC3 = 0x81;
   public static final int TS_STREAM_TYPE_DTS = 0x8A;
   public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
@@ -262,20 +263,24 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     boolean adaptationFieldExists = (tsPacketHeader & 0x20) != 0;
     boolean payloadExists = (tsPacketHeader & 0x10) != 0;
 
+    TsPayloadReader payloadReader = payloadExists ? tsPayloadReaders.get(pid) : null;
+    if (payloadReader == null) {
+      tsPacketBuffer.setPosition(endOfPacket);
+      return RESULT_CONTINUE;
+    }
+
     // Discontinuity check.
-    boolean discontinuityFound = false;
     if (mode != MODE_HLS) {
       int continuityCounter = tsPacketHeader & 0xF;
       int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
       continuityCounters.put(pid, continuityCounter);
       if (previousCounter == continuityCounter) {
-        if (payloadExists) {
-          // Duplicate packet found.
-          tsPacketBuffer.setPosition(endOfPacket);
-          return RESULT_CONTINUE;
-        }
+        // Duplicate packet found.
+        tsPacketBuffer.setPosition(endOfPacket);
+        return RESULT_CONTINUE;
       } else if (continuityCounter != ((previousCounter + 1) & 0xF)) {
-        discontinuityFound = true;
+        // Discontinuity found.
+        payloadReader.seek();
       }
     }
 
@@ -286,17 +291,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     }
 
     // Read the payload.
-    if (payloadExists) {
-      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
-      if (payloadReader != null) {
-        if (discontinuityFound) {
-          payloadReader.seek();
-        }
-        tsPacketBuffer.setLimit(endOfPacket);
-        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
-        tsPacketBuffer.setLimit(limit);
-      }
-    }
+    tsPacketBuffer.setLimit(endOfPacket);
+    payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+    tsPacketBuffer.setLimit(limit);
 
     tsPacketBuffer.setPosition(endOfPacket);
     return RESULT_CONTINUE;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index e7996c66c3..efa764b572 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.SparseArray;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -196,7 +197,8 @@ void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
    *
    * @param data The TS packet. The position will be set to the start of the payload.
    * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
+   * @throws ParserException If the payload could not be parsed.
    */
-  void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);
+  void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) throws ParserException;
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 01229c1104..ef7d691c5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -23,6 +23,7 @@
 import android.media.MediaFormat;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import android.util.Log;
 import com.google.android.exoplayer2.BaseRenderer;
@@ -32,7 +33,6 @@
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSession;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -43,6 +43,8 @@
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
@@ -127,6 +129,10 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final long MAX_CODEC_HOTSWAP_TIME_MS = 1000;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({RECONFIGURATION_STATE_NONE, RECONFIGURATION_STATE_WRITE_PENDING,
+      RECONFIGURATION_STATE_QUEUE_PENDING})
+  private @interface ReconfigurationState {}
   /**
    * There is no pending adaptive reconfiguration work.
    */
@@ -141,6 +147,10 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int RECONFIGURATION_STATE_QUEUE_PENDING = 2;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  private @interface ReinitializationState {}
   /**
    * The codec does not need to be re-initialized.
    */
@@ -158,9 +168,26 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({ADAPTATION_WORKAROUND_MODE_NEVER, ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION,
+      ADAPTATION_WORKAROUND_MODE_ALWAYS})
+  private @interface AdaptationWorkaroundMode {}
+  /**
+   * The adaptation workaround is never used.
+   */
+  private static final int ADAPTATION_WORKAROUND_MODE_NEVER = 0;
+  /**
+   * The adaptation workaround is used when adapting between formats of the same resolution only.
+   */
+  private static final int ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION = 1;
+  /**
+   * The adaptation workaround is always used when adapting between formats.
+   */
+  private static final int ADAPTATION_WORKAROUND_MODE_ALWAYS = 2;
+
   /**
    * H.264/AVC buffer to queue when using the adaptation workaround (see
-   * {@link #codecNeedsAdaptationWorkaround(String)}. Consists of three NAL units with start codes:
+   * {@link #codecAdaptationWorkaroundMode(String)}. Consists of three NAL units with start codes:
    * Baseline sequence/picture parameter sets and a 32 * 32 pixel IDR slice. This stream can be
    * queued to force a resolution change when adapting to a new format.
    */
@@ -169,6 +196,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private static final int ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT = 32;
 
   private final MediaCodecSelector mediaCodecSelector;
+  @Nullable
   private final DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
   private final DecoderInputBuffer buffer;
@@ -182,9 +210,9 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private DrmSession<FrameworkMediaCrypto> pendingDrmSession;
   private MediaCodec codec;
   private MediaCodecInfo codecInfo;
+  private @AdaptationWorkaroundMode int codecAdaptationWorkaroundMode;
   private boolean codecNeedsDiscardToSpsWorkaround;
   private boolean codecNeedsFlushWorkaround;
-  private boolean codecNeedsAdaptationWorkaround;
   private boolean codecNeedsEosPropagationWorkaround;
   private boolean codecNeedsEosFlushWorkaround;
   private boolean codecNeedsEosOutputExceptionWorkaround;
@@ -198,8 +226,8 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private int outputIndex;
   private boolean shouldSkipOutputBuffer;
   private boolean codecReconfigured;
-  private int codecReconfigurationState;
-  private int codecReinitializationState;
+  private @ReconfigurationState int codecReconfigurationState;
+  private @ReinitializationState int codecReinitializationState;
   private boolean codecReceivedBuffers;
   private boolean codecReceivedEos;
 
@@ -223,7 +251,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    */
   public MediaCodecRenderer(int trackType, MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys) {
     super(trackType);
     Assertions.checkState(Util.SDK_INT >= 16);
@@ -247,14 +275,7 @@ public final int supportsMixedMimeTypeAdaptation() {
   @Override
   public final int supportsFormat(Format format) throws ExoPlaybackException {
     try {
-      int formatSupport = supportsFormat(mediaCodecSelector, format);
-      if ((formatSupport & FORMAT_SUPPORT_MASK) > FORMAT_UNSUPPORTED_DRM
-          && !isDrmSchemeSupported(drmSessionManager, format.drmInitData)) {
-        // The renderer advertises higher support than FORMAT_UNSUPPORTED_DRM but the DRM scheme is
-        // not supported. The format support is truncated to reflect this.
-        formatSupport = (formatSupport & ~FORMAT_SUPPORT_MASK) | FORMAT_UNSUPPORTED_DRM;
-      }
-      return formatSupport;
+      return supportsFormat(mediaCodecSelector, drmSessionManager, format);
     } catch (DecoderQueryException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
@@ -264,12 +285,14 @@ public final int supportsFormat(Format format) throws ExoPlaybackException {
    * Returns the extent to which the renderer is capable of supporting a given format.
    *
    * @param mediaCodecSelector The decoder selector.
+   * @param drmSessionManager The renderer's {@link DrmSessionManager}.
    * @param format The format.
    * @return The extent to which the renderer is capable of supporting the given format. See
    *     {@link #supportsFormat(Format)} for more detail.
    * @throws DecoderQueryException If there was an error querying decoders.
    */
-  protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector, Format format)
+  protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, Format format)
       throws DecoderQueryException;
 
   /**
@@ -355,9 +378,9 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     }
 
     String codecName = codecInfo.name;
+    codecAdaptationWorkaroundMode = codecAdaptationWorkaroundMode(codecName);
     codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, format);
     codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
-    codecNeedsAdaptationWorkaround = codecNeedsAdaptationWorkaround(codecName);
     codecNeedsEosPropagationWorkaround = codecNeedsEosPropagationWorkaround(codecName);
     codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
     codecNeedsEosOutputExceptionWorkaround = codecNeedsEosOutputExceptionWorkaround(codecName);
@@ -458,7 +481,7 @@ protected void releaseCodec() {
     codecReceivedBuffers = false;
     codecNeedsDiscardToSpsWorkaround = false;
     codecNeedsFlushWorkaround = false;
-    codecNeedsAdaptationWorkaround = false;
+    codecAdaptationWorkaroundMode = ADAPTATION_WORKAROUND_MODE_NEVER;
     codecNeedsEosPropagationWorkaround = false;
     codecNeedsEosFlushWorkaround = false;
     codecNeedsMonoChannelCountWorkaround = false;
@@ -530,7 +553,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       while (feedInputBuffer()) {}
       TraceUtil.endSection();
     } else {
-      skipSource(positionUs);
+      decoderCounters.skippedInputBufferCount += skipSource(positionUs);
       // We need to read any format changes despite not having a codec so that drmSession can be
       // updated, and so that we have the most recent format should the codec be initialized. We may
       // also reach the end of the stream. Note that readSource will not read a sample into a
@@ -802,8 +825,10 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
         && canReconfigureCodec(codec, codecInfo.adaptive, oldFormat, format)) {
       codecReconfigured = true;
       codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
-      codecNeedsAdaptationWorkaroundBuffer = codecNeedsAdaptationWorkaround
-          && format.width == oldFormat.width && format.height == oldFormat.height;
+      codecNeedsAdaptationWorkaroundBuffer =
+          codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_ALWAYS
+          || (codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
+              && format.width == oldFormat.width && format.height == oldFormat.height);
     } else {
       if (codecReceivedBuffers) {
         // Signal end of stream and wait for any final output buffers before re-initialization.
@@ -989,7 +1014,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
    */
   private void processOutputFormat() throws ExoPlaybackException {
     MediaFormat format = codec.getOutputFormat();
-    if (codecNeedsAdaptationWorkaround
+    if (codecAdaptationWorkaroundMode != ADAPTATION_WORKAROUND_MODE_NEVER
         && format.getInteger(MediaFormat.KEY_WIDTH) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
         && format.getInteger(MediaFormat.KEY_HEIGHT) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT) {
       // We assume this format changed event was caused by the adaptation workaround.
@@ -1083,25 +1108,6 @@ private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
     return false;
   }
 
-  /**
-   * Returns whether the encryption scheme is supported, or true if {@code drmInitData} is null.
-   *
-   * @param drmSessionManager The drm session manager associated with the renderer.
-   * @param drmInitData {@link DrmInitData} of the format to check for support.
-   * @return Whether the encryption scheme is supported, or true if {@code drmInitData} is null.
-   */
-  private static boolean isDrmSchemeSupported(DrmSessionManager drmSessionManager,
-      @Nullable DrmInitData drmInitData) {
-    if (drmInitData == null) {
-      // Content is unencrypted.
-      return true;
-    } else if (drmSessionManager == null) {
-      // Content is encrypted, but no drm session manager is available.
-      return false;
-    }
-    return drmSessionManager.canAcquireSession(drmInitData);
-  }
-
   /**
    * Returns whether the decoder is known to fail when flushed.
    * <p>
@@ -1122,22 +1128,31 @@ private static boolean codecNeedsFlushWorkaround(String name) {
   }
 
   /**
-   * Returns whether the decoder is known to get stuck during some adaptations where the resolution
-   * does not change.
+   * Returns a mode that specifies when the adaptation workaround should be enabled.
    * <p>
-   * If true is returned, the renderer will work around the issue by queueing and discarding a blank
-   * frame at a different resolution, which resets the codec's internal state.
+   * When enabled, the workaround queues and discards a blank frame with a resolution whose width
+   * and height both equal {@link #ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT}, to reset the codec's
+   * internal state when a format change occurs.
    * <p>
    * See [Internal: b/27807182].
+   * See <a href="https://github.com/google/ExoPlayer/issues/3257">GitHub issue #3257</a>.
    *
    * @param name The name of the decoder.
-   * @return True if the decoder is known to get stuck during some adaptations.
+   * @return The mode specifying when the adaptation workaround should be enabled.
    */
-  private static boolean codecNeedsAdaptationWorkaround(String name) {
-    return Util.SDK_INT < 24
+  private @AdaptationWorkaroundMode int codecAdaptationWorkaroundMode(String name) {
+    if (Util.SDK_INT <= 25 && "OMX.Exynos.avc.dec.secure".equals(name)
+        && (Util.MODEL.startsWith("SM-T585") || Util.MODEL.startsWith("SM-A510")
+        || Util.MODEL.startsWith("SM-A520") || Util.MODEL.startsWith("SM-J700"))) {
+      return ADAPTATION_WORKAROUND_MODE_ALWAYS;
+    } else if (Util.SDK_INT < 24
         && ("OMX.Nvidia.h264.decode".equals(name) || "OMX.Nvidia.h264.decode.secure".equals(name))
         && ("flounder".equals(Util.DEVICE) || "flounder_lte".equals(Util.DEVICE)
-        || "grouper".equals(Util.DEVICE) || "tilapia".equals(Util.DEVICE));
+        || "grouper".equals(Util.DEVICE) || "tilapia".equals(Util.DEVICE))) {
+      return ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION;
+    } else {
+      return ADAPTATION_WORKAROUND_MODE_NEVER;
+    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 904ce2f0bd..f75ce5a9e5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -283,13 +283,13 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
       return false;
     }
 
-    // Work around https://github.com/google/ExoPlayer/issues/398
+    // Work around https://github.com/google/ExoPlayer/issues/398.
     if (Util.SDK_INT < 18 && "OMX.SEC.MP3.Decoder".equals(name)) {
       return false;
     }
 
     // Work around https://github.com/google/ExoPlayer/issues/1528 and
-    // https://github.com/google/ExoPlayer/issues/3171
+    // https://github.com/google/ExoPlayer/issues/3171.
     if (Util.SDK_INT < 18 && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
         && ("a70".equals(Util.DEVICE)
             || ("Xiaomi".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith("HM")))) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataOutput.java
new file mode 100644
index 0000000000..b635cbc4b2
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataOutput.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+/**
+ * Receives metadata output.
+ */
+public interface MetadataOutput {
+
+  /**
+   * Called when there is metadata associated with current playback time.
+   *
+   * @param metadata The metadata.
+   */
+  void onMetadata(Metadata metadata);
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index 7ff426e2df..7d36d87a9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -33,27 +33,19 @@
 public final class MetadataRenderer extends BaseRenderer implements Callback {
 
   /**
-   * Receives output from a {@link MetadataRenderer}.
+   * @deprecated Use {@link MetadataOutput}.
    */
-  public interface Output {
-
-    /**
-     * Called each time there is a metadata associated with current playback time.
-     *
-     * @param metadata The metadata.
-     */
-    void onMetadata(Metadata metadata);
-
-  }
+  @Deprecated
+  public interface Output extends MetadataOutput {}
 
   private static final int MSG_INVOKE_RENDERER = 0;
   // TODO: Holding multiple pending metadata objects is temporary mitigation against
-  // https://github.com/google/ExoPlayer/issues/1874
-  // It should be removed once this issue has been addressed.
+  // https://github.com/google/ExoPlayer/issues/1874. It should be removed once this issue has been
+  // addressed.
   private static final int MAX_PENDING_METADATA_COUNT = 5;
 
   private final MetadataDecoderFactory decoderFactory;
-  private final Output output;
+  private final MetadataOutput output;
   private final Handler outputHandler;
   private final FormatHolder formatHolder;
   private final MetadataInputBuffer buffer;
@@ -73,7 +65,7 @@
    *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
    *     called directly on the player's internal rendering thread.
    */
-  public MetadataRenderer(Output output, Looper outputLooper) {
+  public MetadataRenderer(MetadataOutput output, Looper outputLooper) {
     this(output, outputLooper, MetadataDecoderFactory.DEFAULT);
   }
 
@@ -86,7 +78,7 @@ public MetadataRenderer(Output output, Looper outputLooper) {
    *     called directly on the player's internal rendering thread.
    * @param decoderFactory A factory from which to obtain {@link MetadataDecoder} instances.
    */
-  public MetadataRenderer(Output output, Looper outputLooper,
+  public MetadataRenderer(MetadataOutput output, Looper outputLooper,
       MetadataDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_METADATA);
     this.output = Assertions.checkNotNull(output);
@@ -100,7 +92,11 @@ public MetadataRenderer(Output output, Looper outputLooper,
 
   @Override
   public int supportsFormat(Format format) {
-    return decoderFactory.supportsFormat(format) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+    if (decoderFactory.supportsFormat(format)) {
+      return supportsFormatDrm(null, format.drmInitData) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_DRM;
+    } else {
+      return FORMAT_UNSUPPORTED_TYPE;
+    }
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
index d71d0863c7..939c00b9db 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
@@ -101,8 +101,8 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeByte((byte) (isOrdered ? 1 : 0));
     dest.writeStringArray(children);
     dest.writeInt(subFrames.length);
-    for (int i = 0; i < subFrames.length; i++) {
-      dest.writeParcelable(subFrames[i], 0);
+    for (Id3Frame subFrame : subFrames) {
+      dest.writeParcelable(subFrame, 0);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
index beb4cb9b88..4334fa99cb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
@@ -24,8 +24,17 @@
  */
 public final class PrivateCommand extends SpliceCommand {
 
+  /**
+   * The {@code pts_adjustment} as defined in SCTE35, Section 9.2.
+   */
   public final long ptsAdjustment;
+  /**
+   * The identifier as defined in SCTE35, Section 9.3.6.
+   */
   public final long identifier;
+  /**
+   * The private bytes as defined in SCTE35, Section 9.3.6.
+   */
   public final byte[] commandBytes;
 
   private PrivateCommand(long identifier, byte[] commandBytes, long ptsAdjustment) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
index 7ce8b47e2a..6f56d3b68c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
@@ -29,24 +29,72 @@
  */
 public final class SpliceInsertCommand extends SpliceCommand {
 
+  /**
+   * The splice event id.
+   */
   public final long spliceEventId;
+  /**
+   * True if the event with id {@link #spliceEventId} has been canceled.
+   */
   public final boolean spliceEventCancelIndicator;
+  /**
+   * If true, the splice event is an opportunity to exit from the network feed. If false, indicates
+   * an opportunity to return to the network feed.
+   */
   public final boolean outOfNetworkIndicator;
+  /**
+   * Whether the splice mode is program splice mode, whereby all PIDs/components are to be spliced.
+   * If false, splicing is done per PID/component.
+   */
   public final boolean programSpliceFlag;
+  /**
+   * Whether splicing should be done at the nearest opportunity. If false, splicing should be done
+   * at the moment indicated by {@link #programSplicePlaybackPositionUs} or
+   * {@link ComponentSplice#componentSplicePlaybackPositionUs}, depending on
+   * {@link #programSpliceFlag}.
+   */
   public final boolean spliceImmediateFlag;
+  /**
+   * If {@link #programSpliceFlag} is true, the PTS at which the program splice should occur.
+   * {@link C#TIME_UNSET} otherwise.
+   */
   public final long programSplicePts;
+  /**
+   * Equivalent to {@link #programSplicePts} but in the playback timebase.
+   */
   public final long programSplicePlaybackPositionUs;
+  /**
+   * If {@link #programSpliceFlag} is false, a non-empty list containing the
+   * {@link ComponentSplice}s. Otherwise, an empty list.
+   */
   public final List<ComponentSplice> componentSpliceList;
+  /**
+   * If {@link #breakDurationUs} is not {@link C#TIME_UNSET}, defines whether
+   * {@link #breakDurationUs} should be used to know when to return to the network feed. If
+   * {@link #breakDurationUs} is {@link C#TIME_UNSET}, the value is undefined.
+   */
   public final boolean autoReturn;
-  public final long breakDuration;
+  /**
+   * The duration of the splice in microseconds, or {@link C#TIME_UNSET} if no duration is present.
+   */
+  public final long breakDurationUs;
+  /**
+   * The unique program id as defined in SCTE35, Section 9.3.3.
+   */
   public final int uniqueProgramId;
+  /**
+   * Holds the value of {@code avail_num} as defined in SCTE35, Section 9.3.3.
+   */
   public final int availNum;
+  /**
+   * Holds the value of {@code avails_expected} as defined in SCTE35, Section 9.3.3.
+   */
   public final int availsExpected;
 
   private SpliceInsertCommand(long spliceEventId, boolean spliceEventCancelIndicator,
       boolean outOfNetworkIndicator, boolean programSpliceFlag, boolean spliceImmediateFlag,
       long programSplicePts, long programSplicePlaybackPositionUs,
-      List<ComponentSplice> componentSpliceList, boolean autoReturn, long breakDuration,
+      List<ComponentSplice> componentSpliceList, boolean autoReturn, long breakDurationUs,
       int uniqueProgramId, int availNum, int availsExpected) {
     this.spliceEventId = spliceEventId;
     this.spliceEventCancelIndicator = spliceEventCancelIndicator;
@@ -57,7 +105,7 @@ private SpliceInsertCommand(long spliceEventId, boolean spliceEventCancelIndicat
     this.programSplicePlaybackPositionUs = programSplicePlaybackPositionUs;
     this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
     this.autoReturn = autoReturn;
-    this.breakDuration = breakDuration;
+    this.breakDurationUs = breakDurationUs;
     this.uniqueProgramId = uniqueProgramId;
     this.availNum = availNum;
     this.availsExpected = availsExpected;
@@ -78,7 +126,7 @@ private SpliceInsertCommand(Parcel in) {
     }
     this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
     autoReturn = in.readByte() == 1;
-    breakDuration = in.readLong();
+    breakDurationUs = in.readLong();
     uniqueProgramId = in.readInt();
     availNum = in.readInt();
     availsExpected = in.readInt();
@@ -98,7 +146,7 @@ private SpliceInsertCommand(Parcel in) {
     int availNum = 0;
     int availsExpected = 0;
     boolean autoReturn = false;
-    long duration = C.TIME_UNSET;
+    long breakDurationUs = C.TIME_UNSET;
     if (!spliceEventCancelIndicator) {
       int headerByte = sectionData.readUnsignedByte();
       outOfNetworkIndicator = (headerByte & 0x80) != 0;
@@ -124,7 +172,8 @@ private SpliceInsertCommand(Parcel in) {
       if (durationFlag) {
         long firstByte = sectionData.readUnsignedByte();
         autoReturn = (firstByte & 0x80) != 0;
-        duration = ((firstByte & 0x01) << 32) | sectionData.readUnsignedInt();
+        long breakDuration90khz = ((firstByte & 0x01) << 32) | sectionData.readUnsignedInt();
+        breakDurationUs = breakDuration90khz * 1000 / 90;
       }
       uniqueProgramId = sectionData.readUnsignedShort();
       availNum = sectionData.readUnsignedByte();
@@ -133,7 +182,7 @@ private SpliceInsertCommand(Parcel in) {
     return new SpliceInsertCommand(spliceEventId, spliceEventCancelIndicator, outOfNetworkIndicator,
         programSpliceFlag, spliceImmediateFlag, programSplicePts,
         timestampAdjuster.adjustTsTimestamp(programSplicePts), componentSplices, autoReturn,
-        duration, uniqueProgramId, availNum, availsExpected);
+        breakDurationUs, uniqueProgramId, availNum, availsExpected);
   }
 
   /**
@@ -181,7 +230,7 @@ public void writeToParcel(Parcel dest, int flags) {
       componentSpliceList.get(i).writeToParcel(dest);
     }
     dest.writeByte((byte) (autoReturn ? 1 : 0));
-    dest.writeLong(breakDuration);
+    dest.writeLong(breakDurationUs);
     dest.writeInt(uniqueProgramId);
     dest.writeInt(availNum);
     dest.writeInt(availsExpected);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java
index 9b391cea6c..8696909c97 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java
@@ -33,22 +33,62 @@
    */
   public static final class Event {
 
+    /**
+     * The splice event id.
+     */
     public final long spliceEventId;
+    /**
+     * True if the event with id {@link #spliceEventId} has been canceled.
+     */
     public final boolean spliceEventCancelIndicator;
+    /**
+     * If true, the splice event is an opportunity to exit from the network feed. If false,
+     * indicates an opportunity to return to the network feed.
+     */
     public final boolean outOfNetworkIndicator;
+    /**
+     * Whether the splice mode is program splice mode, whereby all PIDs/components are to be
+     * spliced. If false, splicing is done per PID/component.
+     */
     public final boolean programSpliceFlag;
+    /**
+     * Represents the time of the signaled splice event as the number of seconds since 00 hours UTC,
+     * January 6th, 1980, with the count of intervening leap seconds included.
+     */
     public final long utcSpliceTime;
+    /**
+     * If {@link #programSpliceFlag} is false, a non-empty list containing the
+     * {@link ComponentSplice}s. Otherwise, an empty list.
+     */
     public final List<ComponentSplice> componentSpliceList;
+    /**
+     * If {@link #breakDurationUs} is not {@link C#TIME_UNSET}, defines whether
+     * {@link #breakDurationUs} should be used to know when to return to the network feed. If
+     * {@link #breakDurationUs} is {@link C#TIME_UNSET}, the value is undefined.
+     */
     public final boolean autoReturn;
-    public final long breakDuration;
+    /**
+     * The duration of the splice in microseconds, or {@link C#TIME_UNSET} if no duration is
+     * present.
+     */
+    public final long breakDurationUs;
+    /**
+     * The unique program id as defined in SCTE35, Section 9.3.2.
+     */
     public final int uniqueProgramId;
+    /**
+     * Holds the value of {@code avail_num} as defined in SCTE35, Section 9.3.2.
+     */
     public final int availNum;
+    /**
+     * Holds the value of {@code avails_expected} as defined in SCTE35, Section 9.3.2.
+     */
     public final int availsExpected;
 
     private Event(long spliceEventId, boolean spliceEventCancelIndicator,
         boolean outOfNetworkIndicator, boolean programSpliceFlag,
         List<ComponentSplice> componentSpliceList, long utcSpliceTime, boolean autoReturn,
-        long breakDuration, int uniqueProgramId, int availNum, int availsExpected) {
+        long breakDurationUs, int uniqueProgramId, int availNum, int availsExpected) {
       this.spliceEventId = spliceEventId;
       this.spliceEventCancelIndicator = spliceEventCancelIndicator;
       this.outOfNetworkIndicator = outOfNetworkIndicator;
@@ -56,7 +96,7 @@ private Event(long spliceEventId, boolean spliceEventCancelIndicator,
       this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
       this.utcSpliceTime = utcSpliceTime;
       this.autoReturn = autoReturn;
-      this.breakDuration = breakDuration;
+      this.breakDurationUs = breakDurationUs;
       this.uniqueProgramId = uniqueProgramId;
       this.availNum = availNum;
       this.availsExpected = availsExpected;
@@ -75,7 +115,7 @@ private Event(Parcel in) {
       this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
       this.utcSpliceTime = in.readLong();
       this.autoReturn = in.readByte() == 1;
-      this.breakDuration = in.readLong();
+      this.breakDurationUs = in.readLong();
       this.uniqueProgramId = in.readInt();
       this.availNum = in.readInt();
       this.availsExpected = in.readInt();
@@ -93,7 +133,7 @@ private static Event parseFromSection(ParsableByteArray sectionData) {
       int availNum = 0;
       int availsExpected = 0;
       boolean autoReturn = false;
-      long duration = C.TIME_UNSET;
+      long breakDurationUs = C.TIME_UNSET;
       if (!spliceEventCancelIndicator) {
         int headerByte = sectionData.readUnsignedByte();
         outOfNetworkIndicator = (headerByte & 0x80) != 0;
@@ -114,15 +154,16 @@ private static Event parseFromSection(ParsableByteArray sectionData) {
         if (durationFlag) {
           long firstByte = sectionData.readUnsignedByte();
           autoReturn = (firstByte & 0x80) != 0;
-          duration = ((firstByte & 0x01) << 32) | sectionData.readUnsignedInt();
+          long breakDuration90khz = ((firstByte & 0x01) << 32) | sectionData.readUnsignedInt();
+          breakDurationUs = breakDuration90khz * 1000 / 90;
         }
         uniqueProgramId = sectionData.readUnsignedShort();
         availNum = sectionData.readUnsignedByte();
         availsExpected = sectionData.readUnsignedByte();
       }
       return new Event(spliceEventId, spliceEventCancelIndicator, outOfNetworkIndicator,
-          programSpliceFlag, componentSplices, utcSpliceTime, autoReturn, duration, uniqueProgramId,
-          availNum, availsExpected);
+          programSpliceFlag, componentSplices, utcSpliceTime, autoReturn, breakDurationUs,
+          uniqueProgramId, availNum, availsExpected);
     }
 
     private void writeToParcel(Parcel dest) {
@@ -137,7 +178,7 @@ private void writeToParcel(Parcel dest) {
       }
       dest.writeLong(utcSpliceTime);
       dest.writeByte((byte) (autoReturn ? 1 : 0));
-      dest.writeLong(breakDuration);
+      dest.writeLong(breakDurationUs);
       dest.writeInt(uniqueProgramId);
       dest.writeInt(availNum);
       dest.writeInt(availsExpected);
@@ -173,6 +214,9 @@ private void writeToParcel(Parcel dest) {
 
   }
 
+  /**
+   * The list of scheduled events.
+   */
   public final List<Event> events;
 
   private SpliceScheduleCommand(List<Event> events) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
index f756b72d6d..e233a276ed 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
@@ -25,7 +25,13 @@
  */
 public final class TimeSignalCommand extends SpliceCommand {
 
+  /**
+   * A PTS value, as defined in SCTE35, Section 9.3.4.
+   */
   public final long ptsTime;
+  /**
+   * Equivalent to {@link #ptsTime} but in the playback timebase.
+   */
   public final long playbackPositionUs;
 
   private TimeSignalCommand(long ptsTime, long playbackPositionUs) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadException.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadException.java
new file mode 100644
index 0000000000..983727c14d
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadException.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import java.io.IOException;
+
+/** Thrown on an error during downloading. */
+public final class DownloadException extends IOException {
+
+  /** @param message The message for the exception. */
+  public DownloadException(String message) {
+    super(message);
+  }
+
+  /** @param cause The cause for the exception. */
+  public DownloadException(Throwable cause) {
+    super(cause);
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java
new file mode 100644
index 0000000000..b8d9432c63
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/Downloader.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import java.io.IOException;
+
+/**
+ * An interface for stream downloaders.
+ */
+public interface Downloader {
+
+  /**
+   * Listener notified when download progresses.
+   * <p>
+   * No guarantees are made about the thread or threads on which the listener is called, but it is
+   * guaranteed that listener methods will be called in a serial fashion (i.e. one at a time) and in
+   * the same order as events occurred.
+   */
+  interface ProgressListener {
+    /**
+     * Called during the download. Calling intervals depend on the {@link Downloader}
+     * implementation.
+     *
+     * @param downloader The reporting instance.
+     * @param downloadPercentage The download percentage. This value can be an estimation.
+     * @param downloadedBytes Total number of downloaded bytes.
+     * @see #download(ProgressListener)
+     */
+    void onDownloadProgress(Downloader downloader, float downloadPercentage, long downloadedBytes);
+  }
+
+  /**
+   * Initializes the downloader.
+   *
+   * @throws DownloadException Thrown if the media cannot be downloaded.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws IOException Thrown when there is an io error while reading from cache.
+   * @see #getDownloadedBytes()
+   * @see #getDownloadPercentage()
+   */
+  void init() throws InterruptedException, IOException;
+
+  /**
+   * Downloads the media.
+   *
+   * @param listener If not null, called during download.
+   * @throws DownloadException Thrown if the media cannot be downloaded.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws IOException Thrown when there is an io error while downloading.
+   */
+  void download(@Nullable ProgressListener listener)
+      throws InterruptedException, IOException;
+
+  /**
+   * Removes all of the downloaded data of the media.
+   *
+   * @throws InterruptedException Thrown if the thread was interrupted.
+   */
+  void remove() throws InterruptedException;
+
+  /**
+   * Returns the total number of downloaded bytes, or {@link C#LENGTH_UNSET} if it hasn't been
+   * calculated yet.
+   *
+   * @see #init()
+   */
+  long getDownloadedBytes();
+
+  /**
+   * Returns the download percentage, or {@link Float#NaN} if it can't be calculated yet. This
+   * value can be an estimation.
+   *
+   * @see #init()
+   */
+  float getDownloadPercentage();
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
new file mode 100644
index 0000000000..9ef9366397
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSource.Factory;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.FileDataSource;
+import com.google.android.exoplayer2.upstream.PriorityDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSink;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
+
+/** A helper class that holds necessary parameters for {@link Downloader} construction. */
+public final class DownloaderConstructorHelper {
+
+  private final Cache cache;
+  private final Factory upstreamDataSourceFactory;
+  private final Factory cacheReadDataSourceFactory;
+  private final DataSink.Factory cacheWriteDataSinkFactory;
+  private final PriorityTaskManager priorityTaskManager;
+
+  /**
+   * @param cache Cache instance to be used to store downloaded data.
+   * @param upstreamDataSourceFactory A {@link Factory} for downloading data.
+   */
+  public DownloaderConstructorHelper(Cache cache, Factory upstreamDataSourceFactory) {
+    this(cache, upstreamDataSourceFactory, null, null, null);
+  }
+
+  /**
+   * @param cache Cache instance to be used to store downloaded data.
+   * @param upstreamDataSourceFactory A {@link Factory} for downloading data.
+   * @param cacheReadDataSourceFactory A {@link Factory} for reading data from the cache.
+   *     If null, null is passed to {@link Downloader} constructor.
+   * @param cacheWriteDataSinkFactory A {@link DataSink.Factory} for writing data to the cache. If
+   *     null, null is passed to {@link Downloader} constructor.
+   * @param priorityTaskManager If one is given then the download priority is set lower than
+   *     loading. If null, null is passed to {@link Downloader} constructor.
+   */
+  public DownloaderConstructorHelper(Cache cache, Factory upstreamDataSourceFactory,
+      @Nullable Factory cacheReadDataSourceFactory,
+      @Nullable DataSink.Factory cacheWriteDataSinkFactory,
+      @Nullable PriorityTaskManager priorityTaskManager) {
+    Assertions.checkNotNull(upstreamDataSourceFactory);
+    this.cache = cache;
+    this.upstreamDataSourceFactory = upstreamDataSourceFactory;
+    this.cacheReadDataSourceFactory = cacheReadDataSourceFactory;
+    this.cacheWriteDataSinkFactory = cacheWriteDataSinkFactory;
+    this.priorityTaskManager = priorityTaskManager;
+  }
+
+  /** Returns the {@link Cache} instance. */
+  public Cache getCache() {
+    return cache;
+  }
+
+  /** Returns a {@link PriorityTaskManager} instance.*/
+  public PriorityTaskManager getPriorityTaskManager() {
+    // Return a dummy PriorityTaskManager if none is provided. Create a new PriorityTaskManager
+    // each time so clients don't affect each other over the dummy PriorityTaskManager instance.
+    return priorityTaskManager != null ? priorityTaskManager : new PriorityTaskManager();
+  }
+
+  /**
+   * Returns a new {@link CacheDataSource} instance. If {@code offline} is true, it can only read
+   * data from the cache.
+   */
+  public CacheDataSource buildCacheDataSource(boolean offline) {
+    DataSource cacheReadDataSource = cacheReadDataSourceFactory != null
+        ? cacheReadDataSourceFactory.createDataSource() : new FileDataSource();
+    if (offline) {
+      return new CacheDataSource(cache, DummyDataSource.INSTANCE,
+          cacheReadDataSource, null, CacheDataSource.FLAG_BLOCK_ON_CACHE, null);
+    } else {
+      DataSink cacheWriteDataSink = cacheWriteDataSinkFactory != null
+          ? cacheWriteDataSinkFactory.createDataSink()
+          : new CacheDataSink(cache, CacheDataSource.DEFAULT_MAX_CACHE_FILE_SIZE);
+      DataSource upstream = upstreamDataSourceFactory.createDataSource();
+      upstream = priorityTaskManager == null ? upstream
+          : new PriorityDataSource(upstream, priorityTaskManager, C.PRIORITY_DOWNLOAD);
+      return new CacheDataSource(cache, upstream, cacheReadDataSource,
+          cacheWriteDataSink, CacheDataSource.FLAG_BLOCK_ON_CACHE, null);
+    }
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
new file mode 100644
index 0000000000..e5aa429424
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ package com.google.android.exoplayer2.offline;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
+import java.io.IOException;
+
+/**
+ * A downloader for progressive media streams.
+ */
+public final class ProgressiveDownloader implements Downloader {
+
+  private static final int BUFFER_SIZE_BYTES = 128 * 1024;
+
+  private final DataSpec dataSpec;
+  private final Cache cache;
+  private final CacheDataSource dataSource;
+  private final PriorityTaskManager priorityTaskManager;
+  private final CacheUtil.CachingCounters cachingCounters;
+
+  /**
+   * @param uri Uri of the data to be downloaded.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
+   * @param constructorHelper a {@link DownloaderConstructorHelper} instance.
+   */
+  public ProgressiveDownloader(
+      String uri, String customCacheKey, DownloaderConstructorHelper constructorHelper) {
+    this.dataSpec = new DataSpec(Uri.parse(uri), 0, C.LENGTH_UNSET, customCacheKey, 0);
+    this.cache = constructorHelper.getCache();
+    this.dataSource = constructorHelper.buildCacheDataSource(false);
+    this.priorityTaskManager = constructorHelper.getPriorityTaskManager();
+    cachingCounters = new CachingCounters();
+  }
+
+  @Override
+  public void init() {
+    CacheUtil.getCached(dataSpec, cache, cachingCounters);
+  }
+
+  @Override
+  public void download(@Nullable ProgressListener listener) throws InterruptedException,
+      IOException {
+    priorityTaskManager.add(C.PRIORITY_DOWNLOAD);
+    try {
+      byte[] buffer = new byte[BUFFER_SIZE_BYTES];
+      CacheUtil.cache(dataSpec, cache, dataSource, buffer, priorityTaskManager, C.PRIORITY_DOWNLOAD,
+          cachingCounters, true);
+      // TODO: Work out how to call onDownloadProgress periodically during the download, or else
+      // get rid of ProgressListener and move to a model where the manager periodically polls
+      // Downloaders.
+      if (listener != null) {
+        listener.onDownloadProgress(this, 100, cachingCounters.contentLength);
+      }
+    } finally {
+      priorityTaskManager.remove(C.PRIORITY_DOWNLOAD);
+    }
+  }
+
+  @Override
+  public void remove() {
+    CacheUtil.remove(cache, CacheUtil.getKey(dataSpec));
+  }
+
+  @Override
+  public long getDownloadedBytes() {
+    return cachingCounters.totalCachedBytes();
+  }
+
+  @Override
+  public float getDownloadPercentage() {
+    long contentLength = cachingCounters.contentLength;
+    return contentLength == C.LENGTH_UNSET ? Float.NaN
+        : ((cachingCounters.totalCachedBytes() * 100f) / contentLength);
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
new file mode 100644
index 0000000000..3cb5db30ec
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.offline;
+
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Base class for multi segment stream downloaders.
+ *
+ * <p>All of the methods are blocking. Also they are not thread safe, except {@link
+ * #getTotalSegments()}, {@link #getDownloadedSegments()} and {@link #getDownloadedBytes()}.
+ *
+ * @param <M> The type of the manifest object.
+ * @param <K> The type of the representation key object.
+ */
+public abstract class SegmentDownloader<M, K> implements Downloader {
+
+  /** Smallest unit of content to be downloaded. */
+  protected static class Segment implements Comparable<Segment> {
+    /** The start time of the segment in microseconds. */
+    public final long startTimeUs;
+
+    /** The {@link DataSpec} of the segment. */
+    public final DataSpec dataSpec;
+
+    /** Constructs a Segment. */
+    public Segment(long startTimeUs, DataSpec dataSpec) {
+      this.startTimeUs = startTimeUs;
+      this.dataSpec = dataSpec;
+    }
+
+    @Override
+    public int compareTo(@NonNull Segment other) {
+      long startOffsetDiff = startTimeUs - other.startTimeUs;
+      return startOffsetDiff == 0 ? 0 : ((startOffsetDiff < 0) ? -1 : 1);
+    }
+  }
+
+  private static final int BUFFER_SIZE_BYTES = 128 * 1024;
+
+  private final Uri manifestUri;
+  private final PriorityTaskManager priorityTaskManager;
+  private final Cache cache;
+  private final CacheDataSource dataSource;
+  private final CacheDataSource offlineDataSource;
+
+  private M manifest;
+  private K[] keys;
+  private volatile int totalSegments;
+  private volatile int downloadedSegments;
+  private volatile long downloadedBytes;
+
+  /**
+   * @param manifestUri The {@link Uri} of the manifest to be downloaded.
+   * @param constructorHelper a {@link DownloaderConstructorHelper} instance.
+   */
+  public SegmentDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHelper) {
+    this.manifestUri = manifestUri;
+    this.cache = constructorHelper.getCache();
+    this.dataSource = constructorHelper.buildCacheDataSource(false);
+    this.offlineDataSource = constructorHelper.buildCacheDataSource(true);
+    this.priorityTaskManager = constructorHelper.getPriorityTaskManager();
+    resetCounters();
+  }
+
+  /**
+   * Returns the manifest. Downloads and parses it if necessary.
+   *
+   * @return The manifest.
+   * @throws IOException If an error occurs reading data.
+   */
+  public final M getManifest() throws IOException {
+    return getManifestIfNeeded(false);
+  }
+
+  /**
+   * Selects multiple representations pointed to by the keys for downloading, checking status. Any
+   * previous selection is cleared. If keys are null or empty, all representations are downloaded.
+   */
+  public final void selectRepresentations(K[] keys) {
+    this.keys = keys != null ? keys.clone() : null;
+    resetCounters();
+  }
+
+  /**
+   * Initializes the total segments, downloaded segments and downloaded bytes counters for the
+   * selected representations.
+   *
+   * @throws IOException Thrown when there is an io error while reading from cache.
+   * @throws DownloadException Thrown if the media cannot be downloaded.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @see #getTotalSegments()
+   * @see #getDownloadedSegments()
+   * @see #getDownloadedBytes()
+   */
+  @Override
+  public final void init() throws InterruptedException, IOException {
+    try {
+      getManifestIfNeeded(true);
+    } catch (IOException e) {
+      // Either the manifest file isn't available offline or not parsable.
+      return;
+    }
+    try {
+      initStatus(true);
+    } catch (IOException | InterruptedException e) {
+      resetCounters();
+      throw e;
+    }
+  }
+
+  /**
+   * Downloads the content for the selected representations in sync or resumes a previously stopped
+   * download.
+   *
+   * @param listener If not null, called during download.
+   * @throws IOException Thrown when there is an io error while downloading.
+   * @throws DownloadException Thrown if the media cannot be downloaded.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  @Override
+  public final synchronized void download(@Nullable ProgressListener listener)
+      throws IOException, InterruptedException {
+    priorityTaskManager.add(C.PRIORITY_DOWNLOAD);
+    try {
+      getManifestIfNeeded(false);
+      List<Segment> segments = initStatus(false);
+      notifyListener(listener); // Initial notification.
+      Collections.sort(segments);
+      byte[] buffer = new byte[BUFFER_SIZE_BYTES];
+      CachingCounters cachingCounters = new CachingCounters();
+      for (int i = 0; i < segments.size(); i++) {
+        CacheUtil.cache(segments.get(i).dataSpec, cache, dataSource, buffer,
+            priorityTaskManager, C.PRIORITY_DOWNLOAD, cachingCounters, true);
+        downloadedBytes += cachingCounters.newlyCachedBytes;
+        downloadedSegments++;
+        notifyListener(listener);
+      }
+    } finally {
+      priorityTaskManager.remove(C.PRIORITY_DOWNLOAD);
+    }
+  }
+
+  /**
+   * Returns the total number of segments in the representations which are selected, or {@link
+   * C#LENGTH_UNSET} if it hasn't been calculated yet.
+   *
+   * @see #init()
+   */
+  public final int getTotalSegments() {
+    return totalSegments;
+  }
+
+  /**
+   * Returns the total number of downloaded segments in the representations which are selected, or
+   * {@link C#LENGTH_UNSET} if it hasn't been calculated yet.
+   *
+   * @see #init()
+   */
+  public final int getDownloadedSegments() {
+    return downloadedSegments;
+  }
+
+  /**
+   * Returns the total number of downloaded bytes in the representations which are selected, or
+   * {@link C#LENGTH_UNSET} if it hasn't been calculated yet.
+   *
+   * @see #init()
+   */
+  @Override
+  public final long getDownloadedBytes() {
+    return downloadedBytes;
+  }
+
+  @Override
+  public float getDownloadPercentage() {
+    // Take local snapshot of the volatile fields
+    int totalSegments = this.totalSegments;
+    int downloadedSegments = this.downloadedSegments;
+    if (totalSegments == C.LENGTH_UNSET || downloadedSegments == C.LENGTH_UNSET) {
+      return Float.NaN;
+    }
+    return totalSegments == 0 ? 100f : (downloadedSegments * 100f) / totalSegments;
+  }
+
+  @Override
+  public final void remove() throws InterruptedException {
+    try {
+      getManifestIfNeeded(true);
+    } catch (IOException e) {
+      // Either the manifest file isn't available offline, or it's not parsable. Continue anyway to
+      // reset the counters and attempt to remove the manifest file.
+    }
+    resetCounters();
+    if (manifest != null) {
+      List<Segment> segments = null;
+      try {
+        segments = getAllSegments(offlineDataSource, manifest, true);
+      } catch (IOException e) {
+        // Ignore exceptions. We do our best with what's available offline.
+      }
+      if (segments != null) {
+        for (int i = 0; i < segments.size(); i++) {
+          remove(segments.get(i).dataSpec.uri);
+        }
+      }
+      manifest = null;
+    }
+    remove(manifestUri);
+  }
+
+  /**
+   * Loads and parses the manifest.
+   *
+   * @param dataSource The {@link DataSource} through which to load.
+   * @param uri The manifest uri.
+   * @return The manifest.
+   * @throws IOException If an error occurs reading data.
+   */
+  protected abstract M getManifest(DataSource dataSource, Uri uri) throws IOException;
+
+  /**
+   * Returns a list of {@link Segment}s for given keys.
+   *
+   * @param dataSource The {@link DataSource} through which to load any required data.
+   * @param manifest The manifest containing the segments.
+   * @param keys The selected representation keys.
+   * @param allowIncompleteIndex Whether to continue in the case that a load error prevents all
+   *     segments from being listed. If true then a partial segment list will be returned. If false
+   *     an {@link IOException} will be thrown.
+   * @throws InterruptedException Thrown if the thread was interrupted.
+   * @throws IOException Thrown if {@code allowPartialIndex} is false and a load error occurs, or if
+   *     the media is not in a form that allows for its segments to be listed.
+   * @return A list of {@link Segment}s for given keys.
+   */
+  protected abstract List<Segment> getSegments(DataSource dataSource, M manifest, K[] keys,
+      boolean allowIncompleteIndex) throws InterruptedException, IOException;
+
+  /**
+   * Returns a list of all segments.
+   *
+   * @see #getSegments(DataSource, M, Object[], boolean)
+   */
+  protected abstract List<Segment> getAllSegments(DataSource dataSource, M manifest,
+      boolean allowPartialIndex) throws InterruptedException, IOException;
+
+  private void resetCounters() {
+    totalSegments = C.LENGTH_UNSET;
+    downloadedSegments = C.LENGTH_UNSET;
+    downloadedBytes = C.LENGTH_UNSET;
+  }
+
+  private void remove(Uri uri) {
+    CacheUtil.remove(cache, CacheUtil.generateKey(uri));
+  }
+
+  private void notifyListener(ProgressListener listener) {
+    if (listener != null) {
+      listener.onDownloadProgress(this, getDownloadPercentage(), downloadedBytes);
+    }
+  }
+
+  /**
+   * Initializes totalSegments, downloadedSegments and downloadedBytes for selected representations.
+   * If not offline then downloads missing metadata.
+   *
+   * @return A list of not fully downloaded segments.
+   */
+  private synchronized List<Segment> initStatus(boolean offline)
+      throws IOException, InterruptedException {
+    DataSource dataSource = getDataSource(offline);
+    List<Segment> segments = keys != null && keys.length > 0
+        ? getSegments(dataSource, manifest, keys, offline)
+        : getAllSegments(dataSource, manifest, offline);
+    CachingCounters cachingCounters = new CachingCounters();
+    totalSegments = segments.size();
+    downloadedSegments = 0;
+    downloadedBytes = 0;
+    for (int i = segments.size() - 1; i >= 0; i--) {
+      Segment segment = segments.get(i);
+      CacheUtil.getCached(segment.dataSpec, cache, cachingCounters);
+      downloadedBytes += cachingCounters.alreadyCachedBytes;
+      if (cachingCounters.alreadyCachedBytes == cachingCounters.contentLength) {
+        // The segment is fully downloaded.
+        downloadedSegments++;
+        segments.remove(i);
+      }
+    }
+    return segments;
+  }
+
+  private M getManifestIfNeeded(boolean offline) throws IOException {
+    if (manifest == null) {
+      manifest = getManifest(getDataSource(offline), manifestUri);
+    }
+    return manifest;
+  }
+
+  private DataSource getDataSource(boolean offline) {
+    return offline ? offlineDataSource : dataSource;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
index 42ac938677..35234753b0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -26,50 +26,112 @@
 /* package */ abstract class AbstractConcatenatedTimeline extends Timeline {
 
   private final int childCount;
+  private final ShuffleOrder shuffleOrder;
 
-  public AbstractConcatenatedTimeline(int childCount) {
-    this.childCount = childCount;
+  /**
+   * Sets up a concatenated timeline with a shuffle order of child timelines.
+   *
+   * @param shuffleOrder A shuffle order of child timelines. The number of child timelines must
+   *     match the number of elements in the shuffle order.
+   */
+  public AbstractConcatenatedTimeline(ShuffleOrder shuffleOrder) {
+    this.shuffleOrder = shuffleOrder;
+    this.childCount = shuffleOrder.getLength();
   }
 
   @Override
-  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
+  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled) {
+    // Find next window within current child.
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
     int nextWindowIndexInChild = getTimelineByChildIndex(childIndex).getNextWindowIndex(
         windowIndex - firstWindowIndexInChild,
-        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode);
+        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
+        shuffleModeEnabled);
     if (nextWindowIndexInChild != C.INDEX_UNSET) {
       return firstWindowIndexInChild + nextWindowIndexInChild;
-    } else {
-      int nextChildIndex = childIndex + 1;
-      if (nextChildIndex < childCount) {
-        return getFirstWindowIndexByChildIndex(nextChildIndex);
-      } else if (repeatMode == Player.REPEAT_MODE_ALL) {
-        return 0;
-      } else {
-        return C.INDEX_UNSET;
-      }
     }
+    // If not found, find first window of next non-empty child.
+    int nextChildIndex = getNextChildIndex(childIndex, shuffleModeEnabled);
+    while (nextChildIndex != C.INDEX_UNSET && getTimelineByChildIndex(nextChildIndex).isEmpty()) {
+      nextChildIndex = getNextChildIndex(nextChildIndex, shuffleModeEnabled);
+    }
+    if (nextChildIndex != C.INDEX_UNSET) {
+      return getFirstWindowIndexByChildIndex(nextChildIndex)
+          + getTimelineByChildIndex(nextChildIndex).getFirstWindowIndex(shuffleModeEnabled);
+    }
+    // If not found, this is the last window.
+    if (repeatMode == Player.REPEAT_MODE_ALL) {
+      return getFirstWindowIndex(shuffleModeEnabled);
+    }
+    return C.INDEX_UNSET;
   }
 
   @Override
-  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
+  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled) {
+    // Find previous window within current child.
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
     int previousWindowIndexInChild = getTimelineByChildIndex(childIndex).getPreviousWindowIndex(
         windowIndex - firstWindowIndexInChild,
-        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode);
+        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
+        shuffleModeEnabled);
     if (previousWindowIndexInChild != C.INDEX_UNSET) {
       return firstWindowIndexInChild + previousWindowIndexInChild;
-    } else {
-      if (firstWindowIndexInChild > 0) {
-        return firstWindowIndexInChild - 1;
-      } else if (repeatMode == Player.REPEAT_MODE_ALL) {
-        return getWindowCount() - 1;
-      } else {
+    }
+    // If not found, find last window of previous non-empty child.
+    int previousChildIndex = getPreviousChildIndex(childIndex, shuffleModeEnabled);
+    while (previousChildIndex != C.INDEX_UNSET
+        && getTimelineByChildIndex(previousChildIndex).isEmpty()) {
+      previousChildIndex = getPreviousChildIndex(previousChildIndex, shuffleModeEnabled);
+    }
+    if (previousChildIndex != C.INDEX_UNSET) {
+      return getFirstWindowIndexByChildIndex(previousChildIndex)
+          + getTimelineByChildIndex(previousChildIndex).getLastWindowIndex(shuffleModeEnabled);
+    }
+    // If not found, this is the first window.
+    if (repeatMode == Player.REPEAT_MODE_ALL) {
+      return getLastWindowIndex(shuffleModeEnabled);
+    }
+    return C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getLastWindowIndex(boolean shuffleModeEnabled) {
+    if (childCount == 0) {
+      return C.INDEX_UNSET;
+    }
+    // Find last non-empty child.
+    int lastChildIndex = shuffleModeEnabled ? shuffleOrder.getLastIndex() : childCount - 1;
+    while (getTimelineByChildIndex(lastChildIndex).isEmpty()) {
+      lastChildIndex = getPreviousChildIndex(lastChildIndex, shuffleModeEnabled);
+      if (lastChildIndex == C.INDEX_UNSET) {
+        // All children are empty.
+        return C.INDEX_UNSET;
+      }
+    }
+    return getFirstWindowIndexByChildIndex(lastChildIndex)
+        + getTimelineByChildIndex(lastChildIndex).getLastWindowIndex(shuffleModeEnabled);
+  }
+
+  @Override
+  public int getFirstWindowIndex(boolean shuffleModeEnabled) {
+    if (childCount == 0) {
+      return C.INDEX_UNSET;
+    }
+    // Find first non-empty child.
+    int firstChildIndex = shuffleModeEnabled ? shuffleOrder.getFirstIndex() : 0;
+    while (getTimelineByChildIndex(firstChildIndex).isEmpty()) {
+      firstChildIndex = getNextChildIndex(firstChildIndex, shuffleModeEnabled);
+      if (firstChildIndex == C.INDEX_UNSET) {
+        // All children are empty.
         return C.INDEX_UNSET;
       }
     }
+    return getFirstWindowIndexByChildIndex(firstChildIndex)
+        + getTimelineByChildIndex(firstChildIndex).getFirstWindowIndex(shuffleModeEnabled);
   }
 
   @Override
@@ -167,4 +229,14 @@ public final int getIndexOfPeriod(Object uid) {
    */
   protected abstract Object getChildUidByChildIndex(int childIndex);
 
+  private int getNextChildIndex(int childIndex, boolean shuffleModeEnabled) {
+    return shuffleModeEnabled ? shuffleOrder.getNextIndex(childIndex)
+        : childIndex < childCount - 1 ? childIndex + 1 : C.INDEX_UNSET;
+  }
+
+  private int getPreviousChildIndex(int childIndex, boolean shuffleModeEnabled) {
+    return shuffleModeEnabled ? shuffleOrder.getPreviousIndex(childIndex)
+        : childIndex > 0 ? childIndex - 1 : C.INDEX_UNSET;
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
index f97d4a1542..be07cbb5dc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
@@ -19,6 +19,7 @@
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -111,6 +112,13 @@ void onLoadCanceled(DataSpec dataSpec, int dataType, int trackType, Format track
    * The error may or may not have resulted in the load being canceled, as indicated by the
    * {@code wasCanceled} parameter. If the load was canceled, {@link #onLoadCanceled} will
    * <em>not</em> be called in addition to this method.
+   * <p>
+   * This method being called does not indicate that playback has failed, or that it will fail. The
+   * player may be able to recover from the error and continue. Hence applications should
+   * <em>not</em> implement this method to display a user visible error or initiate an application
+   * level retry ({@link Player.EventListener#onPlayerError} is the appropriate place to implement
+   * such behavior). This method is called to provide the application with an opportunity to log the
+   * error if it wishes to do so.
    *
    * @param dataSpec Defines the data being loaded.
    * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
index 12f58d9a21..89af07a3f0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -270,7 +270,14 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         return C.RESULT_BUFFER_READ;
       }
       int result = stream.readData(formatHolder, buffer, requireFormat);
-      // TODO: Clear gapless playback metadata if a format was read (if applicable).
+      if (result == C.RESULT_FORMAT_READ) {
+        // Clear gapless playback metadata if the start/end points don't match the media.
+        Format format = formatHolder.format;
+        int encoderDelay = startUs != 0 ? 0 : format.encoderDelay;
+        int encoderPadding = endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
+        formatHolder.format = format.copyWithGaplessInfo(encoderDelay, encoderPadding);
+        return C.RESULT_FORMAT_READ;
+      }
       if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
           && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
           && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
@@ -286,8 +293,8 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
     }
 
     @Override
-    public void skipData(long positionUs) {
-      stream.skipData(startUs + positionUs);
+    public int skipData(long positionUs) {
+      return stream.skipData(startUs + positionUs);
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index 8be6bf028f..c6924e844a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -17,7 +17,6 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Player.RepeatMode;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
@@ -38,7 +37,6 @@
   private final ArrayList<ClippingMediaPeriod> mediaPeriods;
 
   private MediaSource.Listener sourceListener;
-  private ClippingTimeline clippingTimeline;
 
   /**
    * Creates a new clipping source that wraps the specified source.
@@ -99,7 +97,7 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     ClippingMediaPeriod mediaPeriod = new ClippingMediaPeriod(
         mediaSource.createPeriod(id, allocator), enableInitialDiscontinuity);
     mediaPeriods.add(mediaPeriod);
-    mediaPeriod.setClipping(clippingTimeline.startUs, clippingTimeline.endUs);
+    mediaPeriod.setClipping(startUs, endUs);
     return mediaPeriod;
   }
 
@@ -117,12 +115,9 @@ public void releaseSource() {
   // MediaSource.Listener implementation.
 
   @Override
-  public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
-    clippingTimeline = new ClippingTimeline(timeline, startUs, endUs);
-    sourceListener.onSourceInfoRefreshed(clippingTimeline, manifest);
-    long startUs = clippingTimeline.startUs;
-    long endUs = clippingTimeline.endUs == C.TIME_UNSET ? C.TIME_END_OF_SOURCE
-        : clippingTimeline.endUs;
+  public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
+    sourceListener.onSourceInfoRefreshed(this, new ClippingTimeline(timeline, startUs, endUs),
+        manifest);
     int count = mediaPeriods.size();
     for (int i = 0; i < count; i++) {
       mediaPeriods.get(i).setClipping(startUs, endUs);
@@ -132,9 +127,8 @@ public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
   /**
    * Provides a clipped view of a specified timeline.
    */
-  private static final class ClippingTimeline extends Timeline {
+  private static final class ClippingTimeline extends ForwardingTimeline {
 
-    private final Timeline timeline;
     private final long startUs;
     private final long endUs;
 
@@ -147,6 +141,7 @@ public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
      *     of {@code timeline}, or {@link C#TIME_END_OF_SOURCE} to clip no samples from the end.
      */
     public ClippingTimeline(Timeline timeline, long startUs, long endUs) {
+      super(timeline);
       Assertions.checkArgument(timeline.getWindowCount() == 1);
       Assertions.checkArgument(timeline.getPeriodCount() == 1);
       Window window = timeline.getWindow(0, new Window(), false);
@@ -161,26 +156,10 @@ public ClippingTimeline(Timeline timeline, long startUs, long endUs) {
       }
       Period period = timeline.getPeriod(0, new Period());
       Assertions.checkArgument(period.getPositionInWindowUs() == 0);
-      this.timeline = timeline;
       this.startUs = startUs;
       this.endUs = resolvedEndUs;
     }
 
-    @Override
-    public int getWindowCount() {
-      return 1;
-    }
-
-    @Override
-    public int getNextWindowIndex(int windowIndex, @RepeatMode int repeatMode) {
-      return timeline.getNextWindowIndex(windowIndex, repeatMode);
-    }
-
-    @Override
-    public int getPreviousWindowIndex(int windowIndex, @RepeatMode int repeatMode) {
-      return timeline.getPreviousWindowIndex(windowIndex, repeatMode);
-    }
-
     @Override
     public Window getWindow(int windowIndex, Window window, boolean setIds,
         long defaultPositionProjectionUs) {
@@ -202,11 +181,6 @@ public Window getWindow(int windowIndex, Window window, boolean setIds,
       return window;
     }
 
-    @Override
-    public int getPeriodCount() {
-      return 1;
-    }
-
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       period = timeline.getPeriod(0, period, setIds);
@@ -214,11 +188,6 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       return period;
     }
 
-    @Override
-    public int getIndexOfPeriod(Object uid) {
-      return timeline.getIndexOfPeriod(uid);
-    }
-
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
index 343d4f0bbe..a85d589762 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
@@ -63,7 +63,11 @@ public final boolean continueLoading(long positionUs) {
         break;
       }
       for (SequenceableLoader loader : loaders) {
-        if (loader.getNextLoadPositionUs() == nextLoadPositionUs) {
+        long loaderNextLoadPositionUs = loader.getNextLoadPositionUs();
+        boolean isLoaderBehind =
+            loaderNextLoadPositionUs != C.TIME_END_OF_SOURCE
+                && loaderNextLoadPositionUs <= positionUs;
+        if (loaderNextLoadPositionUs == nextLoadPositionUs || isLoaderBehind) {
           madeProgressThisIteration |= loader.continueLoading(positionUs);
         }
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 5d2bbcc33e..058471f31f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -38,7 +39,8 @@
   private final Object[] manifests;
   private final Map<MediaPeriod, Integer> sourceIndexByMediaPeriod;
   private final boolean[] duplicateFlags;
-  private final boolean isRepeatOneAtomic;
+  private final boolean isAtomic;
+  private final ShuffleOrder shuffleOrder;
 
   private Listener listener;
   private ConcatenatedTimeline timeline;
@@ -52,17 +54,33 @@ public ConcatenatingMediaSource(MediaSource... mediaSources) {
   }
 
   /**
-   * @param isRepeatOneAtomic Whether the concatenated media source shall be treated as atomic
-   *     (i.e., repeated in its entirety) when repeat mode is set to {@code Player.REPEAT_MODE_ONE}.
+   * @param isAtomic Whether the concatenated media source shall be treated as atomic,
+   *     i.e., treated as a single item for repeating and shuffling.
    * @param mediaSources The {@link MediaSource}s to concatenate. It is valid for the same
    *     {@link MediaSource} instance to be present more than once in the array.
    */
-  public ConcatenatingMediaSource(boolean isRepeatOneAtomic, MediaSource... mediaSources) {
+  public ConcatenatingMediaSource(boolean isAtomic, MediaSource... mediaSources) {
+    this(isAtomic, new DefaultShuffleOrder(mediaSources.length), mediaSources);
+  }
+
+  /**
+   * @param isAtomic Whether the concatenated media source shall be treated as atomic,
+   *     i.e., treated as a single item for repeating and shuffling.
+   * @param shuffleOrder The {@link ShuffleOrder} to use when shuffling the child media sources. The
+   *     number of elements in the shuffle order must match the number of concatenated
+   *     {@link MediaSource}s.
+   * @param mediaSources The {@link MediaSource}s to concatenate. It is valid for the same
+   *     {@link MediaSource} instance to be present more than once in the array.
+   */
+  public ConcatenatingMediaSource(boolean isAtomic, ShuffleOrder shuffleOrder,
+      MediaSource... mediaSources) {
     for (MediaSource mediaSource : mediaSources) {
       Assertions.checkNotNull(mediaSource);
     }
+    Assertions.checkArgument(shuffleOrder.getLength() == mediaSources.length);
     this.mediaSources = mediaSources;
-    this.isRepeatOneAtomic = isRepeatOneAtomic;
+    this.isAtomic = isAtomic;
+    this.shuffleOrder = shuffleOrder;
     timelines = new Timeline[mediaSources.length];
     manifests = new Object[mediaSources.length];
     sourceIndexByMediaPeriod = new HashMap<>();
@@ -72,15 +90,20 @@ public ConcatenatingMediaSource(boolean isRepeatOneAtomic, MediaSource... mediaS
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     this.listener = listener;
-    for (int i = 0; i < mediaSources.length; i++) {
-      if (!duplicateFlags[i]) {
-        final int index = i;
-        mediaSources[i].prepareSource(player, false, new Listener() {
-          @Override
-          public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
-            handleSourceInfoRefreshed(index, timeline, manifest);
-          }
-        });
+    if (mediaSources.length == 0) {
+      listener.onSourceInfoRefreshed(this, Timeline.EMPTY, null);
+    } else {
+      for (int i = 0; i < mediaSources.length; i++) {
+        if (!duplicateFlags[i]) {
+          final int index = i;
+          mediaSources[i].prepareSource(player, false, new Listener() {
+            @Override
+            public void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
+                Object manifest) {
+              handleSourceInfoRefreshed(index, timeline, manifest);
+            }
+          });
+        }
       }
     }
   }
@@ -97,8 +120,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     int sourceIndex = timeline.getChildIndexByPeriodIndex(id.periodIndex);
-    MediaPeriodId periodIdInSource =
-        new MediaPeriodId(id.periodIndex - timeline.getFirstPeriodIndexByChildIndex(sourceIndex));
+    MediaPeriodId periodIdInSource = id.copyWithPeriodIndex(
+        id.periodIndex - timeline.getFirstPeriodIndexByChildIndex(sourceIndex));
     MediaPeriod mediaPeriod = mediaSources[sourceIndex].createPeriod(periodIdInSource, allocator);
     sourceIndexByMediaPeriod.put(mediaPeriod, sourceIndex);
     return mediaPeriod;
@@ -138,8 +161,8 @@ private void handleSourceInfoRefreshed(int sourceFirstIndex, Timeline sourceTime
         return;
       }
     }
-    timeline = new ConcatenatedTimeline(timelines.clone(), isRepeatOneAtomic);
-    listener.onSourceInfoRefreshed(timeline, manifests.clone());
+    timeline = new ConcatenatedTimeline(timelines.clone(), isAtomic, shuffleOrder);
+    listener.onSourceInfoRefreshed(this, timeline, manifests.clone());
   }
 
   private static boolean[] buildDuplicateFlags(MediaSource[] mediaSources) {
@@ -164,10 +187,10 @@ private void handleSourceInfoRefreshed(int sourceFirstIndex, Timeline sourceTime
     private final Timeline[] timelines;
     private final int[] sourcePeriodOffsets;
     private final int[] sourceWindowOffsets;
-    private final boolean isRepeatOneAtomic;
+    private final boolean isAtomic;
 
-    public ConcatenatedTimeline(Timeline[] timelines, boolean isRepeatOneAtomic) {
-      super(timelines.length);
+    public ConcatenatedTimeline(Timeline[] timelines, boolean isAtomic, ShuffleOrder shuffleOrder) {
+      super(shuffleOrder);
       int[] sourcePeriodOffsets = new int[timelines.length];
       int[] sourceWindowOffsets = new int[timelines.length];
       long periodCount = 0;
@@ -184,7 +207,7 @@ public ConcatenatedTimeline(Timeline[] timelines, boolean isRepeatOneAtomic) {
       this.timelines = timelines;
       this.sourcePeriodOffsets = sourcePeriodOffsets;
       this.sourceWindowOffsets = sourceWindowOffsets;
-      this.isRepeatOneAtomic = isRepeatOneAtomic;
+      this.isAtomic = isAtomic;
     }
 
     @Override
@@ -198,29 +221,41 @@ public int getPeriodCount() {
     }
 
     @Override
-    public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
-      if (isRepeatOneAtomic && repeatMode == Player.REPEAT_MODE_ONE) {
+    public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+        boolean shuffleModeEnabled) {
+      if (isAtomic && repeatMode == Player.REPEAT_MODE_ONE) {
         repeatMode = Player.REPEAT_MODE_ALL;
       }
-      return super.getNextWindowIndex(windowIndex, repeatMode);
+      return super.getNextWindowIndex(windowIndex, repeatMode, !isAtomic && shuffleModeEnabled);
     }
 
     @Override
-    public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
-      if (isRepeatOneAtomic && repeatMode == Player.REPEAT_MODE_ONE) {
+    public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+        boolean shuffleModeEnabled) {
+      if (isAtomic && repeatMode == Player.REPEAT_MODE_ONE) {
         repeatMode = Player.REPEAT_MODE_ALL;
       }
-      return super.getPreviousWindowIndex(windowIndex, repeatMode);
+      return super.getPreviousWindowIndex(windowIndex, repeatMode, !isAtomic && shuffleModeEnabled);
+    }
+
+    @Override
+    public int getLastWindowIndex(boolean shuffleModeEnabled) {
+      return super.getLastWindowIndex(!isAtomic && shuffleModeEnabled);
+    }
+
+    @Override
+    public int getFirstWindowIndex(boolean shuffleModeEnabled) {
+      return super.getFirstWindowIndex(!isAtomic && shuffleModeEnabled);
     }
 
     @Override
     protected int getChildIndexByPeriodIndex(int periodIndex) {
-      return Util.binarySearchFloor(sourcePeriodOffsets, periodIndex, true, false) + 1;
+      return Util.binarySearchFloor(sourcePeriodOffsets, periodIndex + 1, false, false) + 1;
     }
 
     @Override
     protected int getChildIndexByWindowIndex(int windowIndex) {
-      return Util.binarySearchFloor(sourceWindowOffsets, windowIndex, true, false) + 1;
+      return Util.binarySearchFloor(sourceWindowOffsets, windowIndex + 1, false, false) + 1;
     }
 
     @Override
@@ -254,3 +289,4 @@ protected Object getChildUidByChildIndex(int childIndex) {
   }
 
 }
+
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java
index b00732e839..e80abad3ef 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.util.Pair;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -23,6 +26,7 @@
 import com.google.android.exoplayer2.ExoPlayer.ExoPlayerComponent;
 import com.google.android.exoplayer2.ExoPlayer.ExoPlayerMessage;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
@@ -45,6 +49,7 @@
   private static final int MSG_ADD_MULTIPLE = 1;
   private static final int MSG_REMOVE = 2;
   private static final int MSG_MOVE = 3;
+  private static final int MSG_ON_COMPLETION = 4;
 
   // Accessed on the app thread.
   private final List<MediaSource> mediaSourcesPublic;
@@ -57,11 +62,26 @@
 
   private ExoPlayer player;
   private Listener listener;
+  private ShuffleOrder shuffleOrder;
   private boolean preventListenerNotification;
   private int windowCount;
   private int periodCount;
 
+  /**
+   * Creates a new dynamic concatenating media source.
+   */
   public DynamicConcatenatingMediaSource() {
+    this(new DefaultShuffleOrder(0));
+  }
+
+  /**
+   * Creates a new dynamic concatenating media source with a custom shuffle order.
+   *
+   * @param shuffleOrder The {@link ShuffleOrder} to use when shuffling the child media sources.
+   *     This shuffle order must be empty.
+   */
+  public DynamicConcatenatingMediaSource(ShuffleOrder shuffleOrder) {
+    this.shuffleOrder = shuffleOrder;
     this.mediaSourceByMediaPeriod = new IdentityHashMap<>();
     this.mediaSourcesPublic = new ArrayList<>();
     this.mediaSourceHolders = new ArrayList<>();
@@ -71,41 +91,105 @@ public DynamicConcatenatingMediaSource() {
 
   /**
    * Appends a {@link MediaSource} to the playlist.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
    *
    * @param mediaSource The {@link MediaSource} to be added to the list.
    */
   public synchronized void addMediaSource(MediaSource mediaSource) {
-    addMediaSource(mediaSourcesPublic.size(), mediaSource);
+    addMediaSource(mediaSourcesPublic.size(), mediaSource, null);
+  }
+
+  /**
+   * Appends a {@link MediaSource} to the playlist and executes a custom action on completion.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
+   *
+   * @param mediaSource The {@link MediaSource} to be added to the list.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     source has been added to the playlist.
+   */
+  public synchronized void addMediaSource(MediaSource mediaSource,
+      @Nullable Runnable actionOnCompletion) {
+    addMediaSource(mediaSourcesPublic.size(), mediaSource, actionOnCompletion);
   }
 
   /**
    * Adds a {@link MediaSource} to the playlist.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
    *
    * @param index The index at which the new {@link MediaSource} will be inserted. This index must
    *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param mediaSource The {@link MediaSource} to be added to the list.
    */
   public synchronized void addMediaSource(int index, MediaSource mediaSource) {
+    addMediaSource(index, mediaSource, null);
+  }
+
+  /**
+   * Adds a {@link MediaSource} to the playlist and executes a custom action on completion.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
+   *
+   * @param index The index at which the new {@link MediaSource} will be inserted. This index must
+   *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @param mediaSource The {@link MediaSource} to be added to the list.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     source has been added to the playlist.
+   */
+  public synchronized void addMediaSource(int index, MediaSource mediaSource,
+      @Nullable Runnable actionOnCompletion) {
     Assertions.checkNotNull(mediaSource);
     Assertions.checkArgument(!mediaSourcesPublic.contains(mediaSource));
     mediaSourcesPublic.add(index, mediaSource);
     if (player != null) {
-      player.sendMessages(new ExoPlayerMessage(this, MSG_ADD, Pair.create(index, mediaSource)));
+      player.sendMessages(new ExoPlayerMessage(this, MSG_ADD,
+          new MessageData<>(index, mediaSource, actionOnCompletion)));
+    } else if (actionOnCompletion != null) {
+      actionOnCompletion.run();
     }
   }
 
   /**
    * Appends multiple {@link MediaSource}s to the playlist.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
    *
    * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
    *     sources are added in the order in which they appear in this collection.
    */
   public synchronized void addMediaSources(Collection<MediaSource> mediaSources) {
-    addMediaSources(mediaSourcesPublic.size(), mediaSources);
+    addMediaSources(mediaSourcesPublic.size(), mediaSources, null);
+  }
+
+  /**
+   * Appends multiple {@link MediaSource}s to the playlist and executes a custom action on
+   * completion.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
+   *
+   * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
+   *     sources are added in the order in which they appear in this collection.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     sources have been added to the playlist.
+   */
+  public synchronized void addMediaSources(Collection<MediaSource> mediaSources,
+      @Nullable Runnable actionOnCompletion) {
+    addMediaSources(mediaSourcesPublic.size(), mediaSources, actionOnCompletion);
   }
 
   /**
    * Adds multiple {@link MediaSource}s to the playlist.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
    *
    * @param index The index at which the new {@link MediaSource}s will be inserted. This index must
    *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
@@ -113,6 +197,24 @@ public synchronized void addMediaSources(Collection<MediaSource> mediaSources) {
    *     sources are added in the order in which they appear in this collection.
    */
   public synchronized void addMediaSources(int index, Collection<MediaSource> mediaSources) {
+    addMediaSources(index, mediaSources, null);
+  }
+
+  /**
+   * Adds multiple {@link MediaSource}s to the playlist and executes a custom action on completion.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used. If you want to add the same
+   * piece of media multiple times, use a new instance each time.
+   *
+   * @param index The index at which the new {@link MediaSource}s will be inserted. This index must
+   *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
+   *     sources are added in the order in which they appear in this collection.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     sources have been added to the playlist.
+   */
+  public synchronized void addMediaSources(int index, Collection<MediaSource> mediaSources,
+      @Nullable Runnable actionOnCompletion) {
     for (MediaSource mediaSource : mediaSources) {
       Assertions.checkNotNull(mediaSource);
       Assertions.checkArgument(!mediaSourcesPublic.contains(mediaSource));
@@ -120,20 +222,45 @@ public synchronized void addMediaSources(int index, Collection<MediaSource> medi
     mediaSourcesPublic.addAll(index, mediaSources);
     if (player != null && !mediaSources.isEmpty()) {
       player.sendMessages(new ExoPlayerMessage(this, MSG_ADD_MULTIPLE,
-          Pair.create(index, mediaSources)));
+          new MessageData<>(index, mediaSources, actionOnCompletion)));
+    } else if (actionOnCompletion != null){
+      actionOnCompletion.run();
     }
   }
 
   /**
    * Removes a {@link MediaSource} from the playlist.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used, and so the instance being
+   * removed should not be re-added. If you want to move the instance use
+   * {@link #moveMediaSource(int, int)} instead.
    *
    * @param index The index at which the media source will be removed. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
   public synchronized void removeMediaSource(int index) {
+    removeMediaSource(index, null);
+  }
+
+  /**
+   * Removes a {@link MediaSource} from the playlist and executes a custom action on completion.
+   * <p>
+   * Note: {@link MediaSource} instances are not designed to be re-used, and so the instance being
+   * removed should not be re-added. If you want to move the instance use
+   * {@link #moveMediaSource(int, int)} instead.
+   *
+   * @param index The index at which the media source will be removed. This index must be in the
+   *     range of 0 &lt;= index &lt; {@link #getSize()}.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     source has been removed from the playlist.
+   */
+  public synchronized void removeMediaSource(int index, @Nullable Runnable actionOnCompletion) {
     mediaSourcesPublic.remove(index);
     if (player != null) {
-      player.sendMessages(new ExoPlayerMessage(this, MSG_REMOVE, index));
+      player.sendMessages(new ExoPlayerMessage(this, MSG_REMOVE,
+          new MessageData<>(index, null, actionOnCompletion)));
+    } else if (actionOnCompletion != null) {
+      actionOnCompletion.run();
     }
   }
 
@@ -146,13 +273,31 @@ public synchronized void removeMediaSource(int index) {
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
   public synchronized void moveMediaSource(int currentIndex, int newIndex) {
+    moveMediaSource(currentIndex, newIndex, null);
+  }
+
+  /**
+   * Moves an existing {@link MediaSource} within the playlist and executes a custom action on
+   * completion.
+   *
+   * @param currentIndex The current index of the media source in the playlist. This index must be
+   *     in the range of 0 &lt;= index &lt; {@link #getSize()}.
+   * @param newIndex The target index of the media source in the playlist. This index must be in the
+   *     range of 0 &lt;= index &lt; {@link #getSize()}.
+   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   *     source has been moved.
+   */
+  public synchronized void moveMediaSource(int currentIndex, int newIndex,
+      @Nullable Runnable actionOnCompletion) {
     if (currentIndex == newIndex) {
       return;
     }
     mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
     if (player != null) {
       player.sendMessages(new ExoPlayerMessage(this, MSG_MOVE,
-          Pair.create(currentIndex, newIndex)));
+          new MessageData<>(currentIndex, newIndex, actionOnCompletion)));
+    } else if (actionOnCompletion != null) {
+      actionOnCompletion.run();
     }
   }
 
@@ -166,7 +311,7 @@ public synchronized int getSize() {
   /**
    * Returns the {@link MediaSource} at a specified index.
    *
-   * @param index A index in the range of 0 &lt;= index &lt;= {@link #getSize()}.
+   * @param index An index in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @return The {@link MediaSource} at this index.
    */
   public synchronized MediaSource getMediaSource(int index) {
@@ -179,15 +324,16 @@ public synchronized void prepareSource(ExoPlayer player, boolean isTopLevelSourc
     this.player = player;
     this.listener = listener;
     preventListenerNotification = true;
+    shuffleOrder = shuffleOrder.cloneAndInsert(0, mediaSourcesPublic.size());
     addMediaSourcesInternal(0, mediaSourcesPublic);
     preventListenerNotification = false;
-    maybeNotifyListener();
+    maybeNotifyListener(null);
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    for (MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
-      mediaSourceHolder.mediaSource.maybeThrowSourceInfoRefreshError();
+    for (int i = 0; i < mediaSourceHolders.size(); i++) {
+      mediaSourceHolders.get(i).mediaSource.maybeThrowSourceInfoRefreshError();
     }
   }
 
@@ -195,7 +341,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     int mediaSourceHolderIndex = findMediaSourceHolderByPeriodIndex(id.periodIndex);
     MediaSourceHolder holder = mediaSourceHolders.get(mediaSourceHolderIndex);
-    MediaPeriodId idInSource = new MediaPeriodId(id.periodIndex - holder.firstPeriodIndexInChild);
+    MediaPeriodId idInSource = id.copyWithPeriodIndex(
+        id.periodIndex - holder.firstPeriodIndexInChild);
     MediaPeriod mediaPeriod;
     if (!holder.isPrepared) {
       mediaPeriod = new DeferredMediaPeriod(holder.mediaSource, idInSource, allocator);
@@ -221,34 +368,50 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    for (MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
-      mediaSourceHolder.mediaSource.releaseSource();
+    for (int i = 0; i < mediaSourceHolders.size(); i++) {
+      mediaSourceHolders.get(i).mediaSource.releaseSource();
     }
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    if (messageType == MSG_ON_COMPLETION) {
+      ((EventDispatcher) message).dispatchEvent();
+      return;
+    }
     preventListenerNotification = true;
+    EventDispatcher actionOnCompletion;
     switch (messageType) {
       case MSG_ADD: {
-        Pair<Integer, MediaSource> messageData = (Pair<Integer, MediaSource>) message;
-        addMediaSourceInternal(messageData.first, messageData.second);
+        MessageData<MediaSource> messageData = (MessageData<MediaSource>) message;
+        shuffleOrder = shuffleOrder.cloneAndInsert(messageData.index, 1);
+        addMediaSourceInternal(messageData.index, messageData.customData);
+        actionOnCompletion = messageData.actionOnCompletion;
         break;
       }
       case MSG_ADD_MULTIPLE: {
-        Pair<Integer, Collection<MediaSource>> messageData =
-            (Pair<Integer, Collection<MediaSource>>) message;
-        addMediaSourcesInternal(messageData.first, messageData.second);
+        MessageData<Collection<MediaSource>> messageData =
+            (MessageData<Collection<MediaSource>>) message;
+        shuffleOrder = shuffleOrder.cloneAndInsert(messageData.index,
+            messageData.customData.size());
+        addMediaSourcesInternal(messageData.index, messageData.customData);
+        actionOnCompletion = messageData.actionOnCompletion;
         break;
       }
       case MSG_REMOVE: {
-        removeMediaSourceInternal((Integer) message);
+        MessageData<Void> messageData = (MessageData<Void>) message;
+        shuffleOrder = shuffleOrder.cloneAndRemove(messageData.index);
+        removeMediaSourceInternal(messageData.index);
+        actionOnCompletion = messageData.actionOnCompletion;
         break;
       }
       case MSG_MOVE: {
-        Pair<Integer, Integer> messageData = (Pair<Integer, Integer>) message;
-        moveMediaSourceInternal(messageData.first, messageData.second);
+        MessageData<Integer> messageData = (MessageData<Integer>) message;
+        shuffleOrder = shuffleOrder.cloneAndRemove(messageData.index);
+        shuffleOrder = shuffleOrder.cloneAndInsert(messageData.customData, 1);
+        moveMediaSourceInternal(messageData.index, messageData.customData);
+        actionOnCompletion = messageData.actionOnCompletion;
         break;
       }
       default: {
@@ -256,13 +419,18 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
       }
     }
     preventListenerNotification = false;
-    maybeNotifyListener();
+    maybeNotifyListener(actionOnCompletion);
   }
 
-  private void maybeNotifyListener() {
+  private void maybeNotifyListener(@Nullable EventDispatcher actionOnCompletion) {
     if (!preventListenerNotification) {
-      listener.onSourceInfoRefreshed(
-          new ConcatenatedTimeline(mediaSourceHolders, windowCount, periodCount), null);
+      listener.onSourceInfoRefreshed(this,
+          new ConcatenatedTimeline(mediaSourceHolders, windowCount, periodCount, shuffleOrder),
+          null);
+      if (actionOnCompletion != null) {
+        player.sendMessages(
+            new ExoPlayerMessage(this, MSG_ON_COMPLETION, actionOnCompletion));
+      }
     }
   }
 
@@ -283,7 +451,7 @@ private void addMediaSourceInternal(int newIndex, MediaSource newMediaSource) {
     mediaSourceHolders.add(newIndex, newMediaSourceHolder);
     newMediaSourceHolder.mediaSource.prepareSource(player, false, new Listener() {
       @Override
-      public void onSourceInfoRefreshed(Timeline newTimeline, Object manifest) {
+      public void onSourceInfoRefreshed(MediaSource source, Timeline newTimeline, Object manifest) {
         updateMediaSourceInternal(newMediaSourceHolder, newTimeline);
       }
     });
@@ -319,7 +487,7 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
       }
     }
     mediaSourceHolder.isPrepared = true;
-    maybeNotifyListener();
+    maybeNotifyListener(null);
   }
 
   private void removeMediaSourceInternal(int index) {
@@ -357,9 +525,19 @@ private void correctOffsets(int startIndex, int windowOffsetUpdate, int periodOf
   private int findMediaSourceHolderByPeriodIndex(int periodIndex) {
     query.firstPeriodIndexInChild = periodIndex;
     int index = Collections.binarySearch(mediaSourceHolders, query);
-    return index >= 0 ? index : -index - 2;
+    if (index < 0) {
+      return -index - 2;
+    }
+    while (index < mediaSourceHolders.size() - 1
+        && mediaSourceHolders.get(index + 1).firstPeriodIndexInChild == periodIndex) {
+      index++;
+    }
+    return index;
   }
 
+  /**
+   * Data class to hold playlist media sources together with meta data needed to process them.
+   */
   private static final class MediaSourceHolder implements Comparable<MediaSourceHolder> {
 
     public final MediaSource mediaSource;
@@ -380,11 +558,52 @@ public MediaSourceHolder(MediaSource mediaSource, DeferredTimeline timeline, int
     }
 
     @Override
-    public int compareTo(MediaSourceHolder other) {
+    public int compareTo(@NonNull MediaSourceHolder other) {
       return this.firstPeriodIndexInChild - other.firstPeriodIndexInChild;
     }
   }
 
+  /**
+   * Can be used to dispatch a runnable on the thread the object was created on.
+   */
+  private static final class EventDispatcher {
+
+    public final Handler eventHandler;
+    public final Runnable runnable;
+
+    public EventDispatcher(Runnable runnable) {
+      this.runnable = runnable;
+      this.eventHandler = new Handler(Looper.myLooper() != null ? Looper.myLooper()
+          : Looper.getMainLooper());
+    }
+
+    public void dispatchEvent() {
+      eventHandler.post(runnable);
+    }
+
+  }
+
+  /**
+   * Message used to post actions from app thread to playback thread.
+   */
+  private static final class MessageData<CustomType> {
+
+    public final int index;
+    public final CustomType customData;
+    public final @Nullable EventDispatcher actionOnCompletion;
+
+    public MessageData(int index, CustomType customData, @Nullable Runnable actionOnCompletion) {
+      this.index = index;
+      this.actionOnCompletion = actionOnCompletion != null
+          ? new EventDispatcher(actionOnCompletion) : null;
+      this.customData = customData;
+    }
+
+  }
+
+  /**
+   * Timeline exposing concatenated timelines of playlist media sources.
+   */
   private static final class ConcatenatedTimeline extends AbstractConcatenatedTimeline {
 
     private final int windowCount;
@@ -396,8 +615,8 @@ public int compareTo(MediaSourceHolder other) {
     private final SparseIntArray childIndexByUid;
 
     public ConcatenatedTimeline(Collection<MediaSourceHolder> mediaSourceHolders, int windowCount,
-        int periodCount) {
-      super(mediaSourceHolders.size());
+        int periodCount, ShuffleOrder shuffleOrder) {
+      super(shuffleOrder);
       this.windowCount = windowCount;
       this.periodCount = periodCount;
       int childCount = mediaSourceHolders.size();
@@ -418,12 +637,12 @@ public ConcatenatedTimeline(Collection<MediaSourceHolder> mediaSourceHolders, in
 
     @Override
     protected int getChildIndexByPeriodIndex(int periodIndex) {
-      return Util.binarySearchFloor(firstPeriodInChildIndices, periodIndex, true, false);
+      return Util.binarySearchFloor(firstPeriodInChildIndices, periodIndex + 1, false, false);
     }
 
     @Override
     protected int getChildIndexByWindowIndex(int windowIndex) {
-      return Util.binarySearchFloor(firstWindowInChildIndices, windowIndex, true, false);
+      return Util.binarySearchFloor(firstWindowInChildIndices, windowIndex + 1, false, false);
     }
 
     @Override
@@ -467,6 +686,10 @@ public int getPeriodCount() {
 
   }
 
+  /**
+   * Timeline used as placeholder for an unprepared media source. After preparation, a copy of the
+   * DeferredTimeline is used to keep the originally assigned first period ID.
+   */
   private static final class DeferredTimeline extends Timeline {
 
     private static final Object DUMMY_ID = new Object();
@@ -535,6 +758,11 @@ public int getIndexOfPeriod(Object uid) {
 
   }
 
+  /**
+   * Media period used for periods created from unprepared media sources exposed through
+   * {@link DeferredTimeline}. Period preparation is postponed until the actual media source becomes
+   * available.
+   */
   private static final class DeferredMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
 
     public final MediaSource mediaSource;
@@ -637,3 +865,4 @@ public void onPrepared(MediaPeriod mediaPeriod) {
   }
 
 }
+
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java
index 7aab22d8a0..299b816cc8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java
@@ -43,8 +43,8 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
   }
 
   @Override
-  public void skipData(long positionUs) {
-    // Do nothing.
+  public int skipData(long positionUs) {
+    return 0;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index e7273f834b..1228061cde 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -93,6 +93,7 @@
   private int[] sampleQueueTrackIds;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
+  private int actualMinLoadableRetryCount;
 
   private boolean seenFirstTrackSelection;
   private boolean notifyDiscontinuity;
@@ -160,6 +161,11 @@ public void run() {
     sampleQueues = new SampleQueue[0];
     pendingResetPositionUs = C.TIME_UNSET;
     length = C.LENGTH_UNSET;
+    // Assume on-demand for MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, until prepared.
+    actualMinLoadableRetryCount =
+        minLoadableRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA
+        ? ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND
+        : minLoadableRetryCount;
   }
 
   public void release() {
@@ -238,7 +244,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
           // sample queue, or if we haven't read anything from the queue since the previous seek
           // (this case is common for sparse tracks such as metadata tracks). In all other cases a
           // seek is required.
-          seekRequired = !sampleQueue.advanceTo(positionUs, true, true)
+          seekRequired = sampleQueue.advanceTo(positionUs, true, true) == SampleQueue.ADVANCE_FAILED
               && sampleQueue.getReadIndex() != 0;
         }
       }
@@ -355,31 +361,39 @@ public long seekToUs(long positionUs) {
   // SampleStream methods.
 
   /* package */ boolean isReady(int track) {
-    return loadingFinished || (!isPendingReset() && sampleQueues[track].hasNextSample());
+    return !suppressRead() && (loadingFinished || sampleQueues[track].hasNextSample());
   }
 
   /* package */ void maybeThrowError() throws IOException {
-    loader.maybeThrowError();
+    loader.maybeThrowError(actualMinLoadableRetryCount);
   }
 
   /* package */ int readData(int track, FormatHolder formatHolder, DecoderInputBuffer buffer,
       boolean formatRequired) {
-    if (notifyDiscontinuity || isPendingReset()) {
+    if (suppressRead()) {
       return C.RESULT_NOTHING_READ;
     }
     return sampleQueues[track].read(formatHolder, buffer, formatRequired, loadingFinished,
         lastSeekPositionUs);
   }
 
-  /* package */ void skipData(int track, long positionUs) {
+  /* package */ int skipData(int track, long positionUs) {
+    if (suppressRead()) {
+      return 0;
+    }
     SampleQueue sampleQueue = sampleQueues[track];
     if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
-      sampleQueue.advanceToEnd();
+      return sampleQueue.advanceToEnd();
     } else {
-      sampleQueue.advanceTo(positionUs, true, true);
+      int skipCount = sampleQueue.advanceTo(positionUs, true, true);
+      return skipCount == SampleQueue.ADVANCE_FAILED ? 0 : skipCount;
     }
   }
 
+  private boolean suppressRead() {
+    return notifyDiscontinuity || isPendingReset();
+  }
+
   // Loader.Callback implementation.
 
   @Override
@@ -490,6 +504,10 @@ private void maybeFinishPrepare() {
       haveAudioVideoTracks |= isAudioVideo;
     }
     tracks = new TrackGroupArray(trackArray);
+    if (minLoadableRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA
+        && length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET) {
+      actualMinLoadableRetryCount = ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE;
+    }
     prepared = true;
     listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
     callback.onPrepared(this);
@@ -515,16 +533,7 @@ private void startLoading() {
       pendingResetPositionUs = C.TIME_UNSET;
     }
     extractedSamplesCountAtStartOfLoad = getExtractedSamplesCount();
-
-    int minRetryCount = minLoadableRetryCount;
-    if (minRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA) {
-      // We assume on-demand before we're prepared.
-      minRetryCount = !prepared || length != C.LENGTH_UNSET
-          || (seekMap != null && seekMap.getDurationUs() != C.TIME_UNSET)
-          ? ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND
-          : ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE;
-    }
-    loader.startLoading(loadable, this, minRetryCount);
+    loader.startLoading(loadable, this, actualMinLoadableRetryCount);
   }
 
   private void configureRetry(ExtractingLoadable loadable) {
@@ -558,7 +567,8 @@ private boolean seekInsideBufferUs(long positionUs) {
     for (int i = 0; i < trackCount; i++) {
       SampleQueue sampleQueue = sampleQueues[i];
       sampleQueue.rewind();
-      boolean seekInsideQueue = sampleQueue.advanceTo(positionUs, true, false);
+      boolean seekInsideQueue = sampleQueue.advanceTo(positionUs, true, false)
+          != SampleQueue.ADVANCE_FAILED;
       // If we have AV tracks then an in-buffer seek is successful if the seek into every AV queue
       // is successful. We ignore whether seeks within non-AV queues are successful in this case, as
       // they may be sparse or poorly interleaved. If we only have non-AV tracks then a seek is
@@ -632,8 +642,8 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
     }
 
     @Override
-    public void skipData(long positionUs) {
-      ExtractorMediaPeriod.this.skipData(track, positionUs);
+    public int skipData(long positionUs) {
+      return ExtractorMediaPeriod.this.skipData(track, positionUs);
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 51e9757165..1b3f6cb95c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -19,7 +19,7 @@
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
@@ -48,6 +48,13 @@
 
     /**
      * Called when an error occurs loading media data.
+     * <p>
+     * This method being called does not indicate that playback has failed, or that it will fail.
+     * The player may be able to recover from the error and continue. Hence applications should
+     * <em>not</em> implement this method to display a user visible error or initiate an application
+     * level retry ({@link Player.EventListener#onPlayerError} is the appropriate place to implement
+     * such behavior). This method is called to provide the application with an opportunity to log
+     * the error if it wishes to do so.
      *
      * @param error The load error.
      */
@@ -84,7 +91,6 @@
   private final int minLoadableRetryCount;
   private final Handler eventHandler;
   private final EventListener eventListener;
-  private final Timeline.Period period;
   private final String customCacheKey;
   private final int continueLoadingCheckIntervalBytes;
 
@@ -149,7 +155,6 @@ public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
     this.eventListener = eventListener;
     this.customCacheKey = customCacheKey;
     this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
-    period = new Timeline.Period();
   }
 
   @Override
@@ -187,8 +192,7 @@ public void releaseSource() {
   public void onSourceInfoRefreshed(long durationUs, boolean isSeekable) {
     // If we already have the duration from a previous source info refresh, use it.
     durationUs = durationUs == C.TIME_UNSET ? timelineDurationUs : durationUs;
-    if (timelineDurationUs == durationUs && timelineIsSeekable == isSeekable
-        || (timelineDurationUs != C.TIME_UNSET && durationUs == C.TIME_UNSET)) {
+    if (timelineDurationUs == durationUs && timelineIsSeekable == isSeekable) {
       // Suppress no-op source info changes.
       return;
     }
@@ -201,7 +205,7 @@ private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
     timelineDurationUs = durationUs;
     timelineIsSeekable = isSeekable;
     sourceListener.onSourceInfoRefreshed(
-        new SinglePeriodTimeline(timelineDurationUs, timelineIsSeekable), null);
+        this, new SinglePeriodTimeline(timelineDurationUs, timelineIsSeekable), null);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
new file mode 100644
index 0000000000..cfa5cec387
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+
+/**
+ * An overridable {@link Timeline} implementation forwarding all methods to another timeline.
+ */
+public abstract class ForwardingTimeline extends Timeline {
+
+  protected final Timeline timeline;
+
+  public ForwardingTimeline(Timeline timeline) {
+    this.timeline = timeline;
+  }
+
+  @Override
+  public int getWindowCount() {
+    return timeline.getWindowCount();
+  }
+
+  @Override
+  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled) {
+    return timeline.getNextWindowIndex(windowIndex, repeatMode, shuffleModeEnabled);
+  }
+
+  @Override
+  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled) {
+    return timeline.getPreviousWindowIndex(windowIndex, repeatMode, shuffleModeEnabled);
+  }
+
+  @Override
+  public int getLastWindowIndex(boolean shuffleModeEnabled) {
+    return timeline.getLastWindowIndex(shuffleModeEnabled);
+  }
+
+  @Override
+  public int getFirstWindowIndex(boolean shuffleModeEnabled) {
+    return timeline.getFirstWindowIndex(shuffleModeEnabled);
+  }
+
+  @Override
+  public Window getWindow(int windowIndex, Window window, boolean setIds,
+      long defaultPositionProjectionUs) {
+    return timeline.getWindow(windowIndex, window, setIds, defaultPositionProjectionUs);
+  }
+
+  @Override
+  public int getPeriodCount() {
+    return timeline.getPeriodCount();
+  }
+
+  @Override
+  public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+    return timeline.getPeriod(periodIndex, period, setIds);
+  }
+
+  @Override
+  public int getIndexOfPeriod(Object uid) {
+    return timeline.getIndexOfPeriod(uid);
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index a6e93a92b9..984820cc6a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.ShuffleOrder.UnshuffledShuffleOrder;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -62,11 +63,11 @@ public LoopingMediaSource(MediaSource childSource, int loopCount) {
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, final Listener listener) {
     childSource.prepareSource(player, false, new Listener() {
       @Override
-      public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+      public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
         childPeriodCount = timeline.getPeriodCount();
         Timeline loopingTimeline = loopCount != Integer.MAX_VALUE
             ? new LoopingTimeline(timeline, loopCount) : new InfinitelyLoopingTimeline(timeline);
-        listener.onSourceInfoRefreshed(loopingTimeline, manifest);
+        listener.onSourceInfoRefreshed(LoopingMediaSource.this, loopingTimeline, manifest);
       }
     });
   }
@@ -79,7 +80,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     return loopCount != Integer.MAX_VALUE
-        ? childSource.createPeriod(new MediaPeriodId(id.periodIndex % childPeriodCount), allocator)
+        ? childSource.createPeriod(id.copyWithPeriodIndex(id.periodIndex % childPeriodCount),
+            allocator)
         : childSource.createPeriod(id, allocator);
   }
 
@@ -101,13 +103,15 @@ public void releaseSource() {
     private final int loopCount;
 
     public LoopingTimeline(Timeline childTimeline, int loopCount) {
-      super(loopCount);
+      super(new UnshuffledShuffleOrder(loopCount));
       this.childTimeline = childTimeline;
       childPeriodCount = childTimeline.getPeriodCount();
       childWindowCount = childTimeline.getWindowCount();
       this.loopCount = loopCount;
-      Assertions.checkState(loopCount <= Integer.MAX_VALUE / childPeriodCount,
-          "LoopingMediaSource contains too many periods");
+      if (childPeriodCount > 0) {
+        Assertions.checkState(loopCount <= Integer.MAX_VALUE / childPeriodCount,
+            "LoopingMediaSource contains too many periods");
+      }
     }
 
     @Override
@@ -160,53 +164,30 @@ protected Object getChildUidByChildIndex(int childIndex) {
 
   }
 
-  private static final class InfinitelyLoopingTimeline extends Timeline {
-
-    private final Timeline childTimeline;
+  private static final class InfinitelyLoopingTimeline extends ForwardingTimeline {
 
-    public InfinitelyLoopingTimeline(Timeline childTimeline) {
-      this.childTimeline = childTimeline;
+    public InfinitelyLoopingTimeline(Timeline timeline) {
+      super(timeline);
     }
 
     @Override
-    public int getWindowCount() {
-      return childTimeline.getWindowCount();
+    public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+        boolean shuffleModeEnabled) {
+      int childNextWindowIndex = timeline.getNextWindowIndex(windowIndex, repeatMode,
+          shuffleModeEnabled);
+      return childNextWindowIndex == C.INDEX_UNSET ? getFirstWindowIndex(shuffleModeEnabled)
+          : childNextWindowIndex;
     }
 
     @Override
-    public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
-      int childNextWindowIndex = childTimeline.getNextWindowIndex(windowIndex, repeatMode);
-      return childNextWindowIndex == C.INDEX_UNSET ? 0 : childNextWindowIndex;
-    }
-
-    @Override
-    public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode) {
-      int childPreviousWindowIndex = childTimeline.getPreviousWindowIndex(windowIndex, repeatMode);
-      return childPreviousWindowIndex == C.INDEX_UNSET ? getWindowCount() - 1
+    public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
+        boolean shuffleModeEnabled) {
+      int childPreviousWindowIndex = timeline.getPreviousWindowIndex(windowIndex, repeatMode,
+          shuffleModeEnabled);
+      return childPreviousWindowIndex == C.INDEX_UNSET ? getLastWindowIndex(shuffleModeEnabled)
           : childPreviousWindowIndex;
     }
 
-    @Override
-    public Window getWindow(int windowIndex, Window window, boolean setIds,
-        long defaultPositionProjectionUs) {
-      return childTimeline.getWindow(windowIndex, window, setIds, defaultPositionProjectionUs);
-    }
-
-    @Override
-    public int getPeriodCount() {
-      return childTimeline.getPeriodCount();
-    }
-
-    @Override
-    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
-      return childTimeline.getPeriod(periodIndex, period, setIds);
-    }
-
-    @Override
-    public int getIndexOfPeriod(Object uid) {
-      return childTimeline.getIndexOfPeriod(uid);
-    }
-
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index 514b96ae8d..c297229d78 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -53,13 +53,13 @@
    * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
    * <p>
    * If preparation succeeds and results in a source timeline change (e.g. the period duration
-   * becoming known), {@link MediaSource.Listener#onSourceInfoRefreshed(Timeline, Object)} will be
+   * becoming known),
+   * {@link MediaSource.Listener#onSourceInfoRefreshed(MediaSource, Timeline, Object)} will be
    * called before {@code callback.onPrepared}.
    *
    * @param callback Callback to receive updates from this period, including being notified when
    *     preparation completes.
-   * @param positionUs The position in microseconds relative to the start of the period at which to
-   *     start loading data.
+   * @param positionUs The expected starting position, in microseconds.
    */
   void prepare(Callback callback, long positionUs);
 
@@ -103,7 +103,8 @@
    *     selections.
    * @param streamResetFlags Will be updated to indicate new sample streams, and sample streams that
    *     have been retained but with the requirement that the consuming renderer be reset.
-   * @param positionUs The current playback position in microseconds.
+   * @param positionUs The current playback position in microseconds. If playback of this period has
+    *    not yet started, the value will be the starting position.
    * @return The actual position at which the tracks were enabled, in microseconds.
    */
   long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
@@ -176,7 +177,9 @@ long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
    * called when the period is permitted to continue loading data. A period may do this both during
    * and after preparation.
    *
-   * @param positionUs The current playback position.
+   * @param positionUs The current playback position in microseconds. If playback of this period has
+   *     not yet started, the value will be the starting position in this period minus the duration
+   *     of any media in previous periods still to be played.
    * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
    *     a different value than prior to the call. False otherwise.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 11489cfbb8..7288b39897 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -46,11 +46,14 @@
 
     /**
      * Called when manifest and/or timeline has been refreshed.
+     * <p>
+     * Called on the playback thread.
      *
+     * @param source The {@link MediaSource} whose info has been refreshed.
      * @param timeline The source's timeline.
      * @param manifest The loaded manifest. May be null.
      */
-    void onSourceInfoRefreshed(Timeline timeline, @Nullable Object manifest);
+    void onSourceInfoRefreshed(MediaSource source, Timeline timeline, @Nullable Object manifest);
 
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index 642752b35b..1550970e47 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -98,7 +98,7 @@ public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener l
       final int sourceIndex = i;
       mediaSources[sourceIndex].prepareSource(player, false, new Listener() {
         @Override
-        public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+        public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
           handleSourceInfoRefreshed(sourceIndex, timeline, manifest);
         }
       });
@@ -152,7 +152,7 @@ private void handleSourceInfoRefreshed(int sourceIndex, Timeline timeline, Objec
       primaryManifest = manifest;
     }
     if (pendingTimelineSources.isEmpty()) {
-      listener.onSourceInfoRefreshed(primaryTimeline, primaryManifest);
+      listener.onSourceInfoRefreshed(this, primaryTimeline, primaryManifest);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
index 03b2e3b715..d70c59b195 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
@@ -253,32 +253,35 @@ public synchronized int read(FormatHolder formatHolder, DecoderInputBuffer buffe
    * @param allowTimeBeyondBuffer Whether the operation can succeed if {@code timeUs} is beyond the
    *     end of the queue, by advancing the read position to the last sample (or keyframe) in the
    *     queue.
-   * @return Whether the operation was a success. A successful advance is one in which the read
-   *     position was unchanged or advanced, and is now at a sample meeting the specified criteria.
+   * @return The number of samples that were skipped if the operation was successful, which may be
+   *     equal to 0, or {@link SampleQueue#ADVANCE_FAILED} if the operation was not successful. A
+   *     successful advance is one in which the read position was unchanged or advanced, and is now
+   *     at a sample meeting the specified criteria.
    */
-  public synchronized boolean advanceTo(long timeUs, boolean toKeyframe,
+  public synchronized int advanceTo(long timeUs, boolean toKeyframe,
       boolean allowTimeBeyondBuffer) {
     int relativeReadIndex = getRelativeIndex(readPosition);
     if (!hasNextSample() || timeUs < timesUs[relativeReadIndex]
         || (timeUs > largestQueuedTimestampUs && !allowTimeBeyondBuffer)) {
-      return false;
+      return SampleQueue.ADVANCE_FAILED;
     }
     int offset = findSampleBefore(relativeReadIndex, length - readPosition, timeUs, toKeyframe);
     if (offset == -1) {
-      return false;
+      return SampleQueue.ADVANCE_FAILED;
     }
     readPosition += offset;
-    return true;
+    return offset;
   }
 
   /**
    * Advances the read position to the end of the queue.
+   *
+   * @return The number of samples that were skipped.
    */
-  public synchronized void advanceToEnd() {
-    if (!hasNextSample()) {
-      return;
-    }
+  public synchronized int advanceToEnd() {
+    int skipCount = length - readPosition;
     readPosition = length;
+    return skipCount;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index c7bae8f8b4..b83cf7df5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -49,6 +49,8 @@
 
   }
 
+  public static final int ADVANCE_FAILED = -1;
+
   private static final int INITIAL_SCRATCH_SIZE = 32;
 
   private final Allocator allocator;
@@ -255,9 +257,11 @@ public void discardToEnd() {
 
   /**
    * Advances the read position to the end of the queue.
+   *
+   * @return The number of samples that were skipped.
    */
-  public void advanceToEnd() {
-    metadataQueue.advanceToEnd();
+  public int advanceToEnd() {
+    return metadataQueue.advanceToEnd();
   }
 
   /**
@@ -268,10 +272,12 @@ public void advanceToEnd() {
    *     time, rather than to any sample before or at that time.
    * @param allowTimeBeyondBuffer Whether the operation can succeed if {@code timeUs} is beyond the
    *     end of the queue, by advancing the read position to the last sample (or keyframe).
-   * @return Whether the operation was a success. A successful advance is one in which the read
-   *     position was unchanged or advanced, and is now at a sample meeting the specified criteria.
+   * @return The number of samples that were skipped if the operation was successful, which may be
+   *     equal to 0, or {@link #ADVANCE_FAILED} if the operation was not successful. A successful
+   *     advance is one in which the read position was unchanged or advanced, and is now at a sample
+   *     meeting the specified criteria.
    */
-  public boolean advanceTo(long timeUs, boolean toKeyframe, boolean allowTimeBeyondBuffer) {
+  public int advanceTo(long timeUs, boolean toKeyframe, boolean allowTimeBeyondBuffer) {
     return metadataQueue.advanceTo(timeUs, toKeyframe, allowTimeBeyondBuffer);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
index dc58c29c22..06efc980e2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
@@ -70,7 +70,8 @@
    * {@code positionUs} is beyond it.
    *
    * @param positionUs The specified time.
+   * @return The number of samples that were skipped.
    */
-  void skipData(long positionUs);
+  int skipData(long positionUs);
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 26cb9a2666..6daa1e847a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -52,7 +52,9 @@
   /**
    * Attempts to continue loading.
    *
-   * @param positionUs The current playback position.
+   * @param positionUs The current playback position in microseconds. If playback of the period to
+   *     which this loader belongs has not yet started, the value will be the starting position
+   *     in the period minus the duration of any media in previous periods still to be played.
    * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
    *     a different value than prior to the call. False otherwise.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
new file mode 100644
index 0000000000..4307fd2c19
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import java.util.Arrays;
+import java.util.Random;
+
+/**
+ * Shuffled order of indices.
+ */
+public interface ShuffleOrder {
+
+  /**
+   * The default {@link ShuffleOrder} implementation for random shuffle order.
+   */
+  class DefaultShuffleOrder implements ShuffleOrder {
+
+    private final Random random;
+    private final int[] shuffled;
+    private final int[] indexInShuffled;
+
+    /**
+     * Creates an instance with a specified length.
+     *
+     * @param length The length of the shuffle order.
+     */
+    public DefaultShuffleOrder(int length) {
+      this(length, new Random());
+    }
+
+    /**
+     * Creates an instance with a specified length and the specified random seed. Shuffle orders of
+     * the same length initialized with the same random seed are guaranteed to be equal.
+     *
+     * @param length The length of the shuffle order.
+     * @param randomSeed A random seed.
+     */
+    public DefaultShuffleOrder(int length, long randomSeed) {
+      this(length, new Random(randomSeed));
+    }
+
+    private DefaultShuffleOrder(int length, Random random) {
+      this(createShuffledList(length, random), random);
+    }
+
+    private DefaultShuffleOrder(int[] shuffled, Random random) {
+      this.shuffled = shuffled;
+      this.random = random;
+      this.indexInShuffled = new int[shuffled.length];
+      for (int i = 0; i < shuffled.length; i++) {
+        indexInShuffled[shuffled[i]] = i;
+      }
+    }
+
+    @Override
+    public int getLength() {
+      return shuffled.length;
+    }
+
+    @Override
+    public int getNextIndex(int index) {
+      int shuffledIndex = indexInShuffled[index];
+      return ++shuffledIndex < shuffled.length ? shuffled[shuffledIndex] : C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getPreviousIndex(int index) {
+      int shuffledIndex = indexInShuffled[index];
+      return --shuffledIndex >= 0 ? shuffled[shuffledIndex] : C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getLastIndex() {
+      return shuffled.length > 0 ? shuffled[shuffled.length - 1] : C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getFirstIndex() {
+      return shuffled.length > 0 ? shuffled[0] : C.INDEX_UNSET;
+    }
+
+    @Override
+    public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
+      int[] insertionPoints = new int[insertionCount];
+      int[] insertionValues = new int[insertionCount];
+      for (int i = 0; i < insertionCount; i++) {
+        insertionPoints[i] = random.nextInt(shuffled.length + 1);
+        int swapIndex = random.nextInt(i + 1);
+        insertionValues[i] = insertionValues[swapIndex];
+        insertionValues[swapIndex] = i + insertionIndex;
+      }
+      Arrays.sort(insertionPoints);
+      int[] newShuffled = new int[shuffled.length + insertionCount];
+      int indexInOldShuffled = 0;
+      int indexInInsertionList = 0;
+      for (int i = 0; i < shuffled.length + insertionCount; i++) {
+        if (indexInInsertionList < insertionCount
+            && indexInOldShuffled == insertionPoints[indexInInsertionList]) {
+          newShuffled[i] = insertionValues[indexInInsertionList++];
+        } else {
+          newShuffled[i] = shuffled[indexInOldShuffled++];
+          if (newShuffled[i] >= insertionIndex) {
+            newShuffled[i] += insertionCount;
+          }
+        }
+      }
+      return new DefaultShuffleOrder(newShuffled, new Random(random.nextLong()));
+    }
+
+    @Override
+    public ShuffleOrder cloneAndRemove(int removalIndex) {
+      int[] newShuffled = new int[shuffled.length - 1];
+      boolean foundRemovedElement = false;
+      for (int i = 0; i < shuffled.length; i++) {
+        if (shuffled[i] == removalIndex) {
+          foundRemovedElement = true;
+        } else {
+          newShuffled[foundRemovedElement ? i - 1 : i] = shuffled[i] > removalIndex
+              ? shuffled[i] - 1 : shuffled[i];
+        }
+      }
+      return new DefaultShuffleOrder(newShuffled, new Random(random.nextLong()));
+    }
+
+    private static int[] createShuffledList(int length, Random random) {
+      int[] shuffled = new int[length];
+      for (int i = 0; i < length; i++) {
+        int swapIndex = random.nextInt(i + 1);
+        shuffled[i] = shuffled[swapIndex];
+        shuffled[swapIndex] = i;
+      }
+      return shuffled;
+    }
+
+  }
+
+  /**
+   * A {@link ShuffleOrder} implementation which does not shuffle.
+   */
+  final class UnshuffledShuffleOrder implements ShuffleOrder {
+
+    private final int length;
+
+    /**
+     * Creates an instance with a specified length.
+     *
+     * @param length The length of the shuffle order.
+     */
+    public UnshuffledShuffleOrder(int length) {
+      this.length = length;
+    }
+
+    @Override
+    public int getLength() {
+      return length;
+    }
+
+    @Override
+    public int getNextIndex(int index) {
+      return ++index < length ? index : C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getPreviousIndex(int index) {
+      return --index >= 0 ? index : C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getLastIndex() {
+      return length > 0 ? length - 1 : C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getFirstIndex() {
+      return length > 0 ? 0 : C.INDEX_UNSET;
+    }
+
+    @Override
+    public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
+      return new UnshuffledShuffleOrder(length + insertionCount);
+    }
+
+    @Override
+    public ShuffleOrder cloneAndRemove(int removalIndex) {
+      return new UnshuffledShuffleOrder(length - 1);
+    }
+
+  }
+
+  /**
+   * Returns length of shuffle order.
+   */
+  int getLength();
+
+  /**
+   * Returns the next index in the shuffle order.
+   *
+   * @param index An index.
+   * @return The index after {@code index}, or {@link C#INDEX_UNSET} if {@code index} is the last
+   *     element.
+   */
+  int getNextIndex(int index);
+
+  /**
+   * Returns the previous index in the shuffle order.
+   *
+   * @param index An index.
+   * @return The index before {@code index}, or {@link C#INDEX_UNSET} if {@code index} is the first
+   *     element.
+   */
+  int getPreviousIndex(int index);
+
+  /**
+   * Returns the last index in the shuffle order, or {@link C#INDEX_UNSET} if the shuffle order is
+   * empty.
+   */
+  int getLastIndex();
+
+  /**
+   * Returns the first index in the shuffle order, or {@link C#INDEX_UNSET} if the shuffle order is
+   * empty.
+   */
+  int getFirstIndex();
+
+  /**
+   * Return a copy of the shuffle order with newly inserted elements.
+   *
+   * @param insertionIndex The index in the unshuffled order at which elements are inserted.
+   * @param insertionCount The number of elements inserted at {@code insertionIndex}.
+   * @return A copy of this {@link ShuffleOrder} with newly inserted elements.
+   */
+  ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount);
+
+  /**
+   * Return a copy of the shuffle order with one element removed.
+   *
+   * @param removalIndex The index of the element in the unshuffled order which is to be removed.
+   * @return A copy of this {@link ShuffleOrder} without the removed element.
+   */
+  ShuffleOrder cloneAndRemove(int removalIndex);
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 3435c01eeb..6101c79b7f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -27,7 +27,6 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -52,16 +51,20 @@
   private final int eventSourceId;
   private final TrackGroupArray tracks;
   private final ArrayList<SampleStreamImpl> sampleStreams;
+  // Package private to avoid thunk methods.
   /* package */ final Loader loader;
   /* package */ final Format format;
+  /* package */ final boolean treatLoadErrorsAsEndOfStream;
 
   /* package */ boolean loadingFinished;
+  /* package */ boolean loadingSucceeded;
   /* package */ byte[] sampleData;
   /* package */ int sampleSize;
+  private int errorCount;
 
   public SingleSampleMediaPeriod(Uri uri, DataSource.Factory dataSourceFactory, Format format,
       int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
-      int eventSourceId) {
+      int eventSourceId, boolean treatLoadErrorsAsEndOfStream) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.format = format;
@@ -69,6 +72,7 @@ public SingleSampleMediaPeriod(Uri uri, DataSource.Factory dataSourceFactory, Fo
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.eventSourceId = eventSourceId;
+    this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
     tracks = new TrackGroupArray(new TrackGroup(format));
     sampleStreams = new ArrayList<>();
     loader = new Loader("Loader:SingleSampleMediaPeriod");
@@ -85,7 +89,7 @@ public void prepare(Callback callback, long positionUs) {
 
   @Override
   public void maybeThrowPrepareError() throws IOException {
-    loader.maybeThrowError();
+    // Do nothing.
   }
 
   @Override
@@ -157,6 +161,7 @@ public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
     sampleSize = loadable.sampleSize;
     sampleData = loadable.sampleData;
     loadingFinished = true;
+    loadingSucceeded = true;
   }
 
   @Override
@@ -169,6 +174,11 @@ public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long
   public int onLoadError(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
       IOException error) {
     notifyLoadError(error);
+    errorCount++;
+    if (treatLoadErrorsAsEndOfStream && errorCount >= minLoadableRetryCount) {
+      loadingFinished = true;
+      return Loader.DONT_RETRY;
+    }
     return Loader.RETRY;
   }
 
@@ -206,7 +216,9 @@ public boolean isReady() {
 
     @Override
     public void maybeThrowError() throws IOException {
-      loader.maybeThrowError();
+      if (!treatLoadErrorsAsEndOfStream) {
+        loader.maybeThrowError();
+      }
     }
 
     @Override
@@ -219,26 +231,28 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         formatHolder.format = format;
         streamState = STREAM_STATE_SEND_SAMPLE;
         return C.RESULT_FORMAT_READ;
-      }
-
-      Assertions.checkState(streamState == STREAM_STATE_SEND_SAMPLE);
-      if (!loadingFinished) {
-        return C.RESULT_NOTHING_READ;
-      } else {
-        buffer.timeUs = 0;
-        buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
-        buffer.ensureSpaceForWrite(sampleSize);
-        buffer.data.put(sampleData, 0, sampleSize);
+      } else if (loadingFinished) {
+        if (loadingSucceeded) {
+          buffer.timeUs = 0;
+          buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
+          buffer.ensureSpaceForWrite(sampleSize);
+          buffer.data.put(sampleData, 0, sampleSize);
+        } else {
+          buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        }
         streamState = STREAM_STATE_END_OF_STREAM;
         return C.RESULT_BUFFER_READ;
       }
+      return C.RESULT_NOTHING_READ;
     }
 
     @Override
-    public void skipData(long positionUs) {
-      if (positionUs > 0) {
+    public int skipData(long positionUs) {
+      if (positionUs > 0 && streamState != STREAM_STATE_END_OF_STREAM) {
         streamState = STREAM_STATE_END_OF_STREAM;
+        return 1;
       }
+      return 0;
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 99bc60d6fb..dd901958fd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -57,21 +57,51 @@
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final int eventSourceId;
+  private final boolean treatLoadErrorsAsEndOfStream;
   private final Timeline timeline;
 
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSourceFactory The factory from which the {@link DataSource} to read the media will
+   *     be obtained.
+   * @param format The {@link Format} associated with the output track.
+   * @param durationUs The duration of the media stream in microseconds.
+   */
   public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
       long durationUs) {
     this(uri, dataSourceFactory, format, durationUs, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSourceFactory The factory from which the {@link DataSource} to read the media will
+   *     be obtained.
+   * @param format The {@link Format} associated with the output track.
+   * @param durationUs The duration of the media stream in microseconds.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   */
   public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
       long durationUs, int minLoadableRetryCount) {
-    this(uri, dataSourceFactory, format, durationUs, minLoadableRetryCount, null, null, 0);
+    this(uri, dataSourceFactory, format, durationUs, minLoadableRetryCount, null, null, 0, false);
   }
 
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSourceFactory The factory from which the {@link DataSource} to read the media will
+   *     be obtained.
+   * @param format The {@link Format} associated with the output track.
+   * @param durationUs The duration of the media stream in microseconds.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
+   * @param treatLoadErrorsAsEndOfStream If true, load errors will not be propagated by sample
+   *     streams, treating them as ended instead. If false, load errors will be propagated normally
+   *     by {@link SampleStream#maybeThrowError()}.
+   */
   public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
       long durationUs, int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
-      int eventSourceId) {
+      int eventSourceId, boolean treatLoadErrorsAsEndOfStream) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.format = format;
@@ -79,6 +109,7 @@ public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Fo
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.eventSourceId = eventSourceId;
+    this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
     timeline = new SinglePeriodTimeline(durationUs, true);
   }
 
@@ -86,7 +117,7 @@ public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Fo
 
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    listener.onSourceInfoRefreshed(timeline, null);
+    listener.onSourceInfoRefreshed(this, timeline, null);
   }
 
   @Override
@@ -98,7 +129,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
     return new SingleSampleMediaPeriod(uri, dataSourceFactory, format, minLoadableRetryCount,
-        eventHandler, eventListener, eventSourceId);
+        eventHandler, eventListener, eventSourceId, treatLoadErrorsAsEndOfStream);
   }
 
   @Override
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/AdPlaybackState.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
similarity index 89%
rename from extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/AdPlaybackState.java
rename to library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
index 0edd7d6558..58fa149b59 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/AdPlaybackState.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.ext.ima;
+package com.google.android.exoplayer2.source.ads;
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
@@ -22,7 +22,7 @@
 /**
  * Represents the structure of ads to play and the state of loaded/played ads.
  */
-/* package */ final class AdPlaybackState {
+public final class AdPlaybackState {
 
   /**
    * The number of ad groups.
@@ -51,6 +51,10 @@
    */
   public final Uri[][] adUris;
 
+  /**
+   * The content duration in microseconds, if known. {@link C#TIME_UNSET} otherwise.
+   */
+  public long contentDurationUs;
   /**
    * The position offset in the first unplayed ad at which to begin playback, in microseconds.
    */
@@ -71,15 +75,17 @@ public AdPlaybackState(long[] adGroupTimesUs) {
     adUris = new Uri[adGroupCount][];
     Arrays.fill(adUris, new Uri[0]);
     adsLoadedCounts = new int[adGroupTimesUs.length];
+    contentDurationUs = C.TIME_UNSET;
   }
 
   private AdPlaybackState(long[] adGroupTimesUs, int[] adCounts, int[] adsLoadedCounts,
-      int[] adsPlayedCounts, Uri[][] adUris, long adResumePositionUs) {
+      int[] adsPlayedCounts, Uri[][] adUris, long contentDurationUs, long adResumePositionUs) {
     this.adGroupTimesUs = adGroupTimesUs;
     this.adCounts = adCounts;
     this.adsLoadedCounts = adsLoadedCounts;
     this.adsPlayedCounts = adsPlayedCounts;
     this.adUris = adUris;
+    this.contentDurationUs = contentDurationUs;
     this.adResumePositionUs = adResumePositionUs;
     adGroupCount = adGroupTimesUs.length;
   }
@@ -94,7 +100,8 @@ public AdPlaybackState copy() {
     }
     return new AdPlaybackState(Arrays.copyOf(adGroupTimesUs, adGroupCount),
         Arrays.copyOf(adCounts, adGroupCount), Arrays.copyOf(adsLoadedCounts, adGroupCount),
-        Arrays.copyOf(adsPlayedCounts, adGroupCount), adUris, adResumePositionUs);
+        Arrays.copyOf(adsPlayedCounts, adGroupCount), adUris, contentDurationUs,
+        adResumePositionUs);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
new file mode 100644
index 0000000000..241750a21f
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.ads;
+
+import android.view.ViewGroup;
+import com.google.android.exoplayer2.ExoPlayer;
+import java.io.IOException;
+
+/**
+ * Interface for loaders of ads, which can be used with {@link AdsMediaSource}.
+ * <p>
+ * Ad loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
+ * particular, implementations must call {@link EventListener#onAdPlaybackState(AdPlaybackState)}
+ * with a new copy of the current {@link AdPlaybackState} whenever further information about ads
+ * becomes known (for example, when an ad media URI is available, or an ad has played to the end).
+ * <p>
+ * {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} will be called when the ads media
+ * source first initializes, at which point the loader can request ads. If the player enters the
+ * background, {@link #detachPlayer()} will be called. Loaders should maintain any ad playback state
+ * in preparation for a later call to {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. If
+ * an ad is playing when the player is detached, store the current playback position via
+ * {@link AdPlaybackState#setAdResumePositionUs(long)}.
+ * <p>
+ * If {@link EventListener#onAdPlaybackState(AdPlaybackState)} has been called, the implementation
+ * of {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} should invoke the same listener to
+ * provide the existing playback state to the new player.
+ */
+public interface AdsLoader {
+
+  /**
+   * Listener for ad loader events. All methods are called on the main thread.
+   */
+  interface EventListener {
+
+    /**
+     * Called when the ad playback state has been updated.
+     *
+     * @param adPlaybackState The new ad playback state.
+     */
+    void onAdPlaybackState(AdPlaybackState adPlaybackState);
+
+    /**
+     * Called when there was an error loading ads.
+     *
+     * @param error The error.
+     */
+    void onLoadError(IOException error);
+
+    /**
+     * Called when the user clicks through an ad (for example, following a 'learn more' link).
+     */
+    void onAdClicked();
+
+    /**
+     * Called when the user taps a non-clickthrough part of an ad.
+     */
+    void onAdTapped();
+
+  }
+
+  /**
+   * Attaches a player that will play ads loaded using this instance. Called on the main thread by
+   * {@link AdsMediaSource}.
+   *
+   * @param player The player instance that will play the loaded ads.
+   * @param eventListener Listener for ads loader events.
+   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   */
+  void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup);
+
+  /**
+   * Detaches the attached player and event listener. Called on the main thread by
+   * {@link AdsMediaSource}.
+   */
+  void detachPlayer();
+
+  /**
+   * Releases the loader. Called by the application on the main thread when the instance is no
+   * longer needed.
+   */
+  void release();
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
new file mode 100644
index 0000000000..18aa8a63e7
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.ads;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.view.ViewGroup;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A {@link MediaSource} that inserts ads linearly with a provided content media source.
+ */
+public final class AdsMediaSource implements MediaSource {
+
+  /**
+   * Listener for events relating to ad loading.
+   */
+  public interface AdsListener {
+
+    /**
+     * Called if there was an error loading ads. The media source will load the content without ads
+     * if ads can't be loaded, so listen for this event if you need to implement additional handling
+     * (for example, stopping the player).
+     *
+     * @param error The error.
+     */
+    void onAdLoadError(IOException error);
+
+    /**
+     * Called when the user clicks through an ad (for example, following a 'learn more' link).
+     */
+    void onAdClicked();
+
+    /**
+     * Called when the user taps a non-clickthrough part of an ad.
+     */
+    void onAdTapped();
+
+  }
+
+  private static final String TAG = "AdsMediaSource";
+
+  private final MediaSource contentMediaSource;
+  private final DataSource.Factory dataSourceFactory;
+  private final AdsLoader adsLoader;
+  private final ViewGroup adUiViewGroup;
+  private final Handler mainHandler;
+  private final ComponentListener componentListener;
+  private final Map<MediaPeriod, MediaSource> adMediaSourceByMediaPeriod;
+  private final Timeline.Period period;
+  @Nullable
+  private final Handler eventHandler;
+  @Nullable
+  private final AdsListener eventListener;
+
+  private Handler playerHandler;
+  private ExoPlayer player;
+  private volatile boolean released;
+
+  // Accessed on the player thread.
+  private Timeline contentTimeline;
+  private Object contentManifest;
+  private AdPlaybackState adPlaybackState;
+  private MediaSource[][] adGroupMediaSources;
+  private long[][] adDurationsUs;
+  private MediaSource.Listener listener;
+
+  /**
+   * Constructs a new source that inserts ads linearly with the content specified by
+   * {@code contentMediaSource}.
+   *
+   * @param contentMediaSource The {@link MediaSource} providing the content to play.
+   * @param dataSourceFactory Factory for data sources used to load ad media.
+   * @param adsLoader The loader for ads.
+   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   */
+  public AdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
+      AdsLoader adsLoader, ViewGroup adUiViewGroup) {
+    this(contentMediaSource, dataSourceFactory, adsLoader, adUiViewGroup, null, null);
+  }
+
+  /**
+   * Constructs a new source that inserts ads linearly with the content specified by
+   * {@code contentMediaSource}.
+   *
+   * @param contentMediaSource The {@link MediaSource} providing the content to play.
+   * @param dataSourceFactory Factory for data sources used to load ad media.
+   * @param adsLoader The loader for ads.
+   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public AdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
+      AdsLoader adsLoader, ViewGroup adUiViewGroup, @Nullable Handler eventHandler,
+      @Nullable AdsListener eventListener) {
+    this.contentMediaSource = contentMediaSource;
+    this.dataSourceFactory = dataSourceFactory;
+    this.adsLoader = adsLoader;
+    this.adUiViewGroup = adUiViewGroup;
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    mainHandler = new Handler(Looper.getMainLooper());
+    componentListener = new ComponentListener();
+    adMediaSourceByMediaPeriod = new HashMap<>();
+    period = new Timeline.Period();
+    adGroupMediaSources = new MediaSource[0][];
+    adDurationsUs = new long[0][];
+  }
+
+  @Override
+  public void prepareSource(final ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    Assertions.checkArgument(isTopLevelSource);
+    this.listener = listener;
+    this.player = player;
+    playerHandler = new Handler();
+    contentMediaSource.prepareSource(player, false, new Listener() {
+      @Override
+      public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
+        AdsMediaSource.this.onContentSourceInfoRefreshed(timeline, manifest);
+      }
+    });
+    mainHandler.post(new Runnable() {
+      @Override
+      public void run() {
+        adsLoader.attachPlayer(player, componentListener, adUiViewGroup);
+      }
+    });
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    contentMediaSource.maybeThrowSourceInfoRefreshError();
+    for (MediaSource[] mediaSources : adGroupMediaSources) {
+      for (MediaSource mediaSource : mediaSources) {
+        if (mediaSource != null) {
+          mediaSource.maybeThrowSourceInfoRefreshError();
+        }
+      }
+    }
+  }
+
+  @Override
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+    if (adPlaybackState.adGroupCount > 0 && id.isAd()) {
+      final int adGroupIndex = id.adGroupIndex;
+      final int adIndexInAdGroup = id.adIndexInAdGroup;
+      if (adGroupMediaSources[adGroupIndex].length <= adIndexInAdGroup) {
+        MediaSource adMediaSource = new ExtractorMediaSource(
+            adPlaybackState.adUris[id.adGroupIndex][id.adIndexInAdGroup], dataSourceFactory,
+            new DefaultExtractorsFactory(), mainHandler, componentListener);
+        int oldAdCount = adGroupMediaSources[id.adGroupIndex].length;
+        if (adIndexInAdGroup >= oldAdCount) {
+          int adCount = adIndexInAdGroup + 1;
+          adGroupMediaSources[adGroupIndex] =
+              Arrays.copyOf(adGroupMediaSources[adGroupIndex], adCount);
+          adDurationsUs[adGroupIndex] = Arrays.copyOf(adDurationsUs[adGroupIndex], adCount);
+          Arrays.fill(adDurationsUs[adGroupIndex], oldAdCount, adCount, C.TIME_UNSET);
+        }
+        adGroupMediaSources[adGroupIndex][adIndexInAdGroup] = adMediaSource;
+        adMediaSource.prepareSource(player, false, new Listener() {
+          @Override
+          public void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
+              Object manifest) {
+            onAdSourceInfoRefreshed(adGroupIndex, adIndexInAdGroup, timeline);
+          }
+        });
+      }
+      MediaSource mediaSource = adGroupMediaSources[adGroupIndex][adIndexInAdGroup];
+      MediaPeriod mediaPeriod = mediaSource.createPeriod(new MediaPeriodId(0), allocator);
+      adMediaSourceByMediaPeriod.put(mediaPeriod, mediaSource);
+      return mediaPeriod;
+    } else {
+      return contentMediaSource.createPeriod(id, allocator);
+    }
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {
+    if (adMediaSourceByMediaPeriod.containsKey(mediaPeriod)) {
+      adMediaSourceByMediaPeriod.remove(mediaPeriod).releasePeriod(mediaPeriod);
+    } else {
+      contentMediaSource.releasePeriod(mediaPeriod);
+    }
+  }
+
+  @Override
+  public void releaseSource() {
+    released = true;
+    contentMediaSource.releaseSource();
+    for (MediaSource[] mediaSources : adGroupMediaSources) {
+      for (MediaSource mediaSource : mediaSources) {
+        if (mediaSource != null) {
+          mediaSource.releaseSource();
+        }
+      }
+    }
+    mainHandler.post(new Runnable() {
+      @Override
+      public void run() {
+        adsLoader.detachPlayer();
+      }
+    });
+  }
+
+  // Internal methods.
+
+  private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
+    if (this.adPlaybackState == null) {
+      adGroupMediaSources = new MediaSource[adPlaybackState.adGroupCount][];
+      Arrays.fill(adGroupMediaSources, new MediaSource[0]);
+      adDurationsUs = new long[adPlaybackState.adGroupCount][];
+      Arrays.fill(adDurationsUs, new long[0]);
+    }
+    this.adPlaybackState = adPlaybackState;
+    maybeUpdateSourceInfo();
+  }
+
+  private void onLoadError(final IOException error) {
+    Log.w(TAG, "Ad load error", error);
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          if (!released) {
+            eventListener.onAdLoadError(error);
+          }
+        }
+      });
+    }
+  }
+
+  private void onContentSourceInfoRefreshed(Timeline timeline, Object manifest) {
+    contentTimeline = timeline;
+    contentManifest = manifest;
+    maybeUpdateSourceInfo();
+  }
+
+  private void onAdSourceInfoRefreshed(int adGroupIndex, int adIndexInAdGroup, Timeline timeline) {
+    Assertions.checkArgument(timeline.getPeriodCount() == 1);
+    adDurationsUs[adGroupIndex][adIndexInAdGroup] = timeline.getPeriod(0, period).getDurationUs();
+    maybeUpdateSourceInfo();
+  }
+
+  private void maybeUpdateSourceInfo() {
+    if (adPlaybackState != null && contentTimeline != null) {
+      Timeline timeline = adPlaybackState.adGroupCount == 0 ? contentTimeline
+          : new SinglePeriodAdTimeline(contentTimeline, adPlaybackState.adGroupTimesUs,
+              adPlaybackState.adCounts, adPlaybackState.adsLoadedCounts,
+              adPlaybackState.adsPlayedCounts, adDurationsUs, adPlaybackState.adResumePositionUs,
+              adPlaybackState.contentDurationUs);
+      listener.onSourceInfoRefreshed(this, timeline, contentManifest);
+    }
+  }
+
+  /**
+   * Listener for component events. All methods are called on the main thread.
+   */
+  private final class ComponentListener implements AdsLoader.EventListener,
+      ExtractorMediaSource.EventListener {
+
+    @Override
+    public void onAdPlaybackState(final AdPlaybackState adPlaybackState) {
+      if (released) {
+        return;
+      }
+      playerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          if (released) {
+            return;
+          }
+          AdsMediaSource.this.onAdPlaybackState(adPlaybackState);
+        }
+      });
+    }
+
+    @Override
+    public void onAdClicked() {
+      if (eventHandler != null && eventListener != null) {
+        eventHandler.post(new Runnable() {
+          @Override
+          public void run() {
+            if (!released) {
+              eventListener.onAdClicked();
+            }
+          }
+        });
+      }
+    }
+
+    @Override
+    public void onAdTapped() {
+      if (eventHandler != null && eventListener != null) {
+        eventHandler.post(new Runnable() {
+          @Override
+          public void run() {
+            if (!released) {
+              eventListener.onAdTapped();
+            }
+          }
+        });
+      }
+    }
+
+    @Override
+    public void onLoadError(final IOException error) {
+      if (released) {
+        return;
+      }
+      playerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          if (released) {
+            return;
+          }
+          AdsMediaSource.this.onLoadError(error);
+        }
+      });
+    }
+
+  }
+
+}
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/SinglePeriodAdTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
similarity index 80%
rename from extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/SinglePeriodAdTimeline.java
rename to library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
index 1d73234286..0a04c9ab4b 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/SinglePeriodAdTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
@@ -13,24 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.ext.ima;
+package com.google.android.exoplayer2.source.ads;
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.ForwardingTimeline;
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
  * A {@link Timeline} for sources that have ads.
  */
-/* package */ final class SinglePeriodAdTimeline extends Timeline {
+/* package */ final class SinglePeriodAdTimeline extends ForwardingTimeline {
 
-  private final Timeline contentTimeline;
   private final long[] adGroupTimesUs;
   private final int[] adCounts;
   private final int[] adsLoadedCounts;
   private final int[] adsPlayedCounts;
   private final long[][] adDurationsUs;
   private final long adResumePositionUs;
+  private final long contentDurationUs;
 
   /**
    * Creates a new timeline with a single period containing the specified ads.
@@ -48,40 +49,27 @@
    *     may be {@link C#TIME_UNSET} if the duration is not yet known.
    * @param adResumePositionUs The position offset in the earliest unplayed ad at which to begin
    *     playback, in microseconds.
+   * @param contentDurationUs The content duration in microseconds, if known. {@link C#TIME_UNSET}
+   *     otherwise.
    */
   public SinglePeriodAdTimeline(Timeline contentTimeline, long[] adGroupTimesUs, int[] adCounts,
-      int[] adsLoadedCounts, int[] adsPlayedCounts, long[][] adDurationsUs,
-      long adResumePositionUs) {
+      int[] adsLoadedCounts, int[] adsPlayedCounts, long[][] adDurationsUs, long adResumePositionUs,
+      long contentDurationUs) {
+    super(contentTimeline);
     Assertions.checkState(contentTimeline.getPeriodCount() == 1);
     Assertions.checkState(contentTimeline.getWindowCount() == 1);
-    this.contentTimeline = contentTimeline;
     this.adGroupTimesUs = adGroupTimesUs;
     this.adCounts = adCounts;
     this.adsLoadedCounts = adsLoadedCounts;
     this.adsPlayedCounts = adsPlayedCounts;
     this.adDurationsUs = adDurationsUs;
     this.adResumePositionUs = adResumePositionUs;
-  }
-
-  @Override
-  public int getWindowCount() {
-    return 1;
-  }
-
-  @Override
-  public Window getWindow(int windowIndex, Window window, boolean setIds,
-      long defaultPositionProjectionUs) {
-    return contentTimeline.getWindow(windowIndex, window, setIds, defaultPositionProjectionUs);
-  }
-
-  @Override
-  public int getPeriodCount() {
-    return 1;
+    this.contentDurationUs = contentDurationUs;
   }
 
   @Override
   public Period getPeriod(int periodIndex, Period period, boolean setIds) {
-    contentTimeline.getPeriod(periodIndex, period, setIds);
+    timeline.getPeriod(periodIndex, period, setIds);
     period.set(period.id, period.uid, period.windowIndex, period.durationUs,
         period.getPositionInWindowUs(), adGroupTimesUs, adCounts, adsLoadedCounts, adsPlayedCounts,
         adDurationsUs, adResumePositionUs);
@@ -89,8 +77,13 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
   }
 
   @Override
-  public int getIndexOfPeriod(Object uid) {
-    return contentTimeline.getIndexOfPeriod(uid);
+  public Window getWindow(int windowIndex, Window window, boolean setIds,
+      long defaultPositionProjectionUs) {
+    window = super.getWindow(windowIndex, window, setIds, defaultPositionProjectionUs);
+    if (window.durationUs == C.TIME_UNSET) {
+      window.durationUs = contentDurationUs;
+    }
+    return window;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index 07d1cce8cb..17eb30dee9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -29,9 +29,10 @@
 import java.io.IOException;
 
 /**
- * An {@link Extractor} wrapper for loading chunks containing a single track.
+ * An {@link Extractor} wrapper for loading chunks that contain a single primary track, and possibly
+ * additional embedded tracks.
  * <p>
- * The wrapper allows switching of the {@link TrackOutput} that receives parsed data.
+ * The wrapper allows switching of the {@link TrackOutput}s that receive parsed data.
  */
 public final class ChunkExtractorWrapper implements ExtractorOutput {
 
@@ -56,7 +57,8 @@
 
   public final Extractor extractor;
 
-  private final Format manifestFormat;
+  private final int primaryTrackType;
+  private final Format primaryTrackManifestFormat;
   private final SparseArray<BindingTrackOutput> bindingTrackOutputs;
 
   private boolean extractorInitialized;
@@ -66,12 +68,16 @@
 
   /**
    * @param extractor The extractor to wrap.
-   * @param manifestFormat A manifest defined {@link Format} whose data should be merged into any
-   *     sample {@link Format} output from the {@link Extractor}.
+   * @param primaryTrackType The type of the primary track. Typically one of the
+   *     {@link com.google.android.exoplayer2.C} {@code TRACK_TYPE_*} constants.
+   * @param primaryTrackManifestFormat A manifest defined {@link Format} whose data should be merged
+   *     into any sample {@link Format} output from the {@link Extractor} for the primary track.
    */
-  public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat) {
+  public ChunkExtractorWrapper(Extractor extractor, int primaryTrackType,
+      Format primaryTrackManifestFormat) {
     this.extractor = extractor;
-    this.manifestFormat = manifestFormat;
+    this.primaryTrackType = primaryTrackType;
+    this.primaryTrackManifestFormat = primaryTrackManifestFormat;
     bindingTrackOutputs = new SparseArray<>();
   }
 
@@ -90,8 +96,8 @@ public SeekMap getSeekMap() {
   }
 
   /**
-   * Initializes the extractor to output to the provided {@link TrackOutput}, and configures it to
-   * receive data from a new chunk.
+   * Initializes the wrapper to output to {@link TrackOutput}s provided by the specified
+   * {@link TrackOutputProvider}, and configures the extractor to receive data from a new chunk.
    *
    * @param trackOutputProvider The provider of {@link TrackOutput}s that will receive sample data.
    */
@@ -116,7 +122,9 @@ public TrackOutput track(int id, int type) {
     if (bindingTrackOutput == null) {
       // Assert that if we're seeing a new track we have not seen endTracks.
       Assertions.checkState(sampleFormats == null);
-      bindingTrackOutput = new BindingTrackOutput(id, type, manifestFormat);
+      // TODO: Manifest formats for embedded tracks should also be passed here.
+      bindingTrackOutput = new BindingTrackOutput(id, type,
+          type == primaryTrackType ? primaryTrackManifestFormat : null);
       bindingTrackOutput.bind(trackOutputProvider);
       bindingTrackOutputs.put(id, bindingTrackOutput);
     }
@@ -160,16 +168,15 @@ public void bind(TrackOutputProvider trackOutputProvider) {
         return;
       }
       trackOutput = trackOutputProvider.track(id, type);
-      if (trackOutput != null) {
+      if (sampleFormat != null) {
         trackOutput.format(sampleFormat);
       }
     }
 
     @Override
     public void format(Format format) {
-      // TODO: This should only happen for the primary track. Additional metadata/text tracks need
-      // to be copied with different manifest derived formats.
-      sampleFormat = format.copyWithManifestFormatInfo(manifestFormat);
+      sampleFormat = manifestFormat != null ? format.copyWithManifestFormatInfo(manifestFormat)
+          : format;
       trackOutput.format(sampleFormat);
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 0fc3d5881e..bb51ae074e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -38,6 +40,8 @@
 public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, SequenceableLoader,
     Loader.Callback<Chunk>, Loader.ReleaseCallback {
 
+  private static final String TAG = "ChunkSampleStream";
+
   private final int primaryTrackType;
   private final int[] embeddedTrackTypes;
   private final boolean[] embeddedTracksSelected;
@@ -160,6 +164,7 @@ public T getChunkSource() {
    * @return An estimate of the absolute position in microseconds up to which data is buffered, or
    *     {@link C#TIME_END_OF_SOURCE} if the track is fully buffered.
    */
+  @Override
   public long getBufferedPositionUs() {
     if (loadingFinished) {
       return C.TIME_END_OF_SOURCE;
@@ -185,8 +190,8 @@ public long getBufferedPositionUs() {
   public void seekToUs(long positionUs) {
     lastSeekPositionUs = positionUs;
     // If we're not pending a reset, see if we can seek within the primary sample queue.
-    boolean seekInsideBuffer = !isPendingReset() && primarySampleQueue.advanceTo(positionUs, true,
-        positionUs < getNextLoadPositionUs());
+    boolean seekInsideBuffer = !isPendingReset() && (primarySampleQueue.advanceTo(positionUs, true,
+        positionUs < getNextLoadPositionUs()) != SampleQueue.ADVANCE_FAILED);
     if (seekInsideBuffer) {
       // We succeeded. Discard samples and corresponding chunks prior to the seek position.
       discardDownstreamMediaChunks(primarySampleQueue.getReadIndex());
@@ -266,13 +271,23 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
   }
 
   @Override
-  public void skipData(long positionUs) {
+  public int skipData(long positionUs) {
+    if (isPendingReset()) {
+      return 0;
+    }
+    int skipCount;
     if (loadingFinished && positionUs > primarySampleQueue.getLargestQueuedTimestampUs()) {
-      primarySampleQueue.advanceToEnd();
+      skipCount = primarySampleQueue.advanceToEnd();
     } else {
-      primarySampleQueue.advanceTo(positionUs, true, true);
+      skipCount = primarySampleQueue.advanceTo(positionUs, true, true);
+      if (skipCount == SampleQueue.ADVANCE_FAILED) {
+        skipCount = 0;
+      }
     }
-    primarySampleQueue.discardToRead();
+    if (skipCount > 0) {
+      primarySampleQueue.discardToRead();
+    }
+    return skipCount;
   }
 
   // Loader.Callback implementation.
@@ -308,19 +323,23 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
       IOException error) {
     long bytesLoaded = loadable.bytesLoaded();
     boolean isMediaChunk = isMediaChunk(loadable);
-    boolean cancelable = !isMediaChunk || bytesLoaded == 0 || mediaChunks.size() > 1;
+    boolean cancelable = bytesLoaded == 0 || !isMediaChunk || !haveReadFromLastMediaChunk();
     boolean canceled = false;
     if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
-      canceled = true;
-      if (isMediaChunk) {
-        BaseMediaChunk removed = mediaChunks.removeLast();
-        Assertions.checkState(removed == loadable);
-        primarySampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex(0));
-        for (int i = 0; i < embeddedSampleQueues.length; i++) {
-          embeddedSampleQueues[i].discardUpstreamSamples(removed.getFirstSampleIndex(i + 1));
-        }
-        if (mediaChunks.isEmpty()) {
-          pendingResetPositionUs = lastSeekPositionUs;
+      if (!cancelable) {
+        Log.w(TAG, "Ignoring attempt to cancel non-cancelable load.");
+      } else {
+        canceled = true;
+        if (isMediaChunk) {
+          BaseMediaChunk removed = mediaChunks.removeLast();
+          Assertions.checkState(removed == loadable);
+          primarySampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex(0));
+          for (int i = 0; i < embeddedSampleQueues.length; i++) {
+            embeddedSampleQueues[i].discardUpstreamSamples(removed.getFirstSampleIndex(i + 1));
+          }
+          if (mediaChunks.isEmpty()) {
+            pendingResetPositionUs = lastSeekPositionUs;
+          }
         }
       }
     }
@@ -344,9 +363,16 @@ public boolean continueLoading(long positionUs) {
       return false;
     }
 
-    chunkSource.getNextChunk(mediaChunks.isEmpty() ? null : mediaChunks.getLast(),
-        pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
-        nextChunkHolder);
+    MediaChunk previousChunk;
+    long loadPositionUs;
+    if (isPendingReset()) {
+      previousChunk = null;
+      loadPositionUs = pendingResetPositionUs;
+    } else {
+      previousChunk = mediaChunks.getLast();
+      loadPositionUs = previousChunk.endTimeUs;
+    }
+    chunkSource.getNextChunk(previousChunk, positionUs, loadPositionUs, nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     nextChunkHolder.clear();
@@ -401,6 +427,22 @@ private boolean isMediaChunk(Chunk chunk) {
     return chunk instanceof BaseMediaChunk;
   }
 
+  /**
+   * Returns whether samples have been read from {@code mediaChunks.getLast()}.
+   */
+  private boolean haveReadFromLastMediaChunk() {
+    BaseMediaChunk lastChunk = mediaChunks.getLast();
+    if (primarySampleQueue.getReadIndex() > lastChunk.getFirstSampleIndex(0)) {
+      return true;
+    }
+    for (int i = 0; i < embeddedSampleQueues.length; i++) {
+      if (embeddedSampleQueues[i].getReadIndex() > lastChunk.getFirstSampleIndex(i + 1)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /* package */ boolean isPendingReset() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
@@ -470,11 +512,12 @@ public boolean isReady() {
     }
 
     @Override
-    public void skipData(long positionUs) {
+    public int skipData(long positionUs) {
       if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
-        sampleQueue.advanceToEnd();
+        return sampleQueue.advanceToEnd();
       } else {
-        sampleQueue.advanceTo(positionUs, true, true);
+        int skipCount = sampleQueue.advanceTo(positionUs, true, true);
+        return skipCount == SampleQueue.ADVANCE_FAILED ? 0 : skipCount;
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
index 00865822e1..b04dc7cbdb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
@@ -54,12 +54,17 @@
    * end of the stream has not been reached, the {@link ChunkHolder} is not modified.
    *
    * @param previous The most recently loaded media chunk.
-   * @param playbackPositionUs The current playback position. If {@code previous} is null then this
-   *     parameter is the position from which playback is expected to start (or restart) and hence
-   *     should be interpreted as a seek position.
+   * @param playbackPositionUs The current playback position in microseconds. If playback of the
+   *     period to which this chunk source belongs has not yet started, the value will be the
+   *     starting position in the period minus the duration of any media in previous periods still
+   *     to be played.
+   * @param loadPositionUs The current load position in microseconds. If {@code previous} is null,
+   *     this is the starting position from which chunks should be provided. Else it's equal to
+   *     {@code previous.endTimeUs}.
    * @param out A holder to populate.
    */
-  void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out);
+  void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+      ChunkHolder out);
 
   /**
    * Called when the {@link ChunkSampleStream} has finished loading a chunk obtained from this
@@ -80,7 +85,8 @@
    * @param chunk The chunk whose load encountered the error.
    * @param cancelable Whether the load can be canceled.
    * @param e The error.
-   * @return Whether the load should be canceled.
+   * @return Whether the load should be canceled. Should always be false if {@code cancelable} is
+   *     false.
    */
   boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e);
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java
new file mode 100644
index 0000000000..5a08db94cb
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/TextOutput.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text;
+
+import java.util.List;
+
+/**
+ * Receives text output.
+ */
+public interface TextOutput {
+
+  /**
+   * Called when there is a change in the {@link Cue}s.
+   *
+   * @param cues The {@link Cue}s.
+   */
+  void onCues(List<Cue> cues);
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index 700fc0cb4b..c6d7f6f163 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -37,23 +37,15 @@
  * <p>
  * {@link Subtitle}s are decoded from sample data using {@link SubtitleDecoder} instances obtained
  * from a {@link SubtitleDecoderFactory}. The actual rendering of the subtitle {@link Cue}s is
- * delegated to an {@link Output}.
+ * delegated to a {@link TextOutput}.
  */
 public final class TextRenderer extends BaseRenderer implements Callback {
 
   /**
-   * Receives output from a {@link TextRenderer}.
+   * @deprecated Use {@link TextOutput}.
    */
-  public interface Output {
-
-    /**
-     * Called each time there is a change in the {@link Cue}s.
-     *
-     * @param cues The {@link Cue}s.
-     */
-    void onCues(List<Cue> cues);
-
-  }
+  @Deprecated
+  public interface Output extends TextOutput {}
 
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REPLACEMENT_STATE_NONE, REPLACEMENT_STATE_SIGNAL_END_OF_STREAM,
@@ -79,7 +71,7 @@
   private static final int MSG_UPDATE_OUTPUT = 0;
 
   private final Handler outputHandler;
-  private final Output output;
+  private final TextOutput output;
   private final SubtitleDecoderFactory decoderFactory;
   private final FormatHolder formatHolder;
 
@@ -101,7 +93,7 @@
    *     using {@link android.app.Activity#getMainLooper()}. Null may be passed if the output
    *     should be called directly on the player's internal rendering thread.
    */
-  public TextRenderer(Output output, Looper outputLooper) {
+  public TextRenderer(TextOutput output, Looper outputLooper) {
     this(output, outputLooper, SubtitleDecoderFactory.DEFAULT);
   }
 
@@ -114,7 +106,8 @@ public TextRenderer(Output output, Looper outputLooper) {
    *     should be called directly on the player's internal rendering thread.
    * @param decoderFactory A factory from which to obtain {@link SubtitleDecoder} instances.
    */
-  public TextRenderer(Output output, Looper outputLooper, SubtitleDecoderFactory decoderFactory) {
+  public TextRenderer(TextOutput output, Looper outputLooper,
+      SubtitleDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_TEXT);
     this.output = Assertions.checkNotNull(output);
     this.outputHandler = outputLooper == null ? null : new Handler(outputLooper, this);
@@ -124,9 +117,13 @@ public TextRenderer(Output output, Looper outputLooper, SubtitleDecoderFactory d
 
   @Override
   public int supportsFormat(Format format) {
-    return decoderFactory.supportsFormat(format) ? FORMAT_HANDLED
-        : (MimeTypes.isText(format.sampleMimeType) ? FORMAT_UNSUPPORTED_SUBTYPE
-        : FORMAT_UNSUPPORTED_TYPE);
+    if (decoderFactory.supportsFormat(format)) {
+      return supportsFormatDrm(null, format.drmInitData) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_DRM;
+    } else if (MimeTypes.isText(format.sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_SUBTYPE;
+    } else {
+      return FORMAT_UNSUPPORTED_TYPE;
+    }
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index fe9a5fbc5c..e2c592be6b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -350,7 +350,7 @@ private boolean handleCtrl(byte cc1, byte cc2) {
         repeatableControlSet = false;
         return true;
       } else {
-        // This is a repeatable command, but we haven't see it yet, so set the repeabable control
+        // This is a repeatable command, but we haven't see it yet, so set the repeatable control
         // flag (to ensure we ignore the next one should it be a duplicate) and continue processing
         // the command.
         repeatableControlSet = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
index 8fd70f7a67..030f0cdbb0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -811,43 +811,43 @@ public DtvCcPacket(int sequenceNumber, int packetSize) {
     private static final int PEN_OFFSET_NORMAL = 1;
 
     // The window style properties are specified in the CEA-708 specification.
-    private static final int[] WINDOW_STYLE_JUSTIFICATION = new int[]{
+    private static final int[] WINDOW_STYLE_JUSTIFICATION = new int[] {
         JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_LEFT,
         JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_CENTER,
         JUSTIFICATION_LEFT
     };
-    private static final int[] WINDOW_STYLE_PRINT_DIRECTION = new int[]{
+    private static final int[] WINDOW_STYLE_PRINT_DIRECTION = new int[] {
         DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
         DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
         DIRECTION_TOP_TO_BOTTOM
     };
-    private static final int[] WINDOW_STYLE_SCROLL_DIRECTION = new int[]{
+    private static final int[] WINDOW_STYLE_SCROLL_DIRECTION = new int[] {
         DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
         DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
         DIRECTION_RIGHT_TO_LEFT
     };
-    private static final boolean[] WINDOW_STYLE_WORD_WRAP = new boolean[]{
+    private static final boolean[] WINDOW_STYLE_WORD_WRAP = new boolean[] {
         false, false, false, true, true, true, false
     };
-    private static final int[] WINDOW_STYLE_FILL = new int[]{
+    private static final int[] WINDOW_STYLE_FILL = new int[] {
         COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
         COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK
     };
 
     // The pen style properties are specified in the CEA-708 specification.
-    private static final int[] PEN_STYLE_FONT_STYLE = new int[]{
+    private static final int[] PEN_STYLE_FONT_STYLE = new int[] {
         PEN_FONT_STYLE_DEFAULT, PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS,
         PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS, PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
         PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS,
         PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
         PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS
     };
-    private static final int[] PEN_STYLE_EDGE_TYPE = new int[]{
+    private static final int[] PEN_STYLE_EDGE_TYPE = new int[] {
         BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE,
         BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_UNIFORM,
         BORDER_AND_EDGE_TYPE_UNIFORM
     };
-    private static final int[] PEN_STYLE_BACKGROUND = new int[]{
+    private static final int[] PEN_STYLE_BACKGROUND = new int[] {
         COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
         COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_TRANSPARENT};
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
index 130c7461f9..ddb3804c3e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
@@ -82,7 +82,7 @@ public static void consume(long presentationTimeUs, ParsableByteArray seiBuffer,
    * number of 0xFF bytes and T is the value of the terminating byte.
    *
    * @param buffer The buffer from which to read the value.
-   * @returns The read value, or -1 if the end of the buffer is reached before a value is read.
+   * @return The read value, or -1 if the end of the buffer is reached before a value is read.
    */
   private static int readNon255TerminatedValue(ParsableByteArray buffer) {
     int b;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
index d2f5a67c27..eec4a1269c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
@@ -53,13 +53,14 @@ public SsaDecoder() {
   }
 
   /**
-   * @param initializationData Optional initialization data for the decoder. If not null, the
-   *     initialization data must consist of two byte arrays. The first must contain an SSA format
-   *     line. The second must contain an SSA header that will be assumed common to all samples.
+   * @param initializationData Optional initialization data for the decoder. If not null or empty,
+   *     the initialization data must consist of two byte arrays. The first must contain an SSA
+   *     format line. The second must contain an SSA header that will be assumed common to all
+   *     samples.
    */
   public SsaDecoder(List<byte[]> initializationData) {
     super("SsaDecoder");
-    if (initializationData != null) {
+    if (initializationData != null && !initializationData.isEmpty()) {
       haveInitializationData = true;
       String formatLine = new String(initializationData.get(0));
       Assertions.checkArgument(formatLine.startsWith(FORMAT_LINE_PREFIX));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
index 4d0cd17304..d0c3eda494 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
@@ -56,9 +56,13 @@ public static long parseTimestampUs(String timestamp) throws NumberFormatExcepti
     String[] parts = timestamp.split("\\.", 2);
     String[] subparts = parts[0].split(":");
     for (String subpart : subparts) {
-      value = value * 60 + Long.parseLong(subpart);
+      value = (value * 60) + Long.parseLong(subpart);
     }
-    return (value * 1000 + Long.parseLong(parts[1])) * 1000;
+    value *= 1000;
+    if (parts.length == 2) {
+      value += Long.parseLong(parts[1]);
+    }
+    return value * 1000;
   }
 
   /**
@@ -74,7 +78,7 @@ public static float parsePercentage(String s) throws NumberFormatException {
     }
     return Float.parseFloat(s.substring(0, s.length() - 1)) / 100;
   }
-  
+
   /**
    * Reads lines up to and including the next WebVTT cue header.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index 12f5952dd0..f9eddab286 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -40,6 +40,7 @@
     private final int maxDurationForQualityDecreaseMs;
     private final int minDurationToRetainAfterDiscardMs;
     private final float bandwidthFraction;
+    private final float bufferedFractionToLiveEdgeForQualityIncrease;
 
     /**
      * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
@@ -48,7 +49,9 @@ public Factory(BandwidthMeter bandwidthMeter) {
       this (bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
           DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
           DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-          DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
+          DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+          DEFAULT_BANDWIDTH_FRACTION,
+          DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE);
     }
 
     /**
@@ -70,19 +73,53 @@ public Factory(BandwidthMeter bandwidthMeter) {
     public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
         int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
         int minDurationToRetainAfterDiscardMs, float bandwidthFraction) {
+      this (bandwidthMeter, maxInitialBitrate, minDurationForQualityIncreaseMs,
+          maxDurationForQualityDecreaseMs, minDurationToRetainAfterDiscardMs,
+          bandwidthFraction, DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE);
+    }
+
+    /**
+     * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+     * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed
+     *     when a bandwidth estimate is unavailable.
+     * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for
+     *     the selected track to switch to one of higher quality.
+     * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for
+     *     the selected track to switch to one of lower quality.
+     * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
+     *     quality, the selection may indicate that media already buffered at the lower quality can
+     *     be discarded to speed up the switch. This is the minimum duration of media that must be
+     *     retained at the lower quality.
+     * @param bandwidthFraction The fraction of the available bandwidth that the selection should
+     *     consider available for use. Setting to a value less than 1 is recommended to account
+     *     for inaccuracies in the bandwidth estimator.
+     * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of
+     *     the duration from current playback position to the live edge that has to be buffered
+     *     before the selected track can be switched to one of higher quality. This parameter is
+     *     only applied when the playback position is closer to the live edge than
+     *     {@code minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a
+     *     higher quality from happening.
+     */
+    public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
+        int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
+        int minDurationToRetainAfterDiscardMs, float bandwidthFraction,
+        float bufferedFractionToLiveEdgeForQualityIncrease) {
       this.bandwidthMeter = bandwidthMeter;
       this.maxInitialBitrate = maxInitialBitrate;
       this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs;
       this.maxDurationForQualityDecreaseMs = maxDurationForQualityDecreaseMs;
       this.minDurationToRetainAfterDiscardMs = minDurationToRetainAfterDiscardMs;
       this.bandwidthFraction = bandwidthFraction;
+      this.bufferedFractionToLiveEdgeForQualityIncrease =
+          bufferedFractionToLiveEdgeForQualityIncrease;
     }
 
     @Override
     public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
       return new AdaptiveTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
           minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
-          minDurationToRetainAfterDiscardMs, bandwidthFraction);
+          minDurationToRetainAfterDiscardMs, bandwidthFraction,
+          bufferedFractionToLiveEdgeForQualityIncrease);
     }
 
   }
@@ -92,6 +129,7 @@ public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... trac
   public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
   public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
   public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;
+  public static final float DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE = 0.75f;
 
   private final BandwidthMeter bandwidthMeter;
   private final int maxInitialBitrate;
@@ -99,6 +137,7 @@ public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... trac
   private final long maxDurationForQualityDecreaseUs;
   private final long minDurationToRetainAfterDiscardUs;
   private final float bandwidthFraction;
+  private final float bufferedFractionToLiveEdgeForQualityIncrease;
 
   private int selectedIndex;
   private int reason;
@@ -114,7 +153,9 @@ public AdaptiveTrackSelection(TrackGroup group, int[] tracks,
     this (group, tracks, bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
         DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
         DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-        DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
+        DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+        DEFAULT_BANDWIDTH_FRACTION,
+        DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE);
   }
 
   /**
@@ -135,11 +176,17 @@ public AdaptiveTrackSelection(TrackGroup group, int[] tracks,
    * @param bandwidthFraction The fraction of the available bandwidth that the selection should
    *     consider available for use. Setting to a value less than 1 is recommended to account
    *     for inaccuracies in the bandwidth estimator.
+   * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of
+   *     the duration from current playback position to the live edge that has to be buffered
+   *     before the selected track can be switched to one of higher quality. This parameter is
+   *     only applied when the playback position is closer to the live edge than
+   *     {@code minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a
+   *     higher quality from happening.
    */
   public AdaptiveTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter,
       int maxInitialBitrate, long minDurationForQualityIncreaseMs,
       long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
-      float bandwidthFraction) {
+      float bandwidthFraction, float bufferedFractionToLiveEdgeForQualityIncrease) {
     super(group, tracks);
     this.bandwidthMeter = bandwidthMeter;
     this.maxInitialBitrate = maxInitialBitrate;
@@ -147,12 +194,15 @@ public AdaptiveTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter ban
     this.maxDurationForQualityDecreaseUs = maxDurationForQualityDecreaseMs * 1000L;
     this.minDurationToRetainAfterDiscardUs = minDurationToRetainAfterDiscardMs * 1000L;
     this.bandwidthFraction = bandwidthFraction;
+    this.bufferedFractionToLiveEdgeForQualityIncrease =
+        bufferedFractionToLiveEdgeForQualityIncrease;
     selectedIndex = determineIdealSelectedIndex(Long.MIN_VALUE);
     reason = C.SELECTION_REASON_INITIAL;
   }
 
   @Override
-  public void updateSelectedTrack(long bufferedDurationUs) {
+  public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
+      long availableDurationUs) {
     long nowMs = SystemClock.elapsedRealtime();
     // Stash the current selection, then make a new one.
     int currentSelectedIndex = selectedIndex;
@@ -160,12 +210,13 @@ public void updateSelectedTrack(long bufferedDurationUs) {
     if (selectedIndex == currentSelectedIndex) {
       return;
     }
+
     if (!isBlacklisted(currentSelectedIndex, nowMs)) {
       // Revert back to the current selection if conditions are not suitable for switching.
       Format currentFormat = getFormat(currentSelectedIndex);
       Format selectedFormat = getFormat(selectedIndex);
       if (selectedFormat.bitrate > currentFormat.bitrate
-          && bufferedDurationUs < minDurationForQualityIncreaseUs) {
+          && bufferedDurationUs < minDurationForQualityIncreaseUs(availableDurationUs)) {
         // The selected track is a higher quality, but we have insufficient buffer to safely switch
         // up. Defer switching up for now.
         selectedIndex = currentSelectedIndex;
@@ -251,4 +302,12 @@ private int determineIdealSelectedIndex(long nowMs) {
     return lowestBitrateNonBlacklistedIndex;
   }
 
+  private long minDurationForQualityIncreaseUs(long availableDurationUs) {
+    boolean isAvailableDurationTooShort = availableDurationUs != C.TIME_UNSET
+        && availableDurationUs <= minDurationForQualityIncreaseUs;
+    return isAvailableDurationTooShort
+        ? (long) (availableDurationUs * bufferedFractionToLiveEdgeForQualityIncrease)
+        : minDurationForQualityIncreaseUs;
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index ba0f63b0bb..c789caded4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -127,6 +127,11 @@
     public final boolean viewportOrientationMayChange;
 
     // General
+    /**
+     * Whether to force selection of the single lowest bitrate audio and video tracks that comply
+     * with all other constraints.
+     */
+    public final boolean forceLowestBitrate;
     /**
      * Whether to allow adaptive selections containing mixed mime types.
      */
@@ -145,6 +150,7 @@
      * <ul>
      *   <li>No preferred audio language is set.</li>
      *   <li>No preferred text language is set.</li>
+     *   <li>Lowest bitrate track selections are not forced.</li>
      *   <li>Adaptation between different mime types is not allowed.</li>
      *   <li>Non seamless adaptation is allowed.</li>
      *   <li>No max limit for video width/height.</li>
@@ -155,13 +161,14 @@
      * </ul>
      */
     public Parameters() {
-      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, true,
-          true, Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+      this(null, null, false, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE,
+          true, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true);
     }
 
     /**
      * @param preferredAudioLanguage See {@link #preferredAudioLanguage}
      * @param preferredTextLanguage See {@link #preferredTextLanguage}
+     * @param forceLowestBitrate See {@link #forceLowestBitrate}.
      * @param allowMixedMimeAdaptiveness See {@link #allowMixedMimeAdaptiveness}
      * @param allowNonSeamlessAdaptiveness See {@link #allowNonSeamlessAdaptiveness}
      * @param maxVideoWidth See {@link #maxVideoWidth}
@@ -174,12 +181,14 @@ public Parameters() {
      * @param viewportOrientationMayChange See {@link #viewportOrientationMayChange}
      */
     public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
-        boolean allowMixedMimeAdaptiveness, boolean allowNonSeamlessAdaptiveness,
-        int maxVideoWidth, int maxVideoHeight, int maxVideoBitrate,
-        boolean exceedVideoConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary,
-        int viewportWidth, int viewportHeight, boolean viewportOrientationMayChange) {
+        boolean forceLowestBitrate, boolean allowMixedMimeAdaptiveness,
+        boolean allowNonSeamlessAdaptiveness, int maxVideoWidth, int maxVideoHeight,
+        int maxVideoBitrate, boolean exceedVideoConstraintsIfNecessary,
+        boolean exceedRendererCapabilitiesIfNecessary, int viewportWidth, int viewportHeight,
+        boolean viewportOrientationMayChange) {
       this.preferredAudioLanguage = preferredAudioLanguage;
       this.preferredTextLanguage = preferredTextLanguage;
+      this.forceLowestBitrate = forceLowestBitrate;
       this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
       this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
       this.maxVideoWidth = maxVideoWidth;
@@ -193,101 +202,93 @@ public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
     }
 
     /**
-     * Returns an instance with the provided preferred language for audio and forced text tracks.
-     *
-     * @param preferredAudioLanguage The preferred language as defined by RFC 5646. {@code null} to
-     *     select the default track, or first track if there's no default.
-     * @return An instance with the provided preferred language for audio and forced text tracks.
+     * Returns an instance with the provided {@link #preferredAudioLanguage}.
      */
     public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
       preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
       if (TextUtils.equals(preferredAudioLanguage, this.preferredAudioLanguage)) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided preferred language for text tracks.
-     *
-     * @param preferredTextLanguage The preferred language as defined by RFC 5646. {@code null} to
-     *     select the default track, or no track if there's no default.
-     * @return An instance with the provided preferred language for text tracks.
+     * Returns an instance with the provided {@link #preferredTextLanguage}.
      */
     public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
       preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
       if (TextUtils.equals(preferredTextLanguage, this.preferredTextLanguage)) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided mixed mime adaptiveness allowance.
-     *
-     * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
-     * @return An instance with the provided mixed mime adaptiveness allowance.
+     * Returns an instance with the provided {@link #forceLowestBitrate}.
+     */
+    public Parameters withForceLowestBitrate(boolean forceLowestBitrate) {
+      if (forceLowestBitrate == this.forceLowestBitrate) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    }
+
+    /**
+     * Returns an instance with the provided {@link #allowMixedMimeAdaptiveness}.
      */
     public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
       if (allowMixedMimeAdaptiveness == this.allowMixedMimeAdaptiveness) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided seamless adaptiveness allowance.
-     *
-     * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
-     * @return An instance with the provided seamless adaptiveness allowance.
+     * Returns an instance with the provided {@link #allowNonSeamlessAdaptiveness}.
      */
     public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
       if (allowNonSeamlessAdaptiveness == this.allowNonSeamlessAdaptiveness) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided max video size.
-     *
-     * @param maxVideoWidth The max video width.
-     * @param maxVideoHeight The max video width.
-     * @return An instance with the provided max video size.
+     * Returns an instance with the provided {@link #maxVideoWidth} and {@link #maxVideoHeight}.
      */
     public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
       if (maxVideoWidth == this.maxVideoWidth && maxVideoHeight == this.maxVideoHeight) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided max video bitrate.
-     *
-     * @param maxVideoBitrate The max video bitrate.
-     * @return An instance with the provided max video bitrate.
+     * Returns an instance with the provided {@link #maxVideoBitrate}.
      */
     public Parameters withMaxVideoBitrate(int maxVideoBitrate) {
       if (maxVideoBitrate == this.maxVideoBitrate) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
@@ -312,48 +313,36 @@ public Parameters withoutVideoSizeConstraints() {
     }
 
     /**
-     * Returns an instance with the provided {@code exceedVideoConstraintsIfNecessary} value.
-     *
-     * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
-     *     selection can be made otherwise.
-     * @return An instance with the provided {@code exceedVideoConstraintsIfNecessary} value.
+     * Returns an instance with the provided {@link #exceedVideoConstraintsIfNecessary}.
      */
     public Parameters withExceedVideoConstraintsIfNecessary(
         boolean exceedVideoConstraintsIfNecessary) {
       if (exceedVideoConstraintsIfNecessary == this.exceedVideoConstraintsIfNecessary) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided {@code exceedRendererCapabilitiesIfNecessary} value.
-     *
-     * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
-     *     selection can be made otherwise.
-     * @return An instance with the provided {@code exceedRendererCapabilitiesIfNecessary} value.
+     * Returns an instance with the provided {@link #exceedRendererCapabilitiesIfNecessary}.
      */
     public Parameters withExceedRendererCapabilitiesIfNecessary(
         boolean exceedRendererCapabilitiesIfNecessary) {
       if (exceedRendererCapabilitiesIfNecessary == this.exceedRendererCapabilitiesIfNecessary) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided viewport size.
-     *
-     * @param viewportWidth Viewport width in pixels.
-     * @param viewportHeight Viewport height in pixels.
-     * @param viewportOrientationMayChange Whether orientation may change during playback.
-     * @return An instance with the provided viewport size.
+     * Returns an instance with the provided {@link #viewportWidth}, {@link #viewportHeight} and
+     * {@link #viewportOrientationMayChange}.
      */
     public Parameters withViewportSize(int viewportWidth, int viewportHeight,
         boolean viewportOrientationMayChange) {
@@ -361,7 +350,7 @@ public Parameters withViewportSize(int viewportWidth, int viewportHeight,
           && viewportOrientationMayChange == this.viewportOrientationMayChange) {
         return this;
       }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
           maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
           viewportWidth, viewportHeight, viewportOrientationMayChange);
@@ -371,7 +360,7 @@ public Parameters withViewportSize(int viewportWidth, int viewportHeight,
      * Returns an instance where the viewport size is obtained from the provided {@link Context}.
      *
      * @param context The context to obtain the viewport size from.
-     * @param viewportOrientationMayChange Whether orientation may change during playback.
+     * @param viewportOrientationMayChange See {@link #viewportOrientationMayChange}.
      * @return An instance where the viewport size is obtained from the provided {@link Context}.
      */
     public Parameters withViewportSizeFromContext(Context context,
@@ -399,7 +388,8 @@ public boolean equals(Object obj) {
         return false;
       }
       Parameters other = (Parameters) obj;
-      return allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
+      return forceLowestBitrate == other.forceLowestBitrate
+          && allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
           && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
           && maxVideoWidth == other.maxVideoWidth && maxVideoHeight == other.maxVideoHeight
           && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
@@ -415,6 +405,7 @@ public boolean equals(Object obj) {
     public int hashCode() {
       int result = preferredAudioLanguage.hashCode();
       result = 31 * result + preferredTextLanguage.hashCode();
+      result = 31 * result + (forceLowestBitrate ? 1 : 0);
       result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
       result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
       result = 31 * result + maxVideoWidth;
@@ -568,7 +559,7 @@ protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilit
       TrackGroupArray groups, int[][] formatSupport, Parameters params,
       TrackSelection.Factory adaptiveTrackSelectionFactory) throws ExoPlaybackException {
     TrackSelection selection = null;
-    if (adaptiveTrackSelectionFactory != null) {
+    if (!params.forceLowestBitrate && adaptiveTrackSelectionFactory != null) {
       selection = selectAdaptiveVideoTrack(rendererCapabilities, groups, formatSupport,
           params, adaptiveTrackSelectionFactory);
     }
@@ -709,19 +700,21 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
           }
           boolean selectTrack = trackScore > selectedTrackScore;
           if (trackScore == selectedTrackScore) {
-            // Use the pixel count as a tie breaker (or bitrate if pixel counts are tied). If we're
-            // within constraints prefer a higher pixel count (or bitrate), else prefer a lower
-            // count (or bitrate). If still tied then prefer the first track (i.e. the one that's
-            // already selected).
-            int comparisonResult;
-            int formatPixelCount = format.getPixelCount();
-            if (formatPixelCount != selectedPixelCount) {
-              comparisonResult = compareFormatValues(format.getPixelCount(), selectedPixelCount);
+            if (params.forceLowestBitrate) {
+              // Use bitrate as a tie breaker, preferring the lower bitrate.
+              selectTrack = compareFormatValues(format.bitrate, selectedBitrate) < 0;
             } else {
-              comparisonResult = compareFormatValues(format.bitrate, selectedBitrate);
+              // Use the pixel count as a tie breaker (or bitrate if pixel counts are tied). If
+              // we're within constraints prefer a higher pixel count (or bitrate), else prefer a
+              // lower count (or bitrate). If still tied then prefer the first track (i.e. the one
+              // that's already selected).
+              int formatPixelCount = format.getPixelCount();
+              int comparisonResult = formatPixelCount != selectedPixelCount
+                  ? compareFormatValues(formatPixelCount, selectedPixelCount)
+                  : compareFormatValues(format.bitrate, selectedBitrate);
+              selectTrack = isWithinCapabilities && isWithinConstraints
+                  ? comparisonResult > 0 : comparisonResult < 0;
             }
-            selectTrack = isWithinCapabilities && isWithinConstraints
-                ? comparisonResult > 0 : comparisonResult < 0;
           }
           if (selectTrack) {
             selectedGroup = trackGroup;
@@ -769,9 +762,9 @@ private static int compareFormatValues(int first, int second) {
   protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
       Parameters params, TrackSelection.Factory adaptiveTrackSelectionFactory)
       throws ExoPlaybackException {
-    int selectedGroupIndex = C.INDEX_UNSET;
     int selectedTrackIndex = C.INDEX_UNSET;
-    int selectedTrackScore = 0;
+    int selectedGroupIndex = C.INDEX_UNSET;
+    AudioTrackScore selectedTrackScore = null;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
       int[] trackFormatSupport = formatSupport[groupIndex];
@@ -779,9 +772,9 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
-          int trackScore = getAudioTrackScore(trackFormatSupport[trackIndex],
-              params.preferredAudioLanguage, format);
-          if (trackScore > selectedTrackScore) {
+          AudioTrackScore trackScore =
+              new AudioTrackScore(format, params, trackFormatSupport[trackIndex]);
+          if (selectedTrackScore == null || trackScore.compareTo(selectedTrackScore) > 0) {
             selectedGroupIndex = groupIndex;
             selectedTrackIndex = trackIndex;
             selectedTrackScore = trackScore;
@@ -795,7 +788,7 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
     }
 
     TrackGroup selectedGroup = groups.get(selectedGroupIndex);
-    if (adaptiveTrackSelectionFactory != null) {
+    if (!params.forceLowestBitrate && adaptiveTrackSelectionFactory != null) {
       // If the group of the track with the highest score allows it, try to enable adaptation.
       int[] adaptiveTracks = getAdaptiveAudioTracks(selectedGroup,
           formatSupport[selectedGroupIndex], params.allowMixedMimeAdaptiveness);
@@ -807,27 +800,6 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
     return new FixedTrackSelection(selectedGroup, selectedTrackIndex);
   }
 
-  private static int getAudioTrackScore(int formatSupport, String preferredLanguage,
-      Format format) {
-    boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
-    int trackScore;
-    if (formatHasLanguage(format, preferredLanguage)) {
-      if (isDefault) {
-        trackScore = 4;
-      } else {
-        trackScore = 3;
-      }
-    } else if (isDefault) {
-      trackScore = 2;
-    } else {
-      trackScore = 1;
-    }
-    if (isSupported(formatSupport, false)) {
-      trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
-    }
-    return trackScore;
-  }
-
   private static int[] getAdaptiveAudioTracks(TrackGroup group, int[] formatSupport,
       boolean allowMixedMimeTypes) {
     int selectedConfigurationTrackCount = 0;
@@ -1093,6 +1065,103 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
     }
   }
 
+  /**
+   * A representation of how well a track fits with our track selection {@link Parameters}.
+   *
+   * <p>This is used to rank different audio tracks relatively with each other.
+   */
+  private static final class AudioTrackScore implements Comparable<AudioTrackScore> {
+    private final Parameters parameters;
+    private final int withinRendererCapabilitiesScore;
+    private final int matchLanguageScore;
+    private final int defaultSelectionFlagScore;
+    private final int channelCount;
+    private final int sampleRate;
+    private final int bitrate;
+
+    public AudioTrackScore(Format format, Parameters parameters, int formatSupport) {
+      this.parameters = parameters;
+      withinRendererCapabilitiesScore = isSupported(formatSupport, false) ? 1 : 0;
+      matchLanguageScore = formatHasLanguage(format, parameters.preferredAudioLanguage) ? 1 : 0;
+      defaultSelectionFlagScore = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0 ? 1 : 0;
+      channelCount = format.channelCount;
+      sampleRate = format.sampleRate;
+      bitrate = format.bitrate;
+    }
+
+    /**
+     * Compares the score of the current track format with another {@link AudioTrackScore}.
+     *
+     * @param other The other score to compare to.
+     * @return A positive integer if this score is better than the other. Zero if they are
+     *     equal. A negative integer if this score is worse than the other.
+     */
+    @Override
+    public int compareTo(AudioTrackScore other) {
+      if (this.withinRendererCapabilitiesScore != other.withinRendererCapabilitiesScore) {
+        return compareInts(this.withinRendererCapabilitiesScore,
+            other.withinRendererCapabilitiesScore);
+      } else if (this.matchLanguageScore != other.matchLanguageScore) {
+        return compareInts(this.matchLanguageScore, other.matchLanguageScore);
+      } else if (this.defaultSelectionFlagScore != other.defaultSelectionFlagScore) {
+        return compareInts(this.defaultSelectionFlagScore, other.defaultSelectionFlagScore);
+      } else if (parameters.forceLowestBitrate) {
+        return compareInts(other.bitrate, this.bitrate);
+      } else {
+        // If the format are within renderer capabilities, prefer higher values of channel count,
+        // sample rate and bit rate in that order. Otherwise, prefer lower values.
+        int resultSign = withinRendererCapabilitiesScore == 1 ? 1 : -1;
+        if (this.channelCount != other.channelCount) {
+          return resultSign * compareInts(this.channelCount, other.channelCount);
+        } else if (this.sampleRate != other.sampleRate) {
+          return resultSign * compareInts(this.sampleRate, other.sampleRate);
+        }
+        return resultSign * compareInts(this.bitrate, other.bitrate);
+      }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      AudioTrackScore that = (AudioTrackScore) o;
+
+      return withinRendererCapabilitiesScore == that.withinRendererCapabilitiesScore
+          && matchLanguageScore == that.matchLanguageScore
+          && defaultSelectionFlagScore == that.defaultSelectionFlagScore
+          && channelCount == that.channelCount && sampleRate == that.sampleRate
+          && bitrate == that.bitrate;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = withinRendererCapabilitiesScore;
+      result = 31 * result + matchLanguageScore;
+      result = 31 * result + defaultSelectionFlagScore;
+      result = 31 * result + channelCount;
+      result = 31 * result + sampleRate;
+      result = 31 * result + bitrate;
+      return result;
+    }
+  }
+
+  /**
+   * Compares two integers in a safe way and avoiding potential overflow.
+   *
+   * @param first The first value.
+   * @param second The second value.
+   * @return A negative integer if the first value is less than the second. Zero if they are equal.
+   *     A positive integer if the first value is greater than the second.
+   */
+  private static int compareInts(int first, int second) {
+    return first > second ? 1 : (second > first ? -1 : 0);
+  }
+
   private static final class AudioConfigurationTuple {
 
     public final int channelCount;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
index de1b500c61..50873d372d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
@@ -78,7 +78,8 @@ public FixedTrackSelection(TrackGroup group, int track, int reason, Object data)
   }
 
   @Override
-  public void updateSelectedTrack(long bufferedDurationUs) {
+  public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
+      long availableDurationUs) {
     // Do nothing.
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index d518b5a6be..5d120990fc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -573,6 +573,8 @@ public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCap
       }
     }
 
+    boolean[] rendererEnabled = determineEnabledRenderers(rendererCapabilities, trackSelections);
+
     // Package up the track information and selections.
     MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
         rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
@@ -583,14 +585,26 @@ public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCap
     RendererConfiguration[] rendererConfigurations =
         new RendererConfiguration[rendererCapabilities.length];
     for (int i = 0; i < rendererCapabilities.length; i++) {
-      rendererConfigurations[i] = trackSelections[i] != null ? RendererConfiguration.DEFAULT : null;
+      rendererConfigurations[i] = rendererEnabled[i] ? RendererConfiguration.DEFAULT : null;
     }
     // Configure audio and video renderers to use tunneling if appropriate.
     maybeConfigureRenderersForTunneling(rendererCapabilities, rendererTrackGroupArrays,
         rendererFormatSupports, rendererConfigurations, trackSelections, tunnelingAudioSessionId);
 
-    return new TrackSelectorResult(trackGroups, new TrackSelectionArray(trackSelections),
-        mappedTrackInfo, rendererConfigurations);
+    return new TrackSelectorResult(trackGroups, rendererEnabled,
+        new TrackSelectionArray(trackSelections), mappedTrackInfo, rendererConfigurations);
+  }
+
+  private boolean[] determineEnabledRenderers(RendererCapabilities[] rendererCapabilities,
+      TrackSelection[] trackSelections) {
+    boolean[] rendererEnabled = new boolean[trackSelections.length];
+    for (int i = 0; i < rendererEnabled.length; i++) {
+      boolean forceRendererDisabled = rendererDisabledFlags.get(i);
+      rendererEnabled[i] = !forceRendererDisabled
+          && (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE
+          || trackSelections[i] != null);
+    }
+    return rendererEnabled;
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
index 5c7625d6b4..d11344a6f6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
@@ -88,7 +88,8 @@ public RandomTrackSelection(TrackGroup group, int[] tracks, Random random) {
   }
 
   @Override
-  public void updateSelectedTrack(long bufferedDurationUs) {
+  public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
+      long availableDurationUs) {
     // Count the number of non-blacklisted formats.
     long nowMs = SystemClock.elapsedRealtime();
     int nonBlacklistedFormatCount = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
index fe66946a65..ad02b6c775 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
@@ -26,7 +26,7 @@
  * {@link TrackGroup}, and a possibly varying individual selected track from the subset.
  * <p>
  * Tracks belonging to the subset are exposed in decreasing bandwidth order. The individual selected
- * track may change as a result of calling {@link #updateSelectedTrack(long)}.
+ * track may change as a result of calling {@link #updateSelectedTrack(long, long, long)}.
  */
 public interface TrackSelection {
 
@@ -125,9 +125,21 @@
   /**
    * Updates the selected track.
    *
-   * @param bufferedDurationUs The duration of media currently buffered in microseconds.
+   * @param playbackPositionUs The current playback position in microseconds. If playback of the
+   *     period to which this track selection belongs has not yet started, the value will be the
+   *     starting position in the period minus the duration of any media in previous periods still
+   *     to be played.
+   * @param bufferedDurationUs The duration of media currently buffered from the current playback
+   *     position, in microseconds. Note that the next load position can be calculated as
+   *     {@code (playbackPositionUs + bufferedDurationUs)}.
+   * @param availableDurationUs The duration of media available for buffering from the current
+   *     playback position, in microseconds, or {@link C#TIME_UNSET} if media can be buffered
+   *     to the end of the current period. Note that if not set to {@link C#TIME_UNSET}, the
+   *     position up to which media is available for buffering can be calculated as
+   *     {@code (playbackPositionUs + availableDurationUs)}.
    */
-  void updateSelectedTrack(long bufferedDurationUs);
+  void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
+      long availableDurationUs);
 
   /**
    * May be called periodically by sources that load media in discrete {@link MediaChunk}s and
@@ -140,7 +152,10 @@
    * significantly higher quality. Discarding chunks may allow faster switching to a higher quality
    * track in this case.
    *
-   * @param playbackPositionUs The current playback position in microseconds.
+   * @param playbackPositionUs The current playback position in microseconds. If playback of the
+   *     period to which this track selection belongs has not yet started, the value will be the
+   *     starting position in the period minus the duration of any media in previous periods still
+   *     to be played.
    * @param queue The queue of buffered {@link MediaChunk}s. Must not be modified.
    * @return The number of chunks to retain in the queue.
    */
@@ -148,10 +163,10 @@
 
   /**
    * Attempts to blacklist the track at the specified index in the selection, making it ineligible
-   * for selection by calls to {@link #updateSelectedTrack(long)} for the specified period of time.
-   * Blacklisting will fail if all other tracks are currently blacklisted. If blacklisting the
-   * currently selected track, note that it will remain selected until the next call to
-   * {@link #updateSelectedTrack(long)}.
+   * for selection by calls to {@link #updateSelectedTrack(long, long, long)} for the specified
+   * period of time. Blacklisting will fail if all other tracks are currently blacklisted. If
+   * blacklisting the currently selected track, note that it will remain selected until the next
+   * call to {@link #updateSelectedTrack(long, long, long)}.
    *
    * @param index The index of the track in the selection.
    * @param blacklistDurationMs The duration of time for which the track should be blacklisted, in
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
index cab9a689be..801f5b9584 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -28,6 +28,10 @@
    * The track groups that were provided to the {@link TrackSelector}.
    */
   public final TrackGroupArray groups;
+  /**
+   * An array containing whether each renderer is enabled after the track selection operation.
+   */
+  public final boolean[] renderersEnabled;
   /**
    * A {@link TrackSelectionArray} containing the track selection for each renderer.
    */
@@ -38,21 +42,25 @@
    */
   public final Object info;
   /**
-   * A {@link RendererConfiguration} for each renderer, to be used with the selections.
+   * A {@link RendererConfiguration} for each enabled renderer, to be used with the selections.
    */
   public final RendererConfiguration[] rendererConfigurations;
 
   /**
    * @param groups The track groups provided to the {@link TrackSelector}.
+   * @param renderersEnabled An array containing whether each renderer is enabled after the track
+   *     selection operation.
    * @param selections A {@link TrackSelectionArray} containing the selection for each renderer.
    * @param info An opaque object that will be returned to
    *     {@link TrackSelector#onSelectionActivated(Object)} should the selection be activated.
-   * @param rendererConfigurations A {@link RendererConfiguration} for each renderer, to be used
-   *     with the selections.
+   * @param rendererConfigurations A {@link RendererConfiguration} for each enabled renderer,
+   *     to be used with the selections.
    */
-  public TrackSelectorResult(TrackGroupArray groups, TrackSelectionArray selections, Object info,
+  public TrackSelectorResult(TrackGroupArray groups, boolean[] renderersEnabled,
+      TrackSelectionArray selections, Object info,
       RendererConfiguration[] rendererConfigurations) {
     this.groups = groups;
+    this.renderersEnabled = renderersEnabled;
     this.selections = selections;
     this.info = info;
     this.rendererConfigurations = rendererConfigurations;
@@ -79,8 +87,8 @@ public boolean isEquivalent(TrackSelectorResult other) {
 
   /**
    * Returns whether this result is equivalent to {@code other} for the renderer at the given index.
-   * The results are equivalent if they have equal track selections and configurations for the
-   * renderer.
+   * The results are equivalent if they have equal renderersEnabled array, track selections, and
+   * configurations for the renderer.
    *
    * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
    *     will be returned.
@@ -92,7 +100,8 @@ public boolean isEquivalent(TrackSelectorResult other, int index) {
     if (other == null) {
       return false;
     }
-    return Util.areEqual(selections.get(index), other.selections.get(index))
+    return renderersEnabled[index] == other.renderersEnabled[index]
+        && Util.areEqual(selections.get(index), other.selections.get(index))
         && Util.areEqual(rendererConfigurations[index], other.rendererConfigurations[index]);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
index c37599eccc..87642e0eba 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
@@ -24,7 +24,7 @@
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.InputStream;
+import java.nio.channels.FileChannel;
 
 /**
  * A {@link DataSource} for reading from a content URI.
@@ -47,7 +47,7 @@ public ContentDataSourceException(IOException cause) {
 
   private Uri uri;
   private AssetFileDescriptor assetFileDescriptor;
-  private InputStream inputStream;
+  private FileInputStream inputStream;
   private long bytesRemaining;
   private boolean opened;
 
@@ -88,14 +88,11 @@ public long open(DataSpec dataSpec) throws ContentDataSourceException {
       } else {
         long assetFileDescriptorLength = assetFileDescriptor.getLength();
         if (assetFileDescriptorLength == AssetFileDescriptor.UNKNOWN_LENGTH) {
-          // The asset must extend to the end of the file.
-          bytesRemaining = inputStream.available();
-          if (bytesRemaining == 0) {
-            // FileInputStream.available() returns 0 if the remaining length cannot be determined,
-            // or if it's greater than Integer.MAX_VALUE. We don't know the true length in either
-            // case, so treat as unbounded.
-            bytesRemaining = C.LENGTH_UNSET;
-          }
+          // The asset must extend to the end of the file. If FileInputStream.getChannel().size()
+          // returns 0 then the remaining length cannot be determined.
+          FileChannel channel = inputStream.getChannel();
+          long channelSize = channel.size();
+          bytesRemaining = channelSize == 0 ? C.LENGTH_UNSET : channelSize - channel.position();
         } else {
           bytesRemaining = assetFileDescriptorLength - skipped;
         }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
new file mode 100644
index 0000000000..c547625819
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import android.net.Uri;
+import android.util.Base64;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
+import java.io.IOException;
+import java.net.URLDecoder;
+
+/**
+ * A {@link DataSource} for reading data URLs, as defined by RFC 2397.
+ */
+public final class DataSchemeDataSource implements DataSource {
+
+  public static final String SCHEME_DATA = "data";
+
+  private DataSpec dataSpec;
+  private int bytesRead;
+  private byte[] data;
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    this.dataSpec = dataSpec;
+    Uri uri = dataSpec.uri;
+    String scheme = uri.getScheme();
+    if (!SCHEME_DATA.equals(scheme)) {
+      throw new ParserException("Unsupported scheme: " + scheme);
+    }
+    String[] uriParts = uri.getSchemeSpecificPart().split(",");
+    if (uriParts.length > 2) {
+      throw new ParserException("Unexpected URI format: " + uri);
+    }
+    String dataString = uriParts[1];
+    if (uriParts[0].contains(";base64")) {
+      try {
+        data = Base64.decode(dataString, 0);
+      } catch (IllegalArgumentException e) {
+        throw new ParserException("Error while parsing Base64 encoded string: " + dataString, e);
+      }
+    } else {
+      // TODO: Add support for other charsets.
+      data = URLDecoder.decode(dataString, C.ASCII_NAME).getBytes();
+    }
+    return data.length;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) {
+    if (readLength == 0) {
+      return 0;
+    }
+    int remainingBytes = data.length - bytesRead;
+    if (remainingBytes == 0) {
+      return C.RESULT_END_OF_INPUT;
+    }
+    readLength = Math.min(readLength, remainingBytes);
+    System.arraycopy(data, bytesRead, buffer, offset, readLength);
+    bytesRead += readLength;
+    return readLength;
+  }
+
+  @Override
+  public Uri getUri() {
+    return dataSpec != null ? dataSpec.uri : null;
+  }
+
+  @Override
+  public void close() throws IOException {
+    dataSpec = null;
+    data = null;
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index cbb8ba92a5..853b40f73f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -34,10 +34,11 @@
  * <li>content: For fetching data from a content URI (e.g. content://authority/path/123).
  * <li>rtmp: For fetching data over RTMP. Only supported if the project using ExoPlayer has an
  *     explicit dependency on ExoPlayer's RTMP extension.</li>
+ * <li>data: For parsing data inlined in the URI as defined in RFC 2397.</li>
  * <li>http(s): For fetching data over HTTP and HTTPS (e.g. https://www.something.com/media.mp4), if
  *     constructed using {@link #DefaultDataSource(Context, TransferListener, String, boolean)}, or
  *     any other schemes supported by a base data source if constructed using
- *     {@link #DefaultDataSource(Context, TransferListener, DataSource)}.
+ *     {@link #DefaultDataSource(Context, TransferListener, DataSource)}.</li>
  * </ul>
  */
 public final class DefaultDataSource implements DataSource {
@@ -58,6 +59,7 @@
   private DataSource assetDataSource;
   private DataSource contentDataSource;
   private DataSource rtmpDataSource;
+  private DataSource dataSchemeDataSource;
 
   private DataSource dataSource;
 
@@ -130,6 +132,8 @@ public long open(DataSpec dataSpec) throws IOException {
       dataSource = getContentDataSource();
     } else if (SCHEME_RTMP.equals(scheme)) {
       dataSource = getRtmpDataSource();
+    } else if (DataSchemeDataSource.SCHEME_DATA.equals(scheme)) {
+      dataSource = getDataSchemeDataSource();
     } else {
       dataSource = baseDataSource;
     }
@@ -202,4 +206,11 @@ private DataSource getRtmpDataSource() {
     return rtmpDataSource;
   }
 
+  private DataSource getDataSchemeDataSource() {
+    if (dataSchemeDataSource == null) {
+      dataSchemeDataSource = new DataSchemeDataSource();
+    }
+    return dataSchemeDataSource;
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 02ccfafa89..9e495f42bf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -61,8 +61,8 @@ public UnexpectedLoaderException(Throwable cause) {
     /**
      * Performs the load, returning on completion or cancellation.
      *
-     * @throws IOException
-     * @throws InterruptedException
+     * @throws IOException If the input could not be loaded.
+     * @throws InterruptedException If the thread was interrupted.
      */
     void load() throws IOException, InterruptedException;
 
@@ -380,7 +380,13 @@ public void handleMessage(Message msg) {
           callback.onLoadCanceled(loadable, nowMs, durationMs, false);
           break;
         case MSG_END_OF_SOURCE:
-          callback.onLoadCompleted(loadable, nowMs, durationMs);
+          try {
+            callback.onLoadCompleted(loadable, nowMs, durationMs);
+          } catch (RuntimeException e) {
+            // This should never happen, but handle it anyway.
+            Log.e(TAG, "Unexpected exception handling load completed", e);
+            fatalError = new UnexpectedLoaderException(e);
+          }
           break;
         case MSG_IO_EXCEPTION:
           currentError = (IOException) msg.obj;
@@ -392,6 +398,9 @@ public void handleMessage(Message msg) {
             start(getRetryDelayMillis());
           }
           break;
+        default:
+          // Never happens.
+          break;
       }
     }
 
@@ -420,7 +429,9 @@ public ReleaseTask(ReleaseCallback callback) {
 
     @Override
     public void run() {
-      sendEmptyMessage(0);
+      if (getLooper().getThread().isAlive()) {
+        sendEmptyMessage(0);
+      }
     }
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index adf245d9aa..308340b8b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -72,8 +72,19 @@
    * @param parser Parses the object from the response.
    */
   public ParsingLoadable(DataSource dataSource, Uri uri, int type, Parser<? extends T> parser) {
+    this(dataSource, new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP), type, parser);
+  }
+
+  /**
+   * @param dataSource A {@link DataSource} to use when loading the data.
+   * @param dataSpec The {@link DataSpec} from which the object should be loaded.
+   * @param type See {@link #type}.
+   * @param parser Parses the object from the response.
+   */
+  public ParsingLoadable(DataSource dataSource, DataSpec dataSpec, int type,
+      Parser<? extends T> parser) {
     this.dataSource = dataSource;
-    this.dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP);
+    this.dataSpec = dataSpec;
     this.type = type;
     this.parser = parser;
   }
@@ -108,7 +119,7 @@ public final boolean isLoadCanceled() {
   }
 
   @Override
-  public final void load() throws IOException, InterruptedException {
+  public final void load() throws IOException {
     DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
     try {
       inputStream.open();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
index f2e30d981b..b33fc2b922 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.android.exoplayer2.util;
 
 import android.support.annotation.NonNull;
@@ -105,12 +104,12 @@ public OutputStream startWrite() throws IOException {
     } catch (FileNotFoundException e) {
       File parent = baseName.getParentFile();
       if (!parent.mkdirs()) {
-        throw new IOException("Couldn't create directory " + baseName);
+        throw new IOException("Couldn't create directory " + baseName, e);
       }
       try {
         str = new AtomicFileOutputStream(baseName);
       } catch (FileNotFoundException e2) {
-        throw new IOException("Couldn't create " + baseName);
+        throw new IOException("Couldn't create " + baseName, e2);
       }
     }
     return str;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
index f8d5759c2c..9619ed53ea 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.os.Handler;
+
 /**
  * An interface through which system clocks can be read. The {@link #DEFAULT} implementation
  * must be used for all non-test cases.
@@ -36,4 +38,14 @@
    */
   void sleep(long sleepTimeMs);
 
+  /**
+   * Post a {@link Runnable} on a {@link Handler} thread with a delay measured by this clock.
+   * @see Handler#postDelayed(Runnable, long)
+   *
+   * @param handler The {@link Handler} to post the {@code runnable} on.
+   * @param runnable A {@link Runnable} to be posted.
+   * @param delayMs The delay in milliseconds as measured by this clock.
+   */
+  void postDelayed(Handler handler, Runnable runnable, long delayMs);
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
index 0093c3b826..0514d9dbdc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/CodecSpecificDataUtil.java
@@ -17,6 +17,7 @@
 
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -83,11 +84,27 @@ private CodecSpecificDataUtil() {}
   /**
    * Parses an AudioSpecificConfig, as defined in ISO 14496-3 1.6.2.1
    *
-   * @param audioSpecificConfig The AudioSpecificConfig to parse.
+   * @param audioSpecificConfig A byte array containing the AudioSpecificConfig to parse.
    * @return A pair consisting of the sample rate in Hz and the channel count.
+   * @throws ParserException If the AudioSpecificConfig cannot be parsed as it's not supported.
    */
-  public static Pair<Integer, Integer> parseAacAudioSpecificConfig(byte[] audioSpecificConfig) {
-    ParsableBitArray bitArray = new ParsableBitArray(audioSpecificConfig);
+  public static Pair<Integer, Integer> parseAacAudioSpecificConfig(byte[] audioSpecificConfig)
+      throws ParserException {
+    return parseAacAudioSpecificConfig(new ParsableBitArray(audioSpecificConfig), false);
+  }
+
+  /**
+   * Parses an AudioSpecificConfig, as defined in ISO 14496-3 1.6.2.1
+   *
+   * @param bitArray A {@link ParsableBitArray} containing the AudioSpecificConfig to parse. The
+   *     position is advanced to the end of the AudioSpecificConfig.
+   * @param forceReadToEnd Whether the entire AudioSpecificConfig should be read. Required for
+   *     knowing the length of the configuration payload.
+   * @return A pair consisting of the sample rate in Hz and the channel count.
+   * @throws ParserException If the AudioSpecificConfig cannot be parsed as it's not supported.
+   */
+  public static Pair<Integer, Integer> parseAacAudioSpecificConfig(ParsableBitArray bitArray,
+      boolean forceReadToEnd) throws ParserException {
     int audioObjectType = getAacAudioObjectType(bitArray);
     int sampleRate = getAacSamplingFrequency(bitArray);
     int channelConfiguration = bitArray.readBits(4);
@@ -104,6 +121,41 @@ private CodecSpecificDataUtil() {}
         channelConfiguration = bitArray.readBits(4);
       }
     }
+
+    if (forceReadToEnd) {
+      switch (audioObjectType) {
+        case 1:
+        case 2:
+        case 3:
+        case 4:
+        case 6:
+        case 7:
+        case 17:
+        case 19:
+        case 20:
+        case 21:
+        case 22:
+        case 23:
+          parseGaSpecificConfig(bitArray, audioObjectType, channelConfiguration);
+          break;
+        default:
+          throw new ParserException("Unsupported audio object type: " + audioObjectType);
+      }
+      switch (audioObjectType) {
+        case 17:
+        case 19:
+        case 20:
+        case 21:
+        case 22:
+        case 23:
+          int epConfig = bitArray.readBits(2);
+          if (epConfig == 2 || epConfig == 3) {
+            throw new ParserException("Unsupported epConfig: " + epConfig);
+          }
+          break;
+      }
+    }
+    // For supported containers, bits_to_decode() is always 0.
     int channelCount = AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE[channelConfiguration];
     Assertions.checkArgument(channelCount != AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID);
     return Pair.create(sampleRate, channelCount);
@@ -269,4 +321,32 @@ private static int getAacSamplingFrequency(ParsableBitArray bitArray) {
     return samplingFrequency;
   }
 
+  private static void parseGaSpecificConfig(ParsableBitArray bitArray, int audioObjectType,
+      int channelConfiguration) {
+    bitArray.skipBits(1); // frameLengthFlag.
+    boolean dependsOnCoreDecoder = bitArray.readBit();
+    if (dependsOnCoreDecoder) {
+      bitArray.skipBits(14); // coreCoderDelay.
+    }
+    boolean extensionFlag = bitArray.readBit();
+    if (channelConfiguration == 0) {
+      throw new UnsupportedOperationException(); // TODO: Implement programConfigElement();
+    }
+    if (audioObjectType == 6 || audioObjectType == 20) {
+      bitArray.skipBits(3); // layerNr.
+    }
+    if (extensionFlag) {
+      if (audioObjectType == 22) {
+        bitArray.skipBits(16); // numOfSubFrame (5), layer_length(11).
+      }
+      if (audioObjectType == 17 || audioObjectType == 19 || audioObjectType == 20
+          || audioObjectType == 23) {
+        // aacSectionDataResilienceFlag, aacScalefactorDataResilienceFlag,
+        // aacSpectralDataResilienceFlag.
+        bitArray.skipBits(3);
+      }
+      bitArray.skipBits(1); // extensionFlag3.
+    }
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
index b6c6914c50..262d120af8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.util;
 
 /**
- * A condition variable whose {@link #open()} and {@link #close()} methods return whether they
- * resulted in a change of state.
+ * An interruptible condition variable whose {@link #open()} and {@link #close()} methods return
+ * whether they resulted in a change of state.
  */
 public final class ConditionVariable {
 
@@ -59,4 +59,21 @@ public synchronized void block() throws InterruptedException {
     }
   }
 
+  /**
+   * Blocks until the condition is opened or until timeout milliseconds have passed.
+   *
+   * @param timeout The maximum time to wait in milliseconds.
+   * @return true If the condition was opened, false if the call returns because of the timeout.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  public synchronized boolean block(long timeout) throws InterruptedException {
+    long now = System.currentTimeMillis();
+    long end = now + timeout;
+    while (!isOpen && now < end) {
+      wait(end - now);
+      now = System.currentTimeMillis();
+    }
+    return isOpen;
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java
new file mode 100644
index 0000000000..3d2c043a91
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.util.Pair;
+
+/**
+ * Converts exceptions into error codes and user readable error messages.
+ */
+public interface ErrorMessageProvider<T extends Exception> {
+
+  /**
+   * Returns a pair consisting of an error code and a user readable error message for the given
+   * exception.
+   *
+   * @param exception The exception for which an error code and message should be generated.
+   */
+  Pair<Integer, String> getErrorMessage(T exception);
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java
index 6382f1130e..b08f4a31e3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java
@@ -65,7 +65,7 @@ public FlacStreamInfo(int minBlockSize, int maxBlockSize, int minFrameSize, int
   }
 
   public int maxDecodedFrameSize() {
-    return maxBlockSize * channels * 2;
+    return maxBlockSize * channels * (bitsPerSample / 8);
   }
 
   public int bitRate() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
index 199ceff892..19b303484f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
@@ -62,6 +62,17 @@ public void reset(byte[] data) {
     reset(data, data.length);
   }
 
+  /**
+   * Sets this instance's data, position and limit to match the provided {@code parsableByteArray}.
+   * Any modifications to the underlying data array will be visible in both instances
+   *
+   * @param parsableByteArray The {@link ParsableByteArray}.
+   */
+  public void reset(ParsableByteArray parsableByteArray) {
+    reset(parsableByteArray.data, parsableByteArray.limit());
+    setPosition(parsableByteArray.getPosition() * 8);
+  }
+
   /**
    * Updates the instance to wrap {@code data}, and resets the position to zero.
    *
@@ -174,6 +185,43 @@ public int readBits(int numBits) {
     return returnValue;
   }
 
+  /**
+   * Reads {@code numBits} bits into {@code buffer}.
+   *
+   * @param buffer The array into which the read data should be written. The trailing
+   *     {@code numBits % 8} bits are written into the most significant bits of the last modified
+   *     {@code buffer} byte. The remaining ones are unmodified.
+   * @param offset The offset in {@code buffer} at which the read data should be written.
+   * @param numBits The number of bits to read.
+   */
+  public void readBits(byte[] buffer, int offset, int numBits) {
+    // Whole bytes.
+    int to = offset + (numBits >> 3) /* numBits / 8 */;
+    for (int i = offset; i < to; i++) {
+      buffer[i] = (byte) (data[byteOffset++] << bitOffset);
+      buffer[i] |= (data[byteOffset] & 0xFF) >> (8 - bitOffset);
+    }
+    // Trailing bits.
+    int bitsLeft = numBits & 7 /* numBits % 8 */;
+    if (bitsLeft == 0) {
+      return;
+    }
+    buffer[to] &= 0xFF >> bitsLeft; // Set to 0 the bits that are going to be overwritten.
+    if (bitOffset + bitsLeft > 8) {
+      // We read the rest of data[byteOffset] and increase byteOffset.
+      buffer[to] |= (byte) ((data[byteOffset++] & 0xFF) << bitOffset);
+      bitOffset -= 8;
+    }
+    bitOffset += bitsLeft;
+    int lastDataByteTrailingBits = (data[byteOffset] & 0xFF) >> (8 - bitOffset);
+    buffer[to] |= (byte) (lastDataByteTrailingBits << (8 - bitsLeft));
+    if (bitOffset == 8) {
+      bitOffset = 0;
+      byteOffset++;
+    }
+    assertValidOffset();
+  }
+
   /**
    * Aligns the position to the next byte boundary. Does nothing if the position is already aligned.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index 70cb584085..57313ea895 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -233,7 +233,7 @@ public int readLittleEndianUnsignedShort() {
   }
 
   /**
-   * Reads the next two bytes as an signed value.
+   * Reads the next two bytes as a signed value.
    */
   public short readShort() {
     return (short) ((data[position++] & 0xFF) << 8
@@ -256,6 +256,15 @@ public int readUnsignedInt24() {
         | (data[position++] & 0xFF);
   }
 
+  /**
+   * Reads the next three bytes as a signed value.
+   */
+  public int readInt24() {
+    return ((data[position++] & 0xFF) << 24) >> 8
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF);
+  }
+
   /**
    * Reads the next three bytes as a signed value in little endian order.
    */
@@ -305,7 +314,7 @@ public int readInt() {
   }
 
   /**
-   * Reads the next four bytes as an signed value in little endian order.
+   * Reads the next four bytes as a signed value in little endian order.
    */
   public int readLittleEndianInt() {
     return (data[position++] & 0xFF)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
index 5b8d117dd0..96203bb99a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
@@ -69,16 +69,6 @@ public void setPositionUs(long positionUs) {
     }
   }
 
-  /**
-   * Synchronizes this clock with the current state of {@code clock}.
-   *
-   * @param clock The clock with which to synchronize.
-   */
-  public void synchronize(MediaClock clock) {
-    setPositionUs(clock.getPositionUs());
-    playbackParameters = clock.getPlaybackParameters();
-  }
-
   @Override
   public long getPositionUs() {
     long positionUs = baseUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
index 1f937b721b..272c3f43ec 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.os.Handler;
+
 /**
  * The standard implementation of {@link Clock}.
  */
@@ -30,4 +32,9 @@ public void sleep(long sleepTimeMs) {
     android.os.SystemClock.sleep(sleepTimeMs);
   }
 
+  @Override
+  public void postDelayed(Handler handler, Runnable runnable, long delayMs) {
+    handler.postDelayed(runnable, delayMs);
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index 519919f129..a79ed38755 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -32,6 +32,7 @@
 import android.view.WindowManager;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.DataSource;
 import java.io.ByteArrayOutputStream;
@@ -246,6 +247,16 @@ public static String normalizeLanguageCode(String language) {
     return language == null ? null : new Locale(language).getLanguage();
   }
 
+  /**
+   * Returns a new {@link String} constructed by decoding UTF-8 encoded bytes.
+   *
+   * @param bytes The UTF-8 encoded bytes to decode.
+   * @return The string.
+   */
+  public static String fromUtf8Bytes(byte[] bytes) {
+    return new String(bytes, Charset.forName(C.UTF8_NAME));
+  }
+
   /**
    * Returns a new byte array containing the code points of a {@link String} encoded using UTF-8.
    *
@@ -791,6 +802,8 @@ public static int getPcmFrameSize(@C.PcmEncoding int pcmEncoding, int channelCou
         return channelCount * 3;
       case C.ENCODING_PCM_32BIT:
         return channelCount * 4;
+      case C.ENCODING_INVALID:
+      case Format.NO_VALUE:
       default:
         throw new IllegalArgumentException();
     }
@@ -900,8 +913,7 @@ public static int inferContentType(String fileName) {
       return C.TYPE_DASH;
     } else if (fileName.endsWith(".m3u8")) {
       return C.TYPE_HLS;
-    } else if (fileName.endsWith(".ism") || fileName.endsWith(".isml")
-        || fileName.endsWith(".ism/manifest") || fileName.endsWith(".isml/manifest")) {
+    } else if (fileName.matches(".*\\.ism(l)?(/manifest(\\(.+\\))?)?")) {
       return C.TYPE_SS;
     } else {
       return C.TYPE_OTHER;
@@ -1077,12 +1089,17 @@ public static void recursiveDelete(File fileOrDirectory) {
 
   /** Creates an empty directory in the directory returned by {@link Context#getCacheDir()}. */
   public static File createTempDirectory(Context context, String prefix) throws IOException {
-    File tempFile = File.createTempFile(prefix, null, context.getCacheDir());
+    File tempFile = createTempFile(context, prefix);
     tempFile.delete(); // Delete the temp file.
     tempFile.mkdir(); // Create a directory with the same name.
     return tempFile;
   }
 
+  /** Creates a new empty file in the directory returned by {@link Context#getCacheDir()}. */
+  public static File createTempFile(Context context, String prefix) throws IOException {
+    return File.createTempFile(prefix, null, context.getCacheDir());
+  }
+
   /**
    * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
    * order.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
index 450b4af38c..2d7a9dfd33 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
@@ -150,14 +150,9 @@ private static void assertApiLevel17OrHigher() {
    */
   @TargetApi(24)
   private static boolean enableSecureDummySurfaceV24(Context context) {
-    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    String eglExtensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
-    if (eglExtensions == null || !eglExtensions.contains("EGL_EXT_protected_content")) {
-      // EGL_EXT_protected_content is required to enable secure dummy surfaces.
-      return false;
-    }
-    if (Util.SDK_INT == 24 && "samsung".equals(Util.MANUFACTURER)) {
-      // Samsung devices running API level 24 are known to be broken [Internal: b/37197802].
+    if (Util.SDK_INT < 26 && "samsung".equals(Util.MANUFACTURER)) {
+      // Samsung devices running Nougat are known to be broken. See
+      // https://github.com/google/ExoPlayer/issues/3373 and [Internal: b/37197802].
       return false;
     }
     if (Util.SDK_INT < 26 && !context.getPackageManager().hasSystemFeature(
@@ -165,6 +160,12 @@ private static boolean enableSecureDummySurfaceV24(Context context) {
       // Pre API level 26 devices were not well tested unless they supported VR mode.
       return false;
     }
+    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    String eglExtensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
+    if (eglExtensions == null || !eglExtensions.contains("EGL_EXT_protected_content")) {
+      // EGL_EXT_protected_content is required to enable secure dummy surfaces.
+      return false;
+    }
     return true;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 9d769b2050..41e3c970c4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -25,7 +25,9 @@
 import android.media.MediaFormat;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.CallSuper;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
@@ -84,10 +86,12 @@
   @C.VideoScalingMode
   private int scalingMode;
   private boolean renderedFirstFrame;
+  private boolean forceRenderFrame;
   private long joiningDeadlineMs;
   private long droppedFrameAccumulationStartTimeMs;
   private int droppedFrames;
   private int consecutiveDroppedFrameCount;
+  private int buffersInCodecCount;
 
   private int pendingRotationDegrees;
   private float pendingPixelWidthHeightRatio;
@@ -138,8 +142,8 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
   public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      long allowedJoiningTimeMs, Handler eventHandler, VideoRendererEventListener eventListener,
-      int maxDroppedFrameCountToNotify) {
+      long allowedJoiningTimeMs, @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
     this(context, mediaCodecSelector, allowedJoiningTimeMs, null, false, eventHandler,
         eventListener, maxDroppedFrameCountToNotify);
   }
@@ -163,9 +167,10 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
   public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      long allowedJoiningTimeMs, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler,
-      VideoRendererEventListener eventListener, int maxDroppedFramesToNotify) {
+      long allowedJoiningTimeMs,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener, int maxDroppedFramesToNotify) {
     super(C.TRACK_TYPE_VIDEO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
@@ -185,7 +190,8 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
   }
 
   @Override
-  protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format format)
+  protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, Format format)
       throws DecoderQueryException {
     String mimeType = format.sampleMimeType;
     if (!MimeTypes.isVideo(mimeType)) {
@@ -201,9 +207,12 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType,
         requiresSecureDecryption);
     if (decoderInfo == null) {
-      return FORMAT_UNSUPPORTED_SUBTYPE;
+      return requiresSecureDecryption && mediaCodecSelector.getDecoderInfo(mimeType, false) != null
+          ? FORMAT_UNSUPPORTED_DRM : FORMAT_UNSUPPORTED_SUBTYPE;
+    }
+    if (!supportsFormatDrm(drmSessionManager, drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
     }
-
     boolean decoderCapable = decoderInfo.isCodecSupported(format.codecs);
     if (decoderCapable && format.width > 0 && format.height > 0) {
       if (Util.SDK_INT >= 21) {
@@ -408,11 +417,14 @@ protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format
     }
   }
 
+  @CallSuper
   @Override
   protected void releaseCodec() {
     try {
       super.releaseCodec();
     } finally {
+      buffersInCodecCount = 0;
+      forceRenderFrame = false;
       if (dummySurface != null) {
         if (surface == dummySurface) {
           surface = null;
@@ -423,6 +435,14 @@ protected void releaseCodec() {
     }
   }
 
+  @CallSuper
+  @Override
+  protected void flushCodec() throws ExoPlaybackException {
+    super.flushCodec();
+    buffersInCodecCount = 0;
+    forceRenderFrame = false;
+  }
+
   @Override
   protected void onCodecInitialized(String name, long initializedTimestampMs,
       long initializationDurationMs) {
@@ -438,8 +458,15 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     pendingRotationDegrees = getRotationDegrees(newFormat);
   }
 
+  /**
+   * Called immediately before an input buffer is queued into the codec.
+   *
+   * @param buffer The buffer to be queued.
+   */
+  @CallSuper
   @Override
   protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+    buffersInCodecCount++;
     if (Util.SDK_INT < 23 && tunneling) {
       maybeNotifyRenderedFirstFrame();
     }
@@ -486,7 +513,7 @@ protected boolean canReconfigureCodec(MediaCodec codec, boolean codecIsAdaptive,
   @Override
   protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
       ByteBuffer buffer, int bufferIndex, int bufferFlags, long bufferPresentationTimeUs,
-      boolean shouldSkip) {
+      boolean shouldSkip) throws ExoPlaybackException {
     while (pendingOutputStreamOffsetCount != 0
         && bufferPresentationTimeUs >= pendingOutputStreamOffsetsUs[0]) {
       outputStreamOffsetUs = pendingOutputStreamOffsetsUs[0];
@@ -505,13 +532,15 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (surface == dummySurface) {
       // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
       if (isBufferLate(earlyUs)) {
+        forceRenderFrame = false;
         skipOutputBuffer(codec, bufferIndex, presentationTimeUs);
         return true;
       }
       return false;
     }
 
-    if (!renderedFirstFrame) {
+    if (!renderedFirstFrame || forceRenderFrame) {
+      forceRenderFrame = false;
       if (Util.SDK_INT >= 21) {
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, System.nanoTime());
       } else {
@@ -538,7 +567,11 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
+    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
+        && maybeDropBuffersToKeyframe(codec, bufferIndex, presentationTimeUs, positionUs)) {
+      forceRenderFrame = true;
+      return false;
+    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
       dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -571,6 +604,17 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
+  /**
+   * Called when an output buffer is successfully processed.
+   *
+   * @param presentationTimeUs The timestamp associated with the output buffer.
+   */
+  @CallSuper
+  @Override
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    buffersInCodecCount--;
+  }
+
   /**
    * Returns whether the buffer being processed should be dropped.
    *
@@ -583,6 +627,19 @@ protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
     return isBufferLate(earlyUs);
   }
 
+  /**
+   * Returns whether to drop all buffers from the buffer being processed to the keyframe at or after
+   * the current playback position, if possible.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
+    return isBufferVeryLate(earlyUs);
+  }
+
   /**
    * Skips the output buffer with the specified index.
    *
@@ -608,12 +665,48 @@ protected void dropOutputBuffer(MediaCodec codec, int index, long presentationTi
     TraceUtil.beginSection("dropVideoBuffer");
     codec.releaseOutputBuffer(index, false);
     TraceUtil.endSection();
-    decoderCounters.droppedOutputBufferCount++;
-    droppedFrames++;
-    consecutiveDroppedFrameCount++;
-    decoderCounters.maxConsecutiveDroppedOutputBufferCount = Math.max(consecutiveDroppedFrameCount,
-        decoderCounters.maxConsecutiveDroppedOutputBufferCount);
-    if (droppedFrames == maxDroppedFramesToNotify) {
+    updateDroppedBufferCounters(1);
+  }
+
+  /**
+   * Drops frames from the current output buffer to the next keyframe at or before the playback
+   * position. If no such keyframe exists, as the playback position is inside the same group of
+   * pictures as the buffer being processed, returns {@code false}. Returns {@code true} otherwise.
+   *
+   * @param codec The codec that owns the output buffer.
+   * @param index The index of the output buffer to drop.
+   * @param presentationTimeUs The presentation time of the output buffer, in microseconds.
+   * @param positionUs The current playback position, in microseconds.
+   * @return Whether any buffers were dropped.
+   * @throws ExoPlaybackException If an error occurs flushing the codec.
+   */
+  protected boolean maybeDropBuffersToKeyframe(MediaCodec codec, int index, long presentationTimeUs,
+      long positionUs) throws ExoPlaybackException {
+    int droppedSourceBufferCount = skipSource(positionUs);
+    if (droppedSourceBufferCount == 0) {
+      return false;
+    }
+    decoderCounters.droppedToKeyframeCount++;
+    // We dropped some buffers to catch up, so update the decoder counters and flush the codec,
+    // which releases all pending buffers buffers including the current output buffer.
+    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
+    flushCodec();
+    return true;
+  }
+
+  /**
+   * Updates decoder counters to reflect that {@code droppedBufferCount} additional buffers were
+   * dropped.
+   *
+   * @param droppedBufferCount The number of additional dropped buffers.
+   */
+  protected void updateDroppedBufferCounters(int droppedBufferCount) {
+    decoderCounters.droppedBufferCount += droppedBufferCount;
+    droppedFrames += droppedBufferCount;
+    consecutiveDroppedFrameCount += droppedBufferCount;
+    decoderCounters.maxConsecutiveDroppedBufferCount = Math.max(consecutiveDroppedFrameCount,
+        decoderCounters.maxConsecutiveDroppedBufferCount);
+    if (droppedFrames >= maxDroppedFramesToNotify) {
       maybeNotifyDroppedFrames();
     }
   }
@@ -734,10 +827,15 @@ private void maybeNotifyDroppedFrames() {
   }
 
   private static boolean isBufferLate(long earlyUs) {
-    // Class a buffer as late if it should have been presented more than 30ms ago.
+    // Class a buffer as late if it should have been presented more than 30 ms ago.
     return earlyUs < -30000;
   }
 
+  private static boolean isBufferVeryLate(long earlyUs) {
+    // Class a buffer as very late if it should have been presented more than 500 ms ago.
+    return earlyUs < -500000;
+  }
+
   @TargetApi(23)
   private static void setOutputSurfaceV23(MediaCodec codec, Surface surface) {
     codec.setOutputSurface(surface);
@@ -973,9 +1071,14 @@ private static boolean deviceNeedsAutoFrcWorkaround() {
    * If true is returned then we fall back to releasing and re-instantiating the codec instead.
    */
   private static boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
-    // Work around https://github.com/google/ExoPlayer/issues/3236
-    return ("deb".equals(Util.DEVICE) || "flo".equals(Util.DEVICE))
-        && "OMX.qcom.video.decoder.avc".equals(name);
+    // Work around https://github.com/google/ExoPlayer/issues/3236,
+    // https://github.com/google/ExoPlayer/issues/3355 and
+    // https://github.com/google/ExoPlayer/issues/3439.
+    return (("deb".equals(Util.DEVICE) || "flo".equals(Util.DEVICE))
+        && "OMX.qcom.video.decoder.avc".equals(name))
+        || (("tcl_eu".equals(Util.DEVICE) || "SVP-DTV15".equals(Util.DEVICE)
+        || "BRAVIA_ATV2".equals(Util.DEVICE))
+        && "OMX.MTK.VIDEO.DECODER.AVC".equals(name));
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
index ad489c2312..9036b19a75 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameReleaseTimeHelper.java
@@ -17,13 +17,17 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.hardware.display.DisplayManager;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Message;
+import android.support.annotation.Nullable;
 import android.view.Choreographer;
 import android.view.Choreographer.FrameCallback;
+import android.view.Display;
 import android.view.WindowManager;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
 
 /**
  * Makes a best effort to adjust frame release timestamps for a smoother visual result.
@@ -31,17 +35,18 @@
 @TargetApi(16)
 public final class VideoFrameReleaseTimeHelper {
 
-  private static final double DISPLAY_REFRESH_RATE_UNKNOWN = -1;
   private static final long CHOREOGRAPHER_SAMPLE_DELAY_MILLIS = 500;
   private static final long MAX_ALLOWED_DRIFT_NS = 20000000;
 
   private static final long VSYNC_OFFSET_PERCENTAGE = 80;
   private static final int MIN_FRAMES_FOR_ADJUSTMENT = 6;
 
+  private final WindowManager windowManager;
   private final VSyncSampler vsyncSampler;
-  private final boolean useDefaultDisplayVsync;
-  private final long vsyncDurationNs;
-  private final long vsyncOffsetNs;
+  private final DefaultDisplayListener displayListener;
+
+  private long vsyncDurationNs;
+  private long vsyncOffsetNs;
 
   private long lastFramePresentationTimeUs;
   private long adjustedLastFrameTimeNs;
@@ -57,7 +62,7 @@
    * the default display's vsync signal.
    */
   public VideoFrameReleaseTimeHelper() {
-    this(DISPLAY_REFRESH_RATE_UNKNOWN);
+    this(null);
   }
 
   /**
@@ -66,44 +71,48 @@ public VideoFrameReleaseTimeHelper() {
    *
    * @param context A context from which information about the default display can be retrieved.
    */
-  public VideoFrameReleaseTimeHelper(Context context) {
-    this(getDefaultDisplayRefreshRate(context));
-  }
-
-  private VideoFrameReleaseTimeHelper(double defaultDisplayRefreshRate) {
-    useDefaultDisplayVsync = defaultDisplayRefreshRate != DISPLAY_REFRESH_RATE_UNKNOWN;
-    if (useDefaultDisplayVsync) {
+  public VideoFrameReleaseTimeHelper(@Nullable Context context) {
+    windowManager = context == null ? null
+        : (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    if (windowManager != null) {
+      displayListener = Util.SDK_INT >= 17 ? maybeBuildDefaultDisplayListenerV17(context) : null;
       vsyncSampler = VSyncSampler.getInstance();
-      vsyncDurationNs = (long) (C.NANOS_PER_SECOND / defaultDisplayRefreshRate);
-      vsyncOffsetNs = (vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) / 100;
     } else {
+      displayListener = null;
       vsyncSampler = null;
-      vsyncDurationNs = -1; // Value unused.
-      vsyncOffsetNs = -1; // Value unused.
     }
+    vsyncDurationNs = C.TIME_UNSET;
+    vsyncOffsetNs = C.TIME_UNSET;
   }
 
   /**
-   * Enables the helper.
+   * Enables the helper. Must be called from the playback thread.
    */
   public void enable() {
     haveSync = false;
-    if (useDefaultDisplayVsync) {
+    if (windowManager != null) {
       vsyncSampler.addObserver();
+      if (displayListener != null) {
+        displayListener.register();
+      }
+      updateDefaultDisplayRefreshRateParams();
     }
   }
 
   /**
-   * Disables the helper.
+   * Disables the helper. Must be called from the playback thread.
    */
   public void disable() {
-    if (useDefaultDisplayVsync) {
+    if (windowManager != null) {
+      if (displayListener != null) {
+        displayListener.unregister();
+      }
       vsyncSampler.removeObserver();
     }
   }
 
   /**
-   * Adjusts a frame release timestamp.
+   * Adjusts a frame release timestamp. Must be called from the playback thread.
    *
    * @param framePresentationTimeUs The frame's presentation time, in microseconds.
    * @param unadjustedReleaseTimeNs The frame's unadjusted release time, in nanoseconds and in
@@ -156,25 +165,39 @@ public long adjustReleaseTime(long framePresentationTimeUs, long unadjustedRelea
       syncUnadjustedReleaseTimeNs = unadjustedReleaseTimeNs;
       frameCount = 0;
       haveSync = true;
-      onSynced();
     }
 
     lastFramePresentationTimeUs = framePresentationTimeUs;
     pendingAdjustedFrameTimeNs = adjustedFrameTimeNs;
 
-    if (vsyncSampler == null || vsyncSampler.sampledVsyncTimeNs == 0) {
+    if (vsyncSampler == null || vsyncDurationNs == C.TIME_UNSET) {
+      return adjustedReleaseTimeNs;
+    }
+    long sampledVsyncTimeNs = vsyncSampler.sampledVsyncTimeNs;
+    if (sampledVsyncTimeNs == C.TIME_UNSET) {
       return adjustedReleaseTimeNs;
     }
 
     // Find the timestamp of the closest vsync. This is the vsync that we're targeting.
-    long snappedTimeNs = closestVsync(adjustedReleaseTimeNs,
-        vsyncSampler.sampledVsyncTimeNs, vsyncDurationNs);
+    long snappedTimeNs = closestVsync(adjustedReleaseTimeNs, sampledVsyncTimeNs, vsyncDurationNs);
     // Apply an offset so that we release before the target vsync, but after the previous one.
     return snappedTimeNs - vsyncOffsetNs;
   }
 
-  protected void onSynced() {
-    // Do nothing.
+  @TargetApi(17)
+  private DefaultDisplayListener maybeBuildDefaultDisplayListenerV17(Context context) {
+    DisplayManager manager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
+    return manager == null ? null : new DefaultDisplayListener(manager);
+  }
+
+  private void updateDefaultDisplayRefreshRateParams() {
+    // Note: If we fail to update the parameters, we leave them set to their previous values.
+    Display defaultDisplay = windowManager.getDefaultDisplay();
+    if (defaultDisplay != null) {
+      double defaultDisplayRefreshRate = defaultDisplay.getRefreshRate();
+      vsyncDurationNs = (long) (C.NANOS_PER_SECOND / defaultDisplayRefreshRate);
+      vsyncOffsetNs = (vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) / 100;
+    }
   }
 
   private boolean isDriftTooLarge(long frameTimeNs, long releaseTimeNs) {
@@ -200,10 +223,40 @@ private static long closestVsync(long releaseTime, long sampledVsyncTime, long v
     return snappedAfterDiff < snappedBeforeDiff ? snappedAfterNs : snappedBeforeNs;
   }
 
-  private static double getDefaultDisplayRefreshRate(Context context) {
-    WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    return manager.getDefaultDisplay() != null ? manager.getDefaultDisplay().getRefreshRate()
-        : DISPLAY_REFRESH_RATE_UNKNOWN;
+  @TargetApi(17)
+  private final class DefaultDisplayListener implements DisplayManager.DisplayListener {
+
+    private final DisplayManager displayManager;
+
+    public DefaultDisplayListener(DisplayManager displayManager) {
+      this.displayManager = displayManager;
+    }
+
+    public void register() {
+      displayManager.registerDisplayListener(this, null);
+    }
+
+    public void unregister() {
+      displayManager.unregisterDisplayListener(this);
+    }
+
+    @Override
+    public void onDisplayAdded(int displayId) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onDisplayRemoved(int displayId) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onDisplayChanged(int displayId) {
+      if (displayId == Display.DEFAULT_DISPLAY) {
+        updateDefaultDisplayRefreshRateParams();
+      }
+    }
+
   }
 
   /**
@@ -231,6 +284,7 @@ public static VSyncSampler getInstance() {
     }
 
     private VSyncSampler() {
+      sampledVsyncTimeNs = C.TIME_UNSET;
       choreographerOwnerThread = new HandlerThread("ChoreographerOwner:Handler");
       choreographerOwnerThread.start();
       handler = new Handler(choreographerOwnerThread.getLooper(), this);
@@ -295,7 +349,7 @@ private void removeObserverInternal() {
       observerCount--;
       if (observerCount == 0) {
         choreographer.removeFrameCallback(this);
-        sampledVsyncTimeNs = 0;
+        sampledVsyncTimeNs = C.TIME_UNSET;
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
index 53d6a76b8d..d6ea0ebae2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
@@ -17,6 +17,7 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import android.view.Surface;
 import android.view.TextureView;
 import com.google.android.exoplayer2.Format;
@@ -109,15 +110,16 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
    */
   final class EventDispatcher {
 
-    private final Handler handler;
-    private final VideoRendererEventListener listener;
+    @Nullable private final Handler handler;
+    @Nullable private final VideoRendererEventListener listener;
 
     /**
      * @param handler A handler for dispatching events, or null if creating a dummy instance.
      * @param listener The listener to which events should be dispatched, or null if creating a
      *     dummy instance.
      */
-    public EventDispatcher(Handler handler, VideoRendererEventListener listener) {
+    public EventDispatcher(@Nullable Handler handler,
+        @Nullable VideoRendererEventListener listener) {
       this.handler = listener != null ? Assertions.checkNotNull(handler) : null;
       this.listener = listener;
     }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/CTest.java b/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
similarity index 58%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/CTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/CTest.java
index ddcdc4ac8a..ff4756f5ed 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/CTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
@@ -15,21 +15,29 @@
  */
 package com.google.android.exoplayer2;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.annotation.SuppressLint;
 import android.media.MediaCodec;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link C}.
  */
-public class CTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class CTest {
 
   @SuppressLint("InlinedApi")
-  public static void testConstants() {
+  @Test
+  public void testConstants() {
     // Sanity check that constant values match those defined by the platform.
-    assertEquals(MediaCodec.BUFFER_FLAG_KEY_FRAME, C.BUFFER_FLAG_KEY_FRAME);
-    assertEquals(MediaCodec.BUFFER_FLAG_END_OF_STREAM, C.BUFFER_FLAG_END_OF_STREAM);
-    assertEquals(MediaCodec.CRYPTO_MODE_AES_CTR, C.CRYPTO_MODE_AES_CTR);
+    assertThat(C.BUFFER_FLAG_KEY_FRAME).isEqualTo(MediaCodec.BUFFER_FLAG_KEY_FRAME);
+    assertThat(C.BUFFER_FLAG_END_OF_STREAM).isEqualTo(MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+    assertThat(C.CRYPTO_MODE_AES_CTR).isEqualTo(MediaCodec.CRYPTO_MODE_AES_CTR);
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
similarity index 82%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
index bdea08638b..33e1a673bd 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
@@ -18,6 +18,7 @@
 import static com.google.android.exoplayer2.C.WIDEVINE_UUID;
 import static com.google.android.exoplayer2.util.MimeTypes.VIDEO_MP4;
 import static com.google.android.exoplayer2.util.MimeTypes.VIDEO_WEBM;
+import static com.google.common.truth.Truth.assertThat;
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
@@ -35,12 +36,17 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link Format}.
  */
-public final class FormatTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class FormatTest {
 
   private static final List<byte[]> INIT_DATA;
   static {
@@ -52,12 +58,13 @@
     INIT_DATA = Collections.unmodifiableList(initData);
   }
 
+  @Test
   public void testParcelable() {
-    DrmInitData.SchemeData DRM_DATA_1 = new DrmInitData.SchemeData(WIDEVINE_UUID, "cenc", VIDEO_MP4,
+    DrmInitData.SchemeData drmData1 = new DrmInitData.SchemeData(WIDEVINE_UUID, VIDEO_MP4,
         TestUtil.buildTestData(128, 1 /* data seed */));
-    DrmInitData.SchemeData DRM_DATA_2 = new DrmInitData.SchemeData(C.UUID_NIL, null, VIDEO_WEBM,
+    DrmInitData.SchemeData drmData2 = new DrmInitData.SchemeData(C.UUID_NIL, VIDEO_WEBM,
         TestUtil.buildTestData(128, 1 /* data seed */));
-    DrmInitData drmInitData = new DrmInitData(DRM_DATA_1, DRM_DATA_2);
+    DrmInitData drmInitData = new DrmInitData(drmData1, drmData2);
     byte[] projectionData = new byte[] {1, 2, 3};
     Metadata metadata = new Metadata(
         new TextInformationFrame("id1", "description1", "value1"),
@@ -75,11 +82,12 @@ public void testParcelable() {
     parcel.setDataPosition(0);
 
     Format formatFromParcel = Format.CREATOR.createFromParcel(parcel);
-    assertEquals(formatToParcel, formatFromParcel);
+    assertThat(formatFromParcel).isEqualTo(formatToParcel);
 
     parcel.recycle();
   }
 
+  @Test
   public void testConversionToFrameworkMediaFormat() {
     if (Util.SDK_INT < 16) {
       // Test doesn't apply.
@@ -104,7 +112,7 @@ public void testConversionToFrameworkMediaFormat() {
   @TargetApi(16)
   private static void testConversionToFrameworkMediaFormatV16(Format in) {
     MediaFormat out = in.getFrameworkMediaFormatV16();
-    assertEquals(in.sampleMimeType, out.getString(MediaFormat.KEY_MIME));
+    assertThat(out.getString(MediaFormat.KEY_MIME)).isEqualTo(in.sampleMimeType);
     assertOptionalV16(out, MediaFormat.KEY_LANGUAGE, in.language);
     assertOptionalV16(out, MediaFormat.KEY_MAX_INPUT_SIZE, in.maxInputSize);
     assertOptionalV16(out, MediaFormat.KEY_WIDTH, in.width);
@@ -117,34 +125,34 @@ private static void testConversionToFrameworkMediaFormatV16(Format in) {
       byte[] originalData = in.initializationData.get(i);
       ByteBuffer frameworkBuffer = out.getByteBuffer("csd-" + i);
       byte[] frameworkData = Arrays.copyOf(frameworkBuffer.array(), frameworkBuffer.limit());
-      assertTrue(Arrays.equals(originalData, frameworkData));
+      assertThat(frameworkData).isEqualTo(originalData);
     }
   }
 
   @TargetApi(16)
   private static void assertOptionalV16(MediaFormat format, String key, String value) {
     if (value == null) {
-      assertFalse(format.containsKey(key));
+      assertThat(format.containsKey(key)).isEqualTo(false);
     } else {
-      assertEquals(value, format.getString(key));
+      assertThat(format.getString(key)).isEqualTo(value);
     }
   }
 
   @TargetApi(16)
   private static void assertOptionalV16(MediaFormat format, String key, int value) {
     if (value == Format.NO_VALUE) {
-      assertFalse(format.containsKey(key));
+      assertThat(format.containsKey(key)).isEqualTo(false);
     } else {
-      assertEquals(value, format.getInteger(key));
+      assertThat(format.getInteger(key)).isEqualTo(value);
     }
   }
 
   @TargetApi(16)
   private static void assertOptionalV16(MediaFormat format, String key, float value) {
     if (value == Format.NO_VALUE) {
-      assertFalse(format.containsKey(key));
+      assertThat(format.containsKey(key)).isEqualTo(false);
     } else {
-      assertEquals(value, format.getFloat(key));
+      assertThat(format.getFloat(key)).isEqualTo(value);
     }
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
new file mode 100644
index 0000000000..346b94e5f4
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import static com.google.android.exoplayer2.RendererCapabilities.ADAPTIVE_NOT_SEAMLESS;
+import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_HANDLED;
+import static com.google.android.exoplayer2.RendererCapabilities.TUNNELING_NOT_SUPPORTED;
+import static com.google.android.exoplayer2.RendererCapabilities.TUNNELING_SUPPORTED;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.testutil.FakeSampleStream;
+import com.google.android.exoplayer2.util.MimeTypes;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link SimpleDecoderAudioRenderer}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class SimpleDecoderAudioRendererTest {
+
+  private static final Format FORMAT = Format.createSampleFormat(null, MimeTypes.AUDIO_RAW, 0);
+
+  @Mock private AudioSink mockAudioSink;
+  private SimpleDecoderAudioRenderer audioRenderer;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    audioRenderer = new SimpleDecoderAudioRenderer(null, null, null, false, mockAudioSink) {
+      @Override
+      protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+          Format format) {
+        return FORMAT_HANDLED;
+      }
+
+      @Override
+      protected SimpleDecoder<DecoderInputBuffer, ? extends SimpleOutputBuffer,
+          ? extends AudioDecoderException> createDecoder(Format format, ExoMediaCrypto mediaCrypto)
+          throws AudioDecoderException {
+        return new FakeDecoder();
+      }
+    };
+  }
+
+  @Config(sdk = 19)
+  @Test
+  public void testSupportsFormatAtApi19() {
+    assertThat(audioRenderer.supportsFormat(FORMAT))
+        .isEqualTo(ADAPTIVE_NOT_SEAMLESS | TUNNELING_NOT_SUPPORTED | FORMAT_HANDLED);
+  }
+
+  @Config(sdk = 21)
+  @Test
+  public void testSupportsFormatAtApi21() {
+    // From API 21, tunneling is supported.
+    assertThat(audioRenderer.supportsFormat(FORMAT))
+        .isEqualTo(ADAPTIVE_NOT_SEAMLESS | TUNNELING_SUPPORTED | FORMAT_HANDLED);
+  }
+
+  @Test
+  public void testImmediatelyReadEndOfStreamPlaysAudioSinkToEndOfStream() throws Exception {
+    audioRenderer.enable(RendererConfiguration.DEFAULT, new Format[] {FORMAT},
+        new FakeSampleStream(FORMAT), 0, false, 0);
+    audioRenderer.setCurrentStreamFinal();
+    when(mockAudioSink.isEnded()).thenReturn(true);
+    while (!audioRenderer.isEnded()) {
+      audioRenderer.render(0, 0);
+    }
+    verify(mockAudioSink, times(1)).playToEndOfStream();
+    audioRenderer.disable();
+    verify(mockAudioSink, times(1)).release();
+  }
+
+  private static final class FakeDecoder
+      extends SimpleDecoder<DecoderInputBuffer, SimpleOutputBuffer, AudioDecoderException> {
+
+    public FakeDecoder() {
+      super(new DecoderInputBuffer[1], new SimpleOutputBuffer[1]);
+    }
+
+    @Override
+    public String getName() {
+      return "FakeDecoder";
+    }
+
+    @Override
+    protected DecoderInputBuffer createInputBuffer() {
+      return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
+    }
+
+    @Override
+    protected SimpleOutputBuffer createOutputBuffer() {
+      return new SimpleOutputBuffer(this);
+    }
+
+    @Override
+    protected AudioDecoderException decode(DecoderInputBuffer inputBuffer,
+        SimpleOutputBuffer outputBuffer, boolean reset) {
+      if (inputBuffer.isEndOfStream()) {
+        outputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+      }
+      return null;
+    }
+
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
new file mode 100644
index 0000000000..a4f02f8257
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.C;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link SonicAudioProcessor}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class SonicAudioProcessorTest {
+
+  private SonicAudioProcessor sonicAudioProcessor;
+
+  @Before
+  public void setUp() {
+    sonicAudioProcessor = new SonicAudioProcessor();
+  }
+
+  @Test
+  public void testReconfigureWithSameSampleRate() throws Exception {
+    // When configured for resampling from 44.1 kHz to 48 kHz, the output sample rate is correct.
+    sonicAudioProcessor.setOutputSampleRateHz(48000);
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(48000);
+    assertThat(sonicAudioProcessor.isActive()).isTrue();
+    // When reconfigured with 48 kHz input, there is no resampling.
+    sonicAudioProcessor.configure(48000, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(48000);
+    assertThat(sonicAudioProcessor.isActive()).isFalse();
+    // When reconfigure with 44.1 kHz input, resampling is enabled again.
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(48000);
+    assertThat(sonicAudioProcessor.isActive()).isTrue();
+  }
+
+  @Test
+  public void testNoSampleRateChange() throws Exception {
+    // Configure for resampling 44.1 kHz to 48 kHz.
+    sonicAudioProcessor.setOutputSampleRateHz(48000);
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    // Reconfigure to not modify the sample rate.
+    sonicAudioProcessor.setOutputSampleRateHz(SonicAudioProcessor.SAMPLE_RATE_NO_CHANGE);
+    sonicAudioProcessor.configure(22050, 2, C.ENCODING_PCM_16BIT);
+    // The sample rate is unmodified, and the audio processor is not active.
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(22050);
+    assertThat(sonicAudioProcessor.isActive()).isFalse();
+  }
+
+  @Test
+  public void testBecomesActiveAfterConfigure() throws Exception {
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    // Set a new sample rate.
+    sonicAudioProcessor.setOutputSampleRateHz(22050);
+    // The new sample rate is not active yet.
+    assertThat(sonicAudioProcessor.isActive()).isFalse();
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(44100);
+  }
+
+  @Test
+  public void testSampleRateChangeBecomesActiveAfterConfigure() throws Exception {
+    // Configure for resampling 44.1 kHz to 48 kHz.
+    sonicAudioProcessor.setOutputSampleRateHz(48000);
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    // Set a new sample rate, which isn't active yet.
+    sonicAudioProcessor.setOutputSampleRateHz(22050);
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(48000);
+    // The new sample rate takes effect on reconfiguration.
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.getOutputSampleRateHz()).isEqualTo(22050);
+  }
+
+  @Test
+  public void testIsActiveWithSpeedChange() throws Exception {
+    sonicAudioProcessor.setSpeed(1.5f);
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.isActive()).isTrue();
+  }
+
+  @Test
+  public void testIsActiveWithPitchChange() throws Exception {
+    sonicAudioProcessor.setPitch(1.5f);
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.isActive()).isTrue();
+  }
+
+  @Test
+  public void testIsNotActiveWithNoChange() throws Exception {
+    sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_16BIT);
+    assertThat(sonicAudioProcessor.isActive()).isFalse();
+  }
+
+  @Test
+  public void testDoesNotSupportNon16BitInput() throws Exception {
+    try {
+      sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_8BIT);
+      fail();
+    } catch (AudioProcessor.UnhandledFormatException e) {
+      // Expected.
+    }
+    try {
+      sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_24BIT);
+      fail();
+    } catch (AudioProcessor.UnhandledFormatException e) {
+      // Expected.
+    }
+    try {
+      sonicAudioProcessor.configure(44100, 2, C.ENCODING_PCM_32BIT);
+      fail();
+    } catch (AudioProcessor.UnhandledFormatException e) {
+      // Expected.
+    }
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
new file mode 100644
index 0000000000..01ab9ea9aa
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import java.nio.charset.Charset;
+import java.util.Arrays;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link ClearKeyUtil}.
+ */
+// TODO: When API level 27 is supported, add tests that check the adjust methods are no-ops.
+@RunWith(RobolectricTestRunner.class)
+public final class ClearKeyUtilTest {
+
+  @Config(sdk = 26, manifest = Config.NONE)
+  @Test
+  public void testAdjustResponseDataV26() {
+    byte[] data = ("{\"keys\":[{"
+        + "\"k\":\"abc_def-\","
+        + "\"kid\":\"ab_cde-f\"}],"
+        + "\"type\":\"abc_def-"
+        + "\"}").getBytes(Charset.forName(C.UTF8_NAME));
+    // We expect "-" and "_" to be replaced with "+" and "\/" (forward slashes need to be escaped in
+    // JSON respectively, for "k" and "kid" only.
+    byte[] expected = ("{\"keys\":[{"
+        + "\"k\":\"abc\\/def+\","
+        + "\"kid\":\"ab\\/cde+f\"}],"
+        + "\"type\":\"abc_def-"
+        + "\"}").getBytes(Charset.forName(C.UTF8_NAME));
+    assertThat(Arrays.equals(expected, ClearKeyUtil.adjustResponseData(data))).isTrue();
+  }
+
+  @Config(sdk = 26, manifest = Config.NONE)
+  @Test
+  public void testAdjustRequestDataV26() {
+    byte[] data = "{\"kids\":[\"abc+def/\",\"ab+cde/f\"],\"type\":\"abc+def/\"}"
+        .getBytes(Charset.forName(C.UTF8_NAME));
+    // We expect "+" and "/" to be replaced with "-" and "_" respectively, for "kids".
+    byte[] expected = "{\"kids\":[\"abc-def_\",\"ab-cde_f\"],\"type\":\"abc+def/\"}"
+        .getBytes(Charset.forName(C.UTF8_NAME));
+    assertThat(Arrays.equals(expected, ClearKeyUtil.adjustRequestData(data))).isTrue();
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
new file mode 100644
index 0000000000..9fc6e801d3
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import static com.google.android.exoplayer2.C.PLAYREADY_UUID;
+import static com.google.android.exoplayer2.C.UUID_NIL;
+import static com.google.android.exoplayer2.C.WIDEVINE_UUID;
+import static com.google.android.exoplayer2.util.MimeTypes.VIDEO_MP4;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link DrmInitData}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class DrmInitDataTest {
+
+  private static final SchemeData DATA_1 = new SchemeData(WIDEVINE_UUID, VIDEO_MP4,
+      TestUtil.buildTestData(128, 1 /* data seed */));
+  private static final SchemeData DATA_2 = new SchemeData(PLAYREADY_UUID, VIDEO_MP4,
+      TestUtil.buildTestData(128, 2 /* data seed */));
+  private static final SchemeData DATA_1B = new SchemeData(WIDEVINE_UUID, VIDEO_MP4,
+      TestUtil.buildTestData(128, 1 /* data seed */));
+  private static final SchemeData DATA_2B = new SchemeData(PLAYREADY_UUID, VIDEO_MP4,
+      TestUtil.buildTestData(128, 2 /* data seed */));
+  private static final SchemeData DATA_UNIVERSAL = new SchemeData(C.UUID_NIL, VIDEO_MP4,
+      TestUtil.buildTestData(128, 3 /* data seed */));
+
+  @Test
+  public void testParcelable() {
+    DrmInitData drmInitDataToParcel = new DrmInitData(DATA_1, DATA_2);
+
+    Parcel parcel = Parcel.obtain();
+    drmInitDataToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    DrmInitData drmInitDataFromParcel = DrmInitData.CREATOR.createFromParcel(parcel);
+    assertThat(drmInitDataFromParcel).isEqualTo(drmInitDataToParcel);
+
+    parcel.recycle();
+  }
+
+  @Test
+  public void testEquals() {
+    DrmInitData drmInitData = new DrmInitData(DATA_1, DATA_2);
+
+    // Basic non-referential equality test.
+    DrmInitData testInitData = new DrmInitData(DATA_1, DATA_2);
+    assertThat(testInitData).isEqualTo(drmInitData);
+    assertThat(testInitData.hashCode()).isEqualTo(drmInitData.hashCode());
+
+    // Basic non-referential equality test with non-referential scheme data.
+    testInitData = new DrmInitData(DATA_1B, DATA_2B);
+    assertThat(testInitData).isEqualTo(drmInitData);
+    assertThat(testInitData.hashCode()).isEqualTo(drmInitData.hashCode());
+
+    // Passing the scheme data in reverse order shouldn't affect equality.
+    testInitData = new DrmInitData(DATA_2, DATA_1);
+    assertThat(testInitData).isEqualTo(drmInitData);
+    assertThat(testInitData.hashCode()).isEqualTo(drmInitData.hashCode());
+
+    // Ditto.
+    testInitData = new DrmInitData(DATA_2B, DATA_1B);
+    assertThat(testInitData).isEqualTo(drmInitData);
+    assertThat(testInitData.hashCode()).isEqualTo(drmInitData.hashCode());
+
+    // Different number of tuples should affect equality.
+    testInitData = new DrmInitData(DATA_1);
+    assertThat(drmInitData).isNotEqualTo(testInitData);
+
+    // Different data in one of the tuples should affect equality.
+    testInitData = new DrmInitData(DATA_1, DATA_UNIVERSAL);
+    assertThat(testInitData).isNotEqualTo(drmInitData);
+  }
+
+  @Test
+  @Deprecated
+  public void testGetByUuid() {
+    // Basic matching.
+    DrmInitData testInitData = new DrmInitData(DATA_1, DATA_2);
+    assertThat(testInitData.get(WIDEVINE_UUID)).isEqualTo(DATA_1);
+    assertThat(testInitData.get(PLAYREADY_UUID)).isEqualTo(DATA_2);
+    assertThat(testInitData.get(UUID_NIL)).isNull();
+
+    // Basic matching including universal data.
+    testInitData = new DrmInitData(DATA_1, DATA_2, DATA_UNIVERSAL);
+    assertThat(testInitData.get(WIDEVINE_UUID)).isEqualTo(DATA_1);
+    assertThat(testInitData.get(PLAYREADY_UUID)).isEqualTo(DATA_2);
+    assertThat(testInitData.get(UUID_NIL)).isEqualTo(DATA_UNIVERSAL);
+
+    // Passing the scheme data in reverse order shouldn't affect equality.
+    testInitData = new DrmInitData(DATA_UNIVERSAL, DATA_2, DATA_1);
+    assertThat(testInitData.get(WIDEVINE_UUID)).isEqualTo(DATA_1);
+    assertThat(testInitData.get(PLAYREADY_UUID)).isEqualTo(DATA_2);
+    assertThat(testInitData.get(UUID_NIL)).isEqualTo(DATA_UNIVERSAL);
+
+    // Universal data should be returned in the absence of a specific match.
+    testInitData = new DrmInitData(DATA_1, DATA_UNIVERSAL);
+    assertThat(testInitData.get(WIDEVINE_UUID)).isEqualTo(DATA_1);
+    assertThat(testInitData.get(PLAYREADY_UUID)).isEqualTo(DATA_UNIVERSAL);
+    assertThat(testInitData.get(UUID_NIL)).isEqualTo(DATA_UNIVERSAL);
+  }
+
+  @Test
+  public void testGetByIndex() {
+    DrmInitData testInitData = new DrmInitData(DATA_1, DATA_2);
+    assertThat(getAllSchemeData(testInitData)).containsAllOf(DATA_1, DATA_2);
+  }
+
+  @Test
+  public void testSchemeDatasWithSameUuid() {
+    DrmInitData testInitData = new DrmInitData(DATA_1, DATA_1B);
+    assertThat(testInitData.schemeDataCount).isEqualTo(2);
+    // Deprecated get method should return first entry.
+    assertThat(testInitData.get(WIDEVINE_UUID)).isEqualTo(DATA_1);
+    // Test retrieval of first and second entry.
+    assertThat(testInitData.get(0)).isEqualTo(DATA_1);
+    assertThat(testInitData.get(1)).isEqualTo(DATA_1B);
+  }
+
+  @Test
+  public void testSchemeDataMatches() {
+    assertThat(DATA_1.matches(WIDEVINE_UUID)).isTrue();
+    assertThat(DATA_1.matches(PLAYREADY_UUID)).isFalse();
+    assertThat(DATA_2.matches(UUID_NIL)).isFalse();
+
+    assertThat(DATA_2.matches(WIDEVINE_UUID)).isFalse();
+    assertThat(DATA_2.matches(PLAYREADY_UUID)).isTrue();
+    assertThat(DATA_2.matches(UUID_NIL)).isFalse();
+
+    assertThat(DATA_UNIVERSAL.matches(WIDEVINE_UUID)).isTrue();
+    assertThat(DATA_UNIVERSAL.matches(PLAYREADY_UUID)).isTrue();
+    assertThat(DATA_UNIVERSAL.matches(UUID_NIL)).isTrue();
+  }
+
+  private List<SchemeData> getAllSchemeData(DrmInitData drmInitData) {
+    ArrayList<SchemeData> schemeDatas = new ArrayList<>();
+    for (int i = 0; i < drmInitData.schemeDataCount; i++) {
+      schemeDatas.add(drmInitData.get(i));
+    }
+    return schemeDatas;
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
similarity index 78%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
index 6abd116086..8e27c4f7ca 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
@@ -15,6 +15,12 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import static com.google.android.exoplayer2.C.RESULT_END_OF_INPUT;
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.Arrays.copyOf;
+import static java.util.Arrays.copyOfRange;
+import static org.junit.Assert.fail;
+
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
@@ -22,42 +28,50 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Arrays;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link DefaultExtractorInput}.
  */
-public class DefaultExtractorInputTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class DefaultExtractorInputTest {
 
   private static final String TEST_URI = "http://www.google.com";
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8};
   private static final int LARGE_TEST_DATA_LENGTH = 8192;
 
+  @Test
   public void testInitialPosition() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input =
         new DefaultExtractorInput(testDataSource, 123, C.LENGTH_UNSET);
-    assertEquals(123, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(123);
   }
 
+  @Test
   public void testRead() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     // We expect to perform three reads of three bytes, as setup in buildTestDataSource.
     int bytesRead = 0;
     bytesRead += input.read(target, 0, TEST_DATA.length);
-    assertEquals(3, bytesRead);
+    assertThat(bytesRead).isEqualTo(3);
     bytesRead += input.read(target, 3, TEST_DATA.length);
-    assertEquals(6, bytesRead);
+    assertThat(bytesRead).isEqualTo(6);
     bytesRead += input.read(target, 6, TEST_DATA.length);
-    assertEquals(9, bytesRead);
+    assertThat(bytesRead).isEqualTo(9);
     // Check the read data is correct.
-    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
     // Check we're now indicated that the end of input is reached.
     int expectedEndOfInput = input.read(target, 0, TEST_DATA.length);
-    assertEquals(C.RESULT_END_OF_INPUT, expectedEndOfInput);
+    assertThat(expectedEndOfInput).isEqualTo(RESULT_END_OF_INPUT);
   }
 
+  @Test
   public void testReadPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
@@ -65,12 +79,13 @@ public void testReadPeeked() throws Exception {
     input.advancePeekPosition(TEST_DATA.length);
 
     int bytesRead = input.read(target, 0, TEST_DATA.length);
-    assertEquals(TEST_DATA.length, bytesRead);
+    assertThat(bytesRead).isEqualTo(TEST_DATA.length);
 
     // Check the read data is correct.
-    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
   }
 
+  @Test
   public void testReadMoreDataPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
@@ -78,22 +93,23 @@ public void testReadMoreDataPeeked() throws Exception {
     input.advancePeekPosition(TEST_DATA.length);
 
     int bytesRead = input.read(target, 0, TEST_DATA.length + 1);
-    assertEquals(TEST_DATA.length, bytesRead);
+    assertThat(bytesRead).isEqualTo(TEST_DATA.length);
 
     // Check the read data is correct.
-    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
   }
 
+  @Test
   public void testReadFullyOnce() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.readFully(target, 0, TEST_DATA.length);
     // Check that we read the whole of TEST_DATA.
-    assertTrue(Arrays.equals(TEST_DATA, target));
-    assertEquals(TEST_DATA.length, input.getPosition());
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(TEST_DATA.length);
     // Check that we see end of input if we read again with allowEndOfInput set.
     boolean result = input.readFully(target, 0, 1, true);
-    assertFalse(result);
+    assertThat(result).isFalse();
     // Check that we fail with EOFException we read again with allowEndOfInput unset.
     try {
       input.readFully(target, 0, 1);
@@ -103,19 +119,21 @@ public void testReadFullyOnce() throws Exception {
     }
   }
 
+  @Test
   public void testReadFullyTwice() throws Exception {
     // Read TEST_DATA in two parts.
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[5];
     input.readFully(target, 0, 5);
-    assertTrue(Arrays.equals(Arrays.copyOf(TEST_DATA, 5), target));
-    assertEquals(5, input.getPosition());
+    assertThat(Arrays.equals(copyOf(TEST_DATA, 5), target)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(5);
     target = new byte[4];
     input.readFully(target, 0, 4);
-    assertTrue(Arrays.equals(Arrays.copyOfRange(TEST_DATA, 5, 9), target));
-    assertEquals(5 + 4, input.getPosition());
+    assertThat(Arrays.equals(copyOfRange(TEST_DATA, 5, 9), target)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(5 + 4);
   }
 
+  @Test
   public void testReadFullyTooMuch() throws Exception {
     // Read more than TEST_DATA. Should fail with an EOFException. Position should not update.
     DefaultExtractorInput input = createDefaultExtractorInput();
@@ -126,7 +144,7 @@ public void testReadFullyTooMuch() throws Exception {
     } catch (EOFException e) {
       // Expected.
     }
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
 
     // Read more than TEST_DATA with allowEndOfInput set. Should fail with an EOFException because
     // the end of input isn't encountered immediately. Position should not update.
@@ -138,9 +156,10 @@ public void testReadFullyTooMuch() throws Exception {
     } catch (EOFException e) {
       // Expected.
     }
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
   }
 
+  @Test
   public void testReadFullyWithFailingDataSource() throws Exception {
     FakeDataSource testDataSource = buildFailingDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
@@ -152,9 +171,10 @@ public void testReadFullyWithFailingDataSource() throws Exception {
       // Expected.
     }
     // The position should not have advanced.
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
   }
 
+  @Test
   public void testReadFullyHalfPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
@@ -164,22 +184,24 @@ public void testReadFullyHalfPeeked() throws Exception {
     input.readFully(target, 0, TEST_DATA.length);
 
     // Check the read data is correct.
-    assertTrue(Arrays.equals(TEST_DATA, target));
-    assertEquals(TEST_DATA.length, input.getPosition());
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(TEST_DATA.length);
   }
 
+  @Test
   public void testSkip() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
     // We expect to perform three skips of three bytes, as setup in buildTestDataSource.
     for (int i = 0; i < 3; i++) {
-      assertEquals(3, input.skip(TEST_DATA.length));
+      assertThat(input.skip(TEST_DATA.length)).isEqualTo(3);
     }
     // Check we're now indicated that the end of input is reached.
     int expectedEndOfInput = input.skip(TEST_DATA.length);
-    assertEquals(C.RESULT_END_OF_INPUT, expectedEndOfInput);
+    assertThat(expectedEndOfInput).isEqualTo(RESULT_END_OF_INPUT);
   }
 
+  @Test
   public void testLargeSkip() throws Exception {
     FakeDataSource testDataSource = buildLargeDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
@@ -190,14 +212,15 @@ public void testLargeSkip() throws Exception {
     }
   }
 
+  @Test
   public void testSkipFullyOnce() throws Exception {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(TEST_DATA.length);
-    assertEquals(TEST_DATA.length, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(TEST_DATA.length);
     // Check that we see end of input if we skip again with allowEndOfInput set.
     boolean result = input.skipFully(1, true);
-    assertFalse(result);
+    assertThat(result).isFalse();
     // Check that we fail with EOFException we skip again.
     try {
       input.skipFully(1);
@@ -207,15 +230,17 @@ public void testSkipFullyOnce() throws Exception {
     }
   }
 
+  @Test
   public void testSkipFullyTwice() throws Exception {
     // Skip TEST_DATA in two parts.
     DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(5);
-    assertEquals(5, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(5);
     input.skipFully(4);
-    assertEquals(5 + 4, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(5 + 4);
   }
 
+  @Test
   public void testSkipFullyTwicePeeked() throws Exception {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
@@ -224,12 +249,13 @@ public void testSkipFullyTwicePeeked() throws Exception {
 
     int halfLength = TEST_DATA.length / 2;
     input.skipFully(halfLength);
-    assertEquals(halfLength, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(halfLength);
 
     input.skipFully(TEST_DATA.length - halfLength);
-    assertEquals(TEST_DATA.length, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(TEST_DATA.length);
   }
 
+  @Test
   public void testSkipFullyTooMuch() throws Exception {
     // Skip more than TEST_DATA. Should fail with an EOFException. Position should not update.
     DefaultExtractorInput input = createDefaultExtractorInput();
@@ -239,7 +265,7 @@ public void testSkipFullyTooMuch() throws Exception {
     } catch (EOFException e) {
       // Expected.
     }
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
 
     // Skip more than TEST_DATA with allowEndOfInput set. Should fail with an EOFException because
     // the end of input isn't encountered immediately. Position should not update.
@@ -250,9 +276,10 @@ public void testSkipFullyTooMuch() throws Exception {
     } catch (EOFException e) {
       // Expected.
     }
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
   }
 
+  @Test
   public void testSkipFullyWithFailingDataSource() throws Exception {
     FakeDataSource testDataSource = buildFailingDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
@@ -263,9 +290,10 @@ public void testSkipFullyWithFailingDataSource() throws Exception {
       // Expected.
     }
     // The position should not have advanced.
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
   }
 
+  @Test
   public void testSkipFullyLarge() throws Exception {
     // Tests skipping an amount of data that's larger than any internal scratch space.
     int largeSkipSize = 1024 * 1024;
@@ -275,7 +303,7 @@ public void testSkipFullyLarge() throws Exception {
 
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
     input.skipFully(largeSkipSize);
-    assertEquals(largeSkipSize, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(largeSkipSize);
     // Check that we fail with EOFException we skip again.
     try {
       input.skipFully(1);
@@ -285,22 +313,23 @@ public void testSkipFullyLarge() throws Exception {
     }
   }
 
+  @Test
   public void testPeekFully() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.peekFully(target, 0, TEST_DATA.length);
 
     // Check that we read the whole of TEST_DATA.
-    assertTrue(Arrays.equals(TEST_DATA, target));
-    assertEquals(0, input.getPosition());
-    assertEquals(TEST_DATA.length, input.getPeekPosition());
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(0);
+    assertThat(input.getPeekPosition()).isEqualTo(TEST_DATA.length);
 
     // Check that we can read again from the buffer
     byte[] target2 = new byte[TEST_DATA.length];
     input.readFully(target2, 0, TEST_DATA.length);
-    assertTrue(Arrays.equals(TEST_DATA, target2));
-    assertEquals(TEST_DATA.length, input.getPosition());
-    assertEquals(TEST_DATA.length, input.getPeekPosition());
+    assertThat(Arrays.equals(TEST_DATA, target2)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(TEST_DATA.length);
+    assertThat(input.getPeekPosition()).isEqualTo(TEST_DATA.length);
 
     // Check that we fail with EOFException if we peek again
     try {
@@ -311,20 +340,21 @@ public void testPeekFully() throws Exception {
     }
   }
 
+  @Test
   public void testResetPeekPosition() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.peekFully(target, 0, TEST_DATA.length);
 
     // Check that we read the whole of TEST_DATA.
-    assertTrue(Arrays.equals(TEST_DATA, target));
-    assertEquals(0, input.getPosition());
+    assertThat(Arrays.equals(TEST_DATA, target)).isTrue();
+    assertThat(input.getPosition()).isEqualTo(0);
 
     // Check that we can peek again after resetting.
     input.resetPeekPosition();
     byte[] target2 = new byte[TEST_DATA.length];
     input.peekFully(target2, 0, TEST_DATA.length);
-    assertTrue(Arrays.equals(TEST_DATA, target2));
+    assertThat(Arrays.equals(TEST_DATA, target2)).isTrue();
 
     // Check that we fail with EOFException if we peek past the end of the input.
     try {
@@ -335,40 +365,43 @@ public void testResetPeekPosition() throws Exception {
     }
   }
 
+  @Test
   public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
     // Check peeking up to the end of input succeeds.
-    assertTrue(input.peekFully(target, 0, TEST_DATA.length, true));
+    assertThat(input.peekFully(target, 0, TEST_DATA.length, true)).isTrue();
 
     // Check peeking at the end of input with allowEndOfInput signals the end of input.
-    assertFalse(input.peekFully(target, 0, 1, true));
+    assertThat(input.peekFully(target, 0, 1, true)).isFalse();
   }
 
+  @Test
   public void testPeekFullyAtEndThenReadEndOfInput() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
     // Peek up to the end of the input.
-    assertTrue(input.peekFully(target, 0, TEST_DATA.length, false));
+    assertThat(input.peekFully(target, 0, TEST_DATA.length, false)).isTrue();
 
     // Peek the end of the input.
-    assertFalse(input.peekFully(target, 0, 1, true));
+    assertThat(input.peekFully(target, 0, 1, true)).isFalse();
 
     // Read up to the end of the input.
-    assertTrue(input.readFully(target, 0, TEST_DATA.length, false));
+    assertThat(input.readFully(target, 0, TEST_DATA.length, false)).isTrue();
 
     // Read the end of the input.
-    assertFalse(input.readFully(target, 0, 1, true));
+    assertThat(input.readFully(target, 0, 1, true)).isFalse();
   }
 
+  @Test
   public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
     // Check peeking before the end of input with allowEndOfInput succeeds.
-    assertTrue(input.peekFully(target, 0, TEST_DATA.length - 1, true));
+    assertThat(input.peekFully(target, 0, TEST_DATA.length - 1, true)).isTrue();
 
     // Check peeking across the end of input with allowEndOfInput throws.
     try {
@@ -379,12 +412,13 @@ public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails() throws Excep
     }
   }
 
+  @Test
   public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
     // Check peeking up to the end of input succeeds.
-    assertTrue(input.peekFully(target, 0, TEST_DATA.length, true));
+    assertThat(input.peekFully(target, 0, TEST_DATA.length, true)).isTrue();
     input.resetPeekPosition();
     try {
       // Check peeking one more byte throws.
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
similarity index 60%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
index 250ae8c513..fc31a7be73 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
@@ -15,20 +15,28 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.C;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link Extractor}.
  */
-public class ExtractorTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ExtractorTest {
 
-  public static void testConstants() {
+  @Test
+  public void testConstants() {
     // Sanity check that constant values match those defined by {@link C}.
-    assertEquals(C.RESULT_END_OF_INPUT, Extractor.RESULT_END_OF_INPUT);
+    assertThat(Extractor.RESULT_END_OF_INPUT).isEqualTo(C.RESULT_END_OF_INPUT);
     // Sanity check that the other constant values don't overlap.
-    assertTrue(C.RESULT_END_OF_INPUT != Extractor.RESULT_CONTINUE);
-    assertTrue(C.RESULT_END_OF_INPUT != Extractor.RESULT_SEEK);
+    assertThat(C.RESULT_END_OF_INPUT != Extractor.RESULT_CONTINUE).isTrue();
+    assertThat(C.RESULT_END_OF_INPUT != Extractor.RESULT_SEEK).isTrue();
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
similarity index 92%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
index acc62f41f9..708ffde080 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -22,13 +24,19 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link DefaultEbmlReader}.
  */
-public class DefaultEbmlReaderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class DefaultEbmlReaderTest {
 
+  @Test
   public void testMasterElement() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x1A, 0x45, 0xDF, 0xA3, 0x84, 0x42, 0x85, 0x81, 0x01);
     TestOutput expected = new TestOutput();
@@ -38,6 +46,7 @@ public void testMasterElement() throws IOException, InterruptedException {
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testMasterElementEmpty() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x18, 0x53, 0x80, 0x67, 0x80);
     TestOutput expected = new TestOutput();
@@ -46,6 +55,7 @@ public void testMasterElementEmpty() throws IOException, InterruptedException {
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testUnsignedIntegerElement() throws IOException, InterruptedException {
     // 0xFE is chosen because for signed integers it should be interpreted as -2
     ExtractorInput input = createTestInput(0x42, 0xF7, 0x81, 0xFE);
@@ -54,6 +64,7 @@ public void testUnsignedIntegerElement() throws IOException, InterruptedExceptio
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testUnsignedIntegerElementLarge() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x42, 0xF7, 0x88, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
@@ -62,6 +73,7 @@ public void testUnsignedIntegerElementLarge() throws IOException, InterruptedExc
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testUnsignedIntegerElementTooLargeBecomesNegative()
       throws IOException, InterruptedException {
     ExtractorInput input =
@@ -71,6 +83,7 @@ public void testUnsignedIntegerElementTooLargeBecomesNegative()
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testStringElement() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x42, 0x82, 0x86, 0x41, 0x62, 0x63, 0x31, 0x32, 0x33);
     TestOutput expected = new TestOutput();
@@ -78,6 +91,7 @@ public void testStringElement() throws IOException, InterruptedException {
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testStringElementEmpty() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x42, 0x82, 0x80);
     TestOutput expected = new TestOutput();
@@ -85,6 +99,7 @@ public void testStringElementEmpty() throws IOException, InterruptedException {
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testFloatElementFourBytes() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x44, 0x89, 0x84, 0x3F, 0x80, 0x00, 0x00);
@@ -93,6 +108,7 @@ public void testFloatElementFourBytes() throws IOException, InterruptedException
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testFloatElementEightBytes() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0x44, 0x89, 0x88, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
@@ -101,6 +117,7 @@ public void testFloatElementEightBytes() throws IOException, InterruptedExceptio
     assertEvents(input, expected.events);
   }
 
+  @Test
   public void testBinaryElement() throws IOException, InterruptedException {
     ExtractorInput input =
         createTestInput(0xA3, 0x88, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08);
@@ -118,16 +135,16 @@ private static void assertEvents(ExtractorInput input, List<String> expectedEven
 
     // We expect the number of successful reads to equal the number of expected events.
     for (int i = 0; i < expectedEvents.size(); i++) {
-      assertTrue(reader.read(input));
+      assertThat(reader.read(input)).isTrue();
     }
     // The next read should be unsuccessful.
-    assertFalse(reader.read(input));
+    assertThat(reader.read(input)).isFalse();
     // Check that we really did get to the end of input.
-    assertFalse(input.readFully(new byte[1], 0, 1, true));
+    assertThat(input.readFully(new byte[1], 0, 1, true)).isFalse();
 
-    assertEquals(expectedEvents.size(), output.events.size());
+    assertThat(output.events).hasSize(expectedEvents.size());
     for (int i = 0; i < expectedEvents.size(); i++) {
-      assertEquals(expectedEvents.get(i), output.events.get(i));
+      assertThat(output.events.get(i)).isEqualTo(expectedEvents.get(i));
     }
   }
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
similarity index 92%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
index 3eb2c10a30..bda93db812 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
@@ -15,18 +15,28 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
+import static com.google.android.exoplayer2.C.RESULT_END_OF_INPUT;
+import static com.google.android.exoplayer2.C.RESULT_MAX_LENGTH_EXCEEDED;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import java.io.EOFException;
 import java.io.IOException;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link VarintReader}.
  */
-public final class VarintReaderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class VarintReaderTest {
 
   private static final byte MAX_BYTE = (byte) 0xFF;
 
@@ -78,6 +88,7 @@
   private static final long VALUE_8_BYTE_MAX = 0xFFFFFFFFFFFFFFL;
   private static final long VALUE_8_BYTE_MAX_WITH_MASK = 0x1FFFFFFFFFFFFFFL;
 
+  @Test
   public void testReadVarintEndOfInputAtStart() throws IOException, InterruptedException {
     VarintReader reader = new VarintReader();
     // Build an input with no data.
@@ -86,7 +97,7 @@ public void testReadVarintEndOfInputAtStart() throws IOException, InterruptedExc
         .build();
     // End of input allowed.
     long result = reader.readUnsignedVarint(input, true, false, 8);
-    assertEquals(C.RESULT_END_OF_INPUT, result);
+    assertThat(result).isEqualTo(RESULT_END_OF_INPUT);
     // End of input not allowed.
     try {
       reader.readUnsignedVarint(input, false, false, 8);
@@ -96,6 +107,7 @@ public void testReadVarintEndOfInputAtStart() throws IOException, InterruptedExc
     }
   }
 
+  @Test
   public void testReadVarintExceedsMaximumAllowedLength() throws IOException, InterruptedException {
     VarintReader reader = new VarintReader();
     ExtractorInput input = new FakeExtractorInput.Builder()
@@ -103,9 +115,10 @@ public void testReadVarintExceedsMaximumAllowedLength() throws IOException, Inte
         .setSimulateUnknownLength(true)
         .build();
     long result = reader.readUnsignedVarint(input, false, true, 4);
-    assertEquals(C.RESULT_MAX_LENGTH_EXCEEDED, result);
+    assertThat(result).isEqualTo(RESULT_MAX_LENGTH_EXCEEDED);
   }
 
+  @Test
   public void testReadVarint() throws IOException, InterruptedException {
     VarintReader reader = new VarintReader();
     testReadVarint(reader, true, DATA_1_BYTE_0, 1, 0);
@@ -142,6 +155,7 @@ public void testReadVarint() throws IOException, InterruptedException {
     testReadVarint(reader, false, DATA_8_BYTE_MAX, 8, VALUE_8_BYTE_MAX_WITH_MASK);
   }
 
+  @Test
   public void testReadVarintFlaky() throws IOException, InterruptedException {
     VarintReader reader = new VarintReader();
     testReadVarintFlaky(reader, true, DATA_1_BYTE_0, 1, 0);
@@ -185,8 +199,8 @@ private static void testReadVarint(VarintReader reader, boolean removeMask, byte
         .setSimulateUnknownLength(true)
         .build();
     long result = reader.readUnsignedVarint(input, false, removeMask, 8);
-    assertEquals(expectedLength, input.getPosition());
-    assertEquals(expectedValue, result);
+    assertThat(input.getPosition()).isEqualTo(expectedLength);
+    assertThat(result).isEqualTo(expectedValue);
   }
 
   private static void testReadVarintFlaky(VarintReader reader, boolean removeMask, byte[] data,
@@ -209,8 +223,8 @@ private static void testReadVarintFlaky(VarintReader reader, boolean removeMask,
         // Expected.
       }
     }
-    assertEquals(expectedLength, input.getPosition());
-    assertEquals(expectedValue, result);
+    assertThat(input.getPosition()).isEqualTo(expectedLength);
+    assertThat(result).isEqualTo(expectedValue);
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
similarity index 67%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
index 18775b17f4..b43949b7c2 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
@@ -15,16 +15,24 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link XingSeeker}.
  */
-public final class XingSeekerTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class XingSeekerTest {
 
   // Xing header/payload from http://storage.googleapis.com/exoplayer-test-media-0/play.mp3.
   private static final int XING_FRAME_HEADER_DATA = 0xFFFB3000;
@@ -51,7 +59,7 @@
   private XingSeeker seekerWithInputLength;
   private int xingFrameSize;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
     MpegAudioHeader xingFrameHeader = new MpegAudioHeader();
     MpegAudioHeader.populateHeader(XING_FRAME_HEADER_DATA, xingFrameHeader);
@@ -62,42 +70,49 @@ public void setUp() throws Exception {
     xingFrameSize = xingFrameHeader.frameSize;
   }
 
+  @Test
   public void testGetTimeUsBeforeFirstAudioFrame() {
-    assertEquals(0, seeker.getTimeUs(-1));
-    assertEquals(0, seekerWithInputLength.getTimeUs(-1));
+    assertThat(seeker.getTimeUs(-1)).isEqualTo(0);
+    assertThat(seekerWithInputLength.getTimeUs(-1)).isEqualTo(0);
   }
 
+  @Test
   public void testGetTimeUsAtFirstAudioFrame() {
-    assertEquals(0, seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize));
-    assertEquals(0, seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize));
+    assertThat(seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize)).isEqualTo(0);
+    assertThat(seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize)).isEqualTo(0);
   }
 
+  @Test
   public void testGetTimeUsAtEndOfStream() {
-    assertEquals(STREAM_DURATION_US,
-        seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES));
-    assertEquals(STREAM_DURATION_US,
-        seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES));
+    assertThat(seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES))
+        .isEqualTo(STREAM_DURATION_US);
+    assertThat(
+        seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES))
+        .isEqualTo(STREAM_DURATION_US);
   }
 
+  @Test
   public void testGetPositionAtStartOfStream() {
-    assertEquals(XING_FRAME_POSITION + xingFrameSize, seeker.getPosition(0));
-    assertEquals(XING_FRAME_POSITION + xingFrameSize, seekerWithInputLength.getPosition(0));
+    assertThat(seeker.getPosition(0)).isEqualTo(XING_FRAME_POSITION + xingFrameSize);
+    assertThat(seekerWithInputLength.getPosition(0)).isEqualTo(XING_FRAME_POSITION + xingFrameSize);
   }
 
+  @Test
   public void testGetPositionAtEndOfStream() {
-    assertEquals(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1,
-        seeker.getPosition(STREAM_DURATION_US));
-    assertEquals(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1,
-        seekerWithInputLength.getPosition(STREAM_DURATION_US));
+    assertThat(seeker.getPosition(STREAM_DURATION_US))
+        .isEqualTo(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1);
+    assertThat(seekerWithInputLength.getPosition(STREAM_DURATION_US))
+        .isEqualTo(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1);
   }
 
+  @Test
   public void testGetTimeForAllPositions() {
     for (int offset = xingFrameSize; offset < STREAM_SIZE_BYTES; offset++) {
       int position = XING_FRAME_POSITION + offset;
       long timeUs = seeker.getTimeUs(position);
-      assertEquals(position, seeker.getPosition(timeUs));
+      assertThat(seeker.getPosition(timeUs)).isEqualTo(position);
       timeUs = seekerWithInputLength.getTimeUs(position);
-      assertEquals(position, seekerWithInputLength.getPosition(timeUs));
+      assertThat(seekerWithInputLength.getPosition(timeUs)).isEqualTo(position);
     }
   }
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
similarity index 55%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
index d0213337b8..b0c37ee452 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
@@ -15,14 +15,21 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link AtomParsers}.
  */
-public final class AtomParsersTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class AtomParsersTest {
 
   private static final String ATOM_HEADER = "000000000000000000000000";
   private static final String SAMPLE_COUNT = "00000004";
@@ -33,24 +40,37 @@
   private static final byte[] SIXTEEN_BIT_STZ2 = Util.getBytesFromHexString(ATOM_HEADER + "00000010"
       + SAMPLE_COUNT + "0001000200030004");
 
+  @Test
+  public void testParseCommonEncryptionSinfFromParentIgnoresUnknownSchemeType() {
+    byte[] cencSinf = new byte[] {
+        0, 0, 0, 24, 115, 105, 110, 102, // size (4), 'sinf' (4)
+        0, 0, 0, 16, 115, 99, 104, 109, // size (4), 'schm' (4)
+        0, 0, 0, 0, 88, 88, 88, 88}; // version (1), flags (3), 'xxxx' (4)
+    assertThat(AtomParsers.parseCommonEncryptionSinfFromParent(
+        new ParsableByteArray(cencSinf), 0, cencSinf.length)).isNull();
+  }
+
+  @Test
   public void testStz2Parsing4BitFieldSize() {
-    verifyParsing(new Atom.LeafAtom(Atom.TYPE_stsz, new ParsableByteArray(FOUR_BIT_STZ2)));
+    verifyStz2Parsing(new Atom.LeafAtom(Atom.TYPE_stsz, new ParsableByteArray(FOUR_BIT_STZ2)));
   }
 
+  @Test
   public void testStz2Parsing8BitFieldSize() {
-    verifyParsing(new Atom.LeafAtom(Atom.TYPE_stsz, new ParsableByteArray(EIGHT_BIT_STZ2)));
+    verifyStz2Parsing(new Atom.LeafAtom(Atom.TYPE_stsz, new ParsableByteArray(EIGHT_BIT_STZ2)));
   }
 
+  @Test
   public void testStz2Parsing16BitFieldSize() {
-    verifyParsing(new Atom.LeafAtom(Atom.TYPE_stsz, new ParsableByteArray(SIXTEEN_BIT_STZ2)));
+    verifyStz2Parsing(new Atom.LeafAtom(Atom.TYPE_stsz, new ParsableByteArray(SIXTEEN_BIT_STZ2)));
   }
 
-  private void verifyParsing(Atom.LeafAtom stz2Atom) {
+  private static void verifyStz2Parsing(Atom.LeafAtom stz2Atom) {
     AtomParsers.Stz2SampleSizeBox box = new AtomParsers.Stz2SampleSizeBox(stz2Atom);
-    assertEquals(4, box.getSampleCount());
-    assertFalse(box.isFixedSampleSize());
+    assertThat(box.getSampleCount()).isEqualTo(4);
+    assertThat(box.isFixedSampleSize()).isFalse();
     for (int i = 0; i < box.getSampleCount(); i++) {
-      assertEquals(i + 1, box.readNextSampleSize());
+      assertThat(box.readNextSampleSize()).isEqualTo(i + 1);
     }
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
new file mode 100644
index 0000000000..4d7931cc02
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp4;
+
+import static com.google.android.exoplayer2.C.WIDEVINE_UUID;
+import static com.google.android.exoplayer2.extractor.mp4.Atom.TYPE_pssh;
+import static com.google.android.exoplayer2.extractor.mp4.Atom.parseFullAtomFlags;
+import static com.google.android.exoplayer2.extractor.mp4.Atom.parseFullAtomVersion;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.UUID;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Tests for {@link PsshAtomUtil}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class PsshAtomUtilTest {
+
+  @Test
+  public void testBuildPsshAtom() {
+    byte[] schemeData = new byte[]{0, 1, 2, 3, 4, 5};
+    byte[] psshAtom = PsshAtomUtil.buildPsshAtom(C.WIDEVINE_UUID, schemeData);
+    // Read the PSSH atom back and assert its content is as expected.
+    ParsableByteArray parsablePsshAtom = new ParsableByteArray(psshAtom);
+    assertThat(parsablePsshAtom.readUnsignedIntToInt()).isEqualTo(psshAtom.length); // length
+    assertThat(parsablePsshAtom.readInt()).isEqualTo(TYPE_pssh); // type
+    int fullAtomInt = parsablePsshAtom.readInt(); // version + flags
+    assertThat(parseFullAtomVersion(fullAtomInt)).isEqualTo(0);
+    assertThat(parseFullAtomFlags(fullAtomInt)).isEqualTo(0);
+    UUID systemId = new UUID(parsablePsshAtom.readLong(), parsablePsshAtom.readLong());
+    assertThat(systemId).isEqualTo(WIDEVINE_UUID);
+    assertThat(parsablePsshAtom.readUnsignedIntToInt()).isEqualTo(schemeData.length);
+    byte[] psshSchemeData = new byte[schemeData.length];
+    parsablePsshAtom.readBytes(psshSchemeData, 0, schemeData.length);
+    assertThat(psshSchemeData).isEqualTo(schemeData);
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
similarity index 70%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
index d52deb108f..a3f7e9a548 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
@@ -15,55 +15,68 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Random;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link DefaultOggSeeker} utility methods.
  */
-public class DefaultOggSeekerUtilMethodsTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class DefaultOggSeekerUtilMethodsTest {
 
   private final Random random = new Random(0);
 
+  @Test
   public void testSkipToNextPage() throws Exception {
-    FakeExtractorInput extractorInput = TestData.createInput(
+    FakeExtractorInput extractorInput = OggTestData.createInput(
         TestUtil.joinByteArrays(
             TestUtil.buildTestData(4000, random),
-            new byte[]{'O', 'g', 'g', 'S'},
+            new byte[] {'O', 'g', 'g', 'S'},
             TestUtil.buildTestData(4000, random)
         ), false);
     skipToNextPage(extractorInput);
-    assertEquals(4000, extractorInput.getPosition());
+    assertThat(extractorInput.getPosition()).isEqualTo(4000);
   }
 
+  @Test
   public void testSkipToNextPageOverlap() throws Exception {
-    FakeExtractorInput extractorInput = TestData.createInput(
+    FakeExtractorInput extractorInput = OggTestData.createInput(
         TestUtil.joinByteArrays(
             TestUtil.buildTestData(2046, random),
-            new byte[]{'O', 'g', 'g', 'S'},
+            new byte[] {'O', 'g', 'g', 'S'},
             TestUtil.buildTestData(4000, random)
         ), false);
     skipToNextPage(extractorInput);
-    assertEquals(2046, extractorInput.getPosition());
+    assertThat(extractorInput.getPosition()).isEqualTo(2046);
   }
 
+  @Test
   public void testSkipToNextPageInputShorterThanPeekLength() throws Exception {
-    FakeExtractorInput extractorInput = TestData.createInput(
+    FakeExtractorInput extractorInput = OggTestData.createInput(
         TestUtil.joinByteArrays(
-            new byte[]{'x', 'O', 'g', 'g', 'S'}
+            new byte[] {'x', 'O', 'g', 'g', 'S'}
         ), false);
     skipToNextPage(extractorInput);
-    assertEquals(1, extractorInput.getPosition());
+    assertThat(extractorInput.getPosition()).isEqualTo(1);
   }
 
+  @Test
   public void testSkipToNextPageNoMatch() throws Exception {
-    FakeExtractorInput extractorInput = TestData.createInput(
-        new byte[]{'g', 'g', 'S', 'O', 'g', 'g'}, false);
+    FakeExtractorInput extractorInput = OggTestData.createInput(
+        new byte[] {'g', 'g', 'S', 'O', 'g', 'g'}, false);
     try {
       skipToNextPage(extractorInput);
       fail();
@@ -84,16 +97,17 @@ private static void skipToNextPage(ExtractorInput extractorInput)
     }
   }
 
+  @Test
   public void testSkipToPageOfGranule() throws IOException, InterruptedException {
     byte[] packet = TestUtil.buildTestData(3 * 254, random);
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x01, 20000, 1000, 0x03),
+        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet,
-        TestData.buildOggHeader(0x04, 40000, 1001, 0x03),
+        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet,
-        TestData.buildOggHeader(0x04, 60000, 1002, 0x03),
+        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
@@ -101,44 +115,46 @@ public void testSkipToPageOfGranule() throws IOException, InterruptedException {
     // expect to be granule of the previous page returned as elapsedSamples
     skipToPageOfGranule(input, 54000, 40000);
     // expect to be at the start of the third page
-    assertEquals(2 * (30 + (3 * 254)), input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(2 * (30 + (3 * 254)));
   }
 
+  @Test
   public void testSkipToPageOfGranulePreciseMatch() throws IOException, InterruptedException {
     byte[] packet = TestUtil.buildTestData(3 * 254, random);
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x01, 20000, 1000, 0x03),
+        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet,
-        TestData.buildOggHeader(0x04, 40000, 1001, 0x03),
+        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet,
-        TestData.buildOggHeader(0x04, 60000, 1002, 0x03),
+        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
 
     skipToPageOfGranule(input, 40000, 20000);
     // expect to be at the start of the second page
-    assertEquals((30 + (3 * 254)), input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(30 + (3 * 254));
   }
 
+  @Test
   public void testSkipToPageOfGranuleAfterTargetPage() throws IOException, InterruptedException {
     byte[] packet = TestUtil.buildTestData(3 * 254, random);
     byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x01, 20000, 1000, 0x03),
+        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet,
-        TestData.buildOggHeader(0x04, 40000, 1001, 0x03),
+        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet,
-        TestData.buildOggHeader(0x04, 60000, 1002, 0x03),
+        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
         TestUtil.createByteArray(254, 254, 254), // Laces.
         packet);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
 
     skipToPageOfGranule(input, 10000, -1);
-    assertEquals(0, input.getPosition());
+    assertThat(input.getPosition()).isEqualTo(0);
   }
 
   private void skipToPageOfGranule(ExtractorInput input, long granule,
@@ -146,7 +162,8 @@ private void skipToPageOfGranule(ExtractorInput input, long granule,
     DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader(), 1, 2);
     while (true) {
       try {
-        assertEquals(elapsedSamplesExpected, oggSeeker.skipToPageOfGranule(input, granule, -1));
+        assertThat(oggSeeker.skipToPageOfGranule(input, granule, -1))
+            .isEqualTo(elapsedSamplesExpected);
         return;
       } catch (FakeExtractorInput.SimulatedIOException e) {
         input.resetPeekPosition();
@@ -154,24 +171,26 @@ private void skipToPageOfGranule(ExtractorInput input, long granule,
     }
   }
 
+  @Test
   public void testReadGranuleOfLastPage() throws IOException, InterruptedException {
-    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+    FakeExtractorInput input = OggTestData.createInput(TestUtil.joinByteArrays(
         TestUtil.buildTestData(100, random),
-        TestData.buildOggHeader(0x00, 20000, 66, 3),
+        OggTestData.buildOggHeader(0x00, 20000, 66, 3),
         TestUtil.createByteArray(254, 254, 254), // laces
         TestUtil.buildTestData(3 * 254, random),
-        TestData.buildOggHeader(0x00, 40000, 67, 3),
+        OggTestData.buildOggHeader(0x00, 40000, 67, 3),
         TestUtil.createByteArray(254, 254, 254), // laces
         TestUtil.buildTestData(3 * 254, random),
-        TestData.buildOggHeader(0x05, 60000, 68, 3),
+        OggTestData.buildOggHeader(0x05, 60000, 68, 3),
         TestUtil.createByteArray(254, 254, 254), // laces
         TestUtil.buildTestData(3 * 254, random)
     ), false);
     assertReadGranuleOfLastPage(input, 60000);
   }
 
+  @Test
   public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, InterruptedException {
-    FakeExtractorInput input = TestData.createInput(TestUtil.buildTestData(100, random), false);
+    FakeExtractorInput input = OggTestData.createInput(TestUtil.buildTestData(100, random), false);
     try {
       assertReadGranuleOfLastPage(input, 60000);
       fail();
@@ -180,9 +199,10 @@ public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, Inter
     }
   }
 
+  @Test
   public void testReadGranuleOfLastPageWithUnboundedLength()
       throws IOException, InterruptedException {
-    FakeExtractorInput input = TestData.createInput(new byte[0], true);
+    FakeExtractorInput input = OggTestData.createInput(new byte[0], true);
     try {
       assertReadGranuleOfLastPage(input, 60000);
       fail();
@@ -196,7 +216,7 @@ private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
     DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader(), 1, 2);
     while (true) {
       try {
-        assertEquals(expected, oggSeeker.readGranuleOfLastPage(input));
+        assertThat(oggSeeker.readGranuleOfLastPage(input)).isEqualTo(expected);
         break;
       } catch (FakeExtractorInput.SimulatedIOException e) {
         // ignored
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
similarity index 59%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
index 9d39eba174..c8bcffde3c 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
@@ -15,67 +15,79 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
+import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link OggPageHeader}.
  */
-public final class OggPageHeaderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class OggPageHeaderTest {
 
+  @Test
   public void testPopulatePageHeader() throws IOException, InterruptedException {
-    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x01, 123456, 4, 2),
+    FakeExtractorInput input = OggTestData.createInput(TestUtil.joinByteArrays(
+        OggTestData.buildOggHeader(0x01, 123456, 4, 2),
         TestUtil.createByteArray(2, 2)
     ), true);
     OggPageHeader header = new OggPageHeader();
     populatePageHeader(input, header, false);
 
-    assertEquals(0x01, header.type);
-    assertEquals(27 + 2, header.headerSize);
-    assertEquals(4, header.bodySize);
-    assertEquals(2, header.pageSegmentCount);
-    assertEquals(123456, header.granulePosition);
-    assertEquals(4, header.pageSequenceNumber);
-    assertEquals(0x1000, header.streamSerialNumber);
-    assertEquals(0x100000, header.pageChecksum);
-    assertEquals(0, header.revision);
+    assertThat(header.type).isEqualTo(0x01);
+    assertThat(header.headerSize).isEqualTo(27 + 2);
+    assertThat(header.bodySize).isEqualTo(4);
+    assertThat(header.pageSegmentCount).isEqualTo(2);
+    assertThat(header.granulePosition).isEqualTo(123456);
+    assertThat(header.pageSequenceNumber).isEqualTo(4);
+    assertThat(header.streamSerialNumber).isEqualTo(0x1000);
+    assertThat(header.pageChecksum).isEqualTo(0x100000);
+    assertThat(header.revision).isEqualTo(0);
   }
 
+  @Test
   public void testPopulatePageHeaderQuiteOnExceptionLessThan27Bytes()
       throws IOException, InterruptedException {
-    FakeExtractorInput input = TestData.createInput(TestUtil.createByteArray(2, 2), false);
+    FakeExtractorInput input = OggTestData.createInput(TestUtil.createByteArray(2, 2), false);
     OggPageHeader header = new OggPageHeader();
-    assertFalse(populatePageHeader(input, header, true));
+    assertThat(populatePageHeader(input, header, true)).isFalse();
   }
 
+  @Test
   public void testPopulatePageHeaderQuiteOnExceptionNotOgg()
       throws IOException, InterruptedException {
     byte[] headerBytes = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x01, 123456, 4, 2),
+        OggTestData.buildOggHeader(0x01, 123456, 4, 2),
         TestUtil.createByteArray(2, 2)
     );
     // change from 'O' to 'o'
     headerBytes[0] = 'o';
-    FakeExtractorInput input = TestData.createInput(headerBytes, false);
+    FakeExtractorInput input = OggTestData.createInput(headerBytes, false);
     OggPageHeader header = new OggPageHeader();
-    assertFalse(populatePageHeader(input, header, true));
+    assertThat(populatePageHeader(input, header, true)).isFalse();
   }
 
+  @Test
   public void testPopulatePageHeaderQuiteOnExceptionWrongRevision()
       throws IOException, InterruptedException {
     byte[] headerBytes = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x01, 123456, 4, 2),
+        OggTestData.buildOggHeader(0x01, 123456, 4, 2),
         TestUtil.createByteArray(2, 2)
     );
     // change revision from 0 to 1
     headerBytes[4] = 0x01;
-    FakeExtractorInput input = TestData.createInput(headerBytes, false);
+    FakeExtractorInput input = OggTestData.createInput(headerBytes, false);
     OggPageHeader header = new OggPageHeader();
-    assertFalse(populatePageHeader(input, header, true));
+    assertThat(populatePageHeader(input, header, true)).isFalse();
   }
 
   private boolean populatePageHeader(FakeExtractorInput input, OggPageHeader header,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
new file mode 100644
index 0000000000..08b9b12a18
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ogg;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.testutil.TestUtil;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link VorbisBitArray}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class VorbisBitArrayTest {
+
+  @Test
+  public void testReadBit() {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x5c, 0x50));
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isFalse();
+  }
+
+  @Test
+  public void testSkipBits() {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));
+    bitArray.skipBits(10);
+    assertThat(bitArray.getPosition()).isEqualTo(10);
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isFalse();
+    bitArray.skipBits(1);
+    assertThat(bitArray.getPosition()).isEqualTo(14);
+    assertThat(bitArray.readBit()).isFalse();
+    assertThat(bitArray.readBit()).isFalse();
+  }
+
+  @Test
+  public void testGetPosition() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));
+    assertThat(bitArray.getPosition()).isEqualTo(0);
+    bitArray.readBit();
+    assertThat(bitArray.getPosition()).isEqualTo(1);
+    bitArray.readBit();
+    bitArray.readBit();
+    bitArray.skipBits(4);
+    assertThat(bitArray.getPosition()).isEqualTo(7);
+  }
+
+  @Test
+  public void testSetPosition() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));
+    assertThat(bitArray.getPosition()).isEqualTo(0);
+    bitArray.setPosition(4);
+    assertThat(bitArray.getPosition()).isEqualTo(4);
+    bitArray.setPosition(15);
+    assertThat(bitArray.readBit()).isFalse();
+  }
+
+  @Test
+  public void testReadInt32() {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F, 0xF0, 0x0F));
+    assertThat(bitArray.readBits(32)).isEqualTo(0x0FF00FF0);
+    bitArray = new VorbisBitArray(TestUtil.createByteArray(0x0F, 0xF0, 0x0F, 0xF0));
+    assertThat(bitArray.readBits(32)).isEqualTo(0xF00FF00F);
+  }
+
+  @Test
+  public void testReadBits() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x03, 0x22));
+    assertThat(bitArray.readBits(2)).isEqualTo(3);
+    bitArray.skipBits(6);
+    assertThat(bitArray.readBits(2)).isEqualTo(2);
+    bitArray.skipBits(2);
+    assertThat(bitArray.readBits(2)).isEqualTo(2);
+    bitArray.reset();
+    assertThat(bitArray.readBits(16)).isEqualTo(0x2203);
+  }
+
+  @Test
+  public void testRead4BitsBeyondBoundary() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x2e, 0x10));
+    assertThat(bitArray.readBits(7)).isEqualTo(0x2e);
+    assertThat(bitArray.getPosition()).isEqualTo(7);
+    assertThat(bitArray.readBits(4)).isEqualTo(0x0);
+  }
+
+  @Test
+  public void testReadBitsBeyondByteBoundaries() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xFF, 0x0F, 0xFF, 0x0F));
+    assertThat(bitArray.readBits(32)).isEqualTo(0x0FFF0FFF);
+
+    bitArray.reset();
+    bitArray.skipBits(4);
+    assertThat(bitArray.readBits(16)).isEqualTo(0xF0FF);
+
+    bitArray.reset();
+    bitArray.skipBits(6);
+    assertThat(bitArray.readBits(12)).isEqualTo(0xc3F);
+
+    bitArray.reset();
+    bitArray.skipBits(6);
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.readBit()).isTrue();
+    assertThat(bitArray.bitsLeft()).isEqualTo(24);
+
+    bitArray.reset();
+    bitArray.skipBits(10);
+    assertThat(bitArray.readBits(5)).isEqualTo(3);
+    assertThat(bitArray.getPosition()).isEqualTo(15);
+  }
+
+  @Test
+  public void testReadBitsIllegalLengths() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0x03, 0x22, 0x30));
+
+    // reading zero bits gets 0 without advancing position
+    // (like a zero-bit read is defined to yield zer0)
+    assertThat(bitArray.readBits(0)).isEqualTo(0);
+    assertThat(bitArray.getPosition()).isEqualTo(0);
+    bitArray.readBit();
+    assertThat(bitArray.getPosition()).isEqualTo(1);
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
new file mode 100644
index 0000000000..20a76e83e0
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ogg;
+
+import static com.google.android.exoplayer2.extractor.ogg.VorbisReader.readBits;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.ogg.VorbisReader.VorbisSetup;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
+import com.google.android.exoplayer2.testutil.OggTestData;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link VorbisReader}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class VorbisReaderTest {
+
+  @Test
+  public void testReadBits() throws Exception {
+    assertThat(readBits((byte) 0x00, 2, 2)).isEqualTo(0);
+    assertThat(readBits((byte) 0x02, 1, 1)).isEqualTo(1);
+    assertThat(readBits((byte) 0xF0, 4, 4)).isEqualTo(15);
+    assertThat(readBits((byte) 0x80, 1, 7)).isEqualTo(1);
+  }
+
+  @Test
+  public void testAppendNumberOfSamples() throws Exception {
+    ParsableByteArray buffer = new ParsableByteArray(4);
+    buffer.setLimit(0);
+    VorbisReader.appendNumberOfSamples(buffer, 0x01234567);
+    assertThat(buffer.limit()).isEqualTo(4);
+    assertThat(buffer.data[0]).isEqualTo(0x67);
+    assertThat(buffer.data[1]).isEqualTo(0x45);
+    assertThat(buffer.data[2]).isEqualTo(0x23);
+    assertThat(buffer.data[3]).isEqualTo(0x01);
+  }
+
+  @Test
+  public void testReadSetupHeadersWithIOExceptions() throws IOException, InterruptedException {
+    byte[] data = OggTestData.getVorbisHeaderPages();
+    ExtractorInput input = new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
+        .setSimulateUnknownLength(true).setSimulatePartialReads(true).build();
+
+    VorbisReader reader = new VorbisReader();
+    VorbisReader.VorbisSetup vorbisSetup = readSetupHeaders(reader, input);
+
+    assertThat(vorbisSetup.idHeader).isNotNull();
+    assertThat(vorbisSetup.commentHeader).isNotNull();
+    assertThat(vorbisSetup.setupHeaderData).isNotNull();
+    assertThat(vorbisSetup.modes).isNotNull();
+
+    assertThat(vorbisSetup.commentHeader.length).isEqualTo(45);
+    assertThat(vorbisSetup.idHeader.data).hasLength(30);
+    assertThat(vorbisSetup.setupHeaderData).hasLength(3597);
+
+    assertThat(vorbisSetup.idHeader.bitrateMax).isEqualTo(-1);
+    assertThat(vorbisSetup.idHeader.bitrateMin).isEqualTo(-1);
+    assertThat(vorbisSetup.idHeader.bitrateNominal).isEqualTo(66666);
+    assertThat(vorbisSetup.idHeader.blockSize0).isEqualTo(512);
+    assertThat(vorbisSetup.idHeader.blockSize1).isEqualTo(1024);
+    assertThat(vorbisSetup.idHeader.channels).isEqualTo(2);
+    assertThat(vorbisSetup.idHeader.framingFlag).isTrue();
+    assertThat(vorbisSetup.idHeader.sampleRate).isEqualTo(22050);
+    assertThat(vorbisSetup.idHeader.version).isEqualTo(0);
+
+    assertThat(vorbisSetup.commentHeader.vendor).isEqualTo("Xiph.Org libVorbis I 20030909");
+    assertThat(vorbisSetup.iLogModes).isEqualTo(1);
+
+    assertThat(vorbisSetup.setupHeaderData[vorbisSetup.setupHeaderData.length - 1])
+        .isEqualTo(data[data.length - 1]);
+
+    assertThat(vorbisSetup.modes[0].blockFlag).isFalse();
+    assertThat(vorbisSetup.modes[1].blockFlag).isTrue();
+  }
+
+  private static VorbisSetup readSetupHeaders(VorbisReader reader, ExtractorInput input)
+      throws IOException, InterruptedException {
+    OggPacket oggPacket = new OggPacket();
+    while (true) {
+      try {
+        if (!oggPacket.populate(input)) {
+          fail();
+        }
+        VorbisSetup vorbisSetup = reader.readSetupHeaders(oggPacket.getPayload());
+        if (vorbisSetup != null) {
+          return vorbisSetup;
+        }
+      } catch (SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
new file mode 100644
index 0000000000..bdc573f218
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ogg;
+
+import static com.google.android.exoplayer2.extractor.ogg.VorbisUtil.iLog;
+import static com.google.android.exoplayer2.extractor.ogg.VorbisUtil.verifyVorbisHeaderCapturePattern;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.testutil.OggTestData;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link VorbisUtil}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class VorbisUtilTest {
+
+  @Test
+  public void testILog() throws Exception {
+    assertThat(iLog(0)).isEqualTo(0);
+    assertThat(iLog(1)).isEqualTo(1);
+    assertThat(iLog(2)).isEqualTo(2);
+    assertThat(iLog(3)).isEqualTo(2);
+    assertThat(iLog(4)).isEqualTo(3);
+    assertThat(iLog(5)).isEqualTo(3);
+    assertThat(iLog(8)).isEqualTo(4);
+    assertThat(iLog(-1)).isEqualTo(0);
+    assertThat(iLog(-122)).isEqualTo(0);
+  }
+
+  @Test
+  public void testReadIdHeader() throws Exception {
+    byte[] data = OggTestData.getIdentificationHeaderData();
+    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
+    VorbisUtil.VorbisIdHeader vorbisIdHeader =
+        VorbisUtil.readVorbisIdentificationHeader(headerData);
+
+    assertThat(vorbisIdHeader.sampleRate).isEqualTo(22050);
+    assertThat(vorbisIdHeader.version).isEqualTo(0);
+    assertThat(vorbisIdHeader.framingFlag).isTrue();
+    assertThat(vorbisIdHeader.channels).isEqualTo(2);
+    assertThat(vorbisIdHeader.blockSize0).isEqualTo(512);
+    assertThat(vorbisIdHeader.blockSize1).isEqualTo(1024);
+    assertThat(vorbisIdHeader.bitrateMax).isEqualTo(-1);
+    assertThat(vorbisIdHeader.bitrateMin).isEqualTo(-1);
+    assertThat(vorbisIdHeader.bitrateNominal).isEqualTo(66666);
+    assertThat(vorbisIdHeader.getApproximateBitrate()).isEqualTo(66666);
+  }
+
+  @Test
+  public void testReadCommentHeader() throws ParserException {
+    byte[] data = OggTestData.getCommentHeaderDataUTF8();
+    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
+    VorbisUtil.CommentHeader commentHeader = VorbisUtil.readVorbisCommentHeader(headerData);
+
+    assertThat(commentHeader.vendor).isEqualTo("Xiph.Org libVorbis I 20120203 (Omnipresent)");
+    assertThat(commentHeader.comments).hasLength(3);
+    assertThat(commentHeader.comments[0]).isEqualTo("ALBUM=äö");
+    assertThat(commentHeader.comments[1]).isEqualTo("TITLE=A sample song");
+    assertThat(commentHeader.comments[2]).isEqualTo("ARTIST=Google");
+  }
+
+  @Test
+  public void testReadVorbisModes() throws ParserException {
+    byte[] data = OggTestData.getSetupHeaderData();
+    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
+    VorbisUtil.Mode[] modes = VorbisUtil.readVorbisModes(headerData, 2);
+
+    assertThat(modes).hasLength(2);
+    assertThat(modes[0].blockFlag).isFalse();
+    assertThat(modes[0].mapping).isEqualTo(0);
+    assertThat(modes[0].transformType).isEqualTo(0);
+    assertThat(modes[0].windowType).isEqualTo(0);
+    assertThat(modes[1].blockFlag).isTrue();
+    assertThat(modes[1].mapping).isEqualTo(1);
+    assertThat(modes[1].transformType).isEqualTo(0);
+    assertThat(modes[1].windowType).isEqualTo(0);
+  }
+
+  @Test
+  public void testVerifyVorbisHeaderCapturePattern() throws ParserException {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertThat(verifyVorbisHeaderCapturePattern(0x01, header, false)).isTrue();
+  }
+
+  @Test
+  public void testVerifyVorbisHeaderCapturePatternInvalidHeader() {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    try {
+      VorbisUtil.verifyVorbisHeaderCapturePattern(0x99, header, false);
+      fail();
+    } catch (ParserException e) {
+      assertThat(e.getMessage()).isEqualTo("expected header type 99");
+    }
+  }
+
+  @Test
+  public void testVerifyVorbisHeaderCapturePatternInvalidHeaderQuite() throws ParserException {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertThat(verifyVorbisHeaderCapturePattern(0x99, header, true)).isFalse();
+  }
+
+  @Test
+  public void testVerifyVorbisHeaderCapturePatternInvalidPattern() {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[] {0x01, 'x', 'v', 'o', 'r', 'b', 'i', 's'});
+    try {
+      VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, false);
+      fail();
+    } catch (ParserException e) {
+      assertThat(e.getMessage()).isEqualTo("expected characters 'vorbis'");
+    }
+  }
+
+  @Test
+  public void testVerifyVorbisHeaderCapturePatternQuiteInvalidPatternQuite()
+      throws ParserException {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[] {0x01, 'x', 'v', 'o', 'r', 'b', 'i', 's'});
+    assertThat(verifyVorbisHeaderCapturePattern(0x01, header, true)).isFalse();
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
similarity index 81%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index c4d9de3100..56668d5124 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -15,26 +15,35 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
-import junit.framework.TestCase;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link SectionReader}.
  */
-public class SectionReaderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class SectionReaderTest {
 
   private byte[] packetPayload;
   private CustomSectionPayloadReader payloadReader;
   private SectionReader reader;
 
-  @Override
+  @Before
   public void setUp() {
     packetPayload = new byte[512];
     Arrays.fill(packetPayload, (byte) 0xFF);
@@ -44,27 +53,30 @@ public void setUp() {
         new TsPayloadReader.TrackIdGenerator(0, 1));
   }
 
+  @Test
   public void testSingleOnePacketSection() {
     packetPayload[0] = 3;
     insertTableSection(4, (byte) 99, 3);
     reader.consume(new ParsableByteArray(packetPayload), true);
-    assertEquals(Collections.singletonList(99), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(99));
   }
 
+  @Test
   public void testHeaderSplitAcrossPackets() {
     packetPayload[0] = 3; // The first packet includes a pointer_field.
     insertTableSection(4, (byte) 100, 3); // This section header spreads across both packets.
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 5);
     reader.consume(firstPacket, true);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
     secondPacket.setPosition(5);
     reader.consume(secondPacket, false);
-    assertEquals(Collections.singletonList(100), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(100));
   }
 
+  @Test
   public void testFiveSectionsInTwoPackets() {
     packetPayload[0] = 0; // The first packet includes a pointer_field.
     insertTableSection(1, (byte) 101, 10);
@@ -76,14 +88,15 @@ public void testFiveSectionsInTwoPackets() {
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 40);
     reader.consume(firstPacket, true);
-    assertEquals(Arrays.asList(101, 102, 103), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(asList(101, 102, 103));
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
     secondPacket.setPosition(40);
     reader.consume(secondPacket, true);
-    assertEquals(Arrays.asList(101, 102, 103, 104, 105), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(asList(101, 102, 103, 104, 105));
   }
 
+  @Test
   public void testLongSectionAcrossFourPackets() {
     packetPayload[0] = 13; // The first packet includes a pointer_field.
     insertTableSection(1, (byte) 106, 10); // First section. Should be skipped.
@@ -95,24 +108,25 @@ public void testLongSectionAcrossFourPackets() {
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
     reader.consume(firstPacket, true);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
     secondPacket.setPosition(100);
     reader.consume(secondPacket, false);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
     thirdPacket.setPosition(200);
     reader.consume(thirdPacket, false);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
     fourthPacket.setPosition(300);
     reader.consume(fourthPacket, true);
-    assertEquals(Arrays.asList(107, 108), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(asList(107, 108));
   }
 
+  @Test
   public void testSeek() {
     packetPayload[0] = 13; // The first packet includes a pointer_field.
     insertTableSection(1, (byte) 109, 10); // First section. Should be skipped.
@@ -124,26 +138,27 @@ public void testSeek() {
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
     reader.consume(firstPacket, true);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
     secondPacket.setPosition(100);
     reader.consume(secondPacket, false);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
     thirdPacket.setPosition(200);
     reader.consume(thirdPacket, false);
-    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEmpty();
 
     reader.seek();
 
     ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
     fourthPacket.setPosition(300);
     reader.consume(fourthPacket, true);
-    assertEquals(Collections.singletonList(111), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(111));
   }
 
+  @Test
   public void testCrcChecks() {
     byte[] correctCrcPat = new byte[] {
         (byte) 0x0, (byte) 0x0, (byte) 0xb0, (byte) 0xd, (byte) 0x0, (byte) 0x1, (byte) 0xc1,
@@ -153,9 +168,9 @@ public void testCrcChecks() {
     // Crc field is incorrect, and should not be passed to the payload reader.
     incorrectCrcPat[16]--;
     reader.consume(new ParsableByteArray(correctCrcPat), true);
-    assertEquals(Collections.singletonList(0), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(0));
     reader.consume(new ParsableByteArray(incorrectCrcPat), true);
-    assertEquals(Collections.singletonList(0), payloadReader.parsedTableIds);
+    assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(0));
   }
 
   // Internal methods.
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
similarity index 70%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
index b33dfd1067..1ce0ccb93d 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -15,17 +15,24 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
-import android.test.MoreAsserts;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import java.nio.ByteBuffer;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link EventMessageDecoder}.
  */
-public final class EventMessageDecoderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class EventMessageDecoderTest {
 
+  @Test
   public void testDecodeEventMessage() {
     byte[] rawEmsgBody = new byte[] {
         117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
@@ -39,13 +46,13 @@ public void testDecodeEventMessage() {
     MetadataInputBuffer buffer = new MetadataInputBuffer();
     buffer.data = ByteBuffer.allocate(rawEmsgBody.length).put(rawEmsgBody);
     Metadata metadata = decoder.decode(buffer);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     EventMessage eventMessage = (EventMessage) metadata.get(0);
-    assertEquals("urn:test", eventMessage.schemeIdUri);
-    assertEquals("123", eventMessage.value);
-    assertEquals(3000, eventMessage.durationMs);
-    assertEquals(1000403, eventMessage.id);
-    MoreAsserts.assertEquals(new byte[] {0, 1, 2, 3, 4}, eventMessage.messageData);
+    assertThat(eventMessage.schemeIdUri).isEqualTo("urn:test");
+    assertThat(eventMessage.value).isEqualTo("123");
+    assertThat(eventMessage.durationMs).isEqualTo(3000);
+    assertThat(eventMessage.id).isEqualTo(1000403);
+    assertThat(eventMessage.messageData).isEqualTo(new byte[]{0, 1, 2, 3, 4});
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
similarity index 74%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
index baafb6b18b..b48a071d0d 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -15,14 +15,22 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.os.Parcel;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link EventMessage}.
  */
-public final class EventMessageTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class EventMessageTest {
 
+  @Test
   public void testEventMessageParcelable() {
     EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
         new byte[] {0, 1, 2, 3, 4});
@@ -33,7 +41,7 @@ public void testEventMessageParcelable() {
     parcel.setDataPosition(0);
     EventMessage fromParcelEventMessage = EventMessage.CREATOR.createFromParcel(parcel);
     // Assert equals.
-    assertEquals(eventMessage, fromParcelEventMessage);
+    assertThat(fromParcelEventMessage).isEqualTo(eventMessage);
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
similarity index 75%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
index 182ae6f1c9..a42b71731a 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
@@ -15,14 +15,22 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.os.Parcel;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link ChapterFrame}.
  */
-public final class ChapterFrameTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ChapterFrameTest {
 
+  @Test
   public void testParcelable() {
     Id3Frame[] subFrames = new Id3Frame[] {
       new TextInformationFrame("TIT2", null, "title"),
@@ -35,7 +43,7 @@ public void testParcelable() {
     parcel.setDataPosition(0);
 
     ChapterFrame chapterFrameFromParcel = ChapterFrame.CREATOR.createFromParcel(parcel);
-    assertEquals(chapterFrameToParcel, chapterFrameFromParcel);
+    assertThat(chapterFrameFromParcel).isEqualTo(chapterFrameToParcel);
 
     parcel.recycle();
   }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
similarity index 76%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
index 9641de7669..9636b04e51 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
@@ -15,14 +15,22 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.os.Parcel;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link ChapterTocFrame}.
  */
-public final class ChapterTocFrameTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ChapterTocFrameTest {
 
+  @Test
   public void testParcelable() {
     String[] children = new String[] {"child0", "child1"};
     Id3Frame[] subFrames = new Id3Frame[] {
@@ -37,7 +45,7 @@ public void testParcelable() {
     parcel.setDataPosition(0);
 
     ChapterTocFrame chapterTocFrameFromParcel = ChapterTocFrame.CREATOR.createFromParcel(parcel);
-    assertEquals(chapterTocFrameToParcel, chapterTocFrameFromParcel);
+    assertThat(chapterTocFrameFromParcel).isEqualTo(chapterTocFrameToParcel);
 
     parcel.recycle();
   }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
similarity index 66%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index 6b39ed1645..06ce330146 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -15,182 +15,197 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
-import android.test.MoreAsserts;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoderException;
 import com.google.android.exoplayer2.util.Assertions;
-import junit.framework.TestCase;
+import java.nio.charset.Charset;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link Id3Decoder}.
  */
-public final class Id3DecoderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class Id3DecoderTest {
 
   private static final byte[] TAG_HEADER = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 0};
   private static final int FRAME_HEADER_LENGTH = 10;
   private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
 
+  @Test
   public void testDecodeTxxxFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("TXXX", new byte[] {3, 0, 109, 100, 105, 97, 108, 111, 103,
         95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50, 55, 54, 54, 52, 95, 115, 116, 97, 114, 116, 0});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
-    assertEquals("TXXX", textInformationFrame.id);
-    assertEquals("", textInformationFrame.description);
-    assertEquals("mdialog_VINDICO1527664_start", textInformationFrame.value);
+    assertThat(textInformationFrame.id).isEqualTo("TXXX");
+    assertThat(textInformationFrame.description).isEmpty();
+    assertThat(textInformationFrame.value).isEqualTo("mdialog_VINDICO1527664_start");
 
     // Test empty.
     rawId3 = buildSingleFrameTag("TXXX", new byte[0]);
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(0, metadata.length());
+    assertThat(metadata.length()).isEqualTo(0);
 
     // Test encoding byte only.
     rawId3 = buildSingleFrameTag("TXXX", new byte[] {ID3_TEXT_ENCODING_UTF_8});
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     textInformationFrame = (TextInformationFrame) metadata.get(0);
-    assertEquals("TXXX", textInformationFrame.id);
-    assertEquals("", textInformationFrame.description);
-    assertEquals("", textInformationFrame.value);
+    assertThat(textInformationFrame.id).isEqualTo("TXXX");
+    assertThat(textInformationFrame.description).isEmpty();
+    assertThat(textInformationFrame.value).isEmpty();
   }
 
+  @Test
   public void testDecodeTextInformationFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("TIT2", new byte[] {3, 72, 101, 108, 108, 111, 32, 87, 111,
         114, 108, 100, 0});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
-    assertEquals("TIT2", textInformationFrame.id);
-    assertNull(textInformationFrame.description);
-    assertEquals("Hello World", textInformationFrame.value);
+    assertThat(textInformationFrame.id).isEqualTo("TIT2");
+    assertThat(textInformationFrame.description).isNull();
+    assertThat(textInformationFrame.value).isEqualTo("Hello World");
 
     // Test empty.
     rawId3 = buildSingleFrameTag("TIT2", new byte[0]);
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(0, metadata.length());
+    assertThat(metadata.length()).isEqualTo(0);
 
     // Test encoding byte only.
     rawId3 = buildSingleFrameTag("TIT2", new byte[] {ID3_TEXT_ENCODING_UTF_8});
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     textInformationFrame = (TextInformationFrame) metadata.get(0);
-    assertEquals("TIT2", textInformationFrame.id);
-    assertEquals(null, textInformationFrame.description);
-    assertEquals("", textInformationFrame.value);
+    assertThat(textInformationFrame.id).isEqualTo("TIT2");
+    assertThat(textInformationFrame.description).isNull();
+    assertThat(textInformationFrame.value).isEmpty();
   }
 
+  @Test
   public void testDecodeWxxxFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("WXXX", new byte[] {ID3_TEXT_ENCODING_UTF_8, 116, 101, 115,
         116, 0, 104, 116, 116, 112, 115, 58, 47, 47, 116, 101, 115, 116, 46, 99, 111, 109, 47, 97,
         98, 99, 63, 100, 101, 102});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     UrlLinkFrame urlLinkFrame = (UrlLinkFrame) metadata.get(0);
-    assertEquals("WXXX", urlLinkFrame.id);
-    assertEquals("test", urlLinkFrame.description);
-    assertEquals("https://test.com/abc?def", urlLinkFrame.url);
+    assertThat(urlLinkFrame.id).isEqualTo("WXXX");
+    assertThat(urlLinkFrame.description).isEqualTo("test");
+    assertThat(urlLinkFrame.url).isEqualTo("https://test.com/abc?def");
 
     // Test empty.
     rawId3 = buildSingleFrameTag("WXXX", new byte[0]);
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(0, metadata.length());
+    assertThat(metadata.length()).isEqualTo(0);
 
     // Test encoding byte only.
     rawId3 = buildSingleFrameTag("WXXX", new byte[] {ID3_TEXT_ENCODING_UTF_8});
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     urlLinkFrame = (UrlLinkFrame) metadata.get(0);
-    assertEquals("WXXX", urlLinkFrame.id);
-    assertEquals("", urlLinkFrame.description);
-    assertEquals("", urlLinkFrame.url);
+    assertThat(urlLinkFrame.id).isEqualTo("WXXX");
+    assertThat(urlLinkFrame.description).isEmpty();
+    assertThat(urlLinkFrame.url).isEmpty();
   }
 
+  @Test
   public void testDecodeUrlLinkFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("WCOM", new byte[] {104, 116, 116, 112, 115, 58, 47, 47,
         116, 101, 115, 116, 46, 99, 111, 109, 47, 97, 98, 99, 63, 100, 101, 102});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     UrlLinkFrame urlLinkFrame = (UrlLinkFrame) metadata.get(0);
-    assertEquals("WCOM", urlLinkFrame.id);
-    assertEquals(null, urlLinkFrame.description);
-    assertEquals("https://test.com/abc?def", urlLinkFrame.url);
+    assertThat(urlLinkFrame.id).isEqualTo("WCOM");
+    assertThat(urlLinkFrame.description).isNull();
+    assertThat(urlLinkFrame.url).isEqualTo("https://test.com/abc?def");
 
     // Test empty.
     rawId3 = buildSingleFrameTag("WCOM", new byte[0]);
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     urlLinkFrame = (UrlLinkFrame) metadata.get(0);
-    assertEquals("WCOM", urlLinkFrame.id);
-    assertEquals(null, urlLinkFrame.description);
-    assertEquals("", urlLinkFrame.url);
+    assertThat(urlLinkFrame.id).isEqualTo("WCOM");
+    assertThat(urlLinkFrame.description).isNull();
+    assertThat(urlLinkFrame.url).isEmpty();
   }
 
+  @Test
   public void testDecodePrivFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("PRIV", new byte[] {116, 101, 115, 116, 0, 1, 2, 3, 4});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     PrivFrame privFrame = (PrivFrame) metadata.get(0);
-    assertEquals("test", privFrame.owner);
-    MoreAsserts.assertEquals(new byte[] {1, 2, 3, 4}, privFrame.privateData);
+    assertThat(privFrame.owner).isEqualTo("test");
+    assertThat(privFrame.privateData).isEqualTo(new byte[]{1, 2, 3, 4});
 
     // Test empty.
     rawId3 = buildSingleFrameTag("PRIV", new byte[0]);
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     privFrame = (PrivFrame) metadata.get(0);
-    assertEquals("", privFrame.owner);
-    MoreAsserts.assertEquals(new byte[0], privFrame.privateData);
+    assertThat(privFrame.owner).isEmpty();
+    assertThat(privFrame.privateData).isEqualTo(new byte[0]);
   }
 
+  @Test
   public void testDecodeApicFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("APIC", new byte[] {3, 105, 109, 97, 103, 101, 47, 106, 112,
         101, 103, 0, 16, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 0});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     ApicFrame apicFrame = (ApicFrame) metadata.get(0);
-    assertEquals("image/jpeg", apicFrame.mimeType);
-    assertEquals(16, apicFrame.pictureType);
-    assertEquals("Hello World", apicFrame.description);
-    assertEquals(10, apicFrame.pictureData.length);
-    MoreAsserts.assertEquals(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}, apicFrame.pictureData);
+    assertThat(apicFrame.mimeType).isEqualTo("image/jpeg");
+    assertThat(apicFrame.pictureType).isEqualTo(16);
+    assertThat(apicFrame.description).isEqualTo("Hello World");
+    assertThat(apicFrame.pictureData).hasLength(10);
+    assertThat(apicFrame.pictureData).isEqualTo(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
   }
 
+  @Test
   public void testDecodeCommentFrame() throws MetadataDecoderException {
     byte[] rawId3 = buildSingleFrameTag("COMM", new byte[] {ID3_TEXT_ENCODING_UTF_8, 101, 110, 103,
         100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 0, 116, 101, 120, 116, 0});
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     CommentFrame commentFrame = (CommentFrame) metadata.get(0);
-    assertEquals("eng", commentFrame.language);
-    assertEquals("description", commentFrame.description);
-    assertEquals("text", commentFrame.text);
+    assertThat(commentFrame.language).isEqualTo("eng");
+    assertThat(commentFrame.description).isEqualTo("description");
+    assertThat(commentFrame.text).isEqualTo("text");
 
     // Test empty.
     rawId3 = buildSingleFrameTag("COMM", new byte[0]);
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(0, metadata.length());
+    assertThat(metadata.length()).isEqualTo(0);
 
     // Test language only.
     rawId3 = buildSingleFrameTag("COMM", new byte[] {ID3_TEXT_ENCODING_UTF_8, 101, 110, 103});
     metadata = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     commentFrame = (CommentFrame) metadata.get(0);
-    assertEquals("eng", commentFrame.language);
-    assertEquals("", commentFrame.description);
-    assertEquals("", commentFrame.text);
+    assertThat(commentFrame.language).isEqualTo("eng");
+    assertThat(commentFrame.description).isEmpty();
+    assertThat(commentFrame.text).isEmpty();
   }
 
   private static byte[] buildSingleFrameTag(String frameId, byte[] frameData) {
-    byte[] frameIdBytes = frameId.getBytes();
+    byte[] frameIdBytes = frameId.getBytes(Charset.forName(C.UTF8_NAME));
     Assertions.checkState(frameIdBytes.length == 4);
 
     byte[] tagData = new byte[TAG_HEADER.length + FRAME_HEADER_LENGTH + frameData.length];
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
similarity index 72%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
index c50ff06699..8cd90c7a64 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -15,29 +15,38 @@
  */
 package com.google.android.exoplayer2.metadata.scte35;
 
-import com.google.android.exoplayer2.C;
+import static com.google.android.exoplayer2.C.TIME_UNSET;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoderException;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.nio.ByteBuffer;
 import java.util.List;
-import junit.framework.TestCase;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link SpliceInfoDecoder}.
  */
-public final class SpliceInfoDecoderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class SpliceInfoDecoderTest {
 
   private SpliceInfoDecoder decoder;
   private MetadataInputBuffer inputBuffer;
 
-  @Override
+  @Before
   public void setUp() {
     decoder = new SpliceInfoDecoder();
     inputBuffer = new MetadataInputBuffer();
   }
 
+  @Test
   public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException {
     byte[] rawTimeSignalSection = new byte[] {
         0, // table_id.
@@ -59,11 +68,12 @@ public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException
     // The playback position is 57:15:58.43 approximately.
     // With this offset, the playback position pts before wrapping is 0x451ebf851.
     Metadata metadata = feedInputBuffer(rawTimeSignalSection, 0x3000000000L, -0x50000L);
-    assertEquals(1, metadata.length());
-    assertEquals(removePtsConversionPrecisionError(0x3001000000L, inputBuffer.subsampleOffsetUs),
-        ((TimeSignalCommand) metadata.get(0)).playbackPositionUs);
+    assertThat(metadata.length()).isEqualTo(1);
+    assertThat(((TimeSignalCommand) metadata.get(0)).playbackPositionUs)
+        .isEqualTo(removePtsConversionPrecisionError(0x3001000000L, inputBuffer.subsampleOffsetUs));
   }
 
+  @Test
   public void test2SpliceInsertCommands() throws MetadataDecoderException {
     byte[] rawSpliceInsertCommand1 = new byte[] {
         0, // table_id.
@@ -91,18 +101,18 @@ public void test2SpliceInsertCommands() throws MetadataDecoderException {
         0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
 
     Metadata metadata = feedInputBuffer(rawSpliceInsertCommand1, 2000000, 3000000);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     SpliceInsertCommand command = (SpliceInsertCommand) metadata.get(0);
-    assertEquals(66, command.spliceEventId);
-    assertFalse(command.spliceEventCancelIndicator);
-    assertFalse(command.outOfNetworkIndicator);
-    assertTrue(command.programSpliceFlag);
-    assertFalse(command.spliceImmediateFlag);
-    assertEquals(3000000, command.programSplicePlaybackPositionUs);
-    assertEquals(C.TIME_UNSET, command.breakDuration);
-    assertEquals(16, command.uniqueProgramId);
-    assertEquals(1, command.availNum);
-    assertEquals(2, command.availsExpected);
+    assertThat(command.spliceEventId).isEqualTo(66);
+    assertThat(command.spliceEventCancelIndicator).isFalse();
+    assertThat(command.outOfNetworkIndicator).isFalse();
+    assertThat(command.programSpliceFlag).isTrue();
+    assertThat(command.spliceImmediateFlag).isFalse();
+    assertThat(command.programSplicePlaybackPositionUs).isEqualTo(3000000);
+    assertThat(command.breakDurationUs).isEqualTo(TIME_UNSET);
+    assertThat(command.uniqueProgramId).isEqualTo(16);
+    assertThat(command.availNum).isEqualTo(1);
+    assertThat(command.availsExpected).isEqualTo(2);
 
     byte[] rawSpliceInsertCommand2 = new byte[] {
         0, // table_id.
@@ -137,24 +147,24 @@ public void test2SpliceInsertCommands() throws MetadataDecoderException {
     // By changing the subsample offset we force adjuster reconstruction.
     long subsampleOffset = 1000011;
     metadata = feedInputBuffer(rawSpliceInsertCommand2, 1000000, subsampleOffset);
-    assertEquals(1, metadata.length());
+    assertThat(metadata.length()).isEqualTo(1);
     command = (SpliceInsertCommand) metadata.get(0);
-    assertEquals(0xffffffffL, command.spliceEventId);
-    assertFalse(command.spliceEventCancelIndicator);
-    assertFalse(command.outOfNetworkIndicator);
-    assertFalse(command.programSpliceFlag);
-    assertFalse(command.spliceImmediateFlag);
-    assertEquals(C.TIME_UNSET, command.programSplicePlaybackPositionUs);
-    assertEquals(C.TIME_UNSET, command.breakDuration);
+    assertThat(command.spliceEventId).isEqualTo(0xffffffffL);
+    assertThat(command.spliceEventCancelIndicator).isFalse();
+    assertThat(command.outOfNetworkIndicator).isFalse();
+    assertThat(command.programSpliceFlag).isFalse();
+    assertThat(command.spliceImmediateFlag).isFalse();
+    assertThat(command.programSplicePlaybackPositionUs).isEqualTo(TIME_UNSET);
+    assertThat(command.breakDurationUs).isEqualTo(TIME_UNSET);
     List<SpliceInsertCommand.ComponentSplice> componentSplices = command.componentSpliceList;
-    assertEquals(2, componentSplices.size());
-    assertEquals(16, componentSplices.get(0).componentTag);
-    assertEquals(1000000, componentSplices.get(0).componentSplicePlaybackPositionUs);
-    assertEquals(17, componentSplices.get(1).componentTag);
-    assertEquals(C.TIME_UNSET, componentSplices.get(1).componentSplicePts);
-    assertEquals(32, command.uniqueProgramId);
-    assertEquals(1, command.availNum);
-    assertEquals(2, command.availsExpected);
+    assertThat(componentSplices).hasSize(2);
+    assertThat(componentSplices.get(0).componentTag).isEqualTo(16);
+    assertThat(componentSplices.get(0).componentSplicePlaybackPositionUs).isEqualTo(1000000);
+    assertThat(componentSplices.get(1).componentTag).isEqualTo(17);
+    assertThat(componentSplices.get(1).componentSplicePts).isEqualTo(TIME_UNSET);
+    assertThat(command.uniqueProgramId).isEqualTo(32);
+    assertThat(command.availNum).isEqualTo(1);
+    assertThat(command.availsExpected).isEqualTo(2);
   }
 
   private Metadata feedInputBuffer(byte[] data, long timeUs, long subsampleOffset)
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
new file mode 100644
index 0000000000..e3ac104754
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link CompositeSequenceableLoader}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class CompositeSequenceableLoaderTest {
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#getBufferedPositionUs()} returns minimum buffered
+   * position among all sub-loaders.
+   */
+  @Test
+  public void testGetBufferedPositionUsReturnsMinimumLoaderBufferedPosition() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2001);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+    assertThat(compositeSequenceableLoader.getBufferedPositionUs()).isEqualTo(1000);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#getBufferedPositionUs()} returns minimum buffered
+   * position that is not {@link C#TIME_END_OF_SOURCE} among all sub-loaders.
+   */
+  @Test
+  public void testGetBufferedPositionUsReturnsMinimumNonEndOfSourceLoaderBufferedPosition() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader3 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ C.TIME_END_OF_SOURCE,
+            /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2, loader3});
+    assertThat(compositeSequenceableLoader.getBufferedPositionUs()).isEqualTo(1000);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#getBufferedPositionUs()} returns
+   * {@link C#TIME_END_OF_SOURCE} when all sub-loaders have buffered till end-of-source.
+   */
+  @Test
+  public void testGetBufferedPositionUsReturnsEndOfSourceWhenAllLoaderBufferedTillEndOfSource() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ C.TIME_END_OF_SOURCE,
+            /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ C.TIME_END_OF_SOURCE,
+            /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+    assertThat(compositeSequenceableLoader.getBufferedPositionUs()).isEqualTo(C.TIME_END_OF_SOURCE);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#getNextLoadPositionUs()} returns minimum next
+   * load position among all sub-loaders.
+   */
+  @Test
+  public void testGetNextLoadPositionUsReturnMinimumLoaderNextLoadPositionUs() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2001);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2000);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+    assertThat(compositeSequenceableLoader.getNextLoadPositionUs()).isEqualTo(2000);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#getNextLoadPositionUs()} returns minimum next
+   * load position that is not {@link C#TIME_END_OF_SOURCE} among all sub-loaders.
+   */
+  @Test
+  public void testGetNextLoadPositionUsReturnMinimumNonEndOfSourceLoaderNextLoadPositionUs() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2001);
+    FakeSequenceableLoader loader3 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2, loader3});
+    assertThat(compositeSequenceableLoader.getNextLoadPositionUs()).isEqualTo(2000);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#getNextLoadPositionUs()} returns
+   * {@link C#TIME_END_OF_SOURCE} when all sub-loaders have next load position at end-of-source.
+   */
+  @Test
+  public void testGetNextLoadPositionUsReturnsEndOfSourceWhenAllLoaderLoadingLastChunk() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+    assertThat(compositeSequenceableLoader.getNextLoadPositionUs()).isEqualTo(C.TIME_END_OF_SOURCE);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#continueLoading(long)} only allows the loader
+   * with minimum next load position to continue loading if next load positions are not behind
+   * current playback position.
+   */
+  @Test
+  public void testContinueLoadingOnlyAllowFurthestBehindLoaderToLoadIfNotBehindPlaybackPosition() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2001);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+    compositeSequenceableLoader.continueLoading(100);
+
+    assertThat(loader1.numInvocations).isEqualTo(1);
+    assertThat(loader2.numInvocations).isEqualTo(0);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#continueLoading(long)} allows all loaders
+   * with next load position behind current playback position to continue loading.
+   */
+  @Test
+  public void testContinueLoadingReturnAllowAllLoadersBehindPlaybackPositionToLoad() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2001);
+    FakeSequenceableLoader loader3 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1002, /* nextLoadPositionUs */ 2002);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2, loader3});
+    compositeSequenceableLoader.continueLoading(3000);
+
+    assertThat(loader1.numInvocations).isEqualTo(1);
+    assertThat(loader2.numInvocations).isEqualTo(1);
+    assertThat(loader3.numInvocations).isEqualTo(1);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#continueLoading(long)} does not allow loader
+   * with next load position at end-of-source to continue loading.
+   */
+  @Test
+  public void testContinueLoadingOnlyNotAllowEndOfSourceLoaderToLoad() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(
+            /* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ C.TIME_END_OF_SOURCE);
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+    compositeSequenceableLoader.continueLoading(3000);
+
+    assertThat(loader1.numInvocations).isEqualTo(0);
+    assertThat(loader2.numInvocations).isEqualTo(0);
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#continueLoading(long)} returns true if the loader
+   * with minimum next load position can make progress if next load positions are not behind
+   * current playback position.
+   */
+  @Test
+  public void testContinueLoadingReturnTrueIfFurthestBehindLoaderCanMakeProgress() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2001);
+    loader1.setNextChunkDurationUs(1000);
+
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+
+    assertThat(compositeSequenceableLoader.continueLoading(100)).isTrue();
+  }
+
+  /**
+   * Tests that {@link CompositeSequenceableLoader#continueLoading(long)} returns true if any loader
+   * that are behind current playback position can make progress, even if it is not the one with
+   * minimum next load position.
+   */
+  @Test
+  public void testContinueLoadingReturnTrueIfLoaderBehindPlaybackPositionCanMakeProgress() {
+    FakeSequenceableLoader loader1 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1000, /* nextLoadPositionUs */ 2000);
+    FakeSequenceableLoader loader2 =
+        new FakeSequenceableLoader(/* bufferedPositionUs */ 1001, /* nextLoadPositionUs */ 2001);
+    // loader2 is not the furthest behind, but it can make progress if allowed.
+    loader2.setNextChunkDurationUs(1000);
+
+    CompositeSequenceableLoader compositeSequenceableLoader = new CompositeSequenceableLoader(
+        new SequenceableLoader[] {loader1, loader2});
+
+    assertThat(compositeSequenceableLoader.continueLoading(3000)).isTrue();
+  }
+
+  private static class FakeSequenceableLoader implements SequenceableLoader {
+
+    private long bufferedPositionUs;
+    private long nextLoadPositionUs;
+    private int numInvocations;
+    private int nextChunkDurationUs;
+
+    private FakeSequenceableLoader(long bufferedPositionUs, long nextLoadPositionUs) {
+      this.bufferedPositionUs = bufferedPositionUs;
+      this.nextLoadPositionUs = nextLoadPositionUs;
+    }
+
+    @Override
+    public long getBufferedPositionUs() {
+      return bufferedPositionUs;
+    }
+
+    @Override
+    public long getNextLoadPositionUs() {
+      return nextLoadPositionUs;
+    }
+
+    @Override
+    public boolean continueLoading(long positionUs) {
+      numInvocations++;
+      boolean loaded = nextChunkDurationUs != 0;
+      // The current chunk has been loaded, advance to next chunk.
+      bufferedPositionUs = nextLoadPositionUs;
+      nextLoadPositionUs += nextChunkDurationUs;
+      nextChunkDurationUs = 0;
+      return loaded;
+    }
+
+    private void setNextChunkDurationUs(int nextChunkDurationUs) {
+      this.nextChunkDurationUs = nextChunkDurationUs;
+    }
+
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/SampleQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
similarity index 84%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/source/SampleQueueTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
index 76ea0e34cf..49983fae30 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/SampleQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
@@ -15,7 +15,14 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.test.MoreAsserts;
+import static com.google.android.exoplayer2.C.RESULT_BUFFER_READ;
+import static com.google.android.exoplayer2.C.RESULT_FORMAT_READ;
+import static com.google.android.exoplayer2.C.RESULT_NOTHING_READ;
+import static com.google.android.exoplayer2.source.SampleQueue.ADVANCE_FAILED;
+import static com.google.common.truth.Truth.assertThat;
+import static java.lang.Long.MIN_VALUE;
+import static java.util.Arrays.copyOfRange;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -24,13 +31,19 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import java.util.Arrays;
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link SampleQueue}.
  */
-public class SampleQueueTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class SampleQueueTest {
 
   private static final int ALLOCATION_SIZE = 16;
 
@@ -75,24 +88,23 @@
   private FormatHolder formatHolder;
   private DecoderInputBuffer inputBuffer;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
-    super.setUp();
     allocator = new DefaultAllocator(false, ALLOCATION_SIZE);
     sampleQueue = new SampleQueue(allocator);
     formatHolder = new FormatHolder();
     inputBuffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
   }
 
-  @Override
+  @After
   public void tearDown() throws Exception {
-    super.tearDown();
     allocator = null;
     sampleQueue = null;
     formatHolder = null;
     inputBuffer = null;
   }
 
+  @Test
   public void testResetReleasesAllocations() {
     writeTestData();
     assertAllocationCount(10);
@@ -100,10 +112,12 @@ public void testResetReleasesAllocations() {
     assertAllocationCount(0);
   }
 
+  @Test
   public void testReadWithoutWrite() {
     assertNoSamplesToRead(null);
   }
 
+  @Test
   public void testReadFormatDeduplicated() {
     sampleQueue.format(TEST_FORMAT_1);
     assertReadFormat(false, TEST_FORMAT_1);
@@ -115,6 +129,7 @@ public void testReadFormatDeduplicated() {
     assertNoSamplesToRead(TEST_FORMAT_1);
   }
 
+  @Test
   public void testReadSingleSamples() {
     sampleQueue.sampleData(new ParsableByteArray(TEST_DATA), ALLOCATION_SIZE);
 
@@ -173,9 +188,10 @@ public void testReadSingleSamples() {
     assertAllocationCount(0);
   }
 
+  @Test
   public void testReadMultiSamples() {
     writeTestData();
-    assertEquals(LAST_SAMPLE_TIMESTAMP, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(LAST_SAMPLE_TIMESTAMP);
     assertAllocationCount(10);
     assertReadTestData();
     assertAllocationCount(10);
@@ -183,6 +199,7 @@ public void testReadMultiSamples() {
     assertAllocationCount(0);
   }
 
+  @Test
   public void testReadMultiSamplesTwice() {
     writeTestData();
     writeTestData();
@@ -194,19 +211,21 @@ public void testReadMultiSamplesTwice() {
     assertAllocationCount(0);
   }
 
+  @Test
   public void testReadMultiWithRewind() {
     writeTestData();
     assertReadTestData();
-    assertEquals(8, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(10);
     // Rewind.
     sampleQueue.rewind();
     assertAllocationCount(10);
     // Read again.
-    assertEquals(0, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertReadTestData();
   }
 
+  @Test
   public void testRewindAfterDiscard() {
     writeTestData();
     assertReadTestData();
@@ -216,10 +235,11 @@ public void testRewindAfterDiscard() {
     sampleQueue.rewind();
     assertAllocationCount(0);
     // Can't read again.
-    assertEquals(8, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertReadEndOfStream(false);
   }
 
+  @Test
   public void testAdvanceToEnd() {
     writeTestData();
     sampleQueue.advanceToEnd();
@@ -233,6 +253,7 @@ public void testAdvanceToEnd() {
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testAdvanceToEndRetainsUnassignedData() {
     sampleQueue.format(TEST_FORMAT_1);
     sampleQueue.sampleData(new ParsableByteArray(TEST_DATA), ALLOCATION_SIZE);
@@ -256,56 +277,62 @@ public void testAdvanceToEndRetainsUnassignedData() {
     assertAllocationCount(0);
   }
 
+  @Test
   public void testAdvanceToBeforeBuffer() {
     writeTestData();
-    boolean result = sampleQueue.advanceTo(TEST_SAMPLE_TIMESTAMPS[0] - 1, true, false);
+    int skipCount = sampleQueue.advanceTo(TEST_SAMPLE_TIMESTAMPS[0] - 1, true, false);
     // Should fail and have no effect.
-    assertFalse(result);
+    assertThat(skipCount).isEqualTo(ADVANCE_FAILED);
     assertReadTestData();
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testAdvanceToStartOfBuffer() {
     writeTestData();
-    boolean result = sampleQueue.advanceTo(TEST_SAMPLE_TIMESTAMPS[0], true, false);
+    int skipCount = sampleQueue.advanceTo(TEST_SAMPLE_TIMESTAMPS[0], true, false);
     // Should succeed but have no effect (we're already at the first frame).
-    assertTrue(result);
+    assertThat(skipCount).isEqualTo(0);
     assertReadTestData();
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testAdvanceToEndOfBuffer() {
     writeTestData();
-    boolean result = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP, true, false);
-    // Should succeed and skip to 2nd keyframe.
-    assertTrue(result);
+    int skipCount = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP, true, false);
+    // Should succeed and skip to 2nd keyframe (the 4th frame).
+    assertThat(skipCount).isEqualTo(4);
     assertReadTestData(null, TEST_DATA_SECOND_KEYFRAME_INDEX);
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testAdvanceToAfterBuffer() {
     writeTestData();
-    boolean result = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP + 1, true, false);
+    int skipCount = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP + 1, true, false);
     // Should fail and have no effect.
-    assertFalse(result);
+    assertThat(skipCount).isEqualTo(ADVANCE_FAILED);
     assertReadTestData();
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testAdvanceToAfterBufferAllowed() {
     writeTestData();
-    boolean result = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP + 1, true, true);
-    // Should succeed and skip to 2nd keyframe.
-    assertTrue(result);
+    int skipCount = sampleQueue.advanceTo(LAST_SAMPLE_TIMESTAMP + 1, true, true);
+    // Should succeed and skip to 2nd keyframe (the 4th frame).
+    assertThat(skipCount).isEqualTo(4);
     assertReadTestData(null, TEST_DATA_SECOND_KEYFRAME_INDEX);
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testDiscardToEnd() {
     writeTestData();
     // Should discard everything.
     sampleQueue.discardToEnd();
-    assertEquals(8, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(0);
     // We should still be able to read the upstream format.
     assertReadFormat(false, TEST_FORMAT_2);
@@ -314,17 +341,18 @@ public void testDiscardToEnd() {
     assertReadTestData(TEST_FORMAT_2);
   }
 
+  @Test
   public void testDiscardToStopAtReadPosition() {
     writeTestData();
     // Shouldn't discard anything.
     sampleQueue.discardTo(LAST_SAMPLE_TIMESTAMP, false, true);
-    assertEquals(0, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertAllocationCount(10);
     // Read the first sample.
     assertReadTestData(null, 0, 1);
     // Shouldn't discard anything.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1] - 1, false, true);
-    assertEquals(1, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(10);
     // Should discard the read sample.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1], false, true);
@@ -334,7 +362,7 @@ public void testDiscardToStopAtReadPosition() {
     assertAllocationCount(9);
     // Should be able to read the remaining samples.
     assertReadTestData(TEST_FORMAT_1, 1, 7);
-    assertEquals(8, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     // Should discard up to the second last sample
     sampleQueue.discardTo(LAST_SAMPLE_TIMESTAMP - 1, false, true);
     assertAllocationCount(3);
@@ -343,20 +371,22 @@ public void testDiscardToStopAtReadPosition() {
     assertAllocationCount(1);
   }
 
+  @Test
   public void testDiscardToDontStopAtReadPosition() {
     writeTestData();
     // Shouldn't discard anything.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1] - 1, false, false);
-    assertEquals(0, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertAllocationCount(10);
     // Should discard the first sample.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1], false, false);
-    assertEquals(1, sampleQueue.getReadIndex());
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
     // Should be able to read the remaining samples.
     assertReadTestData(TEST_FORMAT_1, 1, 7);
   }
 
+  @Test
   public void testDiscardUpstream() {
     writeTestData();
     sampleQueue.discardUpstreamSamples(8);
@@ -381,6 +411,7 @@ public void testDiscardUpstream() {
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testDiscardUpstreamMulti() {
     writeTestData();
     sampleQueue.discardUpstreamSamples(4);
@@ -391,6 +422,7 @@ public void testDiscardUpstreamMulti() {
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testDiscardUpstreamBeforeRead() {
     writeTestData();
     sampleQueue.discardUpstreamSamples(4);
@@ -400,6 +432,7 @@ public void testDiscardUpstreamBeforeRead() {
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testDiscardUpstreamAfterRead() {
     writeTestData();
     assertReadTestData(null, 0, 3);
@@ -421,41 +454,44 @@ public void testDiscardUpstreamAfterRead() {
     assertNoSamplesToRead(TEST_FORMAT_2);
   }
 
+  @Test
   public void testLargestQueuedTimestampWithDiscardUpstream() {
     writeTestData();
-    assertEquals(LAST_SAMPLE_TIMESTAMP, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(LAST_SAMPLE_TIMESTAMP);
     sampleQueue.discardUpstreamSamples(TEST_SAMPLE_TIMESTAMPS.length - 1);
     // Discarding from upstream should reduce the largest timestamp.
-    assertEquals(TEST_SAMPLE_TIMESTAMPS[TEST_SAMPLE_TIMESTAMPS.length - 2],
-        sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs())
+        .isEqualTo(TEST_SAMPLE_TIMESTAMPS[TEST_SAMPLE_TIMESTAMPS.length - 2]);
     sampleQueue.discardUpstreamSamples(0);
     // Discarding everything from upstream without reading should unset the largest timestamp.
-    assertEquals(Long.MIN_VALUE, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(MIN_VALUE);
   }
 
+  @Test
   public void testLargestQueuedTimestampWithDiscardUpstreamDecodeOrder() {
     long[] decodeOrderTimestamps = new long[] {0, 3000, 2000, 1000, 4000, 7000, 6000, 5000};
     writeTestData(TEST_DATA, TEST_SAMPLE_SIZES, TEST_SAMPLE_OFFSETS, decodeOrderTimestamps,
         TEST_SAMPLE_FORMATS, TEST_SAMPLE_FLAGS);
-    assertEquals(7000, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(7000);
     sampleQueue.discardUpstreamSamples(TEST_SAMPLE_TIMESTAMPS.length - 2);
     // Discarding the last two samples should not change the largest timestamp, due to the decode
     // ordering of the timestamps.
-    assertEquals(7000, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(7000);
     sampleQueue.discardUpstreamSamples(TEST_SAMPLE_TIMESTAMPS.length - 3);
     // Once a third sample is discarded, the largest timestamp should have changed.
-    assertEquals(4000, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(4000);
     sampleQueue.discardUpstreamSamples(0);
     // Discarding everything from upstream without reading should unset the largest timestamp.
-    assertEquals(Long.MIN_VALUE, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(MIN_VALUE);
   }
 
+  @Test
   public void testLargestQueuedTimestampWithRead() {
     writeTestData();
-    assertEquals(LAST_SAMPLE_TIMESTAMP, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(LAST_SAMPLE_TIMESTAMP);
     assertReadTestData();
     // Reading everything should not reduce the largest timestamp.
-    assertEquals(LAST_SAMPLE_TIMESTAMP, sampleQueue.getLargestQueuedTimestampUs());
+    assertThat(sampleQueue.getLargestQueuedTimestampUs()).isEqualTo(LAST_SAMPLE_TIMESTAMP);
   }
 
   // Internal methods.
@@ -580,9 +616,9 @@ private void assertNoSamplesToRead(Format endFormat) {
   private void assertReadNothing(boolean formatRequired) {
     clearFormatHolderAndInputBuffer();
     int result = sampleQueue.read(formatHolder, inputBuffer, formatRequired, false, 0);
-    assertEquals(C.RESULT_NOTHING_READ, result);
+    assertThat(result).isEqualTo(RESULT_NOTHING_READ);
     // formatHolder should not be populated.
-    assertNull(formatHolder.format);
+    assertThat(formatHolder.format).isNull();
     // inputBuffer should not be populated.
     assertInputBufferContainsNoSampleData();
     assertInputBufferHasNoDefaultFlagsSet();
@@ -597,14 +633,14 @@ private void assertReadNothing(boolean formatRequired) {
   private void assertReadEndOfStream(boolean formatRequired) {
     clearFormatHolderAndInputBuffer();
     int result = sampleQueue.read(formatHolder, inputBuffer, formatRequired, true, 0);
-    assertEquals(C.RESULT_BUFFER_READ, result);
+    assertThat(result).isEqualTo(RESULT_BUFFER_READ);
     // formatHolder should not be populated.
-    assertNull(formatHolder.format);
+    assertThat(formatHolder.format).isNull();
     // inputBuffer should not contain sample data, but end of stream flag should be set.
     assertInputBufferContainsNoSampleData();
-    assertTrue(inputBuffer.isEndOfStream());
-    assertFalse(inputBuffer.isDecodeOnly());
-    assertFalse(inputBuffer.isEncrypted());
+    assertThat(inputBuffer.isEndOfStream()).isTrue();
+    assertThat(inputBuffer.isDecodeOnly()).isFalse();
+    assertThat(inputBuffer.isEncrypted()).isFalse();
   }
 
   /**
@@ -617,9 +653,9 @@ private void assertReadEndOfStream(boolean formatRequired) {
   private void assertReadFormat(boolean formatRequired, Format format) {
     clearFormatHolderAndInputBuffer();
     int result = sampleQueue.read(formatHolder, inputBuffer, formatRequired, false, 0);
-    assertEquals(C.RESULT_FORMAT_READ, result);
+    assertThat(result).isEqualTo(RESULT_FORMAT_READ);
     // formatHolder should be populated.
-    assertEquals(format, formatHolder.format);
+    assertThat(formatHolder.format).isEqualTo(format);
     // inputBuffer should not be populated.
     assertInputBufferContainsNoSampleData();
     assertInputBufferHasNoDefaultFlagsSet();
@@ -639,19 +675,19 @@ private void assertSampleRead(long timeUs, boolean isKeyframe, byte[] sampleData
       int length) {
     clearFormatHolderAndInputBuffer();
     int result = sampleQueue.read(formatHolder, inputBuffer, false, false, 0);
-    assertEquals(C.RESULT_BUFFER_READ, result);
+    assertThat(result).isEqualTo(RESULT_BUFFER_READ);
     // formatHolder should not be populated.
-    assertNull(formatHolder.format);
+    assertThat(formatHolder.format).isNull();
     // inputBuffer should be populated.
-    assertEquals(timeUs, inputBuffer.timeUs);
-    assertEquals(isKeyframe, inputBuffer.isKeyFrame());
-    assertFalse(inputBuffer.isDecodeOnly());
-    assertFalse(inputBuffer.isEncrypted());
+    assertThat(inputBuffer.timeUs).isEqualTo(timeUs);
+    assertThat(inputBuffer.isKeyFrame()).isEqualTo(isKeyframe);
+    assertThat(inputBuffer.isDecodeOnly()).isFalse();
+    assertThat(inputBuffer.isEncrypted()).isFalse();
     inputBuffer.flip();
-    assertEquals(length, inputBuffer.data.limit());
+    assertThat(inputBuffer.data.limit()).isEqualTo(length);
     byte[] readData = new byte[length];
     inputBuffer.data.get(readData);
-    MoreAsserts.assertEquals(Arrays.copyOfRange(sampleData, offset, offset + length), readData);
+    assertThat(readData).isEqualTo(copyOfRange(sampleData, offset, offset + length));
   }
 
   /**
@@ -660,7 +696,7 @@ private void assertSampleRead(long timeUs, boolean isKeyframe, byte[] sampleData
    * @param count The expected number of allocations.
    */
   private void assertAllocationCount(int count) {
-    assertEquals(ALLOCATION_SIZE * count, allocator.getTotalBytesAllocated());
+    assertThat(allocator.getTotalBytesAllocated()).isEqualTo(ALLOCATION_SIZE * count);
   }
 
   /**
@@ -671,13 +707,13 @@ private void assertInputBufferContainsNoSampleData() {
       return;
     }
     inputBuffer.flip();
-    assertEquals(0, inputBuffer.data.limit());
+    assertThat(inputBuffer.data.limit()).isEqualTo(0);
   }
 
   private void assertInputBufferHasNoDefaultFlagsSet() {
-    assertFalse(inputBuffer.isEndOfStream());
-    assertFalse(inputBuffer.isDecodeOnly());
-    assertFalse(inputBuffer.isEncrypted());
+    assertThat(inputBuffer.isEndOfStream()).isFalse();
+    assertThat(inputBuffer.isDecodeOnly()).isFalse();
+    assertThat(inputBuffer.isEncrypted()).isFalse();
   }
 
   private void clearFormatHolderAndInputBuffer() {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
new file mode 100644
index 0000000000..1229e47883
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.android.exoplayer2.C.INDEX_UNSET;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
+import com.google.android.exoplayer2.source.ShuffleOrder.UnshuffledShuffleOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for {@link ShuffleOrder}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ShuffleOrderTest {
+
+  public static final long RANDOM_SEED = 1234567890L;
+
+  @Test
+  public void testDefaultShuffleOrder() {
+    assertShuffleOrderCorrectness(new DefaultShuffleOrder(0, RANDOM_SEED), 0);
+    assertShuffleOrderCorrectness(new DefaultShuffleOrder(1, RANDOM_SEED), 1);
+    assertShuffleOrderCorrectness(new DefaultShuffleOrder(5, RANDOM_SEED), 5);
+    for (int initialLength = 0; initialLength < 4; initialLength++) {
+      for (int insertionPoint = 0; insertionPoint <= initialLength; insertionPoint += 2) {
+        testCloneAndInsert(new DefaultShuffleOrder(initialLength, RANDOM_SEED), insertionPoint, 0);
+        testCloneAndInsert(new DefaultShuffleOrder(initialLength, RANDOM_SEED), insertionPoint, 1);
+        testCloneAndInsert(new DefaultShuffleOrder(initialLength, RANDOM_SEED), insertionPoint, 5);
+      }
+    }
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 0);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 2);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 4);
+    testCloneAndRemove(new DefaultShuffleOrder(1, RANDOM_SEED), 0);
+  }
+
+  @Test
+  public void testUnshuffledShuffleOrder() {
+    assertShuffleOrderCorrectness(new UnshuffledShuffleOrder(0), 0);
+    assertShuffleOrderCorrectness(new UnshuffledShuffleOrder(1), 1);
+    assertShuffleOrderCorrectness(new UnshuffledShuffleOrder(5), 5);
+    for (int initialLength = 0; initialLength < 4; initialLength++) {
+      for (int insertionPoint = 0; insertionPoint <= initialLength; insertionPoint += 2) {
+        testCloneAndInsert(new UnshuffledShuffleOrder(initialLength), insertionPoint, 0);
+        testCloneAndInsert(new UnshuffledShuffleOrder(initialLength), insertionPoint, 1);
+        testCloneAndInsert(new UnshuffledShuffleOrder(initialLength), insertionPoint, 5);
+      }
+    }
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 0);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 2);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 4);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1), 0);
+  }
+
+  @Test
+  public void testUnshuffledShuffleOrderIsUnshuffled() {
+    ShuffleOrder shuffleOrder = new UnshuffledShuffleOrder(5);
+    assertThat(shuffleOrder.getFirstIndex()).isEqualTo(0);
+    assertThat(shuffleOrder.getLastIndex()).isEqualTo(4);
+    for (int i = 0; i < 4; i++) {
+      assertThat(shuffleOrder.getNextIndex(i)).isEqualTo(i + 1);
+    }
+  }
+
+  private static void assertShuffleOrderCorrectness(ShuffleOrder shuffleOrder, int length) {
+    assertThat(shuffleOrder.getLength()).isEqualTo(length);
+    if (length == 0) {
+      assertThat(shuffleOrder.getFirstIndex()).isEqualTo(INDEX_UNSET);
+      assertThat(shuffleOrder.getLastIndex()).isEqualTo(INDEX_UNSET);
+    } else {
+      int[] indices = new int[length];
+      indices[0] = shuffleOrder.getFirstIndex();
+      assertThat(shuffleOrder.getPreviousIndex(indices[0])).isEqualTo(INDEX_UNSET);
+      for (int i = 1; i < length; i++) {
+        indices[i] = shuffleOrder.getNextIndex(indices[i - 1]);
+        assertThat(shuffleOrder.getPreviousIndex(indices[i])).isEqualTo(indices[i - 1]);
+        for (int j = 0; j < i; j++) {
+          assertThat(indices[i] != indices[j]).isTrue();
+        }
+      }
+      assertThat(shuffleOrder.getLastIndex()).isEqualTo(indices[length - 1]);
+      assertThat(shuffleOrder.getNextIndex(indices[length - 1])).isEqualTo(INDEX_UNSET);
+      for (int i = 0; i < length; i++) {
+        assertThat(indices[i] >= 0 && indices[i] < length).isTrue();
+      }
+    }
+  }
+
+  private static void testCloneAndInsert(ShuffleOrder shuffleOrder, int position, int count) {
+    ShuffleOrder newOrder = shuffleOrder.cloneAndInsert(position, count);
+    assertShuffleOrderCorrectness(newOrder, shuffleOrder.getLength() + count);
+    // Assert all elements still have the relative same order
+    for (int i = 0; i < shuffleOrder.getLength(); i++) {
+      int expectedNextIndex = shuffleOrder.getNextIndex(i);
+      if (expectedNextIndex != C.INDEX_UNSET && expectedNextIndex >= position) {
+        expectedNextIndex += count;
+      }
+      int newNextIndex = newOrder.getNextIndex(i < position ? i : i + count);
+      while (newNextIndex >= position && newNextIndex < position + count) {
+        newNextIndex = newOrder.getNextIndex(newNextIndex);
+      }
+      assertThat(newNextIndex).isEqualTo(expectedNextIndex);
+    }
+  }
+
+  private static void testCloneAndRemove(ShuffleOrder shuffleOrder, int position) {
+    ShuffleOrder newOrder = shuffleOrder.cloneAndRemove(position);
+    assertShuffleOrderCorrectness(newOrder, shuffleOrder.getLength() - 1);
+    // Assert all elements still have the relative same order
+    for (int i = 0; i < shuffleOrder.getLength(); i++) {
+      if (i == position) {
+        continue;
+      }
+      int expectedNextIndex = shuffleOrder.getNextIndex(i);
+      if (expectedNextIndex == position) {
+        expectedNextIndex = shuffleOrder.getNextIndex(expectedNextIndex);
+      }
+      if (expectedNextIndex != C.INDEX_UNSET && expectedNextIndex >= position) {
+        expectedNextIndex--;
+      }
+      int newNextIndex = newOrder.getNextIndex(i < position ? i : i - 1);
+      assertThat(newNextIndex).isEqualTo(expectedNextIndex);
+    }
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
similarity index 59%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
index 82dc6b4ad5..557611c4ea 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
@@ -15,43 +15,62 @@
  */
 package com.google.android.exoplayer2.text.ttml;
 
+import static android.graphics.Color.BLACK;
+import static android.graphics.Color.RED;
+import static android.graphics.Color.YELLOW;
+import static com.google.android.exoplayer2.text.ttml.TtmlRenderUtil.resolveStyle;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.STYLE_BOLD;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.STYLE_BOLD_ITALIC;
+import static com.google.common.truth.Truth.assertThat;
+
 import android.graphics.Color;
-import android.test.InstrumentationTestCase;
 import java.util.HashMap;
 import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
- * Unit test for <code>TtmlRenderUtil</code>
+ * Unit test for {@link TtmlRenderUtil}.
  */
-public class TtmlRenderUtilTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class TtmlRenderUtilTest {
 
+  @Test
   public void testResolveStyleNoStyleAtAll() {
-    assertNull(TtmlRenderUtil.resolveStyle(null, null, null));
+    assertThat(resolveStyle(null, null, null)).isNull();
   }
+
+  @Test
   public void testResolveStyleSingleReferentialStyle() {
     Map<String, TtmlStyle> globalStyles = getGlobalStyles();
     String[] styleIds = {"s0"};
 
-    assertSame(globalStyles.get("s0"),
-        TtmlRenderUtil.resolveStyle(null, styleIds, globalStyles));
+    assertThat(TtmlRenderUtil.resolveStyle(null, styleIds, globalStyles))
+        .isSameAs(globalStyles.get("s0"));
   }
+
+  @Test
   public void testResolveStyleMultipleReferentialStyles() {
     Map<String, TtmlStyle> globalStyles = getGlobalStyles();
     String[] styleIds = {"s0", "s1"};
 
     TtmlStyle resolved = TtmlRenderUtil.resolveStyle(null, styleIds, globalStyles);
-    assertNotSame(globalStyles.get("s0"), resolved);
-    assertNotSame(globalStyles.get("s1"), resolved);
-    assertNull(resolved.getId());
+    assertThat(resolved).isNotSameAs(globalStyles.get("s0"));
+    assertThat(resolved).isNotSameAs(globalStyles.get("s1"));
+    assertThat(resolved.getId()).isNull();
 
     // inherited from s0
-    assertEquals(Color.BLACK, resolved.getBackgroundColor());
+    assertThat(resolved.getBackgroundColor()).isEqualTo(BLACK);
     // inherited from s1
-    assertEquals(Color.RED, resolved.getFontColor());
+    assertThat(resolved.getFontColor()).isEqualTo(RED);
     // merged from s0 and s1
-    assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, resolved.getStyle());
+    assertThat(resolved.getStyle()).isEqualTo(STYLE_BOLD_ITALIC);
   }
 
+  @Test
   public void testResolveMergeSingleReferentialStyleIntoInlineStyle() {
     Map<String, TtmlStyle> globalStyles = getGlobalStyles();
     String[] styleIds = {"s0"};
@@ -59,15 +78,15 @@ public void testResolveMergeSingleReferentialStyleIntoInlineStyle() {
     style.setBackgroundColor(Color.YELLOW);
 
     TtmlStyle resolved = TtmlRenderUtil.resolveStyle(style, styleIds, globalStyles);
-    assertSame(style, resolved);
+    assertThat(resolved).isSameAs(style);
 
     // inline attribute not overridden
-    assertEquals(Color.YELLOW, resolved.getBackgroundColor());
+    assertThat(resolved.getBackgroundColor()).isEqualTo(YELLOW);
     // inherited from referential style
-    assertEquals(TtmlStyle.STYLE_BOLD, resolved.getStyle());
+    assertThat(resolved.getStyle()).isEqualTo(STYLE_BOLD);
   }
 
-
+  @Test
   public void testResolveMergeMultipleReferentialStylesIntoInlineStyle() {
     Map<String, TtmlStyle> globalStyles = getGlobalStyles();
     String[] styleIds = {"s0", "s1"};
@@ -75,20 +94,21 @@ public void testResolveMergeMultipleReferentialStylesIntoInlineStyle() {
     style.setBackgroundColor(Color.YELLOW);
 
     TtmlStyle resolved = TtmlRenderUtil.resolveStyle(style, styleIds, globalStyles);
-    assertSame(style, resolved);
+    assertThat(resolved).isSameAs(style);
 
     // inline attribute not overridden
-    assertEquals(Color.YELLOW, resolved.getBackgroundColor());
+    assertThat(resolved.getBackgroundColor()).isEqualTo(YELLOW);
     // inherited from both referential style
-    assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, resolved.getStyle());
+    assertThat(resolved.getStyle()).isEqualTo(STYLE_BOLD_ITALIC);
   }
 
+  @Test
   public void testResolveStyleOnlyInlineStyle() {
     TtmlStyle inlineStyle = new TtmlStyle();
-    assertSame(inlineStyle, TtmlRenderUtil.resolveStyle(inlineStyle, null, null));
+    assertThat(TtmlRenderUtil.resolveStyle(inlineStyle, null, null)).isSameAs(inlineStyle);
   }
 
-  private Map<String, TtmlStyle> getGlobalStyles() {
+  private static Map<String, TtmlStyle> getGlobalStyles() {
     Map<String, TtmlStyle> globalStyles = new HashMap<>();
 
     TtmlStyle s0 = new TtmlStyle();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
new file mode 100644
index 0000000000..4c35e259ff
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.ttml;
+
+import static android.graphics.Color.BLACK;
+import static android.graphics.Color.WHITE;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.STYLE_BOLD;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.STYLE_BOLD_ITALIC;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.STYLE_ITALIC;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.STYLE_NORMAL;
+import static com.google.android.exoplayer2.text.ttml.TtmlStyle.UNSPECIFIED;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.graphics.Color;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit test for {@link TtmlStyle}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class TtmlStyleTest {
+
+  private static final String FONT_FAMILY = "serif";
+  private static final String ID = "id";
+  public static final int FOREGROUND_COLOR = Color.WHITE;
+  public static final int BACKGROUND_COLOR = Color.BLACK;
+  private TtmlStyle style;
+
+  @Before
+  public void setUp() throws Exception {
+    style = new TtmlStyle();
+  }
+
+  @Test
+  public void testInheritStyle() {
+    style.inherit(createAncestorStyle());
+    assertWithMessage("id must not be inherited").that(style.getId()).isNull();
+    assertThat(style.isUnderline()).isTrue();
+    assertThat(style.isLinethrough()).isTrue();
+    assertThat(style.getStyle()).isEqualTo(STYLE_BOLD_ITALIC);
+    assertThat(style.getFontFamily()).isEqualTo(FONT_FAMILY);
+    assertThat(style.getFontColor()).isEqualTo(WHITE);
+    assertWithMessage("do not inherit backgroundColor").that(style.hasBackgroundColor()).isFalse();
+  }
+
+  @Test
+  public void testChainStyle() {
+    style.chain(createAncestorStyle());
+    assertWithMessage("id must not be inherited").that(style.getId()).isNull();
+    assertThat(style.isUnderline()).isTrue();
+    assertThat(style.isLinethrough()).isTrue();
+    assertThat(style.getStyle()).isEqualTo(STYLE_BOLD_ITALIC);
+    assertThat(style.getFontFamily()).isEqualTo(FONT_FAMILY);
+    assertThat(style.getFontColor()).isEqualTo(FOREGROUND_COLOR);
+    // do inherit backgroundColor when chaining
+    assertWithMessage("do not inherit backgroundColor when chaining")
+        .that(style.getBackgroundColor()).isEqualTo(BACKGROUND_COLOR);
+  }
+
+  private static TtmlStyle createAncestorStyle() {
+    TtmlStyle ancestor = new TtmlStyle();
+    ancestor.setId(ID);
+    ancestor.setItalic(true);
+    ancestor.setBold(true);
+    ancestor.setBackgroundColor(BACKGROUND_COLOR);
+    ancestor.setFontColor(FOREGROUND_COLOR);
+    ancestor.setLinethrough(true);
+    ancestor.setUnderline(true);
+    ancestor.setFontFamily(FONT_FAMILY);
+    return ancestor;
+  }
+
+  @Test
+  public void testStyle() {
+    assertThat(style.getStyle()).isEqualTo(UNSPECIFIED);
+    style.setItalic(true);
+    assertThat(style.getStyle()).isEqualTo(STYLE_ITALIC);
+    style.setBold(true);
+    assertThat(style.getStyle()).isEqualTo(STYLE_BOLD_ITALIC);
+    style.setItalic(false);
+    assertThat(style.getStyle()).isEqualTo(STYLE_BOLD);
+    style.setBold(false);
+    assertThat(style.getStyle()).isEqualTo(STYLE_NORMAL);
+  }
+
+  @Test
+  public void testLinethrough() {
+    assertThat(style.isLinethrough()).isFalse();
+    style.setLinethrough(true);
+    assertThat(style.isLinethrough()).isTrue();
+    style.setLinethrough(false);
+    assertThat(style.isLinethrough()).isFalse();
+  }
+
+  @Test
+  public void testUnderline() {
+    assertThat(style.isUnderline()).isFalse();
+    style.setUnderline(true);
+    assertThat(style.isUnderline()).isTrue();
+    style.setUnderline(false);
+    assertThat(style.isUnderline()).isFalse();
+  }
+
+  @Test
+  public void testFontFamily() {
+    assertThat(style.getFontFamily()).isNull();
+    style.setFontFamily(FONT_FAMILY);
+    assertThat(style.getFontFamily()).isEqualTo(FONT_FAMILY);
+    style.setFontFamily(null);
+    assertThat(style.getFontFamily()).isNull();
+  }
+
+  @Test
+  public void testColor() {
+    assertThat(style.hasFontColor()).isFalse();
+    style.setFontColor(Color.BLACK);
+    assertThat(style.getFontColor()).isEqualTo(BLACK);
+    assertThat(style.hasFontColor()).isTrue();
+  }
+
+  @Test
+  public void testBackgroundColor() {
+    assertThat(style.hasBackgroundColor()).isFalse();
+    style.setBackgroundColor(Color.BLACK);
+    assertThat(style.getBackgroundColor()).isEqualTo(BLACK);
+    assertThat(style.hasBackgroundColor()).isTrue();
+  }
+
+  @Test
+  public void testId() {
+    assertThat(style.getId()).isNull();
+    style.setId(ID);
+    assertThat(style.getId()).isEqualTo(ID);
+    style.setId(null);
+    assertThat(style.getId()).isNull();
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
similarity index 61%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
index d6be100877..6ade85be28 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
@@ -15,22 +15,32 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
-import android.test.InstrumentationTestCase;
+import static com.google.android.exoplayer2.text.webvtt.CssParser.parseNextToken;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link CssParser}.
  */
-public final class CssParserTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class CssParserTest {
 
   private CssParser parser;
 
-  @Override
+  @Before
   public void setUp() {
     parser = new CssParser();
   }
 
+  @Test
   public void testSkipWhitespacesAndComments() {
     // Skip only whitespaces
     String skipOnlyWhitespaces = " \t\r\n\f End of skip\n /*  */";
@@ -53,6 +63,7 @@ public void testSkipWhitespacesAndComments() {
     assertSkipsToEndOfSkip(null, skipEverything);
   }
 
+  @Test
   public void testGetInputLimit() {
     // \r After 3 lines.
     String threeLinesThen3Cr = "One Line\nThen other\rAnd finally\r\r\r";
@@ -78,6 +89,7 @@ public void testGetInputLimit() {
     assertInputLimit(null, "");
   }
 
+  @Test
   public void testParseMethodSimpleInput() {
     String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     WebvttCssStyle expectedStyle = new WebvttCssStyle();
@@ -96,6 +108,7 @@ public void testParseMethodSimpleInput() {
     assertParserProduces(expectedStyle, styleBlock3);
   }
 
+  @Test
   public void testMultiplePropertiesInBlock() {
     String styleBlock = "::cue(#id){text-decoration:underline; background-color:green;"
         + "color:red; font-family:Courier; font-weight:bold}";
@@ -110,6 +123,7 @@ public void testMultiplePropertiesInBlock() {
     assertParserProduces(expectedStyle, styleBlock);
   }
 
+  @Test
   public void testRgbaColorExpression() {
     String styleBlock = "::cue(#rgb){background-color: rgba(\n10/* Ugly color */,11\t, 12\n,.1);"
         + "color:rgb(1,1,\n1)}";
@@ -121,59 +135,62 @@ public void testRgbaColorExpression() {
     assertParserProduces(expectedStyle, styleBlock);
   }
 
+  @Test
   public void testGetNextToken() {
     String stringInput = " lorem:ipsum\n{dolor}#sit,amet;lorem:ipsum\r\t\f\ndolor(())\n";
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(stringInput));
     StringBuilder builder = new StringBuilder();
-    assertEquals("lorem", CssParser.parseNextToken(input, builder));
-    assertEquals(":", CssParser.parseNextToken(input, builder));
-    assertEquals("ipsum", CssParser.parseNextToken(input, builder));
-    assertEquals("{", CssParser.parseNextToken(input, builder));
-    assertEquals("dolor", CssParser.parseNextToken(input, builder));
-    assertEquals("}", CssParser.parseNextToken(input, builder));
-    assertEquals("#sit", CssParser.parseNextToken(input, builder));
-    assertEquals(",", CssParser.parseNextToken(input, builder));
-    assertEquals("amet", CssParser.parseNextToken(input, builder));
-    assertEquals(";", CssParser.parseNextToken(input, builder));
-    assertEquals("lorem", CssParser.parseNextToken(input, builder));
-    assertEquals(":", CssParser.parseNextToken(input, builder));
-    assertEquals("ipsum", CssParser.parseNextToken(input, builder));
-    assertEquals("dolor", CssParser.parseNextToken(input, builder));
-    assertEquals("(", CssParser.parseNextToken(input, builder));
-    assertEquals("(", CssParser.parseNextToken(input, builder));
-    assertEquals(")", CssParser.parseNextToken(input, builder));
-    assertEquals(")", CssParser.parseNextToken(input, builder));
-    assertEquals(null, CssParser.parseNextToken(input, builder));
+    assertThat(parseNextToken(input, builder)).isEqualTo("lorem");
+    assertThat(parseNextToken(input, builder)).isEqualTo(":");
+    assertThat(parseNextToken(input, builder)).isEqualTo("ipsum");
+    assertThat(parseNextToken(input, builder)).isEqualTo("{");
+    assertThat(parseNextToken(input, builder)).isEqualTo("dolor");
+    assertThat(parseNextToken(input, builder)).isEqualTo("}");
+    assertThat(parseNextToken(input, builder)).isEqualTo("#sit");
+    assertThat(parseNextToken(input, builder)).isEqualTo(",");
+    assertThat(parseNextToken(input, builder)).isEqualTo("amet");
+    assertThat(parseNextToken(input, builder)).isEqualTo(";");
+    assertThat(parseNextToken(input, builder)).isEqualTo("lorem");
+    assertThat(parseNextToken(input, builder)).isEqualTo(":");
+    assertThat(parseNextToken(input, builder)).isEqualTo("ipsum");
+    assertThat(parseNextToken(input, builder)).isEqualTo("dolor");
+    assertThat(parseNextToken(input, builder)).isEqualTo("(");
+    assertThat(parseNextToken(input, builder)).isEqualTo("(");
+    assertThat(parseNextToken(input, builder)).isEqualTo(")");
+    assertThat(parseNextToken(input, builder)).isEqualTo(")");
+    assertThat(parseNextToken(input, builder)).isNull();
   }
 
+  @Test
   public void testStyleScoreSystem() {
     WebvttCssStyle style = new WebvttCssStyle();
     // Universal selector.
-    assertEquals(1, style.getSpecificityScore("", "", new String[0], ""));
+    assertThat(style.getSpecificityScore("", "", new String[0], "")).isEqualTo(1);
     // Class match without tag match.
     style.setTargetClasses(new String[] { "class1", "class2"});
-    assertEquals(8, style.getSpecificityScore("", "", new String[] { "class1", "class2", "class3" },
-        ""));
+    assertThat(style.getSpecificityScore("", "", new String[]{"class1", "class2", "class3"},
+        "")).isEqualTo(8);
     // Class and tag match
     style.setTargetTagName("b");
-    assertEquals(10, style.getSpecificityScore("", "b",
-        new String[] { "class1", "class2", "class3" }, ""));
+    assertThat(style.getSpecificityScore("", "b",
+        new String[]{"class1", "class2", "class3"}, "")).isEqualTo(10);
     // Class insufficiency.
-    assertEquals(0, style.getSpecificityScore("", "b", new String[] { "class1", "class" }, ""));
+    assertThat(style.getSpecificityScore("", "b", new String[]{"class1", "class"}, ""))
+        .isEqualTo(0);
     // Voice, classes and tag match.
     style.setTargetVoice("Manuel Cráneo");
-    assertEquals(14, style.getSpecificityScore("", "b",
-        new String[] { "class1", "class2", "class3" }, "Manuel Cráneo"));
+    assertThat(style.getSpecificityScore("", "b",
+        new String[]{"class1", "class2", "class3"}, "Manuel Cráneo")).isEqualTo(14);
     // Voice mismatch.
-    assertEquals(0, style.getSpecificityScore(null, "b",
-        new String[] { "class1", "class2", "class3" }, "Manuel Craneo"));
+    assertThat(style.getSpecificityScore(null, "b",
+        new String[]{"class1", "class2", "class3"}, "Manuel Craneo")).isEqualTo(0);
     // Id, voice, classes and tag match.
     style.setTargetId("id");
-    assertEquals(0x40000000 + 14, style.getSpecificityScore("id", "b",
-        new String[] { "class1", "class2", "class3" }, "Manuel Cráneo"));
+    assertThat(style.getSpecificityScore("id", "b",
+        new String[]{"class1", "class2", "class3"}, "Manuel Cráneo")).isEqualTo(0x40000000 + 14);
     // Id mismatch.
-    assertEquals(0, style.getSpecificityScore("id1", "b",
-        new String[] { "class1", "class2", "class3" }, ""));
+    assertThat(style.getSpecificityScore("id1", "b",
+        new String[]{"class1", "class2", "class3"}, "")).isEqualTo(0);
   }
 
   // Utility methods.
@@ -181,34 +198,34 @@ public void testStyleScoreSystem() {
   private void assertSkipsToEndOfSkip(String expectedLine, String s) {
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(s));
     CssParser.skipWhitespaceAndComments(input);
-    assertEquals(expectedLine, input.readLine());
+    assertThat(input.readLine()).isEqualTo(expectedLine);
   }
 
   private void assertInputLimit(String expectedLine, String s) {
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(s));
     CssParser.skipStyleBlock(input);
-    assertEquals(expectedLine, input.readLine());
+    assertThat(input.readLine()).isEqualTo(expectedLine);
   }
 
   private void assertParserProduces(WebvttCssStyle expected,
       String styleBlock){
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(styleBlock));
     WebvttCssStyle actualElem = parser.parseBlock(input);
-    assertEquals(expected.hasBackgroundColor(), actualElem.hasBackgroundColor());
+    assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
     if (expected.hasBackgroundColor()) {
-      assertEquals(expected.getBackgroundColor(), actualElem.getBackgroundColor());
+      assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
     }
-    assertEquals(expected.hasFontColor(), actualElem.hasFontColor());
+    assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
     if (expected.hasFontColor()) {
-      assertEquals(expected.getFontColor(), actualElem.getFontColor());
+      assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
     }
-    assertEquals(expected.getFontFamily(), actualElem.getFontFamily());
-    assertEquals(expected.getFontSize(), actualElem.getFontSize());
-    assertEquals(expected.getFontSizeUnit(), actualElem.getFontSizeUnit());
-    assertEquals(expected.getStyle(), actualElem.getStyle());
-    assertEquals(expected.isLinethrough(), actualElem.isLinethrough());
-    assertEquals(expected.isUnderline(), actualElem.isUnderline());
-    assertEquals(expected.getTextAlign(), actualElem.getTextAlign());
+    assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
+    assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
+    assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
+    assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
+    assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
+    assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
+    assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
similarity index 82%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
index 2cdad081c5..8937007990 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
@@ -15,16 +15,24 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import java.util.List;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link Mp4WebvttDecoder}.
  */
-public final class Mp4WebvttDecoderTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class Mp4WebvttDecoderTest {
 
   private static final byte[] SINGLE_CUE_SAMPLE = {
       0x00, 0x00, 0x00, 0x1C,  // Size
@@ -79,6 +87,7 @@
 
   // Positive tests.
 
+  @Test
   public void testSingleCueSample() throws SubtitleDecoderException {
     Mp4WebvttDecoder decoder = new Mp4WebvttDecoder();
     Subtitle result = decoder.decode(SINGLE_CUE_SAMPLE, SINGLE_CUE_SAMPLE.length, false);
@@ -86,6 +95,7 @@ public void testSingleCueSample() throws SubtitleDecoderException {
     assertMp4WebvttSubtitleEquals(result, expectedCue);
   }
 
+  @Test
   public void testTwoCuesSample() throws SubtitleDecoderException {
     Mp4WebvttDecoder decoder = new Mp4WebvttDecoder();
     Subtitle result = decoder.decode(DOUBLE_CUE_SAMPLE, DOUBLE_CUE_SAMPLE.length, false);
@@ -94,6 +104,7 @@ public void testTwoCuesSample() throws SubtitleDecoderException {
     assertMp4WebvttSubtitleEquals(result, firstExpectedCue, secondExpectedCue);
   }
 
+  @Test
   public void testNoCueSample() throws SubtitleDecoderException {
     Mp4WebvttDecoder decoder = new Mp4WebvttDecoder();
     Subtitle result = decoder.decode(NO_CUE_SAMPLE, NO_CUE_SAMPLE.length, false);
@@ -102,6 +113,7 @@ public void testNoCueSample() throws SubtitleDecoderException {
 
   // Negative tests.
 
+  @Test
   public void testSampleWithIncompleteHeader() {
     Mp4WebvttDecoder decoder = new Mp4WebvttDecoder();
     try {
@@ -122,10 +134,10 @@ public void testSampleWithIncompleteHeader() {
    * @param expectedCues The expected {@link Cue}s.
    */
   private static void assertMp4WebvttSubtitleEquals(Subtitle subtitle, Cue... expectedCues) {
-    assertEquals(1, subtitle.getEventTimeCount());
-    assertEquals(0, subtitle.getEventTime(0));
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(1);
+    assertThat(subtitle.getEventTime(0)).isEqualTo(0);
     List<Cue> subtitleCues = subtitle.getCues(0);
-    assertEquals(expectedCues.length, subtitleCues.size());
+    assertThat(subtitleCues).hasSize(expectedCues.length);
     for (int i = 0; i < subtitleCues.size(); i++) {
       assertCueEquals(expectedCues[i], subtitleCues.get(i));
     }
@@ -135,14 +147,14 @@ private static void assertMp4WebvttSubtitleEquals(Subtitle subtitle, Cue... expe
    * Asserts that two cues are equal.
    */
   private static void assertCueEquals(Cue expected, Cue actual) {
-    assertEquals(expected.line, actual.line);
-    assertEquals(expected.lineAnchor, actual.lineAnchor);
-    assertEquals(expected.lineType, actual.lineType);
-    assertEquals(expected.position, actual.position);
-    assertEquals(expected.positionAnchor, actual.positionAnchor);
-    assertEquals(expected.size, actual.size);
-    assertEquals(expected.text.toString(), actual.text.toString());
-    assertEquals(expected.textAlignment, actual.textAlignment);
+    assertThat(actual.line).isEqualTo(expected.line);
+    assertThat(actual.lineAnchor).isEqualTo(expected.lineAnchor);
+    assertThat(actual.lineType).isEqualTo(expected.lineType);
+    assertThat(actual.position).isEqualTo(expected.position);
+    assertThat(actual.positionAnchor).isEqualTo(expected.positionAnchor);
+    assertThat(actual.size).isEqualTo(expected.size);
+    assertThat(actual.text.toString()).isEqualTo(expected.text.toString());
+    assertThat(actual.textAlignment).isEqualTo(expected.textAlignment);
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
similarity index 50%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
index 1ee8976a7e..2a6e461627 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
@@ -15,209 +15,235 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
+import static android.graphics.Typeface.BOLD;
+import static android.graphics.Typeface.ITALIC;
+import static com.google.common.truth.Truth.assertThat;
+
 import android.graphics.Typeface;
-import android.test.InstrumentationTestCase;
 import android.text.Spanned;
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
 import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link WebvttCueParser}.
  */
-public final class WebvttCueParserTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class WebvttCueParserTest {
 
+  @Test
   public void testParseStrictValidClassesAndTrailingTokens() throws Exception {
     Spanned text = parseCueText("<v.first.loud Esme>"
         + "This <u.style1.style2 some stuff>is</u> text with <b.foo><i.bar>html</i></b> tags");
 
-    assertEquals("This is text with html tags", text.toString());
+    assertThat(text.toString()).isEqualTo("This is text with html tags");
 
     UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
     StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
-    assertEquals(1, underlineSpans.length);
-    assertEquals(2, styleSpans.length);
-    assertEquals(Typeface.ITALIC, styleSpans[0].getStyle());
-    assertEquals(Typeface.BOLD, styleSpans[1].getStyle());
-
-    assertEquals(5, text.getSpanStart(underlineSpans[0]));
-    assertEquals(7, text.getSpanEnd(underlineSpans[0]));
-    assertEquals(18, text.getSpanStart(styleSpans[0]));
-    assertEquals(18, text.getSpanStart(styleSpans[1]));
-    assertEquals(22, text.getSpanEnd(styleSpans[0]));
-    assertEquals(22, text.getSpanEnd(styleSpans[1]));
+    assertThat(underlineSpans).hasLength(1);
+    assertThat(styleSpans).hasLength(2);
+    assertThat(styleSpans[0].getStyle()).isEqualTo(ITALIC);
+    assertThat(styleSpans[1].getStyle()).isEqualTo(BOLD);
+
+    assertThat(text.getSpanStart(underlineSpans[0])).isEqualTo(5);
+    assertThat(text.getSpanEnd(underlineSpans[0])).isEqualTo(7);
+    assertThat(text.getSpanStart(styleSpans[0])).isEqualTo(18);
+    assertThat(text.getSpanStart(styleSpans[1])).isEqualTo(18);
+    assertThat(text.getSpanEnd(styleSpans[0])).isEqualTo(22);
+    assertThat(text.getSpanEnd(styleSpans[1])).isEqualTo(22);
   }
 
+  @Test
   public void testParseStrictValidUnsupportedTagsStrippedOut() throws Exception {
     Spanned text = parseCueText("<v.first.loud Esme>This <unsupported>is</unsupported> text with "
         + "<notsupp><invalid>html</invalid></notsupp> tags");
-    assertEquals("This is text with html tags", text.toString());
-    assertEquals(0, getSpans(text, UnderlineSpan.class).length);
-    assertEquals(0, getSpans(text, StyleSpan.class).length);
+    assertThat(text.toString()).isEqualTo("This is text with html tags");
+    assertThat(getSpans(text, UnderlineSpan.class)).hasLength(0);
+    assertThat(getSpans(text, StyleSpan.class)).hasLength(0);
   }
 
+  @Test
   public void testParseWellFormedUnclosedEndAtCueEnd() throws Exception {
     Spanned text = parseCueText("An <u some trailing stuff>unclosed u tag with "
         + "<i>italic</i> inside");
 
-    assertEquals("An unclosed u tag with italic inside", text.toString());
+    assertThat(text.toString()).isEqualTo("An unclosed u tag with italic inside");
 
     UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
     StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
-    assertEquals(1, underlineSpans.length);
-    assertEquals(1, styleSpans.length);
-    assertEquals(Typeface.ITALIC, styleSpans[0].getStyle());
-
-    assertEquals(3, text.getSpanStart(underlineSpans[0]));
-    assertEquals(23, text.getSpanStart(styleSpans[0]));
-    assertEquals(29, text.getSpanEnd(styleSpans[0]));
-    assertEquals(36, text.getSpanEnd(underlineSpans[0]));
+    assertThat(underlineSpans).hasLength(1);
+    assertThat(styleSpans).hasLength(1);
+    assertThat(styleSpans[0].getStyle()).isEqualTo(ITALIC);
+
+    assertThat(text.getSpanStart(underlineSpans[0])).isEqualTo(3);
+    assertThat(text.getSpanStart(styleSpans[0])).isEqualTo(23);
+    assertThat(text.getSpanEnd(styleSpans[0])).isEqualTo(29);
+    assertThat(text.getSpanEnd(underlineSpans[0])).isEqualTo(36);
   }
 
+  @Test
   public void testParseWellFormedUnclosedEndAtParent() throws Exception {
     Spanned text = parseCueText("An unclosed u tag with <i><u>underline and italic</i> inside");
 
-    assertEquals("An unclosed u tag with underline and italic inside", text.toString());
+    assertThat(text.toString()).isEqualTo("An unclosed u tag with underline and italic inside");
 
     UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
     StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
-    assertEquals(1, underlineSpans.length);
-    assertEquals(1, styleSpans.length);
+    assertThat(underlineSpans).hasLength(1);
+    assertThat(styleSpans).hasLength(1);
 
-    assertEquals(23, text.getSpanStart(underlineSpans[0]));
-    assertEquals(23, text.getSpanStart(styleSpans[0]));
-    assertEquals(43, text.getSpanEnd(underlineSpans[0]));
-    assertEquals(43, text.getSpanEnd(styleSpans[0]));
+    assertThat(text.getSpanStart(underlineSpans[0])).isEqualTo(23);
+    assertThat(text.getSpanStart(styleSpans[0])).isEqualTo(23);
+    assertThat(text.getSpanEnd(underlineSpans[0])).isEqualTo(43);
+    assertThat(text.getSpanEnd(styleSpans[0])).isEqualTo(43);
 
-    assertEquals(Typeface.ITALIC, styleSpans[0].getStyle());
+    assertThat(styleSpans[0].getStyle()).isEqualTo(ITALIC);
   }
 
+  @Test
   public void testParseMalformedNestedElements() throws Exception {
     Spanned text = parseCueText("<b><u>An unclosed u tag with <i>italic</u> inside</i></b>");
-    assertEquals("An unclosed u tag with italic inside", text.toString());
+    assertThat(text.toString()).isEqualTo("An unclosed u tag with italic inside");
 
     UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
     StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
-    assertEquals(1, underlineSpans.length);
-    assertEquals(2, styleSpans.length);
+    assertThat(underlineSpans).hasLength(1);
+    assertThat(styleSpans).hasLength(2);
 
     // all tags applied until matching start tag found
-    assertEquals(0, text.getSpanStart(underlineSpans[0]));
-    assertEquals(29, text.getSpanEnd(underlineSpans[0]));
+    assertThat(text.getSpanStart(underlineSpans[0])).isEqualTo(0);
+    assertThat(text.getSpanEnd(underlineSpans[0])).isEqualTo(29);
     if (styleSpans[0].getStyle() == Typeface.BOLD) {
-      assertEquals(0, text.getSpanStart(styleSpans[0]));
-      assertEquals(23, text.getSpanStart(styleSpans[1]));
-      assertEquals(29, text.getSpanEnd(styleSpans[1]));
-      assertEquals(36, text.getSpanEnd(styleSpans[0]));
+      assertThat(text.getSpanStart(styleSpans[0])).isEqualTo(0);
+      assertThat(text.getSpanStart(styleSpans[1])).isEqualTo(23);
+      assertThat(text.getSpanEnd(styleSpans[1])).isEqualTo(29);
+      assertThat(text.getSpanEnd(styleSpans[0])).isEqualTo(36);
     } else {
-      assertEquals(0, text.getSpanStart(styleSpans[1]));
-      assertEquals(23, text.getSpanStart(styleSpans[0]));
-      assertEquals(29, text.getSpanEnd(styleSpans[0]));
-      assertEquals(36, text.getSpanEnd(styleSpans[1]));
+      assertThat(text.getSpanStart(styleSpans[1])).isEqualTo(0);
+      assertThat(text.getSpanStart(styleSpans[0])).isEqualTo(23);
+      assertThat(text.getSpanEnd(styleSpans[0])).isEqualTo(29);
+      assertThat(text.getSpanEnd(styleSpans[1])).isEqualTo(36);
     }
   }
 
+  @Test
   public void testParseCloseNonExistingTag() throws Exception {
     Spanned text = parseCueText("blah<b>blah</i>blah</b>blah");
-    assertEquals("blahblahblahblah", text.toString());
+    assertThat(text.toString()).isEqualTo("blahblahblahblah");
 
     StyleSpan[] spans = getSpans(text, StyleSpan.class);
-    assertEquals(1, spans.length);
-    assertEquals(Typeface.BOLD, spans[0].getStyle());
-    assertEquals(4, text.getSpanStart(spans[0]));
-    assertEquals(8, text.getSpanEnd(spans[0])); // should be 12 when valid
+    assertThat(spans).hasLength(1);
+    assertThat(spans[0].getStyle()).isEqualTo(BOLD);
+    assertThat(text.getSpanStart(spans[0])).isEqualTo(4);
+    assertThat(text.getSpanEnd(spans[0])).isEqualTo(8); // should be 12 when valid
   }
 
+  @Test
   public void testParseEmptyTagName() throws Exception {
     Spanned text = parseCueText("An unclosed u tag with <>italic inside");
-    assertEquals("An unclosed u tag with italic inside", text.toString());
+    assertThat(text.toString()).isEqualTo("An unclosed u tag with italic inside");
   }
 
+  @Test
   public void testParseEntities() throws Exception {
     Spanned text = parseCueText("&amp; &gt; &lt; &nbsp;");
-    assertEquals("& > <  ", text.toString());
+    assertThat(text.toString()).isEqualTo("& > <  ");
   }
 
+  @Test
   public void testParseEntitiesUnsupported() throws Exception {
     Spanned text = parseCueText("&noway; &sure;");
-    assertEquals(" ", text.toString());
+    assertThat(text.toString()).isEqualTo(" ");
   }
 
+  @Test
   public void testParseEntitiesNotTerminated() throws Exception {
     Spanned text = parseCueText("&amp here comes text");
-    assertEquals("& here comes text", text.toString());
+    assertThat(text.toString()).isEqualTo("& here comes text");
   }
 
+  @Test
   public void testParseEntitiesNotTerminatedUnsupported() throws Exception {
     Spanned text = parseCueText("&surenot here comes text");
-    assertEquals(" here comes text", text.toString());
+    assertThat(text.toString()).isEqualTo(" here comes text");
   }
 
+  @Test
   public void testParseEntitiesNotTerminatedNoSpace() throws Exception {
     Spanned text = parseCueText("&surenot");
-    assertEquals("&surenot", text.toString());
+    assertThat(text.toString()).isEqualTo("&surenot");
   }
 
+  @Test
   public void testParseVoidTag() throws Exception {
     Spanned text = parseCueText("here comes<br/> text<br/>");
-    assertEquals("here comes text", text.toString());
+    assertThat(text.toString()).isEqualTo("here comes text");
   }
 
+  @Test
   public void testParseMultipleTagsOfSameKind() {
     Spanned text = parseCueText("blah <b>blah</b> blah <b>foo</b>");
 
-    assertEquals("blah blah blah foo", text.toString());
+    assertThat(text.toString()).isEqualTo("blah blah blah foo");
     StyleSpan[] spans = getSpans(text, StyleSpan.class);
-    assertEquals(2, spans.length);
-    assertEquals(5, text.getSpanStart(spans[0]));
-    assertEquals(9, text.getSpanEnd(spans[0]));
-    assertEquals(15, text.getSpanStart(spans[1]));
-    assertEquals(18, text.getSpanEnd(spans[1]));
-    assertEquals(Typeface.BOLD, spans[0].getStyle());
-    assertEquals(Typeface.BOLD, spans[1].getStyle());
+    assertThat(spans).hasLength(2);
+    assertThat(text.getSpanStart(spans[0])).isEqualTo(5);
+    assertThat(text.getSpanEnd(spans[0])).isEqualTo(9);
+    assertThat(text.getSpanStart(spans[1])).isEqualTo(15);
+    assertThat(text.getSpanEnd(spans[1])).isEqualTo(18);
+    assertThat(spans[0].getStyle()).isEqualTo(BOLD);
+    assertThat(spans[1].getStyle()).isEqualTo(BOLD);
   }
 
+  @Test
   public void testParseInvalidVoidSlash() {
     Spanned text = parseCueText("blah <b/.st1.st2 trailing stuff> blah");
 
-    assertEquals("blah  blah", text.toString());
+    assertThat(text.toString()).isEqualTo("blah  blah");
     StyleSpan[] spans = getSpans(text, StyleSpan.class);
-    assertEquals(0, spans.length);
+    assertThat(spans).hasLength(0);
   }
 
+  @Test
   public void testParseMonkey() throws Exception {
     Spanned text = parseCueText("< u>An unclosed u tag with <<<<< i>italic</u></u></u></u    >"
         + "</i><u><u> inside");
-    assertEquals("An unclosed u tag with italic inside", text.toString());
+    assertThat(text.toString()).isEqualTo("An unclosed u tag with italic inside");
     text = parseCueText(">>>>>>>>>An unclosed u tag with <<<<< italic</u></u></u>"
         + "</u  ></i><u><u> inside");
-    assertEquals(">>>>>>>>>An unclosed u tag with  inside", text.toString());
+    assertThat(text.toString()).isEqualTo(">>>>>>>>>An unclosed u tag with  inside");
   }
 
+  @Test
   public void testParseCornerCases() throws Exception {
     Spanned text = parseCueText(">");
-    assertEquals(">", text.toString());
+    assertThat(text.toString()).isEqualTo(">");
 
     text = parseCueText("<");
-    assertEquals("", text.toString());
+    assertThat(text.toString()).isEmpty();
 
     text = parseCueText("<b.st1.st2 annotation");
-    assertEquals("", text.toString());
+    assertThat(text.toString()).isEmpty();
 
     text = parseCueText("<<<<<<<<<<<<<<<<");
-    assertEquals("", text.toString());
+    assertThat(text.toString()).isEmpty();
 
     text = parseCueText("<<<<<<>><<<<<<<<<<");
-    assertEquals(">", text.toString());
+    assertThat(text.toString()).isEqualTo(">");
 
     text = parseCueText("<>");
-    assertEquals("", text.toString());
+    assertThat(text.toString()).isEmpty();
 
     text = parseCueText("&");
-    assertEquals("&", text.toString());
+    assertThat(text.toString()).isEqualTo("&");
 
     text = parseCueText("&&&&&&&");
-    assertEquals("&&&&&&&", text.toString());
+    assertThat(text.toString()).isEqualTo("&&&&&&&");
   }
 
   private static Spanned parseCueText(String string) {
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
similarity index 78%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
index 164c6c149a..c3c30e44a8 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
@@ -15,17 +15,25 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
-import com.google.android.exoplayer2.C;
+import static com.google.android.exoplayer2.C.INDEX_UNSET;
+import static com.google.common.truth.Truth.assertThat;
+import static java.lang.Long.MAX_VALUE;
+
 import com.google.android.exoplayer2.text.Cue;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link WebvttSubtitle}.
  */
-public class WebvttSubtitleTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class WebvttSubtitleTest {
 
   private static final String FIRST_SUBTITLE_STRING = "This is the first subtitle.";
   private static final String SECOND_SUBTITLE_STRING = "This is the second subtitle.";
@@ -65,21 +73,25 @@
     nestedSubtitle = new WebvttSubtitle(nestedSubtitleCues);
   }
 
+  @Test
   public void testEventCount() {
-    assertEquals(0, emptySubtitle.getEventTimeCount());
-    assertEquals(4, simpleSubtitle.getEventTimeCount());
-    assertEquals(4, overlappingSubtitle.getEventTimeCount());
-    assertEquals(4, nestedSubtitle.getEventTimeCount());
+    assertThat(emptySubtitle.getEventTimeCount()).isEqualTo(0);
+    assertThat(simpleSubtitle.getEventTimeCount()).isEqualTo(4);
+    assertThat(overlappingSubtitle.getEventTimeCount()).isEqualTo(4);
+    assertThat(nestedSubtitle.getEventTimeCount()).isEqualTo(4);
   }
 
+  @Test
   public void testSimpleSubtitleEventTimes() {
     testSubtitleEventTimesHelper(simpleSubtitle);
   }
 
+  @Test
   public void testSimpleSubtitleEventIndices() {
     testSubtitleEventIndicesHelper(simpleSubtitle);
   }
 
+  @Test
   public void testSimpleSubtitleText() {
     // Test before first subtitle
     assertSingleCueEmpty(simpleSubtitle.getCues(0));
@@ -107,14 +119,17 @@ public void testSimpleSubtitleText() {
     assertSingleCueEmpty(simpleSubtitle.getCues(Long.MAX_VALUE));
   }
 
+  @Test
   public void testOverlappingSubtitleEventTimes() {
     testSubtitleEventTimesHelper(overlappingSubtitle);
   }
 
+  @Test
   public void testOverlappingSubtitleEventIndices() {
     testSubtitleEventIndicesHelper(overlappingSubtitle);
   }
 
+  @Test
   public void testOverlappingSubtitleText() {
     // Test before first subtitle
     assertSingleCueEmpty(overlappingSubtitle.getCues(0));
@@ -145,14 +160,17 @@ public void testOverlappingSubtitleText() {
     assertSingleCueEmpty(overlappingSubtitle.getCues(Long.MAX_VALUE));
   }
 
+  @Test
   public void testNestedSubtitleEventTimes() {
     testSubtitleEventTimesHelper(nestedSubtitle);
   }
 
+  @Test
   public void testNestedSubtitleEventIndices() {
     testSubtitleEventIndicesHelper(nestedSubtitle);
   }
 
+  @Test
   public void testNestedSubtitleText() {
     // Test before first subtitle
     assertSingleCueEmpty(nestedSubtitle.getCues(0));
@@ -181,46 +199,46 @@ public void testNestedSubtitleText() {
   }
 
   private void testSubtitleEventTimesHelper(WebvttSubtitle subtitle) {
-    assertEquals(1000000, subtitle.getEventTime(0));
-    assertEquals(2000000, subtitle.getEventTime(1));
-    assertEquals(3000000, subtitle.getEventTime(2));
-    assertEquals(4000000, subtitle.getEventTime(3));
+    assertThat(subtitle.getEventTime(0)).isEqualTo(1000000);
+    assertThat(subtitle.getEventTime(1)).isEqualTo(2000000);
+    assertThat(subtitle.getEventTime(2)).isEqualTo(3000000);
+    assertThat(subtitle.getEventTime(3)).isEqualTo(4000000);
   }
 
   private void testSubtitleEventIndicesHelper(WebvttSubtitle subtitle) {
     // Test first event
-    assertEquals(0, subtitle.getNextEventTimeIndex(0));
-    assertEquals(0, subtitle.getNextEventTimeIndex(500000));
-    assertEquals(0, subtitle.getNextEventTimeIndex(999999));
+    assertThat(subtitle.getNextEventTimeIndex(0)).isEqualTo(0);
+    assertThat(subtitle.getNextEventTimeIndex(500000)).isEqualTo(0);
+    assertThat(subtitle.getNextEventTimeIndex(999999)).isEqualTo(0);
 
     // Test second event
-    assertEquals(1, subtitle.getNextEventTimeIndex(1000000));
-    assertEquals(1, subtitle.getNextEventTimeIndex(1500000));
-    assertEquals(1, subtitle.getNextEventTimeIndex(1999999));
+    assertThat(subtitle.getNextEventTimeIndex(1000000)).isEqualTo(1);
+    assertThat(subtitle.getNextEventTimeIndex(1500000)).isEqualTo(1);
+    assertThat(subtitle.getNextEventTimeIndex(1999999)).isEqualTo(1);
 
     // Test third event
-    assertEquals(2, subtitle.getNextEventTimeIndex(2000000));
-    assertEquals(2, subtitle.getNextEventTimeIndex(2500000));
-    assertEquals(2, subtitle.getNextEventTimeIndex(2999999));
+    assertThat(subtitle.getNextEventTimeIndex(2000000)).isEqualTo(2);
+    assertThat(subtitle.getNextEventTimeIndex(2500000)).isEqualTo(2);
+    assertThat(subtitle.getNextEventTimeIndex(2999999)).isEqualTo(2);
 
     // Test fourth event
-    assertEquals(3, subtitle.getNextEventTimeIndex(3000000));
-    assertEquals(3, subtitle.getNextEventTimeIndex(3500000));
-    assertEquals(3, subtitle.getNextEventTimeIndex(3999999));
+    assertThat(subtitle.getNextEventTimeIndex(3000000)).isEqualTo(3);
+    assertThat(subtitle.getNextEventTimeIndex(3500000)).isEqualTo(3);
+    assertThat(subtitle.getNextEventTimeIndex(3999999)).isEqualTo(3);
 
     // Test null event (i.e. look for events after the last event)
-    assertEquals(C.INDEX_UNSET, subtitle.getNextEventTimeIndex(4000000));
-    assertEquals(C.INDEX_UNSET, subtitle.getNextEventTimeIndex(4500000));
-    assertEquals(C.INDEX_UNSET, subtitle.getNextEventTimeIndex(Long.MAX_VALUE));
+    assertThat(subtitle.getNextEventTimeIndex(4000000)).isEqualTo(INDEX_UNSET);
+    assertThat(subtitle.getNextEventTimeIndex(4500000)).isEqualTo(INDEX_UNSET);
+    assertThat(subtitle.getNextEventTimeIndex(MAX_VALUE)).isEqualTo(INDEX_UNSET);
   }
 
   private void assertSingleCueEmpty(List<Cue> cues) {
-    assertTrue(cues.size() == 0);
+    assertThat(cues).isEmpty();
   }
 
   private void assertSingleCueTextEquals(String expected, List<Cue> cues) {
-    assertTrue(cues.size() == 1);
-    assertEquals(expected, cues.get(0).text.toString());
+    assertThat(cues).hasSize(1);
+    assertThat(cues.get(0).text.toString()).isEqualTo(expected);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
new file mode 100644
index 0000000000..a0e499139c
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -0,0 +1,660 @@
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES;
+import static com.google.android.exoplayer2.RendererCapabilities.FORMAT_HANDLED;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.Parameters;
+import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link DefaultTrackSelector}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class DefaultTrackSelectorTest {
+
+  private static final Parameters DEFAULT_PARAMETERS = new Parameters();
+  private static final RendererCapabilities ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES =
+      new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO);
+  private static final RendererCapabilities ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES =
+      new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO, FORMAT_EXCEEDS_CAPABILITIES);
+
+  @Mock
+  private InvalidationListener invalidationListener;
+
+  private DefaultTrackSelector trackSelector;
+
+  @Before
+  public void setUp() {
+    initMocks(this);
+    trackSelector = new DefaultTrackSelector();
+  }
+
+  /**
+   * Tests that track selector will not call
+   * {@link InvalidationListener#onTrackSelectionsInvalidated()} when it's set with default
+   * values of {@link Parameters}.
+   */
+  @Test
+  public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListener()
+      throws Exception {
+    trackSelector.init(invalidationListener);
+    trackSelector.setParameters(DEFAULT_PARAMETERS);
+
+    verify(invalidationListener, never()).onTrackSelectionsInvalidated();
+  }
+
+  /**
+   * Tests that track selector will call {@link InvalidationListener#onTrackSelectionsInvalidated()}
+   * when it's set with non-default values of {@link Parameters}.
+   */
+  @Test
+  public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    trackSelector.init(invalidationListener);
+    trackSelector.setParameters(parameters);
+
+    verify(invalidationListener).onTrackSelectionsInvalidated();
+  }
+
+  /**
+   * Tests that track selector will not call
+   * {@link InvalidationListener#onTrackSelectionsInvalidated()} again when it's set with
+   * the same values of {@link Parameters}.
+   */
+  @Test
+  public void testSetParameterWithSameParametersDoesNotNotifyInvalidationListenerAgain()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    trackSelector.init(invalidationListener);
+    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(parameters);
+
+    verify(invalidationListener, times(1)).onTrackSelectionsInvalidated();
+  }
+
+  /**
+   * Tests that track selector will select audio track with {@link C#SELECTION_FLAG_DEFAULT}
+   * given default values of {@link Parameters}.
+   */
+  @Test
+  public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
+    Format audioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format formatWithSelectionFlag =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(formatWithSelectionFlag, audioFormat));
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(formatWithSelectionFlag);
+  }
+
+  /**
+   * Tests that track selector will select audio track with language that match preferred language
+   * given by {@link Parameters}.
+   */
+  @Test
+  public void testSelectTracksSelectPreferredAudioLanguage()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    trackSelector.setParameters(parameters);
+
+    Format frAudioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, "fr");
+    Format enAudioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, "en");
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(frAudioFormat, enAudioFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(enAudioFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer selecting audio track with language that match preferred
+   * language given by {@link Parameters} over track with {@link C#SELECTION_FLAG_DEFAULT}.
+   */
+  @Test
+  public void testSelectTracksSelectPreferredAudioLanguageOverSelectionFlag()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    trackSelector.setParameters(parameters);
+
+    Format frAudioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "fr");
+    Format enAudioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, "en");
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(frAudioFormat, enAudioFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(enAudioFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer tracks that are within renderer's capabilities over
+   * track that exceed renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksPreferTrackWithinCapabilities()
+      throws Exception {
+    Format supportedFormat =
+        Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format exceededFormat =
+        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+    Map<String, Integer> mappedCapabilities = new HashMap<>();
+    mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);
+    mappedCapabilities.put(exceededFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
+    RendererCapabilities mappedAudioRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {mappedAudioRendererCapabilities},
+        singleTrackGroup(exceededFormat, supportedFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFormat);
+  }
+
+  /**
+   * Tests that track selector will select a track that exceeds the renderer's capabilities when
+   * there are no other choice, given the default {@link Parameters}.
+   */
+  @Test
+  public void testSelectTracksWithNoTrackWithinCapabilitiesSelectExceededCapabilityTrack()
+      throws Exception {
+
+    Format audioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(audioFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(audioFormat);
+  }
+
+  /**
+   * Tests that track selector will return a null track selection for a renderer when
+   * all tracks exceed that renderer's capabilities when {@link Parameters} does not allow
+   * exceeding-capabilities tracks.
+   */
+  @Test
+  public void testSelectTracksWithNoTrackWithinCapabilitiesAndSetByParamsReturnNoSelection()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withExceedRendererCapabilitiesIfNecessary(false);
+    trackSelector.setParameters(parameters);
+
+    Format audioFormat =
+        Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(audioFormat));
+
+    assertThat(result.selections.get(0)).isNull();
+  }
+
+  /**
+   * Tests that track selector will prefer tracks that are within renderer's capabilities over
+   * tracks that have {@link C#SELECTION_FLAG_DEFAULT} but exceed renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlag()
+      throws Exception {
+    Format supportedFormat =
+        Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format exceededWithSelectionFlagFormat =
+        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, null);
+
+    Map<String, Integer> mappedCapabilities = new HashMap<>();
+    mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);
+    mappedCapabilities.put(exceededWithSelectionFlagFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
+    RendererCapabilities mappedAudioRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {mappedAudioRendererCapabilities},
+        singleTrackGroup(exceededWithSelectionFlagFormat, supportedFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer tracks that are within renderer's capabilities over
+   * track that have language matching preferred audio given by {@link Parameters} but exceed
+   * renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    trackSelector.setParameters(parameters);
+
+    Format supportedFrFormat =
+        Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fr");
+    Format exceededEnFormat =
+        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "en");
+
+    Map<String, Integer> mappedCapabilities = new HashMap<>();
+    mappedCapabilities.put(exceededEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
+    mappedCapabilities.put(supportedFrFormat.id, FORMAT_HANDLED);
+    RendererCapabilities mappedAudioRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {mappedAudioRendererCapabilities},
+        singleTrackGroup(exceededEnFormat, supportedFrFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFrFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer tracks that are within renderer's capabilities over
+   * track that have both language matching preferred audio given by {@link Parameters} and
+   * {@link C#SELECTION_FLAG_DEFAULT}, but exceed renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlagAndPreferredLanguage()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    trackSelector.setParameters(parameters);
+
+    Format supportedFrFormat =
+        Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fr");
+    Format exceededDefaultSelectionEnFormat =
+        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "en");
+
+    Map<String, Integer> mappedCapabilities = new HashMap<>();
+    mappedCapabilities.put(exceededDefaultSelectionEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
+    mappedCapabilities.put(supportedFrFormat.id, FORMAT_HANDLED);
+    RendererCapabilities mappedAudioRendererCapabilities =
+        new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {mappedAudioRendererCapabilities},
+        singleTrackGroup(exceededDefaultSelectionEnFormat, supportedFrFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFrFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with higher num channel when other factors
+   * are the same, and tracks are within renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksWithinCapabilitiesSelectHigherNumChannel()
+      throws Exception {
+    Format lowerChannelFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherChannelFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 6, 44100, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherChannelFormat, lowerChannelFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(higherChannelFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with higher sample rate when other factors
+   * are the same, and tracks are within renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksWithinCapabilitiesSelectHigherSampleRate()
+      throws Exception {
+    Format higherSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format lowerSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 22050, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherSampleRateFormat, lowerSampleRateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(higherSampleRateFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with higher bit-rate when other factors
+   * are the same, and tracks are within renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksWithinCapabilitiesSelectHigherBitrate()
+      throws Exception {
+    Format lowerBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(lowerBitrateFormat, higherBitrateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(higherBitrateFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer audio tracks with higher channel count over tracks with
+   * higher sample rate when other factors are the same, and tracks are within renderer's
+   * capabilities.
+   */
+  @Test
+  public void testSelectTracksPreferHigherNumChannelBeforeSampleRate()
+      throws Exception {
+    Format lowerChannelHigherSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherChannelLowerSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 6, 22050, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat())
+        .isEqualTo(higherChannelLowerSampleRateFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer audio tracks with higher sample rate over tracks with
+   * higher bitrate when other factors are the same, and tracks are within renderer's
+   * capabilities.
+   */
+  @Test
+  public void testSelectTracksPreferHigherSampleRateBeforeBitrate()
+      throws Exception {
+    Format higherSampleRateLowerBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format lowerSampleRateHigherBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
+            Format.NO_VALUE, 2, 22050, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat())
+        .isEqualTo(higherSampleRateLowerBitrateFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with lower num channel when other factors
+   * are the same, and tracks exceed renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksExceedingCapabilitiesSelectLowerNumChannel()
+      throws Exception {
+    Format lowerChannelFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherChannelFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 6, 44100, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherChannelFormat, lowerChannelFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerChannelFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with lower sample rate when other factors
+   * are the same, and tracks exceed renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksExceedingCapabilitiesSelectLowerSampleRate()
+      throws Exception {
+    Format lowerSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 22050, null, null, 0, null);
+    Format higherSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherSampleRateFormat, lowerSampleRateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerSampleRateFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with lower bit-rate when other factors
+   * are the same, and tracks exceed renderer's capabilities.
+   */
+  @Test
+  public void testSelectTracksExceedingCapabilitiesSelectLowerBitrate()
+      throws Exception {
+    Format lowerBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(lowerBitrateFormat, higherBitrateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerBitrateFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer audio tracks with lower channel count over tracks with
+   * lower sample rate when other factors are the same, and tracks are within renderer's
+   * capabilities.
+   */
+  @Test
+  public void testSelectTracksExceedingCapabilitiesPreferLowerNumChannelBeforeSampleRate()
+      throws Exception {
+    Format lowerChannelHigherSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherChannelLowerSampleRateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 6, 22050, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat())
+        .isEqualTo(lowerChannelHigherSampleRateFormat);
+  }
+
+  /**
+   * Tests that track selector will prefer audio tracks with lower sample rate over tracks with
+   * lower bitrate when other factors are the same, and tracks are within renderer's
+   * capabilities.
+   */
+  @Test
+  public void testSelectTracksExceedingCapabilitiesPreferLowerSampleRateBeforeBitrate()
+      throws Exception {
+    Format higherSampleRateLowerBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format lowerSampleRateHigherBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
+            Format.NO_VALUE, 2, 22050, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},
+        singleTrackGroup(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat())
+        .isEqualTo(lowerSampleRateHigherBitrateFormat);
+  }
+
+  /**
+   * Tests that track selector will select audio tracks with lower bitrate when {@link Parameters}
+   * indicate lowest bitrate preference, even when tracks are within capabilities.
+   */
+  @Test
+  public void testSelectTracksWithinCapabilitiesAndForceLowestBitrateSelectLowerBitrate()
+      throws Exception {
+    Parameters parameters = DEFAULT_PARAMETERS.withForceLowestBitrate(true);
+    trackSelector.setParameters(parameters);
+
+    Format lowerBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+    Format higherBitrateFormat =
+        Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 30000,
+            Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+    TrackSelectorResult result = trackSelector.selectTracks(
+        new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+        singleTrackGroup(lowerBitrateFormat, higherBitrateFormat));
+
+    assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(lowerBitrateFormat);
+  }
+
+  private static TrackGroupArray singleTrackGroup(Format... formats) {
+    return new TrackGroupArray(new TrackGroup(formats));
+  }
+
+  /**
+   * A {@link RendererCapabilities} that advertises support for all formats of a given type using
+   * a provided support value. For any format that does not have the given track type,
+   * {@link #supportsFormat(Format)} will return {@link #FORMAT_UNSUPPORTED_TYPE}.
+   */
+  private static final class FakeRendererCapabilities implements RendererCapabilities {
+
+    private final int trackType;
+    private final int supportValue;
+
+    /**
+     * Returns {@link FakeRendererCapabilities} that advertises adaptive support for all
+     * tracks of the given type.
+     *
+     * @param trackType the track type of all formats that this renderer capabilities advertises
+     * support for.
+     */
+    FakeRendererCapabilities(int trackType) {
+      this(trackType, FORMAT_HANDLED | ADAPTIVE_SEAMLESS);
+    }
+
+    /**
+     * Returns {@link FakeRendererCapabilities} that advertises support level using given value
+     * for all tracks of the given type.
+     *
+     * @param trackType the track type of all formats that this renderer capabilities advertises
+     * support for.
+     * @param supportValue the support level value that will be returned for formats with
+     * the given type.
+     */
+    FakeRendererCapabilities(int trackType, int supportValue) {
+      this.trackType = trackType;
+      this.supportValue = supportValue;
+    }
+
+    @Override
+    public int getTrackType() {
+      return trackType;
+    }
+
+    @Override
+    public int supportsFormat(Format format) throws ExoPlaybackException {
+      return MimeTypes.getTrackType(format.sampleMimeType) == trackType
+          ? (supportValue) : FORMAT_UNSUPPORTED_TYPE;
+    }
+
+    @Override
+    public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+      return ADAPTIVE_SEAMLESS;
+    }
+
+  }
+
+  /**
+   * A {@link RendererCapabilities} that advertises support for different formats using a mapping
+   * between format ID and format-support value.
+   */
+  private static final class FakeMappedRendererCapabilities implements RendererCapabilities {
+
+    private final int trackType;
+    private final Map<String, Integer> formatToCapability;
+
+    /**
+     * Returns {@link FakeRendererCapabilities} that advertises support level using the given
+     * mapping between format ID and format-support value.
+     *
+     * @param trackType the track type to be returned for {@link #getTrackType()}
+     * @param formatToCapability a map of (format id, support level) that will be used to return
+     * support level for any given format. For any format that's not in the map,
+     * {@link #supportsFormat(Format)} will return {@link #FORMAT_UNSUPPORTED_TYPE}.
+     */
+    FakeMappedRendererCapabilities(int trackType, Map<String, Integer> formatToCapability) {
+      this.trackType = trackType;
+      this.formatToCapability = new HashMap<>(formatToCapability);
+    }
+
+    @Override
+    public int getTrackType() {
+      return trackType;
+    }
+
+    @Override
+    public int supportsFormat(Format format) throws ExoPlaybackException {
+      return format.id != null && formatToCapability.containsKey(format.id)
+          ? formatToCapability.get(format.id)
+          : FORMAT_UNSUPPORTED_TYPE;
+    }
+
+    @Override
+    public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+      return ADAPTIVE_SEAMLESS;
+    }
+
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
new file mode 100644
index 0000000000..b9ea0087c7
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.android.exoplayer2.RendererConfiguration.DEFAULT;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link MappingTrackSelector}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class MappingTrackSelectorTest {
+
+  private static final RendererCapabilities VIDEO_CAPABILITIES =
+      new FakeRendererCapabilities(C.TRACK_TYPE_VIDEO);
+  private static final RendererCapabilities AUDIO_CAPABILITIES =
+      new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO);
+  private static final RendererCapabilities NO_SAMPLE_CAPABILITIES =
+      new FakeRendererCapabilities(C.TRACK_TYPE_NONE);
+  private static final RendererCapabilities[] RENDERER_CAPABILITIES = new RendererCapabilities[] {
+      VIDEO_CAPABILITIES, AUDIO_CAPABILITIES
+  };
+  private static final RendererCapabilities[] RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER =
+      new RendererCapabilities[] {
+          VIDEO_CAPABILITIES, AUDIO_CAPABILITIES, NO_SAMPLE_CAPABILITIES
+      };
+
+  private static final TrackGroup VIDEO_TRACK_GROUP = new TrackGroup(
+      Format.createVideoSampleFormat("video", MimeTypes.VIDEO_H264, null, Format.NO_VALUE,
+          Format.NO_VALUE, 1024, 768, Format.NO_VALUE, null, null));
+  private static final TrackGroup AUDIO_TRACK_GROUP = new TrackGroup(
+      Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+          Format.NO_VALUE, 2, 44100, null, null, 0, null));
+  private static final TrackGroupArray TRACK_GROUPS = new TrackGroupArray(
+      VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);
+
+  private static final TrackSelection[] TRACK_SELECTIONS = new TrackSelection[] {
+      new FixedTrackSelection(VIDEO_TRACK_GROUP, 0),
+      new FixedTrackSelection(AUDIO_TRACK_GROUP, 0)
+  };
+
+  private static final TrackSelection[] TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER =
+      new TrackSelection[] {
+          new FixedTrackSelection(VIDEO_TRACK_GROUP, 0),
+          new FixedTrackSelection(AUDIO_TRACK_GROUP, 0),
+          null
+      };
+
+  /**
+   * Tests that the video and audio track groups are mapped onto the correct renderers.
+   */
+  @Test
+  public void testMapping() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
+    trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
+    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP);
+    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
+  }
+
+  /**
+   * Tests that the video and audio track groups are mapped onto the correct renderers when the
+   * renderer ordering is reversed.
+   */
+  @Test
+  public void testMappingReverseOrder() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
+    RendererCapabilities[] reverseOrderRendererCapabilities = new RendererCapabilities[] {
+        AUDIO_CAPABILITIES, VIDEO_CAPABILITIES};
+    trackSelector.selectTracks(reverseOrderRendererCapabilities, TRACK_GROUPS);
+    trackSelector.assertMappedTrackGroups(0, AUDIO_TRACK_GROUP);
+    trackSelector.assertMappedTrackGroups(1, VIDEO_TRACK_GROUP);
+  }
+
+  /**
+   * Tests video and audio track groups are mapped onto the correct renderers when there are
+   * multiple track groups of the same type.
+   */
+  @Test
+  public void testMappingMulti() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
+    TrackGroupArray multiTrackGroups = new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP,
+        VIDEO_TRACK_GROUP);
+    trackSelector.selectTracks(RENDERER_CAPABILITIES, multiTrackGroups);
+    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP, VIDEO_TRACK_GROUP);
+    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
+  }
+
+  /**
+   * Tests the result of {@link MappingTrackSelector#selectTracks(RendererCapabilities[],
+   * TrackGroupArray[], int[][][])} is propagated correctly to the result of
+   * {@link MappingTrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)}.
+   */
+  @Test
+  public void testSelectTracks() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(
+        TRACK_SELECTIONS);
+    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isEqualTo(TRACK_SELECTIONS[0]);
+    assertThat(result.selections.get(1)).isEqualTo(TRACK_SELECTIONS[1]);
+    assertThat(new boolean[] {true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that a null override clears a track selection.
+   */
+  @Test
+  public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(
+        TRACK_SELECTIONS);
+    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
+    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isNull();
+    assertThat(result.selections.get(1)).isEqualTo(TRACK_SELECTIONS[1]);
+    assertThat(new boolean[] {false, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {null, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that a null override can be cleared.
+   */
+  @Test
+  public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(
+        TRACK_SELECTIONS);
+    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
+    trackSelector.clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP));
+    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isEqualTo(TRACK_SELECTIONS[0]);
+    assertThat(result.selections.get(1)).isEqualTo(TRACK_SELECTIONS[1]);
+    assertThat(new boolean[] {true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that an override is not applied for a different set of available track groups.
+   */
+  @Test
+  public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(
+        TRACK_SELECTIONS);
+    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
+    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES,
+        new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP));
+    assertThat(result.selections.get(0)).isEqualTo(TRACK_SELECTIONS[0]);
+    assertThat(result.selections.get(1)).isEqualTo(TRACK_SELECTIONS[1]);
+    assertThat(new boolean[] {true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests the result of {@link MappingTrackSelector#selectTracks(RendererCapabilities[],
+   * TrackGroupArray[], int[][][])} is propagated correctly to the result of
+   * {@link MappingTrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)}
+   * when there is no-sample renderer.
+   */
+  @Test
+  public void testSelectTracksWithNoSampleRenderer() throws ExoPlaybackException {
+    TrackSelection[] expectedTrackSelection = TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER;
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(expectedTrackSelection);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isEqualTo(expectedTrackSelection[0]);
+    assertThat(result.selections.get(1)).isEqualTo(expectedTrackSelection[1]);
+    assertThat(result.selections.get(2)).isNull();
+    assertThat(new boolean[] {true, true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that a null override clears a track selection when there is no-sample renderer.
+   */
+  @Test
+  public void testSelectTracksWithNoSampleRendererWithNullOverride() throws ExoPlaybackException {
+    TrackSelection[] expectedTrackSelection = TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER;
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(expectedTrackSelection);
+    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isNull();
+    assertThat(result.selections.get(1)).isEqualTo(expectedTrackSelection[1]);
+    assertThat(result.selections.get(2)).isNull();
+    assertThat(new boolean[] {false, true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {null, DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that a null override can be cleared when there is no-sample renderer.
+   */
+  @Test
+  public void testSelectTracksWithNoSampleRendererWithClearedNullOverride()
+      throws ExoPlaybackException {
+    TrackSelection[] expectedTrackSelection = TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER;
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(expectedTrackSelection);
+    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
+    trackSelector.clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP));
+    TrackSelectorResult result = trackSelector.selectTracks(
+        RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isEqualTo(expectedTrackSelection[0]);
+    assertThat(result.selections.get(1)).isEqualTo(expectedTrackSelection[1]);
+    assertThat(result.selections.get(2)).isNull();
+    assertThat(new boolean[] {true, true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that an override is not applied for a different set of available track groups
+   * when there is no-sample renderer.
+   */
+  @Test
+  public void testSelectTracksWithNoSampleRendererWithNullOverrideForDifferentTracks()
+      throws ExoPlaybackException {
+    TrackSelection[] expectedTrackSelection = TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER;
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(expectedTrackSelection);
+    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER,
+        new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP));
+    assertThat(result.selections.get(0)).isEqualTo(expectedTrackSelection[0]);
+    assertThat(result.selections.get(1)).isEqualTo(expectedTrackSelection[1]);
+    assertThat(result.selections.get(2)).isNull();
+    assertThat(new boolean[] {true, true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that disabling another renderer works when there is no-sample renderer.
+   */
+  @Test
+  public void testSelectTracksDisablingNormalRendererWithNoSampleRenderer()
+      throws ExoPlaybackException {
+    TrackSelection[] expectedTrackSelection = TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER;
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(expectedTrackSelection);
+    trackSelector.setRendererDisabled(0, true);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isNull();
+    assertThat(result.selections.get(1)).isEqualTo(expectedTrackSelection[1]);
+    assertThat(result.selections.get(2)).isNull();
+    assertThat(new boolean[] {false, true, true}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {null, DEFAULT, DEFAULT})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * Tests that disabling no-sample renderer work.
+   */
+  @Test
+  public void testSelectTracksDisablingNoSampleRenderer()
+      throws ExoPlaybackException {
+    TrackSelection[] expectedTrackSelection = TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER;
+    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(expectedTrackSelection);
+    trackSelector.setRendererDisabled(2, true);
+    TrackSelectorResult result = trackSelector.selectTracks(
+        RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS);
+    assertThat(result.selections.get(0)).isEqualTo(expectedTrackSelection[0]);
+    assertThat(result.selections.get(1)).isEqualTo(expectedTrackSelection[1]);
+    assertThat(result.selections.get(2)).isNull();
+    assertThat(new boolean[] {true, true, false}).isEqualTo(result.renderersEnabled);
+    assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT, null})
+        .isEqualTo(result.rendererConfigurations);
+  }
+
+  /**
+   * A {@link MappingTrackSelector} that returns a fixed result from
+   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray[], int[][][])}.
+   */
+  private static final class FakeMappingTrackSelector extends MappingTrackSelector {
+
+    private final TrackSelection[] result;
+    private TrackGroupArray[] lastRendererTrackGroupArrays;
+
+    public FakeMappingTrackSelector(TrackSelection... result) {
+      this.result = result.length == 0 ? null : result;
+    }
+
+    @Override
+    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
+        TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
+        throws ExoPlaybackException {
+      lastRendererTrackGroupArrays = rendererTrackGroupArrays;
+      TrackSelection[] trackSelectionResult = new TrackSelection[rendererCapabilities.length];
+      return result == null ? trackSelectionResult
+          // return a copy of the provided result, because MappingTrackSelector
+          // might modify the returned array here, and we don't want that to affect
+          // the original array.
+          : Arrays.asList(result).toArray(trackSelectionResult);
+    }
+
+    public void assertMappedTrackGroups(int rendererIndex, TrackGroup... expected) {
+      assertThat(lastRendererTrackGroupArrays[rendererIndex].length).isEqualTo(expected.length);
+      for (int i = 0; i < expected.length; i++) {
+        assertThat(lastRendererTrackGroupArrays[rendererIndex].get(i)).isEqualTo(expected[i]);
+      }
+    }
+
+  }
+
+  /**
+   * A {@link RendererCapabilities} that advertises adaptive support for all tracks of a given type.
+   */
+  private static final class FakeRendererCapabilities implements RendererCapabilities {
+
+    private final int trackType;
+
+    public FakeRendererCapabilities(int trackType) {
+      this.trackType = trackType;
+    }
+
+    @Override
+    public int getTrackType() {
+      return trackType;
+    }
+
+    @Override
+    public int supportsFormat(Format format) throws ExoPlaybackException {
+      return MimeTypes.getTrackType(format.sampleMimeType) == trackType
+          ? (FORMAT_HANDLED | ADAPTIVE_SEAMLESS) : FORMAT_UNSUPPORTED_TYPE;
+    }
+
+    @Override
+    public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+      return ADAPTIVE_SEAMLESS;
+    }
+
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
similarity index 82%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
index b805ccbdd5..a72d060287 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
@@ -15,26 +15,37 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link ByteArrayDataSource}.
  */
-public class ByteArrayDataSourceTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ByteArrayDataSourceTest {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   private static final byte[] TEST_DATA_ODD = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
 
+  @Test
   public void testFullReadSingleBytes() {
     readTestData(TEST_DATA, 0, C.LENGTH_UNSET, 1, 0, 1, false);
   }
 
+  @Test
   public void testFullReadAllBytes() {
     readTestData(TEST_DATA, 0, C.LENGTH_UNSET, 100, 0, 100, false);
   }
 
+  @Test
   public void testLimitReadSingleBytes() {
     // Limit set to the length of the data.
     readTestData(TEST_DATA, 0, TEST_DATA.length, 1, 0, 1, false);
@@ -42,6 +53,7 @@ public void testLimitReadSingleBytes() {
     readTestData(TEST_DATA, 0, 6, 1, 0, 1, false);
   }
 
+  @Test
   public void testFullReadTwoBytes() {
     // Try with the total data length an exact multiple of the size of each individual read.
     readTestData(TEST_DATA, 0, C.LENGTH_UNSET, 2, 0, 2, false);
@@ -49,6 +61,7 @@ public void testFullReadTwoBytes() {
     readTestData(TEST_DATA_ODD, 0, C.LENGTH_UNSET, 2, 0, 2, false);
   }
 
+  @Test
   public void testLimitReadTwoBytes() {
     // Try with the limit an exact multiple of the size of each individual read.
     readTestData(TEST_DATA, 0, 6, 2, 0, 2, false);
@@ -56,6 +69,7 @@ public void testLimitReadTwoBytes() {
     readTestData(TEST_DATA, 0, 7, 2, 0, 2, false);
   }
 
+  @Test
   public void testReadFromValidOffsets() {
     // Read from an offset without bound.
     readTestData(TEST_DATA, 1, C.LENGTH_UNSET, 1, 0, 1, false);
@@ -67,6 +81,7 @@ public void testReadFromValidOffsets() {
     readTestData(TEST_DATA, TEST_DATA.length - 1, 1, 1, 0, 1, false);
   }
 
+  @Test
   public void testReadFromInvalidOffsets() {
     // Read from first invalid offset and check failure without bound.
     readTestData(TEST_DATA, TEST_DATA.length, C.LENGTH_UNSET, 1, 0, 1, true);
@@ -74,6 +89,7 @@ public void testReadFromInvalidOffsets() {
     readTestData(TEST_DATA, TEST_DATA.length, 1, 1, 0, 1, true);
   }
 
+  @Test
   public void testReadWithInvalidLength() {
     // Read more data than is available.
     readTestData(TEST_DATA, 0, TEST_DATA.length + 1, 1, 0, 1, true);
@@ -102,10 +118,10 @@ private void readTestData(byte[] testData, int dataOffset, int dataLength, int o
       // Open the source.
       long length = dataSource.open(new DataSpec(null, dataOffset, dataLength, null));
       opened = true;
-      assertFalse(expectFailOnOpen);
+      assertThat(expectFailOnOpen).isFalse();
 
       // Verify the resolved length is as we expect.
-      assertEquals(expectedFinalBytesRead, length);
+      assertThat(length).isEqualTo(expectedFinalBytesRead);
 
       byte[] outputBuffer = new byte[outputBufferLength];
       int accumulatedBytesRead = 0;
@@ -113,26 +129,26 @@ private void readTestData(byte[] testData, int dataOffset, int dataLength, int o
         // Calculate a valid length for the next read, constraining by the specified output buffer
         // length, write offset and maximum write length input parameters.
         int requestedReadLength = Math.min(maxReadLength, outputBufferLength - writeOffset);
-        assertTrue(requestedReadLength > 0);
+        assertThat(requestedReadLength).isGreaterThan(0);
 
         int bytesRead = dataSource.read(outputBuffer, writeOffset, requestedReadLength);
         if (bytesRead != C.RESULT_END_OF_INPUT) {
-          assertTrue(bytesRead > 0);
-          assertTrue(bytesRead <= requestedReadLength);
+          assertThat(bytesRead).isGreaterThan(0);
+          assertThat(bytesRead).isAtMost(requestedReadLength);
           // Check the data read was correct.
           for (int i = 0; i < bytesRead; i++) {
-            assertEquals(testData[dataOffset + accumulatedBytesRead + i],
-                outputBuffer[writeOffset + i]);
+            assertThat(outputBuffer[writeOffset + i])
+                .isEqualTo(testData[dataOffset + accumulatedBytesRead + i]);
           }
           // Check that we haven't read more data than we were expecting.
           accumulatedBytesRead += bytesRead;
-          assertTrue(accumulatedBytesRead <= expectedFinalBytesRead);
+          assertThat(accumulatedBytesRead).isAtMost(expectedFinalBytesRead);
           // If we haven't read all of the bytes the request should have been satisfied in full.
-          assertTrue(accumulatedBytesRead == expectedFinalBytesRead
-              || bytesRead == requestedReadLength);
+          assertThat(accumulatedBytesRead == expectedFinalBytesRead
+              || bytesRead == requestedReadLength).isTrue();
         } else {
           // We're done. Check we read the expected number of bytes.
-          assertEquals(expectedFinalBytesRead, accumulatedBytesRead);
+          assertThat(accumulatedBytesRead).isEqualTo(expectedFinalBytesRead);
           return;
         }
       }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
new file mode 100644
index 0000000000..85c4341232
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.android.exoplayer2.C.RESULT_END_OF_INPUT;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link DataSchemeDataSource}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class DataSchemeDataSourceTest {
+
+  private DataSource schemeDataDataSource;
+
+  @Before
+  public void setUp() {
+    schemeDataDataSource = new DataSchemeDataSource();
+  }
+
+  @Test
+  public void testBase64Data() throws IOException {
+    DataSpec dataSpec = buildDataSpec("data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiL"
+        + "CJjb250ZW50X2lkIjoiTWpBeE5WOTBaV0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwM"
+        + "DAwMDAwMDAwMDAiXX0=");
+    DataSourceAsserts.assertDataSourceContent(schemeDataDataSource, dataSpec,
+        ("{\"provider\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
+        + "[\"00000000000000000000000000000000\"]}").getBytes(Charset.forName(C.UTF8_NAME)));
+  }
+
+  @Test
+  public void testAsciiData() throws IOException {
+    DataSourceAsserts.assertDataSourceContent(schemeDataDataSource,
+        buildDataSpec("data:,A%20brief%20note"),
+        "A brief note".getBytes(Charset.forName(C.UTF8_NAME)));
+  }
+
+  @Test
+  public void testPartialReads() throws IOException {
+    byte[] buffer = new byte[18];
+    DataSpec dataSpec = buildDataSpec("data:,012345678901234567");
+    assertThat(schemeDataDataSource.open(dataSpec)).isEqualTo(18);
+    assertThat(schemeDataDataSource.read(buffer, 0, 9)).isEqualTo(9);
+    assertThat(schemeDataDataSource.read(buffer, 3, 0)).isEqualTo(0);
+    assertThat(schemeDataDataSource.read(buffer, 9, 15)).isEqualTo(9);
+    assertThat(schemeDataDataSource.read(buffer, 1, 0)).isEqualTo(0);
+    assertThat(schemeDataDataSource.read(buffer, 1, 1)).isEqualTo(RESULT_END_OF_INPUT);
+    assertThat(new String(buffer, 0, 18, C.UTF8_NAME)).isEqualTo("012345678901234567");
+  }
+
+  @Test
+  public void testIncorrectScheme() {
+    try {
+      schemeDataDataSource.open(buildDataSpec("http://www.google.com"));
+      fail();
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testMalformedData() {
+    try {
+      schemeDataDataSource.open(buildDataSpec("data:text/plain;base64,,This%20is%20Content"));
+      fail();
+    } catch (IOException e) {
+      // Expected.
+    }
+    try {
+      schemeDataDataSource.open(buildDataSpec("data:text/plain;base64,IncorrectPadding=="));
+      fail();
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  private static DataSpec buildDataSpec(String uriString) {
+    return new DataSpec(Uri.parse(uriString));
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceAsserts.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceAsserts.java
new file mode 100644
index 0000000000..eff3245923
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceAsserts.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.IOException;
+
+/**
+ * Assertions for data source tests.
+ */
+/* package */ final class DataSourceAsserts {
+
+  /**
+   * Asserts that data read from a {@link DataSource} matches {@code expected}.
+   *
+   * @param dataSource The {@link DataSource} through which to read.
+   * @param dataSpec The {@link DataSpec} to use when opening the {@link DataSource}.
+   * @param expectedData The expected data.
+   * @throws IOException If an error occurs reading fom the {@link DataSource}.
+   */
+  public static void assertDataSourceContent(DataSource dataSource, DataSpec dataSpec,
+      byte[] expectedData) throws IOException {
+    try {
+      long length = dataSource.open(dataSpec);
+      assertThat(length).isEqualTo(expectedData.length);
+      byte[] readData = TestUtil.readToEnd(dataSource);
+      assertThat(readData).isEqualTo(expectedData);
+    } finally {
+      dataSource.close();
+    }
+  }
+
+  private DataSourceAsserts() {}
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
similarity index 65%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
index 38797ede66..8cd6c23fb1 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
@@ -15,75 +15,84 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.net.Uri;
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
 import java.util.Arrays;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link DataSourceInputStream}.
  */
-public class DataSourceInputStreamTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class DataSourceInputStreamTest {
 
   private static final byte[] TEST_DATA = TestUtil.buildTestData(16);
 
+  @Test
   public void testReadSingleBytes() throws IOException {
     DataSourceInputStream inputStream = buildTestInputStream();
     // No bytes read yet.
-    assertEquals(0, inputStream.bytesRead());
+    assertThat(inputStream.bytesRead()).isEqualTo(0);
     // Read bytes.
     for (int i = 0; i < TEST_DATA.length; i++) {
       int readByte = inputStream.read();
-      assertTrue(0 <= readByte && readByte < 256);
-      assertEquals(TEST_DATA[i] & 0xFF, readByte);
-      assertEquals(i + 1, inputStream.bytesRead());
+      assertThat(0 <= readByte && readByte < 256).isTrue();
+      assertThat(readByte).isEqualTo(TEST_DATA[i] & 0xFF);
+      assertThat(inputStream.bytesRead()).isEqualTo(i + 1);
     }
     // Check end of stream.
-    assertEquals(-1, inputStream.read());
-    assertEquals(TEST_DATA.length, inputStream.bytesRead());
+    assertThat(inputStream.read()).isEqualTo(-1);
+    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
     // Check close succeeds.
     inputStream.close();
   }
 
+  @Test
   public void testRead() throws IOException {
     DataSourceInputStream inputStream = buildTestInputStream();
     // Read bytes.
     byte[] readBytes = new byte[TEST_DATA.length];
     int totalBytesRead = 0;
     while (totalBytesRead < TEST_DATA.length) {
-      long bytesRead = inputStream.read(readBytes, totalBytesRead,
+      int bytesRead = inputStream.read(readBytes, totalBytesRead,
           TEST_DATA.length - totalBytesRead);
-      assertTrue(bytesRead > 0);
+      assertThat(bytesRead).isGreaterThan(0);
       totalBytesRead += bytesRead;
-      assertEquals(totalBytesRead, inputStream.bytesRead());
+      assertThat(inputStream.bytesRead()).isEqualTo(totalBytesRead);
     }
     // Check the read data.
-    MoreAsserts.assertEquals(TEST_DATA, readBytes);
+    assertThat(readBytes).isEqualTo(TEST_DATA);
     // Check end of stream.
-    assertEquals(TEST_DATA.length, inputStream.bytesRead());
-    assertEquals(TEST_DATA.length, totalBytesRead);
-    assertEquals(-1, inputStream.read());
+    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
+    assertThat(totalBytesRead).isEqualTo(TEST_DATA.length);
+    assertThat(inputStream.read()).isEqualTo(-1);
     // Check close succeeds.
     inputStream.close();
   }
 
+  @Test
   public void testSkip() throws IOException {
     DataSourceInputStream inputStream = buildTestInputStream();
     // Skip bytes.
     long totalBytesSkipped = 0;
     while (totalBytesSkipped < TEST_DATA.length) {
       long bytesSkipped = inputStream.skip(Long.MAX_VALUE);
-      assertTrue(bytesSkipped > 0);
+      assertThat(bytesSkipped > 0).isTrue();
       totalBytesSkipped += bytesSkipped;
-      assertEquals(totalBytesSkipped, inputStream.bytesRead());
+      assertThat(inputStream.bytesRead()).isEqualTo(totalBytesSkipped);
     }
     // Check end of stream.
-    assertEquals(TEST_DATA.length, inputStream.bytesRead());
-    assertEquals(TEST_DATA.length, totalBytesSkipped);
-    assertEquals(-1, inputStream.read());
+    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
+    assertThat(totalBytesSkipped).isEqualTo(TEST_DATA.length);
+    assertThat(inputStream.read()).isEqualTo(-1);
     // Check close succeeds.
     inputStream.close();
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
new file mode 100644
index 0000000000..aa98ad3179
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.testutil.FakeDataSet;
+import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
+import com.google.android.exoplayer2.upstream.DataSourceInputStream;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+
+/** Assertion methods for {@link com.google.android.exoplayer2.upstream.cache.Cache}. */
+/* package */ final class CacheAsserts {
+
+  /** Asserts that the cache content is equal to the data in the {@code fakeDataSet}. */
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
+    ArrayList<FakeData> allData = fakeDataSet.getAllData();
+    Uri[] uris = new Uri[allData.size()];
+    for (int i = 0; i < allData.size(); i++) {
+      uris[i] = allData.get(i).uri;
+    }
+    assertCachedData(cache, fakeDataSet, uris);
+  }
+
+  /**
+   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   */
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
+      throws IOException {
+    Uri[] uris = new Uri[uriStrings.length];
+    for (int i = 0; i < uriStrings.length; i++) {
+      uris[i] = Uri.parse(uriStrings[i]);
+    }
+    assertCachedData(cache, fakeDataSet, uris);
+  }
+
+  /**
+   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   */
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
+      throws IOException {
+    int totalLength = 0;
+    for (Uri uri : uris) {
+      byte[] data = fakeDataSet.getData(uri).getData();
+      assertDataCached(cache, uri, data);
+      totalLength += data.length;
+    }
+    assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
+  }
+
+  /** Asserts that the cache contains the given subset of data in the {@code fakeDataSet}. */
+  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
+      throws IOException {
+    for (Uri uri : uris) {
+      assertDataCached(cache, uri, fakeDataSet.getData(uri).getData());
+    }
+  }
+
+  /** Asserts that the cache contains the given data for {@code uriString}. */
+  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
+    CacheDataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
+    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
+        new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
+    try {
+      inputStream.open();
+      byte[] buffer = new byte[1024];
+      int bytesRead;
+      while ((bytesRead = inputStream.read(buffer)) != -1) {
+        outputStream.write(buffer, 0, bytesRead);
+      }
+    } catch (IOException e) {
+      // Ignore
+    } finally {
+      inputStream.close();
+    }
+    assertWithMessage("Cached data doesn't match expected for '" + uri + "'")
+        .that(outputStream.toByteArray()).isEqualTo(expected);
+  }
+
+  /** Asserts that there is no cache content for the given {@code uriStrings}. */
+  public static void assertDataNotCached(Cache cache, String... uriStrings) {
+    for (String uriString : uriStrings) {
+      assertWithMessage("There is cached data for '" + uriString + "'")
+          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString)))).isNull();
+    }
+  }
+
+  /** Asserts that the cache is empty. */
+  public static void assertCacheEmpty(Cache cache) {
+    assertThat(cache.getCacheSpace()).isEqualTo(0);
+  }
+
+  private CacheAsserts() {}
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
similarity index 77%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index e7ff2a6811..e92f072dc2 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -15,11 +15,16 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
+import static android.net.Uri.EMPTY;
+import static com.google.android.exoplayer2.C.LENGTH_UNSET;
+import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static java.util.Arrays.copyOf;
+import static java.util.Arrays.copyOfRange;
+import static org.junit.Assert.fail;
 
 import android.net.Uri;
-import android.test.InstrumentationTestCase;
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
@@ -28,12 +33,21 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link CacheDataSource}.
  */
-public class CacheDataSourceTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class CacheDataSourceTest {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   private static final int MAX_CACHE_FILE_SIZE = 3;
@@ -43,47 +57,52 @@
   private File tempFolder;
   private SimpleCache cache;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
-    super.setUp();
-    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
 
-  @Override
+  @After
   public void tearDown() throws Exception {
     Util.recursiveDelete(tempFolder);
-    super.tearDown();
   }
 
+  @Test
   public void testMaxCacheFileSize() throws Exception {
     CacheDataSource cacheDataSource = createCacheDataSource(false, false);
     assertReadDataContentLength(cacheDataSource, false, false);
     for (String key : cache.getKeys()) {
       for (CacheSpan cacheSpan : cache.getCachedSpans(key)) {
-        assertTrue(cacheSpan.length <= MAX_CACHE_FILE_SIZE);
-        assertTrue(cacheSpan.file.length() <= MAX_CACHE_FILE_SIZE);
+        assertThat(cacheSpan.length <= MAX_CACHE_FILE_SIZE).isTrue();
+        assertThat(cacheSpan.file.length() <= MAX_CACHE_FILE_SIZE).isTrue();
       }
     }
   }
 
+  @Test
   public void testCacheAndRead() throws Exception {
     assertCacheAndRead(false, false);
   }
 
+  @Test
   public void testCacheAndReadUnboundedRequest() throws Exception {
     assertCacheAndRead(true, false);
   }
 
+  @Test
   public void testCacheAndReadUnknownLength() throws Exception {
     assertCacheAndRead(false, true);
   }
 
   // Disabled test as we don't support caching of definitely unknown length content
+  @Ignore
+  @Test
   public void disabledTestCacheAndReadUnboundedRequestUnknownLength() throws Exception {
     assertCacheAndRead(true, true);
   }
 
+  @Test
   public void testUnsatisfiableRange() throws Exception {
     // Bounded request but the content length is unknown. This forces all data to be cached but not
     // the length
@@ -104,11 +123,12 @@ public void testUnsatisfiableRange() throws Exception {
     }
   }
 
+  @Test
   public void testContentLengthEdgeCases() throws Exception {
     // Read partial at EOS but don't cross it so length is unknown
     CacheDataSource cacheDataSource = createCacheDataSource(false, true);
     assertReadData(cacheDataSource, true, TEST_DATA.length - 2, 2);
-    assertEquals(C.LENGTH_UNSET, cache.getContentLength(KEY_1));
+    assertThat(cache.getContentLength(KEY_1)).isEqualTo(LENGTH_UNSET);
 
     // Now do an unbounded request for whole data. This will cause a bounded request from upstream.
     // End of data from upstream shouldn't be mixed up with EOS and cause length set wrong.
@@ -116,21 +136,23 @@ public void testContentLengthEdgeCases() throws Exception {
     assertReadDataContentLength(cacheDataSource, true, true);
 
     // Now the length set correctly do an unbounded request with offset
-    assertEquals(2, cacheDataSource.open(new DataSpec(Uri.EMPTY, TEST_DATA.length - 2,
-        C.LENGTH_UNSET, KEY_1)));
+    assertThat(cacheDataSource.open(new DataSpec(EMPTY, TEST_DATA.length - 2,
+        LENGTH_UNSET, KEY_1))).isEqualTo(2);
 
     // An unbounded request with offset for not cached content
-    assertEquals(C.LENGTH_UNSET, cacheDataSource.open(new DataSpec(Uri.EMPTY, TEST_DATA.length - 2,
-        C.LENGTH_UNSET, KEY_2)));
+    assertThat(cacheDataSource.open(new DataSpec(EMPTY, TEST_DATA.length - 2,
+        LENGTH_UNSET, KEY_2))).isEqualTo(LENGTH_UNSET);
   }
 
+  @Test
   public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
     CacheDataSource cacheDataSource = createCacheDataSource(false, true,
         CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
     assertReadData(cacheDataSource, true, 0, C.LENGTH_UNSET);
-    MoreAsserts.assertEmpty(cache.getKeys());
+    assertThat(cache.getKeys()).isEmpty();
   }
 
+  @Test
   public void testReadOnlyCache() throws Exception {
     CacheDataSource cacheDataSource = createCacheDataSource(false, false, 0, null);
     assertReadDataContentLength(cacheDataSource, false, false);
@@ -157,9 +179,9 @@ private void assertReadDataContentLength(CacheDataSource cacheDataSource,
       boolean unboundedRequest, boolean unknownLength) throws IOException {
     int length = unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length;
     assertReadData(cacheDataSource, unknownLength, 0, length);
-    assertEquals("When the range specified, CacheDataSource doesn't reach EOS so shouldn't cache "
-        + "content length", !unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length,
-        cache.getContentLength(KEY_1));
+    assertWithMessage("When the range specified, CacheDataSource doesn't reach EOS so shouldn't "
+        + "cache content length").that(cache.getContentLength(KEY_1))
+        .isEqualTo(!unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length);
   }
 
   private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLength, int position,
@@ -168,8 +190,8 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
     if (length != C.LENGTH_UNSET) {
       testDataLength = Math.min(testDataLength, length);
     }
-    assertEquals(unknownLength ? length : testDataLength,
-        cacheDataSource.open(new DataSpec(Uri.EMPTY, position, length, KEY_1)));
+    assertThat(cacheDataSource.open(new DataSpec(EMPTY, position, length, KEY_1)))
+        .isEqualTo(unknownLength ? length : testDataLength);
 
     byte[] buffer = new byte[100];
     int totalBytesRead = 0;
@@ -180,9 +202,9 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
       }
       totalBytesRead += read;
     }
-    assertEquals(testDataLength, totalBytesRead);
-    MoreAsserts.assertEquals(Arrays.copyOfRange(TEST_DATA, position, position + testDataLength),
-        Arrays.copyOf(buffer, totalBytesRead));
+    assertThat(totalBytesRead).isEqualTo(testDataLength);
+    assertThat(copyOf(buffer, totalBytesRead))
+        .isEqualTo(copyOfRange(TEST_DATA, position, position + testDataLength));
 
     cacheDataSource.close();
   }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
similarity index 86%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
index 7e8088f3be..3b8276c731 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
@@ -15,10 +15,12 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.Arrays.copyOf;
+import static java.util.Arrays.copyOfRange;
+
 import android.content.Context;
 import android.net.Uri;
-import android.test.AndroidTestCase;
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -32,13 +34,19 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 /**
  * Additional tests for {@link CacheDataSource}.
  */
-public class CacheDataSourceTest2 extends AndroidTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class CacheDataSourceTest2 {
 
   private static final String EXO_CACHE_DIR = "exo";
   private static final int EXO_CACHE_MAX_FILESIZE = 128;
@@ -64,17 +72,20 @@
   private static final DataSpec START_OFF_BOUNDARY = new DataSpec(URI, OFFSET_OFF_BOUNDARY,
       DATA.length - OFFSET_OFF_BOUNDARY, KEY);
 
+  @Test
   public void testWithoutEncryption() throws IOException {
     testReads(false);
   }
 
+  @Test
   public void testWithEncryption() throws IOException {
     testReads(true);
   }
 
   private void testReads(boolean useEncryption) throws IOException {
     FakeDataSource upstreamSource = buildFakeUpstreamSource();
-    CacheDataSource source = buildCacheDataSource(getContext(), upstreamSource, useEncryption);
+    CacheDataSource source =
+        buildCacheDataSource(RuntimeEnvironment.application, upstreamSource, useEncryption);
     // First read, should arrive from upstream.
     testRead(END_ON_BOUNDARY, source);
     assertSingleOpen(upstreamSource, 0, OFFSET_ON_BOUNDARY);
@@ -110,8 +121,8 @@ private void testRead(DataSpec dataSpec, CacheDataSource source) throws IOExcept
       int maxBytesToRead = random.nextInt(scratch.length) + 1;
       bytesRead = source.read(scratch, 0, maxBytesToRead);
       if (bytesRead != C.RESULT_END_OF_INPUT) {
-        MoreAsserts.assertEquals(Arrays.copyOfRange(DATA, position, position + bytesRead),
-            Arrays.copyOf(scratch, bytesRead));
+        assertThat(copyOf(scratch, bytesRead))
+            .isEqualTo(copyOfRange(DATA, position, position + bytesRead));
         position += bytesRead;
       }
     }
@@ -124,10 +135,10 @@ private void testRead(DataSpec dataSpec, CacheDataSource source) throws IOExcept
    */
   private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end) {
     DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
-    assertEquals(1, openedDataSpecs.length);
-    assertEquals(start, openedDataSpecs[0].position);
-    assertEquals(start, openedDataSpecs[0].absoluteStreamPosition);
-    assertEquals(end - start, openedDataSpecs[0].length);
+    assertThat(openedDataSpecs).hasLength(1);
+    assertThat(openedDataSpecs[0].position).isEqualTo(start);
+    assertThat(openedDataSpecs[0].absoluteStreamPosition).isEqualTo(start);
+    assertThat(openedDataSpecs[0].length).isEqualTo(end - start);
   }
 
   /**
@@ -135,7 +146,7 @@ private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end)
    */
   private void assertNoOpen(FakeDataSource upstreamSource) {
     DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
-    assertEquals(0, openedDataSpecs.length);
+    assertThat(openedDataSpecs).hasLength(0);
   }
 
   private static FakeDataSource buildFakeUpstreamSource() {
@@ -177,7 +188,7 @@ private static void emptyCache(Cache cache) throws CacheException {
       }
     }
     // Sanity check that the cache really is empty now.
-    assertTrue(cache.getKeys().isEmpty());
+    assertThat(cache.getKeys().isEmpty()).isTrue();
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
similarity index 83%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
index df9975d43b..c8231ec4ac 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
@@ -15,11 +15,17 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
-import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
+import static android.net.Uri.EMPTY;
+import static android.net.Uri.parse;
+import static com.google.android.exoplayer2.C.LENGTH_UNSET;
+import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
+import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCachedData;
+import static com.google.android.exoplayer2.upstream.cache.CacheUtil.generateKey;
+import static com.google.android.exoplayer2.upstream.cache.CacheUtil.getKey;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 import android.net.Uri;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
@@ -29,13 +35,23 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.mockito.Answers;
 import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link CacheUtil}.
  */
-public class CacheUtilTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class CacheUtilTest {
 
   /**
    * Abstract fake Cache implementation used by the test. This class must be public so Mockito can
@@ -78,45 +94,46 @@ public long getContentLength(String key) {
   private File tempFolder;
   private SimpleCache cache;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
-    super.setUp();
-    TestUtil.setUpMockito(this);
+    MockitoAnnotations.initMocks(this);
     mockCache.init();
-    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
 
-  @Override
+  @After
   public void tearDown() throws Exception {
     Util.recursiveDelete(tempFolder);
-    super.tearDown();
   }
 
+  @Test
   public void testGenerateKey() throws Exception {
-    assertNotNull(CacheUtil.generateKey(Uri.EMPTY));
+    assertThat(generateKey(EMPTY)).isNotNull();
 
     Uri testUri = Uri.parse("test");
     String key = CacheUtil.generateKey(testUri);
-    assertNotNull(key);
+    assertThat(key).isNotNull();
 
     // Should generate the same key for the same input
-    assertEquals(key, CacheUtil.generateKey(testUri));
+    assertThat(generateKey(testUri)).isEqualTo(key);
 
     // Should generate different key for different input
-    assertFalse(key.equals(CacheUtil.generateKey(Uri.parse("test2"))));
+    assertThat(key.equals(generateKey(parse("test2")))).isFalse();
   }
 
+  @Test
   public void testGetKey() throws Exception {
     Uri testUri = Uri.parse("test");
     String key = "key";
     // If DataSpec.key is present, returns it
-    assertEquals(key, CacheUtil.getKey(new DataSpec(testUri, 0, C.LENGTH_UNSET, key)));
+    assertThat(getKey(new DataSpec(testUri, 0, LENGTH_UNSET, key))).isEqualTo(key);
     // If not generates a new one using DataSpec.uri
-    assertEquals(CacheUtil.generateKey(testUri),
-        CacheUtil.getKey(new DataSpec(testUri, 0, C.LENGTH_UNSET, null)));
+    assertThat(getKey(new DataSpec(testUri, 0, LENGTH_UNSET, null)))
+        .isEqualTo(generateKey(testUri));
   }
 
+  @Test
   public void testGetCachedNoData() throws Exception {
     CachingCounters counters = new CachingCounters();
     CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
@@ -124,6 +141,7 @@ public void testGetCachedNoData() throws Exception {
     assertCounters(counters, 0, 0, C.LENGTH_UNSET);
   }
 
+  @Test
   public void testGetCachedDataUnknownLength() throws Exception {
     // Mock there is 100 bytes cached at the beginning
     mockCache.spansAndGaps = new int[] {100};
@@ -133,6 +151,7 @@ public void testGetCachedDataUnknownLength() throws Exception {
     assertCounters(counters, 100, 0, C.LENGTH_UNSET);
   }
 
+  @Test
   public void testGetCachedNoDataKnownLength() throws Exception {
     mockCache.contentLength = 1000;
     CachingCounters counters = new CachingCounters();
@@ -141,6 +160,7 @@ public void testGetCachedNoDataKnownLength() throws Exception {
     assertCounters(counters, 0, 0, 1000);
   }
 
+  @Test
   public void testGetCached() throws Exception {
     mockCache.contentLength = 1000;
     mockCache.spansAndGaps = new int[] {100, 100, 200};
@@ -150,6 +170,7 @@ public void testGetCached() throws Exception {
     assertCounters(counters, 300, 0, 1000);
   }
 
+  @Test
   public void testCache() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
@@ -161,6 +182,7 @@ public void testCache() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testCacheSetOffsetAndLength() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
@@ -178,6 +200,7 @@ public void testCacheSetOffsetAndLength() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testCacheUnknownLength() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
         .setSimulateUnknownLength(true)
@@ -192,6 +215,7 @@ public void testCacheUnknownLength() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testCacheUnknownLengthPartialCaching() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
         .setSimulateUnknownLength(true)
@@ -211,6 +235,7 @@ public void testCacheUnknownLengthPartialCaching() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testCacheLengthExceedsActualDataLength() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
@@ -224,6 +249,7 @@ public void testCacheLengthExceedsActualDataLength() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testCacheThrowEOFException() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
@@ -241,6 +267,7 @@ public void testCacheThrowEOFException() throws Exception {
     }
   }
 
+  @Test
   public void testCachePolling() throws Exception {
     final CachingCounters counters = new CachingCounters();
     FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
@@ -267,6 +294,7 @@ public void run() {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testRemove() throws Exception {
     FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
     FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
@@ -283,9 +311,9 @@ public void testRemove() throws Exception {
 
   private static void assertCounters(CachingCounters counters, int alreadyCachedBytes,
       int newlyCachedBytes, int contentLength) {
-    assertEquals(alreadyCachedBytes, counters.alreadyCachedBytes);
-    assertEquals(newlyCachedBytes, counters.newlyCachedBytes);
-    assertEquals(contentLength, counters.contentLength);
+    assertThat(counters.alreadyCachedBytes).isEqualTo(alreadyCachedBytes);
+    assertThat(counters.newlyCachedBytes).isEqualTo(newlyCachedBytes);
+    assertThat(counters.contentLength).isEqualTo(contentLength);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
new file mode 100644
index 0000000000..6f7f567ae7
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link LeastRecentlyUsedCacheEvictor}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class LeastRecentlyUsedCacheEvictorTest {
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testContentBiggerThanMaxSizeDoesNotThrowException() throws Exception {
+    int maxBytes = 100;
+    LeastRecentlyUsedCacheEvictor evictor = new LeastRecentlyUsedCacheEvictor(maxBytes);
+    evictor.onCacheInitialized();
+    evictor.onStartFile(Mockito.mock(Cache.class), "key", 0, maxBytes + 1);
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
similarity index 59%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index 1a6beeb6ba..d5894895b1 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -15,9 +15,13 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import android.test.InstrumentationTestCase;
-import android.test.MoreAsserts;
+import static com.google.android.exoplayer2.C.LENGTH_UNSET;
+import static com.google.android.exoplayer2.util.Util.toByteArray;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.doAnswer;
+
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileInputStream;
@@ -26,60 +30,77 @@
 import java.util.NavigableSet;
 import java.util.Random;
 import java.util.Set;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link SimpleCache}.
  */
-public class SimpleCacheTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class SimpleCacheTest {
 
   private static final String KEY_1 = "key1";
 
   private File cacheDir;
 
-  @Override
-  protected void setUp() throws Exception {
-    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    cacheDir = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() throws Exception {
     Util.recursiveDelete(cacheDir);
   }
 
+  @Test
   public void testCommittingOneFile() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
     CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    assertFalse(cacheSpan1.isCached);
-    assertTrue(cacheSpan1.isOpenEnded());
+    assertThat(cacheSpan1.isCached).isFalse();
+    assertThat(cacheSpan1.isOpenEnded()).isTrue();
 
-    assertNull(simpleCache.startReadWriteNonBlocking(KEY_1, 0));
+    assertThat(simpleCache.startReadWriteNonBlocking(KEY_1, 0)).isNull();
 
-    assertEquals(0, simpleCache.getKeys().size());
+    assertThat(simpleCache.getKeys()).isEmpty();
     NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertTrue(cachedSpans == null || cachedSpans.size() == 0);
-    assertEquals(0, simpleCache.getCacheSpace());
-    assertEquals(0, cacheDir.listFiles().length);
+    assertThat(cachedSpans == null || cachedSpans.isEmpty()).isTrue();
+    assertThat(simpleCache.getCacheSpace()).isEqualTo(0);
+    assertThat(cacheDir.listFiles()).hasLength(0);
 
     addCache(simpleCache, KEY_1, 0, 15);
 
     Set<String> cachedKeys = simpleCache.getKeys();
-    assertEquals(1, cachedKeys.size());
-    assertTrue(cachedKeys.contains(KEY_1));
+    assertThat(cachedKeys).hasSize(1);
+    assertThat(cachedKeys.contains(KEY_1)).isTrue();
     cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertEquals(1, cachedSpans.size());
-    assertTrue(cachedSpans.contains(cacheSpan1));
-    assertEquals(15, simpleCache.getCacheSpace());
+    assertThat(cachedSpans).hasSize(1);
+    assertThat(cachedSpans.contains(cacheSpan1)).isTrue();
+    assertThat(simpleCache.getCacheSpace()).isEqualTo(15);
 
     simpleCache.releaseHoleSpan(cacheSpan1);
 
     CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
-    assertTrue(cacheSpan2.isCached);
-    assertFalse(cacheSpan2.isOpenEnded());
-    assertEquals(15, cacheSpan2.length);
+    assertThat(cacheSpan2.isCached).isTrue();
+    assertThat(cacheSpan2.isOpenEnded()).isFalse();
+    assertThat(cacheSpan2.length).isEqualTo(15);
     assertCachedDataReadCorrect(cacheSpan2);
   }
 
+  @Test
   public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
@@ -90,19 +111,20 @@ public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
     simpleCache.releaseHoleSpan(cacheSpan1);
   }
 
+  @Test
   public void testSetGetLength() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
-    assertEquals(C.LENGTH_UNSET, simpleCache.getContentLength(KEY_1));
+    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(LENGTH_UNSET);
     simpleCache.setContentLength(KEY_1, 15);
-    assertEquals(15, simpleCache.getContentLength(KEY_1));
+    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(15);
 
     simpleCache.startReadWrite(KEY_1, 0);
 
     addCache(simpleCache, KEY_1, 0, 15);
 
     simpleCache.setContentLength(KEY_1, 150);
-    assertEquals(150, simpleCache.getContentLength(KEY_1));
+    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(150);
 
     addCache(simpleCache, KEY_1, 140, 10);
 
@@ -110,19 +132,20 @@ public void testSetGetLength() throws Exception {
     SimpleCache simpleCache2 = getSimpleCache();
     Set<String> keys = simpleCache.getKeys();
     Set<String> keys2 = simpleCache2.getKeys();
-    assertEquals(keys, keys2);
+    assertThat(keys2).isEqualTo(keys);
     for (String key : keys) {
-      assertEquals(simpleCache.getContentLength(key), simpleCache2.getContentLength(key));
-      assertEquals(simpleCache.getCachedSpans(key), simpleCache2.getCachedSpans(key));
+      assertThat(simpleCache2.getContentLength(key)).isEqualTo(simpleCache.getContentLength(key));
+      assertThat(simpleCache2.getCachedSpans(key)).isEqualTo(simpleCache.getCachedSpans(key));
     }
 
     // Removing the last span shouldn't cause the length be change next time cache loaded
     SimpleCacheSpan lastSpan = simpleCache2.startReadWrite(KEY_1, 145);
     simpleCache2.removeSpan(lastSpan);
     simpleCache2 = getSimpleCache();
-    assertEquals(150, simpleCache2.getContentLength(KEY_1));
+    assertThat(simpleCache2.getContentLength(KEY_1)).isEqualTo(150);
   }
 
+  @Test
   public void testReloadCache() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
@@ -139,6 +162,7 @@ public void testReloadCache() throws Exception {
     assertCachedDataReadCorrect(cacheSpan2);
   }
 
+  @Test
   public void testEncryptedIndex() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
     SimpleCache simpleCache = getEncryptedSimpleCache(key);
@@ -156,6 +180,7 @@ public void testEncryptedIndex() throws Exception {
     assertCachedDataReadCorrect(cacheSpan2);
   }
 
+  @Test
   public void testEncryptedIndexWrongKey() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
     SimpleCache simpleCache = getEncryptedSimpleCache(key);
@@ -170,10 +195,11 @@ public void testEncryptedIndexWrongKey() throws Exception {
     simpleCache = getEncryptedSimpleCache(key2);
 
     // Cache should be cleared
-    assertEquals(0, simpleCache.getKeys().size());
-    assertEquals(0, cacheDir.listFiles().length);
+    assertThat(simpleCache.getKeys()).isEmpty();
+    assertThat(cacheDir.listFiles()).hasLength(0);
   }
 
+  @Test
   public void testEncryptedIndexLostKey() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
     SimpleCache simpleCache = getEncryptedSimpleCache(key);
@@ -187,45 +213,81 @@ public void testEncryptedIndexLostKey() throws Exception {
     simpleCache = getSimpleCache();
 
     // Cache should be cleared
-    assertEquals(0, simpleCache.getKeys().size());
-    assertEquals(0, cacheDir.listFiles().length);
+    assertThat(simpleCache.getKeys()).isEmpty();
+    assertThat(cacheDir.listFiles()).hasLength(0);
   }
 
-
+  @Test
   public void testGetCachedBytes() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
     CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
 
     // No cached bytes, returns -'length'
-    assertEquals(-100, simpleCache.getCachedBytes(KEY_1, 0, 100));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(-100);
 
     // Position value doesn't affect the return value
-    assertEquals(-100, simpleCache.getCachedBytes(KEY_1, 20, 100));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 20, 100)).isEqualTo(-100);
 
     addCache(simpleCache, KEY_1, 0, 15);
 
     // Returns the length of a single span
-    assertEquals(15, simpleCache.getCachedBytes(KEY_1, 0, 100));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(15);
 
     // Value is capped by the 'length'
-    assertEquals(10, simpleCache.getCachedBytes(KEY_1, 0, 10));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 10)).isEqualTo(10);
 
     addCache(simpleCache, KEY_1, 15, 35);
 
     // Returns the length of two adjacent spans
-    assertEquals(50, simpleCache.getCachedBytes(KEY_1, 0, 100));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(50);
 
     addCache(simpleCache, KEY_1, 60, 10);
 
     // Not adjacent span doesn't affect return value
-    assertEquals(50, simpleCache.getCachedBytes(KEY_1, 0, 100));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(50);
 
     // Returns length of hole up to the next cached span
-    assertEquals(-5, simpleCache.getCachedBytes(KEY_1, 55, 100));
+    assertThat(simpleCache.getCachedBytes(KEY_1, 55, 100)).isEqualTo(-5);
 
     simpleCache.releaseHoleSpan(cacheSpan);
   }
 
+  /* Tests https://github.com/google/ExoPlayer/issues/3260 case. */
+  @Test
+  public void testExceptionDuringEvictionByLeastRecentlyUsedCacheEvictorNotHang() throws Exception {
+    CachedContentIndex index = Mockito.spy(new CachedContentIndex(cacheDir));
+    SimpleCache simpleCache =
+        new SimpleCache(cacheDir, new LeastRecentlyUsedCacheEvictor(20), index);
+
+    // Add some content.
+    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+
+    // Make index.store() throw exception from now on.
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        throw new Cache.CacheException("SimpleCacheTest");
+      }
+    }).when(index).store();
+
+    // Adding more content will make LeastRecentlyUsedCacheEvictor evict previous content.
+    try {
+      addCache(simpleCache, KEY_1, 15, 15);
+      Assert.fail("Exception was expected");
+    } catch (CacheException e) {
+      // do nothing.
+    }
+
+    simpleCache.releaseHoleSpan(cacheSpan);
+
+    // Although store() has failed, it should remove the first span and add the new one.
+    NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
+    assertThat(cachedSpans).isNotNull();
+    assertThat(cachedSpans).hasSize(1);
+    assertThat(cachedSpans.pollFirst().position).isEqualTo(15);
+  }
+
   private SimpleCache getSimpleCache() {
     return new SimpleCache(cacheDir, new NoOpCacheEvictor());
   }
@@ -247,11 +309,11 @@ private static void addCache(SimpleCache simpleCache, String key, int position,
   }
 
   private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOException {
-    assertTrue(cacheSpan.isCached);
+    assertThat(cacheSpan.isCached).isTrue();
     byte[] expected = generateData(cacheSpan.key, (int) cacheSpan.position, (int) cacheSpan.length);
     FileInputStream inputStream = new FileInputStream(cacheSpan.file);
     try {
-      MoreAsserts.assertEquals(expected, Util.toByteArray(inputStream));
+      assertThat(toByteArray(inputStream)).isEqualTo(expected);
     } finally {
       inputStream.close();
     }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
similarity index 77%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
index b4e7e6e7f6..833a7e10c1 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
@@ -15,16 +15,25 @@
  */
 package com.google.android.exoplayer2.upstream.crypto;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Random;
 import javax.crypto.Cipher;
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link AesFlushingCipher}.
  */
-public class AesFlushingCipherTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class AesFlushingCipherTest {
 
   private static final int DATA_LENGTH = 65536;
   private static final byte[] KEY = Util.getUtf8Bytes("testKey:12345678");
@@ -35,26 +44,26 @@
   private AesFlushingCipher encryptCipher;
   private AesFlushingCipher decryptCipher;
 
-  @Override
-  protected void setUp() {
+  @Before
+  public void setUp() {
     encryptCipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, KEY, NONCE, START_OFFSET);
     decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, START_OFFSET);
   }
 
-  @Override
-  protected void tearDown() {
+  @After
+  public void tearDown() {
     encryptCipher = null;
     decryptCipher = null;
   }
 
-  private long getMaxUnchangedBytesAllowedPostEncryption(long length) {
+  private static long getMaxUnchangedBytesAllowedPostEncryption(long length) {
     // Assuming that not more than 10% of the resultant bytes should be identical.
     // The value of 10% is arbitrary, ciphers standards do not name a value.
     return length / 10;
   }
 
   // Count the number of bytes that do not match.
-  private int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
+  private static int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
     int count = 0;
     for (int i = startOffset; i < data1.length; i++) {
       if (data1[i] != data2[i]) {
@@ -65,25 +74,28 @@ private int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
   }
 
   // Count the number of bytes that do not match.
-  private int getDifferingByteCount(byte[] data1, byte[] data2) {
+  private static int getDifferingByteCount(byte[] data1, byte[] data2) {
     return getDifferingByteCount(data1, data2, 0);
   }
 
-  // Test a single encrypt and decrypt call
+  // Test a single encrypt and decrypt call.
+  @Test
   public void testSingle() {
     byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
     byte[] data = reference.clone();
 
     encryptCipher.updateInPlace(data, 0, data.length);
     int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
+        .isTrue();
 
     decryptCipher.updateInPlace(data, 0, data.length);
     int differingByteCount = getDifferingByteCount(reference, data);
-    assertEquals(0, differingByteCount);
+    assertThat(differingByteCount).isEqualTo(0);
   }
 
-  // Test several encrypt and decrypt calls, each aligned on a 16 byte block size
+  // Test several encrypt and decrypt calls, each aligned on a 16 byte block size.
+  @Test
   public void testAligned() {
     byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
     byte[] data = reference.clone();
@@ -93,28 +105,30 @@ public void testAligned() {
     while (offset < data.length) {
       int bytes = (1 + random.nextInt(50)) * 16;
       bytes = Math.min(bytes, data.length - offset);
-      assertEquals(0, bytes % 16);
+      assertThat(bytes % 16).isEqualTo(0);
       encryptCipher.updateInPlace(data, offset, bytes);
       offset += bytes;
     }
 
     int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
+        .isTrue();
 
     offset = 0;
     while (offset < data.length) {
       int bytes = (1 + random.nextInt(50)) * 16;
       bytes = Math.min(bytes, data.length - offset);
-      assertEquals(0, bytes % 16);
+      assertThat(bytes % 16).isEqualTo(0);
       decryptCipher.updateInPlace(data, offset, bytes);
       offset += bytes;
     }
 
     int differingByteCount = getDifferingByteCount(reference, data);
-    assertEquals(0, differingByteCount);
+    assertThat(differingByteCount).isEqualTo(0);
   }
 
-  // Test several encrypt and decrypt calls, not aligned on block boundary
+  // Test several encrypt and decrypt calls, not aligned on block boundary.
+  @Test
   public void testUnAligned() {
     byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
     byte[] data = reference.clone();
@@ -130,7 +144,8 @@ public void testUnAligned() {
     }
 
     int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
+        .isTrue();
 
     offset = 0;
     while (offset < data.length) {
@@ -141,10 +156,11 @@ public void testUnAligned() {
     }
 
     int differingByteCount = getDifferingByteCount(reference, data);
-    assertEquals(0, differingByteCount);
+    assertThat(differingByteCount).isEqualTo(0);
   }
 
-  // Test decryption starting from the middle of an encrypted block
+  // Test decryption starting from the middle of an encrypted block.
+  @Test
   public void testMidJoin() {
     byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
     byte[] data = reference.clone();
@@ -161,7 +177,8 @@ public void testMidJoin() {
 
     // Verify
     int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
+        .isTrue();
 
     // Setup decryption from random location
     offset = random.nextInt(4096);
@@ -180,7 +197,7 @@ public void testMidJoin() {
 
     // Verify
     int differingByteCount = getDifferingByteCount(reference, data, originalOffset);
-    assertEquals(0, differingByteCount);
+    assertThat(differingByteCount).isEqualTo(0);
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
similarity index 69%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
index 6c5d7c76f7..dcf3d31eb3 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
@@ -13,42 +13,53 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.android.exoplayer2.util;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link AtomicFile}.
  */
-public class AtomicFileTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class AtomicFileTest {
 
   private File tempFolder;
   private File file;
   private AtomicFile atomicFile;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
-    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     file = new File(tempFolder, "atomicFile");
     atomicFile = new AtomicFile(file);
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() throws Exception {
     Util.recursiveDelete(tempFolder);
   }
 
+  @Test
   public void testDelete() throws Exception {
-    assertTrue(file.createNewFile());
+    assertThat(file.createNewFile()).isTrue();
     atomicFile.delete();
-    assertFalse(file.exists());
+    assertThat(file.exists()).isFalse();
   }
 
+  @Test
   public void testWriteRead() throws Exception {
     OutputStream output = atomicFile.startWrite();
     output.write(5);
@@ -78,8 +89,8 @@ public void testWriteRead() throws Exception {
 
   private void assertRead() throws IOException {
     InputStream input = atomicFile.openRead();
-    assertEquals(5, input.read());
-    assertEquals(-1, input.read());
+    assertThat(input.read()).isEqualTo(5);
+    assertThat(input.read()).isEqualTo(-1);
     input.close();
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
new file mode 100644
index 0000000000..13b126090c
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static android.graphics.Color.BLACK;
+import static android.graphics.Color.RED;
+import static android.graphics.Color.WHITE;
+import static android.graphics.Color.argb;
+import static android.graphics.Color.parseColor;
+import static com.google.android.exoplayer2.util.ColorParser.parseTtmlColor;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.graphics.Color;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit test for <code>ColorParser</code>.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ColorParserTest {
+
+  // Negative tests.
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testParseUnknownColor() {
+    ColorParser.parseTtmlColor("colorOfAnElectron");
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testParseNull() {
+    ColorParser.parseTtmlColor(null);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testParseEmpty() {
+    ColorParser.parseTtmlColor("");
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testRgbColorParsingRgbValuesNegative() {
+    ColorParser.parseTtmlColor("rgb(-4, 55, 209)");
+  }
+
+  // Positive tests.
+
+  @Test
+  public void testHexCodeParsing() {
+    assertThat(parseTtmlColor("#FFFFFF")).isEqualTo(WHITE);
+    assertThat(parseTtmlColor("#FFFFFFFF")).isEqualTo(WHITE);
+    assertThat(parseTtmlColor("#123456")).isEqualTo(parseColor("#FF123456"));
+    // Hex colors in ColorParser are RGBA, where-as {@link Color#parseColor} takes ARGB.
+    assertThat(parseTtmlColor("#FFFFFF00")).isEqualTo(parseColor("#00FFFFFF"));
+    assertThat(parseTtmlColor("#12345678")).isEqualTo(parseColor("#78123456"));
+  }
+
+  @Test
+  public void testRgbColorParsing() {
+    assertThat(parseTtmlColor("rgb(255,255,255)")).isEqualTo(WHITE);
+    // Spaces are ignored.
+    assertThat(parseTtmlColor("   rgb (      255, 255, 255)")).isEqualTo(WHITE);
+  }
+
+  @Test
+  public void testRgbColorParsingRgbValuesOutOfBounds() {
+    int outOfBounds = ColorParser.parseTtmlColor("rgb(999, 999, 999)");
+    int color = Color.rgb(999, 999, 999);
+    // Behave like the framework does.
+    assertThat(outOfBounds).isEqualTo(color);
+  }
+
+  @Test
+  public void testRgbaColorParsing() {
+    assertThat(parseTtmlColor("rgba(255,255,255,255)")).isEqualTo(WHITE);
+    assertThat(parseTtmlColor("rgba(255,255,255,255)"))
+        .isEqualTo(argb(255, 255, 255, 255));
+    assertThat(parseTtmlColor("rgba(0, 0, 0, 255)")).isEqualTo(BLACK);
+    assertThat(parseTtmlColor("rgba(0, 0, 255, 0)"))
+        .isEqualTo(argb(0, 0, 0, 255));
+    assertThat(parseTtmlColor("rgba(255, 0, 0, 255)")).isEqualTo(RED);
+    assertThat(parseTtmlColor("rgba(255, 0, 255, 0)"))
+        .isEqualTo(argb(0, 255, 0, 255));
+    assertThat(parseTtmlColor("rgba(255, 0, 0, 205)"))
+        .isEqualTo(argb(205, 255, 0, 0));
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
similarity index 79%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
index 286013e83a..ee77664cce 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
@@ -16,15 +16,21 @@
 package com.google.android.exoplayer2.util;
 
 import static com.google.android.exoplayer2.testutil.TestUtil.createByteArray;
+import static com.google.common.truth.Truth.assertThat;
 
 import java.nio.ByteBuffer;
 import java.util.Arrays;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link NalUnitUtil}.
  */
-public class NalUnitUtilTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class NalUnitUtilTest {
 
   private static final int TEST_PARTIAL_NAL_POSITION = 4;
   private static final int TEST_NAL_POSITION = 10;
@@ -33,26 +39,28 @@
       0x00, 0x0F, 0x47, 0x8B, 0x16, 0xCB);
   private static final int SPS_TEST_DATA_OFFSET = 3;
 
+  @Test
   public void testFindNalUnit() {
     byte[] data = buildTestData();
 
     // Should find NAL unit.
     int result = NalUnitUtil.findNalUnit(data, 0, data.length, null);
-    assertEquals(TEST_NAL_POSITION, result);
+    assertThat(result).isEqualTo(TEST_NAL_POSITION);
     // Should find NAL unit whose prefix ends one byte before the limit.
     result = NalUnitUtil.findNalUnit(data, 0, TEST_NAL_POSITION + 4, null);
-    assertEquals(TEST_NAL_POSITION, result);
+    assertThat(result).isEqualTo(TEST_NAL_POSITION);
     // Shouldn't find NAL unit whose prefix ends at the limit (since the limit is exclusive).
     result = NalUnitUtil.findNalUnit(data, 0, TEST_NAL_POSITION + 3, null);
-    assertEquals(TEST_NAL_POSITION + 3, result);
+    assertThat(result).isEqualTo(TEST_NAL_POSITION + 3);
     // Should find NAL unit whose prefix starts at the offset.
     result = NalUnitUtil.findNalUnit(data, TEST_NAL_POSITION, data.length, null);
-    assertEquals(TEST_NAL_POSITION, result);
+    assertThat(result).isEqualTo(TEST_NAL_POSITION);
     // Shouldn't find NAL unit whose prefix starts one byte past the offset.
     result = NalUnitUtil.findNalUnit(data, TEST_NAL_POSITION + 1, data.length, null);
-    assertEquals(data.length, result);
+    assertThat(result).isEqualTo(data.length);
   }
 
+  @Test
   public void testFindNalUnitWithPrefix() {
     byte[] data = buildTestData();
 
@@ -61,9 +69,9 @@ public void testFindNalUnitWithPrefix() {
     byte[] data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 1);
     byte[] data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, data.length);
     int result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
-    assertEquals(data1.length, result);
+    assertThat(result).isEqualTo(data1.length);
     result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
-    assertEquals(-1, result);
+    assertThat(result).isEqualTo(-1);
     assertPrefixFlagsCleared(prefixFlags);
 
     // First three bytes of NAL unit in data1, rest in data2.
@@ -71,9 +79,9 @@ public void testFindNalUnitWithPrefix() {
     data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 3);
     data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 3, data.length);
     result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
-    assertEquals(data1.length, result);
+    assertThat(result).isEqualTo(data1.length);
     result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
-    assertEquals(-3, result);
+    assertThat(result).isEqualTo(-3);
     assertPrefixFlagsCleared(prefixFlags);
 
     // First byte of NAL unit in data1, second byte in data2, rest in data3.
@@ -82,11 +90,11 @@ public void testFindNalUnitWithPrefix() {
     data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, TEST_NAL_POSITION + 2);
     byte[] data3 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, data.length);
     result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
-    assertEquals(data1.length, result);
+    assertThat(result).isEqualTo(data1.length);
     result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
-    assertEquals(data2.length, result);
+    assertThat(result).isEqualTo(data2.length);
     result = NalUnitUtil.findNalUnit(data3, 0, data3.length, prefixFlags);
-    assertEquals(-2, result);
+    assertThat(result).isEqualTo(-2);
     assertPrefixFlagsCleared(prefixFlags);
 
     // NAL unit split with one byte in four arrays.
@@ -96,13 +104,13 @@ public void testFindNalUnitWithPrefix() {
     data3 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, TEST_NAL_POSITION + 3);
     byte[] data4 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, data.length);
     result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
-    assertEquals(data1.length, result);
+    assertThat(result).isEqualTo(data1.length);
     result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
-    assertEquals(data2.length, result);
+    assertThat(result).isEqualTo(data2.length);
     result = NalUnitUtil.findNalUnit(data3, 0, data3.length, prefixFlags);
-    assertEquals(data3.length, result);
+    assertThat(result).isEqualTo(data3.length);
     result = NalUnitUtil.findNalUnit(data4, 0, data4.length, prefixFlags);
-    assertEquals(-3, result);
+    assertThat(result).isEqualTo(-3);
     assertPrefixFlagsCleared(prefixFlags);
 
     // NAL unit entirely in data2. data1 ends with partial prefix.
@@ -110,27 +118,29 @@ public void testFindNalUnitWithPrefix() {
     data1 = Arrays.copyOfRange(data, 0, TEST_PARTIAL_NAL_POSITION + 2);
     data2 = Arrays.copyOfRange(data, TEST_PARTIAL_NAL_POSITION + 2, data.length);
     result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
-    assertEquals(data1.length, result);
+    assertThat(result).isEqualTo(data1.length);
     result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
-    assertEquals(4, result);
+    assertThat(result).isEqualTo(4);
     assertPrefixFlagsCleared(prefixFlags);
   }
 
+  @Test
   public void testParseSpsNalUnit() {
     NalUnitUtil.SpsData data = NalUnitUtil.parseSpsNalUnit(SPS_TEST_DATA, SPS_TEST_DATA_OFFSET,
         SPS_TEST_DATA.length);
-    assertEquals(640, data.width);
-    assertEquals(360, data.height);
-    assertFalse(data.deltaPicOrderAlwaysZeroFlag);
-    assertTrue(data.frameMbsOnlyFlag);
-    assertEquals(4, data.frameNumLength);
-    assertEquals(6, data.picOrderCntLsbLength);
-    assertEquals(0, data.seqParameterSetId);
-    assertEquals(1.0f, data.pixelWidthAspectRatio);
-    assertEquals(0, data.picOrderCountType);
-    assertFalse(data.separateColorPlaneFlag);
+    assertThat(data.width).isEqualTo(640);
+    assertThat(data.height).isEqualTo(360);
+    assertThat(data.deltaPicOrderAlwaysZeroFlag).isFalse();
+    assertThat(data.frameMbsOnlyFlag).isTrue();
+    assertThat(data.frameNumLength).isEqualTo(4);
+    assertThat(data.picOrderCntLsbLength).isEqualTo(6);
+    assertThat(data.seqParameterSetId).isEqualTo(0);
+    assertThat(data.pixelWidthAspectRatio).isEqualTo(1.0f);
+    assertThat(data.picOrderCountType).isEqualTo(0);
+    assertThat(data.separateColorPlaneFlag).isFalse();
   }
 
+  @Test
   public void testUnescapeDoesNotModifyBuffersWithoutStartCodes() {
     assertUnescapeDoesNotModify("");
     assertUnescapeDoesNotModify("0000");
@@ -138,11 +148,13 @@ public void testUnescapeDoesNotModifyBuffersWithoutStartCodes() {
     assertUnescapeDoesNotModify("000004");
   }
 
+  @Test
   public void testUnescapeModifiesBuffersWithStartCodes() {
     assertUnescapeMatchesExpected("00000301", "000001");
     assertUnescapeMatchesExpected("0000030200000300", "000002000000");
   }
 
+  @Test
   public void testDiscardToSps() {
     assertDiscardToSpsMatchesExpected("", "");
     assertDiscardToSpsMatchesExpected("00", "");
@@ -176,7 +188,7 @@ public void testDiscardToSps() {
   }
 
   private static void assertPrefixFlagsCleared(boolean[] flags) {
-    assertEquals(false, flags[0] || flags[1] || flags[2]);
+    assertThat(flags[0] || flags[1] || flags[2]).isEqualTo(false);
   }
 
   private static void assertUnescapeDoesNotModify(String input) {
@@ -187,10 +199,10 @@ private static void assertUnescapeMatchesExpected(String input, String expectedO
     byte[] bitstream = Util.getBytesFromHexString(input);
     byte[] expectedOutputBitstream = Util.getBytesFromHexString(expectedOutput);
     int count = NalUnitUtil.unescapeStream(bitstream, bitstream.length);
-    assertEquals(expectedOutputBitstream.length, count);
+    assertThat(count).isEqualTo(expectedOutputBitstream.length);
     byte[] outputBitstream = new byte[count];
     System.arraycopy(bitstream, 0, outputBitstream, 0, count);
-    assertTrue(Arrays.equals(expectedOutputBitstream, outputBitstream));
+    assertThat(outputBitstream).isEqualTo(expectedOutputBitstream);
   }
 
   private static void assertDiscardToSpsMatchesExpected(String input, String expectedOutput) {
@@ -199,8 +211,7 @@ private static void assertDiscardToSpsMatchesExpected(String input, String expec
     ByteBuffer buffer = ByteBuffer.wrap(bitstream);
     buffer.position(buffer.limit());
     NalUnitUtil.discardToSps(buffer);
-    assertTrue(Arrays.equals(expectedOutputBitstream,
-        Arrays.copyOf(buffer.array(), buffer.position())));
+    assertThat(Arrays.copyOf(buffer.array(), buffer.position())).isEqualTo(expectedOutputBitstream);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
new file mode 100644
index 0000000000..0d864f407f
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Tests for {@link ParsableBitArray}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ParsableBitArrayTest {
+
+  private static final byte[] TEST_DATA = new byte[] {0x3C, (byte) 0xD2, (byte) 0x5F, (byte) 0x01,
+      (byte) 0xFF, (byte) 0x14, (byte) 0x60, (byte) 0x99};
+
+  private ParsableBitArray testArray;
+
+  @Before
+  public void setUp() {
+    testArray = new ParsableBitArray(TEST_DATA);
+  }
+
+  @Test
+  public void testReadAllBytes() {
+    byte[] bytesRead = new byte[TEST_DATA.length];
+    testArray.readBytes(bytesRead, 0, TEST_DATA.length);
+    assertThat(bytesRead).isEqualTo(TEST_DATA);
+    assertThat(testArray.getPosition()).isEqualTo(TEST_DATA.length * 8);
+    assertThat(testArray.getBytePosition()).isEqualTo(TEST_DATA.length);
+  }
+
+  @Test
+  public void testReadBit() {
+    assertReadBitsToEnd(0);
+  }
+
+  @Test
+  public void testReadBits() {
+    assertThat(testArray.readBits(5)).isEqualTo(getTestDataBits(0, 5));
+    assertThat(testArray.readBits(0)).isEqualTo(getTestDataBits(5, 0));
+    assertThat(testArray.readBits(3)).isEqualTo(getTestDataBits(5, 3));
+    assertThat(testArray.readBits(16)).isEqualTo(getTestDataBits(8, 16));
+    assertThat(testArray.readBits(3)).isEqualTo(getTestDataBits(24, 3));
+    assertThat(testArray.readBits(18)).isEqualTo(getTestDataBits(27, 18));
+    assertThat(testArray.readBits(5)).isEqualTo(getTestDataBits(45, 5));
+    assertThat(testArray.readBits(14)).isEqualTo(getTestDataBits(50, 14));
+  }
+
+  @Test
+  public void testReadBitsToByteArray() {
+    byte[] result = new byte[TEST_DATA.length];
+    // Test read within byte boundaries.
+    testArray.readBits(result, 0, 6);
+    assertThat(result[0]).isEqualTo((byte) (TEST_DATA[0] & 0xFC));
+    // Test read across byte boundaries.
+    testArray.readBits(result, 0, 8);
+    assertThat(result[0]).isEqualTo(
+        (byte) (((TEST_DATA[0] & 0x03) << 6) | ((TEST_DATA[1] & 0xFC) >> 2)));
+    // Test reading across multiple bytes.
+    testArray.readBits(result, 1, 50);
+    for (int i = 1; i < 7; i++) {
+      assertThat(result[i])
+          .isEqualTo((byte) (((TEST_DATA[i] & 0x03) << 6) | ((TEST_DATA[i + 1] & 0xFC) >> 2)));
+    }
+    assertThat(result[7]).isEqualTo((byte) ((TEST_DATA[7] & 0x03) << 6));
+    assertThat(testArray.bitsLeft()).isEqualTo(0);
+    // Test read last buffer byte across input data bytes.
+    testArray.setPosition(31);
+    result[3] = 0;
+    testArray.readBits(result, 3, 3);
+    assertThat(result[3]).isEqualTo((byte) 0xE0);
+    // Test read bits in the middle of a input data byte.
+    result[0] = 0;
+    assertThat(testArray.getPosition()).isEqualTo(34);
+    testArray.readBits(result, 0, 3);
+    assertThat(result[0]).isEqualTo((byte) 0xE0);
+    // Test read 0 bits.
+    testArray.setPosition(32);
+    result[1] = 0;
+    testArray.readBits(result, 1, 0);
+    assertThat(result[1]).isEqualTo((byte) 0);
+    // Test reading a number of bits divisible by 8.
+    testArray.setPosition(0);
+    testArray.readBits(result, 0, 16);
+    assertThat(result[0]).isEqualTo(TEST_DATA[0]);
+    assertThat(result[1]).isEqualTo(TEST_DATA[1]);
+    // Test least significant bits are unmodified.
+    result[1] = (byte) 0xFF;
+    testArray.readBits(result, 0, 9);
+    assertThat(result[0]).isEqualTo((byte) 0x5F);
+    assertThat(result[1]).isEqualTo((byte) 0x7F);
+  }
+
+  @Test
+  public void testRead32BitsByteAligned() {
+    assertThat(testArray.readBits(32)).isEqualTo(getTestDataBits(0, 32));
+    assertThat(testArray.readBits(32)).isEqualTo(getTestDataBits(32, 32));
+  }
+
+  @Test
+  public void testRead32BitsNonByteAligned() {
+    assertThat(testArray.readBits(5)).isEqualTo(getTestDataBits(0, 5));
+    assertThat(testArray.readBits(32)).isEqualTo(getTestDataBits(5, 32));
+  }
+
+  @Test
+  public void testSkipBytes() {
+    testArray.skipBytes(2);
+    assertReadBitsToEnd(16);
+  }
+
+  @Test
+  public void testSkipBitsByteAligned() {
+    testArray.skipBits(16);
+    assertReadBitsToEnd(16);
+  }
+
+  @Test
+  public void testSkipBitsNonByteAligned() {
+    testArray.skipBits(5);
+    assertReadBitsToEnd(5);
+  }
+
+  @Test
+  public void testSetPositionByteAligned() {
+    testArray.setPosition(16);
+    assertReadBitsToEnd(16);
+  }
+
+  @Test
+  public void testSetPositionNonByteAligned() {
+    testArray.setPosition(5);
+    assertReadBitsToEnd(5);
+  }
+
+  @Test
+  public void testByteAlignFromNonByteAligned() {
+    testArray.setPosition(11);
+    testArray.byteAlign();
+    assertThat(testArray.getBytePosition()).isEqualTo(2);
+    assertThat(testArray.getPosition()).isEqualTo(16);
+    assertReadBitsToEnd(16);
+  }
+
+  @Test
+  public void testByteAlignFromByteAligned() {
+    testArray.setPosition(16);
+    testArray.byteAlign(); // Should be a no-op.
+    assertThat(testArray.getBytePosition()).isEqualTo(2);
+    assertThat(testArray.getPosition()).isEqualTo(16);
+    assertReadBitsToEnd(16);
+  }
+
+  private void assertReadBitsToEnd(int expectedStartPosition) {
+    int position = testArray.getPosition();
+    assertThat(position).isEqualTo(expectedStartPosition);
+    for (int i = position; i < TEST_DATA.length * 8; i++) {
+      assertThat(testArray.readBit()).isEqualTo(getTestDataBit(i));
+      assertThat(testArray.getPosition()).isEqualTo(i + 1);
+    }
+  }
+
+  private static int getTestDataBits(int bitPosition, int length) {
+    int result = 0;
+    for (int i = 0; i < length; i++) {
+      result = result << 1;
+      if (getTestDataBit(bitPosition++)) {
+        result |= 0x1;
+      }
+    }
+    return result;
+  }
+
+  private static boolean getTestDataBit(int bitPosition) {
+    return (TEST_DATA[bitPosition / 8] & (0x80 >>> (bitPosition % 8))) != 0;
+  }
+
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
similarity index 62%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
index 49719b95f7..947a692647 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
@@ -15,15 +15,23 @@
  */
 package com.google.android.exoplayer2.util;
 
+import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.Charset.forName;
+import static junit.framework.TestCase.fail;
+
 import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 import java.util.Arrays;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link ParsableByteArray}.
  */
-public class ParsableByteArrayTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ParsableByteArrayTest {
 
   private static final byte[] TEST_DATA =
       new byte[] {0x0F, (byte) 0xFF, (byte) 0x42, (byte) 0x0F, 0x00, 0x00, 0x00, 0x00};
@@ -34,6 +42,7 @@ private static ParsableByteArray getTestDataArray() {
     return testArray;
   }
 
+  @Test
   public void testReadShort() {
     testReadShort((short) -1);
     testReadShort((short) 0);
@@ -48,17 +57,18 @@ private static void testReadShort(short testValue) {
     int readValue = testArray.readShort();
 
     // Assert that the value we read was the value we wrote.
-    assertEquals(testValue, readValue);
+    assertThat(readValue).isEqualTo(testValue);
     // And that the position advanced as expected.
-    assertEquals(2, testArray.getPosition());
+    assertThat(testArray.getPosition()).isEqualTo(2);
 
     // And that skipping back and reading gives the same results.
     testArray.skipBytes(-2);
     readValue = testArray.readShort();
-    assertEquals(testValue, readValue);
-    assertEquals(2, testArray.getPosition());
+    assertThat(readValue).isEqualTo(testValue);
+    assertThat(testArray.getPosition()).isEqualTo(2);
   }
 
+  @Test
   public void testReadInt() {
     testReadInt(0);
     testReadInt(1);
@@ -73,17 +83,18 @@ private static void testReadInt(int testValue) {
     int readValue = testArray.readInt();
 
     // Assert that the value we read was the value we wrote.
-    assertEquals(testValue, readValue);
+    assertThat(readValue).isEqualTo(testValue);
     // And that the position advanced as expected.
-    assertEquals(4, testArray.getPosition());
+    assertThat(testArray.getPosition()).isEqualTo(4);
 
     // And that skipping back and reading gives the same results.
     testArray.skipBytes(-4);
     readValue = testArray.readInt();
-    assertEquals(testValue, readValue);
-    assertEquals(4, testArray.getPosition());
+    assertThat(readValue).isEqualTo(testValue);
+    assertThat(testArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadUnsignedInt() {
     testReadUnsignedInt(0);
     testReadUnsignedInt(1);
@@ -98,17 +109,18 @@ private static void testReadUnsignedInt(long testValue) {
     long readValue = testArray.readUnsignedInt();
 
     // Assert that the value we read was the value we wrote.
-    assertEquals(testValue, readValue);
+    assertThat(readValue).isEqualTo(testValue);
     // And that the position advanced as expected.
-    assertEquals(4, testArray.getPosition());
+    assertThat(testArray.getPosition()).isEqualTo(4);
 
     // And that skipping back and reading gives the same results.
     testArray.skipBytes(-4);
     readValue = testArray.readUnsignedInt();
-    assertEquals(testValue, readValue);
-    assertEquals(4, testArray.getPosition());
+    assertThat(readValue).isEqualTo(testValue);
+    assertThat(testArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadUnsignedIntToInt() {
     testReadUnsignedIntToInt(0);
     testReadUnsignedIntToInt(1);
@@ -133,17 +145,18 @@ private static void testReadUnsignedIntToInt(int testValue) {
     int readValue = testArray.readUnsignedIntToInt();
 
     // Assert that the value we read was the value we wrote.
-    assertEquals(testValue, readValue);
+    assertThat(readValue).isEqualTo(testValue);
     // And that the position advanced as expected.
-    assertEquals(4, testArray.getPosition());
+    assertThat(testArray.getPosition()).isEqualTo(4);
 
     // And that skipping back and reading gives the same results.
     testArray.skipBytes(-4);
     readValue = testArray.readUnsignedIntToInt();
-    assertEquals(testValue, readValue);
-    assertEquals(4, testArray.getPosition());
+    assertThat(readValue).isEqualTo(testValue);
+    assertThat(testArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadUnsignedLongToLong() {
     testReadUnsignedLongToLong(0);
     testReadUnsignedLongToLong(1);
@@ -168,17 +181,18 @@ private static void testReadUnsignedLongToLong(long testValue) {
     long readValue = testArray.readUnsignedLongToLong();
 
     // Assert that the value we read was the value we wrote.
-    assertEquals(testValue, readValue);
+    assertThat(readValue).isEqualTo(testValue);
     // And that the position advanced as expected.
-    assertEquals(8, testArray.getPosition());
+    assertThat(testArray.getPosition()).isEqualTo(8);
 
     // And that skipping back and reading gives the same results.
     testArray.skipBytes(-8);
     readValue = testArray.readUnsignedLongToLong();
-    assertEquals(testValue, readValue);
-    assertEquals(8, testArray.getPosition());
+    assertThat(readValue).isEqualTo(testValue);
+    assertThat(testArray.getPosition()).isEqualTo(8);
   }
 
+  @Test
   public void testReadLong() {
     testReadLong(0);
     testReadLong(1);
@@ -193,33 +207,35 @@ private static void testReadLong(long testValue) {
     long readValue = testArray.readLong();
 
     // Assert that the value we read was the value we wrote.
-    assertEquals(testValue, readValue);
+    assertThat(readValue).isEqualTo(testValue);
     // And that the position advanced as expected.
-    assertEquals(8, testArray.getPosition());
+    assertThat(testArray.getPosition()).isEqualTo(8);
 
     // And that skipping back and reading gives the same results.
     testArray.skipBytes(-8);
     readValue = testArray.readLong();
-    assertEquals(testValue, readValue);
-    assertEquals(8, testArray.getPosition());
+    assertThat(readValue).isEqualTo(testValue);
+    assertThat(testArray.getPosition()).isEqualTo(8);
   }
 
+  @Test
   public void testReadingMovesPosition() {
     ParsableByteArray parsableByteArray = getTestDataArray();
 
     // Given an array at the start
-    assertEquals(0, parsableByteArray.getPosition());
+    assertThat(parsableByteArray.getPosition()).isEqualTo(0);
     // When reading an integer, the position advances
     parsableByteArray.readUnsignedInt();
-    assertEquals(4, parsableByteArray.getPosition());
+    assertThat(parsableByteArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testOutOfBoundsThrows() {
     ParsableByteArray parsableByteArray = getTestDataArray();
 
     // Given an array at the end
     parsableByteArray.readUnsignedLongToLong();
-    assertEquals(TEST_DATA.length, parsableByteArray.getPosition());
+    assertThat(parsableByteArray.getPosition()).isEqualTo(TEST_DATA.length);
     // Then reading more data throws.
     try {
       parsableByteArray.readUnsignedInt();
@@ -229,6 +245,7 @@ public void testOutOfBoundsThrows() {
     }
   }
 
+  @Test
   public void testModificationsAffectParsableArray() {
     ParsableByteArray parsableByteArray = getTestDataArray();
 
@@ -238,9 +255,10 @@ public void testModificationsAffectParsableArray() {
     data[0] = (byte) (TEST_DATA[0] + 1);
     parsableByteArray.setPosition(0);
     // Then the parsed value changes.
-    assertFalse(parsableByteArray.readUnsignedInt() == readValue);
+    assertThat(parsableByteArray.readUnsignedInt()).isNotEqualTo(readValue);
   }
 
+  @Test
   public void testReadingUnsignedLongWithMsbSetThrows() {
     ParsableByteArray parsableByteArray = getTestDataArray();
 
@@ -256,80 +274,105 @@ public void testReadingUnsignedLongWithMsbSetThrows() {
     }
   }
 
+  @Test
   public void testReadUnsignedFixedPoint1616() {
     ParsableByteArray parsableByteArray = getTestDataArray();
 
     // When reading the integer part of a 16.16 fixed point value
     int value = parsableByteArray.readUnsignedFixedPoint1616();
     // Then the read value is equal to the array elements interpreted as a short.
-    assertEquals((0xFF & TEST_DATA[0]) << 8 | (TEST_DATA[1] & 0xFF), value);
-    assertEquals(4, parsableByteArray.getPosition());
+    assertThat(value).isEqualTo((0xFF & TEST_DATA[0]) << 8 | (TEST_DATA[1] & 0xFF));
+    assertThat(parsableByteArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadingBytesReturnsCopy() {
     ParsableByteArray parsableByteArray = getTestDataArray();
 
     // When reading all the bytes back
     int length = parsableByteArray.limit();
-    assertEquals(TEST_DATA.length, length);
+    assertThat(length).isEqualTo(TEST_DATA.length);
     byte[] copy = new byte[length];
     parsableByteArray.readBytes(copy, 0, length);
     // Then the array elements are the same.
-    assertTrue(Arrays.equals(parsableByteArray.data, copy));
+    assertThat(copy).isEqualTo(parsableByteArray.data);
   }
 
+  @Test
   public void testReadLittleEndianLong() {
-    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[] {
         0x01, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, (byte) 0xFF
     });
-    assertEquals(0xFF00000000000001L, byteArray.readLittleEndianLong());
-    assertEquals(8, byteArray.getPosition());
+    assertThat(byteArray.readLittleEndianLong()).isEqualTo(0xFF00000000000001L);
+    assertThat(byteArray.getPosition()).isEqualTo(8);
   }
 
+  @Test
   public void testReadLittleEndianUnsignedInt() {
     ParsableByteArray byteArray = new ParsableByteArray(new byte[] {
         0x10, 0x00, 0x00, (byte) 0xFF
     });
-    assertEquals(0xFF000010L, byteArray.readLittleEndianUnsignedInt());
-    assertEquals(4, byteArray.getPosition());
+    assertThat(byteArray.readLittleEndianUnsignedInt()).isEqualTo(0xFF000010L);
+    assertThat(byteArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadLittleEndianInt() {
-    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[] {
         0x01, 0x00, 0x00, (byte) 0xFF
     });
-    assertEquals(0xFF000001, byteArray.readLittleEndianInt());
-    assertEquals(4, byteArray.getPosition());
+    assertThat(byteArray.readLittleEndianInt()).isEqualTo(0xFF000001);
+    assertThat(byteArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadLittleEndianUnsignedInt24() {
-    byte[] data = { 0x01, 0x02, (byte) 0xFF };
+    byte[] data = {0x01, 0x02, (byte) 0xFF};
+    ParsableByteArray byteArray = new ParsableByteArray(data);
+    assertThat(byteArray.readLittleEndianUnsignedInt24()).isEqualTo(0xFF0201);
+    assertThat(byteArray.getPosition()).isEqualTo(3);
+  }
+
+  @Test
+  public void testReadInt24Positive() {
+    byte[] data = {0x01, 0x02, (byte) 0xFF};
     ParsableByteArray byteArray = new ParsableByteArray(data);
-    assertEquals(0xFF0201, byteArray.readLittleEndianUnsignedInt24());
-    assertEquals(3, byteArray.getPosition());
+    assertThat(byteArray.readInt24()).isEqualTo(0x0102FF);
+    assertThat(byteArray.getPosition()).isEqualTo(3);
   }
 
+  @Test
+  public void testReadInt24Negative() {
+    byte[] data = {(byte) 0xFF, 0x02, (byte) 0x01};
+    ParsableByteArray byteArray = new ParsableByteArray(data);
+    assertThat(byteArray.readInt24()).isEqualTo(0xFFFF0201);
+    assertThat(byteArray.getPosition()).isEqualTo(3);
+  }
+
+  @Test
   public void testReadLittleEndianUnsignedShort() {
-    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[] {
         0x01, (byte) 0xFF, 0x02, (byte) 0xFF
     });
-    assertEquals(0xFF01, byteArray.readLittleEndianUnsignedShort());
-    assertEquals(2, byteArray.getPosition());
-    assertEquals(0xFF02, byteArray.readLittleEndianUnsignedShort());
-    assertEquals(4, byteArray.getPosition());
+    assertThat(byteArray.readLittleEndianUnsignedShort()).isEqualTo(0xFF01);
+    assertThat(byteArray.getPosition()).isEqualTo(2);
+    assertThat(byteArray.readLittleEndianUnsignedShort()).isEqualTo(0xFF02);
+    assertThat(byteArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadLittleEndianShort() {
-    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[] {
         0x01, (byte) 0xFF, 0x02, (byte) 0xFF
     });
-    assertEquals((short) 0xFF01, byteArray.readLittleEndianShort());
-    assertEquals(2, byteArray.getPosition());
-    assertEquals((short) 0xFF02, byteArray.readLittleEndianShort());
-    assertEquals(4, byteArray.getPosition());
+    assertThat(byteArray.readLittleEndianShort()).isEqualTo((short) 0xFF01);
+    assertThat(byteArray.getPosition()).isEqualTo(2);
+    assertThat(byteArray.readLittleEndianShort()).isEqualTo((short) 0xFF02);
+    assertThat(byteArray.getPosition()).isEqualTo(4);
   }
 
+  @Test
   public void testReadString() {
     byte[] data = {
         (byte) 0xC3, (byte) 0xA4, (byte) 0x20,
@@ -341,17 +384,19 @@ public void testReadString() {
         (byte) 0xE8, (byte) 0xB0, (byte) 0xA2, (byte) 0x20,
     };
     ParsableByteArray byteArray = new ParsableByteArray(data);
-    assertEquals("ä ö ® π √ ± 谢 ", byteArray.readString(data.length));
-    assertEquals(data.length, byteArray.getPosition());
+    assertThat(byteArray.readString(data.length)).isEqualTo("ä ö ® π √ ± 谢 ");
+    assertThat(byteArray.getPosition()).isEqualTo(data.length);
   }
 
+  @Test
   public void testReadAsciiString() {
     byte[] data = new byte[] {'t', 'e', 's', 't'};
     ParsableByteArray testArray = new ParsableByteArray(data);
-    assertEquals("test", testArray.readString(data.length, Charset.forName("US-ASCII")));
-    assertEquals(data.length, testArray.getPosition());
+    assertThat(testArray.readString(data.length, forName("US-ASCII"))).isEqualTo("test");
+    assertThat(testArray.getPosition()).isEqualTo(data.length);
   }
 
+  @Test
   public void testReadStringOutOfBoundsDoesNotMovePosition() {
     byte[] data = {
         (byte) 0xC3, (byte) 0xA4, (byte) 0x20
@@ -361,132 +406,141 @@ public void testReadStringOutOfBoundsDoesNotMovePosition() {
       byteArray.readString(data.length + 1);
       fail();
     } catch (StringIndexOutOfBoundsException e) {
-      assertEquals(0, byteArray.getPosition());
+      assertThat(byteArray.getPosition()).isEqualTo(0);
     }
   }
 
+  @Test
   public void testReadEmptyString() {
     byte[] bytes = new byte[0];
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertNull(parser.readLine());
+    assertThat(parser.readLine()).isNull();
   }
 
+  @Test
   public void testReadNullTerminatedStringWithLengths() {
     byte[] bytes = new byte[] {
         'f', 'o', 'o', 0, 'b', 'a', 'r', 0
     };
     // Test with lengths that match NUL byte positions.
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readNullTerminatedString(4));
-    assertEquals(4, parser.getPosition());
-    assertEquals("bar", parser.readNullTerminatedString(4));
-    assertEquals(8, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString(4)).isEqualTo("foo");
+    assertThat(parser.getPosition()).isEqualTo(4);
+    assertThat(parser.readNullTerminatedString(4)).isEqualTo("bar");
+    assertThat(parser.getPosition()).isEqualTo(8);
+    assertThat(parser.readNullTerminatedString()).isNull();
     // Test with lengths that do not match NUL byte positions.
     parser = new ParsableByteArray(bytes);
-    assertEquals("fo", parser.readNullTerminatedString(2));
-    assertEquals(2, parser.getPosition());
-    assertEquals("o", parser.readNullTerminatedString(2));
-    assertEquals(4, parser.getPosition());
-    assertEquals("bar", parser.readNullTerminatedString(3));
-    assertEquals(7, parser.getPosition());
-    assertEquals("", parser.readNullTerminatedString(1));
-    assertEquals(8, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString(2)).isEqualTo("fo");
+    assertThat(parser.getPosition()).isEqualTo(2);
+    assertThat(parser.readNullTerminatedString(2)).isEqualTo("o");
+    assertThat(parser.getPosition()).isEqualTo(4);
+    assertThat(parser.readNullTerminatedString(3)).isEqualTo("bar");
+    assertThat(parser.getPosition()).isEqualTo(7);
+    assertThat(parser.readNullTerminatedString(1)).isEqualTo("");
+    assertThat(parser.getPosition()).isEqualTo(8);
+    assertThat(parser.readNullTerminatedString()).isNull();
     // Test with limit at NUL
     parser = new ParsableByteArray(bytes, 4);
-    assertEquals("foo", parser.readNullTerminatedString(4));
-    assertEquals(4, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString(4)).isEqualTo("foo");
+    assertThat(parser.getPosition()).isEqualTo(4);
+    assertThat(parser.readNullTerminatedString()).isNull();
     // Test with limit before NUL
     parser = new ParsableByteArray(bytes, 3);
-    assertEquals("foo", parser.readNullTerminatedString(3));
-    assertEquals(3, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString(3)).isEqualTo("foo");
+    assertThat(parser.getPosition()).isEqualTo(3);
+    assertThat(parser.readNullTerminatedString()).isNull();
   }
 
+  @Test
   public void testReadNullTerminatedString() {
     byte[] bytes = new byte[] {
         'f', 'o', 'o', 0, 'b', 'a', 'r', 0
     };
     // Test normal case.
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readNullTerminatedString());
-    assertEquals(4, parser.getPosition());
-    assertEquals("bar", parser.readNullTerminatedString());
-    assertEquals(8, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString()).isEqualTo("foo");
+    assertThat(parser.getPosition()).isEqualTo(4);
+    assertThat(parser.readNullTerminatedString()).isEqualTo("bar");
+    assertThat(parser.getPosition()).isEqualTo(8);
+    assertThat(parser.readNullTerminatedString()).isNull();
     // Test with limit at NUL.
     parser = new ParsableByteArray(bytes, 4);
-    assertEquals("foo", parser.readNullTerminatedString());
-    assertEquals(4, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString()).isEqualTo("foo");
+    assertThat(parser.getPosition()).isEqualTo(4);
+    assertThat(parser.readNullTerminatedString()).isNull();
     // Test with limit before NUL.
     parser = new ParsableByteArray(bytes, 3);
-    assertEquals("foo", parser.readNullTerminatedString());
-    assertEquals(3, parser.getPosition());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString()).isEqualTo("foo");
+    assertThat(parser.getPosition()).isEqualTo(3);
+    assertThat(parser.readNullTerminatedString()).isNull();
   }
 
+  @Test
   public void testReadNullTerminatedStringWithoutEndingNull() {
     byte[] bytes = new byte[] {
         'f', 'o', 'o', 0, 'b', 'a', 'r'
     };
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readNullTerminatedString());
-    assertEquals("bar", parser.readNullTerminatedString());
-    assertNull(parser.readNullTerminatedString());
+    assertThat(parser.readNullTerminatedString()).isEqualTo("foo");
+    assertThat(parser.readNullTerminatedString()).isEqualTo("bar");
+    assertThat(parser.readNullTerminatedString()).isNull();
   }
 
+  @Test
   public void testReadSingleLineWithoutEndingTrail() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o'
     };
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readLine());
-    assertNull(parser.readLine());
+    assertThat(parser.readLine()).isEqualTo("foo");
+    assertThat(parser.readLine()).isNull();
   }
 
+  @Test
   public void testReadSingleLineWithEndingLf() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o', '\n'
     };
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readLine());
-    assertNull(parser.readLine());
+    assertThat(parser.readLine()).isEqualTo("foo");
+    assertThat(parser.readLine()).isNull();
   }
 
+  @Test
   public void testReadTwoLinesWithCrFollowedByLf() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o', '\r', '\n', 'b', 'a', 'r'
     };
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readLine());
-    assertEquals("bar", parser.readLine());
-    assertNull(parser.readLine());
+    assertThat(parser.readLine()).isEqualTo("foo");
+    assertThat(parser.readLine()).isEqualTo("bar");
+    assertThat(parser.readLine()).isNull();
   }
 
+  @Test
   public void testReadThreeLinesWithEmptyLine() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o', '\r', '\n', '\r', 'b', 'a', 'r'
     };
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readLine());
-    assertEquals("", parser.readLine());
-    assertEquals("bar", parser.readLine());
-    assertNull(parser.readLine());
+    assertThat(parser.readLine()).isEqualTo("foo");
+    assertThat(parser.readLine()).isEqualTo("");
+    assertThat(parser.readLine()).isEqualTo("bar");
+    assertThat(parser.readLine()).isNull();
   }
 
+  @Test
   public void testReadFourLinesWithLfFollowedByCr() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o', '\n', '\r', '\r', 'b', 'a', 'r', '\r', '\n'
     };
     ParsableByteArray parser = new ParsableByteArray(bytes);
-    assertEquals("foo", parser.readLine());
-    assertEquals("", parser.readLine());
-    assertEquals("", parser.readLine());
-    assertEquals("bar", parser.readLine());
-    assertNull(parser.readLine());
+    assertThat(parser.readLine()).isEqualTo("foo");
+    assertThat(parser.readLine()).isEqualTo("");
+    assertThat(parser.readLine()).isEqualTo("");
+    assertThat(parser.readLine()).isEqualTo("bar");
+    assertThat(parser.readLine()).isNull();
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
similarity index 51%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
index 294d3d352a..a3f38abcdb 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
@@ -16,34 +16,43 @@
 package com.google.android.exoplayer2.util;
 
 import static com.google.android.exoplayer2.testutil.TestUtil.createByteArray;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link ParsableNalUnitBitArray}.
  */
-public final class ParsableNalUnitBitArrayTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ParsableNalUnitBitArrayTest {
 
   private static final byte[] NO_ESCAPING_TEST_DATA = createByteArray(0, 3, 0, 1, 3, 0, 0);
   private static final byte[] ALL_ESCAPING_TEST_DATA = createByteArray(0, 0, 3, 0, 0, 3, 0, 0, 3);
   private static final byte[] MIX_TEST_DATA = createByteArray(255, 0, 0, 3, 255, 0, 0, 127);
 
+  @Test
   public void testReadNoEscaping() {
     ParsableNalUnitBitArray array =
         new ParsableNalUnitBitArray(NO_ESCAPING_TEST_DATA, 0, NO_ESCAPING_TEST_DATA.length);
-    assertEquals(0x000300, array.readBits(24));
-    assertEquals(0, array.readBits(7));
-    assertTrue(array.readBit());
-    assertEquals(0x030000, array.readBits(24));
-    assertFalse(array.canReadBits(1));
-    assertFalse(array.canReadBits(8));
+    assertThat(array.readBits(24)).isEqualTo(0x000300);
+    assertThat(array.readBits(7)).isEqualTo(0);
+    assertThat(array.readBit()).isTrue();
+    assertThat(array.readBits(24)).isEqualTo(0x030000);
+    assertThat(array.canReadBits(1)).isFalse();
+    assertThat(array.canReadBits(8)).isFalse();
   }
 
+  @Test
   public void testReadNoEscapingTruncated() {
     ParsableNalUnitBitArray array = new ParsableNalUnitBitArray(NO_ESCAPING_TEST_DATA, 0, 4);
-    assertTrue(array.canReadBits(32));
+    assertThat(array.canReadBits(32)).isTrue();
     array.skipBits(32);
-    assertFalse(array.canReadBits(1));
+    assertThat(array.canReadBits(1)).isFalse();
     try {
       array.readBit();
       fail();
@@ -52,37 +61,40 @@ public void testReadNoEscapingTruncated() {
     }
   }
 
+  @Test
   public void testReadAllEscaping() {
     ParsableNalUnitBitArray array =
         new ParsableNalUnitBitArray(ALL_ESCAPING_TEST_DATA, 0, ALL_ESCAPING_TEST_DATA.length);
-    assertTrue(array.canReadBits(48));
-    assertFalse(array.canReadBits(49));
-    assertEquals(0, array.readBits(15));
-    assertFalse(array.readBit());
-    assertEquals(0, array.readBits(17));
-    assertEquals(0, array.readBits(15));
+    assertThat(array.canReadBits(48)).isTrue();
+    assertThat(array.canReadBits(49)).isFalse();
+    assertThat(array.readBits(15)).isEqualTo(0);
+    assertThat(array.readBit()).isFalse();
+    assertThat(array.readBits(17)).isEqualTo(0);
+    assertThat(array.readBits(15)).isEqualTo(0);
   }
 
+  @Test
   public void testReadMix() {
     ParsableNalUnitBitArray array =
         new ParsableNalUnitBitArray(MIX_TEST_DATA, 0, MIX_TEST_DATA.length);
-    assertTrue(array.canReadBits(56));
-    assertFalse(array.canReadBits(57));
-    assertEquals(127, array.readBits(7));
-    assertEquals(2, array.readBits(2));
-    assertEquals(3, array.readBits(17));
-    assertEquals(126, array.readBits(7));
-    assertEquals(127, array.readBits(23));
-    assertFalse(array.canReadBits(1));
+    assertThat(array.canReadBits(56)).isTrue();
+    assertThat(array.canReadBits(57)).isFalse();
+    assertThat(array.readBits(7)).isEqualTo(127);
+    assertThat(array.readBits(2)).isEqualTo(2);
+    assertThat(array.readBits(17)).isEqualTo(3);
+    assertThat(array.readBits(7)).isEqualTo(126);
+    assertThat(array.readBits(23)).isEqualTo(127);
+    assertThat(array.canReadBits(1)).isFalse();
   }
 
+  @Test
   public void testReadExpGolomb() {
     ParsableNalUnitBitArray array = new ParsableNalUnitBitArray(createByteArray(0x9E), 0, 1);
-    assertTrue(array.canReadExpGolombCodedNum());
-    assertEquals(0, array.readUnsignedExpGolombCodedInt());
-    assertEquals(6, array.readUnsignedExpGolombCodedInt());
-    assertEquals(0, array.readUnsignedExpGolombCodedInt());
-    assertFalse(array.canReadExpGolombCodedNum());
+    assertThat(array.canReadExpGolombCodedNum()).isTrue();
+    assertThat(array.readUnsignedExpGolombCodedInt()).isEqualTo(0);
+    assertThat(array.readUnsignedExpGolombCodedInt()).isEqualTo(6);
+    assertThat(array.readUnsignedExpGolombCodedInt()).isEqualTo(0);
+    assertThat(array.canReadExpGolombCodedNum()).isFalse();
     try {
       array.readUnsignedExpGolombCodedInt();
       fail();
@@ -91,24 +103,26 @@ public void testReadExpGolomb() {
     }
   }
 
+  @Test
   public void testReadExpGolombWithEscaping() {
     ParsableNalUnitBitArray array =
         new ParsableNalUnitBitArray(createByteArray(0, 0, 3, 128, 0), 0, 5);
-    assertFalse(array.canReadExpGolombCodedNum());
+    assertThat(array.canReadExpGolombCodedNum()).isFalse();
     array.skipBit();
-    assertTrue(array.canReadExpGolombCodedNum());
-    assertEquals(32767, array.readUnsignedExpGolombCodedInt());
-    assertFalse(array.canReadBits(1));
+    assertThat(array.canReadExpGolombCodedNum()).isTrue();
+    assertThat(array.readUnsignedExpGolombCodedInt()).isEqualTo(32767);
+    assertThat(array.canReadBits(1)).isFalse();
   }
 
+  @Test
   public void testReset() {
     ParsableNalUnitBitArray array = new ParsableNalUnitBitArray(createByteArray(0, 0), 0, 2);
-    assertFalse(array.canReadExpGolombCodedNum());
-    assertTrue(array.canReadBits(16));
-    assertFalse(array.canReadBits(17));
+    assertThat(array.canReadExpGolombCodedNum()).isFalse();
+    assertThat(array.canReadBits(16)).isTrue();
+    assertThat(array.canReadBits(17)).isFalse();
     array.reset(createByteArray(0, 0, 3, 0), 0, 4);
-    assertTrue(array.canReadBits(24));
-    assertFalse(array.canReadBits(25));
+    assertThat(array.canReadBits(24)).isTrue();
+    assertThat(array.canReadBits(25)).isFalse();
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
similarity index 73%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
index beb9e44853..8e384bbb10 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
@@ -15,18 +15,25 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.test.MoreAsserts;
+import static com.google.common.truth.Truth.assertThat;
+
 import java.io.ByteArrayOutputStream;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link ReusableBufferedOutputStream}.
  */
-public class ReusableBufferedOutputStreamTest extends TestCase {
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class ReusableBufferedOutputStreamTest {
 
   private static final byte[] TEST_DATA_1 = "test data 1".getBytes();
   private static final byte[] TEST_DATA_2 = "2 test data".getBytes();
 
+  @Test
   public void testReset() throws Exception {
     ByteArrayOutputStream byteArrayOutputStream1 = new ByteArrayOutputStream(1000);
     ReusableBufferedOutputStream outputStream = new ReusableBufferedOutputStream(
@@ -39,8 +46,8 @@ public void testReset() throws Exception {
     outputStream.write(TEST_DATA_2);
     outputStream.close();
 
-    MoreAsserts.assertEquals(TEST_DATA_1, byteArrayOutputStream1.toByteArray());
-    MoreAsserts.assertEquals(TEST_DATA_2, byteArrayOutputStream2.toByteArray());
+    assertThat(byteArrayOutputStream1.toByteArray()).isEqualTo(TEST_DATA_1);
+    assertThat(byteArrayOutputStream2.toByteArray()).isEqualTo(TEST_DATA_2);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
new file mode 100644
index 0000000000..52e7a722fb
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static com.google.android.exoplayer2.util.UriUtil.resolve;
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link UriUtil}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public final class UriUtilTest {
+
+  /**
+   * Tests normal usage of {@link UriUtil#resolve(String, String)}.
+   * <p>
+   * The test cases are taken from RFC-3986 5.4.1.
+   */
+  @Test
+  public void testResolveNormal() {
+    String base = "http://a/b/c/d;p?q";
+
+    assertThat(resolve(base, "g:h")).isEqualTo("g:h");
+    assertThat(resolve(base, "g")).isEqualTo("http://a/b/c/g");
+    assertThat(resolve(base, "g/")).isEqualTo("http://a/b/c/g/");
+    assertThat(resolve(base, "/g")).isEqualTo("http://a/g");
+    assertThat(resolve(base, "//g")).isEqualTo("http://g");
+    assertThat(resolve(base, "?y")).isEqualTo("http://a/b/c/d;p?y");
+    assertThat(resolve(base, "g?y")).isEqualTo("http://a/b/c/g?y");
+    assertThat(resolve(base, "#s")).isEqualTo("http://a/b/c/d;p?q#s");
+    assertThat(resolve(base, "g#s")).isEqualTo("http://a/b/c/g#s");
+    assertThat(resolve(base, "g?y#s")).isEqualTo("http://a/b/c/g?y#s");
+    assertThat(resolve(base, ";x")).isEqualTo("http://a/b/c/;x");
+    assertThat(resolve(base, "g;x")).isEqualTo("http://a/b/c/g;x");
+    assertThat(resolve(base, "g;x?y#s")).isEqualTo("http://a/b/c/g;x?y#s");
+    assertThat(resolve(base, "")).isEqualTo("http://a/b/c/d;p?q");
+    assertThat(resolve(base, ".")).isEqualTo("http://a/b/c/");
+    assertThat(resolve(base, "./")).isEqualTo("http://a/b/c/");
+    assertThat(resolve(base, "..")).isEqualTo("http://a/b/");
+    assertThat(resolve(base, "../")).isEqualTo("http://a/b/");
+    assertThat(resolve(base, "../g")).isEqualTo("http://a/b/g");
+    assertThat(resolve(base, "../..")).isEqualTo("http://a/");
+    assertThat(resolve(base, "../../")).isEqualTo("http://a/");
+    assertThat(resolve(base, "../../g")).isEqualTo("http://a/g");
+  }
+
+  /**
+   * Tests abnormal usage of {@link UriUtil#resolve(String, String)}.
+   * <p>
+   * The test cases are taken from RFC-3986 5.4.2.
+   */
+  @Test
+  public void testResolveAbnormal() {
+    String base = "http://a/b/c/d;p?q";
+
+    assertThat(resolve(base, "../../../g")).isEqualTo("http://a/g");
+    assertThat(resolve(base, "../../../../g")).isEqualTo("http://a/g");
+
+    assertThat(resolve(base, "/./g")).isEqualTo("http://a/g");
+    assertThat(resolve(base, "/../g")).isEqualTo("http://a/g");
+    assertThat(resolve(base, "g.")).isEqualTo("http://a/b/c/g.");
+    assertThat(resolve(base, ".g")).isEqualTo("http://a/b/c/.g");
+    assertThat(resolve(base, "g..")).isEqualTo("http://a/b/c/g..");
+    assertThat(resolve(base, "..g")).isEqualTo("http://a/b/c/..g");
+
+    assertThat(resolve(base, "./../g")).isEqualTo("http://a/b/g");
+    assertThat(resolve(base, "./g/.")).isEqualTo("http://a/b/c/g/");
+    assertThat(resolve(base, "g/./h")).isEqualTo("http://a/b/c/g/h");
+    assertThat(resolve(base, "g/../h")).isEqualTo("http://a/b/c/h");
+    assertThat(resolve(base, "g;x=1/./y")).isEqualTo("http://a/b/c/g;x=1/y");
+    assertThat(resolve(base, "g;x=1/../y")).isEqualTo("http://a/b/c/y");
+
+    assertThat(resolve(base, "g?y/./x")).isEqualTo("http://a/b/c/g?y/./x");
+    assertThat(resolve(base, "g?y/../x")).isEqualTo("http://a/b/c/g?y/../x");
+    assertThat(resolve(base, "g#s/./x")).isEqualTo("http://a/b/c/g#s/./x");
+    assertThat(resolve(base, "g#s/../x")).isEqualTo("http://a/b/c/g#s/../x");
+
+    assertThat(resolve(base, "http:g")).isEqualTo("http:g");
+  }
+
+  /**
+   * Tests additional abnormal usage of {@link UriUtil#resolve(String, String)}.
+   */
+  @Test
+  public void testResolveAbnormalAdditional() {
+    assertThat(resolve("http://a/b", "c:d/../e")).isEqualTo("c:e");
+    assertThat(resolve("a:b", "../c")).isEqualTo("a:c");
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
new file mode 100644
index 0000000000..1afe380483
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static com.google.android.exoplayer2.util.Util.binarySearchCeil;
+import static com.google.android.exoplayer2.util.Util.binarySearchFloor;
+import static com.google.android.exoplayer2.util.Util.escapeFileName;
+import static com.google.android.exoplayer2.util.Util.parseXsDateTime;
+import static com.google.android.exoplayer2.util.Util.parseXsDuration;
+import static com.google.android.exoplayer2.util.Util.unescapeFileName;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link Util}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
+public class UtilTest {
+
+  @Test
+  public void testInferContentType() {
+    assertThat(Util.inferContentType("http://a.b/c.ism")).isEqualTo(C.TYPE_SS);
+    assertThat(Util.inferContentType("http://a.b/c.isml")).isEqualTo(C.TYPE_SS);
+    assertThat(Util.inferContentType("http://a.b/c.ism/Manifest")).isEqualTo(C.TYPE_SS);
+    assertThat(Util.inferContentType("http://a.b/c.isml/manifest")).isEqualTo(C.TYPE_SS);
+    assertThat(Util.inferContentType("http://a.b/c.isml/manifest(filter=x)")).isEqualTo(C.TYPE_SS);
+
+    assertThat(Util.inferContentType("http://a.b/c.ism/prefix-manifest")).isEqualTo(C.TYPE_OTHER);
+    assertThat(Util.inferContentType("http://a.b/c.ism/manifest-suffix")).isEqualTo(C.TYPE_OTHER);
+  }
+
+  @Test
+  public void testArrayBinarySearchFloor() {
+    long[] values = new long[0];
+    assertThat(binarySearchFloor(values, 0, false, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 0, false, true)).isEqualTo(0);
+
+    values = new long[] {1, 3, 5};
+    assertThat(binarySearchFloor(values, 0, false, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 0, true, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 0, false, true)).isEqualTo(0);
+    assertThat(binarySearchFloor(values, 0, true, true)).isEqualTo(0);
+
+    assertThat(binarySearchFloor(values, 1, false, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 1, true, false)).isEqualTo(0);
+    assertThat(binarySearchFloor(values, 1, false, true)).isEqualTo(0);
+    assertThat(binarySearchFloor(values, 1, true, true)).isEqualTo(0);
+
+    assertThat(binarySearchFloor(values, 4, false, false)).isEqualTo(1);
+    assertThat(binarySearchFloor(values, 4, true, false)).isEqualTo(1);
+
+    assertThat(binarySearchFloor(values, 5, false, false)).isEqualTo(1);
+    assertThat(binarySearchFloor(values, 5, true, false)).isEqualTo(2);
+
+    assertThat(binarySearchFloor(values, 6, false, false)).isEqualTo(2);
+    assertThat(binarySearchFloor(values, 6, true, false)).isEqualTo(2);
+  }
+
+  @Test
+  public void testListBinarySearchFloor() {
+    List<Integer> values = new ArrayList<>();
+    assertThat(binarySearchFloor(values, 0, false, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 0, false, true)).isEqualTo(0);
+
+    values.add(1);
+    values.add(3);
+    values.add(5);
+    assertThat(binarySearchFloor(values, 0, false, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 0, true, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 0, false, true)).isEqualTo(0);
+    assertThat(binarySearchFloor(values, 0, true, true)).isEqualTo(0);
+
+    assertThat(binarySearchFloor(values, 1, false, false)).isEqualTo(-1);
+    assertThat(binarySearchFloor(values, 1, true, false)).isEqualTo(0);
+    assertThat(binarySearchFloor(values, 1, false, true)).isEqualTo(0);
+    assertThat(binarySearchFloor(values, 1, true, true)).isEqualTo(0);
+
+    assertThat(binarySearchFloor(values, 4, false, false)).isEqualTo(1);
+    assertThat(binarySearchFloor(values, 4, true, false)).isEqualTo(1);
+
+    assertThat(binarySearchFloor(values, 5, false, false)).isEqualTo(1);
+    assertThat(binarySearchFloor(values, 5, true, false)).isEqualTo(2);
+
+    assertThat(binarySearchFloor(values, 6, false, false)).isEqualTo(2);
+    assertThat(binarySearchFloor(values, 6, true, false)).isEqualTo(2);
+  }
+
+  @Test
+  public void testArrayBinarySearchCeil() {
+    long[] values = new long[0];
+    assertThat(binarySearchCeil(values, 0, false, false)).isEqualTo(0);
+    assertThat(binarySearchCeil(values, 0, false, true)).isEqualTo(-1);
+
+    values = new long[] {1, 3, 5};
+    assertThat(binarySearchCeil(values, 0, false, false)).isEqualTo(0);
+    assertThat(binarySearchCeil(values, 0, true, false)).isEqualTo(0);
+
+    assertThat(binarySearchCeil(values, 1, false, false)).isEqualTo(1);
+    assertThat(binarySearchCeil(values, 1, true, false)).isEqualTo(0);
+
+    assertThat(binarySearchCeil(values, 2, false, false)).isEqualTo(1);
+    assertThat(binarySearchCeil(values, 2, true, false)).isEqualTo(1);
+
+    assertThat(binarySearchCeil(values, 5, false, false)).isEqualTo(3);
+    assertThat(binarySearchCeil(values, 5, true, false)).isEqualTo(2);
+    assertThat(binarySearchCeil(values, 5, false, true)).isEqualTo(2);
+    assertThat(binarySearchCeil(values, 5, true, true)).isEqualTo(2);
+
+    assertThat(binarySearchCeil(values, 6, false, false)).isEqualTo(3);
+    assertThat(binarySearchCeil(values, 6, true, false)).isEqualTo(3);
+    assertThat(binarySearchCeil(values, 6, false, true)).isEqualTo(2);
+    assertThat(binarySearchCeil(values, 6, true, true)).isEqualTo(2);
+  }
+
+  @Test
+  public void testListBinarySearchCeil() {
+    List<Integer> values = new ArrayList<>();
+    assertThat(binarySearchCeil(values, 0, false, false)).isEqualTo(0);
+    assertThat(binarySearchCeil(values, 0, false, true)).isEqualTo(-1);
+
+    values.add(1);
+    values.add(3);
+    values.add(5);
+    assertThat(binarySearchCeil(values, 0, false, false)).isEqualTo(0);
+    assertThat(binarySearchCeil(values, 0, true, false)).isEqualTo(0);
+
+    assertThat(binarySearchCeil(values, 1, false, false)).isEqualTo(1);
+    assertThat(binarySearchCeil(values, 1, true, false)).isEqualTo(0);
+
+    assertThat(binarySearchCeil(values, 2, false, false)).isEqualTo(1);
+    assertThat(binarySearchCeil(values, 2, true, false)).isEqualTo(1);
+
+    assertThat(binarySearchCeil(values, 5, false, false)).isEqualTo(3);
+    assertThat(binarySearchCeil(values, 5, true, false)).isEqualTo(2);
+    assertThat(binarySearchCeil(values, 5, false, true)).isEqualTo(2);
+    assertThat(binarySearchCeil(values, 5, true, true)).isEqualTo(2);
+
+    assertThat(binarySearchCeil(values, 6, false, false)).isEqualTo(3);
+    assertThat(binarySearchCeil(values, 6, true, false)).isEqualTo(3);
+    assertThat(binarySearchCeil(values, 6, false, true)).isEqualTo(2);
+    assertThat(binarySearchCeil(values, 6, true, true)).isEqualTo(2);
+  }
+
+  @Test
+  public void testParseXsDuration() {
+    assertThat(parseXsDuration("PT150.279S")).isEqualTo(150279L);
+    assertThat(parseXsDuration("PT1.500S")).isEqualTo(1500L);
+  }
+
+  @Test
+  public void testParseXsDateTime() throws Exception {
+    assertThat(parseXsDateTime("2014-06-19T23:07:42")).isEqualTo(1403219262000L);
+    assertThat(parseXsDateTime("2014-08-06T11:00:00Z")).isEqualTo(1407322800000L);
+    assertThat(parseXsDateTime("2014-08-06T11:00:00,000Z")).isEqualTo(1407322800000L);
+    assertThat(parseXsDateTime("2014-09-19T13:18:55-08:00")).isEqualTo(1411161535000L);
+    assertThat(parseXsDateTime("2014-09-19T13:18:55-0800")).isEqualTo(1411161535000L);
+    assertThat(parseXsDateTime("2014-09-19T13:18:55.000-0800")).isEqualTo(1411161535000L);
+    assertThat(parseXsDateTime("2014-09-19T13:18:55.000-800")).isEqualTo(1411161535000L);
+  }
+
+  @Test
+  public void testUnescapeInvalidFileName() {
+    assertThat(Util.unescapeFileName("%a")).isNull();
+    assertThat(Util.unescapeFileName("%xyz")).isNull();
+  }
+
+  @Test
+  public void testEscapeUnescapeFileName() {
+    assertEscapeUnescapeFileName("just+a regular+fileName", "just+a regular+fileName");
+    assertEscapeUnescapeFileName("key:value", "key%3avalue");
+    assertEscapeUnescapeFileName("<>:\"/\\|?*%", "%3c%3e%3a%22%2f%5c%7c%3f%2a%25");
+
+    Random random = new Random(0);
+    for (int i = 0; i < 1000; i++) {
+      String string = TestUtil.buildTestString(1000, random);
+      assertEscapeUnescapeFileName(string);
+    }
+  }
+
+  private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
+    assertThat(escapeFileName(fileName)).isEqualTo(escapedFileName);
+    assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
+  }
+
+  private static void assertEscapeUnescapeFileName(String fileName) {
+    String escapedFileName = Util.escapeFileName(fileName);
+    assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
+  }
+
+}
diff --git a/library/dash/build.gradle b/library/dash/build.gradle
index 2220e5b250..99441a2849 100644
--- a/library/dash/build.gradle
+++ b/library/dash/build.gradle
@@ -35,11 +35,15 @@ android {
 dependencies {
     compile project(modulePrefix + 'library-core')
     compile 'com.android.support:support-annotations:' + supportLibraryVersion
-    compile 'com.android.support:support-core-utils:' + supportLibraryVersion
     androidTestCompile project(modulePrefix + 'testutils')
     androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
     androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile project(modulePrefix + 'testutils')
+    testCompile 'com.google.truth:truth:' + truthVersion
+    testCompile 'junit:junit:' + junitVersion
+    testCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile 'org.robolectric:robolectric:' + robolectricVersion
 }
 
 ext {
diff --git a/library/dash/src/androidTest/AndroidManifest.xml b/library/dash/src/androidTest/AndroidManifest.xml
index a9b143253f..3a5b0c1fa2 100644
--- a/library/dash/src/androidTest/AndroidManifest.xml
+++ b/library/dash/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.source.dash.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
index bac1c272e8..3db8c6b2f9 100644
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
+++ b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
@@ -75,8 +75,8 @@ private static Representation newRepresentations(DrmInitData drmInitData) {
   }
 
   private static DrmInitData newDrmInitData() {
-    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, null, "mimeType",
-        new byte[]{1, 4, 7, 0, 3, 6}));
+    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
+        new byte[] {1, 4, 7, 0, 3, 6}));
   }
 
 }
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/MockitoUtil.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/MockitoUtil.java
new file mode 100644
index 0000000000..e7cd9baf59
--- /dev/null
+++ b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/MockitoUtil.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import android.test.InstrumentationTestCase;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Utility for setting up Mockito for instrumentation tests.
+ */
+public final class MockitoUtil {
+
+  /**
+   * Sets up Mockito for an instrumentation test.
+   */
+  public static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
+    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
+    System.setProperty("dexmaker.dexcache",
+        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
+    MockitoAnnotations.initMocks(instrumentationTestCase);
+  }
+
+  private MockitoUtil() {}
+
+}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
new file mode 100644
index 0000000000..50752c8a72
--- /dev/null
+++ b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.offline;
+
+import android.net.Uri;
+
+/**
+ * Data for DASH downloading tests.
+ */
+/* package */ interface DashDownloadTestData {
+
+  Uri TEST_MPD_URI = Uri.parse("test.mpd");
+
+  byte[] TEST_MPD =
+      ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+          + "<MPD xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" type=\"static\" "
+          + "    mediaPresentationDuration=\"PT31S\">\n"
+          + "    <Period duration=\"PT16S\" >\n"
+          + "        <AdaptationSet>\n"
+          + "            <SegmentList>\n"
+          + "                <SegmentTimeline>\n"
+          + "                    <S d=\"5\" />\n"
+          + "                    <S d=\"5\" />\n"
+          + "                    <S d=\"5\" />\n"
+          + "                </SegmentTimeline>\n"
+          + "            </SegmentList>\n"
+          + "            <Representation>\n"
+          + "                <SegmentList>\n"
+          // Bounded range data
+          + "                    <Initialization range=\"0-9\" sourceURL=\"audio_init_data\" />\n"
+          // Unbounded range data
+          + "                    <SegmentURL media=\"audio_segment_1\" />\n"
+          + "                    <SegmentURL media=\"audio_segment_2\" />\n"
+          + "                    <SegmentURL media=\"audio_segment_3\" />\n"
+          + "                </SegmentList>\n"
+          + "            </Representation>\n"
+          + "        </AdaptationSet>\n"
+          + "        <AdaptationSet>\n"
+          // This segment list has a 1 second offset to make sure the progressive download order
+          + "            <SegmentList>\n"
+          + "                <SegmentTimeline>\n"
+          + "                    <S t=\"1\" d=\"5\" />\n" // 1s offset
+          + "                    <S d=\"5\" />\n"
+          + "                    <S d=\"5\" />\n"
+          + "                </SegmentTimeline>\n"
+          + "            </SegmentList>\n"
+          + "            <Representation>\n"
+          + "                <SegmentList>\n"
+          + "                    <SegmentURL media=\"text_segment_1\" />\n"
+          + "                    <SegmentURL media=\"text_segment_2\" />\n"
+          + "                    <SegmentURL media=\"text_segment_3\" />\n"
+          + "                </SegmentList>\n"
+          + "            </Representation>\n"
+          + "        </AdaptationSet>\n"
+          + "    </Period>\n"
+          + "    <Period>\n"
+          + "        <SegmentList>\n"
+          + "            <SegmentTimeline>\n"
+          + "                <S d=\"5\" />\n"
+          + "                <S d=\"5\" />\n"
+          + "                <S d=\"5\" />\n"
+          + "            </SegmentTimeline>\n"
+          + "        </SegmentList>\n"
+          + "        <AdaptationSet>\n"
+          + "            <Representation>\n"
+          + "                <SegmentList>\n"
+          + "                    <SegmentURL media=\"period_2_segment_1\" />\n"
+          + "                    <SegmentURL media=\"period_2_segment_2\" />\n"
+          + "                    <SegmentURL media=\"period_2_segment_3\" />\n"
+          + "                </SegmentList>\n"
+          + "            </Representation>\n"
+          + "        </AdaptationSet>\n"
+          + "    </Period>\n"
+          + "</MPD>").getBytes();
+
+  byte[] TEST_MPD_NO_INDEX =
+      ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+          + "<MPD xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" type=\"dynamic\">\n"
+          + "    <Period start=\"PT6462826.784S\" >\n"
+          + "        <AdaptationSet>\n"
+          + "            <Representation>\n"
+          + "                <SegmentBase indexRange='0-10'/>\n"
+          + "            </Representation>\n"
+          + "        </AdaptationSet>\n"
+          + "    </Period>\n"
+          + "</MPD>").getBytes();
+}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
new file mode 100644
index 0000000000..8532e65a68
--- /dev/null
+++ b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
@@ -0,0 +1,407 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.offline;
+
+import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD;
+import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD_NO_INDEX;
+import static com.google.android.exoplayer2.source.dash.offline.DashDownloadTestData.TEST_MPD_URI;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertDataCached;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.DownloadException;
+import com.google.android.exoplayer2.offline.Downloader.ProgressListener;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.source.dash.MockitoUtil;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.testutil.FakeDataSet;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import org.mockito.InOrder;
+import org.mockito.Mockito;
+
+/**
+ * Unit tests for {@link DashDownloader}.
+ */
+public class DashDownloaderTest extends InstrumentationTestCase {
+
+  private SimpleCache cache;
+  private File tempFolder;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    MockitoUtil.setUpMockito(this);
+    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    Util.recursiveDelete(tempFolder);
+    super.tearDown();
+  }
+
+  public void testGetManifest() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    DashManifest manifest = dashDownloader.getManifest();
+
+    assertNotNull(manifest);
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testDownloadManifestFailure() throws Exception {
+    byte[] testMpdFirstPart = Arrays.copyOf(TEST_MPD, 10);
+    byte[] testMpdSecondPart = Arrays.copyOfRange(TEST_MPD, 10, TEST_MPD.length);
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .newData(TEST_MPD_URI)
+        .appendReadData(testMpdFirstPart)
+        .appendReadError(new IOException())
+        .appendReadData(testMpdSecondPart)
+        .endData();
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    // fails on the first try
+    try {
+      dashDownloader.getManifest();
+      fail();
+    } catch (IOException e) {
+      // ignore
+    }
+    assertDataCached(cache, TEST_MPD_URI, testMpdFirstPart);
+
+    // on the second try it downloads the rest of the data
+    DashManifest manifest = dashDownloader.getManifest();
+
+    assertNotNull(manifest);
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testDownloadRepresentation() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    dashDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testDownloadRepresentationInSmallParts() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .newData("audio_segment_1")
+        .appendReadData(TestUtil.buildTestData(10))
+        .appendReadData(TestUtil.buildTestData(10))
+        .appendReadData(TestUtil.buildTestData(10))
+        .endData()
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    dashDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testDownloadRepresentations() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6)
+        .setRandomData("text_segment_1", 1)
+        .setRandomData("text_segment_2", 2)
+        .setRandomData("text_segment_3", 3);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(
+        new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0)});
+    dashDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testDownloadAllRepresentations() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6)
+        .setRandomData("text_segment_1", 1)
+        .setRandomData("text_segment_2", 2)
+        .setRandomData("text_segment_3", 3)
+        .setRandomData("period_2_segment_1", 1)
+        .setRandomData("period_2_segment_2", 2)
+        .setRandomData("period_2_segment_3", 3);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    // dashDownloader.selectRepresentations() isn't called
+    dashDownloader.download(null);
+    assertCachedData(cache, fakeDataSet);
+    dashDownloader.remove();
+
+    // select something random
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    // clear selection
+    dashDownloader.selectRepresentations(null);
+    dashDownloader.download(null);
+    assertCachedData(cache, fakeDataSet);
+    dashDownloader.remove();
+
+    dashDownloader.selectRepresentations(new RepresentationKey[0]);
+    dashDownloader.download(null);
+    assertCachedData(cache, fakeDataSet);
+    dashDownloader.remove();
+  }
+
+  public void testProgressiveDownload() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6)
+        .setRandomData("text_segment_1", 1)
+        .setRandomData("text_segment_2", 2)
+        .setRandomData("text_segment_3", 3);
+    FakeDataSource fakeDataSource = new FakeDataSource(fakeDataSet);
+    Factory factory = Mockito.mock(Factory.class);
+    Mockito.when(factory.createDataSource()).thenReturn(fakeDataSource);
+    DashDownloader dashDownloader = new DashDownloader(TEST_MPD_URI,
+        new DownloaderConstructorHelper(cache, factory));
+
+    dashDownloader.selectRepresentations(
+        new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0)});
+    dashDownloader.download(null);
+
+    DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
+    assertEquals(8, openedDataSpecs.length);
+    assertEquals(TEST_MPD_URI, openedDataSpecs[0].uri);
+    assertEquals("audio_init_data", openedDataSpecs[1].uri.getPath());
+    assertEquals("audio_segment_1", openedDataSpecs[2].uri.getPath());
+    assertEquals("text_segment_1", openedDataSpecs[3].uri.getPath());
+    assertEquals("audio_segment_2", openedDataSpecs[4].uri.getPath());
+    assertEquals("text_segment_2", openedDataSpecs[5].uri.getPath());
+    assertEquals("audio_segment_3", openedDataSpecs[6].uri.getPath());
+    assertEquals("text_segment_3", openedDataSpecs[7].uri.getPath());
+  }
+
+  public void testProgressiveDownloadSeparatePeriods() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6)
+        .setRandomData("period_2_segment_1", 1)
+        .setRandomData("period_2_segment_2", 2)
+        .setRandomData("period_2_segment_3", 3);
+    FakeDataSource fakeDataSource = new FakeDataSource(fakeDataSet);
+    Factory factory = Mockito.mock(Factory.class);
+    Mockito.when(factory.createDataSource()).thenReturn(fakeDataSource);
+    DashDownloader dashDownloader = new DashDownloader(TEST_MPD_URI,
+        new DownloaderConstructorHelper(cache, factory));
+
+    dashDownloader.selectRepresentations(
+        new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(1, 0, 0)});
+    dashDownloader.download(null);
+
+    DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
+    assertEquals(8, openedDataSpecs.length);
+    assertEquals(TEST_MPD_URI, openedDataSpecs[0].uri);
+    assertEquals("audio_init_data", openedDataSpecs[1].uri.getPath());
+    assertEquals("audio_segment_1", openedDataSpecs[2].uri.getPath());
+    assertEquals("audio_segment_2", openedDataSpecs[3].uri.getPath());
+    assertEquals("audio_segment_3", openedDataSpecs[4].uri.getPath());
+    assertEquals("period_2_segment_1", openedDataSpecs[5].uri.getPath());
+    assertEquals("period_2_segment_2", openedDataSpecs[6].uri.getPath());
+    assertEquals("period_2_segment_3", openedDataSpecs[7].uri.getPath());
+  }
+
+  public void testDownloadRepresentationFailure() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .newData("audio_segment_2")
+        .appendReadData(TestUtil.buildTestData(2))
+        .appendReadError(new IOException())
+        .appendReadData(TestUtil.buildTestData(3))
+        .endData()
+        .setRandomData("audio_segment_3", 6);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    // downloadRepresentations fails on the first try
+    try {
+      dashDownloader.download(null);
+      fail();
+    } catch (IOException e) {
+      // ignore
+    }
+    dashDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testCounters() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .newData("audio_segment_2")
+        .appendReadData(TestUtil.buildTestData(2))
+        .appendReadError(new IOException())
+        .appendReadData(TestUtil.buildTestData(3))
+        .endData()
+        .setRandomData("audio_segment_3", 6);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    assertCounters(dashDownloader, C.LENGTH_UNSET, C.LENGTH_UNSET, C.LENGTH_UNSET);
+
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    dashDownloader.init();
+    assertCounters(dashDownloader, C.LENGTH_UNSET, C.LENGTH_UNSET, C.LENGTH_UNSET);
+
+    // downloadRepresentations fails after downloading init data, segment 1 and 2 bytes in segment 2
+    try {
+      dashDownloader.download(null);
+      fail();
+    } catch (IOException e) {
+      // ignore
+    }
+    dashDownloader.init();
+    assertCounters(dashDownloader, 4, 2, 10 + 4 + 2);
+
+    dashDownloader.download(null);
+
+    assertCounters(dashDownloader, 4, 4, 10 + 4 + 5 + 6);
+  }
+
+  public void testListener() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    ProgressListener mockListener = Mockito.mock(ProgressListener.class);
+    dashDownloader.download(mockListener);
+    InOrder inOrder = Mockito.inOrder(mockListener);
+    inOrder.verify(mockListener).onDownloadProgress(dashDownloader, 0.0f, 0);
+    inOrder.verify(mockListener).onDownloadProgress(dashDownloader, 25.0f, 10);
+    inOrder.verify(mockListener).onDownloadProgress(dashDownloader, 50.0f, 14);
+    inOrder.verify(mockListener).onDownloadProgress(dashDownloader, 75.0f, 19);
+    inOrder.verify(mockListener).onDownloadProgress(dashDownloader, 100.0f, 25);
+    inOrder.verifyNoMoreInteractions();
+  }
+
+  public void testRemoveAll() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6)
+        .setRandomData("text_segment_1", 1)
+        .setRandomData("text_segment_2", 2)
+        .setRandomData("text_segment_3", 3);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+    dashDownloader.selectRepresentations(
+        new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0)});
+    dashDownloader.download(null);
+
+    dashDownloader.remove();
+
+    assertCacheEmpty(cache);
+  }
+
+  public void testRepresentationWithoutIndex() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD_NO_INDEX)
+        .setRandomData("test_segment_1", 4);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    dashDownloader.init();
+    try {
+      dashDownloader.download(null);
+      fail();
+    } catch (DownloadException e) {
+      // expected exception.
+    }
+    dashDownloader.remove();
+
+    assertCacheEmpty(cache);
+  }
+
+  public void testSelectRepresentationsClearsPreviousSelection() throws Exception {
+    FakeDataSet fakeDataSet = new FakeDataSet()
+        .setData(TEST_MPD_URI, TEST_MPD)
+        .setRandomData("audio_init_data", 10)
+        .setRandomData("audio_segment_1", 4)
+        .setRandomData("audio_segment_2", 5)
+        .setRandomData("audio_segment_3", 6);
+    DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
+
+    dashDownloader.selectRepresentations(
+        new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0)});
+    dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+    dashDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  private DashDownloader getDashDownloader(FakeDataSet fakeDataSet) {
+    Factory factory = new Factory(null).setFakeDataSet(fakeDataSet);
+    return new DashDownloader(TEST_MPD_URI, new DownloaderConstructorHelper(cache, factory));
+  }
+
+  private static void assertCounters(DashDownloader dashDownloader, int totalSegments,
+      int downloadedSegments, int downloadedBytes) {
+    assertEquals(totalSegments, dashDownloader.getTotalSegments());
+    assertEquals(downloadedSegments, dashDownloader.getDownloadedSegments());
+    assertEquals(downloadedBytes, dashDownloader.getDownloadedBytes());
+  }
+
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index 81b4a4ceed..35f3c2e129 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -64,7 +64,6 @@
   private CompositeSequenceableLoader sequenceableLoader;
   private DashManifest manifest;
   private int periodIndex;
-  private List<AdaptationSet> adaptationSets;
 
   public DashMediaPeriod(int id, DashManifest manifest, int periodIndex,
       DashChunkSource.Factory chunkSourceFactory,  int minLoadableRetryCount,
@@ -81,8 +80,8 @@ public DashMediaPeriod(int id, DashManifest manifest, int periodIndex,
     this.allocator = allocator;
     sampleStreams = newSampleStreamArray(0);
     sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
-    adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
-    Pair<TrackGroupArray, TrackGroupInfo[]> result = buildTrackGroups(adaptationSets);
+    Pair<TrackGroupArray, TrackGroupInfo[]> result =
+        buildTrackGroups(manifest.getPeriod(periodIndex).adaptationSets);
     trackGroups = result.first;
     trackGroupInfos = result.second;
   }
@@ -90,7 +89,6 @@ public DashMediaPeriod(int id, DashManifest manifest, int periodIndex,
   public void updateManifest(DashManifest manifest, int periodIndex) {
     this.manifest = manifest;
     this.periodIndex = periodIndex;
-    adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
     if (sampleStreams != null) {
       for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
         sampleStream.getChunkSource().updateManifest(manifest, periodIndex);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 315e87dcd3..c529fcab4b 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -76,8 +76,8 @@
 
   /**
    * The interval in milliseconds between invocations of
-   * {@link MediaSource.Listener#onSourceInfoRefreshed(Timeline, Object)} when the source's
-   * {@link Timeline} is changing dynamically (for example, for incomplete live streams).
+   * {@link MediaSource.Listener#onSourceInfoRefreshed(MediaSource, Timeline, Object)} when the
+   * source's {@link Timeline} is changing dynamically (for example, for incomplete live streams).
    */
   private static final int NOTIFY_MANIFEST_INTERVAL_MS = 5000;
   /**
@@ -527,7 +527,7 @@ private void processManifest(boolean scheduleRefresh) {
     DashTimeline timeline = new DashTimeline(manifest.availabilityStartTime, windowStartTimeMs,
         firstPeriodId, currentStartTimeUs, windowDurationUs, windowDefaultStartPositionUs,
         manifest);
-    sourceListener.onSourceInfoRefreshed(timeline, manifest);
+    sourceListener.onSourceInfoRefreshed(this, timeline, manifest);
 
     if (!sideloadedManifest) {
       // Remove any pending simulated refresh.
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
index 2febeb8c81..ed2f916b87 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
@@ -25,16 +25,15 @@
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
 import com.google.android.exoplayer2.source.chunk.InitializationChunk;
-import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
 import com.google.android.exoplayer2.source.dash.manifest.Period;
 import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
 import java.util.List;
@@ -48,66 +47,21 @@
    * Loads a DASH manifest.
    *
    * @param dataSource The {@link HttpDataSource} from which the manifest should be read.
-   * @param manifestUri The URI of the manifest to be read.
+   * @param uri The {@link Uri} of the manifest to be read.
    * @return An instance of {@link DashManifest}.
    * @throws IOException Thrown when there is an error while loading.
    */
-  public static DashManifest loadManifest(DataSource dataSource, String manifestUri)
+  public static DashManifest loadManifest(DataSource dataSource, Uri uri)
       throws IOException {
-    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
-        new DataSpec(Uri.parse(manifestUri), DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
-    try {
-      inputStream.open();
-      DashManifestParser parser = new DashManifestParser();
-      return parser.parse(dataSource.getUri(), inputStream);
-    } finally {
-      inputStream.close();
-    }
+    DataSpec dataSpec = new DataSpec(uri,
+        DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
+    ParsingLoadable<DashManifest> loadable = new ParsingLoadable<>(dataSource, dataSpec,
+        C.DATA_TYPE_MANIFEST, new DashManifestParser());
+    loadable.load();
+    return loadable.getResult();
   }
 
   /**
-   * Loads {@link DrmInitData} for a given manifest.
-   *
-   * @param dataSource The {@link HttpDataSource} from which data should be loaded.
-   * @param dashManifest The {@link DashManifest} of the DASH content.
-   * @return The loaded {@link DrmInitData}.
-   */
-  public static DrmInitData loadDrmInitData(DataSource dataSource, DashManifest dashManifest)
-      throws IOException, InterruptedException {
-    // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
-    // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
-    if (dashManifest.getPeriodCount() < 1) {
-      return null;
-    }
-    Period period = dashManifest.getPeriod(0);
-    int adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
-    if (adaptationSetIndex == C.INDEX_UNSET) {
-      adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_AUDIO);
-      if (adaptationSetIndex == C.INDEX_UNSET) {
-        return null;
-      }
-    }
-    AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
-    if (adaptationSet.representations.isEmpty()) {
-      return null;
-    }
-    Representation representation = adaptationSet.representations.get(0);
-    DrmInitData drmInitData = representation.format.drmInitData;
-    if (drmInitData == null) {
-      Format sampleFormat = DashUtil.loadSampleFormat(dataSource, representation);
-      if (sampleFormat != null) {
-        drmInitData = sampleFormat.drmInitData;
-      }
-      if (drmInitData == null) {
-        return null;
-      }
-    }
-    return drmInitData;
-  }
-
-  /**
-   * Loads initialization data for the {@code representation} and returns the sample {@link
-   * Format}.
    * Loads {@link DrmInitData} for a given period in a DASH manifest.
    *
    * @param dataSource The {@link HttpDataSource} from which data should be loaded.
@@ -118,9 +72,11 @@ public static DrmInitData loadDrmInitData(DataSource dataSource, DashManifest da
    */
   public static DrmInitData loadDrmInitData(DataSource dataSource, Period period)
       throws IOException, InterruptedException {
-    Representation representation = getFirstRepresentation(period, C.TRACK_TYPE_VIDEO);
+    int primaryTrackType = C.TRACK_TYPE_VIDEO;
+    Representation representation = getFirstRepresentation(period, primaryTrackType);
     if (representation == null) {
-      representation = getFirstRepresentation(period, C.TRACK_TYPE_AUDIO);
+      primaryTrackType = C.TRACK_TYPE_AUDIO;
+      representation = getFirstRepresentation(period, primaryTrackType);
       if (representation == null) {
         return null;
       }
@@ -131,7 +87,7 @@ public static DrmInitData loadDrmInitData(DataSource dataSource, Period period)
       // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
       return drmInitData;
     }
-    Format sampleFormat = DashUtil.loadSampleFormat(dataSource, representation);
+    Format sampleFormat = DashUtil.loadSampleFormat(dataSource, primaryTrackType, representation);
     return sampleFormat == null ? null : sampleFormat.drmInitData;
   }
 
@@ -139,15 +95,17 @@ public static DrmInitData loadDrmInitData(DataSource dataSource, Period period)
    * Loads initialization data for the {@code representation} and returns the sample {@link Format}.
    *
    * @param dataSource The source from which the data should be loaded.
+   * @param trackType The type of the representation. Typically one of the
+   *     {@link com.google.android.exoplayer2.C} {@code TRACK_TYPE_*} constants.
    * @param representation The representation which initialization chunk belongs to.
    * @return the sample {@link Format} of the given representation.
    * @throws IOException Thrown when there is an error while loading.
    * @throws InterruptedException Thrown if the thread was interrupted.
    */
-  public static Format loadSampleFormat(DataSource dataSource, Representation representation)
-      throws IOException, InterruptedException {
-    ChunkExtractorWrapper extractorWrapper = loadInitializationData(dataSource, representation,
-        false);
+  public static Format loadSampleFormat(DataSource dataSource, int trackType,
+      Representation representation) throws IOException, InterruptedException {
+    ChunkExtractorWrapper extractorWrapper = loadInitializationData(dataSource, trackType,
+        representation, false);
     return extractorWrapper == null ? null : extractorWrapper.getSampleFormats()[0];
   }
 
@@ -156,15 +114,18 @@ public static Format loadSampleFormat(DataSource dataSource, Representation repr
    * ChunkIndex}.
    *
    * @param dataSource The source from which the data should be loaded.
+   * @param trackType The type of the representation. Typically one of the
+   *     {@link com.google.android.exoplayer2.C} {@code TRACK_TYPE_*} constants.
    * @param representation The representation which initialization chunk belongs to.
-   * @return {@link ChunkIndex} of the given representation.
+   * @return The {@link ChunkIndex} of the given representation, or null if no initialization or
+   *     index data exists.
    * @throws IOException Thrown when there is an error while loading.
    * @throws InterruptedException Thrown if the thread was interrupted.
    */
-  public static ChunkIndex loadChunkIndex(DataSource dataSource, Representation representation)
-      throws IOException, InterruptedException {
-    ChunkExtractorWrapper extractorWrapper = loadInitializationData(dataSource, representation,
-        true);
+  public static ChunkIndex loadChunkIndex(DataSource dataSource, int trackType,
+      Representation representation) throws IOException, InterruptedException {
+    ChunkExtractorWrapper extractorWrapper = loadInitializationData(dataSource, trackType,
+        representation, true);
     return extractorWrapper == null ? null : (ChunkIndex) extractorWrapper.getSeekMap();
   }
 
@@ -173,6 +134,8 @@ public static ChunkIndex loadChunkIndex(DataSource dataSource, Representation re
    * returns a {@link ChunkExtractorWrapper} which contains the output.
    *
    * @param dataSource The source from which the data should be loaded.
+   * @param trackType The type of the representation. Typically one of the
+   *     {@link com.google.android.exoplayer2.C} {@code TRACK_TYPE_*} constants.
    * @param representation The representation which initialization chunk belongs to.
    * @param loadIndex Whether to load index data too.
    * @return A {@link ChunkExtractorWrapper} for the {@code representation}, or null if no
@@ -180,14 +143,13 @@ public static ChunkIndex loadChunkIndex(DataSource dataSource, Representation re
    * @throws IOException Thrown when there is an error while loading.
    * @throws InterruptedException Thrown if the thread was interrupted.
    */
-  private static ChunkExtractorWrapper loadInitializationData(DataSource dataSource,
-      Representation representation, boolean loadIndex)
-      throws IOException, InterruptedException {
+  private static ChunkExtractorWrapper loadInitializationData(DataSource dataSource, int trackType,
+      Representation representation, boolean loadIndex) throws IOException, InterruptedException {
     RangedUri initializationUri = representation.getInitializationUri();
     if (initializationUri == null) {
       return null;
     }
-    ChunkExtractorWrapper extractorWrapper = newWrappedExtractor(representation.format);
+    ChunkExtractorWrapper extractorWrapper = newWrappedExtractor(trackType, representation.format);
     RangedUri requestUri;
     if (loadIndex) {
       RangedUri indexUri = representation.getIndexUri();
@@ -219,12 +181,12 @@ private static void loadInitializationData(DataSource dataSource,
     initializationChunk.load();
   }
 
-  private static ChunkExtractorWrapper newWrappedExtractor(Format format) {
+  private static ChunkExtractorWrapper newWrappedExtractor(int trackType, Format format) {
     String mimeType = format.containerMimeType;
     boolean isWebm = mimeType.startsWith(MimeTypes.VIDEO_WEBM)
         || mimeType.startsWith(MimeTypes.AUDIO_WEBM);
     Extractor extractor = isWebm ? new MatroskaExtractor() : new FragmentedMp4Extractor();
-    return new ChunkExtractorWrapper(extractor, format);
+    return new ChunkExtractorWrapper(extractor, trackType, format);
   }
 
   private static Representation getFirstRepresentation(Period period, int type) {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index dd62d47621..1eac1b5616 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -95,6 +95,7 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
   private int periodIndex;
   private IOException fatalError;
   private boolean missingLastSegment;
+  private long liveEdgeTimeUs;
 
   /**
    * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
@@ -130,12 +131,13 @@ public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
     this.maxSegmentsPerLoad = maxSegmentsPerLoad;
 
     long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
+    liveEdgeTimeUs = C.TIME_UNSET;
     List<Representation> representations = getRepresentations();
     representationHolders = new RepresentationHolder[trackSelection.length()];
     for (int i = 0; i < representationHolders.length; i++) {
       Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
-      representationHolders[i] = new RepresentationHolder(periodDurationUs, representation,
-          enableEventMessageTrack, enableCea608Track);
+      representationHolders[i] = new RepresentationHolder(periodDurationUs, trackType,
+          representation, enableEventMessageTrack, enableCea608Track);
     }
   }
 
@@ -173,13 +175,15 @@ public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaCh
   }
 
   @Override
-  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out) {
+  public void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+      ChunkHolder out) {
     if (fatalError != null) {
       return;
     }
 
-    long bufferedDurationUs = previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
-    trackSelection.updateSelectedTrack(bufferedDurationUs);
+    long bufferedDurationUs = loadPositionUs - playbackPositionUs;
+    long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
+    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
 
     RepresentationHolder representationHolder =
         representationHolders[trackSelection.getSelectedIndex()];
@@ -203,7 +207,6 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
       }
     }
 
-    long nowUs = getNowUnixTimeUs();
     int availableSegmentCount = representationHolder.getSegmentCount();
     if (availableSegmentCount == 0) {
       // The index doesn't define any segments.
@@ -216,24 +219,26 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
     if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
       // The index is itself unbounded. We need to use the current time to calculate the range of
       // available segments.
-      long liveEdgeTimeUs = nowUs - manifest.availabilityStartTime * 1000;
-      long periodStartUs = manifest.getPeriod(periodIndex).startMs * 1000;
+      long liveEdgeTimeUs = getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTime);
+      long periodStartUs = C.msToUs(manifest.getPeriod(periodIndex).startMs);
       long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
       if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
-        long bufferDepthUs = manifest.timeShiftBufferDepth * 1000;
+        long bufferDepthUs = C.msToUs(manifest.timeShiftBufferDepth);
         firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
             representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
       }
-      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
+      // getSegmentNum(liveEdgeTimeInPeriodUs) will not be completed yet, so subtract one to get the
       // index of the last completed segment.
       lastAvailableSegmentNum = representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
     } else {
       lastAvailableSegmentNum = firstAvailableSegmentNum + availableSegmentCount - 1;
     }
 
+    updateLiveEdgeTimeUs(representationHolder, lastAvailableSegmentNum);
+
     int segmentNum;
     if (previous == null) {
-      segmentNum = Util.constrainValue(representationHolder.getSegmentNum(playbackPositionUs),
+      segmentNum = Util.constrainValue(representationHolder.getSegmentNum(loadPositionUs),
           firstAvailableSegmentNum, lastAvailableSegmentNum);
     } else {
       segmentNum = previous.getNextChunkIndex();
@@ -300,7 +305,7 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
         trackSelection.indexOf(chunk.trackFormat), e);
   }
 
-  // Private methods.
+  // Internal methods.
 
   private ArrayList<Representation> getRepresentations() {
     List<AdaptationSet> manifestAdapationSets = manifest.getPeriod(periodIndex).adaptationSets;
@@ -311,6 +316,12 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
     return representations;
   }
 
+  private void updateLiveEdgeTimeUs(RepresentationHolder representationHolder,
+      int lastAvailableSegmentNum) {
+    liveEdgeTimeUs = manifest.dynamic
+        ? representationHolder.getSegmentEndTimeUs(lastAvailableSegmentNum) : C.TIME_UNSET;
+  }
+
   private long getNowUnixTimeUs() {
     if (elapsedRealtimeOffsetMs != 0) {
       return (SystemClock.elapsedRealtime() + elapsedRealtimeOffsetMs) * 1000;
@@ -319,7 +330,12 @@ private long getNowUnixTimeUs() {
     }
   }
 
-  private static Chunk newInitializationChunk(RepresentationHolder representationHolder,
+  private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
+    boolean resolveTimeToLiveEdgePossible = manifest.dynamic && liveEdgeTimeUs != C.TIME_UNSET;
+    return resolveTimeToLiveEdgePossible ? liveEdgeTimeUs - playbackPositionUs : C.TIME_UNSET;
+  }
+
+  protected static Chunk newInitializationChunk(RepresentationHolder representationHolder,
       DataSource dataSource, Format trackFormat, int trackSelectionReason,
       Object trackSelectionData, RangedUri initializationUri, RangedUri indexUri) {
     RangedUri requestUri;
@@ -340,7 +356,7 @@ private static Chunk newInitializationChunk(RepresentationHolder representationH
         trackSelectionReason, trackSelectionData, representationHolder.extractorWrapper);
   }
 
-  private static Chunk newMediaChunk(RepresentationHolder representationHolder,
+  protected static Chunk newMediaChunk(RepresentationHolder representationHolder,
       DataSource dataSource, int trackType, Format trackFormat, int trackSelectionReason,
       Object trackSelectionData, int firstSegmentNum, int maxSegmentCount) {
     Representation representation = representationHolder.representation;
@@ -390,8 +406,8 @@ private static Chunk newMediaChunk(RepresentationHolder representationHolder,
     private long periodDurationUs;
     private int segmentNumShift;
 
-    /* package */ RepresentationHolder(long periodDurationUs, Representation representation,
-        boolean enableEventMessageTrack, boolean enableCea608Track) {
+    /* package */ RepresentationHolder(long periodDurationUs, int trackType,
+        Representation representation, boolean enableEventMessageTrack, boolean enableCea608Track) {
       this.periodDurationUs = periodDurationUs;
       this.representation = representation;
       String containerMimeType = representation.format.containerMimeType;
@@ -415,7 +431,7 @@ private static Chunk newMediaChunk(RepresentationHolder representationHolder,
         }
         // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
         // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
-        extractorWrapper = new ChunkExtractorWrapper(extractor, representation.format);
+        extractorWrapper = new ChunkExtractorWrapper(extractor, trackType, representation.format);
       }
       segmentIndex = representation.getIndex();
     }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 53115a7a0e..7ffb429784 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -238,6 +238,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     int audioChannels = Format.NO_VALUE;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", Format.NO_VALUE);
     String language = xpp.getAttributeValue(null, "lang");
+    String drmSchemeType = null;
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
     ArrayList<Descriptor> inbandEventStreams = new ArrayList<>();
     ArrayList<Descriptor> accessibilityDescriptors = new ArrayList<>();
@@ -254,9 +255,12 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
           seenFirstBaseUrl = true;
         }
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentProtection")) {
-        SchemeData contentProtection = parseContentProtection(xpp);
-        if (contentProtection != null) {
-          drmSchemeDatas.add(contentProtection);
+        Pair<String, SchemeData> contentProtection = parseContentProtection(xpp);
+        if (contentProtection.first != null) {
+          drmSchemeType = contentProtection.first;
+        }
+        if (contentProtection.second != null) {
+          drmSchemeDatas.add(contentProtection.second);
         }
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentComponent")) {
         language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
@@ -293,7 +297,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     List<Representation> representations = new ArrayList<>(representationInfos.size());
     for (int i = 0; i < representationInfos.size(); i++) {
       representations.add(buildRepresentation(representationInfos.get(i), contentId,
-          drmSchemeDatas, inbandEventStreams));
+          drmSchemeType, drmSchemeDatas, inbandEventStreams));
     }
 
     return buildAdaptationSet(id, contentType, representations, accessibilityDescriptors,
@@ -311,9 +315,9 @@ protected int parseContentType(XmlPullParser xpp) {
     String contentType = xpp.getAttributeValue(null, "contentType");
     return TextUtils.isEmpty(contentType) ? C.TRACK_TYPE_UNKNOWN
         : MimeTypes.BASE_TYPE_AUDIO.equals(contentType) ? C.TRACK_TYPE_AUDIO
-        : MimeTypes.BASE_TYPE_VIDEO.equals(contentType) ? C.TRACK_TYPE_VIDEO
-        : MimeTypes.BASE_TYPE_TEXT.equals(contentType) ? C.TRACK_TYPE_TEXT
-        : C.TRACK_TYPE_UNKNOWN;
+            : MimeTypes.BASE_TYPE_VIDEO.equals(contentType) ? C.TRACK_TYPE_VIDEO
+                : MimeTypes.BASE_TYPE_TEXT.equals(contentType) ? C.TRACK_TYPE_TEXT
+                    : C.TRACK_TYPE_UNKNOWN;
   }
 
   protected int getContentType(Format format) {
@@ -336,41 +340,64 @@ protected int getContentType(Format format) {
    * @param xpp The parser from which to read.
    * @throws XmlPullParserException If an error occurs parsing the element.
    * @throws IOException If an error occurs reading the element.
-   * @return {@link SchemeData} parsed from the ContentProtection element, or null if the element is
-   *     unsupported.
+   * @return The scheme type and/or {@link SchemeData} parsed from the ContentProtection element.
+   *     Either or both may be null, depending on the ContentProtection element being parsed.
    */
-  protected SchemeData parseContentProtection(XmlPullParser xpp) throws XmlPullParserException,
-      IOException {
-    String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
-    boolean isPlayReady = "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95".equals(schemeIdUri);
-    String schemeType = xpp.getAttributeValue(null, "value");
+  protected Pair<String, SchemeData> parseContentProtection(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    String schemeType = null;
     byte[] data = null;
     UUID uuid = null;
     boolean requiresSecureDecoder = false;
+
+    String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
+    if (schemeIdUri != null) {
+      switch (Util.toLowerInvariant(schemeIdUri)) {
+        case "urn:mpeg:dash:mp4protection:2011":
+          schemeType = xpp.getAttributeValue(null, "value");
+          String defaultKid = xpp.getAttributeValue(null, "cenc:default_KID");
+          if (defaultKid != null && !"00000000-0000-0000-0000-000000000000".equals(defaultKid)) {
+            UUID keyId = UUID.fromString(defaultKid);
+            data = PsshAtomUtil.buildPsshAtom(C.COMMON_PSSH_UUID, new UUID[] {keyId}, null);
+            uuid = C.COMMON_PSSH_UUID;
+          }
+          break;
+        case "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95":
+          uuid = C.PLAYREADY_UUID;
+          break;
+        case "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed":
+          uuid = C.WIDEVINE_UUID;
+          break;
+        default:
+          break;
+      }
+    }
+
     do {
       xpp.next();
-      if (data == null && XmlPullParserUtil.isStartTag(xpp, "cenc:pssh")
-          && xpp.next() == XmlPullParser.TEXT) {
-        // The cenc:pssh element is defined in 23001-7:2015.
-        data = Base64.decode(xpp.getText(), Base64.DEFAULT);
-        uuid = PsshAtomUtil.parseUuid(data);
-        if (uuid == null) {
-          Log.w(TAG, "Skipping malformed cenc:pssh data");
-          data = null;
-        }
-      } else if (data == null && isPlayReady && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
-          && xpp.next() == XmlPullParser.TEXT) {
-        // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
-        data = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID,
-            Base64.decode(xpp.getText(), Base64.DEFAULT));
-        uuid = C.PLAYREADY_UUID;
-      } else if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
+      if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
         String robustnessLevel = xpp.getAttributeValue(null, "robustness_level");
         requiresSecureDecoder = robustnessLevel != null && robustnessLevel.startsWith("HW");
+      } else if (data == null) {
+        if (XmlPullParserUtil.isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
+          // The cenc:pssh element is defined in 23001-7:2015.
+          data = Base64.decode(xpp.getText(), Base64.DEFAULT);
+          uuid = PsshAtomUtil.parseUuid(data);
+          if (uuid == null) {
+            Log.w(TAG, "Skipping malformed cenc:pssh data");
+            data = null;
+          }
+        } else if (uuid == C.PLAYREADY_UUID && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
+            && xpp.next() == XmlPullParser.TEXT) {
+          // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
+          data = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID,
+              Base64.decode(xpp.getText(), Base64.DEFAULT));
+        }
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "ContentProtection"));
-    return data != null
-        ? new SchemeData(uuid, schemeType, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder) : null;
+    SchemeData schemeData = uuid != null
+        ? new SchemeData(uuid, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder) : null;
+    return Pair.create(schemeType, schemeData);
   }
 
   /**
@@ -422,6 +449,7 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
     float frameRate = parseFrameRate(xpp, adaptationSetFrameRate);
     int audioChannels = adaptationSetAudioChannels;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", adaptationSetAudioSamplingRate);
+    String drmSchemeType = null;
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
     ArrayList<Descriptor> inbandEventStreams = new ArrayList<>();
 
@@ -442,9 +470,12 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentProtection")) {
-        SchemeData contentProtection = parseContentProtection(xpp);
-        if (contentProtection != null) {
-          drmSchemeDatas.add(contentProtection);
+        Pair<String, SchemeData> contentProtection = parseContentProtection(xpp);
+        if (contentProtection.first != null) {
+          drmSchemeType = contentProtection.first;
+        }
+        if (contentProtection.second != null) {
+          drmSchemeDatas.add(contentProtection.second);
         }
       } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
@@ -456,7 +487,8 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
         adaptationSetAccessibilityDescriptors, codecs);
     segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase();
 
-    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeDatas, inbandEventStreams);
+    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeType, drmSchemeDatas,
+        inbandEventStreams);
   }
 
   protected Format buildFormat(String id, String containerMimeType, int width, int height,
@@ -489,18 +521,22 @@ protected Format buildFormat(String id, String containerMimeType, int width, int
   }
 
   protected Representation buildRepresentation(RepresentationInfo representationInfo,
-      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas,
+      String contentId, String extraDrmSchemeType, ArrayList<SchemeData> extraDrmSchemeDatas,
       ArrayList<Descriptor> extraInbandEventStreams) {
     Format format = representationInfo.format;
+    String drmSchemeType = representationInfo.drmSchemeType != null
+        ? representationInfo.drmSchemeType : extraDrmSchemeType;
     ArrayList<SchemeData> drmSchemeDatas = representationInfo.drmSchemeDatas;
     drmSchemeDatas.addAll(extraDrmSchemeDatas);
     if (!drmSchemeDatas.isEmpty()) {
-      format = format.copyWithDrmInitData(new DrmInitData(drmSchemeDatas));
+      filterRedundantIncompleteSchemeDatas(drmSchemeDatas);
+      DrmInitData drmInitData = new DrmInitData(drmSchemeType, drmSchemeDatas);
+      format = format.copyWithDrmInitData(drmInitData);
     }
-    ArrayList<Descriptor> inbandEventStremas = representationInfo.inbandEventStreams;
-    inbandEventStremas.addAll(extraInbandEventStreams);
+    ArrayList<Descriptor> inbandEventStreams = representationInfo.inbandEventStreams;
+    inbandEventStreams.addAll(extraInbandEventStreams);
     return Representation.newInstance(contentId, Representation.REVISION_ID_DEFAULT, format,
-        representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStremas);
+        representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStreams);
   }
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
@@ -690,7 +726,9 @@ protected int parseAudioChannelConfiguration(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     String schemeIdUri = parseString(xpp, "schemeIdUri", null);
     int audioChannels = "urn:mpeg:dash:23003:3:audio_channel_configuration:2011".equals(schemeIdUri)
-        ? parseInt(xpp, "value", Format.NO_VALUE) : Format.NO_VALUE;
+        ? parseInt(xpp, "value", Format.NO_VALUE)
+        : ("tag:dolby.com,2014:dash:audio_channel_configuration:2011".equals(schemeIdUri)
+        ? parseDolbyChannelConfiguration(xpp) : Format.NO_VALUE);
     do {
       xpp.next();
     } while (!XmlPullParserUtil.isEndTag(xpp, "AudioChannelConfiguration"));
@@ -699,6 +737,25 @@ protected int parseAudioChannelConfiguration(XmlPullParser xpp)
 
   // Utility methods.
 
+  /**
+   * Removes unnecessary {@link SchemeData}s with null {@link SchemeData#data}.
+   */
+  private static void filterRedundantIncompleteSchemeDatas(ArrayList<SchemeData> schemeDatas) {
+    for (int i = schemeDatas.size() - 1; i >= 0; i--) {
+      SchemeData schemeData = schemeDatas.get(i);
+      if (!schemeData.hasData()) {
+        for (int j = 0; j < schemeDatas.size(); j++) {
+          if (schemeDatas.get(j).canReplace(schemeData)) {
+            // schemeData is incomplete, but there is another matching SchemeData which does contain
+            // data, so we remove the incomplete one.
+            schemeDatas.remove(i);
+            break;
+          }
+        }
+      }
+    }
+  }
+
   /**
    * Derives a sample mimeType from a container mimeType and codecs attribute.
    *
@@ -901,19 +958,50 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
     return value == null ? defaultValue : value;
   }
 
+  /**
+   * Parses the number of channels from the value attribute of an AudioElementConfiguration with
+   * schemeIdUri "tag:dolby.com,2014:dash:audio_channel_configuration:2011", as defined by table E.5
+   * in ETSI TS 102 366.
+   *
+   * @param xpp The parser from which to read.
+   * @return The parsed number of channels, or {@link Format#NO_VALUE} if the channel count could
+   *     not be parsed.
+   */
+  protected static int parseDolbyChannelConfiguration(XmlPullParser xpp) {
+    String value = Util.toLowerInvariant(xpp.getAttributeValue(null, "value"));
+    if (value == null) {
+      return Format.NO_VALUE;
+    }
+    switch (value) {
+      case "4000":
+        return 1;
+      case "a000":
+        return 2;
+      case "f801":
+        return 6;
+      case "fa01":
+        return 8;
+      default:
+        return Format.NO_VALUE;
+    }
+  }
+
   private static final class RepresentationInfo {
 
     public final Format format;
     public final String baseUrl;
     public final SegmentBase segmentBase;
+    public final String drmSchemeType;
     public final ArrayList<SchemeData> drmSchemeDatas;
     public final ArrayList<Descriptor> inbandEventStreams;
 
     public RepresentationInfo(Format format, String baseUrl, SegmentBase segmentBase,
-        ArrayList<SchemeData> drmSchemeDatas, ArrayList<Descriptor> inbandEventStreams) {
+        String drmSchemeType, ArrayList<SchemeData> drmSchemeDatas,
+        ArrayList<Descriptor> inbandEventStreams) {
       this.format = format;
       this.baseUrl = baseUrl;
       this.segmentBase = segmentBase;
+      this.drmSchemeType = drmSchemeType;
       this.drmSchemeDatas = drmSchemeDatas;
       this.inbandEventStreams = inbandEventStreams;
     }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
index cf17a081d7..4ce1d06700 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
@@ -80,4 +80,27 @@ public int compareTo(@NonNull RepresentationKey o) {
     return result;
   }
 
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+
+    RepresentationKey that = (RepresentationKey) o;
+    return periodIndex == that.periodIndex
+        && adaptationSetIndex == that.adaptationSetIndex
+        && representationIndex == that.representationIndex;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = periodIndex;
+    result = 31 * result + adaptationSetIndex;
+    result = 31 * result + representationIndex;
+    return result;
+  }
+
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
new file mode 100644
index 0000000000..4c07e4874e
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.offline;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.offline.DownloadException;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.SegmentDownloader;
+import com.google.android.exoplayer2.source.dash.DashSegmentIndex;
+import com.google.android.exoplayer2.source.dash.DashUtil;
+import com.google.android.exoplayer2.source.dash.DashWrappingSegmentIndex;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Helper class to download DASH streams.
+ *
+ * <p>Except {@link #getTotalSegments()}, {@link #getDownloadedSegments()} and
+ * {@link #getDownloadedBytes()}, this class isn't thread safe.
+ *
+ * <p>Example usage:
+ *
+ * <pre>
+ * {@code
+ * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor());
+ * DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
+ * DownloaderConstructorHelper constructorHelper =
+ *     new DownloaderConstructorHelper(cache, factory);
+ * DashDownloader dashDownloader = new DashDownloader(manifestUrl, constructorHelper);
+ * // Select the first representation of the first adaptation set of the first period
+ * dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
+ * dashDownloader.download(new ProgressListener() {
+ *   @Override
+ *   public void onDownloadProgress(Downloader downloader, float downloadPercentage,
+ *       long downloadedBytes) {
+ *     // Invoked periodically during the download.
+ *   }
+ * });
+ * // Access downloaded data using CacheDataSource
+ * CacheDataSource cacheDataSource =
+ *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);}
+ * </pre>
+ */
+public final class DashDownloader extends SegmentDownloader<DashManifest, RepresentationKey> {
+
+  /**
+   * @see SegmentDownloader#SegmentDownloader(Uri, DownloaderConstructorHelper)
+   */
+  public DashDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHelper)  {
+    super(manifestUri, constructorHelper);
+  }
+
+  @Override
+  public DashManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
+    return DashUtil.loadManifest(dataSource, uri);
+  }
+
+  @Override
+  protected List<Segment> getAllSegments(DataSource dataSource, DashManifest manifest,
+      boolean allowIndexLoadErrors) throws InterruptedException, IOException {
+    ArrayList<Segment> segments = new ArrayList<>();
+    for (int periodIndex = 0; periodIndex < manifest.getPeriodCount(); periodIndex++) {
+      List<AdaptationSet> adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
+      for (int adaptationIndex = 0; adaptationIndex < adaptationSets.size(); adaptationIndex++) {
+        AdaptationSet adaptationSet = adaptationSets.get(adaptationIndex);
+        RepresentationKey[] keys = new RepresentationKey[adaptationSet.representations.size()];
+        for (int i = 0; i < keys.length; i++) {
+          keys[i] = new RepresentationKey(periodIndex, adaptationIndex, i);
+        }
+        segments.addAll(getSegments(dataSource, manifest, keys, allowIndexLoadErrors));
+      }
+    }
+    return segments;
+  }
+
+  @Override
+  protected List<Segment> getSegments(DataSource dataSource, DashManifest manifest,
+      RepresentationKey[] keys, boolean allowIndexLoadErrors)
+      throws InterruptedException, IOException {
+    ArrayList<Segment> segments = new ArrayList<>();
+    for (RepresentationKey key : keys) {
+      DashSegmentIndex index;
+      try {
+        index = getSegmentIndex(dataSource, manifest, key);
+        if (index == null) {
+          // Loading succeeded but there was no index. This is always a failure.
+          throw new DownloadException("No index for representation: " + key);
+        }
+      } catch (IOException e) {
+        if (allowIndexLoadErrors) {
+          // Loading failed, but load errors are allowed. Advance to the next key.
+          continue;
+        } else {
+          throw e;
+        }
+      }
+
+      int segmentCount = index.getSegmentCount(C.TIME_UNSET);
+      if (segmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
+        throw new DownloadException("Unbounded index for representation: " + key);
+      }
+
+      Period period = manifest.getPeriod(key.periodIndex);
+      Representation representation = period.adaptationSets.get(key.adaptationSetIndex)
+          .representations.get(key.representationIndex);
+      long startUs = C.msToUs(period.startMs);
+      String baseUrl = representation.baseUrl;
+      RangedUri initializationUri = representation.getInitializationUri();
+      if (initializationUri != null) {
+        addSegment(segments, startUs, baseUrl, initializationUri);
+      }
+      RangedUri indexUri = representation.getIndexUri();
+      if (indexUri != null) {
+        addSegment(segments, startUs, baseUrl, indexUri);
+      }
+
+      int firstSegmentNum = index.getFirstSegmentNum();
+      int lastSegmentNum = firstSegmentNum + segmentCount - 1;
+      for (int j = firstSegmentNum; j <= lastSegmentNum; j++) {
+        addSegment(segments, startUs + index.getTimeUs(j), baseUrl, index.getSegmentUrl(j));
+      }
+    }
+    return segments;
+  }
+
+  /**
+   * Returns DashSegmentIndex for given representation.
+   */
+  private DashSegmentIndex getSegmentIndex(DataSource dataSource, DashManifest manifest,
+      RepresentationKey key) throws IOException, InterruptedException {
+    AdaptationSet adaptationSet = manifest.getPeriod(key.periodIndex).adaptationSets.get(
+        key.adaptationSetIndex);
+    Representation representation = adaptationSet.representations.get(key.representationIndex);
+    DashSegmentIndex index = representation.getIndex();
+    if (index != null) {
+      return index;
+    }
+    ChunkIndex seekMap = DashUtil.loadChunkIndex(dataSource, adaptationSet.type, representation);
+    return seekMap == null ? null : new DashWrappingSegmentIndex(seekMap);
+  }
+
+  private static void addSegment(ArrayList<Segment> segments, long startTimeUs, String baseUrl,
+      RangedUri rangedUri) {
+    DataSpec dataSpec = new DataSpec(rangedUri.resolveUri(baseUrl), rangedUri.start,
+        rangedUri.length, null);
+    segments.add(new Segment(startTimeUs, dataSpec));
+  }
+
+}
diff --git a/library/hls/build.gradle b/library/hls/build.gradle
index ac77725ca5..5471eacec6 100644
--- a/library/hls/build.gradle
+++ b/library/hls/build.gradle
@@ -35,6 +35,7 @@ android {
 dependencies {
     compile project(modulePrefix + 'library-core')
     compile 'com.android.support:support-annotations:' + supportLibraryVersion
+    androidTestCompile project(modulePrefix + 'testutils')
     androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
     androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
diff --git a/library/hls/src/androidTest/AndroidManifest.xml b/library/hls/src/androidTest/AndroidManifest.xml
index dcf6c2f940..1abbcad810 100644
--- a/library/hls/src/androidTest/AndroidManifest.xml
+++ b/library/hls/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.source.hls.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java
new file mode 100644
index 0000000000..ec70fb1200
--- /dev/null
+++ b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.offline;
+
+/**
+ * Data for HLS downloading tests.
+ */
+/* package */ interface HlsDownloadTestData {
+
+  String MASTER_PLAYLIST_URI = "test.m3u8";
+
+  String MEDIA_PLAYLIST_0_DIR = "gear0/";
+  String MEDIA_PLAYLIST_0_URI = MEDIA_PLAYLIST_0_DIR + "prog_index.m3u8";
+  String MEDIA_PLAYLIST_1_DIR = "gear1/";
+  String MEDIA_PLAYLIST_1_URI = MEDIA_PLAYLIST_1_DIR + "prog_index.m3u8";
+  String MEDIA_PLAYLIST_2_DIR = "gear2/";
+  String MEDIA_PLAYLIST_2_URI = MEDIA_PLAYLIST_2_DIR + "prog_index.m3u8";
+  String MEDIA_PLAYLIST_3_DIR = "gear3/";
+  String MEDIA_PLAYLIST_3_URI = MEDIA_PLAYLIST_3_DIR + "prog_index.m3u8";
+
+  byte[] MASTER_PLAYLIST_DATA =
+      ("#EXTM3U\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=232370,CODECS=\"mp4a.40.2, avc1.4d4015\"\n"
+          + MEDIA_PLAYLIST_1_URI + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=649879,CODECS=\"mp4a.40.2, avc1.4d401e\"\n"
+          + MEDIA_PLAYLIST_2_URI + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=991714,CODECS=\"mp4a.40.2, avc1.4d401e\"\n"
+          + MEDIA_PLAYLIST_3_URI + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=41457,CODECS=\"mp4a.40.2\"\n"
+          + MEDIA_PLAYLIST_0_URI).getBytes();
+
+  byte[] MEDIA_PLAYLIST_DATA =
+      ("#EXTM3U\n"
+          + "#EXT-X-TARGETDURATION:10\n"
+          + "#EXT-X-VERSION:3\n"
+          + "#EXT-X-MEDIA-SEQUENCE:0\n"
+          + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+          + "#EXTINF:9.97667,\n"
+          + "fileSequence0.ts\n"
+          + "#EXTINF:9.97667,\n"
+          + "fileSequence1.ts\n"
+          + "#EXTINF:9.97667,\n"
+          + "fileSequence2.ts\n"
+          + "#EXT-X-ENDLIST").getBytes();
+
+  String ENC_MEDIA_PLAYLIST_URI = "enc_index.m3u8";
+
+  byte[] ENC_MEDIA_PLAYLIST_DATA =
+      ("#EXTM3U\n"
+          + "#EXT-X-TARGETDURATION:10\n"
+          + "#EXT-X-VERSION:3\n"
+          + "#EXT-X-MEDIA-SEQUENCE:0\n"
+          + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+          + "#EXT-X-KEY:METHOD=AES-128,URI=\"enc.key\"\n"
+          + "#EXTINF:9.97667,\n"
+          + "fileSequence0.ts\n"
+          + "#EXTINF:9.97667,\n"
+          + "fileSequence1.ts\n"
+          + "#EXT-X-KEY:METHOD=AES-128,URI=\"enc2.key\"\n"
+          + "#EXTINF:9.97667,\n"
+          + "fileSequence2.ts\n"
+          + "#EXT-X-ENDLIST").getBytes();
+
+}
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
new file mode 100644
index 0000000000..ebf73ebfd7
--- /dev/null
+++ b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.offline;
+
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.ENC_MEDIA_PLAYLIST_DATA;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.ENC_MEDIA_PLAYLIST_URI;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MASTER_PLAYLIST_DATA;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MASTER_PLAYLIST_URI;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_0_DIR;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_0_URI;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_1_DIR;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_1_URI;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_2_DIR;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_2_URI;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_3_DIR;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_3_URI;
+import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_DATA;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
+import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
+
+import android.net.Uri;
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.testutil.FakeDataSet;
+import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+
+/** Unit tests for {@link HlsDownloader}. */
+public class HlsDownloaderTest extends InstrumentationTestCase {
+
+  private SimpleCache cache;
+  private File tempFolder;
+  private FakeDataSet fakeDataSet;
+  private HlsDownloader hlsDownloader;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
+
+    fakeDataSet = new FakeDataSet()
+        .setData(MASTER_PLAYLIST_URI, MASTER_PLAYLIST_DATA)
+        .setData(MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_DATA)
+        .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts", 10)
+        .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts", 11)
+        .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts", 12)
+        .setData(MEDIA_PLAYLIST_2_URI, MEDIA_PLAYLIST_DATA)
+        .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence0.ts", 13)
+        .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence1.ts", 14)
+        .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence2.ts", 15);
+    hlsDownloader = getHlsDownloader(MASTER_PLAYLIST_URI);
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    Util.recursiveDelete(tempFolder);
+    super.tearDown();
+  }
+
+  public void testDownloadManifest() throws Exception {
+    HlsMasterPlaylist manifest = hlsDownloader.getManifest();
+
+    assertNotNull(manifest);
+    assertCachedData(cache, fakeDataSet, MASTER_PLAYLIST_URI);
+  }
+
+  public void testSelectRepresentationsClearsPreviousSelection() throws Exception {
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_2_URI});
+    hlsDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet, MASTER_PLAYLIST_URI, MEDIA_PLAYLIST_2_URI,
+        MEDIA_PLAYLIST_2_DIR + "fileSequence0.ts",
+        MEDIA_PLAYLIST_2_DIR + "fileSequence1.ts",
+        MEDIA_PLAYLIST_2_DIR + "fileSequence2.ts");
+  }
+
+  public void testCounterMethods() throws Exception {
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    hlsDownloader.download(null);
+
+    assertEquals(4, hlsDownloader.getTotalSegments());
+    assertEquals(4, hlsDownloader.getDownloadedSegments());
+    assertEquals(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12, hlsDownloader.getDownloadedBytes());
+  }
+
+  public void testInitStatus() throws Exception {
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    hlsDownloader.download(null);
+
+    HlsDownloader newHlsDownloader =
+        getHlsDownloader(MASTER_PLAYLIST_URI);
+    newHlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    newHlsDownloader.init();
+
+    assertEquals(4, newHlsDownloader.getTotalSegments());
+    assertEquals(4, newHlsDownloader.getDownloadedSegments());
+    assertEquals(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12, newHlsDownloader.getDownloadedBytes());
+  }
+
+  public void testDownloadRepresentation() throws Exception {
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    hlsDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet, MASTER_PLAYLIST_URI, MEDIA_PLAYLIST_1_URI,
+        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+  }
+
+  public void testDownloadMultipleRepresentations() throws Exception {
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_2_URI});
+    hlsDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  public void testDownloadAllRepresentations() throws Exception {
+    // Add data for the rest of the playlists
+    fakeDataSet.setData(MEDIA_PLAYLIST_0_URI, MEDIA_PLAYLIST_DATA)
+        .setRandomData(MEDIA_PLAYLIST_0_DIR + "fileSequence0.ts", 10)
+        .setRandomData(MEDIA_PLAYLIST_0_DIR + "fileSequence1.ts", 11)
+        .setRandomData(MEDIA_PLAYLIST_0_DIR + "fileSequence2.ts", 12)
+        .setData(MEDIA_PLAYLIST_3_URI, MEDIA_PLAYLIST_DATA)
+        .setRandomData(MEDIA_PLAYLIST_3_DIR + "fileSequence0.ts", 13)
+        .setRandomData(MEDIA_PLAYLIST_3_DIR + "fileSequence1.ts", 14)
+        .setRandomData(MEDIA_PLAYLIST_3_DIR + "fileSequence2.ts", 15);
+    hlsDownloader = getHlsDownloader(MASTER_PLAYLIST_URI);
+
+    // hlsDownloader.selectRepresentations() isn't called
+    hlsDownloader.download(null);
+    assertCachedData(cache, fakeDataSet);
+    hlsDownloader.remove();
+
+    // select something random
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    // clear selection
+    hlsDownloader.selectRepresentations(null);
+    hlsDownloader.download(null);
+    assertCachedData(cache, fakeDataSet);
+    hlsDownloader.remove();
+
+    hlsDownloader.selectRepresentations(new String[0]);
+    hlsDownloader.download(null);
+    assertCachedData(cache, fakeDataSet);
+    hlsDownloader.remove();
+  }
+
+  public void testRemoveAll() throws Exception {
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_2_URI});
+    hlsDownloader.download(null);
+    hlsDownloader.remove();
+
+    assertCacheEmpty(cache);
+  }
+
+  public void testDownloadMediaPlaylist() throws Exception {
+    hlsDownloader = getHlsDownloader(MEDIA_PLAYLIST_1_URI);
+    hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
+    hlsDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet, MEDIA_PLAYLIST_1_URI,
+        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+  }
+
+  public void testDownloadEncMediaPlaylist() throws Exception {
+    fakeDataSet = new FakeDataSet()
+        .setData(ENC_MEDIA_PLAYLIST_URI, ENC_MEDIA_PLAYLIST_DATA)
+        .setRandomData("enc.key", 8)
+        .setRandomData("enc2.key", 9)
+        .setRandomData("fileSequence0.ts", 10)
+        .setRandomData("fileSequence1.ts", 11)
+        .setRandomData("fileSequence2.ts", 12);
+    hlsDownloader =
+        getHlsDownloader(ENC_MEDIA_PLAYLIST_URI);
+    hlsDownloader.selectRepresentations(new String[] {ENC_MEDIA_PLAYLIST_URI});
+    hlsDownloader.download(null);
+
+    assertCachedData(cache, fakeDataSet);
+  }
+
+  private HlsDownloader getHlsDownloader(String mediaPlaylistUri) {
+    Factory factory = new Factory(null).setFakeDataSet(fakeDataSet);
+    return new HlsDownloader(Uri.parse(mediaPlaylistUri),
+        new DownloaderConstructorHelper(cache, factory));
+  }
+
+}
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index f835c87466..8b0d76d2e5 100644
--- a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -28,7 +28,7 @@
 import junit.framework.TestCase;
 
 /**
- * Test for {@link HlsMasterPlaylistParserTest}
+ * Test for {@link HlsMasterPlaylistParserTest}.
  */
 public class HlsMasterPlaylistParserTest extends TestCase {
 
@@ -42,10 +42,10 @@
       + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
       + "http://example.com/spaces_in_codecs.m3u8\n"
       + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,FRAME-RATE=25,RESOLUTION=384x160\n"
       + "http://example.com/mid.m3u8\n"
       + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=7680000,FRAME-RATE=29.997\n"
       + "http://example.com/hi.m3u8\n"
       + "\n"
       + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
@@ -96,18 +96,21 @@ public void testParseMasterPlaylist() throws IOException{
     assertNull(variants.get(2).format.codecs);
     assertEquals(384, variants.get(2).format.width);
     assertEquals(160, variants.get(2).format.height);
+    assertEquals(25.0f, variants.get(2).format.frameRate);
     assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
 
     assertEquals(7680000, variants.get(3).format.bitrate);
     assertNull(variants.get(3).format.codecs);
     assertEquals(Format.NO_VALUE, variants.get(3).format.width);
     assertEquals(Format.NO_VALUE, variants.get(3).format.height);
+    assertEquals(29.997f, variants.get(3).format.frameRate);
     assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
 
     assertEquals(65000, variants.get(4).format.bitrate);
     assertEquals("mp4a.40.5", variants.get(4).format.codecs);
     assertEquals(Format.NO_VALUE, variants.get(4).format.width);
     assertEquals(Format.NO_VALUE, variants.get(4).format.height);
+    assertEquals((float) Format.NO_VALUE, variants.get(4).format.frameRate);
     assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
   }
 
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
index e2eb173df8..e4edb07926 100644
--- a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -27,7 +27,7 @@
 import junit.framework.TestCase;
 
 /**
- * Test for {@link HlsMediaPlaylistParserTest}
+ * Test for {@link HlsMediaPlaylistParserTest}.
  */
 public class HlsMediaPlaylistParserTest extends TestCase {
 
@@ -85,9 +85,8 @@ public void testParseMediaPlaylist() {
       Segment segment = segments.get(0);
       assertEquals(4, mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence);
       assertEquals(7975000, segment.durationUs);
-      assertFalse(segment.isEncrypted);
-      assertEquals(null, segment.encryptionKeyUri);
-      assertEquals(null, segment.encryptionIV);
+      assertNull(segment.fullSegmentEncryptionKeyUri);
+      assertNull(segment.encryptionIV);
       assertEquals(51370, segment.byterangeLength);
       assertEquals(0, segment.byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2679.ts", segment.url);
@@ -95,8 +94,7 @@ public void testParseMediaPlaylist() {
       segment = segments.get(1);
       assertEquals(0, segment.relativeDiscontinuitySequence);
       assertEquals(7975000, segment.durationUs);
-      assertTrue(segment.isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2680", segment.encryptionKeyUri);
+      assertEquals("https://priv.example.com/key.php?r=2680", segment.fullSegmentEncryptionKeyUri);
       assertEquals("0x1566B", segment.encryptionIV);
       assertEquals(51501, segment.byterangeLength);
       assertEquals(2147483648L, segment.byterangeOffset);
@@ -105,8 +103,7 @@ public void testParseMediaPlaylist() {
       segment = segments.get(2);
       assertEquals(0, segment.relativeDiscontinuitySequence);
       assertEquals(7941000, segment.durationUs);
-      assertFalse(segment.isEncrypted);
-      assertEquals(null, segment.encryptionKeyUri);
+      assertNull(segment.fullSegmentEncryptionKeyUri);
       assertEquals(null, segment.encryptionIV);
       assertEquals(51501, segment.byterangeLength);
       assertEquals(2147535149L, segment.byterangeOffset);
@@ -115,8 +112,7 @@ public void testParseMediaPlaylist() {
       segment = segments.get(3);
       assertEquals(1, segment.relativeDiscontinuitySequence);
       assertEquals(7975000, segment.durationUs);
-      assertTrue(segment.isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.fullSegmentEncryptionKeyUri);
       // 0xA7A == 2682.
       assertNotNull(segment.encryptionIV);
       assertEquals("A7A", segment.encryptionIV.toUpperCase(Locale.getDefault()));
@@ -127,8 +123,7 @@ public void testParseMediaPlaylist() {
       segment = segments.get(4);
       assertEquals(1, segment.relativeDiscontinuitySequence);
       assertEquals(7975000, segment.durationUs);
-      assertTrue(segment.isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.fullSegmentEncryptionKeyUri);
       // 0xA7B == 2683.
       assertNotNull(segment.encryptionIV);
       assertEquals("A7B", segment.encryptionIV.toUpperCase(Locale.getDefault()));
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
new file mode 100644
index 0000000000..957aefcdbc
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.Pair;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
+import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory;
+import com.google.android.exoplayer2.extractor.ts.TsExtractor;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Default {@link HlsExtractorFactory} implementation.
+ */
+public final class DefaultHlsExtractorFactory implements HlsExtractorFactory {
+
+  public static final String AAC_FILE_EXTENSION = ".aac";
+  public static final String AC3_FILE_EXTENSION = ".ac3";
+  public static final String EC3_FILE_EXTENSION = ".ec3";
+  public static final String MP3_FILE_EXTENSION = ".mp3";
+  public static final String MP4_FILE_EXTENSION = ".mp4";
+  public static final String M4_FILE_EXTENSION_PREFIX = ".m4";
+  public static final String VTT_FILE_EXTENSION = ".vtt";
+  public static final String WEBVTT_FILE_EXTENSION = ".webvtt";
+
+  @Override
+  public Pair<Extractor, Boolean> createExtractor(Extractor previousExtractor, Uri uri,
+      Format format, List<Format> muxedCaptionFormats, DrmInitData drmInitData,
+      TimestampAdjuster timestampAdjuster) {
+    String lastPathSegment = uri.getLastPathSegment();
+    boolean isPackedAudioExtractor = false;
+    Extractor extractor;
+    if (MimeTypes.TEXT_VTT.equals(format.sampleMimeType)
+        || lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
+        || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
+      extractor = new WebvttExtractor(format.language, timestampAdjuster);
+    } else if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
+      isPackedAudioExtractor = true;
+      extractor = new AdtsExtractor();
+    } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
+        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
+      isPackedAudioExtractor = true;
+      extractor = new Ac3Extractor();
+    } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
+      isPackedAudioExtractor = true;
+      extractor = new Mp3Extractor(0, 0);
+    } else if (previousExtractor != null) {
+      // Only reuse TS and fMP4 extractors.
+      extractor = previousExtractor;
+    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
+        || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)) {
+      extractor = new FragmentedMp4Extractor(0, timestampAdjuster, null, drmInitData);
+    } else {
+      // For any other file extension, we assume TS format.
+      @DefaultTsPayloadReaderFactory.Flags
+      int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
+      if (muxedCaptionFormats != null) {
+        // The playlist declares closed caption renditions, we should ignore descriptors.
+        esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
+      } else {
+        muxedCaptionFormats = Collections.emptyList();
+      }
+      String codecs = format.codecs;
+      if (!TextUtils.isEmpty(codecs)) {
+        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
+        // exist. If we know from the codec attribute that they don't exist, then we can
+        // explicitly ignore them even if they're declared.
+        if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
+          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
+        }
+        if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
+          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
+        }
+      }
+      extractor = new TsExtractor(TsExtractor.MODE_HLS, timestampAdjuster,
+          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats));
+    }
+    return Pair.create(extractor, isPackedAudioExtractor);
+  }
+
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 7173d0d6d5..2b1ece4eee 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -80,6 +80,7 @@ public void clear() {
 
   }
 
+  private final HlsExtractorFactory extractorFactory;
   private final DataSource mediaDataSource;
   private final DataSource encryptionDataSource;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
@@ -103,8 +104,11 @@ public void clear() {
   // the way in which HlsSampleStreamWrapper generates track groups. Use only index based methods
   // in TrackSelection to avoid unexpected behavior.
   private TrackSelection trackSelection;
+  private long liveEdgeTimeUs;
 
   /**
+   * @param extractorFactory An {@link HlsExtractorFactory} from which to obtain the extractors for
+   *     media chunks.
    * @param playlistTracker The {@link HlsPlaylistTracker} from which to obtain media playlists.
    * @param variants The available variants.
    * @param dataSourceFactory An {@link HlsDataSourceFactory} to create {@link DataSource}s for the
@@ -115,13 +119,15 @@ public void clear() {
    * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
    *     information is available in the master playlist.
    */
-  public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
-      HlsDataSourceFactory dataSourceFactory, TimestampAdjusterProvider timestampAdjusterProvider,
-      List<Format> muxedCaptionFormats) {
+  public HlsChunkSource(HlsExtractorFactory extractorFactory, HlsPlaylistTracker playlistTracker,
+      HlsUrl[] variants, HlsDataSourceFactory dataSourceFactory,
+      TimestampAdjusterProvider timestampAdjusterProvider, List<Format> muxedCaptionFormats) {
+    this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
     this.variants = variants;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
     this.muxedCaptionFormats = muxedCaptionFormats;
+    liveEdgeTimeUs = C.TIME_UNSET;
     Format[] variantFormats = new Format[variants.length];
     int[] initialTrackSelection = new int[variants.length];
     for (int i = 0; i < variants.length; i++) {
@@ -198,23 +204,39 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
    * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
    *
    * @param previous The most recently loaded media chunk.
-   * @param playbackPositionUs The current playback position. If {@code previous} is null then this
-   *     parameter is the position from which playback is expected to start (or restart) and hence
-   *     should be interpreted as a seek position.
+   * @param playbackPositionUs The current playback position in microseconds. If playback of the
+   *     period to which this chunk source belongs has not yet started, the value will be the
+   *     starting position in the period minus the duration of any media in previous periods still
+   *     to be played.
+   * @param loadPositionUs The current load position in microseconds. If {@code previous} is null,
+   *     this is the starting position from which chunks should be provided. Else it's equal to
+   *     {@code previous.endTimeUs}.
    * @param out A holder to populate.
    */
-  public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
+  public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, long loadPositionUs,
+      HlsChunkHolder out) {
     int oldVariantIndex = previous == null ? C.INDEX_UNSET
         : trackGroup.indexOf(previous.trackFormat);
     expectedPlaylistUrl = null;
-    // Unless segments are known to be independent, switching variant will require downloading
-    // overlapping segments. Hence we use the start time of the previous chunk rather than its end
-    // time for this case.
-    long bufferedDurationUs = previous == null ? 0 : Math.max(0,
-        (independentSegments ? previous.endTimeUs : previous.startTimeUs) - playbackPositionUs);
+
+    long bufferedDurationUs = loadPositionUs - playbackPositionUs;
+    long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
+    if (previous != null && !independentSegments) {
+      // Unless segments are known to be independent, switching variant will require downloading
+      // overlapping segments. Hence we will subtract previous chunk's duration from buffered
+      // duration.
+      // This may affect the live-streaming adaptive track selection logic, when we are comparing
+      // buffered duration to time to live edge to decide whether to switch. Therefore,
+      // we will subtract this same amount from timeToLiveEdgeUs as well.
+      long subtractedDurationUs = previous.getDurationUs();
+      bufferedDurationUs = Math.max(0, bufferedDurationUs - subtractedDurationUs);
+      if (timeToLiveEdgeUs != C.TIME_UNSET) {
+        timeToLiveEdgeUs = Math.max(0, timeToLiveEdgeUs - subtractedDurationUs);
+      }
+    }
 
     // Select the variant.
-    trackSelection.updateSelectedTrack(bufferedDurationUs);
+    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
     int selectedVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
 
     boolean switchingVariant = oldVariantIndex != selectedVariantIndex;
@@ -228,11 +250,13 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
     independentSegments = mediaPlaylist.hasIndependentSegmentsTag;
 
+    updateLiveEdgeTimeUs(mediaPlaylist);
+
     // Select the chunk.
     int chunkMediaSequence;
     if (previous == null || switchingVariant) {
-      long targetPositionUs = previous == null ? playbackPositionUs
-          : independentSegments ? previous.endTimeUs : previous.startTimeUs;
+      long targetPositionUs = (previous == null || independentSegments) ? loadPositionUs
+          : previous.startTimeUs;
       if (!mediaPlaylist.hasEndTag && targetPositionUs >= mediaPlaylist.getEndTimeUs()) {
         // If the playlist is too old to contain the chunk, we need to refresh it.
         chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
@@ -271,9 +295,9 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     // Handle encryption.
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
 
-    // Check if encryption is specified.
-    if (segment.isEncrypted) {
-      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
+    // Check if the segment is completely encrypted using the identity key format.
+    if (segment.fullSegmentEncryptionKeyUri != null) {
+      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.fullSegmentEncryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
         out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
@@ -306,10 +330,11 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
         null);
-    out.chunk = new HlsMediaChunk(mediaDataSource, dataSpec, initDataSpec, selectedUrl,
-        muxedCaptionFormats, trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
-        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence, discontinuitySequence,
-        isTimestampMaster, timestampAdjuster, previous, encryptionKey, encryptionIv);
+    out.chunk = new HlsMediaChunk(extractorFactory, mediaDataSource, dataSpec, initDataSpec,
+        selectedUrl, muxedCaptionFormats, trackSelection.getSelectionReason(),
+        trackSelection.getSelectionData(), startTimeUs, startTimeUs + segment.durationUs,
+        chunkMediaSequence, discontinuitySequence, isTimestampMaster, timestampAdjuster, previous,
+        mediaPlaylist.drmInitData, encryptionKey, encryptionIv);
   }
 
   /**
@@ -359,6 +384,15 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
 
   // Private methods.
 
+  private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
+    final boolean resolveTimeToLiveEdgePossible = liveEdgeTimeUs != C.TIME_UNSET;
+    return resolveTimeToLiveEdgePossible ? liveEdgeTimeUs - playbackPositionUs : C.TIME_UNSET;
+  }
+
+  private void updateLiveEdgeTimeUs(HlsMediaPlaylist mediaPlaylist) {
+    liveEdgeTimeUs = mediaPlaylist.hasEndTag ? C.TIME_UNSET : mediaPlaylist.getEndTimeUs();
+  }
+
   private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
       int trackSelectionReason, Object trackSelectionData) {
     DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
@@ -408,7 +442,8 @@ public InitializationTrackSelection(TrackGroup group, int[] tracks) {
     }
 
     @Override
-    public void updateSelectedTrack(long bufferedDurationUs) {
+    public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
+        long availableDurationUs) {
       long nowMs = SystemClock.elapsedRealtime();
       if (!isBlacklisted(selectedIndex, nowMs)) {
         return;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
new file mode 100644
index 0000000000..3ed6a549db
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsExtractorFactory.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import android.net.Uri;
+import android.util.Pair;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.util.List;
+
+/**
+ * Factory for HLS media chunk extractors.
+ */
+public interface HlsExtractorFactory {
+
+  HlsExtractorFactory DEFAULT = new DefaultHlsExtractorFactory();
+
+  /**
+   * Creates an {@link Extractor} for extracting HLS media chunks.
+   *
+   * @param previousExtractor A previously used {@link Extractor} which can be reused if the current
+   *     chunk is a continuation of the previously extracted chunk, or null otherwise. It is the
+   *     responsibility of implementers to only reuse extractors that are suited for reusage.
+   * @param uri The URI of the media chunk.
+   * @param format A {@link Format} associated with the chunk to extract.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
+   *     information is available in the master playlist.
+   * @param drmInitData {@link DrmInitData} associated with the chunk.
+   * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
+   * @return A pair containing the {@link Extractor} and a boolean that indicates whether it is a
+   *     packed audio extractor. The first element may be {@code previousExtractor} if the factory
+   *     has determined it can be re-used.
+   */
+  Pair<Extractor, Boolean> createExtractor(Extractor previousExtractor, Uri uri, Format format,
+      List<Format> muxedCaptionFormats, DrmInitData drmInitData,
+      TimestampAdjuster timestampAdjuster);
+
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 29b7e4a6a8..5ca8675dd9 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -15,18 +15,13 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
-import android.text.TextUtils;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
-import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
-import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
-import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory;
-import com.google.android.exoplayer2.extractor.ts.TsExtractor;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
@@ -34,12 +29,10 @@
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -48,19 +41,11 @@
  */
 /* package */ final class HlsMediaChunk extends MediaChunk {
 
-  private static final AtomicInteger UID_SOURCE = new AtomicInteger();
 
   private static final String PRIV_TIMESTAMP_FRAME_OWNER =
       "com.apple.streaming.transportStreamTimestamp";
 
-  private static final String AAC_FILE_EXTENSION = ".aac";
-  private static final String AC3_FILE_EXTENSION = ".ac3";
-  private static final String EC3_FILE_EXTENSION = ".ec3";
-  private static final String MP3_FILE_EXTENSION = ".mp3";
-  private static final String MP4_FILE_EXTENSION = ".mp4";
-  private static final String M4_FILE_EXTENSION_PREFIX = ".m4";
-  private static final String VTT_FILE_EXTENSION = ".vtt";
-  private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
+  private static final AtomicInteger uidSource = new AtomicInteger();
 
   /**
    * A unique identifier for the chunk.
@@ -82,25 +67,24 @@
   private final boolean isEncrypted;
   private final boolean isMasterTimestampSource;
   private final TimestampAdjuster timestampAdjuster;
-  private final String lastPathSegment;
-  private final Extractor previousExtractor;
   private final boolean shouldSpliceIn;
-  private final boolean needNewExtractor;
-  private final List<Format> muxedCaptionFormats;
-
-  private final boolean isPackedAudio;
+  private final Extractor extractor;
+  private final boolean isPackedAudioExtractor;
+  private final boolean reusingExtractor;
   private final Id3Decoder id3Decoder;
   private final ParsableByteArray id3Data;
 
-  private Extractor extractor;
+  private HlsSampleStreamWrapper output;
   private int initSegmentBytesLoaded;
   private int bytesLoaded;
+  private boolean id3TimestampPeeked;
   private boolean initLoadCompleted;
-  private HlsSampleStreamWrapper extractorOutput;
   private volatile boolean loadCanceled;
   private volatile boolean loadCompleted;
 
   /**
+   * @param extractorFactory A {@link HlsExtractorFactory} from which the HLS media chunk
+   *     extractor is obtained.
    * @param dataSource The source from which the data should be loaded.
    * @param dataSpec Defines the data to be loaded.
    * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
@@ -116,46 +100,52 @@
    * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
    * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
    * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
-   * @param encryptionKey For AES encryption chunks, the encryption key.
-   * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
+   * @param drmInitData A {@link DrmInitData} to sideload to the extractor.
+   * @param fullSegmentEncryptionKey The key to decrypt the full segment, or null if the segment is
+   *     not fully encrypted.
+   * @param encryptionIv The AES initialization vector, or null if the segment is not fully
+   *     encrypted.
    */
-  public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
-      HlsUrl hlsUrl, List<Format> muxedCaptionFormats, int trackSelectionReason,
-      Object trackSelectionData, long startTimeUs, long endTimeUs, int chunkIndex,
-      int discontinuitySequenceNumber, boolean isMasterTimestampSource,
-      TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, byte[] encryptionKey,
-      byte[] encryptionIv) {
-    super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
-        trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
+  public HlsMediaChunk(HlsExtractorFactory extractorFactory, DataSource dataSource,
+      DataSpec dataSpec, DataSpec initDataSpec, HlsUrl hlsUrl, List<Format> muxedCaptionFormats,
+      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
+      int chunkIndex, int discontinuitySequenceNumber, boolean isMasterTimestampSource,
+      TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, DrmInitData drmInitData,
+      byte[] fullSegmentEncryptionKey, byte[] encryptionIv) {
+    super(buildDataSource(dataSource, fullSegmentEncryptionKey, encryptionIv), dataSpec,
+        hlsUrl.format, trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs,
+        chunkIndex);
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
     this.initDataSpec = initDataSpec;
     this.hlsUrl = hlsUrl;
-    this.muxedCaptionFormats = muxedCaptionFormats;
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
-    lastPathSegment = dataSpec.uri.getLastPathSegment();
-    isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
-        || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
+    Extractor previousExtractor = null;
     if (previousChunk != null) {
-      id3Decoder = previousChunk.id3Decoder;
-      id3Data = previousChunk.id3Data;
-      previousExtractor = previousChunk.extractor;
       shouldSpliceIn = previousChunk.hlsUrl != hlsUrl;
-      needNewExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
-          || shouldSpliceIn;
+      previousExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
+          || shouldSpliceIn ? null : previousChunk.extractor;
     } else {
-      id3Decoder = isPackedAudio ? new Id3Decoder() : null;
-      id3Data = isPackedAudio ? new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH) : null;
-      previousExtractor = null;
       shouldSpliceIn = false;
-      needNewExtractor = true;
+    }
+    Pair<Extractor, Boolean> extractorData = extractorFactory.createExtractor(previousExtractor,
+        dataSpec.uri, trackFormat, muxedCaptionFormats, drmInitData, timestampAdjuster);
+    extractor = extractorData.first;
+    isPackedAudioExtractor = extractorData.second;
+    reusingExtractor = extractor == previousExtractor;
+    initLoadCompleted = reusingExtractor && initDataSpec != null;
+    if (isPackedAudioExtractor) {
+      id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
+      id3Data =  previousChunk != null ? previousChunk.id3Data
+          : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+    } else {
+      id3Decoder = null;
+      id3Data = null;
     }
     initDataSource = dataSource;
-    uid = UID_SOURCE.getAndIncrement();
+    uid = uidSource.getAndIncrement();
   }
 
   /**
@@ -165,8 +155,11 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
    * @param output The output that will receive the loaded samples.
    */
   public void init(HlsSampleStreamWrapper output) {
-    extractorOutput = output;
+    this.output = output;
     output.init(uid, shouldSpliceIn);
+    if (!reusingExtractor) {
+      extractor.init(output);
+    }
   }
 
   @Override
@@ -193,10 +186,6 @@ public boolean isLoadCanceled() {
 
   @Override
   public void load() throws IOException, InterruptedException {
-    if (extractor == null && !isPackedAudio) {
-      // See HLS spec, version 20, Section 3.4 for more information on packed audio extraction.
-      extractor = createExtractor();
-    }
     maybeLoadInitData();
     if (!loadCanceled) {
       loadMedia();
@@ -206,8 +195,8 @@ public void load() throws IOException, InterruptedException {
   // Internal loading methods.
 
   private void maybeLoadInitData() throws IOException, InterruptedException {
-    if (previousExtractor == extractor || initLoadCompleted || initDataSpec == null) {
-      // According to spec, for packed audio, initDataSpec is expected to be null.
+    if (initLoadCompleted || initDataSpec == null) {
+      // Note: The HLS spec forbids initialization segments for packed audio.
       return;
     }
     DataSpec initSegmentDataSpec = initDataSpec.subrange(initSegmentBytesLoaded);
@@ -251,10 +240,10 @@ private void loadMedia() throws IOException, InterruptedException {
     try {
       ExtractorInput input = new DefaultExtractorInput(dataSource,
           loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
-      if (extractor == null) {
-        // Media segment format is packed audio.
+      if (isPackedAudioExtractor && !id3TimestampPeeked) {
         long id3Timestamp = peekId3PrivTimestamp(input);
-        extractor = buildPackedAudioExtractor(id3Timestamp != C.TIME_UNSET
+        id3TimestampPeeked = true;
+        output.setSampleOffsetUs(id3Timestamp != C.TIME_UNSET
             ? timestampAdjuster.adjustTsTimestamp(id3Timestamp) : startTimeUs);
       }
       if (skipLoadedBytes) {
@@ -327,79 +316,15 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
   // Internal factory methods.
 
   /**
-   * If the content is encrypted, returns an {@link Aes128DataSource} that wraps the original in
-   * order to decrypt the loaded data. Else returns the original.
+   * If the segment is fully encrypted, returns an {@link Aes128DataSource} that wraps the original
+   * in order to decrypt the loaded data. Else returns the original.
    */
-  private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
+  private static DataSource buildDataSource(DataSource dataSource, byte[] fullSegmentEncryptionKey,
       byte[] encryptionIv) {
-    if (encryptionKey == null || encryptionIv == null) {
-      return dataSource;
-    }
-    return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
-  }
-
-  private Extractor createExtractor() {
-    // Select the extractor that will read the chunk.
-    Extractor extractor;
-    boolean usingNewExtractor = true;
-    if (MimeTypes.TEXT_VTT.equals(hlsUrl.format.sampleMimeType)
-        || lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
-        || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
-      extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
-    } else if (!needNewExtractor) {
-      // Only reuse TS and fMP4 extractors.
-      usingNewExtractor = false;
-      extractor = previousExtractor;
-    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
-        || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)) {
-      extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
-    } else {
-      // MPEG-2 TS segments, but we need a new extractor.
-      // This flag ensures the change of pid between streams does not affect the sample queues.
-      @DefaultTsPayloadReaderFactory.Flags
-      int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
-      List<Format> closedCaptionFormats = muxedCaptionFormats;
-      if (closedCaptionFormats != null) {
-        // The playlist declares closed caption renditions, we should ignore descriptors.
-        esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
-      } else {
-        closedCaptionFormats = Collections.emptyList();
-      }
-      String codecs = trackFormat.codecs;
-      if (!TextUtils.isEmpty(codecs)) {
-        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
-        // exist. If we know from the codec attribute that they don't exist, then we can
-        // explicitly ignore them even if they're declared.
-        if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
-          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
-        }
-        if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
-          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
-        }
-      }
-      extractor = new TsExtractor(TsExtractor.MODE_HLS, timestampAdjuster,
-          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, closedCaptionFormats));
-    }
-    if (usingNewExtractor) {
-      extractor.init(extractorOutput);
-    }
-    return extractor;
-  }
-
-  private Extractor buildPackedAudioExtractor(long startTimeUs) {
-    Extractor extractor;
-    if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
-      extractor = new AdtsExtractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
-      extractor = new Ac3Extractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
-      extractor = new Mp3Extractor(0, startTimeUs);
-    } else {
-      throw new IllegalArgumentException("Unknown extension for audio file: " + lastPathSegment);
+    if (fullSegmentEncryptionKey != null) {
+      return new Aes128DataSource(dataSource, fullSegmentEncryptionKey, encryptionIv);
     }
-    extractor.init(extractorOutput);
-    return extractor;
+    return dataSource;
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 003b38efef..ea9e52e62e 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -44,6 +44,7 @@
 public final class HlsMediaPeriod implements MediaPeriod, HlsSampleStreamWrapper.Callback,
     HlsPlaylistTracker.PlaylistEventListener {
 
+  private final HlsExtractorFactory extractorFactory;
   private final HlsPlaylistTracker playlistTracker;
   private final HlsDataSourceFactory dataSourceFactory;
   private final int minLoadableRetryCount;
@@ -60,8 +61,10 @@
   private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
   private CompositeSequenceableLoader sequenceableLoader;
 
-  public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, HlsDataSourceFactory dataSourceFactory,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator) {
+  public HlsMediaPeriod(HlsExtractorFactory extractorFactory, HlsPlaylistTracker playlistTracker,
+      HlsDataSourceFactory dataSourceFactory, int minLoadableRetryCount,
+      EventDispatcher eventDispatcher, Allocator allocator) {
+    this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -344,8 +347,8 @@ private void buildAndPrepareSampleStreamWrappers(long positionUs) {
 
   private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
       Format muxedAudioFormat, List<Format> muxedCaptionFormats, long positionUs) {
-    HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants,
-        dataSourceFactory, timestampAdjusterProvider, muxedCaptionFormats);
+    HlsChunkSource defaultChunkSource = new HlsChunkSource(extractorFactory, playlistTracker,
+        variants, dataSourceFactory, timestampAdjusterProvider, muxedCaptionFormats);
     return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator, positionUs,
         muxedAudioFormat, minLoadableRetryCount, eventDispatcher);
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index fd3d533337..21b27e655d 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -20,15 +20,19 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.List;
@@ -48,33 +52,69 @@
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
+  private final HlsExtractorFactory extractorFactory;
   private final Uri manifestUri;
   private final HlsDataSourceFactory dataSourceFactory;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
+  private final ParsingLoadable.Parser<HlsPlaylist> playlistParser;
 
   private HlsPlaylistTracker playlistTracker;
   private Listener sourceListener;
 
+  /**
+   * @param manifestUri The {@link Uri} of the HLS manifest.
+   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
+   *     segments and keys.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener An {@link AdaptiveMediaSourceEventListener}. May be null if delivery of
+   *     events is not required.
+   */
   public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
     this(manifestUri, dataSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
         eventListener);
   }
 
+  /**
+   * @param manifestUri The {@link Uri} of the HLS manifest.
+   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
+   *     segments and keys.
+   * @param minLoadableRetryCount The minimum number of times loads must be retried before
+   *     errors are propagated.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener An {@link AdaptiveMediaSourceEventListener}. May be null if delivery of
+   *     events is not required.
+   */
   public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
       int minLoadableRetryCount, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
-    this(manifestUri, new DefaultHlsDataSourceFactory(dataSourceFactory), minLoadableRetryCount,
-        eventHandler, eventListener);
+    this(manifestUri, new DefaultHlsDataSourceFactory(dataSourceFactory),
+        HlsExtractorFactory.DEFAULT, minLoadableRetryCount, eventHandler, eventListener,
+        new HlsPlaylistParser());
   }
 
+  /**
+   * @param manifestUri The {@link Uri} of the HLS manifest.
+   * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
+   *     segments and keys.
+   * @param extractorFactory An {@link HlsExtractorFactory} for {@link Extractor}s for the segments.
+   * @param minLoadableRetryCount The minimum number of times loads must be retried before
+   *     errors are propagated.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener An {@link AdaptiveMediaSourceEventListener}. May be null if delivery of
+   *     events is not required.
+   * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
+   */
   public HlsMediaSource(Uri manifestUri, HlsDataSourceFactory dataSourceFactory,
-      int minLoadableRetryCount, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+     HlsExtractorFactory extractorFactory, int minLoadableRetryCount, Handler eventHandler,
+     AdaptiveMediaSourceEventListener eventListener,
+      ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
     this.manifestUri = manifestUri;
     this.dataSourceFactory = dataSourceFactory;
+    this.extractorFactory = extractorFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
+    this.playlistParser = playlistParser;
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
   }
 
@@ -82,7 +122,7 @@ public HlsMediaSource(Uri manifestUri, HlsDataSourceFactory dataSourceFactory,
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     Assertions.checkState(playlistTracker == null);
     playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher,
-        minLoadableRetryCount, this);
+        minLoadableRetryCount, this, playlistParser);
     sourceListener = listener;
     playlistTracker.start();
   }
@@ -95,8 +135,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
-    return new HlsMediaPeriod(playlistTracker, dataSourceFactory, minLoadableRetryCount,
-        eventDispatcher, allocator);
+    return new HlsMediaPeriod(extractorFactory, playlistTracker, dataSourceFactory,
+        minLoadableRetryCount, eventDispatcher, allocator);
   }
 
   @Override
@@ -139,7 +179,7 @@ public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
           playlist.startTimeUs + playlist.durationUs, playlist.durationUs, playlist.startTimeUs,
           windowDefaultStartPositionUs, true, false);
     }
-    sourceListener.onSourceInfoRefreshed(timeline,
+    sourceListener.onSourceInfoRefreshed(this, timeline,
         new HlsManifest(playlistTracker.getMasterPlaylist(), playlist));
   }
 
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index 450644f60f..e423a682f3 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -50,8 +50,8 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolea
   }
 
   @Override
-  public void skipData(long positionUs) {
-    sampleStreamWrapper.skipData(group, positionUs);
+  public int skipData(long positionUs) {
+    return sampleStreamWrapper.skipData(group, positionUs);
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 0b6d1863bd..ddd6689fa6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -92,7 +92,6 @@
   private boolean prepared;
   private int enabledTrackCount;
   private Format downstreamTrackFormat;
-  private int upstreamChunkUid;
   private boolean released;
 
   // Tracks are complicated in HLS. See documentation of buildTracks for details.
@@ -104,6 +103,7 @@
   private boolean[] trackGroupEnabledStates;
   private boolean[] trackGroupIsAudioVideoFlags;
 
+  private long sampleOffsetUs;
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
   private boolean pendingResetUpstreamFormats;
@@ -229,7 +229,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
           // sample queue, or if we haven't read anything from the queue since the previous seek
           // (this case is common for sparse tracks such as metadata tracks). In all other cases a
           // seek is required.
-          seekRequired = !sampleQueue.advanceTo(positionUs, true, true)
+          seekRequired = sampleQueue.advanceTo(positionUs, true, true) == SampleQueue.ADVANCE_FAILED
               && sampleQueue.getReadIndex() != 0;
         }
       }
@@ -255,7 +255,8 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
         // may need to be discarded.
         boolean primarySampleQueueDirty = false;
         if (!seenFirstTrackSelection) {
-          primaryTrackSelection.updateSelectedTrack(0);
+          long bufferedDurationUs = positionUs < 0 ? -positionUs : 0;
+          primaryTrackSelection.updateSelectedTrack(positionUs, bufferedDurationUs, C.TIME_UNSET);
           int chunkIndex = chunkSource.getTrackGroup().indexOf(mediaChunks.getLast().trackFormat);
           if (primaryTrackSelection.getSelectedIndexInTrackGroup() != chunkIndex) {
             // This is the first selection and the chunk loaded during preparation does not match
@@ -320,6 +321,7 @@ public boolean seekToUs(long positionUs, boolean forceReset) {
     return true;
   }
 
+  @Override
   public long getBufferedPositionUs() {
     if (loadingFinished) {
       return C.TIME_END_OF_SOURCE;
@@ -369,21 +371,49 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
 
   // SampleStream implementation.
 
-  /* package */ boolean isReady(int trackGroupIndex) {
+  public boolean isReady(int trackGroupIndex) {
     return loadingFinished || (!isPendingReset() && sampleQueues[trackGroupIndex].hasNextSample());
   }
 
-  /* package */ void maybeThrowError() throws IOException {
+  public void maybeThrowError() throws IOException {
     loader.maybeThrowError();
     chunkSource.maybeThrowError();
   }
 
-  /* package */ int readData(int trackGroupIndex, FormatHolder formatHolder,
+  public int readData(int trackGroupIndex, FormatHolder formatHolder,
       DecoderInputBuffer buffer, boolean requireFormat) {
     if (isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
+    int result = sampleQueues[trackGroupIndex].read(formatHolder, buffer, requireFormat,
+        loadingFinished, lastSeekPositionUs);
+    if (result == C.RESULT_BUFFER_READ) {
+      discardToRead();
+    }
+    return result;
+  }
+
+  public int skipData(int trackGroupIndex, long positionUs) {
+    if (isPendingReset()) {
+      return 0;
+    }
+    int skipCount;
+    SampleQueue sampleQueue = sampleQueues[trackGroupIndex];
+    if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
+      skipCount = sampleQueue.advanceToEnd();
+    } else {
+      skipCount = sampleQueue.advanceTo(positionUs, true, true);
+      if (skipCount == SampleQueue.ADVANCE_FAILED) {
+        skipCount = 0;
+      }
+    }
+    if (skipCount > 0) {
+      discardToRead();
+    }
+    return skipCount;
+  }
 
+  private void discardToRead() {
     if (!mediaChunks.isEmpty()) {
       while (mediaChunks.size() > 1 && finishedReadingChunk(mediaChunks.getFirst())) {
         mediaChunks.removeFirst();
@@ -397,18 +427,6 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
       }
       downstreamTrackFormat = trackFormat;
     }
-
-    return sampleQueues[trackGroupIndex].read(formatHolder, buffer, requireFormat, loadingFinished,
-        lastSeekPositionUs);
-  }
-
-  /* package */ void skipData(int trackGroupIndex, long positionUs) {
-    SampleQueue sampleQueue = sampleQueues[trackGroupIndex];
-    if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
-      sampleQueue.advanceToEnd();
-    } else {
-      sampleQueue.advanceTo(positionUs, true, true);
-    }
   }
 
   private boolean finishedReadingChunk(HlsMediaChunk chunk) {
@@ -436,9 +454,16 @@ public boolean continueLoading(long positionUs) {
       return false;
     }
 
-    chunkSource.getNextChunk(mediaChunks.isEmpty() ? null : mediaChunks.getLast(),
-        pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
-        nextChunkHolder);
+    HlsMediaChunk previousChunk;
+    long loadPositionUs;
+    if (isPendingReset()) {
+      previousChunk = null;
+      loadPositionUs = pendingResetPositionUs;
+    } else {
+      previousChunk = mediaChunks.getLast();
+      loadPositionUs = previousChunk.endTimeUs;
+    }
+    chunkSource.getNextChunk(previousChunk, positionUs, loadPositionUs, nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
@@ -551,7 +576,6 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
    *     samples already queued to the wrapper.
    */
   public void init(int chunkUid, boolean shouldSpliceIn) {
-    upstreamChunkUid = chunkUid;
     for (SampleQueue sampleQueue : sampleQueues) {
       sampleQueue.sourceId(chunkUid);
     }
@@ -573,6 +597,7 @@ public SampleQueue track(int id, int type) {
       }
     }
     SampleQueue trackOutput = new SampleQueue(allocator);
+    trackOutput.setSampleOffsetUs(sampleOffsetUs);
     trackOutput.setUpstreamFormatChangeListener(this);
     sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
     sampleQueueTrackIds[trackCount] = id;
@@ -599,6 +624,15 @@ public void onUpstreamFormatChanged(Format format) {
     handler.post(maybeFinishPrepareRunnable);
   }
 
+  // Called by the loading thread.
+
+  public void setSampleOffsetUs(long sampleOffsetUs) {
+    this.sampleOffsetUs = sampleOffsetUs;
+    for (SampleQueue sampleQueue : sampleQueues) {
+      sampleQueue.setSampleOffsetUs(sampleOffsetUs);
+    }
+  }
+
   // Internal methods.
 
   private void maybeFinishPrepare() {
@@ -760,7 +794,8 @@ private boolean seekInsideBufferUs(long positionUs) {
     for (int i = 0; i < trackCount; i++) {
       SampleQueue sampleQueue = sampleQueues[i];
       sampleQueue.rewind();
-      boolean seekInsideQueue = sampleQueue.advanceTo(positionUs, true, false);
+      boolean seekInsideQueue = sampleQueue.advanceTo(positionUs, true, false)
+          != SampleQueue.ADVANCE_FAILED;
       // If we have AV tracks then an in-queue seek is successful if the seek into every AV queue
       // is successful. We ignore whether seeks within non-AV queues are successful in this case, as
       // they may be sparse or poorly interleaved. If we only have non-AV tracks then a seek is
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
new file mode 100644
index 0000000000..5ac61294a4
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.offline;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.SegmentDownloader;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.util.UriUtil;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+/**
+ * Helper class to download HLS streams.
+ *
+ * A subset of renditions can be downloaded by selecting them using {@link
+ * #selectRepresentations(Object[])}. As key, string form of the rendition's url is used. The urls
+ * can be absolute or relative to the master playlist url.
+ */
+public final class HlsDownloader extends SegmentDownloader<HlsMasterPlaylist, String> {
+
+  /**
+   * @see SegmentDownloader#SegmentDownloader(Uri, DownloaderConstructorHelper)
+   */
+  public HlsDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHelper)  {
+    super(manifestUri, constructorHelper);
+  }
+
+  @Override
+  protected HlsMasterPlaylist getManifest(DataSource dataSource, Uri uri) throws IOException {
+    HlsPlaylist hlsPlaylist = loadManifest(dataSource, uri);
+    if (hlsPlaylist instanceof HlsMasterPlaylist) {
+      return (HlsMasterPlaylist) hlsPlaylist;
+    } else {
+      return HlsMasterPlaylist.createSingleVariantMasterPlaylist(hlsPlaylist.baseUri);
+    }
+  }
+
+  @Override
+  protected List<Segment> getAllSegments(DataSource dataSource, HlsMasterPlaylist manifest,
+      boolean allowIndexLoadErrors) throws InterruptedException, IOException {
+    ArrayList<String> urls = new ArrayList<>();
+    extractUrls(manifest.variants, urls);
+    extractUrls(manifest.audios, urls);
+    extractUrls(manifest.subtitles, urls);
+    return getSegments(dataSource, manifest, urls.toArray(new String[urls.size()]),
+        allowIndexLoadErrors);
+  }
+
+  @Override
+  protected List<Segment> getSegments(DataSource dataSource, HlsMasterPlaylist manifest,
+      String[] keys, boolean allowIndexLoadErrors) throws InterruptedException, IOException {
+    HashSet<Uri> encryptionKeyUris = new HashSet<>();
+    ArrayList<Segment> segments = new ArrayList<>();
+    for (String playlistUrl : keys) {
+      HlsMediaPlaylist mediaPlaylist = null;
+      Uri uri = UriUtil.resolveToUri(manifest.baseUri, playlistUrl);
+      try {
+        mediaPlaylist = (HlsMediaPlaylist) loadManifest(dataSource, uri);
+      } catch (IOException e) {
+        if (!allowIndexLoadErrors) {
+          throw e;
+        }
+      }
+      segments.add(new Segment(mediaPlaylist != null ? mediaPlaylist.startTimeUs : Long.MIN_VALUE,
+          new DataSpec(uri)));
+      if (mediaPlaylist == null) {
+        continue;
+      }
+
+      HlsMediaPlaylist.Segment initSegment = mediaPlaylist.initializationSegment;
+      if (initSegment != null) {
+        addSegment(segments, mediaPlaylist, initSegment, encryptionKeyUris);
+      }
+
+      List<HlsMediaPlaylist.Segment> hlsSegments = mediaPlaylist.segments;
+      for (int i = 0; i < hlsSegments.size(); i++) {
+        addSegment(segments, mediaPlaylist, hlsSegments.get(i), encryptionKeyUris);
+      }
+    }
+    return segments;
+  }
+
+  private HlsPlaylist loadManifest(DataSource dataSource, Uri uri) throws IOException {
+    DataSpec dataSpec = new DataSpec(uri,
+        DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
+    ParsingLoadable<HlsPlaylist> loadable = new ParsingLoadable<>(dataSource, dataSpec,
+        C.DATA_TYPE_MANIFEST, new HlsPlaylistParser());
+    loadable.load();
+    return loadable.getResult();
+  }
+
+  private static void addSegment(ArrayList<Segment> segments, HlsMediaPlaylist mediaPlaylist,
+      HlsMediaPlaylist.Segment hlsSegment, HashSet<Uri> encryptionKeyUris)
+      throws IOException, InterruptedException {
+    long startTimeUs = mediaPlaylist.startTimeUs + hlsSegment.relativeStartTimeUs;
+    if (hlsSegment.fullSegmentEncryptionKeyUri != null) {
+      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri,
+          hlsSegment.fullSegmentEncryptionKeyUri);
+      if (encryptionKeyUris.add(keyUri)) {
+        segments.add(new Segment(startTimeUs, new DataSpec(keyUri)));
+      }
+    }
+    Uri resolvedUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, hlsSegment.url);
+    segments.add(new Segment(startTimeUs,
+        new DataSpec(resolvedUri, hlsSegment.byterangeOffset, hlsSegment.byterangeLength, null)));
+  }
+
+  private static void extractUrls(List<HlsUrl> hlsUrls, ArrayList<String> urls) {
+    for (int i = 0; i < hlsUrls.size(); i++) {
+      urls.add(hlsUrls.get(i).url);
+    }
+  }
+
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index b38763f7e8..04192def9d 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
@@ -108,6 +109,20 @@ public HlsMasterPlaylist(String baseUri, List<String> tags, List<HlsUrl> variant
         ? Collections.unmodifiableList(muxedCaptionFormats) : null;
   }
 
+  /**
+   * Returns a copy of this playlist which includes only the renditions identified by the given
+   * urls.
+   *
+   * @param renditionUrls List of rendition urls.
+   * @return A copy of this playlist which includes only the renditions identified by the given
+   *     urls.
+   */
+  public HlsMasterPlaylist copy(List<String> renditionUrls) {
+    return new HlsMasterPlaylist(baseUri, tags, copyRenditionsList(variants, renditionUrls),
+        copyRenditionsList(audios, renditionUrls), copyRenditionsList(subtitles, renditionUrls),
+        muxedAudioFormat, muxedCaptionFormats);
+  }
+
   /**
    * Creates a playlist with a single variant.
    *
@@ -121,4 +136,15 @@ public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variant
         emptyList, null, null);
   }
 
+  private static List<HlsUrl> copyRenditionsList(List<HlsUrl> renditions, List<String> urls) {
+    List<HlsUrl> copiedRenditions = new ArrayList<>(urls.size());
+    for (int i = 0; i < renditions.size(); i++) {
+      HlsUrl rendition = renditions.get(i);
+      if (urls.contains(rendition.url)) {
+        copiedRenditions.add(rendition);
+      }
+    }
+    return copiedRenditions;
+  }
+
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index db4f041be2..b21ecb02d5 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -18,6 +18,7 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -50,13 +51,10 @@
      */
     public final long relativeStartTimeUs;
     /**
-     * Whether the segment is encrypted, as defined by #EXT-X-KEY.
+     * The encryption identity key uri as defined by #EXT-X-KEY, or null if the segment does not use
+     * full segment encryption with identity key.
      */
-    public final boolean isEncrypted;
-    /**
-     * The encryption key uri as defined by #EXT-X-KEY, or null if the segment is not encrypted.
-     */
-    public final String encryptionKeyUri;
+    public final String fullSegmentEncryptionKeyUri;
     /**
      * The encryption initialization vector as defined by #EXT-X-KEY, or null if the segment is not
      * encrypted.
@@ -73,7 +71,7 @@
     public final long byterangeLength;
 
     public Segment(String uri, long byterangeOffset, long byterangeLength) {
-      this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
+      this(uri, 0, -1, C.TIME_UNSET, null, null, byterangeOffset, byterangeLength);
     }
 
     /**
@@ -81,21 +79,19 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
      * @param durationUs See {@link #durationUs}.
      * @param relativeDiscontinuitySequence See {@link #relativeDiscontinuitySequence}.
      * @param relativeStartTimeUs See {@link #relativeStartTimeUs}.
-     * @param isEncrypted See {@link #isEncrypted}.
-     * @param encryptionKeyUri See {@link #encryptionKeyUri}.
+     * @param fullSegmentEncryptionKeyUri See {@link #fullSegmentEncryptionKeyUri}.
      * @param encryptionIV See {@link #encryptionIV}.
      * @param byterangeOffset See {@link #byterangeOffset}.
      * @param byterangeLength See {@link #byterangeLength}.
      */
     public Segment(String url, long durationUs, int relativeDiscontinuitySequence,
-        long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
-        long byterangeOffset, long byterangeLength) {
+        long relativeStartTimeUs, String fullSegmentEncryptionKeyUri,
+        String encryptionIV, long byterangeOffset, long byterangeLength) {
       this.url = url;
       this.durationUs = durationUs;
       this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
       this.relativeStartTimeUs = relativeStartTimeUs;
-      this.isEncrypted = isEncrypted;
-      this.encryptionKeyUri = encryptionKeyUri;
+      this.fullSegmentEncryptionKeyUri = fullSegmentEncryptionKeyUri;
       this.encryptionIV = encryptionIV;
       this.byterangeOffset = byterangeOffset;
       this.byterangeLength = byterangeLength;
@@ -110,7 +106,7 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
   }
 
   /**
-   * Type of the playlist as defined by #EXT-X-PLAYLIST-TYPE.
+   * Type of the playlist, as defined by #EXT-X-PLAYLIST-TYPE.
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
@@ -165,6 +161,11 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * Whether the playlist contains a #EXT-X-PROGRAM-DATE-TIME tag.
    */
   public final boolean hasProgramDateTime;
+  /**
+   * DRM initialization data for sample decryption, or null if none of the segment uses sample
+   * encryption.
+   */
+  public final DrmInitData drmInitData;
   /**
    * The initialization segment, as defined by #EXT-X-MAP.
    */
@@ -192,6 +193,7 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * @param hasIndependentSegmentsTag See {@link #hasIndependentSegmentsTag}.
    * @param hasEndTag See {@link #hasEndTag}.
    * @param hasProgramDateTime See {@link #hasProgramDateTime}.
+   * @param drmInitData See {@link #drmInitData}.
    * @param initializationSegment See {@link #initializationSegment}.
    * @param segments See {@link #segments}.
    */
@@ -199,7 +201,7 @@ public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, List<Str
       long startOffsetUs, long startTimeUs, boolean hasDiscontinuitySequence,
       int discontinuitySequence, int mediaSequence, int version, long targetDurationUs,
       boolean hasIndependentSegmentsTag, boolean hasEndTag, boolean hasProgramDateTime,
-      Segment initializationSegment, List<Segment> segments) {
+      DrmInitData drmInitData, Segment initializationSegment, List<Segment> segments) {
     super(baseUri, tags);
     this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
@@ -211,6 +213,7 @@ public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, List<Str
     this.hasIndependentSegmentsTag = hasIndependentSegmentsTag;
     this.hasEndTag = hasEndTag;
     this.hasProgramDateTime = hasProgramDateTime;
+    this.drmInitData = drmInitData;
     this.initializationSegment = initializationSegment;
     this.segments = Collections.unmodifiableList(segments);
     if (!segments.isEmpty()) {
@@ -262,7 +265,7 @@ public long getEndTimeUs() {
   public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
     return new HlsMediaPlaylist(playlistType, baseUri, tags, startOffsetUs, startTimeUs, true,
         discontinuitySequence, mediaSequence, version, targetDurationUs, hasIndependentSegmentsTag,
-        hasEndTag, hasProgramDateTime, initializationSegment, segments);
+        hasEndTag, hasProgramDateTime, drmInitData, initializationSegment, segments);
   }
 
   /**
@@ -277,7 +280,8 @@ public HlsMediaPlaylist copyWithEndTag() {
     }
     return new HlsMediaPlaylist(playlistType, baseUri, tags, startOffsetUs, startTimeUs,
         hasDiscontinuitySequence, discontinuitySequence, mediaSequence, version, targetDurationUs,
-        hasIndependentSegmentsTag, true, hasProgramDateTime, initializationSegment, segments);
+        hasIndependentSegmentsTag, true, hasProgramDateTime, drmInitData, initializationSegment,
+        segments);
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 09d6fcfa18..c63ded6275 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -16,9 +16,12 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.net.Uri;
+import android.util.Base64;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
@@ -28,10 +31,11 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.regex.Matcher;
@@ -69,7 +73,13 @@
   private static final String TYPE_CLOSED_CAPTIONS = "CLOSED-CAPTIONS";
 
   private static final String METHOD_NONE = "NONE";
-  private static final String METHOD_AES128 = "AES-128";
+  private static final String METHOD_AES_128 = "AES-128";
+  private static final String METHOD_SAMPLE_AES = "SAMPLE-AES";
+  private static final String METHOD_SAMPLE_AES_CENC = "SAMPLE-AES-CENC";
+  private static final String KEYFORMAT_IDENTITY = "identity";
+  private static final String KEYFORMAT_WIDEVINE_PSSH_BINARY =
+      "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
+  private static final String KEYFORMAT_WIDEVINE_PSSH_JSON = "com.widevine";
 
   private static final String BOOLEAN_TRUE = "YES";
   private static final String BOOLEAN_FALSE = "NO";
@@ -81,6 +91,7 @@
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("[^-]BANDWIDTH=(\\d+)\\b");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
+  private static final Pattern REGEX_FRAME_RATE = Pattern.compile("FRAME-RATE=([\\d\\.]+)\\b");
   private static final Pattern REGEX_TARGET_DURATION = Pattern.compile(TAG_TARGET_DURATION
       + ":(\\d+)\\b");
   private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
@@ -96,7 +107,8 @@
   private static final Pattern REGEX_ATTR_BYTERANGE =
       Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
   private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
-      + METHOD_AES128 + ")");
+      + METHOD_AES_128 + "|" + METHOD_SAMPLE_AES + ")");
+  private static final Pattern REGEX_KEYFORMAT = Pattern.compile("KEYFORMAT=\"(.+?)\"");
   private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
   private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
   private static final Pattern REGEX_TYPE = Pattern.compile("TYPE=(" + TYPE_AUDIO + "|" + TYPE_VIDEO
@@ -112,7 +124,7 @@
   @Override
   public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-    Queue<String> extraLines = new LinkedList<>();
+    Queue<String> extraLines = new ArrayDeque<>();
     String line;
     try {
       if (!checkPlaylistHeader(reader)) {
@@ -238,6 +250,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
             break;
         }
       } else if (line.startsWith(TAG_STREAM_INF)) {
+        noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
         String averageBandwidthString = parseOptionalStringAttr(line, REGEX_AVERAGE_BANDWIDTH);
         if (averageBandwidthString != null) {
@@ -246,7 +259,6 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         }
         String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
         String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
-        noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int width;
         int height;
         if (resolutionString != null) {
@@ -262,11 +274,15 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           width = Format.NO_VALUE;
           height = Format.NO_VALUE;
         }
+        float frameRate = Format.NO_VALUE;
+        String frameRateString = parseOptionalStringAttr(line, REGEX_FRAME_RATE);
+        if (frameRateString != null) {
+          frameRate = Float.parseFloat(frameRateString);
+        }
         line = iterator.next(); // #EXT-X-STREAM-INF's URI.
         if (variantUrls.add(line)) {
           Format format = Format.createVideoContainerFormat(Integer.toString(variants.size()),
-              MimeTypes.APPLICATION_M3U8, null, codecs, bitrate, width, height, Format.NO_VALUE,
-              null, 0);
+              MimeTypes.APPLICATION_M3U8, null, codecs, bitrate, width, height, frameRate, null, 0);
           variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
         }
       }
@@ -308,9 +324,9 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     long segmentByteRangeLength = C.LENGTH_UNSET;
     int segmentMediaSequence = 0;
 
-    boolean isEncrypted = false;
     String encryptionKeyUri = null;
     String encryptionIV = null;
+    DrmInitData drmInitData = null;
 
     String line;
     while (iterator.hasNext()) {
@@ -355,13 +371,26 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
             (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_KEY)) {
         String method = parseStringAttr(line, REGEX_METHOD);
-        isEncrypted = METHOD_AES128.equals(method);
-        if (isEncrypted) {
-          encryptionKeyUri = parseStringAttr(line, REGEX_URI);
+        String keyFormat = parseOptionalStringAttr(line, REGEX_KEYFORMAT);
+        encryptionKeyUri = null;
+        encryptionIV = null;
+        if (!METHOD_NONE.equals(method)) {
           encryptionIV = parseOptionalStringAttr(line, REGEX_IV);
-        } else {
-          encryptionKeyUri = null;
-          encryptionIV = null;
+          if (KEYFORMAT_IDENTITY.equals(keyFormat) || keyFormat == null) {
+            if (METHOD_AES_128.equals(method)) {
+              // The segment is fully encrypted using an identity key.
+              encryptionKeyUri = parseStringAttr(line, REGEX_URI);
+            } else {
+              // Do nothing. Samples are encrypted using an identity key, but this is not supported.
+              // Hopefully, a traditional DRM alternative is also provided.
+            }
+          } else {
+            SchemeData schemeData = parseWidevineSchemeData(line, keyFormat);
+            if (schemeData != null) {
+              drmInitData = new DrmInitData(METHOD_SAMPLE_AES_CENC.equals(method)
+                  ? C.CENC_TYPE_cenc : C.CENC_TYPE_cbcs, schemeData);
+            }
+          }
         }
       } else if (line.startsWith(TAG_BYTERANGE)) {
         String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
@@ -383,7 +412,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         }
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
-        if (!isEncrypted) {
+        if (encryptionKeyUri == null) {
           segmentEncryptionIV = null;
         } else if (encryptionIV != null) {
           segmentEncryptionIV = encryptionIV;
@@ -395,7 +424,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           segmentByteRangeOffset = 0;
         }
         segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
-            segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
+            segmentStartTimeUs, encryptionKeyUri, segmentEncryptionIV,
             segmentByteRangeOffset, segmentByteRangeLength));
         segmentStartTimeUs += segmentDurationUs;
         segmentDurationUs = 0;
@@ -412,7 +441,24 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     return new HlsMediaPlaylist(playlistType, baseUri, tags, startOffsetUs, playlistStartTimeUs,
         hasDiscontinuitySequence, playlistDiscontinuitySequence, mediaSequence, version,
         targetDurationUs, hasIndependentSegmentsTag, hasEndTag, playlistStartTimeUs != 0,
-        initializationSegment, segments);
+        drmInitData, initializationSegment, segments);
+  }
+
+  private static SchemeData parseWidevineSchemeData(String line, String keyFormat)
+      throws ParserException {
+    if (KEYFORMAT_WIDEVINE_PSSH_BINARY.equals(keyFormat)) {
+     String uriString = parseStringAttr(line, REGEX_URI);
+     return new SchemeData(C.WIDEVINE_UUID, MimeTypes.VIDEO_MP4,
+         Base64.decode(uriString.substring(uriString.indexOf(',')), Base64.DEFAULT));
+    }
+    if (KEYFORMAT_WIDEVINE_PSSH_JSON.equals(keyFormat)) {
+      try {
+        return new SchemeData(C.WIDEVINE_UUID, "hls", line.getBytes(C.UTF8_NAME));
+      } catch (UnsupportedEncodingException e) {
+        throw new ParserException(e);
+      }
+    }
+    return null;
   }
 
   private static int parseIntAttr(String line, Pattern pattern) throws ParserException {
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index 567dbd4af6..355a8575ca 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -112,15 +112,10 @@ private PlaylistResetException(String url) {
    * which an unchanging playlist is considered stuck.
    */
   private static final double PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT = 3.5;
-  /**
-   * The minimum number of milliseconds that a url is kept as primary url, if no
-   * {@link #getPlaylistSnapshot} call is made for that url.
-   */
-  private static final long PRIMARY_URL_KEEPALIVE_MS = 15000;
 
   private final Uri initialPlaylistUri;
   private final HlsDataSourceFactory dataSourceFactory;
-  private final HlsPlaylistParser playlistParser;
+  private final ParsingLoadable.Parser<HlsPlaylist> playlistParser;
   private final int minRetryCount;
   private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
   private final Handler playlistRefreshHandler;
@@ -139,21 +134,23 @@ private PlaylistResetException(String url) {
    *     playlist or a master playlist.
    * @param dataSourceFactory A factory for {@link DataSource} instances.
    * @param eventDispatcher A dispatcher to notify of events.
-   * @param minRetryCount The minimum number of times the load must be retried before blacklisting a
-   *     playlist.
+   * @param minRetryCount The minimum number of times loads must be retried before
+   *     {@link #maybeThrowPlaylistRefreshError(HlsUrl)} and
+   *     {@link #maybeThrowPrimaryPlaylistRefreshError()} propagate any loading errors.
    * @param primaryPlaylistListener A callback for the primary playlist change events.
    */
   public HlsPlaylistTracker(Uri initialPlaylistUri, HlsDataSourceFactory dataSourceFactory,
       EventDispatcher eventDispatcher, int minRetryCount,
-      PrimaryPlaylistListener primaryPlaylistListener) {
+      PrimaryPlaylistListener primaryPlaylistListener,
+      ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
     this.initialPlaylistUri = initialPlaylistUri;
     this.dataSourceFactory = dataSourceFactory;
     this.eventDispatcher = eventDispatcher;
     this.minRetryCount = minRetryCount;
     this.primaryPlaylistListener = primaryPlaylistListener;
+    this.playlistParser = playlistParser;
     listeners = new ArrayList<>();
     initialPlaylistLoader = new Loader("HlsPlaylistTracker:MasterPlaylist");
-    playlistParser = new HlsPlaylistParser();
     playlistBundles = new IdentityHashMap<>();
     playlistRefreshHandler = new Handler();
   }
@@ -343,27 +340,22 @@ private boolean maybeSelectNewPrimaryUrl() {
   }
 
   private void maybeSetPrimaryUrl(HlsUrl url) {
-    if (!masterPlaylist.variants.contains(url)
+    if (url == primaryHlsUrl
+        || !masterPlaylist.variants.contains(url)
         || (primaryUrlSnapshot != null && primaryUrlSnapshot.hasEndTag)) {
-      // Only allow variant urls to be chosen as primary. Also prevent changing the primary url if
-      // the last primary snapshot contains an end tag.
+      // Ignore if the primary url is unchanged, if the url is not a variant url, or if the last
+      // primary snapshot contains an end tag.
       return;
     }
-    MediaPlaylistBundle currentPrimaryBundle = playlistBundles.get(primaryHlsUrl);
-    long primarySnapshotAccessAgeMs =
-        currentPrimaryBundle.lastSnapshotAccessTimeMs - SystemClock.elapsedRealtime();
-    if (primarySnapshotAccessAgeMs > PRIMARY_URL_KEEPALIVE_MS) {
-      primaryHlsUrl = url;
-      playlistBundles.get(primaryHlsUrl).loadPlaylist();
-    }
+    primaryHlsUrl = url;
+    playlistBundles.get(primaryHlsUrl).loadPlaylist();
   }
 
   private void createBundles(List<HlsUrl> urls) {
     int listSize = urls.size();
-    long currentTimeMs = SystemClock.elapsedRealtime();
     for (int i = 0; i < listSize; i++) {
       HlsUrl url = urls.get(i);
-      MediaPlaylistBundle bundle = new MediaPlaylistBundle(url, currentTimeMs);
+      MediaPlaylistBundle bundle = new MediaPlaylistBundle(url);
       playlistBundles.put(url, bundle);
     }
   }
@@ -373,9 +365,8 @@ private void createBundles(List<HlsUrl> urls) {
    *
    * @param url The url of the playlist.
    * @param newSnapshot The new snapshot.
-   * @return True if a refresh should be scheduled.
    */
-  private boolean onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
+  private void onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
     if (url == primaryHlsUrl) {
       if (primaryUrlSnapshot == null) {
         // This is the first primary url snapshot.
@@ -388,8 +379,6 @@ private boolean onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
     for (int i = 0; i < listenersSize; i++) {
       listeners.get(i).onPlaylistChanged();
     }
-    // If the primary playlist is not the final one, we should schedule a refresh.
-    return url == primaryHlsUrl && !newSnapshot.hasEndTag;
   }
 
   private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
@@ -479,14 +468,13 @@ private static Segment getFirstOldOverlappingSegment(HlsMediaPlaylist oldPlaylis
     private HlsMediaPlaylist playlistSnapshot;
     private long lastSnapshotLoadMs;
     private long lastSnapshotChangeMs;
-    private long lastSnapshotAccessTimeMs;
+    private long earliestNextLoadTimeMs;
     private long blacklistUntilMs;
-    private boolean pendingRefresh;
+    private boolean loadPending;
     private IOException playlistError;
 
-    public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTimeMs) {
+    public MediaPlaylistBundle(HlsUrl playlistUrl) {
       this.playlistUrl = playlistUrl;
-      lastSnapshotAccessTimeMs = initialLastSnapshotAccessTimeMs;
       mediaPlaylistLoader = new Loader("HlsPlaylistTracker:MediaPlaylist");
       mediaPlaylistLoadable = new ParsingLoadable<>(
           dataSourceFactory.createDataSource(C.DATA_TYPE_MANIFEST),
@@ -495,7 +483,6 @@ public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTim
     }
 
     public HlsMediaPlaylist getPlaylistSnapshot() {
-      lastSnapshotAccessTimeMs = SystemClock.elapsedRealtime();
       return playlistSnapshot;
     }
 
@@ -517,8 +504,16 @@ public void release() {
 
     public void loadPlaylist() {
       blacklistUntilMs = 0;
-      if (!pendingRefresh && !mediaPlaylistLoader.isLoading()) {
-        mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
+      if (loadPending || mediaPlaylistLoader.isLoading()) {
+        // Load already pending or in progress. Do nothing.
+        return;
+      }
+      long currentTimeMs = SystemClock.elapsedRealtime();
+      if (currentTimeMs < earliestNextLoadTimeMs) {
+        loadPending = true;
+        playlistRefreshHandler.postDelayed(this, earliestNextLoadTimeMs - currentTimeMs);
+      } else {
+        loadPlaylistImmediately();
       }
     }
 
@@ -562,8 +557,7 @@ public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealti
       }
       boolean shouldRetry = true;
       if (ChunkedTrackBlacklistUtil.shouldBlacklist(error)) {
-        blacklistPlaylist();
-        shouldRetry = primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
+        shouldRetry = blacklistPlaylist();
       }
       return shouldRetry ? Loader.RETRY : Loader.DONT_RETRY;
     }
@@ -572,48 +566,60 @@ public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealti
 
     @Override
     public void run() {
-      pendingRefresh = false;
-      loadPlaylist();
+      loadPending = false;
+      loadPlaylistImmediately();
     }
 
     // Internal methods.
 
+    private void loadPlaylistImmediately() {
+      mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
+    }
+
     private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
       HlsMediaPlaylist oldPlaylist = playlistSnapshot;
       long currentTimeMs = SystemClock.elapsedRealtime();
       lastSnapshotLoadMs = currentTimeMs;
       playlistSnapshot = getLatestPlaylistSnapshot(oldPlaylist, loadedPlaylist);
-      long refreshDelayUs = C.TIME_UNSET;
       if (playlistSnapshot != oldPlaylist) {
         playlistError = null;
         lastSnapshotChangeMs = currentTimeMs;
-        if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
-          refreshDelayUs = playlistSnapshot.targetDurationUs;
-        }
+        onPlaylistUpdated(playlistUrl, playlistSnapshot);
       } else if (!playlistSnapshot.hasEndTag) {
-        if (currentTimeMs - lastSnapshotChangeMs
+        if (loadedPlaylist.mediaSequence + loadedPlaylist.segments.size()
+            < playlistSnapshot.mediaSequence) {
+          // The media sequence jumped backwards. The server has probably reset.
+          playlistError = new PlaylistResetException(playlistUrl.url);
+        } else if (currentTimeMs - lastSnapshotChangeMs
             > C.usToMs(playlistSnapshot.targetDurationUs)
                 * PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT) {
-          // The playlist seems to be stuck, we blacklist it.
+          // The playlist seems to be stuck. Blacklist it.
           playlistError = new PlaylistStuckException(playlistUrl.url);
           blacklistPlaylist();
-        } else if (loadedPlaylist.mediaSequence + loadedPlaylist.segments.size()
-            < playlistSnapshot.mediaSequence) {
-          // The media sequence has jumped backwards. The server has likely reset.
-          playlistError = new PlaylistResetException(playlistUrl.url);
         }
-        refreshDelayUs = playlistSnapshot.targetDurationUs / 2;
       }
-      if (refreshDelayUs != C.TIME_UNSET) {
-        // See HLS spec v20, section 6.3.4 for more information on media playlist refreshing.
-        pendingRefresh = playlistRefreshHandler.postDelayed(this, C.usToMs(refreshDelayUs));
+      // Do not allow the playlist to load again within the target duration if we obtained a new
+      // snapshot, or half the target duration otherwise.
+      earliestNextLoadTimeMs = currentTimeMs + C.usToMs(playlistSnapshot != oldPlaylist
+          ? playlistSnapshot.targetDurationUs : (playlistSnapshot.targetDurationUs / 2));
+      // Schedule a load if this is the primary playlist and it doesn't have an end tag. Else the
+      // next load will be scheduled when refreshPlaylist is called, or when this playlist becomes
+      // the primary.
+      if (playlistUrl == primaryHlsUrl && !playlistSnapshot.hasEndTag) {
+        loadPlaylist();
       }
     }
 
-    private void blacklistPlaylist() {
+    /**
+     * Blacklists the playlist.
+     *
+     * @return Whether the playlist is the primary, despite being blacklisted.
+     */
+    private boolean blacklistPlaylist() {
       blacklistUntilMs = SystemClock.elapsedRealtime()
           + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;
       notifyPlaylistBlacklisting(playlistUrl, ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);
+      return primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
     }
 
   }
diff --git a/library/smoothstreaming/src/androidTest/AndroidManifest.xml b/library/smoothstreaming/src/androidTest/AndroidManifest.xml
index ab314ce806..1d2317677b 100644
--- a/library/smoothstreaming/src/androidTest/AndroidManifest.xml
+++ b/library/smoothstreaming/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.source.smoothstreaming.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java b/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
new file mode 100644
index 0000000000..f172293c22
--- /dev/null
+++ b/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.manifest;
+
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link SsManifest}.
+ */
+public class SsManifestTest extends TestCase {
+
+  private static final ProtectionElement DUMMY_PROTECTION_ELEMENT =
+      new ProtectionElement(C.WIDEVINE_UUID, new byte[] {0, 1, 2});
+
+  public void testCopy() throws Exception {
+    Format[][] formats = newFormats(2, 3);
+    SsManifest sourceManifest = newSsManifest(
+        newStreamElement("1",formats[0]),
+        newStreamElement("2", formats[1]));
+
+    List<TrackKey> keys = Arrays.asList(
+        new TrackKey(0, 0),
+        new TrackKey(0, 2),
+        new TrackKey(1, 0));
+    // Keys don't need to be in any particular order
+    Collections.shuffle(keys, new Random(0));
+
+    SsManifest copyManifest = sourceManifest.copy(keys);
+
+    SsManifest expectedManifest = newSsManifest(
+        newStreamElement("1", formats[0][0], formats[0][2]),
+        newStreamElement("2", formats[1][0]));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  public void testCopyRemoveStreamElement() throws Exception {
+    Format[][] formats = newFormats(2, 3);
+    SsManifest sourceManifest = newSsManifest(
+        newStreamElement("1", formats[0]),
+        newStreamElement("2", formats[1]));
+
+    List<TrackKey> keys = Arrays.asList(
+        new TrackKey(1, 0));
+    // Keys don't need to be in any particular order
+    Collections.shuffle(keys, new Random(0));
+
+    SsManifest copyManifest = sourceManifest.copy(keys);
+
+    SsManifest expectedManifest = newSsManifest(
+        newStreamElement("2", formats[1][0]));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  private static void assertManifestEquals(SsManifest expected, SsManifest actual) {
+    assertEquals(expected.durationUs, actual.durationUs);
+    assertEquals(expected.dvrWindowLengthUs, actual.dvrWindowLengthUs);
+    assertEquals(expected.isLive, actual.isLive);
+    assertEquals(expected.lookAheadCount, actual.lookAheadCount);
+    assertEquals(expected.majorVersion, actual.majorVersion);
+    assertEquals(expected.minorVersion, actual.minorVersion);
+    assertEquals(expected.protectionElement.uuid, actual.protectionElement.uuid);
+    assertEquals(expected.protectionElement, actual.protectionElement);
+    for (int i = 0; i < expected.streamElements.length; i++) {
+      StreamElement expectedStreamElement = expected.streamElements[i];
+      StreamElement actualStreamElement = actual.streamElements[i];
+      assertEquals(expectedStreamElement.chunkCount, actualStreamElement.chunkCount);
+      assertEquals(expectedStreamElement.displayHeight, actualStreamElement.displayHeight);
+      assertEquals(expectedStreamElement.displayWidth, actualStreamElement.displayWidth);
+      assertEquals(expectedStreamElement.language, actualStreamElement.language);
+      assertEquals(expectedStreamElement.maxHeight, actualStreamElement.maxHeight);
+      assertEquals(expectedStreamElement.maxWidth, actualStreamElement.maxWidth);
+      assertEquals(expectedStreamElement.name, actualStreamElement.name);
+      assertEquals(expectedStreamElement.subType, actualStreamElement.subType);
+      assertEquals(expectedStreamElement.timescale, actualStreamElement.timescale);
+      assertEquals(expectedStreamElement.type, actualStreamElement.type);
+      MoreAsserts.assertEquals(expectedStreamElement.formats, actualStreamElement.formats);
+    }
+  }
+
+  private static Format[][] newFormats(int streamElementCount, int trackCounts) {
+    Format[][] formats = new Format[streamElementCount][];
+    for (int i = 0; i < streamElementCount; i++) {
+      formats[i] = new Format[trackCounts];
+      for (int j = 0; j < trackCounts; j++) {
+        formats[i][j] = newFormat(i + "." + j);
+      }
+    }
+    return formats;
+  }
+
+  private static SsManifest newSsManifest(StreamElement... streamElements) {
+    return new SsManifest(1, 2, 1000, 5000, 0, 0, false, DUMMY_PROTECTION_ELEMENT, streamElements);
+  }
+
+  private static StreamElement newStreamElement(String name, Format... formats) {
+    return new StreamElement("baseUri", "chunkTemplate", C.TRACK_TYPE_VIDEO, "subType",
+        1000, name, 1024, 768, 1024, 768, null, formats, Collections.<Long>emptyList(), 0);
+  }
+
+  private static Format newFormat(String id) {
+    return Format.createContainerFormat(id, MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null,
+        Format.NO_VALUE, 0, null);
+  }
+
+}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index f2e4c57298..5a6493b702 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -101,8 +101,8 @@ public DefaultSsChunkSource(LoaderErrorThrower manifestLoaderErrorThrower, SsMan
           trackEncryptionBoxes, nalUnitLengthFieldLength, null, null);
       FragmentedMp4Extractor extractor = new FragmentedMp4Extractor(
           FragmentedMp4Extractor.FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
-          | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, null, track);
-      extractorWrappers[i] = new ChunkExtractorWrapper(extractor, format);
+          | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, null, track, null);
+      extractorWrappers[i] = new ChunkExtractorWrapper(extractor, streamElement.type, format);
     }
   }
 
@@ -149,14 +149,12 @@ public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaCh
   }
 
   @Override
-  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out) {
+  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+      ChunkHolder out) {
     if (fatalError != null) {
       return;
     }
 
-    long bufferedDurationUs = previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
-    trackSelection.updateSelectedTrack(bufferedDurationUs);
-
     StreamElement streamElement = manifest.streamElements[elementIndex];
     if (streamElement.chunkCount == 0) {
       // There aren't any chunks for us to load.
@@ -166,7 +164,7 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
 
     int chunkIndex;
     if (previous == null) {
-      chunkIndex = streamElement.getChunkIndex(playbackPositionUs);
+      chunkIndex = streamElement.getChunkIndex(loadPositionUs);
     } else {
       chunkIndex = previous.getNextChunkIndex() - currentManifestChunkOffset;
       if (chunkIndex < 0) {
@@ -182,6 +180,10 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
       return;
     }
 
+    long bufferedDurationUs = loadPositionUs - playbackPositionUs;
+    long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
+    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
+
     long chunkStartTimeUs = streamElement.getStartTimeUs(chunkIndex);
     long chunkEndTimeUs = chunkStartTimeUs + streamElement.getChunkDurationUs(chunkIndex);
     int currentAbsoluteChunkIndex = chunkIndex + currentManifestChunkOffset;
@@ -222,4 +224,16 @@ private static MediaChunk newMediaChunk(Format format, DataSource dataSource, Ur
         extractorWrapper);
   }
 
+  private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
+    if (!manifest.isLive) {
+      return C.TIME_UNSET;
+    }
+
+    StreamElement currentElement = manifest.streamElements[elementIndex];
+    int lastChunkIndex = currentElement.chunkCount - 1;
+    long lastChunkEndTimeUs = currentElement.getStartTimeUs(lastChunkIndex)
+        + currentElement.getChunkDurationUs(lastChunkIndex);
+    return lastChunkEndTimeUs - playbackPositionUs;
+  }
+
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index 885d5bd227..548f787741 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -193,8 +193,8 @@ private SsMediaSource(SsManifest manifest, Uri manifestUri,
     Assertions.checkState(manifest == null || !manifest.isLive);
     this.manifest = manifest;
     this.manifestUri = manifestUri == null ? null
-        : Util.toLowerInvariant(manifestUri.getLastPathSegment()).equals("manifest") ? manifestUri
-            : Uri.withAppendedPath(manifestUri, "Manifest");
+        : Util.toLowerInvariant(manifestUri.getLastPathSegment()).matches("manifest(\\(.+\\))?")
+            ? manifestUri : Uri.withAppendedPath(manifestUri, "Manifest");
     this.manifestDataSourceFactory = manifestDataSourceFactory;
     this.manifestParser = manifestParser;
     this.chunkSourceFactory = chunkSourceFactory;
@@ -328,7 +328,7 @@ private void processManifest() {
       timeline = new SinglePeriodTimeline(startTimeUs + durationUs, durationUs, startTimeUs, 0,
           true /* isSeekable */, false /* isDynamic */);
     }
-    sourceListener.onSourceInfoRefreshed(timeline, manifest);
+    sourceListener.onSourceInfoRefreshed(this, timeline, manifest);
   }
 
   private void scheduleManifestRefresh() {
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
index 1bb877eb59..fbc3726a0e 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
@@ -21,6 +21,9 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.UUID;
 
@@ -96,16 +99,60 @@
   public SsManifest(int majorVersion, int minorVersion, long timescale, long duration,
       long dvrWindowLength, int lookAheadCount, boolean isLive, ProtectionElement protectionElement,
       StreamElement[] streamElements) {
+    this(majorVersion, minorVersion,
+        duration == 0 ? C.TIME_UNSET
+            : Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, timescale),
+        dvrWindowLength == 0 ? C.TIME_UNSET
+            : Util.scaleLargeTimestamp(dvrWindowLength, C.MICROS_PER_SECOND, timescale),
+        lookAheadCount, isLive, protectionElement, streamElements);
+  }
+
+  private SsManifest(int majorVersion, int minorVersion, long durationUs, long dvrWindowLengthUs,
+      int lookAheadCount, boolean isLive, ProtectionElement protectionElement,
+      StreamElement[] streamElements) {
     this.majorVersion = majorVersion;
     this.minorVersion = minorVersion;
+    this.durationUs = durationUs;
+    this.dvrWindowLengthUs = dvrWindowLengthUs;
     this.lookAheadCount = lookAheadCount;
     this.isLive = isLive;
     this.protectionElement = protectionElement;
     this.streamElements = streamElements;
-    dvrWindowLengthUs = dvrWindowLength == 0 ? C.TIME_UNSET
-        : Util.scaleLargeTimestamp(dvrWindowLength, C.MICROS_PER_SECOND, timescale);
-    durationUs = duration == 0 ? C.TIME_UNSET
-        : Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, timescale);
+  }
+
+  /**
+   * Creates a copy of this manifest which includes only the tracks identified by the given keys.
+   *
+   * @param trackKeys List of keys for the tracks to be included in the copy.
+   * @return A copy of this manifest with the selected tracks.
+   * @throws IndexOutOfBoundsException If a key has an invalid index.
+   */
+  public final SsManifest copy(List<TrackKey> trackKeys) {
+    LinkedList<TrackKey> sortedKeys = new LinkedList<>(trackKeys);
+    Collections.sort(sortedKeys);
+
+    StreamElement currentStreamElement = null;
+    List<StreamElement> copiedStreamElements = new ArrayList<>();
+    List<Format> copiedFormats = new ArrayList<>();
+    for (int i = 0; i < sortedKeys.size(); i++) {
+      TrackKey key = sortedKeys.get(i);
+      StreamElement streamElement = streamElements[key.streamElementIndex];
+      if (streamElement != currentStreamElement && currentStreamElement != null) {
+        // We're advancing to a new stream element. Add the current one.
+        copiedStreamElements.add(currentStreamElement.copy(copiedFormats.toArray(new Format[0])));
+        copiedFormats.clear();
+      }
+      currentStreamElement = streamElement;
+      copiedFormats.add(streamElement.formats[key.trackIndex]);
+    }
+    if (currentStreamElement != null) {
+      // Add the last stream element.
+      copiedStreamElements.add(currentStreamElement.copy(copiedFormats.toArray(new Format[0])));
+    }
+
+    StreamElement[] copiedStreamElementsArray = copiedStreamElements.toArray(new StreamElement[0]);
+    return new SsManifest(majorVersion, minorVersion, durationUs, dvrWindowLengthUs, lookAheadCount,
+        isLive, protectionElement, copiedStreamElementsArray);
   }
 
   /**
@@ -156,6 +203,16 @@ public StreamElement(String baseUri, String chunkTemplate, int type, String subT
         long timescale, String name, int maxWidth, int maxHeight, int displayWidth,
         int displayHeight, String language, Format[] formats, List<Long> chunkStartTimes,
         long lastChunkDuration) {
+      this (baseUri, chunkTemplate, type, subType, timescale, name, maxWidth, maxHeight,
+          displayWidth, displayHeight, language, formats, chunkStartTimes,
+          Util.scaleLargeTimestamps(chunkStartTimes, C.MICROS_PER_SECOND, timescale),
+          Util.scaleLargeTimestamp(lastChunkDuration, C.MICROS_PER_SECOND, timescale));
+    }
+
+    private StreamElement(String baseUri, String chunkTemplate, int type, String subType,
+        long timescale, String name, int maxWidth, int maxHeight, int displayWidth,
+        int displayHeight, String language, Format[] formats, List<Long> chunkStartTimes,
+        long[] chunkStartTimesUs, long lastChunkDurationUs) {
       this.baseUri = baseUri;
       this.chunkTemplate = chunkTemplate;
       this.type = type;
@@ -168,12 +225,23 @@ public StreamElement(String baseUri, String chunkTemplate, int type, String subT
       this.displayHeight = displayHeight;
       this.language = language;
       this.formats = formats;
-      this.chunkCount = chunkStartTimes.size();
       this.chunkStartTimes = chunkStartTimes;
-      lastChunkDurationUs =
-          Util.scaleLargeTimestamp(lastChunkDuration, C.MICROS_PER_SECOND, timescale);
-      chunkStartTimesUs =
-          Util.scaleLargeTimestamps(chunkStartTimes, C.MICROS_PER_SECOND, timescale);
+      this.chunkStartTimesUs = chunkStartTimesUs;
+      this.lastChunkDurationUs = lastChunkDurationUs;
+      chunkCount = chunkStartTimes.size();
+    }
+
+    /**
+     * Creates a copy of this stream element with the formats replaced with those specified.
+     *
+     * @param formats The formats to be included in the copy.
+     * @return A copy of this stream element with the formats replaced.
+     * @throws IndexOutOfBoundsException If a key has an invalid index.
+     */
+    public StreamElement copy(Format[] formats) {
+      return new StreamElement(baseUri, chunkTemplate, type, subType, timescale, name, maxWidth,
+          maxHeight, displayWidth, displayHeight, language, formats, chunkStartTimes,
+          chunkStartTimesUs, lastChunkDurationUs);
     }
 
     /**
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 5784cc7bc6..3ca5f8d997 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -375,7 +375,7 @@ public Object build() {
       StreamElement[] streamElementArray = new StreamElement[streamElements.size()];
       streamElements.toArray(streamElementArray);
       if (protectionElement != null) {
-        DrmInitData drmInitData = new DrmInitData(new SchemeData(protectionElement.uuid, null,
+        DrmInitData drmInitData = new DrmInitData(new SchemeData(protectionElement.uuid,
             MimeTypes.VIDEO_MP4, protectionElement.data));
         for (StreamElement streamElement : streamElementArray) {
           for (int i = 0; i < streamElement.formats.length; i++) {
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/TrackKey.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/TrackKey.java
new file mode 100644
index 0000000000..ed52e6fa12
--- /dev/null
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/TrackKey.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.manifest;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.NonNull;
+
+/**
+ * Uniquely identifies a track in a {@link SsManifest}.
+ */
+public final class TrackKey implements Parcelable, Comparable<TrackKey> {
+
+  public final int streamElementIndex;
+  public final int trackIndex;
+
+  public TrackKey(int streamElementIndex, int trackIndex) {
+    this.streamElementIndex = streamElementIndex;
+    this.trackIndex = trackIndex;
+  }
+
+  @Override
+  public String toString() {
+    return streamElementIndex + "." + trackIndex;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(streamElementIndex);
+    dest.writeInt(trackIndex);
+  }
+
+  public static final Creator<TrackKey> CREATOR = new Creator<TrackKey>() {
+    @Override
+    public TrackKey createFromParcel(Parcel in) {
+      return new TrackKey(in.readInt(), in.readInt());
+    }
+
+    @Override
+    public TrackKey[] newArray(int size) {
+      return new TrackKey[size];
+    }
+  };
+
+  // Comparable implementation.
+
+  @Override
+  public int compareTo(@NonNull TrackKey o) {
+    int result = streamElementIndex - o.streamElementIndex;
+    if (result == 0) {
+      result = trackIndex - o.trackIndex;
+    }
+    return result;
+  }
+
+}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
new file mode 100644
index 0000000000..5e9ae9a164
--- /dev/null
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.offline;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.SegmentDownloader;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.TrackKey;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Helper class to download SmoothStreaming streams.
+ *
+ * <p>Except {@link #getTotalSegments()}, {@link #getDownloadedSegments()} and
+ * {@link #getDownloadedBytes()}, this class isn't thread safe.
+ *
+ * <p>Example usage:
+ *
+ * <pre>
+ * {@code
+ * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor());
+ * DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
+ * DownloaderConstructorHelper constructorHelper =
+ *     new DownloaderConstructorHelper(cache, factory);
+ * SsDownloader ssDownloader = new SsDownloader(manifestUrl, constructorHelper);
+ * // Select the first track of the first stream element
+ * ssDownloader.selectRepresentations(new TrackKey[] {new TrackKey(0, 0)});
+ * ssDownloader.download(new ProgressListener() {
+ *   @Override
+ *   public void onDownloadProgress(Downloader downloader, float downloadPercentage,
+ *       long downloadedBytes) {
+ *     // Invoked periodically during the download.
+ *   }
+ * });
+ * // Access downloaded data using CacheDataSource
+ * CacheDataSource cacheDataSource =
+ *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);}
+ * </pre>
+ */
+public final class SsDownloader extends SegmentDownloader<SsManifest, TrackKey> {
+
+  /**
+   * @see SegmentDownloader#SegmentDownloader(Uri, DownloaderConstructorHelper)
+   */
+  public SsDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHelper)  {
+    super(manifestUri, constructorHelper);
+  }
+
+  @Override
+  public SsManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
+    DataSpec dataSpec = new DataSpec(uri,
+        DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
+    ParsingLoadable<SsManifest> loadable = new ParsingLoadable<>(dataSource, dataSpec,
+        C.DATA_TYPE_MANIFEST, new SsManifestParser());
+    loadable.load();
+    return loadable.getResult();
+  }
+
+  @Override
+  protected List<Segment> getAllSegments(DataSource dataSource, SsManifest manifest,
+      boolean allowIndexLoadErrors) throws InterruptedException, IOException {
+    ArrayList<Segment> segments = new ArrayList<>();
+    for (int i = 0; i < manifest.streamElements.length; i++) {
+      StreamElement streamElement = manifest.streamElements[i];
+      for (int j = 0; j < streamElement.formats.length; j++) {
+        segments.addAll(getSegments(dataSource, manifest, new TrackKey[] {new TrackKey(i, j)},
+            allowIndexLoadErrors));
+      }
+    }
+    return segments;
+  }
+
+  @Override
+  protected List<Segment> getSegments(DataSource dataSource, SsManifest manifest,
+      TrackKey[] keys, boolean allowIndexLoadErrors) throws InterruptedException, IOException {
+    ArrayList<Segment> segments = new ArrayList<>();
+    for (TrackKey key : keys) {
+      StreamElement streamElement = manifest.streamElements[key.streamElementIndex];
+      for (int i = 0; i < streamElement.chunkCount; i++) {
+        segments.add(new Segment(streamElement.getStartTimeUs(i),
+            new DataSpec(streamElement.buildRequestUri(key.trackIndex, i))));
+      }
+    }
+    return segments;
+  }
+
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
index cb5e3465f8..fda74db28d 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
@@ -17,22 +17,17 @@
 
 import android.annotation.SuppressLint;
 import android.widget.TextView;
-import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import java.util.Locale;
 
 /**
  * A helper class for periodically updating a {@link TextView} with debug information obtained from
  * a {@link SimpleExoPlayer}.
  */
-public final class DebugTextViewHelper implements Runnable, Player.EventListener {
+public final class DebugTextViewHelper extends Player.DefaultEventListener implements Runnable {
 
   private static final int REFRESH_INTERVAL_MS = 1000;
 
@@ -78,46 +73,16 @@ public void stop() {
 
   // Player.EventListener implementation.
 
-  @Override
-  public void onLoadingChanged(boolean isLoading) {
-    // Do nothing.
-  }
-
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
     updateAndPost();
   }
 
   @Override
-  public void onRepeatModeChanged(int repeatMode) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPositionDiscontinuity() {
+  public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
     updateAndPost();
   }
 
-  @Override
-  public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPlayerError(ExoPlaybackException error) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
-    // Do nothing.
-  }
-
   // Runnable implementation.
 
   @Override
@@ -186,10 +151,12 @@ private static String getDecoderCountersBufferCountString(DecoderCounters counte
       return "";
     }
     counters.ensureUpdated();
-    return " rb:" + counters.renderedOutputBufferCount
+    return " sib:" + counters.skippedInputBufferCount
         + " sb:" + counters.skippedOutputBufferCount
-        + " db:" + counters.droppedOutputBufferCount
-        + " mcdb:" + counters.maxConsecutiveDroppedOutputBufferCount;
+        + " rb:" + counters.renderedOutputBufferCount
+        + " db:" + counters.droppedBufferCount
+        + " mcdb:" + counters.maxConsecutiveDroppedBufferCount
+        + " dk:" + counters.droppedToKeyframeCount;
   }
 
   private static String getPixelAspectRatioString(float pixelAspectRatio) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index 523c7fd73d..048bb3ffff 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -23,6 +23,7 @@
 import android.graphics.Paint;
 import android.graphics.Point;
 import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.annotation.Nullable;
 import android.util.AttributeSet;
@@ -39,16 +40,132 @@
 import com.google.android.exoplayer2.util.Util;
 import java.util.Formatter;
 import java.util.Locale;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
  * A time bar that shows a current position, buffered position, duration and ad markers.
+ * <p>
+ * A DefaultTimeBar can be customized by setting attributes, as outlined below.
+ *
+ * <h3>Attributes</h3>
+ * The following attributes can be set on a DefaultTimeBar when used in a layout XML file:
+ * <p>
+ * <ul>
+ *   <li><b>{@code bar_height}</b> - Dimension for the height of the time bar.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_BAR_HEIGHT_DP}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code touch_target_height}</b> - Dimension for the height of the area in which touch
+ *       interactions with the time bar are handled. If no height is specified, this also determines
+ *       the height of the view.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_TOUCH_TARGET_HEIGHT_DP}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code ad_marker_width}</b> - Dimension for the width of any ad markers shown on the
+ *       bar. Ad markers are superimposed on the time bar to show the times at which ads will play.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_AD_MARKER_WIDTH_DP}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code scrubber_enabled_size}</b> - Dimension for the diameter of the circular scrubber
+ *       handle when scrubbing is enabled but not in progress. Set to zero if no scrubber handle
+ *       should be shown.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_SCRUBBER_ENABLED_SIZE_DP}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code scrubber_disabled_size}</b> - Dimension for the diameter of the circular scrubber
+ *       handle when scrubbing isn't enabled. Set to zero if no scrubber handle should be shown.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_SCRUBBER_DISABLED_SIZE_DP}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code scrubber_dragged_size}</b> - Dimension for the diameter of the circular scrubber
+ *       handle when scrubbing is in progress. Set to zero if no scrubber handle should be shown.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_SCRUBBER_DRAGGED_SIZE_DP}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code scrubber_drawable}</b> - Optional reference to a drawable to draw for the
+ *       scrubber handle. If set, this overrides the default behavior, which is to draw a circle for
+ *       the scrubber handle.
+ *   </li>
+ *   <li><b>{@code played_color}</b> - Color for the portion of the time bar representing media
+ *       before the current playback position.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_PLAYED_COLOR}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code scrubber_color}</b> - Color for the scrubber handle.
+ *       <ul>
+ *         <li>Default: see {@link #getDefaultScrubberColor(int)}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code buffered_color}</b> - Color for the portion of the time bar after the current
+ *       played position up to the current buffered position.
+ *       <ul>
+ *         <li>Default: see {@link #getDefaultBufferedColor(int)}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code unplayed_color}</b> - Color for the portion of the time bar after the current
+ *       buffered position.
+ *       <ul>
+ *         <li>Default: see {@link #getDefaultUnplayedColor(int)}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code ad_marker_color}</b> - Color for unplayed ad markers.
+ *       <ul>
+ *         <li>Default: {@link #DEFAULT_AD_MARKER_COLOR}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code played_ad_marker_color}</b> - Color for played ad markers.
+ *       <ul>
+ *         <li>Default: see {@link #getDefaultPlayedAdMarkerColor(int)}</li>
+ *       </ul>
+ *   </li>
+ * </ul>
  */
 public class DefaultTimeBar extends View implements TimeBar {
 
+  /**
+   * Default height for the time bar, in dp.
+   */
+  public static final int DEFAULT_BAR_HEIGHT_DP = 4;
+  /**
+   * Default height for the touch target, in dp.
+   */
+  public static final int DEFAULT_TOUCH_TARGET_HEIGHT_DP = 26;
+  /**
+   * Default width for ad markers, in dp.
+   */
+  public static final int DEFAULT_AD_MARKER_WIDTH_DP = 4;
+  /**
+   * Default diameter for the scrubber when enabled, in dp.
+   */
+  public static final int DEFAULT_SCRUBBER_ENABLED_SIZE_DP = 12;
+  /**
+   * Default diameter for the scrubber when disabled, in dp.
+   */
+  public static final int DEFAULT_SCRUBBER_DISABLED_SIZE_DP = 0;
+  /**
+   * Default diameter for the scrubber when dragged, in dp.
+   */
+  public static final int DEFAULT_SCRUBBER_DRAGGED_SIZE_DP = 16;
+  /**
+   * Default color for the played portion of the time bar.
+   */
+  public static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
+  /**
+   * Default color for ad markers.
+   */
+  public static final int DEFAULT_AD_MARKER_COLOR = 0xB2FFFF00;
+
   /**
    * The threshold in dps above the bar at which touch events trigger fine scrub mode.
    */
-  private static final int FINE_SCRUB_Y_THRESHOLD = -50;
+  private static final int FINE_SCRUB_Y_THRESHOLD_DP = -50;
   /**
    * The ratio by which times are reduced in fine scrub mode.
    */
@@ -59,14 +176,6 @@
    */
   private static final long STOP_SCRUBBING_TIMEOUT_MS = 1000;
   private static final int DEFAULT_INCREMENT_COUNT = 20;
-  private static final int DEFAULT_BAR_HEIGHT = 4;
-  private static final int DEFAULT_TOUCH_TARGET_HEIGHT = 26;
-  private static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
-  private static final int DEFAULT_AD_MARKER_COLOR = 0xB2FFFF00;
-  private static final int DEFAULT_AD_MARKER_WIDTH = 4;
-  private static final int DEFAULT_SCRUBBER_ENABLED_SIZE = 12;
-  private static final int DEFAULT_SCRUBBER_DISABLED_SIZE = 0;
-  private static final int DEFAULT_SCRUBBER_DRAGGED_SIZE = 16;
 
   private final Rect seekBounds;
   private final Rect progressBar;
@@ -78,6 +187,7 @@
   private final Paint adMarkerPaint;
   private final Paint playedAdMarkerPaint;
   private final Paint scrubberPaint;
+  private final Drawable scrubberDrawable;
   private final int barHeight;
   private final int touchTargetHeight;
   private final int adMarkerWidth;
@@ -89,8 +199,8 @@
   private final StringBuilder formatBuilder;
   private final Formatter formatter;
   private final Runnable stopScrubbingRunnable;
+  private final CopyOnWriteArraySet<OnScrubListener> listeners;
 
-  private OnScrubListener listener;
   private int keyCountIncrement;
   private long keyTimeIncrement;
   private int lastCoarseScrubXPosition;
@@ -122,21 +232,28 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     playedAdMarkerPaint = new Paint();
     scrubberPaint = new Paint();
     scrubberPaint.setAntiAlias(true);
+    listeners = new CopyOnWriteArraySet<>();
 
     // Calculate the dimensions and paints for drawn elements.
     Resources res = context.getResources();
     DisplayMetrics displayMetrics = res.getDisplayMetrics();
-    fineScrubYThreshold = dpToPx(displayMetrics, FINE_SCRUB_Y_THRESHOLD);
-    int defaultBarHeight = dpToPx(displayMetrics, DEFAULT_BAR_HEIGHT);
-    int defaultTouchTargetHeight = dpToPx(displayMetrics, DEFAULT_TOUCH_TARGET_HEIGHT);
-    int defaultAdMarkerWidth = dpToPx(displayMetrics, DEFAULT_AD_MARKER_WIDTH);
-    int defaultScrubberEnabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_ENABLED_SIZE);
-    int defaultScrubberDisabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DISABLED_SIZE);
-    int defaultScrubberDraggedSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DRAGGED_SIZE);
+    fineScrubYThreshold = dpToPx(displayMetrics, FINE_SCRUB_Y_THRESHOLD_DP);
+    int defaultBarHeight = dpToPx(displayMetrics, DEFAULT_BAR_HEIGHT_DP);
+    int defaultTouchTargetHeight = dpToPx(displayMetrics, DEFAULT_TOUCH_TARGET_HEIGHT_DP);
+    int defaultAdMarkerWidth = dpToPx(displayMetrics, DEFAULT_AD_MARKER_WIDTH_DP);
+    int defaultScrubberEnabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
+    int defaultScrubberDisabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
+    int defaultScrubberDraggedSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
     if (attrs != null) {
       TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
           0);
       try {
+        scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
+        if (scrubberDrawable != null) {
+          setDrawableLayoutDirection(scrubberDrawable, getLayoutDirection());
+          defaultTouchTargetHeight =
+              Math.max(scrubberDrawable.getMinimumHeight(), defaultTouchTargetHeight);
+        }
         barHeight = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height,
             defaultBarHeight);
         touchTargetHeight = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_touch_target_height,
@@ -181,6 +298,7 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
       bufferedPaint.setColor(getDefaultBufferedColor(DEFAULT_PLAYED_COLOR));
       unplayedPaint.setColor(getDefaultUnplayedColor(DEFAULT_PLAYED_COLOR));
       adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
+      scrubberDrawable = null;
     }
     formatBuilder = new StringBuilder();
     formatter = new Formatter(formatBuilder, Locale.getDefault());
@@ -190,9 +308,13 @@ public void run() {
         stopScrubbing(false);
       }
     };
-    scrubberPadding =
-        (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1)
-            / 2;
+    if (scrubberDrawable != null) {
+      scrubberPadding = (scrubberDrawable.getMinimumWidth() + 1) / 2;
+    } else {
+      scrubberPadding =
+          (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1)
+              / 2;
+    }
     duration = C.TIME_UNSET;
     keyTimeIncrement = C.TIME_UNSET;
     keyCountIncrement = DEFAULT_INCREMENT_COUNT;
@@ -203,8 +325,13 @@ public void run() {
   }
 
   @Override
-  public void setListener(OnScrubListener listener) {
-    this.listener = listener;
+  public void addListener(OnScrubListener listener) {
+    listeners.add(listener);
+  }
+
+  @Override
+  public void removeListener(OnScrubListener listener) {
+    listeners.remove(listener);
   }
 
   @Override
@@ -299,7 +426,7 @@ public boolean onTouchEvent(MotionEvent event) {
             positionScrubber(x);
           }
           scrubPosition = getScrubberPosition();
-          if (listener != null) {
+          for (OnScrubListener listener : listeners) {
             listener.onScrubMove(this, scrubPosition);
           }
           update();
@@ -350,6 +477,20 @@ public boolean onKeyDown(int keyCode, KeyEvent event) {
     return super.onKeyDown(keyCode, event);
   }
 
+  @Override
+  protected void drawableStateChanged() {
+    super.drawableStateChanged();
+    updateDrawableState();
+  }
+
+  @Override
+  public void jumpDrawablesToCurrentState() {
+    super.jumpDrawablesToCurrentState();
+    if (scrubberDrawable != null) {
+      scrubberDrawable.jumpToCurrentState();
+    }
+  }
+
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     int heightMode = MeasureSpec.getMode(heightMeasureSpec);
@@ -357,6 +498,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     int height = heightMode == MeasureSpec.UNSPECIFIED ? touchTargetHeight
         : heightMode == MeasureSpec.EXACTLY ? heightSize : Math.min(touchTargetHeight, heightSize);
     setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);
+    updateDrawableState();
   }
 
   @Override
@@ -374,11 +516,12 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
   }
 
   @Override
-  protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
-    super.onSizeChanged(width, height, oldWidth, oldHeight);
+  public void onRtlPropertiesChanged(int layoutDirection) {
+    if (scrubberDrawable != null && setDrawableLayoutDirection(scrubberDrawable, layoutDirection)) {
+      invalidate();
+    }
   }
 
-  @TargetApi(14)
   @Override
   public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
     super.onInitializeAccessibilityEvent(event);
@@ -441,23 +584,25 @@ private void maybeSetImportantForAccessibilityV16() {
 
   private void startScrubbing() {
     scrubbing = true;
+    setPressed(true);
     ViewParent parent = getParent();
     if (parent != null) {
       parent.requestDisallowInterceptTouchEvent(true);
     }
-    if (listener != null) {
+    for (OnScrubListener listener : listeners) {
       listener.onScrubStart(this, getScrubberPosition());
     }
   }
 
   private void stopScrubbing(boolean canceled) {
     scrubbing = false;
+    setPressed(false);
     ViewParent parent = getParent();
     if (parent != null) {
       parent.requestDisallowInterceptTouchEvent(false);
     }
     invalidate();
-    if (listener != null) {
+    for (OnScrubListener listener : listeners) {
       listener.onScrubStop(this, getScrubberPosition(), canceled);
     }
   }
@@ -542,12 +687,30 @@ private void drawPlayhead(Canvas canvas) {
     if (duration <= 0) {
       return;
     }
-    int scrubberSize = (scrubbing || isFocused()) ? scrubberDraggedSize
-        : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);
-    int playheadRadius = scrubberSize / 2;
-    int playheadCenter = Util.constrainValue(scrubberBar.right, scrubberBar.left,
-        progressBar.right);
-    canvas.drawCircle(playheadCenter, scrubberBar.centerY(), playheadRadius, scrubberPaint);
+    int playheadX = Util.constrainValue(scrubberBar.right, scrubberBar.left, progressBar.right);
+    int playheadY = scrubberBar.centerY();
+    if (scrubberDrawable == null) {
+      int scrubberSize = (scrubbing || isFocused()) ? scrubberDraggedSize
+          : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);
+      int playheadRadius = scrubberSize / 2;
+      canvas.drawCircle(playheadX, playheadY, playheadRadius, scrubberPaint);
+    } else {
+      int scrubberDrawableWidth = scrubberDrawable.getIntrinsicWidth();
+      int scrubberDrawableHeight = scrubberDrawable.getIntrinsicHeight();
+      scrubberDrawable.setBounds(
+          playheadX - scrubberDrawableWidth / 2,
+          playheadY - scrubberDrawableHeight / 2,
+          playheadX + scrubberDrawableWidth / 2,
+          playheadY + scrubberDrawableHeight / 2);
+      scrubberDrawable.draw(canvas);
+    }
+  }
+
+  private void updateDrawableState() {
+    if (scrubberDrawable != null && scrubberDrawable.isStateful()
+        && scrubberDrawable.setState(getDrawableState())) {
+      invalidate();
+    }
   }
 
   private String getProgressText() {
@@ -577,7 +740,7 @@ private boolean scrubIncrementally(long positionChange) {
     if (!scrubbing) {
       startScrubbing();
     }
-    if (listener != null) {
+    for (OnScrubListener listener : listeners) {
       listener.onScrubMove(this, scrubPosition);
     }
     update();
@@ -588,19 +751,23 @@ private static int dpToPx(DisplayMetrics displayMetrics, int dps) {
     return (int) (dps * displayMetrics.density + 0.5f);
   }
 
-  private static int getDefaultScrubberColor(int playedColor) {
+  private static boolean setDrawableLayoutDirection(Drawable drawable, int layoutDirection) {
+    return Util.SDK_INT >= 23 && drawable.setLayoutDirection(layoutDirection);
+  }
+
+  public static int getDefaultScrubberColor(int playedColor) {
     return 0xFF000000 | playedColor;
   }
 
-  private static int getDefaultUnplayedColor(int playedColor) {
+  public static int getDefaultUnplayedColor(int playedColor) {
     return 0x33000000 | (playedColor & 0x00FFFFFF);
   }
 
-  private static int getDefaultBufferedColor(int playedColor) {
+  public static int getDefaultBufferedColor(int playedColor) {
     return 0xCC000000 | (playedColor & 0x00FFFFFF);
   }
 
-  private static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
+  public static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
     return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index fb97343c38..a96ed3a622 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.ui;
 
 import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
@@ -31,14 +30,9 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Player.RepeatMode;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -85,6 +79,12 @@
  *         <li>Default: {@link PlaybackControlView#DEFAULT_REPEAT_TOGGLE_MODES}</li>
  *       </ul>
  *   </li>
+ *   <li><b>{@code show_shuffle_button}</b> - Whether the shuffle button is shown.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setShowShuffleButton(boolean)}</li>
+ *         <li>Default: false</li>
+ *       </ul>
+ *   </li>
  *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout to be inflated. See
  *       below for more details.
  *       <ul>
@@ -137,6 +137,11 @@
  *         <li>Type: {@link View}</li>
  *       </ul>
  *   </li>
+ *   <li><b>{@code exo_shuffle}</b> - The shuffle button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
  *   <li><b>{@code exo_position}</b> - Text view displaying the current playback position.
  *       <ul>
  *         <li>Type: {@link TextView}</li>
@@ -170,6 +175,12 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.ui");
   }
 
+  /**
+   * @deprecated Use {@link com.google.android.exoplayer2.ControlDispatcher}.
+   */
+  @Deprecated
+  public interface ControlDispatcher extends com.google.android.exoplayer2.ControlDispatcher {}
+
   /**
    * Listener to be notified about changes of the visibility of the UI control.
    */
@@ -184,71 +195,13 @@
 
   }
 
+  private static final class DefaultControlDispatcher
+      extends com.google.android.exoplayer2.DefaultControlDispatcher implements ControlDispatcher {}
   /**
-   * Dispatches operations to the {@link Player}.
-   * <p>
-   * Implementations may choose to suppress (e.g. prevent playback from resuming if audio focus is
-   * denied) or modify (e.g. change the seek position to prevent a user from seeking past a
-   * non-skippable advert) operations.
+   * @deprecated Use {@link com.google.android.exoplayer2.DefaultControlDispatcher}.
    */
-  public interface ControlDispatcher {
-
-    /**
-     * Dispatches a {@link Player#setPlayWhenReady(boolean)} operation.
-     *
-     * @param player The {@link Player} to which the operation should be dispatched.
-     * @param playWhenReady Whether playback should proceed when ready.
-     * @return True if the operation was dispatched. False if suppressed.
-     */
-    boolean dispatchSetPlayWhenReady(Player player, boolean playWhenReady);
-
-    /**
-     * Dispatches a {@link Player#seekTo(int, long)} operation.
-     *
-     * @param player The {@link Player} to which the operation should be dispatched.
-     * @param windowIndex The index of the window.
-     * @param positionMs The seek position in the specified window, or {@link C#TIME_UNSET} to seek
-     *     to the window's default position.
-     * @return True if the operation was dispatched. False if suppressed.
-     */
-    boolean dispatchSeekTo(Player player, int windowIndex, long positionMs);
-
-    /**
-     * Dispatches a {@link Player#setRepeatMode(int)} operation.
-     *
-     * @param player The {@link Player} to which the operation should be dispatched.
-     * @param repeatMode The repeat mode.
-     * @return True if the operation was dispatched. False if suppressed.
-     */
-    boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode);
-
-  }
-
-  /**
-   * Default {@link ControlDispatcher} that dispatches operations to the player without
-   * modification.
-   */
-  public static final ControlDispatcher DEFAULT_CONTROL_DISPATCHER = new ControlDispatcher() {
-
-    @Override
-    public boolean dispatchSetPlayWhenReady(Player player, boolean playWhenReady) {
-      player.setPlayWhenReady(playWhenReady);
-      return true;
-    }
-
-    @Override
-    public boolean dispatchSeekTo(Player player, int windowIndex, long positionMs) {
-      player.seekTo(windowIndex, positionMs);
-      return true;
-    }
-
-    @Override
-    public boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode) {
-      player.setRepeatMode(repeatMode);
-      return true;
-    }
-
-  };
+  @Deprecated
+  public static final ControlDispatcher DEFAULT_CONTROL_DISPATCHER = new DefaultControlDispatcher();
 
   /**
    * The default fast forward increment, in milliseconds.
@@ -283,6 +236,7 @@ public boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode)
   private final View fastForwardButton;
   private final View rewindButton;
   private final ImageView repeatToggleButton;
+  private final View shuffleButton;
   private final TextView durationView;
   private final TextView positionView;
   private final TimeBar timeBar;
@@ -299,7 +253,7 @@ public boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode)
   private final String repeatAllButtonContentDescription;
 
   private Player player;
-  private ControlDispatcher controlDispatcher;
+  private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
   private VisibilityListener visibilityListener;
 
   private boolean isAttachedToWindow;
@@ -310,6 +264,7 @@ public boolean dispatchSetRepeatMode(Player player, @RepeatMode int repeatMode)
   private int fastForwardMs;
   private int showTimeoutMs;
   private @RepeatModeUtil.RepeatToggleModes int repeatToggleModes;
+  private boolean showShuffleButton;
   private long hideAtMs;
   private long[] adGroupTimesMs;
   private boolean[] playedAdGroups;
@@ -350,6 +305,7 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
     fastForwardMs = DEFAULT_FAST_FORWARD_MS;
     showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
     repeatToggleModes = DEFAULT_REPEAT_TOGGLE_MODES;
+    showShuffleButton = false;
     if (playbackAttrs != null) {
       TypedArray a = context.getTheme().obtainStyledAttributes(playbackAttrs,
           R.styleable.PlaybackControlView, 0, 0);
@@ -361,6 +317,8 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
         controllerLayoutId = a.getResourceId(R.styleable.PlaybackControlView_controller_layout_id,
             controllerLayoutId);
         repeatToggleModes = getRepeatToggleModes(a, repeatToggleModes);
+        showShuffleButton = a.getBoolean(R.styleable.PlaybackControlView_show_shuffle_button,
+            showShuffleButton);
       } finally {
         a.recycle();
       }
@@ -374,16 +332,16 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
     extraAdGroupTimesMs = new long[0];
     extraPlayedAdGroups = new boolean[0];
     componentListener = new ComponentListener();
-    controlDispatcher = DEFAULT_CONTROL_DISPATCHER;
+    controlDispatcher = new com.google.android.exoplayer2.DefaultControlDispatcher();
 
     LayoutInflater.from(context).inflate(controllerLayoutId, this);
     setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
 
-    durationView = (TextView) findViewById(R.id.exo_duration);
-    positionView = (TextView) findViewById(R.id.exo_position);
-    timeBar = (TimeBar) findViewById(R.id.exo_progress);
+    durationView = findViewById(R.id.exo_duration);
+    positionView = findViewById(R.id.exo_position);
+    timeBar = findViewById(R.id.exo_progress);
     if (timeBar != null) {
-      timeBar.setListener(componentListener);
+      timeBar.addListener(componentListener);
     }
     playButton = findViewById(R.id.exo_play);
     if (playButton != null) {
@@ -409,10 +367,14 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
     if (fastForwardButton != null) {
       fastForwardButton.setOnClickListener(componentListener);
     }
-    repeatToggleButton = (ImageView) findViewById(R.id.exo_repeat_toggle);
+    repeatToggleButton = findViewById(R.id.exo_repeat_toggle);
     if (repeatToggleButton != null) {
       repeatToggleButton.setOnClickListener(componentListener);
     }
+    shuffleButton = findViewById(R.id.exo_shuffle);
+    if (shuffleButton != null) {
+      shuffleButton.setOnClickListener(componentListener);
+    }
     Resources resources = context.getResources();
     repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off);
     repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one);
@@ -504,14 +466,15 @@ public void setVisibilityListener(VisibilityListener listener) {
   }
 
   /**
-   * Sets the {@link ControlDispatcher}.
+   * Sets the {@link com.google.android.exoplayer2.ControlDispatcher}.
    *
-   * @param controlDispatcher The {@link ControlDispatcher}, or null to use
-   *     {@link #DEFAULT_CONTROL_DISPATCHER}.
+   * @param controlDispatcher The {@link com.google.android.exoplayer2.ControlDispatcher}, or null
+   *     to use {@link com.google.android.exoplayer2.DefaultControlDispatcher}.
    */
-  public void setControlDispatcher(ControlDispatcher controlDispatcher) {
-    this.controlDispatcher = controlDispatcher == null ? DEFAULT_CONTROL_DISPATCHER
-        : controlDispatcher;
+  public void setControlDispatcher(
+      @Nullable com.google.android.exoplayer2.ControlDispatcher controlDispatcher) {
+    this.controlDispatcher = controlDispatcher == null
+        ? new com.google.android.exoplayer2.DefaultControlDispatcher() : controlDispatcher;
   }
 
   /**
@@ -589,6 +552,23 @@ public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatTog
     }
   }
 
+  /**
+   * Returns whether the shuffle button is shown.
+   */
+  public boolean getShowShuffleButton() {
+    return showShuffleButton;
+  }
+
+  /**
+   * Sets whether the shuffle button is shown.
+   *
+   * @param showShuffleButton Whether the shuffle button is shown.
+   */
+  public void setShowShuffleButton(boolean showShuffleButton) {
+    this.showShuffleButton = showShuffleButton;
+    updateShuffleButton();
+  }
+
   /**
    * Shows the playback controls. If {@link #getShowTimeoutMs()} is positive then the controls will
    * be automatically hidden after this duration of time has elapsed without user input.
@@ -644,6 +624,7 @@ private void updateAll() {
     updatePlayPauseButton();
     updateNavigation();
     updateRepeatModeButton();
+    updateShuffleButton();
     updateProgress();
   }
 
@@ -675,18 +656,13 @@ private void updateNavigation() {
     boolean isSeekable = false;
     boolean enablePrevious = false;
     boolean enableNext = false;
-    if (haveNonEmptyTimeline) {
+    if (haveNonEmptyTimeline && !player.isPlayingAd()) {
       int windowIndex = player.getCurrentWindowIndex();
       timeline.getWindow(windowIndex, window);
       isSeekable = window.isSeekable;
       enablePrevious = isSeekable || !window.isDynamic
-          || timeline.getPreviousWindowIndex(windowIndex, player.getRepeatMode()) != C.INDEX_UNSET;
-      enableNext = window.isDynamic
-          || timeline.getNextWindowIndex(windowIndex, player.getRepeatMode()) != C.INDEX_UNSET;
-      if (player.isPlayingAd()) {
-        // Always hide player controls during ads.
-        hide();
-      }
+          || player.getPreviousWindowIndex() != C.INDEX_UNSET;
+      enableNext = window.isDynamic || player.getNextWindowIndex() != C.INDEX_UNSET;
     }
     setButtonEnabled(enablePrevious, previousButton);
     setButtonEnabled(enableNext, nextButton);
@@ -727,6 +703,21 @@ private void updateRepeatModeButton() {
     repeatToggleButton.setVisibility(View.VISIBLE);
   }
 
+  private void updateShuffleButton() {
+    if (!isVisible() || !isAttachedToWindow || shuffleButton == null) {
+      return;
+    }
+    if (!showShuffleButton) {
+      shuffleButton.setVisibility(View.GONE);
+    } else if (player == null) {
+      setButtonEnabled(false, shuffleButton);
+    } else {
+      shuffleButton.setAlpha(player.getShuffleModeEnabled() ? 1f : 0.3f);
+      shuffleButton.setEnabled(true);
+      shuffleButton.setVisibility(View.VISIBLE);
+    }
+  }
+
   private void updateTimeBarMode() {
     if (player == null) {
       return;
@@ -830,9 +821,19 @@ private void updateProgress() {
     if (playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED) {
       long delayMs;
       if (player.getPlayWhenReady() && playbackState == Player.STATE_READY) {
-        delayMs = 1000 - (position % 1000);
-        if (delayMs < 200) {
-          delayMs += 1000;
+        float playbackSpeed = player.getPlaybackParameters().speed;
+        if (playbackSpeed <= 0.1f) {
+          delayMs = 1000;
+        } else if (playbackSpeed <= 5f) {
+          long mediaTimeUpdatePeriodMs = 1000 / Math.max(1, Math.round(1 / playbackSpeed));
+          long mediaTimeDelayMs = mediaTimeUpdatePeriodMs - (position % mediaTimeUpdatePeriodMs);
+          if (mediaTimeDelayMs < (mediaTimeUpdatePeriodMs / 5)) {
+            mediaTimeDelayMs += mediaTimeUpdatePeriodMs;
+          }
+          delayMs = playbackSpeed == 1 ? mediaTimeDelayMs
+              : (long) (mediaTimeDelayMs / playbackSpeed);
+        } else {
+          delayMs = 200;
         }
       } else {
         delayMs = 1000;
@@ -855,17 +856,8 @@ private void setButtonEnabled(boolean enabled, View view) {
       return;
     }
     view.setEnabled(enabled);
-    if (Util.SDK_INT >= 11) {
-      setViewAlphaV11(view, enabled ? 1f : 0.3f);
-      view.setVisibility(VISIBLE);
-    } else {
-      view.setVisibility(enabled ? VISIBLE : INVISIBLE);
-    }
-  }
-
-  @TargetApi(11)
-  private void setViewAlphaV11(View view, float alpha) {
-    view.setAlpha(alpha);
+    view.setAlpha(enabled ? 1f : 0.3f);
+    view.setVisibility(VISIBLE);
   }
 
   private void previous() {
@@ -875,7 +867,7 @@ private void previous() {
     }
     int windowIndex = player.getCurrentWindowIndex();
     timeline.getWindow(windowIndex, window);
-    int previousWindowIndex = timeline.getPreviousWindowIndex(windowIndex, player.getRepeatMode());
+    int previousWindowIndex = player.getPreviousWindowIndex();
     if (previousWindowIndex != C.INDEX_UNSET
         && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
         || (window.isDynamic && !window.isSeekable))) {
@@ -891,7 +883,7 @@ private void next() {
       return;
     }
     int windowIndex = player.getCurrentWindowIndex();
-    int nextWindowIndex = timeline.getNextWindowIndex(windowIndex, player.getRepeatMode());
+    int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
       seekTo(nextWindowIndex, C.TIME_UNSET);
     } else if (timeline.getWindow(windowIndex, window, false).isDynamic) {
@@ -1056,8 +1048,8 @@ private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Win
     return true;
   }
 
-  private final class ComponentListener implements Player.EventListener, TimeBar.OnScrubListener,
-      OnClickListener {
+  private final class ComponentListener extends Player.DefaultEventListener implements
+      TimeBar.OnScrubListener, OnClickListener {
 
     @Override
     public void onScrubStart(TimeBar timeBar, long position) {
@@ -1094,14 +1086,15 @@ public void onRepeatModeChanged(int repeatMode) {
     }
 
     @Override
-    public void onPositionDiscontinuity() {
+    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
+      updateShuffleButton();
       updateNavigation();
-      updateProgress();
     }
 
     @Override
-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      // Do nothing.
+    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+      updateNavigation();
+      updateProgress();
     }
 
     @Override
@@ -1111,21 +1104,6 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
       updateProgress();
     }
 
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlayerError(ExoPlaybackException error) {
-      // Do nothing.
-    }
-
     @Override
     public void onClick(View view) {
       if (player != null) {
@@ -1144,6 +1122,8 @@ public void onClick(View view) {
         } else if (repeatToggleButton == view) {
           controlDispatcher.dispatchSetRepeatMode(player, RepeatModeUtil.getNextRepeatMode(
               player.getRepeatMode(), repeatToggleModes));
+        } else if (shuffleButton == view) {
+          controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
         }
       }
       hideAfterTimeout();
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index de28eb2f93..b09e80c591 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ui;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.Resources;
@@ -34,20 +35,19 @@
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.ControlDispatcher;
+import com.google.android.exoplayer2.DefaultControlDispatcher;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
-import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode;
-import com.google.android.exoplayer2.ui.PlaybackControlView.ControlDispatcher;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -113,6 +113,13 @@
  *         <li>Default: {@code surface_view}</li>
  *       </ul>
  *   </li>
+ *   <li><b>{@code shutter_background_color}</b> - The background color of the {@code exo_shutter}
+ *       view.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setShutterBackgroundColor(int)}</li>
+ *         <li>Default: {@code unset}</li>
+ *       </ul>
+ *   </li>
  *   <li><b>{@code player_layout_id}</b> - Specifies the id of the layout to be inflated. See below
  *       for more details.
  *       <ul>
@@ -249,6 +256,8 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
       return;
     }
 
+    boolean shutterColorSet = false;
+    int shutterColor = 0;
     int playerLayoutId = R.layout.exo_simple_player_view;
     boolean useArtwork = true;
     int defaultArtworkId = 0;
@@ -262,6 +271,9 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
       TypedArray a = context.getTheme().obtainStyledAttributes(attrs,
           R.styleable.SimpleExoPlayerView, 0, 0);
       try {
+        shutterColorSet = a.hasValue(R.styleable.SimpleExoPlayerView_shutter_background_color);
+        shutterColor = a.getColor(R.styleable.SimpleExoPlayerView_shutter_background_color,
+              shutterColor);
         playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,
             playerLayoutId);
         useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);
@@ -286,13 +298,16 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
     setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
 
     // Content frame.
-    contentFrame = (AspectRatioFrameLayout) findViewById(R.id.exo_content_frame);
+    contentFrame = findViewById(R.id.exo_content_frame);
     if (contentFrame != null) {
       setResizeModeRaw(contentFrame, resizeMode);
     }
 
     // Shutter view.
     shutterView = findViewById(R.id.exo_shutter);
+    if (shutterView != null && shutterColorSet) {
+      shutterView.setBackgroundColor(shutterColor);
+    }
 
     // Create a surface view and insert it into the content frame, if there is one.
     if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
@@ -307,24 +322,24 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
     }
 
     // Overlay frame layout.
-    overlayFrameLayout = (FrameLayout) findViewById(R.id.exo_overlay);
+    overlayFrameLayout = findViewById(R.id.exo_overlay);
 
     // Artwork view.
-    artworkView = (ImageView) findViewById(R.id.exo_artwork);
+    artworkView = findViewById(R.id.exo_artwork);
     this.useArtwork = useArtwork && artworkView != null;
     if (defaultArtworkId != 0) {
       defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
     }
 
     // Subtitle view.
-    subtitleView = (SubtitleView) findViewById(R.id.exo_subtitles);
+    subtitleView = findViewById(R.id.exo_subtitles);
     if (subtitleView != null) {
       subtitleView.setUserDefaultStyle();
       subtitleView.setUserDefaultTextSize();
     }
 
     // Playback control view.
-    PlaybackControlView customController = (PlaybackControlView) findViewById(R.id.exo_controller);
+    PlaybackControlView customController = findViewById(R.id.exo_controller);
     View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);
     if (customController != null) {
       this.controller = customController;
@@ -431,7 +446,7 @@ public void setPlayer(SimpleExoPlayer player) {
   public void setVisibility(int visibility) {
     super.setVisibility(visibility);
     if (surfaceView instanceof SurfaceView) {
-      // Work around https://github.com/google/ExoPlayer/issues/3160
+      // Work around https://github.com/google/ExoPlayer/issues/3160.
       surfaceView.setVisibility(visibility);
     }
   }
@@ -513,6 +528,17 @@ public void setUseController(boolean useController) {
     }
   }
 
+  /**
+   * Sets the background color of the {@code exo_shutter} view.
+   *
+   * @param color The background color.
+   */
+  public void setShutterBackgroundColor(int color) {
+    if (shutterView != null) {
+      shutterView.setBackgroundColor(color);
+    }
+  }
+
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
     if (player != null && player.isPlayingAd()) {
@@ -522,8 +548,10 @@ public boolean dispatchKeyEvent(KeyEvent event) {
       overlayFrameLayout.requestFocus();
       return super.dispatchKeyEvent(event);
     }
+    boolean isDpadWhenControlHidden = isDpadKey(event.getKeyCode()) && useController
+        && !controller.isVisible();
     maybeShowController(true);
-    return dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+    return isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
   }
 
   /**
@@ -632,9 +660,9 @@ public void setControllerVisibilityListener(PlaybackControlView.VisibilityListen
    * Sets the {@link ControlDispatcher}.
    *
    * @param controlDispatcher The {@link ControlDispatcher}, or null to use
-   *     {@link PlaybackControlView#DEFAULT_CONTROL_DISPATCHER}.
+   *     {@link DefaultControlDispatcher}.
    */
-  public void setControlDispatcher(ControlDispatcher controlDispatcher) {
+  public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
     Assertions.checkState(controller != null);
     controller.setControlDispatcher(controlDispatcher);
   }
@@ -671,6 +699,16 @@ public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatTog
     controller.setRepeatToggleModes(repeatToggleModes);
   }
 
+  /**
+   * Sets whether the shuffle button is shown.
+   *
+   * @param showShuffleButton Whether the shuffle button is shown.
+   */
+  public void setShowShuffleButton(boolean showShuffleButton) {
+    Assertions.checkState(controller != null);
+    controller.setShowShuffleButton(showShuffleButton);
+  }
+
   /**
    * Sets whether the time bar should show all windows, as opposed to just the current one.
    *
@@ -743,6 +781,10 @@ public boolean onTrackballEvent(MotionEvent ev) {
    * Shows the playback controls, but only if forced or shown indefinitely.
    */
   private void maybeShowController(boolean isForced) {
+    if (isPlayingAd()) {
+      // Never show the controller if an ad is currently playing.
+      return;
+    }
     if (useController) {
       boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;
       boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();
@@ -769,6 +811,10 @@ private void showController(boolean showIndefinitely) {
     controller.show();
   }
 
+  private boolean isPlayingAd() {
+    return player != null && player.isPlayingAd() && player.getPlayWhenReady();
+  }
+
   private void updateForCurrentTrackSelections() {
     if (player == null) {
       return;
@@ -854,16 +900,24 @@ private static void configureEditModeLogo(Resources resources, ImageView logo) {
     logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color));
   }
 
-
   @SuppressWarnings("ResourceType")
   private static void setResizeModeRaw(AspectRatioFrameLayout aspectRatioFrame, int resizeMode) {
     aspectRatioFrame.setResizeMode(resizeMode);
   }
 
-  private final class ComponentListener implements SimpleExoPlayer.VideoListener,
-      TextRenderer.Output, Player.EventListener {
+  @SuppressLint("InlinedApi")
+  private boolean isDpadKey(int keyCode) {
+    return keyCode == KeyEvent.KEYCODE_DPAD_UP || keyCode == KeyEvent.KEYCODE_DPAD_UP_RIGHT
+        || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_RIGHT
+        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_LEFT
+        || keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_UP_LEFT
+        || keyCode == KeyEvent.KEYCODE_DPAD_CENTER;
+  }
+
+  private final class ComponentListener extends Player.DefaultEventListener implements TextOutput,
+      SimpleExoPlayer.VideoListener {
 
-    // TextRenderer.Output implementation
+    // TextOutput implementation
 
     @Override
     public void onCues(List<Cue> cues) {
@@ -872,7 +926,7 @@ public void onCues(List<Cue> cues) {
       }
     }
 
-    // SimpleExoPlayer.VideoListener implementation
+    // SimpleExoPlayer.VideoInfoListener implementation
 
     @Override
     public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
@@ -897,39 +951,20 @@ public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selectio
 
     // Player.EventListener implementation
 
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-      // Do nothing.
-    }
-
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      maybeShowController(false);
-    }
-
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlayerError(ExoPlaybackException e) {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPositionDiscontinuity() {
-      // Do nothing.
-    }
-
-    @Override
-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-      // Do nothing.
+      if (isPlayingAd()) {
+        hideController();
+      } else {
+        maybeShowController(false);
+      }
     }
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
-      // Do nothing.
+    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+      if (isPlayingAd()) {
+        hideController();
+      }
     }
 
   }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 3bcfcc3ef3..618f2fa336 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -25,7 +25,7 @@
 import android.view.accessibility.CaptioningManager;
 import com.google.android.exoplayer2.text.CaptionStyleCompat;
 import com.google.android.exoplayer2.text.Cue;
-import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.List;
@@ -33,7 +33,7 @@
 /**
  * A view for displaying subtitle {@link Cue}s.
  */
-public final class SubtitleView extends View implements TextRenderer.Output {
+public final class SubtitleView extends View implements TextOutput {
 
   /**
    * The default fractional text size.
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java
index 4b448738d3..866921c2f9 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java
@@ -25,16 +25,23 @@
 public interface TimeBar {
 
   /**
-   * @see View#isEnabled()
+   * Adds a listener for scrubbing events.
+   *
+   * @param listener The listener to add.
    */
-  void setEnabled(boolean enabled);
+  void addListener(OnScrubListener listener);
 
   /**
-   * Sets the listener for the scrubbing events.
+   * Removes a listener for scrubbing events.
    *
-   * @param listener The listener for scrubbing events.
+   * @param listener The listener to remove.
+   */
+  void removeListener(OnScrubListener listener);
+
+  /**
+   * @see View#isEnabled()
    */
-  void setListener(OnScrubListener listener);
+  void setEnabled(boolean enabled);
 
   /**
    * Sets the position increment for key presses and accessibility actions, in milliseconds.
diff --git a/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle.xml b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle.xml
new file mode 100644
index 0000000000..123c06c43e
--- /dev/null
+++ b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_shuffle.xml
@@ -0,0 +1,26 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportWidth="24.0"
+    android:viewportHeight="24.0">
+
+    <path
+        android:fillColor="#FFFFFFFF"
+        android:pathData="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20
+17.96 7.46 20 9.5V4h-5.5zm0.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04
+2.04-3.13-3.13z" />
+</vector>
diff --git a/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle.png
new file mode 100644
index 0000000000..52a805aac1
Binary files /dev/null and b/library/ui/src/main/res/drawable-hdpi/exo_controls_shuffle.png differ
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle.png
new file mode 100644
index 0000000000..80ec43a119
Binary files /dev/null and b/library/ui/src/main/res/drawable-ldpi/exo_controls_shuffle.png differ
diff --git a/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle.png
new file mode 100644
index 0000000000..0924b2cb69
Binary files /dev/null and b/library/ui/src/main/res/drawable-mdpi/exo_controls_shuffle.png differ
diff --git a/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle.png
new file mode 100644
index 0000000000..ede80c9341
Binary files /dev/null and b/library/ui/src/main/res/drawable-xhdpi/exo_controls_shuffle.png differ
diff --git a/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle.png b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle.png
new file mode 100644
index 0000000000..4c5e141a3f
Binary files /dev/null and b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_shuffle.png differ
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index 407329890d..159844c234 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -34,6 +34,9 @@
     <ImageButton android:id="@id/exo_rew"
       style="@style/ExoMediaButton.Rewind"/>
 
+    <ImageButton android:id="@id/exo_shuffle"
+      style="@style/ExoMediaButton.Shuffle"/>
+
     <ImageButton android:id="@id/exo_repeat_toggle"
       style="@style/ExoMediaButton"/>
 
diff --git a/library/ui/src/main/res/layout/exo_simple_player_view.xml b/library/ui/src/main/res/layout/exo_simple_player_view.xml
index 1f59b7796d..340113da6c 100644
--- a/library/ui/src/main/res/layout/exo_simple_player_view.xml
+++ b/library/ui/src/main/res/layout/exo_simple_player_view.xml
@@ -38,11 +38,11 @@
 
   </com.google.android.exoplayer2.ui.AspectRatioFrameLayout>
 
-  <View android:id="@id/exo_controller_placeholder"
+  <FrameLayout android:id="@id/exo_overlay"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
 
-  <FrameLayout android:id="@id/exo_overlay"
+  <View android:id="@id/exo_controller_placeholder"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
 
diff --git a/library/ui/src/main/res/values-af/strings.xml b/library/ui/src/main/res/values-af/strings.xml
index 103877f1e6..2510552c0c 100644
--- a/library/ui/src/main/res/values-af/strings.xml
+++ b/library/ui/src/main/res/values-af/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Herhaal alles"</string>
   <string name="exo_controls_repeat_off_description">"Herhaal niks"</string>
   <string name="exo_controls_repeat_one_description">"Herhaal een"</string>
+  <string name="exo_controls_shuffle_description">"Skommel"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-am/strings.xml b/library/ui/src/main/res/values-am/strings.xml
index 356566cb87..165b5eee62 100644
--- a/library/ui/src/main/res/values-am/strings.xml
+++ b/library/ui/src/main/res/values-am/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"ሁሉንም ድገም"</string>
   <string name="exo_controls_repeat_off_description">"ምንም አትድገም"</string>
   <string name="exo_controls_repeat_one_description">"አንዱን ድገም"</string>
+  <string name="exo_controls_shuffle_description">"በው"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ar/strings.xml b/library/ui/src/main/res/values-ar/strings.xml
index 4bdbda061c..239f01be6b 100644
--- a/library/ui/src/main/res/values-ar/strings.xml
+++ b/library/ui/src/main/res/values-ar/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"تكرار الكل"</string>
   <string name="exo_controls_repeat_off_description">"عدم التكرار"</string>
   <string name="exo_controls_repeat_one_description">"تكرار مقطع واحد"</string>
+  <string name="exo_controls_shuffle_description">"ترتيب عشوائي"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-az-rAZ/strings.xml b/library/ui/src/main/res/values-az-rAZ/strings.xml
index 771335952f..1071cd5542 100644
--- a/library/ui/src/main/res/values-az-rAZ/strings.xml
+++ b/library/ui/src/main/res/values-az-rAZ/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Bütün təkrarlayın"</string>
   <string name="exo_controls_repeat_one_description">"Təkrar bir"</string>
   <string name="exo_controls_repeat_off_description">"Heç bir təkrar"</string>
+  <string name="exo_controls_shuffle_description">"Qarışdır"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-b+sr+Latn/strings.xml b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
index 7c373b5b55..a9d35e5cb6 100644
--- a/library/ui/src/main/res/values-b+sr+Latn/strings.xml
+++ b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ponovi sve"</string>
   <string name="exo_controls_repeat_off_description">"Ne ponavljaj nijednu"</string>
   <string name="exo_controls_repeat_one_description">"Ponovi jednu"</string>
+  <string name="exo_controls_shuffle_description">"Pusti nasumično"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-be-rBY/strings.xml b/library/ui/src/main/res/values-be-rBY/strings.xml
index 7790a7887f..69b24ad5e9 100644
--- a/library/ui/src/main/res/values-be-rBY/strings.xml
+++ b/library/ui/src/main/res/values-be-rBY/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Паўтарыць усё"</string>
   <string name="exo_controls_repeat_off_description">"Паўтараць ні"</string>
   <string name="exo_controls_repeat_one_description">"Паўтарыць адзін"</string>
+  <string name="exo_controls_shuffle_description">"Перамяшаць"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bg/strings.xml b/library/ui/src/main/res/values-bg/strings.xml
index ce9e3d6943..e350479788 100644
--- a/library/ui/src/main/res/values-bg/strings.xml
+++ b/library/ui/src/main/res/values-bg/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Повтаряне на всички"</string>
   <string name="exo_controls_repeat_off_description">"Без повтаряне"</string>
   <string name="exo_controls_repeat_one_description">"Повтаряне на един елемент"</string>
+  <string name="exo_controls_shuffle_description">"Разбъркване"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bn-rBD/strings.xml b/library/ui/src/main/res/values-bn-rBD/strings.xml
index 5f8ebfa98e..446ef982a3 100644
--- a/library/ui/src/main/res/values-bn-rBD/strings.xml
+++ b/library/ui/src/main/res/values-bn-rBD/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"সবগুলির পুনরাবৃত্তি করুন"</string>
   <string name="exo_controls_repeat_off_description">"একটিরও পুনরাবৃত্তি করবেন না"</string>
   <string name="exo_controls_repeat_one_description">"একটির পুনরাবৃত্তি করুন"</string>
+  <string name="exo_controls_shuffle_description">"অদলবদল"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bs-rBA/strings.xml b/library/ui/src/main/res/values-bs-rBA/strings.xml
index ef47099760..186b1058d9 100644
--- a/library/ui/src/main/res/values-bs-rBA/strings.xml
+++ b/library/ui/src/main/res/values-bs-rBA/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ponovite sve"</string>
   <string name="exo_controls_repeat_off_description">"Ne ponavljaju"</string>
   <string name="exo_controls_repeat_one_description">"Ponovite jedan"</string>
+  <string name="exo_controls_shuffle_description">"Izmiješaj"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ca/strings.xml b/library/ui/src/main/res/values-ca/strings.xml
index a42fe3b9cb..fd76a8e08e 100644
--- a/library/ui/src/main/res/values-ca/strings.xml
+++ b/library/ui/src/main/res/values-ca/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repeteix-ho tot"</string>
   <string name="exo_controls_repeat_off_description">"No en repeteixis cap"</string>
   <string name="exo_controls_repeat_one_description">"Repeteix-ne un"</string>
+  <string name="exo_controls_shuffle_description">"Reprodueix aleatòriament"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-cs/strings.xml b/library/ui/src/main/res/values-cs/strings.xml
index 9c1e50ce27..087ab79c25 100644
--- a/library/ui/src/main/res/values-cs/strings.xml
+++ b/library/ui/src/main/res/values-cs/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Opakovat vše"</string>
   <string name="exo_controls_repeat_off_description">"Neopakovat"</string>
   <string name="exo_controls_repeat_one_description">"Opakovat jednu položku"</string>
+  <string name="exo_controls_shuffle_description">"Náhodně"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-da/strings.xml b/library/ui/src/main/res/values-da/strings.xml
index 3ec132ebb7..0ae23ee288 100644
--- a/library/ui/src/main/res/values-da/strings.xml
+++ b/library/ui/src/main/res/values-da/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Gentag alle"</string>
   <string name="exo_controls_repeat_off_description">"Gentag ingen"</string>
   <string name="exo_controls_repeat_one_description">"Gentag en"</string>
+  <string name="exo_controls_shuffle_description">"Bland"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-de/strings.xml b/library/ui/src/main/res/values-de/strings.xml
index a1dc749864..37ca6c44ac 100644
--- a/library/ui/src/main/res/values-de/strings.xml
+++ b/library/ui/src/main/res/values-de/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Alle wiederholen"</string>
   <string name="exo_controls_repeat_off_description">"Keinen Titel wiederholen"</string>
   <string name="exo_controls_repeat_one_description">"Einen Titel wiederholen"</string>
+  <string name="exo_controls_shuffle_description">"Zufallsmix"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-el/strings.xml b/library/ui/src/main/res/values-el/strings.xml
index 845011fe55..534192e185 100644
--- a/library/ui/src/main/res/values-el/strings.xml
+++ b/library/ui/src/main/res/values-el/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Επανάληψη όλων"</string>
   <string name="exo_controls_repeat_off_description">"Καμία επανάληψη"</string>
   <string name="exo_controls_repeat_one_description">"Επανάληψη ενός στοιχείου"</string>
+  <string name="exo_controls_shuffle_description">"Τυχαία αναπαραγωγή"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rAU/strings.xml b/library/ui/src/main/res/values-en-rAU/strings.xml
index 8a1742c8ca..0b4c465853 100644
--- a/library/ui/src/main/res/values-en-rAU/strings.xml
+++ b/library/ui/src/main/res/values-en-rAU/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repeat all"</string>
   <string name="exo_controls_repeat_off_description">"Repeat none"</string>
   <string name="exo_controls_repeat_one_description">"Repeat one"</string>
+  <string name="exo_controls_shuffle_description">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rGB/strings.xml b/library/ui/src/main/res/values-en-rGB/strings.xml
index 8a1742c8ca..0b4c465853 100644
--- a/library/ui/src/main/res/values-en-rGB/strings.xml
+++ b/library/ui/src/main/res/values-en-rGB/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repeat all"</string>
   <string name="exo_controls_repeat_off_description">"Repeat none"</string>
   <string name="exo_controls_repeat_one_description">"Repeat one"</string>
+  <string name="exo_controls_shuffle_description">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rIN/strings.xml b/library/ui/src/main/res/values-en-rIN/strings.xml
index 8a1742c8ca..0b4c465853 100644
--- a/library/ui/src/main/res/values-en-rIN/strings.xml
+++ b/library/ui/src/main/res/values-en-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repeat all"</string>
   <string name="exo_controls_repeat_off_description">"Repeat none"</string>
   <string name="exo_controls_repeat_one_description">"Repeat one"</string>
+  <string name="exo_controls_shuffle_description">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-es-rUS/strings.xml b/library/ui/src/main/res/values-es-rUS/strings.xml
index f2ec848fb6..e6cf3fc6f2 100644
--- a/library/ui/src/main/res/values-es-rUS/strings.xml
+++ b/library/ui/src/main/res/values-es-rUS/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetir todo"</string>
   <string name="exo_controls_repeat_off_description">"No repetir"</string>
   <string name="exo_controls_repeat_one_description">"Repetir uno"</string>
+  <string name="exo_controls_shuffle_description">"Reproducir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-es/strings.xml b/library/ui/src/main/res/values-es/strings.xml
index 116f064223..04e1ea038c 100644
--- a/library/ui/src/main/res/values-es/strings.xml
+++ b/library/ui/src/main/res/values-es/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetir todo"</string>
   <string name="exo_controls_repeat_off_description">"No repetir"</string>
   <string name="exo_controls_repeat_one_description">"Repetir uno"</string>
+  <string name="exo_controls_shuffle_description">"Reproducción aleatoria"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-et-rEE/strings.xml b/library/ui/src/main/res/values-et-rEE/strings.xml
index 153611ece4..004ec7e6c3 100644
--- a/library/ui/src/main/res/values-et-rEE/strings.xml
+++ b/library/ui/src/main/res/values-et-rEE/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Korda kõike"</string>
   <string name="exo_controls_repeat_off_description">"Ära korda midagi"</string>
   <string name="exo_controls_repeat_one_description">"Korda ühte"</string>
+  <string name="exo_controls_shuffle_description">"Esita juhuslikus järjekorras"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-eu-rES/strings.xml b/library/ui/src/main/res/values-eu-rES/strings.xml
index 1128572d9a..6a3345303a 100644
--- a/library/ui/src/main/res/values-eu-rES/strings.xml
+++ b/library/ui/src/main/res/values-eu-rES/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Errepikatu guztiak"</string>
   <string name="exo_controls_repeat_off_description">"Ez errepikatu"</string>
   <string name="exo_controls_repeat_one_description">"Errepikatu bat"</string>
+  <string name="exo_controls_shuffle_description">"Erreproduzitu ausaz"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fa/strings.xml b/library/ui/src/main/res/values-fa/strings.xml
index d6be77323b..101fcdbfb5 100644
--- a/library/ui/src/main/res/values-fa/strings.xml
+++ b/library/ui/src/main/res/values-fa/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"تکرار همه"</string>
   <string name="exo_controls_repeat_off_description">"تکرار هیچ‌کدام"</string>
   <string name="exo_controls_repeat_one_description">"یک‌بار تکرار"</string>
+  <string name="exo_controls_shuffle_description">"پخش درهم"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fi/strings.xml b/library/ui/src/main/res/values-fi/strings.xml
index 10e4b0bbe3..92feb86683 100644
--- a/library/ui/src/main/res/values-fi/strings.xml
+++ b/library/ui/src/main/res/values-fi/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Toista kaikki"</string>
   <string name="exo_controls_repeat_off_description">"Toista ei mitään"</string>
   <string name="exo_controls_repeat_one_description">"Toista yksi"</string>
+  <string name="exo_controls_shuffle_description">"Toista satunnaisesti"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fr-rCA/strings.xml b/library/ui/src/main/res/values-fr-rCA/strings.xml
index d8852b5d3f..45fc0a86f9 100644
--- a/library/ui/src/main/res/values-fr-rCA/strings.xml
+++ b/library/ui/src/main/res/values-fr-rCA/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Tout lire en boucle"</string>
   <string name="exo_controls_repeat_off_description">"Aucune répétition"</string>
   <string name="exo_controls_repeat_one_description">"Répéter un élément"</string>
+  <string name="exo_controls_shuffle_description">"Lecture aléatoire"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fr/strings.xml b/library/ui/src/main/res/values-fr/strings.xml
index acf3670fa4..82b5a40626 100644
--- a/library/ui/src/main/res/values-fr/strings.xml
+++ b/library/ui/src/main/res/values-fr/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Tout lire en boucle"</string>
   <string name="exo_controls_repeat_off_description">"Ne rien lire en boucle"</string>
   <string name="exo_controls_repeat_one_description">"Lire en boucle un élément"</string>
+  <string name="exo_controls_shuffle_description">"Lire en mode aléatoire"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-gl-rES/strings.xml b/library/ui/src/main/res/values-gl-rES/strings.xml
index 81b854cafe..7062d8d023 100644
--- a/library/ui/src/main/res/values-gl-rES/strings.xml
+++ b/library/ui/src/main/res/values-gl-rES/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetir todo"</string>
   <string name="exo_controls_repeat_off_description">"Non repetir"</string>
   <string name="exo_controls_repeat_one_description">"Repetir un"</string>
+  <string name="exo_controls_shuffle_description">"Reprodución aleatoria"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-gu-rIN/strings.xml b/library/ui/src/main/res/values-gu-rIN/strings.xml
index 6d51c29f97..ed78b1ee30 100644
--- a/library/ui/src/main/res/values-gu-rIN/strings.xml
+++ b/library/ui/src/main/res/values-gu-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"બધા પુનરાવર્તન કરો"</string>
   <string name="exo_controls_repeat_off_description">"કંઈ પુનરાવર્તન કરો"</string>
   <string name="exo_controls_repeat_one_description">"એક પુનરાવર્તન કરો"</string>
+  <string name="exo_controls_shuffle_description">"શફલ કરો"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hi/strings.xml b/library/ui/src/main/res/values-hi/strings.xml
index eadb0519df..ec624b1f35 100644
--- a/library/ui/src/main/res/values-hi/strings.xml
+++ b/library/ui/src/main/res/values-hi/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"सभी को दोहराएं"</string>
   <string name="exo_controls_repeat_off_description">"कुछ भी न दोहराएं"</string>
   <string name="exo_controls_repeat_one_description">"एक दोहराएं"</string>
+  <string name="exo_controls_shuffle_description">"शफ़ल करें"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hr/strings.xml b/library/ui/src/main/res/values-hr/strings.xml
index cb49965640..7cb23e11dd 100644
--- a/library/ui/src/main/res/values-hr/strings.xml
+++ b/library/ui/src/main/res/values-hr/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ponovi sve"</string>
   <string name="exo_controls_repeat_off_description">"Bez ponavljanja"</string>
   <string name="exo_controls_repeat_one_description">"Ponovi jedno"</string>
+  <string name="exo_controls_shuffle_description">"Reproduciraj nasumično"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hu/strings.xml b/library/ui/src/main/res/values-hu/strings.xml
index 43ac8f51ff..cf3d34c88f 100644
--- a/library/ui/src/main/res/values-hu/strings.xml
+++ b/library/ui/src/main/res/values-hu/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Összes ismétlése"</string>
   <string name="exo_controls_repeat_off_description">"Nincs ismétlés"</string>
   <string name="exo_controls_repeat_one_description">"Egy ismétlése"</string>
+  <string name="exo_controls_shuffle_description">"Véletlenszerű lejátszás"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hy-rAM/strings.xml b/library/ui/src/main/res/values-hy-rAM/strings.xml
index 3b09f9a507..13a489baf5 100644
--- a/library/ui/src/main/res/values-hy-rAM/strings.xml
+++ b/library/ui/src/main/res/values-hy-rAM/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"կրկնել այն ամենը"</string>
   <string name="exo_controls_repeat_off_description">"Չկրկնել"</string>
   <string name="exo_controls_repeat_one_description">"Կրկնել մեկը"</string>
+  <string name="exo_controls_shuffle_description">"Խառնել"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-in/strings.xml b/library/ui/src/main/res/values-in/strings.xml
index 928be5945a..09b05815e6 100644
--- a/library/ui/src/main/res/values-in/strings.xml
+++ b/library/ui/src/main/res/values-in/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ulangi Semua"</string>
   <string name="exo_controls_repeat_off_description">"Jangan Ulangi"</string>
   <string name="exo_controls_repeat_one_description">"Ulangi Satu"</string>
+  <string name="exo_controls_shuffle_description">"Acak"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-is-rIS/strings.xml b/library/ui/src/main/res/values-is-rIS/strings.xml
index 75be2aeb17..12c4632cdf 100644
--- a/library/ui/src/main/res/values-is-rIS/strings.xml
+++ b/library/ui/src/main/res/values-is-rIS/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Endurtaka allt"</string>
   <string name="exo_controls_repeat_off_description">"Endurtaka ekkert"</string>
   <string name="exo_controls_repeat_one_description">"Endurtaka eitt"</string>
+  <string name="exo_controls_shuffle_description">"Stokka"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-it/strings.xml b/library/ui/src/main/res/values-it/strings.xml
index 59117a6b75..aea20db82e 100644
--- a/library/ui/src/main/res/values-it/strings.xml
+++ b/library/ui/src/main/res/values-it/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ripeti tutti"</string>
   <string name="exo_controls_repeat_off_description">"Non ripetere nessuno"</string>
   <string name="exo_controls_repeat_one_description">"Ripeti uno"</string>
+  <string name="exo_controls_shuffle_description">"Riproduci casualmente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-iw/strings.xml b/library/ui/src/main/res/values-iw/strings.xml
index 347b137cf2..dd973af50b 100644
--- a/library/ui/src/main/res/values-iw/strings.xml
+++ b/library/ui/src/main/res/values-iw/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"חזור על הכל"</string>
   <string name="exo_controls_repeat_off_description">"אל תחזור על כלום"</string>
   <string name="exo_controls_repeat_one_description">"חזור על פריט אחד"</string>
+  <string name="exo_controls_shuffle_description">"ערבב"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ja/strings.xml b/library/ui/src/main/res/values-ja/strings.xml
index cf2cc49b67..d6ce751d5c 100644
--- a/library/ui/src/main/res/values-ja/strings.xml
+++ b/library/ui/src/main/res/values-ja/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"全曲を繰り返し"</string>
   <string name="exo_controls_repeat_off_description">"繰り返しなし"</string>
   <string name="exo_controls_repeat_one_description">"1曲を繰り返し"</string>
+  <string name="exo_controls_shuffle_description">"シャッフル"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ka-rGE/strings.xml b/library/ui/src/main/res/values-ka-rGE/strings.xml
index 75da8dde18..252e52f151 100644
--- a/library/ui/src/main/res/values-ka-rGE/strings.xml
+++ b/library/ui/src/main/res/values-ka-rGE/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"გამეორება ყველა"</string>
   <string name="exo_controls_repeat_off_description">"გაიმეორეთ არცერთი"</string>
   <string name="exo_controls_repeat_one_description">"გაიმეორეთ ერთი"</string>
+  <string name="exo_controls_shuffle_description">"არეულად დაკვრა"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-kk-rKZ/strings.xml b/library/ui/src/main/res/values-kk-rKZ/strings.xml
index b1ab22ecf6..43eb3dd030 100644
--- a/library/ui/src/main/res/values-kk-rKZ/strings.xml
+++ b/library/ui/src/main/res/values-kk-rKZ/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Барлығын қайталау"</string>
   <string name="exo_controls_repeat_off_description">"Ешқайсысын қайталамау"</string>
   <string name="exo_controls_repeat_one_description">"Біреуін қайталау"</string>
+  <string name="exo_controls_shuffle_description">"Кездейсоқ ретпен ойнату"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-km-rKH/strings.xml b/library/ui/src/main/res/values-km-rKH/strings.xml
index dfd9f7d863..653c9f051d 100644
--- a/library/ui/src/main/res/values-km-rKH/strings.xml
+++ b/library/ui/src/main/res/values-km-rKH/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"ធ្វើ​ម្ដង​ទៀត​ទាំងអស់"</string>
   <string name="exo_controls_repeat_off_description">"មិន​ធ្វើ​ឡើង​វិញ"</string>
   <string name="exo_controls_repeat_one_description">"ធ្វើ​​ឡើងវិញ​ម្ដង"</string>
+  <string name="exo_controls_shuffle_description">"ច្របល់"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-kn-rIN/strings.xml b/library/ui/src/main/res/values-kn-rIN/strings.xml
index 868af17a65..7368fc8ad3 100644
--- a/library/ui/src/main/res/values-kn-rIN/strings.xml
+++ b/library/ui/src/main/res/values-kn-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"ಎಲ್ಲವನ್ನು ಪುನರಾವರ್ತಿಸಿ"</string>
   <string name="exo_controls_repeat_off_description">"ಯಾವುದನ್ನೂ ಪುನರಾವರ್ತಿಸಬೇಡಿ"</string>
   <string name="exo_controls_repeat_one_description">"ಒಂದನ್ನು ಪುನರಾವರ್ತಿಸಿ"</string>
+  <string name="exo_controls_shuffle_description">"ಬೆರೆಸು"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ko/strings.xml b/library/ui/src/main/res/values-ko/strings.xml
index 89636ac8a0..99d4a2f9a4 100644
--- a/library/ui/src/main/res/values-ko/strings.xml
+++ b/library/ui/src/main/res/values-ko/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"전체 반복"</string>
   <string name="exo_controls_repeat_off_description">"반복 안함"</string>
   <string name="exo_controls_repeat_one_description">"한 항목 반복"</string>
+  <string name="exo_controls_shuffle_description">"셔플"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ky-rKG/strings.xml b/library/ui/src/main/res/values-ky-rKG/strings.xml
index 15fd50468a..9b903a124e 100644
--- a/library/ui/src/main/res/values-ky-rKG/strings.xml
+++ b/library/ui/src/main/res/values-ky-rKG/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Баарын кайталоо"</string>
   <string name="exo_controls_repeat_off_description">"Эч бирин кайталабоо"</string>
   <string name="exo_controls_repeat_one_description">"Бирөөнү кайталоо"</string>
+  <string name="exo_controls_shuffle_description">"Аралаштыруу"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lo-rLA/strings.xml b/library/ui/src/main/res/values-lo-rLA/strings.xml
index 405d0c64fe..702cd54396 100644
--- a/library/ui/src/main/res/values-lo-rLA/strings.xml
+++ b/library/ui/src/main/res/values-lo-rLA/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"ຫຼິ້ນ​ຊ້ຳ​ທັງ​ໝົດ"</string>
   <string name="exo_controls_repeat_off_description">"​ບໍ່ຫຼິ້ນ​ຊ້ຳ"</string>
   <string name="exo_controls_repeat_one_description">"ຫຼິ້ນ​ຊ້ຳ"</string>
+  <string name="exo_controls_shuffle_description">"ຫຼີ້ນແບບສຸ່ມ"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lt/strings.xml b/library/ui/src/main/res/values-lt/strings.xml
index bd7d4142fc..d6073f42e3 100644
--- a/library/ui/src/main/res/values-lt/strings.xml
+++ b/library/ui/src/main/res/values-lt/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Kartoti viską"</string>
   <string name="exo_controls_repeat_off_description">"Nekartoti nieko"</string>
   <string name="exo_controls_repeat_one_description">"Kartoti vieną"</string>
+  <string name="exo_controls_shuffle_description">"Maišyti"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lv/strings.xml b/library/ui/src/main/res/values-lv/strings.xml
index c2ebc70cbd..64393d679a 100644
--- a/library/ui/src/main/res/values-lv/strings.xml
+++ b/library/ui/src/main/res/values-lv/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Atkārtot visu"</string>
   <string name="exo_controls_repeat_off_description">"Neatkārtot nevienu"</string>
   <string name="exo_controls_repeat_one_description">"Atkārtot vienu"</string>
+  <string name="exo_controls_shuffle_description">"Atskaņot jauktā secībā"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-mk-rMK/strings.xml b/library/ui/src/main/res/values-mk-rMK/strings.xml
index 14ce7111a4..60858df8b1 100644
--- a/library/ui/src/main/res/values-mk-rMK/strings.xml
+++ b/library/ui/src/main/res/values-mk-rMK/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Повтори ги сите"</string>
   <string name="exo_controls_repeat_off_description">"Не повторувај ниту една"</string>
   <string name="exo_controls_repeat_one_description">"Повтори една"</string>
+  <string name="exo_controls_shuffle_description">"По случаен избор"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ml-rIN/strings.xml b/library/ui/src/main/res/values-ml-rIN/strings.xml
index 17fe7a1655..4e5eddb93e 100644
--- a/library/ui/src/main/res/values-ml-rIN/strings.xml
+++ b/library/ui/src/main/res/values-ml-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"എല്ലാം ആവർത്തിക്കുക"</string>
   <string name="exo_controls_repeat_off_description">"ഒന്നും ആവർത്തിക്കരുത്"</string>
   <string name="exo_controls_repeat_one_description">"ഒന്ന് ആവർത്തിക്കുക"</string>
+  <string name="exo_controls_shuffle_description">"ഷഫിൾ ചെയ്യുക"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-mn-rMN/strings.xml b/library/ui/src/main/res/values-mn-rMN/strings.xml
index bf9a7e03bf..4ab26a7f62 100644
--- a/library/ui/src/main/res/values-mn-rMN/strings.xml
+++ b/library/ui/src/main/res/values-mn-rMN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Бүгдийг давтах"</string>
   <string name="exo_controls_repeat_off_description">"Алийг нь ч давтахгүй"</string>
   <string name="exo_controls_repeat_one_description">"Нэгийг давтах"</string>
+  <string name="exo_controls_shuffle_description">"Холих"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-mr-rIN/strings.xml b/library/ui/src/main/res/values-mr-rIN/strings.xml
index df4ac9de6b..7869355b59 100644
--- a/library/ui/src/main/res/values-mr-rIN/strings.xml
+++ b/library/ui/src/main/res/values-mr-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"सर्व पुनरावृत्ती करा"</string>
   <string name="exo_controls_repeat_off_description">"काहीही पुनरावृत्ती करू नका"</string>
   <string name="exo_controls_repeat_one_description">"एक पुनरावृत्ती करा"</string>
+  <string name="exo_controls_shuffle_description">"शफल करा"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ms-rMY/strings.xml b/library/ui/src/main/res/values-ms-rMY/strings.xml
index 33dfcb40f0..fdde3de079 100644
--- a/library/ui/src/main/res/values-ms-rMY/strings.xml
+++ b/library/ui/src/main/res/values-ms-rMY/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ulang semua"</string>
   <string name="exo_controls_repeat_off_description">"Tiada ulangan"</string>
   <string name="exo_controls_repeat_one_description">"Ulangan"</string>
+  <string name="exo_controls_shuffle_description">"Rombak"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-my-rMM/strings.xml b/library/ui/src/main/res/values-my-rMM/strings.xml
index b4ea5b1155..3d7918d953 100644
--- a/library/ui/src/main/res/values-my-rMM/strings.xml
+++ b/library/ui/src/main/res/values-my-rMM/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"အားလုံး ထပ်တလဲလဲဖွင့်ရန်"</string>
   <string name="exo_controls_repeat_off_description">"ထပ်တလဲလဲမဖွင့်ရန်"</string>
   <string name="exo_controls_repeat_one_description">"တစ်ခုအား ထပ်တလဲလဲဖွင့်ရန်"</string>
+  <string name="exo_controls_shuffle_description">"မွှေနှောက်ဖွင့်ရန်"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-nb/strings.xml b/library/ui/src/main/res/values-nb/strings.xml
index 679bf1134c..370c759b84 100644
--- a/library/ui/src/main/res/values-nb/strings.xml
+++ b/library/ui/src/main/res/values-nb/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Gjenta alle"</string>
   <string name="exo_controls_repeat_off_description">"Ikke gjenta noen"</string>
   <string name="exo_controls_repeat_one_description">"Gjenta én"</string>
+  <string name="exo_controls_shuffle_description">"Spill av i tilfeldig rekkefølge"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ne-rNP/strings.xml b/library/ui/src/main/res/values-ne-rNP/strings.xml
index 43730c1880..19f43d0392 100644
--- a/library/ui/src/main/res/values-ne-rNP/strings.xml
+++ b/library/ui/src/main/res/values-ne-rNP/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"सबै दोहोर्याउनुहोस्"</string>
   <string name="exo_controls_repeat_off_description">"कुनै पनि नदोहोर्याउनुहोस्"</string>
   <string name="exo_controls_repeat_one_description">"एउटा दोहोर्याउनुहोस्"</string>
+  <string name="exo_controls_shuffle_description">"मिसाउनुहोस्"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-nl/strings.xml b/library/ui/src/main/res/values-nl/strings.xml
index 6383c977fc..a67ab2968c 100644
--- a/library/ui/src/main/res/values-nl/strings.xml
+++ b/library/ui/src/main/res/values-nl/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Alles herhalen"</string>
   <string name="exo_controls_repeat_off_description">"Niet herhalen"</string>
   <string name="exo_controls_repeat_one_description">"Eén herhalen"</string>
+  <string name="exo_controls_shuffle_description">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pa-rIN/strings.xml b/library/ui/src/main/res/values-pa-rIN/strings.xml
index ddf60b0394..6250b90514 100644
--- a/library/ui/src/main/res/values-pa-rIN/strings.xml
+++ b/library/ui/src/main/res/values-pa-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"ਸਭ ਨੂੰ ਦੁਹਰਾਓ"</string>
   <string name="exo_controls_repeat_off_description">"ਕੋਈ ਵੀ ਨਹੀਂ ਦੁਹਰਾਓ"</string>
   <string name="exo_controls_repeat_one_description">"ਇੱਕ ਦੁਹਰਾਓ"</string>
+  <string name="exo_controls_shuffle_description">"ਸ਼ੱਫਲ"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pl/strings.xml b/library/ui/src/main/res/values-pl/strings.xml
index 113c568f85..ff1d77fdd5 100644
--- a/library/ui/src/main/res/values-pl/strings.xml
+++ b/library/ui/src/main/res/values-pl/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Powtórz wszystkie"</string>
   <string name="exo_controls_repeat_off_description">"Nie powtarzaj"</string>
   <string name="exo_controls_repeat_one_description">"Powtórz jeden"</string>
+  <string name="exo_controls_shuffle_description">"Odtwarzaj losowo"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt-rBR/strings.xml b/library/ui/src/main/res/values-pt-rBR/strings.xml
index 87c54358ba..86a91b0677 100644
--- a/library/ui/src/main/res/values-pt-rBR/strings.xml
+++ b/library/ui/src/main/res/values-pt-rBR/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetir tudo"</string>
   <string name="exo_controls_repeat_off_description">"Não repetir"</string>
   <string name="exo_controls_repeat_one_description">"Repetir um"</string>
+  <string name="exo_controls_shuffle_description">"Reproduzir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt-rPT/strings.xml b/library/ui/src/main/res/values-pt-rPT/strings.xml
index ca34afec3c..5a7144e36b 100644
--- a/library/ui/src/main/res/values-pt-rPT/strings.xml
+++ b/library/ui/src/main/res/values-pt-rPT/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetir tudo"</string>
   <string name="exo_controls_repeat_off_description">"Não repetir"</string>
   <string name="exo_controls_repeat_one_description">"Repetir um"</string>
+  <string name="exo_controls_shuffle_description">"Reproduzir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt/strings.xml b/library/ui/src/main/res/values-pt/strings.xml
index 2fc3191738..8441e4e1cc 100644
--- a/library/ui/src/main/res/values-pt/strings.xml
+++ b/library/ui/src/main/res/values-pt/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetir tudo"</string>
   <string name="exo_controls_repeat_off_description">"Não repetir"</string>
   <string name="exo_controls_repeat_one_description">"Repetir uma"</string>
+  <string name="exo_controls_shuffle_description">"Reproduzir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ro/strings.xml b/library/ui/src/main/res/values-ro/strings.xml
index 0b2ce540f7..6b8644e30a 100644
--- a/library/ui/src/main/res/values-ro/strings.xml
+++ b/library/ui/src/main/res/values-ro/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Repetați toate"</string>
   <string name="exo_controls_repeat_off_description">"Repetați niciuna"</string>
   <string name="exo_controls_repeat_one_description">"Repetați unul"</string>
+  <string name="exo_controls_shuffle_description">"Redați aleatoriu"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ru/strings.xml b/library/ui/src/main/res/values-ru/strings.xml
index 1d179e028c..51d11d6371 100644
--- a/library/ui/src/main/res/values-ru/strings.xml
+++ b/library/ui/src/main/res/values-ru/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Повторять все"</string>
   <string name="exo_controls_repeat_off_description">"Не повторять"</string>
   <string name="exo_controls_repeat_one_description">"Повторять один элемент"</string>
+  <string name="exo_controls_shuffle_description">"Перемешать"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-si-rLK/strings.xml b/library/ui/src/main/res/values-si-rLK/strings.xml
index bc37d98eed..eb8453b156 100644
--- a/library/ui/src/main/res/values-si-rLK/strings.xml
+++ b/library/ui/src/main/res/values-si-rLK/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"සියලු නැවත"</string>
   <string name="exo_controls_repeat_off_description">"කිසිවක් නැවත"</string>
   <string name="exo_controls_repeat_one_description">"නැවත නැවත එක්"</string>
+  <string name="exo_controls_shuffle_description">"කලවම් කරන්න"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sk/strings.xml b/library/ui/src/main/res/values-sk/strings.xml
index a6ea26bdf0..2428dbdcce 100644
--- a/library/ui/src/main/res/values-sk/strings.xml
+++ b/library/ui/src/main/res/values-sk/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Opakovať všetko"</string>
   <string name="exo_controls_repeat_off_description">"Neopakovať"</string>
   <string name="exo_controls_repeat_one_description">"Opakovať jednu položku"</string>
+  <string name="exo_controls_shuffle_description">"Náhodne prehrávať"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sl/strings.xml b/library/ui/src/main/res/values-sl/strings.xml
index 39813fa385..8ed731b0d3 100644
--- a/library/ui/src/main/res/values-sl/strings.xml
+++ b/library/ui/src/main/res/values-sl/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ponovi vse"</string>
   <string name="exo_controls_repeat_off_description">"Ne ponovi"</string>
   <string name="exo_controls_repeat_one_description">"Ponovi eno"</string>
+  <string name="exo_controls_shuffle_description">"Naključno predvajaj"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sq-rAL/strings.xml b/library/ui/src/main/res/values-sq-rAL/strings.xml
index 0bdc2e5f84..e2d209e10b 100644
--- a/library/ui/src/main/res/values-sq-rAL/strings.xml
+++ b/library/ui/src/main/res/values-sq-rAL/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Përsërit të gjithë"</string>
   <string name="exo_controls_repeat_off_description">"Përsëritni asnjë"</string>
   <string name="exo_controls_repeat_one_description">"Përsëritni një"</string>
+  <string name="exo_controls_shuffle_description">"Përziej"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sr/strings.xml b/library/ui/src/main/res/values-sr/strings.xml
index 0d54de5f6a..8e43a03079 100644
--- a/library/ui/src/main/res/values-sr/strings.xml
+++ b/library/ui/src/main/res/values-sr/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Понови све"</string>
   <string name="exo_controls_repeat_off_description">"Понављање је искључено"</string>
   <string name="exo_controls_repeat_one_description">"Понови једну"</string>
+  <string name="exo_controls_shuffle_description">"Пусти насумично"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sv/strings.xml b/library/ui/src/main/res/values-sv/strings.xml
index 0f7f16f91d..5ff1100632 100644
--- a/library/ui/src/main/res/values-sv/strings.xml
+++ b/library/ui/src/main/res/values-sv/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Upprepa alla"</string>
   <string name="exo_controls_repeat_off_description">"Upprepa inga"</string>
   <string name="exo_controls_repeat_one_description">"Upprepa en"</string>
+  <string name="exo_controls_shuffle_description">"Blanda"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sw/strings.xml b/library/ui/src/main/res/values-sw/strings.xml
index b48af88659..d1d5978f9c 100644
--- a/library/ui/src/main/res/values-sw/strings.xml
+++ b/library/ui/src/main/res/values-sw/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Rudia zote"</string>
   <string name="exo_controls_repeat_off_description">"Usirudie Yoyote"</string>
   <string name="exo_controls_repeat_one_description">"Rudia Moja"</string>
+  <string name="exo_controls_shuffle_description">"Changanya"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ta-rIN/strings.xml b/library/ui/src/main/res/values-ta-rIN/strings.xml
index 3dd64f52f7..43a925aa2e 100644
--- a/library/ui/src/main/res/values-ta-rIN/strings.xml
+++ b/library/ui/src/main/res/values-ta-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"அனைத்தையும் மீண்டும் இயக்கு"</string>
   <string name="exo_controls_repeat_off_description">"எதையும் மீண்டும் இயக்காதே"</string>
   <string name="exo_controls_repeat_one_description">"ஒன்றை மட்டும் மீண்டும் இயக்கு"</string>
+  <string name="exo_controls_shuffle_description">"குலை"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-te-rIN/strings.xml b/library/ui/src/main/res/values-te-rIN/strings.xml
index daf337a931..8541a44553 100644
--- a/library/ui/src/main/res/values-te-rIN/strings.xml
+++ b/library/ui/src/main/res/values-te-rIN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"అన్నీ పునరావృతం చేయి"</string>
   <string name="exo_controls_repeat_off_description">"ఏదీ పునరావృతం చేయవద్దు"</string>
   <string name="exo_controls_repeat_one_description">"ఒకదాన్ని పునరావృతం చేయి"</string>
+  <string name="exo_controls_shuffle_description">"షఫుల్ చేయి"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-th/strings.xml b/library/ui/src/main/res/values-th/strings.xml
index ff89b8d5f5..cd97712b67 100644
--- a/library/ui/src/main/res/values-th/strings.xml
+++ b/library/ui/src/main/res/values-th/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"เล่นซ้ำทั้งหมด"</string>
   <string name="exo_controls_repeat_off_description">"ไม่เล่นซ้ำ"</string>
   <string name="exo_controls_repeat_one_description">"เล่นซ้ำรายการเดียว"</string>
+  <string name="exo_controls_shuffle_description">"สุ่มเพลง"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-tl/strings.xml b/library/ui/src/main/res/values-tl/strings.xml
index 89cf2ef400..e8cb87acdd 100644
--- a/library/ui/src/main/res/values-tl/strings.xml
+++ b/library/ui/src/main/res/values-tl/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Ulitin Lahat"</string>
   <string name="exo_controls_repeat_off_description">"Walang Uulitin"</string>
   <string name="exo_controls_repeat_one_description">"Ulitin ang Isa"</string>
+  <string name="exo_controls_shuffle_description">"I-shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-tr/strings.xml b/library/ui/src/main/res/values-tr/strings.xml
index 87dba7204c..cd1bfc5444 100644
--- a/library/ui/src/main/res/values-tr/strings.xml
+++ b/library/ui/src/main/res/values-tr/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Tümünü Tekrarla"</string>
   <string name="exo_controls_repeat_off_description">"Hiçbirini Tekrarlama"</string>
   <string name="exo_controls_repeat_one_description">"Birini Tekrarla"</string>
+  <string name="exo_controls_shuffle_description">"Karıştır"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-uk/strings.xml b/library/ui/src/main/res/values-uk/strings.xml
index 1fdfe2bce5..1b0278ae94 100644
--- a/library/ui/src/main/res/values-uk/strings.xml
+++ b/library/ui/src/main/res/values-uk/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Повторити все"</string>
   <string name="exo_controls_repeat_off_description">"Не повторювати"</string>
   <string name="exo_controls_repeat_one_description">"Повторити один елемент"</string>
+  <string name="exo_controls_shuffle_description">"Перемішати"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ur-rPK/strings.xml b/library/ui/src/main/res/values-ur-rPK/strings.xml
index 956374b26a..f253e56c00 100644
--- a/library/ui/src/main/res/values-ur-rPK/strings.xml
+++ b/library/ui/src/main/res/values-ur-rPK/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"سبھی کو دہرائیں"</string>
   <string name="exo_controls_repeat_off_description">"کسی کو نہ دہرائیں"</string>
   <string name="exo_controls_repeat_one_description">"ایک کو دہرائیں"</string>
+  <string name="exo_controls_shuffle_description">"شفل کریں"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-uz-rUZ/strings.xml b/library/ui/src/main/res/values-uz-rUZ/strings.xml
index 286d4d01ab..a322690b2d 100644
--- a/library/ui/src/main/res/values-uz-rUZ/strings.xml
+++ b/library/ui/src/main/res/values-uz-rUZ/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Barchasini takrorlash"</string>
   <string name="exo_controls_repeat_off_description">"Takrorlamaslik"</string>
   <string name="exo_controls_repeat_one_description">"Bir marta takrorlash"</string>
+  <string name="exo_controls_shuffle_description">"Tasodifiy tartibda"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-vi/strings.xml b/library/ui/src/main/res/values-vi/strings.xml
index 4dea58d494..cff19eca7e 100644
--- a/library/ui/src/main/res/values-vi/strings.xml
+++ b/library/ui/src/main/res/values-vi/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Lặp lại tất cả"</string>
   <string name="exo_controls_repeat_off_description">"Không lặp lại"</string>
   <string name="exo_controls_repeat_one_description">"Lặp lại một mục"</string>
+  <string name="exo_controls_shuffle_description">"Trộn bài"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rCN/strings.xml b/library/ui/src/main/res/values-zh-rCN/strings.xml
index e15d84e777..cf3fe5e88b 100644
--- a/library/ui/src/main/res/values-zh-rCN/strings.xml
+++ b/library/ui/src/main/res/values-zh-rCN/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"重复播放全部"</string>
   <string name="exo_controls_repeat_off_description">"不重复播放"</string>
   <string name="exo_controls_repeat_one_description">"重复播放单个视频"</string>
+  <string name="exo_controls_shuffle_description">"随机播放"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rHK/strings.xml b/library/ui/src/main/res/values-zh-rHK/strings.xml
index ba793e98a8..78fe4ad995 100644
--- a/library/ui/src/main/res/values-zh-rHK/strings.xml
+++ b/library/ui/src/main/res/values-zh-rHK/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"重複播放所有媒體項目"</string>
   <string name="exo_controls_repeat_off_description">"不重複播放任何媒體項目"</string>
   <string name="exo_controls_repeat_one_description">"重複播放一個媒體項目"</string>
+  <string name="exo_controls_shuffle_description">"隨機播放"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rTW/strings.xml b/library/ui/src/main/res/values-zh-rTW/strings.xml
index bf3364d5cf..3632742904 100644
--- a/library/ui/src/main/res/values-zh-rTW/strings.xml
+++ b/library/ui/src/main/res/values-zh-rTW/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"重複播放所有媒體項目"</string>
   <string name="exo_controls_repeat_off_description">"不重複播放"</string>
   <string name="exo_controls_repeat_one_description">"重複播放單一媒體項目"</string>
+  <string name="exo_controls_shuffle_description">"隨機播放"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zu/strings.xml b/library/ui/src/main/res/values-zu/strings.xml
index d7bebaaa2a..42dd59c97f 100644
--- a/library/ui/src/main/res/values-zu/strings.xml
+++ b/library/ui/src/main/res/values-zu/strings.xml
@@ -25,4 +25,5 @@
   <string name="exo_controls_repeat_all_description">"Phinda konke"</string>
   <string name="exo_controls_repeat_off_description">"Ungaphindi lutho"</string>
   <string name="exo_controls_repeat_one_description">"Phida okukodwa"</string>
+  <string name="exo_controls_shuffle_description">"Shova"</string>
 </resources>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index d1f45228b1..525f95768c 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -39,9 +39,11 @@
     <flag name="one" value="1"/>
     <flag name="all" value="2"/>
   </attr>
+  <attr name="show_shuffle_button" format="boolean"/>
 
   <declare-styleable name="SimpleExoPlayerView">
     <attr name="use_artwork" format="boolean"/>
+    <attr name="shutter_background_color" format="color"/>
     <attr name="default_artwork" format="reference"/>
     <attr name="use_controller" format="boolean"/>
     <attr name="hide_on_touch" format="boolean"/>
@@ -64,6 +66,7 @@
     <attr name="rewind_increment"/>
     <attr name="fastforward_increment"/>
     <attr name="repeat_toggle_modes"/>
+    <attr name="show_shuffle_button"/>
     <attr name="controller_layout_id"/>
   </declare-styleable>
 
@@ -74,6 +77,7 @@
     <attr name="scrubber_enabled_size" format="dimension"/>
     <attr name="scrubber_disabled_size" format="dimension"/>
     <attr name="scrubber_dragged_size" format="dimension"/>
+    <attr name="scrubber_drawable" format="reference"/>
     <attr name="played_color" format="color"/>
     <attr name="scrubber_color" format="color"/>
     <attr name="buffered_color" format="color"/>
diff --git a/library/ui/src/main/res/values/ids.xml b/library/ui/src/main/res/values/ids.xml
index b16b1729da..b90d2329b3 100644
--- a/library/ui/src/main/res/values/ids.xml
+++ b/library/ui/src/main/res/values/ids.xml
@@ -28,6 +28,7 @@
   <item name="exo_ffwd" type="id"/>
   <item name="exo_prev" type="id"/>
   <item name="exo_next" type="id"/>
+  <item name="exo_shuffle" type="id"/>
   <item name="exo_repeat_toggle" type="id"/>
   <item name="exo_duration" type="id"/>
   <item name="exo_position" type="id"/>
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index c5d11eeadb..ee8cd78be7 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -24,4 +24,5 @@
   <string name="exo_controls_repeat_off_description">Repeat none</string>
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <string name="exo_controls_repeat_all_description">Repeat all</string>
+  <string name="exo_controls_shuffle_description">Shuffle</string>
 </resources>
diff --git a/library/ui/src/main/res/values/styles.xml b/library/ui/src/main/res/values/styles.xml
index a67cffe420..b57cbeaddf 100644
--- a/library/ui/src/main/res/values/styles.xml
+++ b/library/ui/src/main/res/values/styles.xml
@@ -16,7 +16,7 @@
 <resources>
 
   <style name="ExoMediaButton">
-    <item name="android:background">@null</item>
+    <item name="android:background">?android:attr/selectableItemBackground</item>
     <item name="android:layout_width">@dimen/exo_media_button_width</item>
     <item name="android:layout_height">@dimen/exo_media_button_height</item>
   </style>
@@ -51,4 +51,9 @@
     <item name="android:contentDescription">@string/exo_controls_pause_description</item>
   </style>
 
+  <style name="ExoMediaButton.Shuffle">
+    <item name="android:src">@drawable/exo_controls_shuffle</item>
+    <item name="android:contentDescription">@string/exo_controls_shuffle_description</item>
+  </style>
+
 </resources>
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
index 053fe4e61c..1a660591d8 100644
--- a/playbacktests/src/androidTest/AndroidManifest.xml
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -21,7 +21,7 @@
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
index 3f84b9ea85..a4cd35911b 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/CommonEncryptionDrmTest.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.playbacktests.gts;
 
 import android.test.ActivityInstrumentationTestCase2;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.testutil.ActionSchedule;
 import com.google.android.exoplayer2.testutil.HostActivity;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -29,18 +30,19 @@
   private static final String TAG = "CencDrmTest";
 
   private static final String URL_cenc =
-      "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd";
+      "https://storage.googleapis.com/exoplayer-test-media-1/gts/tears-cenc.mpd";
   private static final String URL_cbc1 =
-      "https://storage.googleapis.com/wvmedia/cbc1/h264/tears/tears_aes_cbc1.mpd";
+      "https://storage.googleapis.com/exoplayer-test-media-1/gts/tears-aes-cbc1.mpd";
   private static final String URL_cbcs =
-      "https://storage.googleapis.com/wvmedia/cbcs/h264/tears/tears_aes_cbcs.mpd";
+      "https://storage.googleapis.com/exoplayer-test-media-1/gts/tears-aes-cbcs.mpd";
   private static final String ID_AUDIO = "0";
   private static final String[] IDS_VIDEO = new String[] {"1", "2"};
 
   // Seeks help reproduce playback issues in certain devices.
   private static final ActionSchedule ACTION_SCHEDULE_WITH_SEEKS = new ActionSchedule.Builder(TAG)
-      .delay(30000).seek(300000).delay(10000).seek(270000).delay(10000).seek(200000).delay(10000)
-      .stop().build();
+      .waitForPlaybackState(Player.STATE_READY).delay(30000).seekAndWait(300000).delay(10000)
+      .seekAndWait(270000).delay(10000).seekAndWait(200000).delay(10000).seekAndWait(732000)
+      .build();
 
   private DashTestRunner testRunner;
 
@@ -65,7 +67,7 @@ protected void tearDown() throws Exception {
     super.tearDown();
   }
 
-  public void testCencSchemeType() {
+  public void testCencSchemeTypeV18() {
     if (Util.SDK_INT < 18) {
       // Pass.
       return;
@@ -73,23 +75,27 @@ public void testCencSchemeType() {
     testRunner.setStreamName("test_widevine_h264_scheme_cenc").setManifestUrl(URL_cenc).run();
   }
 
-  public void testCbc1SchemeType() {
-    if (Util.SDK_INT < 24) {
+  public void testCbc1SchemeTypeV25() {
+    if (Util.SDK_INT < 25) {
+      // cbc1 support was added in API 24, but it is stable from API 25 onwards.
+      // See [internal: b/65634809].
       // Pass.
       return;
     }
     testRunner.setStreamName("test_widevine_h264_scheme_cbc1").setManifestUrl(URL_cbc1).run();
   }
 
-  public void testCbcsSchemeType() {
-    if (Util.SDK_INT < 24) {
+  public void testCbcsSchemeTypeV25() {
+    if (Util.SDK_INT < 25) {
+      // cbcs support was added in API 24, but it is stable from API 25 onwards.
+      // See [internal: b/65634809].
       // Pass.
       return;
     }
     testRunner.setStreamName("test_widevine_h264_scheme_cbcs").setManifestUrl(URL_cbcs).run();
   }
 
-  public void testCensSchemeType() {
+  public void testCensSchemeTypeV25() {
     // TODO: Implement once content is available. Track [internal: b/31219813].
   }
 
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
new file mode 100644
index 0000000000..8e02204c26
--- /dev/null
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.playbacktests.gts;
+
+import android.net.Uri;
+import android.test.ActivityInstrumentationTestCase2;
+import android.util.Log;
+import com.google.android.exoplayer2.offline.Downloader;
+import com.google.android.exoplayer2.offline.Downloader.ProgressListener;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.source.dash.offline.DashDownloader;
+import com.google.android.exoplayer2.testutil.HostActivity;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSourceFactory;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Tests downloaded DASH playbacks.
+ */
+public final class DashDownloadTest extends ActivityInstrumentationTestCase2<HostActivity> {
+
+  private static final String TAG = "DashDownloadTest";
+
+  private DashTestRunner testRunner;
+  private File tempFolder;
+  private SimpleCache cache;
+
+  public DashDownloadTest() {
+    super(HostActivity.class);
+  }
+
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation())
+        .setManifestUrl(DashTestData.H264_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_CDD_FIXED);
+    tempFolder = Util.createTempDirectory(getActivity(), "ExoPlayerTest");
+    cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    testRunner = null;
+    Util.recursiveDelete(tempFolder);
+    cache = null;
+    super.tearDown();
+  }
+
+  // Download tests
+
+  public void testDownload() throws Exception {
+    if (Util.SDK_INT < 16) {
+      return; // Pass.
+    }
+
+    // Download manifest only
+    createDashDownloader(false).getManifest();
+    long manifestLength = cache.getCacheSpace();
+
+    // Download representations
+    DashDownloader dashDownloader = downloadContent(false, Float.NaN);
+    assertEquals(cache.getCacheSpace() - manifestLength, dashDownloader.getDownloadedBytes());
+
+    testRunner.setStreamName("test_h264_fixed_download").
+        setDataSourceFactory(newOfflineCacheDataSourceFactory()).run();
+
+    dashDownloader.remove();
+
+    assertEquals("There should be no content left.", 0, cache.getKeys().size());
+    assertEquals("There should be no content left.", 0, cache.getCacheSpace());
+  }
+
+  public void testPartialDownload() throws Exception {
+    if (Util.SDK_INT < 16) {
+      return; // Pass.
+    }
+
+    // Just download the first half and manifest
+    downloadContent(false, 0.5f);
+
+    // Download the rest
+    DashDownloader dashDownloader = downloadContent(false, Float.NaN);
+    long downloadedBytes = dashDownloader.getDownloadedBytes();
+
+    // Make sure it doesn't download any data
+    dashDownloader = downloadContent(true, Float.NaN);
+    assertEquals(downloadedBytes, dashDownloader.getDownloadedBytes());
+
+    testRunner.setStreamName("test_h264_fixed_partial_download")
+        .setDataSourceFactory(newOfflineCacheDataSourceFactory()).run();
+  }
+
+  private DashDownloader downloadContent(boolean offline, float stopAt) throws Exception {
+    DashDownloader dashDownloader = createDashDownloader(offline);
+    DashManifest dashManifest = dashDownloader.getManifest();
+    try {
+      ArrayList<RepresentationKey> keys = new ArrayList<>();
+      for (int pIndex = 0; pIndex < dashManifest.getPeriodCount(); pIndex++) {
+        List<AdaptationSet> adaptationSets = dashManifest.getPeriod(pIndex).adaptationSets;
+        for (int aIndex = 0; aIndex < adaptationSets.size(); aIndex++) {
+          AdaptationSet adaptationSet = adaptationSets.get(aIndex);
+          List<Representation> representations = adaptationSet.representations;
+          for (int rIndex = 0; rIndex < representations.size(); rIndex++) {
+            String id = representations.get(rIndex).format.id;
+            if (DashTestData.AAC_AUDIO_REPRESENTATION_ID.equals(id)
+                || DashTestData.H264_CDD_FIXED.equals(id)) {
+              keys.add(new RepresentationKey(pIndex, aIndex, rIndex));
+            }
+          }
+        }
+        dashDownloader.selectRepresentations(keys.toArray(new RepresentationKey[keys.size()]));
+        TestProgressListener listener = new TestProgressListener(stopAt);
+        dashDownloader.download(listener);
+      }
+    } catch (InterruptedException e) {
+      // do nothing
+    } catch (IOException e) {
+      Throwable exception = e;
+      while (!(exception instanceof InterruptedIOException)) {
+        if (exception == null) {
+          throw e;
+        }
+        exception = exception.getCause();
+      }
+      // else do nothing
+    }
+    return dashDownloader;
+  }
+
+  private DashDownloader createDashDownloader(boolean offline) {
+    DownloaderConstructorHelper constructorHelper = new DownloaderConstructorHelper(cache,
+        offline ? DummyDataSource.FACTORY : new DefaultHttpDataSourceFactory("ExoPlayer", null));
+    return new DashDownloader(Uri.parse(DashTestData.H264_MANIFEST), constructorHelper);
+  }
+
+  private CacheDataSourceFactory newOfflineCacheDataSourceFactory() {
+    return new CacheDataSourceFactory(cache, DummyDataSource.FACTORY,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE);
+  }
+
+  private static class TestProgressListener implements ProgressListener {
+
+    private final float stopAt;
+
+    private TestProgressListener(float stopAt) {
+      this.stopAt = stopAt;
+    }
+
+    @Override
+    public void onDownloadProgress(Downloader downloader, float downloadPercentage,
+        long downloadedBytes) {
+      Log.d("DashDownloadTest",
+          String.format("onDownloadProgress downloadPercentage = [%g], downloadedData = [%d]%n",
+          downloadPercentage, downloadedBytes));
+      if (downloadPercentage >= stopAt) {
+        Thread.currentThread().interrupt();
+      }
+    }
+
+  }
+
+}
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
index 529f57582e..3748779b9d 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
@@ -17,6 +17,7 @@
 
 import android.test.ActivityInstrumentationTestCase2;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
@@ -33,12 +34,14 @@
   private static final String TAG = "DashStreamingTest";
 
   private static final ActionSchedule SEEKING_SCHEDULE = new ActionSchedule.Builder(TAG)
-      .delay(10000).seek(15000)
-      .delay(10000).seek(30000).seek(31000).seek(32000).seek(33000).seek(34000)
+      .waitForPlaybackState(Player.STATE_READY)
+      .delay(10000).seekAndWait(15000)
+      .delay(10000).seek(30000).seek(31000).seek(32000).seek(33000).seekAndWait(34000)
       .delay(1000).pause().delay(1000).play()
-      .delay(1000).pause().seek(120000).delay(1000).play()
+      .delay(1000).pause().seekAndWait(120000).delay(1000).play()
       .build();
   private static final ActionSchedule RENDERER_DISABLING_SCHEDULE = new ActionSchedule.Builder(TAG)
+      .waitForPlaybackState(Player.STATE_READY)
       // Wait 10 seconds, disable the video renderer, wait another 10 seconds and enable it again.
       .delay(10000).disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
       .delay(10000).enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
@@ -159,7 +162,7 @@ public void testH264AdaptiveWithRendererDisabling() throws DecoderQueryException
 
   // H265 CDD.
 
-  public void testH265Fixed() {
+  public void testH265FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -173,8 +176,8 @@ public void testH265Fixed() {
         .run();
   }
 
-  public void testH265Adaptive() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+  public void testH265AdaptiveV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -188,8 +191,8 @@ public void testH265Adaptive() throws DecoderQueryException {
         .run();
   }
 
-  public void testH265AdaptiveWithSeeking() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+  public void testH265AdaptiveWithSeekingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -204,8 +207,8 @@ public void testH265AdaptiveWithSeeking() throws DecoderQueryException {
         .run();
   }
 
-  public void testH265AdaptiveWithRendererDisabling() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+  public void testH265AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -222,7 +225,7 @@ public void testH265AdaptiveWithRendererDisabling() throws DecoderQueryException
 
   // VP9 (CDD).
 
-  public void testVp9Fixed360p() {
+  public void testVp9Fixed360pV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -237,8 +240,8 @@ public void testVp9Fixed360p() {
         .run();
   }
 
-  public void testVp9Adaptive() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+  public void testVp9AdaptiveV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -252,8 +255,8 @@ public void testVp9Adaptive() throws DecoderQueryException {
         .run();
   }
 
-  public void testVp9AdaptiveWithSeeking() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+  public void testVp9AdaptiveWithSeekingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -268,8 +271,8 @@ public void testVp9AdaptiveWithSeeking() throws DecoderQueryException {
         .run();
   }
 
-  public void testVp9AdaptiveWithRendererDisabling() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+  public void testVp9AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -287,7 +290,7 @@ public void testVp9AdaptiveWithRendererDisabling() throws DecoderQueryException
   // H264: Other frame-rates for output buffer count assertions.
 
   // 23.976 fps.
-  public void test23FpsH264Fixed() {
+  public void test23FpsH264FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -303,7 +306,7 @@ public void test23FpsH264Fixed() {
   }
 
   // 24 fps.
-  public void test24FpsH264Fixed() {
+  public void test24FpsH264FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -319,7 +322,7 @@ public void test24FpsH264Fixed() {
   }
 
   // 29.97 fps.
-  public void test29FpsH264Fixed() {
+  public void test29FpsH264FixedV23() {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -337,7 +340,7 @@ public void test29FpsH264Fixed() {
   // Widevine encrypted media tests.
   // H264 CDD.
 
-  public void testWidevineH264Fixed() throws DecoderQueryException {
+  public void testWidevineH264FixedV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18) {
       // Pass.
       return;
@@ -353,7 +356,7 @@ public void testWidevineH264Fixed() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineH264Adaptive() throws DecoderQueryException {
+  public void testWidevineH264AdaptiveV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
@@ -369,7 +372,7 @@ public void testWidevineH264Adaptive() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineH264AdaptiveWithSeeking() throws DecoderQueryException {
+  public void testWidevineH264AdaptiveWithSeekingV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
@@ -386,7 +389,7 @@ public void testWidevineH264AdaptiveWithSeeking() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineH264AdaptiveWithRendererDisabling() throws DecoderQueryException {
+  public void testWidevineH264AdaptiveWithRendererDisablingV18() throws DecoderQueryException {
     if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
@@ -405,7 +408,7 @@ public void testWidevineH264AdaptiveWithRendererDisabling() throws DecoderQueryE
 
   // H265 CDD.
 
-  public void testWidevineH265Fixed() throws DecoderQueryException {
+  public void testWidevineH265FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -421,8 +424,8 @@ public void testWidevineH265Fixed() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineH265Adaptive() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+  public void testWidevineH265AdaptiveV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -437,8 +440,8 @@ public void testWidevineH265Adaptive() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineH265AdaptiveWithSeeking() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+  public void testWidevineH265AdaptiveWithSeekingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -454,8 +457,8 @@ public void testWidevineH265AdaptiveWithSeeking() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineH265AdaptiveWithRendererDisabling() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+  public void testWidevineH265AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -473,7 +476,7 @@ public void testWidevineH265AdaptiveWithRendererDisabling() throws DecoderQueryE
 
   // VP9 (CDD).
 
-  public void testWidevineVp9Fixed360p() throws DecoderQueryException {
+  public void testWidevineVp9Fixed360pV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -489,8 +492,8 @@ public void testWidevineVp9Fixed360p() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineVp9Adaptive() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+  public void testWidevineVp9AdaptiveV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -505,8 +508,8 @@ public void testWidevineVp9Adaptive() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineVp9AdaptiveWithSeeking() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+  public void testWidevineVp9AdaptiveWithSeekingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -522,8 +525,8 @@ public void testWidevineVp9AdaptiveWithSeeking() throws DecoderQueryException {
         .run();
   }
 
-  public void testWidevineVp9AdaptiveWithRendererDisabling() throws DecoderQueryException {
-    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+  public void testWidevineVp9AdaptiveWithRendererDisablingV24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
       // Pass.
       return;
     }
@@ -542,7 +545,7 @@ public void testWidevineVp9AdaptiveWithRendererDisabling() throws DecoderQueryEx
   // H264: Other frame-rates for output buffer count assertions.
 
   // 23.976 fps.
-  public void testWidevine23FpsH264Fixed() throws DecoderQueryException {
+  public void testWidevine23FpsH264FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -559,7 +562,7 @@ public void testWidevine23FpsH264Fixed() throws DecoderQueryException {
   }
 
   // 24 fps.
-  public void testWidevine24FpsH264Fixed() throws DecoderQueryException {
+  public void testWidevine24FpsH264FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -576,7 +579,7 @@ public void testWidevine24FpsH264Fixed() throws DecoderQueryException {
   }
 
   // 29.97 fps.
-  public void testWidevine29FpsH264Fixed() throws DecoderQueryException {
+  public void testWidevine29FpsH264FixedV23() throws DecoderQueryException {
     if (Util.SDK_INT < 23) {
       // Pass.
       return;
@@ -592,16 +595,39 @@ public void testWidevine29FpsH264Fixed() throws DecoderQueryException {
         .run();
   }
 
+  // Decoder info.
+
+  public void testDecoderInfoH264() throws DecoderQueryException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H264, false);
+    assertNotNull(decoderInfo);
+    assertTrue(Util.SDK_INT < 21 || decoderInfo.adaptive);
+  }
+
+  public void testDecoderInfoH265V24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
+      // Pass.
+      return;
+    }
+    assertTrue(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H265, false).adaptive);
+  }
+
+  public void testDecoderInfoVP9V24() throws DecoderQueryException {
+    if (Util.SDK_INT < 24) {
+      // Pass.
+      return;
+    }
+    assertTrue(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_VP9, false).adaptive);
+  }
+
   // Internal.
 
   private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQueryException {
     MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false);
-    assertNotNull(decoderInfo);
-    if (decoderInfo.adaptive) {
-      return false;
-    }
-    assertTrue(Util.SDK_INT < 21);
-    return true;
+    return decoderInfo == null || !decoderInfo.adaptive;
   }
 
 }
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
index 9b8d6483b9..85cefbc2f6 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -108,21 +108,23 @@
   private String widevineLicenseUrl;
   private DataSource.Factory dataSourceFactory;
 
-  @TargetApi(18)
   @SuppressWarnings("ResourceType")
   public static boolean isL1WidevineAvailable(String mimeType) {
-    try {
-      // Force L3 if secure decoder is not available.
-      if (MediaCodecUtil.getDecoderInfo(mimeType, true) == null) {
-        return false;
+    if (Util.SDK_INT >= 18) {
+      try {
+        // Force L3 if secure decoder is not available.
+        if (MediaCodecUtil.getDecoderInfo(mimeType, true) == null) {
+          return false;
+        }
+        MediaDrm mediaDrm = MediaDrmBuilder.build();
+        String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
+        mediaDrm.release();
+        return WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
+      } catch (MediaCodecUtil.DecoderQueryException e) {
+        throw new IllegalStateException(e);
       }
-      MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
-      String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
-      mediaDrm.release();
-      return WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
-    } catch (MediaCodecUtil.DecoderQueryException | UnsupportedSchemeException e) {
-      throw new IllegalStateException(e);
     }
+    return false;
   }
 
   public DashTestRunner(String tag, HostActivity activity, Instrumentation instrumentation) {
@@ -323,9 +325,9 @@ protected void logMetrics(DecoderCounters audioCounters, DecoderCounters videoCo
       metricsLogger.logMetric(MetricsLogger.KEY_TEST_NAME, streamName);
       metricsLogger.logMetric(MetricsLogger.KEY_IS_CDD_LIMITED_RETRY, isCddLimitedRetry);
       metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
-          videoCounters.droppedOutputBufferCount);
+          videoCounters.droppedBufferCount);
       metricsLogger.logMetric(MetricsLogger.KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT,
-          videoCounters.maxConsecutiveDroppedOutputBufferCount);
+          videoCounters.maxConsecutiveDroppedBufferCount);
       metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_SKIPPED_COUNT,
           videoCounters.skippedOutputBufferCount);
       metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
@@ -343,20 +345,20 @@ protected void assertPassed(DecoderCounters audioCounters, DecoderCounters video
             .assertSkippedOutputBufferCount(tag + VIDEO_TAG_SUFFIX, videoCounters, 0);
         // We allow one fewer output buffer due to the way that MediaCodecRenderer and the
         // underlying decoders handle the end of stream. This should be tightened up in the future.
-        DecoderCountersUtil.assertTotalOutputBufferCount(tag + AUDIO_TAG_SUFFIX, audioCounters,
+        DecoderCountersUtil.assertTotalBufferCount(tag + AUDIO_TAG_SUFFIX, audioCounters,
             audioCounters.inputBufferCount - 1, audioCounters.inputBufferCount);
-        DecoderCountersUtil.assertTotalOutputBufferCount(tag + VIDEO_TAG_SUFFIX, videoCounters,
+        DecoderCountersUtil.assertTotalBufferCount(tag + VIDEO_TAG_SUFFIX, videoCounters,
             videoCounters.inputBufferCount - 1, videoCounters.inputBufferCount);
       }
       try {
         int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
-            * DecoderCountersUtil.getTotalOutputBuffers(videoCounters));
+            * DecoderCountersUtil.getTotalBufferCount(videoCounters));
         // Assert that performance is acceptable.
         // Assert that total dropped frames were within limit.
-        DecoderCountersUtil.assertDroppedOutputBufferLimit(tag + VIDEO_TAG_SUFFIX, videoCounters,
+        DecoderCountersUtil.assertDroppedBufferLimit(tag + VIDEO_TAG_SUFFIX, videoCounters,
             droppedFrameLimit);
         // Assert that consecutive dropped frames were within limit.
-        DecoderCountersUtil.assertConsecutiveDroppedOutputBufferLimit(tag + VIDEO_TAG_SUFFIX,
+        DecoderCountersUtil.assertConsecutiveDroppedBufferLimit(tag + VIDEO_TAG_SUFFIX,
             videoCounters, MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
       } catch (AssertionFailedError e) {
         if (trackSelector.includedAdditionalVideoFormats) {
@@ -457,4 +459,21 @@ private static boolean isFormatHandled(int formatSupport) {
 
   }
 
+  /**
+   * Creates a new {@code MediaDrm} object. The encapsulation ensures that the tests can be
+   * executed for API level < 18.
+   */
+  @TargetApi(18)
+  private static final class MediaDrmBuilder {
+
+    public static MediaDrm build () {
+      try {
+        return new MediaDrm(WIDEVINE_UUID);
+      } catch (UnsupportedSchemeException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+
+  }
+
 }
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
index c2b102d1ec..a50c230a39 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
@@ -16,8 +16,10 @@
 package com.google.android.exoplayer2.playbacktests.gts;
 
 import android.media.MediaDrm.MediaDrmStateException;
+import android.net.Uri;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Pair;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -65,8 +67,10 @@ protected void setUp() throws Exception {
     boolean useL1Widevine = DashTestRunner.isL1WidevineAvailable(MimeTypes.VIDEO_H264);
     String widevineLicenseUrl = DashTestData.getWidevineLicenseUrl(true, useL1Widevine);
     httpDataSourceFactory = new DefaultHttpDataSourceFactory(USER_AGENT);
-    offlineLicenseHelper = OfflineLicenseHelper.newWidevineInstance(widevineLicenseUrl,
-        httpDataSourceFactory);
+    if (Util.SDK_INT >= 18) {
+      offlineLicenseHelper = OfflineLicenseHelper.newWidevineInstance(widevineLicenseUrl,
+          httpDataSourceFactory);
+    }
   }
 
   @Override
@@ -85,7 +89,7 @@ protected void tearDown() throws Exception {
 
   // Offline license tests
 
-  public void testWidevineOfflineLicense() throws Exception {
+  public void testWidevineOfflineLicenseV22() throws Exception {
     if (Util.SDK_INT < 22) {
       return; // Pass.
     }
@@ -97,7 +101,7 @@ public void testWidevineOfflineLicense() throws Exception {
     Assert.assertNotNull(offlineLicenseKeySetId);
   }
 
-  public void testWidevineOfflineReleasedLicense() throws Throwable {
+  public void testWidevineOfflineReleasedLicenseV22() throws Throwable {
     if (Util.SDK_INT < 22) {
       return; // Pass.
     }
@@ -123,7 +127,7 @@ public void testWidevineOfflineReleasedLicense() throws Throwable {
     }
   }
 
-  public void testWidevineOfflineExpiredLicense() throws Exception {
+  public void testWidevineOfflineExpiredLicenseV22() throws Exception {
     if (Util.SDK_INT < 22) {
       return; // Pass.
     }
@@ -148,7 +152,7 @@ public void testWidevineOfflineExpiredLicense() throws Exception {
     testRunner.run();
   }
 
-  public void testWidevineOfflineLicenseExpiresOnPause() throws Exception {
+  public void testWidevineOfflineLicenseExpiresOnPauseV22() throws Exception {
     if (Util.SDK_INT < 22) {
       return; // Pass.
     }
@@ -161,6 +165,7 @@ public void testWidevineOfflineLicenseExpiresOnPause() throws Exception {
     assertTrue("License duration should be less than 30 sec. "
         + "Server settings might have changed.", licenseDuration < 30);
     ActionSchedule schedule = new ActionSchedule.Builder(TAG)
+        .waitForPlaybackState(Player.STATE_READY)
         .delay(3000).pause().delay(licenseDuration * 1000 + 2000).play().build();
 
     // DefaultDrmSessionManager should renew the license and stream play fine
@@ -170,7 +175,7 @@ public void testWidevineOfflineLicenseExpiresOnPause() throws Exception {
   private void downloadLicense() throws InterruptedException, DrmSessionException, IOException {
     DataSource dataSource = httpDataSourceFactory.createDataSource();
     DashManifest dashManifest = DashUtil.loadManifest(dataSource,
-        DashTestData.WIDEVINE_H264_MANIFEST);
+        Uri.parse(DashTestData.WIDEVINE_H264_MANIFEST));
     DrmInitData drmInitData = DashUtil.loadDrmInitData(dataSource, dashManifest.getPeriod(0));
     offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(drmInitData);
     Assert.assertNotNull(offlineLicenseKeySetId);
diff --git a/settings.gradle b/settings.gradle
index fb31055f5e..0a404aad73 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -19,8 +19,10 @@ if (gradle.ext.has('exoplayerModulePrefix')) {
 }
 
 include modulePrefix + 'demo'
+include modulePrefix + 'demo-ima'
 include modulePrefix + 'playbacktests'
-project(modulePrefix + 'demo').projectDir = new File(rootDir, 'demo')
+project(modulePrefix + 'demo').projectDir = new File(rootDir, 'demos/main')
+project(modulePrefix + 'demo-ima').projectDir = new File(rootDir, 'demos/ima')
 project(modulePrefix + 'playbacktests').projectDir = new File(rootDir, 'playbacktests')
 
 apply from: 'core_settings.gradle'
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index b1c6f081cf..2abe521883 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -15,10 +15,15 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.os.Handler;
 import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.testutil.ActionSchedule.ActionNode;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 
 /**
@@ -39,21 +44,41 @@ public Action(String tag, String description) {
   }
 
   /**
-   * Executes the action.
+   * Executes the action and schedules the next.
    *
    * @param player The player to which the action should be applied.
    * @param trackSelector The track selector to which the action should be applied.
    * @param surface The surface to use when applying actions.
+   * @param handler The handler to use to pass to the next action.
+   * @param nextAction The next action to schedule immediately after this action finished.
    */
-  public final void doAction(SimpleExoPlayer player, MappingTrackSelector trackSelector,
-      Surface surface) {
+  public final void doActionAndScheduleNext(SimpleExoPlayer player,
+      MappingTrackSelector trackSelector, Surface surface, Handler handler, ActionNode nextAction) {
     Log.i(tag, description);
+    doActionAndScheduleNextImpl(player, trackSelector, surface, handler, nextAction);
+  }
+
+  /**
+   * Called by {@link #doActionAndScheduleNext(SimpleExoPlayer, MappingTrackSelector, Surface,
+   * Handler, ActionNode)} to perform the action and to schedule the next action node.
+   *
+   * @param player The player to which the action should be applied.
+   * @param trackSelector The track selector to which the action should be applied.
+   * @param surface The surface to use when applying actions.
+   * @param handler The handler to use to pass to the next action.
+   * @param nextAction The next action to schedule immediately after this action finished.
+   */
+  protected void doActionAndScheduleNextImpl(SimpleExoPlayer player,
+      MappingTrackSelector trackSelector, Surface surface, Handler handler, ActionNode nextAction) {
     doActionImpl(player, trackSelector, surface);
+    if (nextAction != null) {
+      nextAction.schedule(player, trackSelector, surface, handler);
+    }
   }
 
   /**
-   * Called by {@link #doAction(SimpleExoPlayer, MappingTrackSelector, Surface)} do perform the
-   * action.
+   * Called by {@link #doActionAndScheduleNextImpl(SimpleExoPlayer, MappingTrackSelector, Surface,
+   * Handler, ActionNode)} to perform the action.
    *
    * @param player The player to which the action should be applied.
    * @param trackSelector The track selector to which the action should be applied.
@@ -63,7 +88,7 @@ protected abstract void doActionImpl(SimpleExoPlayer player, MappingTrackSelecto
       Surface surface);
 
   /**
-   * Calls {@link ExoPlayer#seekTo(long)}.
+   * Calls {@link Player#seekTo(long)}.
    */
   public static final class Seek extends Action {
 
@@ -87,7 +112,7 @@ protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSe
   }
 
   /**
-   * Calls {@link ExoPlayer#stop()}.
+   * Calls {@link Player#stop()}.
    */
   public static final class Stop extends Action {
 
@@ -107,7 +132,7 @@ protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSe
   }
 
   /**
-   * Calls {@link ExoPlayer#setPlayWhenReady(boolean)}.
+   * Calls {@link Player#setPlayWhenReady(boolean)}.
    */
   public static final class SetPlayWhenReady extends Action {
 
@@ -197,5 +222,272 @@ protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSe
 
   }
 
+  /**
+   * Calls {@link ExoPlayer#prepare(MediaSource)}.
+   */
+  public static final class PrepareSource extends Action {
+
+    private final MediaSource mediaSource;
+    private final boolean resetPosition;
+    private final boolean resetState;
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public PrepareSource(String tag, MediaSource mediaSource) {
+      this(tag, mediaSource, true, true);
+    }
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public PrepareSource(String tag, MediaSource mediaSource, boolean resetPosition,
+        boolean resetState) {
+      super(tag, "PrepareSource");
+      this.mediaSource = mediaSource;
+      this.resetPosition = resetPosition;
+      this.resetState = resetState;
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      player.prepare(mediaSource, resetPosition, resetState);
+    }
+
+  }
+
+  /**
+   * Calls {@link Player#setRepeatMode(int)}.
+   */
+  public static final class SetRepeatMode extends Action {
+
+    private final @Player.RepeatMode int repeatMode;
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public SetRepeatMode(String tag, @Player.RepeatMode int repeatMode) {
+      super(tag, "SetRepeatMode:" + repeatMode);
+      this.repeatMode = repeatMode;
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      player.setRepeatMode(repeatMode);
+    }
+
+  }
+
+  /**
+   * Calls {@link Player#setShuffleModeEnabled(boolean)}.
+   */
+  public static final class SetShuffleModeEnabled extends Action {
+
+    private final boolean shuffleModeEnabled;
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public SetShuffleModeEnabled(String tag, boolean shuffleModeEnabled) {
+      super(tag, "SetShuffleModeEnabled:" + shuffleModeEnabled);
+      this.shuffleModeEnabled = shuffleModeEnabled;
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      player.setShuffleModeEnabled(shuffleModeEnabled);
+    }
+
+  }
+
+  /**
+   * Waits for {@link Player.EventListener#onTimelineChanged(Timeline, Object)}.
+   */
+  public static final class WaitForTimelineChanged extends Action {
+
+    private final Timeline expectedTimeline;
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public WaitForTimelineChanged(String tag, Timeline expectedTimeline) {
+      super(tag, "WaitForTimelineChanged");
+      this.expectedTimeline = expectedTimeline;
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+        final ActionNode nextAction) {
+      if (nextAction == null) {
+        return;
+      }
+      Player.EventListener listener = new Player.DefaultEventListener() {
+        @Override
+        public void onTimelineChanged(Timeline timeline, Object manifest) {
+          if (timeline.equals(expectedTimeline)) {
+            player.removeListener(this);
+            nextAction.schedule(player, trackSelector, surface, handler);
+          }
+        }
+      };
+      player.addListener(listener);
+      if (player.getCurrentTimeline().equals(expectedTimeline)) {
+        player.removeListener(listener);
+        nextAction.schedule(player, trackSelector, surface, handler);
+      }
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      // Not triggered.
+    }
+
+  }
+
+  /**
+   * Waits for {@link Player.EventListener#onPositionDiscontinuity(int)}.
+   */
+  public static final class WaitForPositionDiscontinuity extends Action {
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public WaitForPositionDiscontinuity(String tag) {
+      super(tag, "WaitForPositionDiscontinuity");
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+        final ActionNode nextAction) {
+      if (nextAction == null) {
+        return;
+      }
+      player.addListener(new Player.DefaultEventListener() {
+        @Override
+        public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+          player.removeListener(this);
+          nextAction.schedule(player, trackSelector, surface, handler);
+        }
+      });
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      // Not triggered.
+    }
+
+  }
+
+  /**
+   * Waits for a specified playback state, returning either immediately or after a call to
+   * {@link Player.EventListener#onPlayerStateChanged(boolean, int)}.
+   */
+  public static final class WaitForPlaybackState extends Action {
+
+    private final int targetPlaybackState;
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public WaitForPlaybackState(String tag, int targetPlaybackState) {
+      super(tag, "WaitForPlaybackState");
+      this.targetPlaybackState = targetPlaybackState;
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+        final ActionNode nextAction) {
+      if (nextAction == null) {
+        return;
+      }
+      if (targetPlaybackState == player.getPlaybackState()) {
+        nextAction.schedule(player, trackSelector, surface, handler);
+      } else {
+        player.addListener(new Player.DefaultEventListener() {
+          @Override
+          public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+            if (targetPlaybackState == playbackState) {
+              player.removeListener(this);
+              nextAction.schedule(player, trackSelector, surface, handler);
+            }
+          }
+        });
+      }
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      // Not triggered.
+    }
+
+  }
+
+  /**
+   * Waits for {@link Player.EventListener#onSeekProcessed()}.
+   */
+  public static final class WaitForSeekProcessed extends Action {
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public WaitForSeekProcessed(String tag) {
+      super(tag, "WaitForSeekProcessed");
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+        final ActionNode nextAction) {
+      if (nextAction == null) {
+        return;
+      }
+      player.addListener(new Player.DefaultEventListener() {
+        @Override
+        public void onSeekProcessed() {
+          player.removeListener(this);
+          nextAction.schedule(player, trackSelector, surface, handler);
+        }
+      });
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      // Not triggered.
+    }
+
+  }
+
+  /**
+   * Calls {@link Runnable#run()}.
+   */
+  public static final class ExecuteRunnable extends Action {
+
+    private final Runnable runnable;
+
+    /**
+     * @param tag A tag to use for logging.
+     */
+    public ExecuteRunnable(String tag, Runnable runnable) {
+      super(tag, "ExecuteRunnable");
+      this.runnable = runnable;
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      runnable.run();
+    }
+
+  }
 
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index 66f7ebca95..ddfa2345ee 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -16,16 +16,29 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.testutil.Action.ClearVideoSurface;
+import com.google.android.exoplayer2.testutil.Action.ExecuteRunnable;
+import com.google.android.exoplayer2.testutil.Action.PrepareSource;
 import com.google.android.exoplayer2.testutil.Action.Seek;
 import com.google.android.exoplayer2.testutil.Action.SetPlayWhenReady;
 import com.google.android.exoplayer2.testutil.Action.SetRendererDisabled;
+import com.google.android.exoplayer2.testutil.Action.SetRepeatMode;
+import com.google.android.exoplayer2.testutil.Action.SetShuffleModeEnabled;
 import com.google.android.exoplayer2.testutil.Action.SetVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.Stop;
+import com.google.android.exoplayer2.testutil.Action.WaitForPlaybackState;
+import com.google.android.exoplayer2.testutil.Action.WaitForPositionDiscontinuity;
+import com.google.android.exoplayer2.testutil.Action.WaitForSeekProcessed;
+import com.google.android.exoplayer2.testutil.Action.WaitForTimelineChanged;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.util.Clock;
 
 /**
  * Schedules a sequence of {@link Action}s for execution during a test.
@@ -60,17 +73,27 @@ private ActionSchedule(ActionNode rootNode) {
   public static final class Builder {
 
     private final String tag;
+    private final Clock clock;
     private final ActionNode rootNode;
-    private long currentDelayMs;
 
+    private long currentDelayMs;
     private ActionNode previousNode;
 
     /**
      * @param tag A tag to use for logging.
      */
     public Builder(String tag) {
+      this(tag, Clock.DEFAULT);
+    }
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param clock A clock to use for measuring delays.
+     */
+    public Builder(String tag, Clock clock) {
       this.tag = tag;
-      rootNode = new ActionNode(new RootAction(tag), 0);
+      this.clock = clock;
+      rootNode = new ActionNode(new RootAction(tag), clock, 0);
       previousNode = rootNode;
     }
 
@@ -92,7 +115,7 @@ public Builder delay(long delayMs) {
      * @return The builder, for convenience.
      */
     public Builder apply(Action action) {
-      return appendActionNode(new ActionNode(action, currentDelayMs));
+      return appendActionNode(new ActionNode(action, clock, currentDelayMs));
     }
 
     /**
@@ -103,7 +126,7 @@ public Builder apply(Action action) {
      * @return The builder, for convenience.
      */
     public Builder repeat(Action action, long intervalMs) {
-      return appendActionNode(new ActionNode(action, currentDelayMs, intervalMs));
+      return appendActionNode(new ActionNode(action, clock, currentDelayMs, intervalMs));
     }
 
     /**
@@ -116,6 +139,18 @@ public Builder seek(long positionMs) {
       return apply(new Seek(tag, positionMs));
     }
 
+    /**
+     * Schedules a seek action to be executed and waits until playback resumes after the seek.
+     *
+     * @param positionMs The seek position.
+     * @return The builder, for convenience.
+     */
+    public Builder seekAndWait(long positionMs) {
+      return apply(new Seek(tag, positionMs))
+          .apply(new WaitForSeekProcessed(tag))
+          .apply(new WaitForPlaybackState(tag, Player.STATE_READY));
+    }
+
     /**
      * Schedules a stop action to be executed.
      *
@@ -179,6 +214,82 @@ public Builder setVideoSurface() {
       return apply(new SetVideoSurface(tag));
     }
 
+    /**
+     * Schedules a new source preparation action to be executed.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder prepareSource(MediaSource mediaSource) {
+      return apply(new PrepareSource(tag, mediaSource));
+    }
+
+    /**
+     * Schedules a new source preparation action to be executed.
+     * @see com.google.android.exoplayer2.ExoPlayer#prepare(MediaSource, boolean, boolean).
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder prepareSource(MediaSource mediaSource, boolean resetPosition,
+        boolean resetState) {
+      return apply(new PrepareSource(tag, mediaSource, resetPosition, resetState));
+    }
+
+    /**
+     * Schedules a repeat mode setting action to be executed.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder setRepeatMode(@Player.RepeatMode int repeatMode) {
+      return apply(new SetRepeatMode(tag, repeatMode));
+    }
+
+    /**
+     * Schedules a shuffle setting action to be executed.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder setShuffleModeEnabled(boolean shuffleModeEnabled) {
+      return apply(new SetShuffleModeEnabled(tag, shuffleModeEnabled));
+    }
+
+    /**
+     * Schedules a delay until the timeline changed to a specified expected timeline.
+     *
+     * @param expectedTimeline The expected timeline to wait for.
+     * @return The builder, for convenience.
+     */
+    public Builder waitForTimelineChanged(Timeline expectedTimeline) {
+      return apply(new WaitForTimelineChanged(tag, expectedTimeline));
+    }
+
+    /**
+     * Schedules a delay until the next position discontinuity.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder waitForPositionDiscontinuity() {
+      return apply(new WaitForPositionDiscontinuity(tag));
+    }
+
+    /**
+     * Schedules a delay until the playback state changed to the specified state.
+     *
+     * @param targetPlaybackState The target playback state.
+     * @return The builder, for convenience.
+     */
+    public Builder waitForPlaybackState(int targetPlaybackState) {
+      return apply(new WaitForPlaybackState(tag, targetPlaybackState));
+    }
+
+    /**
+     * Schedules a {@link Runnable} to be executed.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder executeRunnable(Runnable runnable) {
+      return apply(new ExecuteRunnable(tag, runnable));
+    }
+
     public ActionSchedule build() {
       return new ActionSchedule(rootNode);
     }
@@ -195,9 +306,10 @@ private Builder appendActionNode(ActionNode actionNode) {
   /**
    * Wraps an {@link Action}, allowing a delay and a next {@link Action} to be specified.
    */
-  private static final class ActionNode implements Runnable {
+  /* package */ static final class ActionNode implements Runnable {
 
     private final Action action;
+    private final Clock clock;
     private final long delayMs;
     private final long repeatIntervalMs;
 
@@ -210,20 +322,23 @@ private Builder appendActionNode(ActionNode actionNode) {
 
     /**
      * @param action The wrapped action.
+     * @param clock The clock to use for measuring the delay.
      * @param delayMs The delay between the node being scheduled and the action being executed.
      */
-    public ActionNode(Action action, long delayMs) {
-      this(action, delayMs, C.TIME_UNSET);
+    public ActionNode(Action action, Clock clock, long delayMs) {
+      this(action, clock, delayMs, C.TIME_UNSET);
     }
 
     /**
      * @param action The wrapped action.
+     * @param clock The clock to use for measuring the delay.
      * @param delayMs The delay between the node being scheduled and the action being executed.
      * @param repeatIntervalMs The interval between one execution and the next repetition. If set to
      *     {@link C#TIME_UNSET}, the action is executed once only.
      */
-    public ActionNode(Action action, long delayMs, long repeatIntervalMs) {
+    public ActionNode(Action action, Clock clock, long delayMs, long repeatIntervalMs) {
       this.action = action;
+      this.clock = clock;
       this.delayMs = delayMs;
       this.repeatIntervalMs = repeatIntervalMs;
     }
@@ -252,17 +367,24 @@ public void schedule(SimpleExoPlayer player, MappingTrackSelector trackSelector,
       this.trackSelector = trackSelector;
       this.surface = surface;
       this.mainHandler = mainHandler;
-      mainHandler.postDelayed(this, delayMs);
+      if (delayMs == 0 && Looper.myLooper() == mainHandler.getLooper()) {
+        run();
+      } else {
+        clock.postDelayed(mainHandler, this, delayMs);
+      }
     }
 
     @Override
     public void run() {
-      action.doAction(player, trackSelector, surface);
-      if (next != null) {
-        next.schedule(player, trackSelector, surface, mainHandler);
-      }
+      action.doActionAndScheduleNext(player, trackSelector, surface, mainHandler, next);
       if (repeatIntervalMs != C.TIME_UNSET) {
-        mainHandler.postDelayed(this, repeatIntervalMs);
+        clock.postDelayed(mainHandler, new Runnable() {
+            @Override
+            public void run() {
+              action.doActionAndScheduleNext(player, trackSelector, surface, mainHandler, null);
+              clock.postDelayed(mainHandler, this, repeatIntervalMs);
+            }
+          }, repeatIntervalMs);
       }
     }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
index c8ead5dcba..82fff0d4fe 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
@@ -39,11 +39,11 @@
   /** Asserts that the cache content is equal to the data in the {@code fakeDataSet}. */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
     ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    String[] uriStrings = new String[allData.size()];
+    Uri[] uris = new Uri[allData.size()];
     for (int i = 0; i < allData.size(); i++) {
-      uriStrings[i] = allData.get(i).uri;
+      uris[i] = allData.get(i).uri;
     }
-    assertCachedData(cache, fakeDataSet, uriStrings);
+    assertCachedData(cache, fakeDataSet, uris);
   }
 
   /**
@@ -51,30 +51,41 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws
    */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
       throws IOException {
+    Uri[] uris = new Uri[uriStrings.length];
+    for (int i = 0; i < uriStrings.length; i++) {
+      uris[i] = Uri.parse(uriStrings[i]);
+    }
+    assertCachedData(cache, fakeDataSet, uris);
+  }
+
+  /**
+   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   */
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
+      throws IOException {
     int totalLength = 0;
-    for (String uriString : uriStrings) {
-      byte[] data = fakeDataSet.getData(uriString).getData();
-      assertDataCached(cache, uriString, data);
+    for (Uri uri : uris) {
+      byte[] data = fakeDataSet.getData(uri).getData();
+      assertDataCached(cache, uri, data);
       totalLength += data.length;
     }
     assertEquals(totalLength, cache.getCacheSpace());
   }
 
   /** Asserts that the cache contains the given subset of data in the {@code fakeDataSet}. */
-  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
+  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
       throws IOException {
-    for (String uriString : uriStrings) {
-      assertDataCached(cache, uriString, fakeDataSet.getData(uriString).getData());
+    for (Uri uri : uris) {
+      assertDataCached(cache, uri, fakeDataSet.getData(uri).getData());
     }
   }
 
   /** Asserts that the cache contains the given data for {@code uriString}. */
-  public static void assertDataCached(Cache cache, String uriString, byte[] expected)
-      throws IOException {
+  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
     CacheDataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
-        new DataSpec(Uri.parse(uriString), DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
+        new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
     try {
       inputStream.open();
       byte[] buffer = new byte[1024];
@@ -87,7 +98,7 @@ public static void assertDataCached(Cache cache, String uriString, byte[] expect
     } finally {
       inputStream.close();
     }
-    MoreAsserts.assertEquals("Cached data doesn't match expected for '" + uriString + "',",
+    MoreAsserts.assertEquals("Cached data doesn't match expected for '" + uri + "',",
         expected, outputStream.toByteArray());
   }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
index af7c1a3e2a..392a4907d4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
@@ -17,6 +17,8 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.media.MediaCodec;
+import android.media.MediaCrypto;
 import android.os.Handler;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -25,9 +27,12 @@
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
+import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 
 /**
@@ -66,6 +71,7 @@ protected void buildVideoRenderers(Context context,
     private int queueSize;
     private int bufferCount;
     private int minimumInsertIndex;
+    private boolean skipToPositionBeforeRenderingFirstFrame;
 
     public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
         long allowedJoiningTimeMs, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
@@ -75,10 +81,23 @@ public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCod
           eventHandler, eventListener, maxDroppedFrameCountToNotify);
     }
 
+    @Override
+    protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+        MediaCrypto crypto) throws DecoderQueryException {
+      // If the codec is being initialized whilst the renderer is started, default behavior is to
+      // render the first frame (i.e. the keyframe before the current position), then drop frames up
+      // to the current playback position. For test runs that place a maximum limit on the number of
+      // dropped frames allowed, this is not desired behavior. Hence we skip (rather than drop)
+      // frames up to the current playback position [Internal: b/66494991].
+      skipToPositionBeforeRenderingFirstFrame = getState() == Renderer.STATE_STARTED;
+      super.configureCodec(codecInfo, codec, format, crypto);
+    }
+
     @Override
     protected void releaseCodec() {
       super.releaseCodec();
       clearTimestamps();
+      skipToPositionBeforeRenderingFirstFrame = false;
     }
 
     @Override
@@ -102,6 +121,34 @@ protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
       maybeShiftTimestampsList();
     }
 
+    @Override
+    protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
+        ByteBuffer buffer, int bufferIndex, int bufferFlags, long bufferPresentationTimeUs,
+        boolean shouldSkip) throws ExoPlaybackException {
+      if (skipToPositionBeforeRenderingFirstFrame && bufferPresentationTimeUs < positionUs) {
+        // After the codec has been initialized, don't render the first frame until we've caught up
+        // to the playback position. Else test runs on devices that do not support dummy surface
+        // will drop frames between rendering the first one and catching up [Internal: b/66494991].
+        shouldSkip = true;
+      }
+      return super.processOutputBuffer(positionUs, elapsedRealtimeUs, codec, buffer, bufferIndex,
+          bufferFlags, bufferPresentationTimeUs, shouldSkip);
+    }
+
+    @Override
+    protected void renderOutputBuffer(MediaCodec codec, int index, long presentationTimeUs) {
+      skipToPositionBeforeRenderingFirstFrame = false;
+      super.renderOutputBuffer(codec, index, presentationTimeUs);
+    }
+
+    @TargetApi(21)
+    @Override
+    protected void renderOutputBufferV21(MediaCodec codec, int index, long presentationTimeUs,
+        long releaseTimeNs) {
+      skipToPositionBeforeRenderingFirstFrame = false;
+      super.renderOutputBufferV21(codec, index, presentationTimeUs, releaseTimeNs);
+    }
+
     @Override
     protected void onProcessedOutputBuffer(long presentationTimeUs) {
       super.onProcessedOutputBuffer(presentationTimeUs);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java
index 448ec79c2d..16af394cdf 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java
@@ -31,8 +31,9 @@ private DecoderCountersUtil() {}
    * @param counters The counters for which the total should be calculated.
    * @return The sum of the skipped, dropped and rendered buffers.
    */
-  public static int getTotalOutputBuffers(DecoderCounters counters) {
-    return counters.skippedOutputBufferCount + counters.droppedOutputBufferCount
+  public static int getTotalBufferCount(DecoderCounters counters) {
+    counters.ensureUpdated();
+    return counters.skippedOutputBufferCount + counters.droppedBufferCount
         + counters.renderedOutputBufferCount;
   }
 
@@ -44,26 +45,24 @@ public static void assertSkippedOutputBufferCount(String name, DecoderCounters c
         + expected + ".", expected, actual);
   }
 
-  public static void assertTotalOutputBufferCount(String name, DecoderCounters counters,
-      int minCount, int maxCount) {
-    counters.ensureUpdated();
-    int actual = getTotalOutputBuffers(counters);
+  public static void assertTotalBufferCount(String name, DecoderCounters counters, int minCount,
+      int maxCount) {
+    int actual = getTotalBufferCount(counters);
     TestCase.assertTrue("Codec(" + name + ") output " + actual + " buffers. Expected in range ["
         + minCount + ", " + maxCount + "].", minCount <= actual && actual <= maxCount);
   }
 
-  public static void assertDroppedOutputBufferLimit(String name, DecoderCounters counters,
-      int limit) {
+  public static void assertDroppedBufferLimit(String name, DecoderCounters counters, int limit) {
     counters.ensureUpdated();
-    int actual = counters.droppedOutputBufferCount;
+    int actual = counters.droppedBufferCount;
     TestCase.assertTrue("Codec(" + name + ") was late decoding: " + actual + " buffers. "
         + "Limit: " + limit + ".", actual <= limit);
   }
 
-  public static void assertConsecutiveDroppedOutputBufferLimit(String name,
-      DecoderCounters counters, int limit) {
+  public static void assertConsecutiveDroppedBufferLimit(String name, DecoderCounters counters,
+      int limit) {
     counters.ensureUpdated();
-    int actual = counters.maxConsecutiveDroppedOutputBufferCount;
+    int actual = counters.maxConsecutiveDroppedBufferCount;
     TestCase.assertTrue("Codec(" + name + ") was late decoding: " + actual
         + " buffers consecutively. " + "Limit: " + limit + ".", actual <= limit);
   }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
index b61b484e32..ee4018ba0e 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.SystemClock;
 import android.util.Log;
@@ -24,23 +25,19 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
+import com.google.android.exoplayer2.audio.DefaultAudioSink;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.testutil.HostActivity.HostedTest;
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
@@ -52,14 +49,14 @@
 /**
  * A {@link HostedTest} for {@link ExoPlayer} playback tests.
  */
-public abstract class ExoHostedTest implements HostedTest, Player.EventListener,
+public abstract class ExoHostedTest extends Player.DefaultEventListener implements HostedTest,
     AudioRendererEventListener, VideoRendererEventListener {
 
   static {
-    // ExoPlayer's AudioTrack class is able to work around spurious timestamps reported by the
-    // platform (by ignoring them). Disable this workaround, since we're interested in testing
-    // that the underlying platform is behaving correctly.
-    AudioTrack.failOnSpuriousAudioTimestamp = true;
+    // DefaultAudioSink is able to work around spurious timestamps reported by the platform (by
+    // ignoring them). Disable this workaround, since we're interested in testing that the
+    // underlying platform is behaving correctly.
+    DefaultAudioSink.failOnSpuriousAudioTimestamp = true;
   }
 
   public static final long MAX_PLAYING_TIME_DISCREPANCY_MS = 2000;
@@ -72,6 +69,7 @@
   private final long expectedPlayingTimeMs;
   private final DecoderCounters videoDecoderCounters;
   private final DecoderCounters audioDecoderCounters;
+  private final ConditionVariable testFinished;
 
   private ActionSchedule pendingSchedule;
   private Handler actionHandler;
@@ -81,7 +79,7 @@
   private ExoPlaybackException playerError;
   private Player.EventListener playerEventListener;
   private boolean playerWasPrepared;
-  private boolean playerFinished;
+
   private boolean playing;
   private long totalPlayingTimeMs;
   private long lastPlayingStartTimeMs;
@@ -114,8 +112,9 @@ public ExoHostedTest(String tag, long expectedPlayingTimeMs, boolean failOnPlaye
     this.tag = tag;
     this.expectedPlayingTimeMs = expectedPlayingTimeMs;
     this.failOnPlayerError = failOnPlayerError;
-    videoDecoderCounters = new DecoderCounters();
-    audioDecoderCounters = new DecoderCounters();
+    this.testFinished = new ConditionVariable();
+    this.videoDecoderCounters = new DecoderCounters();
+    this.audioDecoderCounters = new DecoderCounters();
   }
 
   /**
@@ -169,16 +168,13 @@ public final void onStart(HostActivity host, Surface surface) {
   }
 
   @Override
-  public final boolean canStop() {
-    return playerFinished;
+  public final boolean blockUntilStopped(long timeoutMs) {
+    return testFinished.block(timeoutMs);
   }
 
   @Override
-  public final void onStop() {
-    actionHandler.removeCallbacksAndMessages(null);
-    sourceDurationMs = player.getDuration();
-    player.release();
-    player = null;
+  public final boolean forceStop() {
+    return stopTest();
   }
 
   @Override
@@ -203,23 +199,13 @@ public final void onFinished() {
 
   // Player.EventListener
 
-  @Override
-  public void onLoadingChanged(boolean isLoading) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-    // Do nothing.
-  }
-
   @Override
   public final void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
     Log.d(tag, "state [" + playWhenReady + ", " + playbackState + "]");
     playerWasPrepared |= playbackState != Player.STATE_IDLE;
     if (playbackState == Player.STATE_ENDED
         || (playbackState == Player.STATE_IDLE && playerWasPrepared)) {
-      playerFinished = true;
+      stopTest();
     }
     boolean playing = playWhenReady && playbackState == Player.STATE_READY;
     if (!this.playing && playing) {
@@ -230,11 +216,6 @@ public final void onPlayerStateChanged(boolean playWhenReady, int playbackState)
     this.playing = playing;
   }
 
-  @Override
-  public void onRepeatModeChanged(int repeatMode) {
-    // Do nothing.
-  }
-
   @Override
   public final void onPlayerError(ExoPlaybackException error) {
     playerWasPrepared = true;
@@ -242,21 +223,6 @@ public final void onPlayerError(ExoPlaybackException error) {
     onPlayerErrorInternal(error);
   }
 
-  @Override
-  public final void onPositionDiscontinuity() {
-    // Do nothing.
-  }
-
-  @Override
-  public final void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-    // Do nothing.
-  }
-
-  @Override
-  public final void onTimelineChanged(Timeline timeline, Object manifest) {
-    // Do nothing.
-  }
-
   // AudioRendererEventListener
 
   @Override
@@ -287,7 +253,7 @@ public void onAudioDisabled(DecoderCounters counters) {
   }
 
   @Override
-  public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+  public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
     Log.e(tag, "audioTrackUnderrun [" + bufferSize + ", " + bufferSizeMs + ", "
         + elapsedSinceLastFeedMs + "]", null);
   }
@@ -334,6 +300,25 @@ public void onRenderedFirstFrame(Surface surface) {
 
   // Internal logic
 
+  private boolean stopTest() {
+    if (player == null) {
+      return false;
+    }
+    actionHandler.removeCallbacksAndMessages(null);
+    sourceDurationMs = player.getDuration();
+    player.release();
+    player = null;
+    // We post opening of the finished condition so that any events posted to the main thread as a
+    // result of player.release() are guaranteed to be handled before the test returns.
+    actionHandler.post(new Runnable() {
+      @Override
+      public void run() {
+        testFinished.open();
+      }
+    });
+    return true;
+  }
+
   protected DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(String userAgent) {
     // Do nothing. Interested subclasses may override.
     return null;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
new file mode 100644
index 0000000000..a87066415d
--- /dev/null
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import com.google.android.exoplayer2.DefaultLoadControl;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder.PlayerFactory;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.text.TextOutput;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.util.LinkedList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import junit.framework.Assert;
+
+/**
+ * Helper class to run an ExoPlayer test.
+ */
+public final class ExoPlayerTestRunner extends Player.DefaultEventListener {
+
+  /**
+   * Builder to set-up a {@link ExoPlayerTestRunner}. Default fake implementations will be used for
+   * unset test properties.
+   */
+  public static final class Builder {
+
+    /**
+     * Factory to create an {@link SimpleExoPlayer} instance. The player will be created on its own
+     * {@link HandlerThread}.
+     */
+    public interface PlayerFactory {
+
+      SimpleExoPlayer createExoPlayer(RenderersFactory renderersFactory,
+          MappingTrackSelector trackSelector, LoadControl loadControl);
+
+    }
+
+    public static final Format VIDEO_FORMAT = Format.createVideoSampleFormat(null,
+        MimeTypes.VIDEO_H264, null, Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE,
+        null, null);
+    public static final Format AUDIO_FORMAT = Format.createAudioSampleFormat(null,
+        MimeTypes.AUDIO_AAC, null, Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+    private PlayerFactory playerFactory;
+    private Timeline timeline;
+    private Object manifest;
+    private MediaSource mediaSource;
+    private MappingTrackSelector trackSelector;
+    private LoadControl loadControl;
+    private Format[] supportedFormats;
+    private Renderer[] renderers;
+    private RenderersFactory renderersFactory;
+    private ActionSchedule actionSchedule;
+    private Player.EventListener eventListener;
+
+    public Builder setTimeline(Timeline timeline) {
+      Assert.assertNull(mediaSource);
+      this.timeline = timeline;
+      return this;
+    }
+
+    public Builder setManifest(Object manifest) {
+      Assert.assertNull(mediaSource);
+      this.manifest = manifest;
+      return this;
+    }
+
+    /** Replaces {@link #setTimeline(Timeline)} and {@link #setManifest(Object)}. */
+    public Builder setMediaSource(MediaSource mediaSource) {
+      Assert.assertNull(timeline);
+      Assert.assertNull(manifest);
+      this.mediaSource = mediaSource;
+      return this;
+    }
+
+    public Builder setTrackSelector(MappingTrackSelector trackSelector) {
+      this.trackSelector = trackSelector;
+      return this;
+    }
+
+    public Builder setLoadControl(LoadControl loadControl) {
+      this.loadControl = loadControl;
+      return this;
+    }
+
+    public Builder setSupportedFormats(Format... supportedFormats) {
+      this.supportedFormats = supportedFormats;
+      return this;
+    }
+
+    public Builder setRenderers(Renderer... renderers) {
+      Assert.assertNull(renderersFactory);
+      this.renderers = renderers;
+      return this;
+    }
+
+    /** Replaces {@link #setRenderers(Renderer...)}. */
+    public Builder setRenderersFactory(RenderersFactory renderersFactory) {
+      Assert.assertNull(renderers);
+      this.renderersFactory = renderersFactory;
+      return this;
+    }
+
+    public Builder setExoPlayer(PlayerFactory playerFactory) {
+      this.playerFactory = playerFactory;
+      return this;
+    }
+
+    public Builder setActionSchedule(ActionSchedule actionSchedule) {
+      this.actionSchedule = actionSchedule;
+      return this;
+    }
+
+    public Builder setEventListener(Player.EventListener eventListener) {
+      this.eventListener = eventListener;
+      return this;
+    }
+
+    public ExoPlayerTestRunner build() {
+      if (supportedFormats == null) {
+        supportedFormats = new Format[] { VIDEO_FORMAT };
+      }
+      if (trackSelector == null) {
+        trackSelector = new DefaultTrackSelector();
+      }
+      if (renderersFactory == null) {
+        if (renderers == null) {
+          renderers = new Renderer[] { new FakeRenderer(supportedFormats) };
+        }
+        renderersFactory = new RenderersFactory() {
+          @Override
+          public Renderer[] createRenderers(Handler eventHandler,
+              VideoRendererEventListener videoRendererEventListener,
+              AudioRendererEventListener audioRendererEventListener, TextOutput textRendererOutput,
+              MetadataOutput metadataRendererOutput) {
+            return renderers;
+          }
+        };
+      }
+      if (loadControl == null) {
+        loadControl = new DefaultLoadControl();
+      }
+      if (playerFactory == null) {
+        playerFactory = new PlayerFactory() {
+          @Override
+          public SimpleExoPlayer createExoPlayer(RenderersFactory renderersFactory,
+              MappingTrackSelector trackSelector, LoadControl loadControl) {
+            return ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector, loadControl);
+          }
+        };
+      }
+      if (mediaSource == null) {
+        if (timeline == null) {
+          timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
+        }
+        mediaSource = new FakeMediaSource(timeline, manifest, supportedFormats);
+      }
+      return new ExoPlayerTestRunner(playerFactory, mediaSource, renderersFactory, trackSelector,
+          loadControl, actionSchedule, eventListener);
+    }
+  }
+
+  private final PlayerFactory playerFactory;
+  private final MediaSource mediaSource;
+  private final RenderersFactory renderersFactory;
+  private final MappingTrackSelector trackSelector;
+  private final LoadControl loadControl;
+  private final ActionSchedule actionSchedule;
+  private final Player.EventListener eventListener;
+
+  private final HandlerThread playerThread;
+  private final Handler handler;
+  private final CountDownLatch endedCountDownLatch;
+  private final LinkedList<Timeline> timelines;
+  private final LinkedList<Object> manifests;
+  private final LinkedList<Integer> periodIndices;
+
+  private SimpleExoPlayer player;
+  private Exception exception;
+  private TrackGroupArray trackGroups;
+  private int positionDiscontinuityCount;
+  private boolean playerWasPrepared;
+
+  private ExoPlayerTestRunner(PlayerFactory playerFactory, MediaSource mediaSource,
+      RenderersFactory renderersFactory, MappingTrackSelector trackSelector,
+      LoadControl loadControl, ActionSchedule actionSchedule, Player.EventListener eventListener) {
+    this.playerFactory = playerFactory;
+    this.mediaSource = mediaSource;
+    this.renderersFactory = renderersFactory;
+    this.trackSelector = trackSelector;
+    this.loadControl = loadControl;
+    this.actionSchedule = actionSchedule;
+    this.eventListener = eventListener;
+    this.timelines = new LinkedList<>();
+    this.manifests = new LinkedList<>();
+    this.periodIndices = new LinkedList<>();
+    this.endedCountDownLatch = new CountDownLatch(1);
+    this.playerThread = new HandlerThread("ExoPlayerTest thread");
+    playerThread.start();
+    this.handler = new Handler(playerThread.getLooper());
+  }
+
+  // Called on the test thread to run the test.
+
+  public ExoPlayerTestRunner start() {
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          player = playerFactory.createExoPlayer(renderersFactory, trackSelector, loadControl);
+          player.addListener(ExoPlayerTestRunner.this);
+          if (eventListener != null) {
+            player.addListener(eventListener);
+          }
+          player.setPlayWhenReady(true);
+          if (actionSchedule != null) {
+            actionSchedule.start(player, trackSelector, null, handler);
+          }
+          player.prepare(mediaSource);
+        } catch (Exception e) {
+          handleException(e);
+        }
+      }
+    });
+    return this;
+  }
+
+  public ExoPlayerTestRunner blockUntilEnded(long timeoutMs) throws Exception {
+    if (!endedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
+      exception = new TimeoutException("Test playback timed out waiting for playback to end.");
+    }
+    release();
+    // Throw any pending exception (from playback, timing out or releasing).
+    if (exception != null) {
+      throw exception;
+    }
+    return this;
+  }
+
+  // Assertions called on the test thread after test finished.
+
+  public void assertTimelinesEqual(Timeline... timelines) {
+    Assert.assertEquals(timelines.length, this.timelines.size());
+    for (Timeline timeline : timelines) {
+      Assert.assertEquals(timeline, this.timelines.remove());
+    }
+  }
+
+  public void assertManifestsEqual(Object... manifests) {
+    Assert.assertEquals(manifests.length, this.manifests.size());
+    for (Object manifest : manifests) {
+      Assert.assertEquals(manifest, this.manifests.remove());
+    }
+  }
+
+  public void assertTrackGroupsEqual(TrackGroupArray trackGroupArray) {
+    Assert.assertEquals(trackGroupArray, this.trackGroups);
+  }
+
+  public void assertPositionDiscontinuityCount(int expectedCount) {
+    Assert.assertEquals(expectedCount, positionDiscontinuityCount);
+  }
+
+  public void assertPlayedPeriodIndices(int... periodIndices) {
+    Assert.assertEquals(periodIndices.length, this.periodIndices.size());
+    for (int periodIndex : periodIndices) {
+      Assert.assertEquals(periodIndex, (int) this.periodIndices.remove());
+    }
+  }
+
+  // Private implementation details.
+
+  private void release() throws InterruptedException {
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          if (player != null) {
+            player.release();
+          }
+        } catch (Exception e) {
+          handleException(e);
+        } finally {
+          playerThread.quit();
+        }
+      }
+    });
+    playerThread.join();
+  }
+
+  private void handleException(Exception exception) {
+    if (this.exception == null) {
+      this.exception = exception;
+    }
+    endedCountDownLatch.countDown();
+  }
+
+  // Player.EventListener
+
+  @Override
+  public void onTimelineChanged(Timeline timeline, Object manifest) {
+    timelines.add(timeline);
+    manifests.add(manifest);
+  }
+
+  @Override
+  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+    this.trackGroups = trackGroups;
+  }
+
+  @Override
+  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+    if (periodIndices.isEmpty() && playbackState == Player.STATE_READY) {
+      periodIndices.add(player.getCurrentPeriodIndex());
+    }
+    playerWasPrepared |= playbackState != Player.STATE_IDLE;
+    if (playbackState == Player.STATE_ENDED
+        || (playbackState == Player.STATE_IDLE && playerWasPrepared)) {
+      endedCountDownLatch.countDown();
+    }
+  }
+
+  @Override
+  public void onPlayerError(ExoPlaybackException error) {
+    handleException(exception);
+  }
+
+  @Override
+  public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+    positionDiscontinuityCount++;
+    periodIndices.add(player.getCurrentPeriodIndex());
+  }
+
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerWrapper.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerWrapper.java
deleted file mode 100644
index ab247283e6..0000000000
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerWrapper.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.testutil;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.util.Pair;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.PlaybackParameters;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Renderer;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import java.util.LinkedList;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import junit.framework.Assert;
-
-/**
- * Wraps a player with its own handler thread.
- */
-public class ExoPlayerWrapper implements Player.EventListener {
-
-  private final CountDownLatch sourceInfoCountDownLatch;
-  private final CountDownLatch endedCountDownLatch;
-  private final HandlerThread playerThread;
-  private final Handler handler;
-  private final LinkedList<Pair<Timeline, Object>> sourceInfos;
-
-  public ExoPlayer player;
-  public TrackGroupArray trackGroups;
-  public Exception exception;
-
-  // Written only on the main thread.
-  public volatile int positionDiscontinuityCount;
-
-  public ExoPlayerWrapper() {
-    sourceInfoCountDownLatch = new CountDownLatch(1);
-    endedCountDownLatch = new CountDownLatch(1);
-    playerThread = new HandlerThread("ExoPlayerTest thread");
-    playerThread.start();
-    handler = new Handler(playerThread.getLooper());
-    sourceInfos = new LinkedList<>();
-  }
-
-  // Called on the test thread.
-
-  public void blockUntilEnded(long timeoutMs) throws Exception {
-    if (!endedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
-      exception = new TimeoutException("Test playback timed out waiting for playback to end.");
-    }
-    release();
-    // Throw any pending exception (from playback, timing out or releasing).
-    if (exception != null) {
-      throw exception;
-    }
-  }
-
-  public void blockUntilSourceInfoRefreshed(long timeoutMs) throws Exception {
-    if (!sourceInfoCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
-      throw new TimeoutException("Test playback timed out waiting for source info.");
-    }
-  }
-
-  public void setup(final MediaSource mediaSource, final Renderer... renderers) {
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          player = ExoPlayerFactory.newInstance(renderers, new DefaultTrackSelector());
-          player.addListener(ExoPlayerWrapper.this);
-          player.setPlayWhenReady(true);
-          player.prepare(mediaSource);
-        } catch (Exception e) {
-          handleError(e);
-        }
-      }
-    });
-  }
-
-  public void prepare(final MediaSource mediaSource) {
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          player.prepare(mediaSource);
-        } catch (Exception e) {
-          handleError(e);
-        }
-      }
-    });
-  }
-
-  public void release() throws InterruptedException {
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          if (player != null) {
-            player.release();
-          }
-        } catch (Exception e) {
-          handleError(e);
-        } finally {
-          playerThread.quit();
-        }
-      }
-    });
-    playerThread.join();
-  }
-
-  private void handleError(Exception exception) {
-    if (this.exception == null) {
-      this.exception = exception;
-    }
-    endedCountDownLatch.countDown();
-  }
-
-  @SafeVarargs
-  public final void assertSourceInfosEquals(Pair<Timeline, Object>... sourceInfos) {
-    Assert.assertEquals(sourceInfos.length, this.sourceInfos.size());
-    for (Pair<Timeline, Object> sourceInfo : sourceInfos) {
-      Assert.assertEquals(sourceInfo, this.sourceInfos.remove());
-    }
-  }
-
-  // Player.EventListener implementation.
-
-  @Override
-  public void onLoadingChanged(boolean isLoading) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-    if (playbackState == Player.STATE_ENDED) {
-      endedCountDownLatch.countDown();
-    }
-  }
-
-  @Override
-  public void onRepeatModeChanged(int repeatMode) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest) {
-    sourceInfos.add(Pair.create(timeline, manifest));
-    sourceInfoCountDownLatch.countDown();
-  }
-
-  @Override
-  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-    this.trackGroups = trackGroups;
-  }
-
-  @Override
-  public void onPlayerError(ExoPlaybackException exception) {
-    handleError(exception);
-  }
-
-  @SuppressWarnings("NonAtomicVolatileUpdate")
-  @Override
-  public void onPositionDiscontinuity() {
-    positionDiscontinuityCount++;
-  }
-
-  @Override
-  public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
-    // Do nothing.
-  }
-
-}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java
index f4476ddf93..82c14a5b32 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSet.java
@@ -17,11 +17,12 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.source.TrackGroup;
+import java.util.Random;
 
 /**
  * Fake data set emulating the data of an adaptive media source.
- * It provides chunk data for all {@link Format}s in the given {@link TrackSelection}.
+ * It provides chunk data for all {@link Format}s in the given {@link TrackGroup}.
  */
 public final class FakeAdaptiveDataSet extends FakeDataSet {
 
@@ -30,52 +31,86 @@
    */
   public static final class Factory {
 
+    private static final Random random = new Random();
+
     private final long chunkDurationUs;
+    private final double bitratePercentStdDev;
 
-    public Factory(long chunkDurationUs) {
+    /**
+     * Set up factory for {@link FakeAdaptiveDataSet}s with a chunk duration and the standard
+     * deviation of the chunk size.
+     *
+     * @param chunkDurationUs The chunk duration to use in microseconds.
+     * @param bitratePercentStdDev The standard deviation used to generate the chunk sizes centered
+     *     around the average bitrate of the {@link Format}s. The standard deviation is given in
+     *     percent (of the average size).
+     */
+    public Factory(long chunkDurationUs, double bitratePercentStdDev) {
       this.chunkDurationUs = chunkDurationUs;
+      this.bitratePercentStdDev = bitratePercentStdDev;
     }
 
-    public FakeAdaptiveDataSet createDataSet(TrackSelection trackSelection, long mediaDurationUs) {
-      return new FakeAdaptiveDataSet(trackSelection, mediaDurationUs, chunkDurationUs);
+    /**
+     * Returns a new {@link FakeAdaptiveDataSet} for the given {@link TrackGroup}.
+     *
+     * @param trackGroup The {@link TrackGroup} for which the data set is to be created.
+     * @param mediaDurationUs The total duration of the fake data set in microseconds.
+     */
+    public FakeAdaptiveDataSet createDataSet(TrackGroup trackGroup, long mediaDurationUs) {
+      return new FakeAdaptiveDataSet(trackGroup, mediaDurationUs, chunkDurationUs,
+          bitratePercentStdDev, random);
     }
 
   }
 
-  private final long chunkCount;
+  private final int chunkCount;
   private final long chunkDurationUs;
   private final long lastChunkDurationUs;
 
-  public FakeAdaptiveDataSet(TrackSelection trackSelection, long mediaDurationUs,
-      long chunkDurationUs) {
+  /**
+   * Create {@link FakeAdaptiveDataSet} using a {@link TrackGroup} and meta data about the media.
+   *
+   * @param trackGroup The {@link TrackGroup} for which the data set is to be created.
+   * @param mediaDurationUs The total duration of the fake data set in microseconds.
+   * @param chunkDurationUs The chunk duration to use in microseconds.
+   * @param bitratePercentStdDev  The standard deviation used to generate the chunk sizes centered
+   *     around the average bitrate of the {@link Format}s in the {@link TrackGroup}. The standard
+   *     deviation is given in percent (of the average size).
+   * @param random A {@link Random} instance used to generate random chunk sizes.
+   */
+  /* package */ FakeAdaptiveDataSet(TrackGroup trackGroup, long mediaDurationUs,
+      long chunkDurationUs, double bitratePercentStdDev, Random random) {
     this.chunkDurationUs = chunkDurationUs;
-    int selectionCount = trackSelection.length();
     long lastChunkDurationUs = mediaDurationUs % chunkDurationUs;
     int fullChunks = (int) (mediaDurationUs / chunkDurationUs);
-    for (int i = 0; i < selectionCount; i++) {
+    this.lastChunkDurationUs = lastChunkDurationUs == 0 ? chunkDurationUs : lastChunkDurationUs;
+    this.chunkCount = lastChunkDurationUs == 0 ? fullChunks : fullChunks + 1;
+    double[] bitrateFactors = new double[chunkCount];
+    for (int i = 0; i < chunkCount; i++) {
+      bitrateFactors[i] = 1.0 + random.nextGaussian() * bitratePercentStdDev / 100.0;
+    }
+    for (int i = 0; i < trackGroup.length; i++) {
       String uri = getUri(i);
-      Format format = trackSelection.getFormat(i);
-      int chunkLength = (int) (format.bitrate * chunkDurationUs / (8 * C.MICROS_PER_SECOND));
+      Format format = trackGroup.getFormat(i);
+      double avgChunkLength = format.bitrate * chunkDurationUs / (8 * C.MICROS_PER_SECOND);
       FakeData newData = this.newData(uri);
       for (int j = 0; j < fullChunks; j++) {
-        newData.appendReadData(chunkLength);
+        newData.appendReadData((int) (avgChunkLength * bitrateFactors[j]));
       }
       if (lastChunkDurationUs > 0) {
-        int lastChunkLength = (int) (format.bitrate * (mediaDurationUs % chunkDurationUs)
-            / (8 * C.MICROS_PER_SECOND));
+        int lastChunkLength = (int) (format.bitrate * bitrateFactors[bitrateFactors.length - 1]
+            * (mediaDurationUs % chunkDurationUs) / (8 * C.MICROS_PER_SECOND));
         newData.appendReadData(lastChunkLength);
       }
     }
-    this.lastChunkDurationUs = lastChunkDurationUs == 0 ? chunkDurationUs : lastChunkDurationUs;
-    this.chunkCount = lastChunkDurationUs == 0 ? fullChunks : fullChunks + 1;
   }
 
-  public long getChunkCount() {
+  public int getChunkCount() {
     return chunkCount;
   }
 
-  public String getUri(int trackSelectionIndex) {
-    return "fake://adaptive.media/" + Integer.toString(trackSelectionIndex);
+  public String getUri(int trackIndex) {
+    return "fake://adaptive.media/" + trackIndex;
   }
 
   public long getChunkDuration(int chunkIndex) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
new file mode 100644
index 0000000000..3dcf551943
--- /dev/null
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.source.SequenceableLoader;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.chunk.ChunkSampleStream;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Fake {@link MediaPeriod} that provides tracks from the given {@link TrackGroupArray}. Selecting a
+ * track will give the player a {@link ChunkSampleStream<FakeChunkSource>}.
+ */
+public class FakeAdaptiveMediaPeriod extends FakeMediaPeriod
+    implements SequenceableLoader.Callback<ChunkSampleStream<FakeChunkSource>> {
+
+  private final EventDispatcher eventDispatcher;
+  private final Allocator allocator;
+  private final FakeChunkSource.Factory chunkSourceFactory;
+  private final long durationUs;
+
+  private Callback callback;
+  private ChunkSampleStream<FakeChunkSource>[] sampleStreams;
+  private SequenceableLoader sequenceableLoader;
+
+  public FakeAdaptiveMediaPeriod(TrackGroupArray trackGroupArray, EventDispatcher eventDispatcher,
+      Allocator allocator, FakeChunkSource.Factory chunkSourceFactory, long durationUs) {
+    super(trackGroupArray);
+    this.eventDispatcher = eventDispatcher;
+    this.allocator = allocator;
+    this.chunkSourceFactory = chunkSourceFactory;
+    this.durationUs = durationUs;
+  }
+
+  @Override
+  public void release() {
+    super.release();
+    for (ChunkSampleStream<FakeChunkSource> sampleStream : sampleStreams) {
+      sampleStream.release();
+    }
+  }
+
+  @Override
+  public void prepare(Callback callback, long positionUs) {
+    super.prepare(callback, positionUs);
+    this.callback = callback;
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+    long returnPositionUs = super.selectTracks(selections, mayRetainStreamFlags, streams,
+        streamResetFlags, positionUs);
+    List<ChunkSampleStream<FakeChunkSource>> validStreams = new ArrayList<>();
+    for (SampleStream stream : streams) {
+      if (stream != null) {
+        validStreams.add((ChunkSampleStream<FakeChunkSource>) stream);
+      }
+    }
+    this.sampleStreams = validStreams.toArray(new ChunkSampleStream[validStreams.size()]);
+    this.sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
+    return returnPositionUs;
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    super.getBufferedPositionUs();
+    return sequenceableLoader.getBufferedPositionUs();
+  }
+
+  @Override
+  public long seekToUs(long positionUs) {
+    for (ChunkSampleStream<FakeChunkSource> sampleStream : sampleStreams) {
+      sampleStream.seekToUs(positionUs);
+    }
+    return super.seekToUs(positionUs);
+  }
+
+  @Override
+  public long getNextLoadPositionUs() {
+    super.getNextLoadPositionUs();
+    return sequenceableLoader.getNextLoadPositionUs();
+  }
+
+  @Override
+  public boolean continueLoading(long positionUs) {
+    super.continueLoading(positionUs);
+    return sequenceableLoader.continueLoading(positionUs);
+  }
+
+  @Override
+  protected SampleStream createSampleStream(TrackSelection trackSelection) {
+    FakeChunkSource chunkSource = chunkSourceFactory.createChunkSource(trackSelection, durationUs);
+    return new ChunkSampleStream<>(
+        MimeTypes.getTrackType(trackSelection.getSelectedFormat().sampleMimeType), null,
+        chunkSource, this, allocator, 0, 3, eventDispatcher);
+  }
+
+  @Override
+  public void onContinueLoadingRequested(ChunkSampleStream<FakeChunkSource> source) {
+    callback.onContinueLoadingRequested(this);
+  }
+
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
new file mode 100644
index 0000000000..59bcaf3e7c
--- /dev/null
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import android.os.Handler;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
+import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.upstream.Allocator;
+
+/**
+ * Fake {@link MediaSource} that provides a given timeline. Creating the period returns a
+ * {@link FakeAdaptiveMediaPeriod} from the given {@link TrackGroupArray}.
+ */
+public class FakeAdaptiveMediaSource extends FakeMediaSource {
+
+  private final EventDispatcher eventDispatcher;
+  private final FakeChunkSource.Factory chunkSourceFactory;
+
+  public FakeAdaptiveMediaSource(Timeline timeline, Object manifest,
+      TrackGroupArray trackGroupArray, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener, FakeChunkSource.Factory chunkSourceFactory) {
+    super(timeline, manifest, trackGroupArray);
+    this.eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    this.chunkSourceFactory = chunkSourceFactory;
+  }
+
+  @Override
+  protected FakeMediaPeriod createFakeMediaPeriod(MediaPeriodId id, TrackGroupArray trackGroupArray,
+      Allocator allocator) {
+    Period period = timeline.getPeriod(id.periodIndex, new Period());
+    return new FakeAdaptiveMediaPeriod(trackGroupArray, eventDispatcher, allocator,
+        chunkSourceFactory, period.durationUs);
+  }
+
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
index 0c970caa15..28f5926bfa 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.net.Uri;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.chunk.Chunk;
 import com.google.android.exoplayer2.source.chunk.ChunkHolder;
@@ -50,7 +51,8 @@ public Factory(FakeAdaptiveDataSet.Factory dataSetFactory,
     }
 
     public FakeChunkSource createChunkSource(TrackSelection trackSelection, long durationUs) {
-      FakeAdaptiveDataSet dataSet = dataSetFactory.createDataSet(trackSelection, durationUs);
+      FakeAdaptiveDataSet dataSet =
+          dataSetFactory.createDataSet(trackSelection.getTrackGroup(), durationUs);
       dataSourceFactory.setFakeDataSet(dataSet);
       DataSource dataSource = dataSourceFactory.createDataSource();
       return new FakeChunkSource(trackSelection, dataSource, dataSet);
@@ -80,9 +82,10 @@ public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaCh
   }
 
   @Override
-  public void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out) {
-    long bufferedDurationUs = previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
-    trackSelection.updateSelectedTrack(bufferedDurationUs);
+  public void getNextChunk(MediaChunk previous, long playbackPositionUs, long loadPositionUs,
+      ChunkHolder out) {
+    long bufferedDurationUs = loadPositionUs - playbackPositionUs;
+    trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, C.TIME_UNSET);
     int chunkIndex = previous == null ? dataSet.getChunkIndexByPosition(playbackPositionUs)
         : previous.getNextChunkIndex();
     if (chunkIndex >= dataSet.getChunkCount()) {
@@ -91,7 +94,8 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHold
       Format selectedFormat = trackSelection.getSelectedFormat();
       long startTimeUs = dataSet.getStartTime(chunkIndex);
       long endTimeUs = startTimeUs + dataSet.getChunkDuration(chunkIndex);
-      String uri = dataSet.getUri(trackSelection.getSelectedIndex());
+      int trackGroupIndex = trackSelection.getIndexInTrackGroup(trackSelection.getSelectedIndex());
+      String uri = dataSet.getUri(trackGroupIndex);
       Segment fakeDataChunk = dataSet.getData(uri).getSegments().get(chunkIndex);
       DataSpec dataSpec = new DataSpec(Uri.parse(uri), fakeDataChunk.byteOffset,
           fakeDataChunk.length, null);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java
index 36ce4b5c3e..843e5858d8 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.os.Handler;
 import com.google.android.exoplayer2.util.Clock;
 import java.util.ArrayList;
 import java.util.List;
@@ -26,6 +27,7 @@
 
   private long currentTimeMs;
   private final List<Long> wakeUpTimes;
+  private final List<HandlerPostData> handlerPosts;
 
   /**
    * Create {@link FakeClock} with an arbitrary initial timestamp.
@@ -35,6 +37,7 @@
   public FakeClock(long initialTimeMs) {
     this.currentTimeMs = initialTimeMs;
     this.wakeUpTimes = new ArrayList<>();
+    this.handlerPosts = new ArrayList<>();
   }
 
   /**
@@ -50,10 +53,16 @@ public synchronized void advanceTime(long timeDiffMs) {
         break;
       }
     }
+    for (int i = handlerPosts.size() - 1; i >= 0; i--) {
+      if (handlerPosts.get(i).postTime <= currentTimeMs) {
+        HandlerPostData postData = handlerPosts.remove(i);
+        postData.handler.post(postData.runnable);
+      }
+    }
   }
 
   @Override
-  public long elapsedRealtime() {
+  public synchronized long elapsedRealtime() {
     return currentTimeMs;
   }
 
@@ -74,5 +83,28 @@ public synchronized void sleep(long sleepTimeMs) {
     wakeUpTimes.remove(wakeUpTimeMs);
   }
 
+  @Override
+  public synchronized void postDelayed(Handler handler, Runnable runnable, long delayMs) {
+    if (delayMs <= 0) {
+      handler.post(runnable);
+    } else {
+      handlerPosts.add(new HandlerPostData(currentTimeMs + delayMs, handler, runnable));
+    }
+  }
+
+  private static final class HandlerPostData {
+
+    public final long postTime;
+    public final Handler handler;
+    public final Runnable runnable;
+
+    public HandlerPostData(long postTime, Handler handler, Runnable runnable) {
+      this.postTime = postTime;
+      this.handler = handler;
+      this.runnable = runnable;
+    }
+
+  }
+
 }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java
index 2580205361..e77e0714e7 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSet.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.net.Uri;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -28,11 +29,11 @@
 /**
  * Collection of {@link FakeData} to be served by a {@link FakeDataSource}.
  *
- * <p>Multiple fake data can be defined by {@link FakeDataSet#setData(String, byte[])} and {@link
- * FakeDataSet#newData(String)} methods. It's also possible to define a default data by {@link
+ * <p>Multiple fake data can be defined by {@link FakeDataSet#setData(Uri, byte[])} and {@link
+ * FakeDataSet#newData(Uri)} methods. It's also possible to define a default data by {@link
  * FakeDataSet#newDefaultData()}.
  *
- * <p>{@link FakeDataSet#newData(String)} and {@link FakeDataSet#newDefaultData()} return a {@link
+ * <p>{@link FakeDataSet#newData(Uri)} and {@link FakeDataSet#newDefaultData()} return a {@link
  * FakeData} instance which can be used to define specific results during
  * {@link FakeDataSource#read(byte[], int, int)} calls.
  *
@@ -104,8 +105,8 @@ private Segment(Runnable action, Segment previousSegment) {
         this(null, 0, null, action, previousSegment);
       }
 
-      private Segment(byte[] data, int length, IOException exception, Runnable action,
-          Segment previousSegment) {
+      private Segment(@Nullable byte[] data, int length, @Nullable IOException exception,
+          @Nullable Runnable action, Segment previousSegment) {
         this.exception = exception;
         this.action = action;
         this.data = data;
@@ -125,12 +126,12 @@ public boolean isActionSegment() {
     }
 
     /** Uri of the data or null if this is the default FakeData. */
-    public final String uri;
+    public final Uri uri;
     private final ArrayList<Segment> segments;
     private final FakeDataSet dataSet;
     private boolean simulateUnknownLength;
 
-    private FakeData(FakeDataSet dataSet, String uri) {
+    private FakeData(FakeDataSet dataSet, Uri uri) {
       this.uri = uri;
       this.segments = new ArrayList<>();
       this.dataSet = dataSet;
@@ -162,8 +163,8 @@ public FakeData appendReadData(byte[] data) {
     }
 
     /**
-     * Appends data of the specified length. No actual data is available and this data should not
-     * be read.
+     * Appends a data segment of the specified length. No actual data is available and the
+     * {@link FakeDataSource} will perform no copy operations when this data is read.
      */
     public FakeData appendReadData(int length) {
       Assertions.checkState(length > 0);
@@ -219,7 +220,7 @@ private Segment getLastSegment() {
 
   }
 
-  private final HashMap<String, FakeData> dataMap;
+  private final HashMap<Uri, FakeData> dataMap;
   private FakeData defaultData;
 
   public FakeDataSet() {
@@ -234,16 +235,31 @@ public FakeData newDefaultData() {
 
   /** Sets random data with the given {@code length} for the given {@code uri}. */
   public FakeDataSet setRandomData(String uri, int length) {
+    return setRandomData(Uri.parse(uri), length);
+  }
+
+  /** Sets random data with the given {@code length} for the given {@code uri}. */
+  public FakeDataSet setRandomData(Uri uri, int length) {
     return setData(uri, TestUtil.buildTestData(length));
   }
 
   /** Sets the given {@code data} for the given {@code uri}. */
   public FakeDataSet setData(String uri, byte[] data) {
+    return setData(Uri.parse(uri), data);
+  }
+
+  /** Sets the given {@code data} for the given {@code uri}. */
+  public FakeDataSet setData(Uri uri, byte[] data) {
     return newData(uri).appendReadData(data).endData();
   }
 
   /** Returns a new {@link FakeData} with the given {@code uri}. */
   public FakeData newData(String uri) {
+    return newData(Uri.parse(uri));
+  }
+
+  /** Returns a new {@link FakeData} with the given {@code uri}. */
+  public FakeData newData(Uri uri) {
     FakeData data = new FakeData(this, uri);
     dataMap.put(uri, data);
     return data;
@@ -251,6 +267,11 @@ public FakeData newData(String uri) {
 
   /** Returns the data for the given {@code uri}, or {@code defaultData} if no data is set. */
   public FakeData getData(String uri) {
+    return getData(Uri.parse(uri));
+  }
+
+  /** Returns the data for the given {@code uri}, or {@code defaultData} if no data is set. */
+  public FakeData getData(Uri uri) {
     FakeData data = dataMap.get(uri);
     return data != null ? data : defaultData;
   }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
index 6180a8aa77..2675e1f0d7 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
@@ -166,6 +166,7 @@ public final int read(byte[] buffer, int offset, int readLength) throws IOExcept
         // Do not allow crossing of the segment boundary.
         readLength = Math.min(readLength, current.length - current.bytesRead);
         // Perform the read and return.
+        Assertions.checkArgument(buffer.length - offset >= readLength);
         if (current.data != null) {
           System.arraycopy(current.data, current.bytesRead, buffer, offset, readLength);
         }
@@ -216,7 +217,7 @@ public final void close() throws IOException {
     return dataSpecs;
   }
 
-  protected void onDataRead(int bytesRead) {
+  protected void onDataRead(int bytesRead) throws IOException {
     // Do nothing. Can be overridden.
   }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
index d8e501a298..38a5e37fa5 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.testutil;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -26,10 +25,10 @@
 import junit.framework.Assert;
 
 /**
- * Fake {@link MediaPeriod} that provides one track with a given {@link Format}. Selecting that
- * track will give the player a {@link FakeSampleStream}.
+ * Fake {@link MediaPeriod} that provides tracks from the given {@link TrackGroupArray}. Selecting
+ * tracks will give the player {@link FakeSampleStream}s.
  */
-public final class FakeMediaPeriod implements MediaPeriod {
+public class FakeMediaPeriod implements MediaPeriod {
 
   private final TrackGroupArray trackGroupArray;
 
@@ -46,7 +45,6 @@ public void release() {
   @Override
   public void prepare(Callback callback, long positionUs) {
     Assert.assertFalse(preparedPeriod);
-    Assert.assertEquals(0, positionUs);
     preparedPeriod = true;
     callback.onPrepared(this);
   }
@@ -71,8 +69,6 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
       if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
         streams[i] = null;
       }
-    }
-    for (int i = 0; i < rendererCount; i++) {
       if (streams[i] == null && selections[i] != null) {
         TrackSelection selection = selections[i];
         Assert.assertTrue(1 <= selection.length());
@@ -81,11 +77,11 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
         int indexInTrackGroup = selection.getIndexInTrackGroup(selection.getSelectedIndex());
         Assert.assertTrue(0 <= indexInTrackGroup);
         Assert.assertTrue(indexInTrackGroup < trackGroup.length);
-        streams[i] = new FakeSampleStream(selection.getSelectedFormat());
+        streams[i] = createSampleStream(selection);
         streamResetFlags[i] = true;
       }
     }
-    return 0;
+    return positionUs;
   }
 
   @Override
@@ -123,4 +119,8 @@ public boolean continueLoading(long positionUs) {
     return false;
   }
 
+  protected SampleStream createSampleStream(TrackSelection selection) {
+    return new FakeSampleStream(selection.getSelectedFormat());
+  }
+
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
index a2c1e9879e..1f2524110a 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
@@ -34,10 +34,11 @@
  */
 public class FakeMediaSource implements MediaSource {
 
-  private final Timeline timeline;
+  protected final Timeline timeline;
   private final Object manifest;
   private final TrackGroupArray trackGroupArray;
   private final ArrayList<FakeMediaPeriod> activeMediaPeriods;
+  private final ArrayList<MediaPeriodId> createdMediaPeriods;
 
   private boolean preparedSource;
   private boolean releasedSource;
@@ -58,18 +59,15 @@ public FakeMediaSource(Timeline timeline, Object manifest, TrackGroupArray track
     this.timeline = timeline;
     this.manifest = manifest;
     this.activeMediaPeriods = new ArrayList<>();
+    this.createdMediaPeriods = new ArrayList<>();
     this.trackGroupArray = trackGroupArray;
   }
 
-  public void assertReleased() {
-    Assert.assertTrue(releasedSource);
-  }
-
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     Assert.assertFalse(preparedSource);
     preparedSource = true;
-    listener.onSourceInfoRefreshed(timeline, manifest);
+    listener.onSourceInfoRefreshed(this, timeline, manifest);
   }
 
   @Override
@@ -82,8 +80,9 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkIndex(id.periodIndex, 0, timeline.getPeriodCount());
     Assert.assertTrue(preparedSource);
     Assert.assertFalse(releasedSource);
-    FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+    FakeMediaPeriod mediaPeriod = createFakeMediaPeriod(id, trackGroupArray, allocator);
     activeMediaPeriods.add(mediaPeriod);
+    createdMediaPeriods.add(id);
     return mediaPeriod;
   }
 
@@ -104,6 +103,25 @@ public void releaseSource() {
     releasedSource = true;
   }
 
+  /**
+   * Assert that the source and all periods have been released.
+   */
+  public void assertReleased() {
+    Assert.assertTrue(releasedSource);
+  }
+
+  /**
+   * Assert that a media period for the given id has been created.
+   */
+  public void assertMediaPeriodCreated(MediaPeriodId mediaPeriodId) {
+    Assert.assertTrue(createdMediaPeriods.contains(mediaPeriodId));
+  }
+
+  protected FakeMediaPeriod createFakeMediaPeriod(MediaPeriodId id, TrackGroupArray trackGroupArray,
+      Allocator allocator) {
+    return new FakeMediaPeriod(trackGroupArray);
+  }
+
   private static TrackGroupArray buildTrackGroupArray(Format... formats) {
     TrackGroup[] trackGroups = new TrackGroup[formats.length];
     for (int i = 0; i < formats.length; i++) {
@@ -111,4 +129,5 @@ private static TrackGroupArray buildTrackGroupArray(Format... formats) {
     }
     return new TrackGroupArray(trackGroups);
   }
+
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
index a66043b77f..c4270eb9c4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
@@ -59,6 +59,7 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (!isEnded) {
+      buffer.clear();
       // Verify the format matches the expected format.
       FormatHolder formatHolder = new FormatHolder();
       int result = readSource(formatHolder, buffer, false);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
index 4e1e32980f..699b850f73 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
@@ -60,8 +60,8 @@ public void maybeThrowError() throws IOException {
   }
 
   @Override
-  public void skipData(long positionUs) {
-    // Do nothing.
+  public int skipData(long positionUs) {
+    return 0;
   }
 
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
new file mode 100644
index 0000000000..0664f47023
--- /dev/null
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.ShuffleOrder;
+
+/**
+ * Fake {@link ShuffleOrder} which returns a reverse order. This order is thus deterministic but
+ * different from the original order.
+ */
+public final class FakeShuffleOrder implements ShuffleOrder {
+
+  private final int length;
+
+  public FakeShuffleOrder(int length) {
+    this.length = length;
+  }
+
+  @Override
+  public int getLength() {
+    return length;
+  }
+
+  @Override
+  public int getNextIndex(int index) {
+    return index > 0 ? index - 1 : C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getPreviousIndex(int index) {
+    return index < length - 1 ? index + 1 : C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getLastIndex() {
+    return length > 0 ? 0 : C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getFirstIndex() {
+    return length > 0 ? length - 1 : C.INDEX_UNSET;
+  }
+
+  @Override
+  public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
+    return new FakeShuffleOrder(length + insertionCount);
+  }
+
+  @Override
+  public ShuffleOrder cloneAndRemove(int removalIndex) {
+    return new FakeShuffleOrder(length - 1);
+  }
+
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSimpleExoPlayer.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSimpleExoPlayer.java
new file mode 100644
index 0000000000..4d53a6c89d
--- /dev/null
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSimpleExoPlayer.java
@@ -0,0 +1,575 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.Arrays;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+/**
+ * Fake {@link SimpleExoPlayer} which runs a simplified copy of the playback loop as fast as
+ * possible without waiting. It does only support single period timelines and does not support
+ * updates during playback (like seek, timeline changes, repeat mode changes).
+ */
+public class FakeSimpleExoPlayer extends SimpleExoPlayer {
+
+  private FakeExoPlayer player;
+
+  public FakeSimpleExoPlayer(RenderersFactory renderersFactory, TrackSelector trackSelector,
+      LoadControl loadControl, FakeClock clock) {
+    super (renderersFactory, trackSelector, loadControl);
+    player.setFakeClock(clock);
+  }
+
+  @Override
+  protected ExoPlayer createExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector,
+      LoadControl loadControl) {
+    this.player = new FakeExoPlayer(renderers, trackSelector, loadControl);
+    return player;
+  }
+
+  private static class FakeExoPlayer implements ExoPlayer, MediaSource.Listener,
+      MediaPeriod.Callback, Runnable {
+
+    private final Renderer[] renderers;
+    private final TrackSelector trackSelector;
+    private final LoadControl loadControl;
+    private final CopyOnWriteArraySet<Player.EventListener> eventListeners;
+    private final HandlerThread playbackThread;
+    private final Handler playbackHandler;
+    private final Handler eventListenerHandler;
+
+    private FakeClock clock;
+    private MediaSource mediaSource;
+    private Timeline timeline;
+    private Object manifest;
+    private MediaPeriod mediaPeriod;
+    private TrackSelectorResult selectorResult;
+
+    private boolean isStartingUp;
+    private boolean isLoading;
+    private int playbackState;
+    private long rendererPositionUs;
+    private long durationUs;
+    private volatile long currentPositionMs;
+    private volatile long bufferedPositionMs;
+
+    public FakeExoPlayer(Renderer[] renderers, TrackSelector trackSelector,
+        LoadControl loadControl) {
+      this.renderers = renderers;
+      this.trackSelector = trackSelector;
+      this.loadControl = loadControl;
+      this.eventListeners = new CopyOnWriteArraySet<>();
+      Looper eventListenerLooper = Looper.myLooper();
+      this.eventListenerHandler = new Handler(eventListenerLooper != null ? eventListenerLooper
+          : Looper.getMainLooper());
+      this.playbackThread = new HandlerThread("FakeExoPlayer Thread");
+      playbackThread.start();
+      this.playbackHandler = new Handler(playbackThread.getLooper());
+      this.isStartingUp = true;
+      this.isLoading = false;
+      this.playbackState = Player.STATE_IDLE;
+      this.durationUs = C.TIME_UNSET;
+    }
+
+    public void setFakeClock(FakeClock clock) {
+      this.clock = clock;
+    }
+
+    @Override
+    public void addListener(Player.EventListener listener) {
+      eventListeners.add(listener);
+    }
+
+    @Override
+    public void removeListener(Player.EventListener listener) {
+      eventListeners.remove(listener);
+    }
+
+    @Override
+    public int getPlaybackState() {
+      return playbackState;
+    }
+
+    @Override
+    public void setPlayWhenReady(boolean playWhenReady) {
+      if (!playWhenReady) {
+        throw new UnsupportedOperationException();
+      }
+    }
+
+    @Override
+    public boolean getPlayWhenReady() {
+      return true;
+    }
+
+    @Override
+    public void setRepeatMode(@RepeatMode int repeatMode) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getRepeatMode() {
+      return Player.REPEAT_MODE_OFF;
+    }
+
+    @Override
+    public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean getShuffleModeEnabled() {
+      return false;
+    }
+
+    @Override
+    public boolean isLoading() {
+      return isLoading;
+    }
+
+    @Override
+    public void seekToDefaultPosition() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void seekToDefaultPosition(int windowIndex) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void seekTo(long positionMs) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void seekTo(int windowIndex, long positionMs) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setPlaybackParameters(@Nullable PlaybackParameters playbackParameters) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PlaybackParameters getPlaybackParameters() {
+      return PlaybackParameters.DEFAULT;
+    }
+
+    @Override
+    public void stop() {
+      playbackHandler.post(new Runnable() {
+        @Override
+        public void run () {
+          playbackHandler.removeCallbacksAndMessages(null);
+          releaseMedia();
+          changePlaybackState(Player.STATE_IDLE);
+        }
+      });
+    }
+
+    @Override
+    @SuppressWarnings("ThreadJoinLoop")
+    public void release() {
+      stop();
+      playbackHandler.post(new Runnable() {
+        @Override
+        public void run () {
+          playbackHandler.removeCallbacksAndMessages(null);
+          playbackThread.quit();
+        }
+      });
+      while (playbackThread.isAlive()) {
+        try {
+          playbackThread.join();
+        } catch (InterruptedException e) {
+          // Ignore interrupt.
+        }
+      }
+    }
+
+    @Override
+    public int getRendererCount() {
+      return renderers.length;
+    }
+
+    @Override
+    public int getRendererType(int index) {
+      return renderers[index].getTrackType();
+    }
+
+    @Override
+    public TrackGroupArray getCurrentTrackGroups() {
+      return selectorResult != null ? selectorResult.groups : null;
+    }
+
+    @Override
+    public TrackSelectionArray getCurrentTrackSelections() {
+      return selectorResult != null ? selectorResult.selections : null;
+    }
+
+    @Nullable
+    @Override
+    public Object getCurrentManifest() {
+      return manifest;
+    }
+
+    @Override
+    public Timeline getCurrentTimeline() {
+      return timeline;
+    }
+
+    @Override
+    public int getCurrentPeriodIndex() {
+      return 0;
+    }
+
+    @Override
+    public int getCurrentWindowIndex() {
+      return 0;
+    }
+
+    @Override
+    public int getNextWindowIndex() {
+      return C.INDEX_UNSET;
+    }
+
+    @Override
+    public int getPreviousWindowIndex() {
+      return C.INDEX_UNSET;
+    }
+
+    @Override
+    public long getDuration() {
+      return C.usToMs(durationUs);
+    }
+
+    @Override
+    public long getCurrentPosition() {
+      return currentPositionMs;
+    }
+
+    @Override
+    public long getBufferedPosition() {
+      return bufferedPositionMs == C.TIME_END_OF_SOURCE ? getDuration() : bufferedPositionMs;
+    }
+
+    @Override
+    public int getBufferedPercentage() {
+      long duration = getDuration();
+      return duration == C.TIME_UNSET ? 0 : (int) (getBufferedPosition() * 100 / duration);
+    }
+
+    @Override
+    public boolean isCurrentWindowDynamic() {
+      return false;
+    }
+
+    @Override
+    public boolean isCurrentWindowSeekable() {
+      return false;
+    }
+
+    @Override
+    public boolean isPlayingAd() {
+      return false;
+    }
+
+    @Override
+    public int getCurrentAdGroupIndex() {
+      return 0;
+    }
+
+    @Override
+    public int getCurrentAdIndexInAdGroup() {
+      return 0;
+    }
+
+    @Override
+    public long getContentPosition() {
+      return getCurrentPosition();
+    }
+
+    @Override
+    public Looper getPlaybackLooper() {
+      return playbackThread.getLooper();
+    }
+
+    @Override
+    public void prepare(MediaSource mediaSource) {
+      prepare(mediaSource, true, true);
+    }
+
+    @Override
+    public void prepare(final MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+      if (!resetPosition || !resetState) {
+        throw new UnsupportedOperationException();
+      }
+      this.mediaSource = mediaSource;
+      playbackHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          mediaSource.prepareSource(FakeExoPlayer.this, true, FakeExoPlayer.this);
+        }
+      });
+    }
+
+    @Override
+    public void sendMessages(ExoPlayerMessage... messages) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void blockingSendMessages(ExoPlayerMessage... messages) {
+      throw new UnsupportedOperationException();
+    }
+
+    // MediaSource.Listener
+
+    @Override
+    public void onSourceInfoRefreshed(MediaSource source, final Timeline timeline,
+        final @Nullable Object manifest) {
+      if (this.timeline != null) {
+        throw new UnsupportedOperationException();
+      }
+      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+      Assertions.checkArgument(timeline.getWindowCount() == 1);
+      final ConditionVariable waitForNotification = new ConditionVariable();
+      eventListenerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          for (Player.EventListener eventListener : eventListeners) {
+            FakeExoPlayer.this.durationUs = timeline.getPeriod(0, new Period()).durationUs;
+            FakeExoPlayer.this.timeline = timeline;
+            FakeExoPlayer.this.manifest = manifest;
+            eventListener.onTimelineChanged(timeline, manifest);
+            waitForNotification.open();
+          }
+        }
+      });
+      waitForNotification.block();
+      this.mediaPeriod = mediaSource.createPeriod(new MediaPeriodId(0), loadControl.getAllocator());
+      mediaPeriod.prepare(this, 0);
+    }
+
+    // MediaPeriod.Callback
+
+    @Override
+    public void onContinueLoadingRequested(MediaPeriod source) {
+      maybeContinueLoading();
+    }
+
+    @Override
+    public void onPrepared(MediaPeriod mediaPeriod) {
+      try {
+        initializePlaybackLoop();
+      } catch (ExoPlaybackException e) {
+        handlePlayerError(e);
+      }
+    }
+
+    // Runnable (Playback loop).
+
+    @Override
+    public void run() {
+      try {
+        maybeContinueLoading();
+        boolean allRenderersEnded = true;
+        boolean allRenderersReadyOrEnded = true;
+        if (playbackState == Player.STATE_READY) {
+          for (Renderer renderer : renderers) {
+            renderer.render(rendererPositionUs, C.msToUs(clock.elapsedRealtime()));
+            if (!renderer.isEnded()) {
+              allRenderersEnded = false;
+            }
+            if (!(renderer.isReady() || renderer.isEnded())) {
+              allRenderersReadyOrEnded = false;
+            }
+          }
+        }
+        if (rendererPositionUs >= durationUs && allRenderersEnded) {
+          changePlaybackState(Player.STATE_ENDED);
+          return;
+        }
+        long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
+        if (playbackState == Player.STATE_BUFFERING && allRenderersReadyOrEnded
+            && haveSufficientBuffer(!isStartingUp, rendererPositionUs, bufferedPositionUs)) {
+          changePlaybackState(Player.STATE_READY);
+          isStartingUp = false;
+        } else if (playbackState == Player.STATE_READY && !allRenderersReadyOrEnded) {
+          changePlaybackState(Player.STATE_BUFFERING);
+        }
+        // Advance simulated time by 10ms.
+        clock.advanceTime(10);
+        if (playbackState == Player.STATE_READY) {
+          rendererPositionUs += 10000;
+        }
+        this.currentPositionMs = C.usToMs(rendererPositionUs);
+        this.bufferedPositionMs = C.usToMs(bufferedPositionUs);
+        playbackHandler.post(this);
+      } catch (ExoPlaybackException e) {
+        handlePlayerError(e);
+      }
+    }
+
+    // Internal logic
+
+    private void initializePlaybackLoop() throws ExoPlaybackException {
+      Assertions.checkNotNull(clock);
+      trackSelector.init(new InvalidationListener() {
+        @Override
+        public void onTrackSelectionsInvalidated() {
+          throw new IllegalStateException();
+        }
+      });
+      RendererCapabilities[] rendererCapabilities = new RendererCapabilities[renderers.length];
+      for (int i = 0; i < renderers.length; i++) {
+        rendererCapabilities[i] = renderers[i].getCapabilities();
+      }
+      selectorResult = trackSelector.selectTracks(rendererCapabilities,
+          mediaPeriod.getTrackGroups());
+      SampleStream[] sampleStreams = new SampleStream[renderers.length];
+      boolean[] mayRetainStreamFlags = new boolean[renderers.length];
+      Arrays.fill(mayRetainStreamFlags, true);
+      mediaPeriod.selectTracks(selectorResult.selections.getAll(), mayRetainStreamFlags,
+          sampleStreams, new boolean[renderers.length], 0);
+      eventListenerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          for (Player.EventListener eventListener : eventListeners) {
+            eventListener.onTracksChanged(selectorResult.groups, selectorResult.selections);
+          }
+        }
+      });
+
+      loadControl.onPrepared();
+      loadControl.onTracksSelected(renderers, selectorResult.groups, selectorResult.selections);
+
+      for (int i = 0; i < renderers.length; i++) {
+        TrackSelection selection = selectorResult.selections.get(i);
+        Format[] formats = new Format[selection.length()];
+        for (int j = 0; j < formats.length; j++) {
+          formats[j] = selection.getFormat(j);
+        }
+        renderers[i].enable(selectorResult.rendererConfigurations[i], formats, sampleStreams[i], 0,
+            false, 0);
+        renderers[i].setCurrentStreamFinal();
+      }
+
+      rendererPositionUs = 0;
+      changePlaybackState(Player.STATE_BUFFERING);
+      playbackHandler.post(this);
+    }
+
+    private void maybeContinueLoading() {
+      boolean newIsLoading = false;
+      long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
+      if (nextLoadPositionUs != C.TIME_END_OF_SOURCE) {
+        long bufferedDurationUs = nextLoadPositionUs - rendererPositionUs;
+        if (loadControl.shouldContinueLoading(bufferedDurationUs)) {
+          newIsLoading = true;
+          mediaPeriod.continueLoading(rendererPositionUs);
+        }
+      }
+      if (newIsLoading != isLoading) {
+        isLoading = newIsLoading;
+        eventListenerHandler.post(new Runnable() {
+          @Override
+          public void run() {
+            for (Player.EventListener eventListener : eventListeners) {
+              eventListener.onLoadingChanged(isLoading);
+            }
+          }
+        });
+      }
+    }
+
+    private boolean haveSufficientBuffer(boolean rebuffering, long rendererPositionUs,
+        long bufferedPositionUs) {
+      if (bufferedPositionUs == C.TIME_END_OF_SOURCE) {
+        return true;
+      }
+      return loadControl.shouldStartPlayback(bufferedPositionUs - rendererPositionUs, rebuffering);
+    }
+
+    private void handlePlayerError(final ExoPlaybackException e) {
+      eventListenerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          for (Player.EventListener listener : eventListeners) {
+            listener.onPlayerError(e);
+          }
+        }
+      });
+      changePlaybackState(Player.STATE_ENDED);
+    }
+
+    private void changePlaybackState(final int playbackState) {
+      this.playbackState = playbackState;
+      eventListenerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          for (Player.EventListener listener : eventListeners) {
+            listener.onPlayerStateChanged(true, playbackState);
+          }
+        }
+      });
+    }
+
+    private void releaseMedia() {
+      if (mediaSource != null) {
+        if (mediaPeriod != null) {
+          mediaSource.releasePeriod(mediaPeriod);
+          mediaPeriod = null;
+        }
+        mediaSource.releaseSource();
+        mediaSource = null;
+      }
+    }
+
+  }
+
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
index 040782264b..2937ee2770 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
 
 /**
  * Fake {@link Timeline} which can be setup to return custom {@link TimelineWindowDefinition}s.
@@ -36,6 +37,8 @@
     public final boolean isSeekable;
     public final boolean isDynamic;
     public final long durationUs;
+    public final int adGroupsPerPeriodCount;
+    public final int adsPerAdGroupCount;
 
     public TimelineWindowDefinition(int periodCount, Object id) {
       this(periodCount, id, true, false, WINDOW_DURATION_US);
@@ -47,15 +50,24 @@ public TimelineWindowDefinition(boolean isSeekable, boolean isDynamic, long dura
 
     public TimelineWindowDefinition(int periodCount, Object id, boolean isSeekable,
         boolean isDynamic, long durationUs) {
+      this(periodCount, id, isSeekable, isDynamic, durationUs, 0, 0);
+    }
+
+    public TimelineWindowDefinition(int periodCount, Object id, boolean isSeekable,
+        boolean isDynamic, long durationUs, int adGroupsCountPerPeriod, int adsPerAdGroupCount) {
       this.periodCount = periodCount;
       this.id = id;
       this.isSeekable = isSeekable;
       this.isDynamic = isDynamic;
       this.durationUs = durationUs;
+      this.adGroupsPerPeriodCount = adGroupsCountPerPeriod;
+      this.adsPerAdGroupCount = adsPerAdGroupCount;
     }
 
   }
 
+  private static final long AD_DURATION_US = 10 * C.MICROS_PER_SECOND;
+
   private final TimelineWindowDefinition[] windowDefinitions;
   private final int[] periodOffsets;
 
@@ -96,7 +108,28 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
     Object id = setIds ? windowPeriodIndex : null;
     Object uid = setIds ? periodIndex : null;
     long periodDurationUs = windowDefinition.durationUs / windowDefinition.periodCount;
-    return period.set(id, uid, windowIndex, periodDurationUs, periodDurationUs * windowPeriodIndex);
+    long positionInWindowUs = periodDurationUs * windowPeriodIndex;
+    if (windowDefinition.adGroupsPerPeriodCount == 0) {
+      return period.set(id, uid, windowIndex, periodDurationUs, positionInWindowUs);
+    } else {
+      int adGroups = windowDefinition.adGroupsPerPeriodCount;
+      long[] adGroupTimesUs = new long[adGroups];
+      int[] adCounts = new int[adGroups];
+      int[] adLoadedAndPlayedCounts = new int[adGroups];
+      long[][] adDurationsUs = new long[adGroups][];
+      long adResumePositionUs = 0;
+      long adGroupOffset = adGroups > 1 ? periodDurationUs / (adGroups - 1) : 0;
+      for (int i = 0; i < adGroups; i++) {
+        adGroupTimesUs[i] = i * adGroupOffset;
+        adCounts[i] = windowDefinition.adsPerAdGroupCount;
+        adLoadedAndPlayedCounts[i] = 0;
+        adDurationsUs[i] = new long[adCounts[i]];
+        Arrays.fill(adDurationsUs[i], AD_DURATION_US);
+      }
+      return period.set(id, uid, windowIndex, periodDurationUs, positionInWindowUs, adGroupTimesUs,
+          adCounts, adLoadedAndPlayedCounts, adLoadedAndPlayedCounts, adDurationsUs,
+          adResumePositionUs);
+    }
   }
 
   @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 831344aa8b..1ef1acd80b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -17,14 +17,12 @@
 
 import static junit.framework.Assert.fail;
 
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.Context;
 import android.net.wifi.WifiManager;
 import android.net.wifi.WifiManager.WifiLock;
 import android.os.Bundle;
 import android.os.ConditionVariable;
-import android.os.Handler;
 import android.os.PowerManager;
 import android.os.PowerManager.WakeLock;
 import android.util.Log;
@@ -57,19 +55,20 @@
     void onStart(HostActivity host, Surface surface);
 
     /**
-     * Called on the main thread to check whether the test is ready to be stopped.
+     * Called on the main thread to block until the test has stopped or {@link #forceStop()} is
+     * called.
      *
-     * @return Whether the test is ready to be stopped.
+     * @param timeoutMs The maximum time to block in milliseconds.
+     * @return Whether the test has stopped successful.
      */
-    boolean canStop();
+    boolean blockUntilStopped(long timeoutMs);
 
     /**
-     * Called on the main thread when the test is stopped.
-     * <p>
-     * The test will be stopped if {@link #canStop()} returns true, if the {@link HostActivity} has
-     * been paused, or if the {@link HostActivity}'s {@link Surface} has been destroyed.
+     * Called on the main thread to force stop the test (if it is not stopped already).
+     *
+     * @return Whether the test was forced stopped.
      */
-    void onStop();
+    boolean forceStop();
 
     /**
      * Called on the test thread after the test has finished and been stopped.
@@ -85,13 +84,11 @@
   private WakeLock wakeLock;
   private WifiLock wifiLock;
   private SurfaceView surfaceView;
-  private Handler mainHandler;
-  private CheckCanStopRunnable checkCanStopRunnable;
 
   private HostedTest hostedTest;
-  private ConditionVariable hostedTestStoppedCondition;
   private boolean hostedTestStarted;
-  private boolean hostedTestFinished;
+  private ConditionVariable hostedTestStartedCondition;
+  private boolean forcedStopped;
 
   /**
    * Executes a {@link HostedTest} inside the host.
@@ -100,7 +97,7 @@
    * @param timeoutMs The number of milliseconds to wait for the test to finish. If the timeout
    *     is exceeded then the test will fail.
    */
-  public void runTest(final HostedTest hostedTest, long timeoutMs) {
+  public void runTest(HostedTest hostedTest, long timeoutMs) {
     runTest(hostedTest, timeoutMs, true);
   }
 
@@ -114,40 +111,46 @@ public void runTest(final HostedTest hostedTest, long timeoutMs) {
   public void runTest(final HostedTest hostedTest, long timeoutMs, boolean failOnTimeout) {
     Assertions.checkArgument(timeoutMs > 0);
     Assertions.checkState(Thread.currentThread() != getMainLooper().getThread());
-
     Assertions.checkState(this.hostedTest == null);
-    this.hostedTest = Assertions.checkNotNull(hostedTest);
-    hostedTestStoppedCondition = new ConditionVariable();
+    Assertions.checkNotNull(hostedTest);
+    hostedTestStartedCondition = new ConditionVariable();
+    forcedStopped = false;
     hostedTestStarted = false;
-    hostedTestFinished = false;
 
     runOnUiThread(new Runnable() {
       @Override
       public void run() {
+        HostActivity.this.hostedTest = hostedTest;
         maybeStartHostedTest();
       }
     });
+    hostedTestStartedCondition.block();
 
-    if (hostedTestStoppedCondition.block(timeoutMs)) {
-      if (hostedTestFinished) {
-        Log.d(TAG, "Test finished. Checking pass conditions.");
+    if (hostedTest.blockUntilStopped(timeoutMs)) {
+      if (!forcedStopped) {
+        Log.d(TAG, "Checking test pass conditions.");
         hostedTest.onFinished();
         Log.d(TAG, "Pass conditions checked.");
       } else {
-        String message = "Test released before it finished. Activity may have been paused whilst "
+        String message = "Test force stopped. Activity may have been paused whilst "
             + "test was in progress.";
         Log.e(TAG, message);
         fail(message);
       }
     } else {
+      runOnUiThread(new Runnable() {
+        @Override
+        public void run() {
+          hostedTest.forceStop();
+        }
+      });
       String message = "Test timed out after " + timeoutMs + " ms.";
       Log.e(TAG, message);
       if (failOnTimeout) {
         fail(message);
       }
-      maybeStopHostedTest();
-      hostedTestStoppedCondition.block();
     }
+    this.hostedTest = null;
   }
 
   // Activity lifecycle
@@ -157,18 +160,16 @@ public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     requestWindowFeature(Window.FEATURE_NO_TITLE);
     setContentView(getResources().getIdentifier("host_activity", "layout", getPackageName()));
-    surfaceView = (SurfaceView) findViewById(
+    surfaceView = findViewById(
         getResources().getIdentifier("surface_view", "id", getPackageName()));
     surfaceView.getHolder().addCallback(this);
-    mainHandler = new Handler();
-    checkCanStopRunnable = new CheckCanStopRunnable();
   }
 
   @Override
   public void onStart() {
     Context appContext = getApplicationContext();
     WifiManager wifiManager = (WifiManager) appContext.getSystemService(Context.WIFI_SERVICE);
-    wifiLock = wifiManager.createWifiLock(getWifiLockMode(), TAG);
+    wifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, TAG);
     wifiLock.acquire();
     PowerManager powerManager = (PowerManager) appContext.getSystemService(Context.POWER_SERVICE);
     wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
@@ -176,21 +177,20 @@ public void onStart() {
     super.onStart();
   }
 
-  @Override
-  public void onResume() {
-    super.onResume();
-    maybeStartHostedTest();
-  }
-
   @Override
   public void onPause() {
     super.onPause();
-    maybeStopHostedTest();
+    if (Util.SDK_INT <= 23) {
+      maybeStopHostedTest();
+    }
   }
 
   @Override
   public void onStop() {
     super.onStop();
+    if (Util.SDK_INT > 23) {
+      maybeStopHostedTest();
+    }
     wakeLock.release();
     wakeLock = null;
     wifiLock.release();
@@ -225,50 +225,14 @@ private void maybeStartHostedTest() {
       hostedTestStarted = true;
       Log.d(TAG, "Starting test.");
       hostedTest.onStart(this, surface);
-      checkCanStopRunnable.startChecking();
+      hostedTestStartedCondition.open();
     }
   }
 
   private void maybeStopHostedTest() {
-    if (hostedTest != null && hostedTestStarted) {
-      hostedTest.onStop();
-      hostedTest = null;
-      mainHandler.removeCallbacks(checkCanStopRunnable);
-      // We post opening of the stopped condition so that any events posted to the main thread as a
-      // result of hostedTest.onStop() are guaranteed to be handled before hostedTest.onFinished()
-      // is called from runTest.
-      mainHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          hostedTestStoppedCondition.open();
-        }
-      });
-    }
-  }
-
-  @SuppressLint("InlinedApi")
-  private static int getWifiLockMode() {
-    return Util.SDK_INT < 12 ? WifiManager.WIFI_MODE_FULL : WifiManager.WIFI_MODE_FULL_HIGH_PERF;
-  }
-
-  private final class CheckCanStopRunnable implements Runnable {
-
-    private static final long CHECK_INTERVAL_MS = 1000;
-
-    private void startChecking() {
-      mainHandler.post(this);
-    }
-
-    @Override
-    public void run() {
-      if (hostedTest.canStop()) {
-        hostedTestFinished = true;
-        maybeStopHostedTest();
-      } else {
-        mainHandler.postDelayed(this, CHECK_INTERVAL_MS);
-      }
+    if (hostedTest != null && hostedTestStarted && !forcedStopped) {
+      forcedStopped = hostedTest.forceStop();
     }
-
   }
 
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/TestData.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
similarity index 99%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/TestData.java
rename to testutils/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
index cef033bf17..88b5de7f65 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/TestData.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
@@ -13,19 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.extractor.ogg;
+package com.google.android.exoplayer2.testutil;
 
-import com.google.android.exoplayer2.testutil.FakeExtractorInput;
-import com.google.android.exoplayer2.testutil.TestUtil;
 
 /**
  * Provides ogg/vorbis test data in bytes for unit tests.
  */
-/* package */ final class TestData {
+public final class OggTestData {
 
-  /* package */ static FakeExtractorInput createInput(byte[] data, boolean simulateUnkownLength) {
+  public static FakeExtractorInput createInput(byte[] data, boolean simulateUnknownLength) {
     return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
-        .setSimulateUnknownLength(simulateUnkownLength).setSimulatePartialReads(true).build();
+        .setSimulateUnknownLength(simulateUnknownLength).setSimulatePartialReads(true).build();
   }
 
   public static byte[] buildOggHeader(int headerType, long granule, int pageSequenceCounter,
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 2e59b33c0b..61d1ecaeea 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.app.Instrumentation;
-import android.test.InstrumentationTestCase;
+import android.content.Context;
 import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
@@ -33,7 +33,6 @@
 import java.util.Arrays;
 import java.util.Random;
 import junit.framework.Assert;
-import org.mockito.MockitoAnnotations;
 
 /**
  * Utility methods for tests.
@@ -121,21 +120,22 @@ public static String buildTestString(int maxLength, Random random) {
     return joined;
   }
 
-  public static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
-    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
-    System.setProperty("dexmaker.dexcache",
-        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
-    MockitoAnnotations.initMocks(instrumentationTestCase);
-  }
-
   public static byte[] getByteArray(Instrumentation instrumentation, String fileName)
       throws IOException {
-    return Util.toByteArray(getInputStream(instrumentation, fileName));
+    return getByteArray(instrumentation.getContext(), fileName);
+  }
+
+  public static byte[] getByteArray(Context context, String fileName) throws IOException {
+    return Util.toByteArray(getInputStream(context, fileName));
   }
 
   public static InputStream getInputStream(Instrumentation instrumentation, String fileName)
       throws IOException {
-    return instrumentation.getContext().getResources().getAssets().open(fileName);
+    return getInputStream(instrumentation.getContext(), fileName);
+  }
+
+  public static InputStream getInputStream(Context context, String fileName) throws IOException {
+    return context.getResources().getAssets().open(fileName);
   }
 
   public static String getString(Instrumentation instrumentation, String fileName)
@@ -150,7 +150,8 @@ public static Timeline extractTimelineFromMediaSource(MediaSource mediaSource) {
     class TimelineListener implements Listener {
       private Timeline timeline;
       @Override
-      public synchronized void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+      public synchronized void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
+          Object manifest) {
         this.timeline = timeline;
         this.notify();
       }
@@ -175,13 +176,15 @@ public synchronized void onSourceInfoRefreshed(Timeline timeline, Object manifes
    * @param dataSource The {@link DataSource} through which to read.
    * @param dataSpec The {@link DataSpec} to use when opening the {@link DataSource}.
    * @param expectedData The expected data.
+   * @param expectKnownLength Whether to assert that {@link DataSource#open} returns the expected
+   *     data length. If false then it's asserted that {@link C#LENGTH_UNSET} is returned.
    * @throws IOException If an error occurs reading fom the {@link DataSource}.
    */
   public static void assertDataSourceContent(DataSource dataSource, DataSpec dataSpec,
-      byte[] expectedData) throws IOException {
+      byte[] expectedData, boolean expectKnownLength) throws IOException {
     try {
       long length = dataSource.open(dataSpec);
-      Assert.assertEquals(expectedData.length, length);
+      Assert.assertEquals(expectKnownLength ? expectedData.length : C.LENGTH_UNSET, length);
       byte[] readData = TestUtil.readToEnd(dataSource);
       MoreAsserts.assertEquals(expectedData, readData);
     } finally {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
index 8357ce70c7..b1df8f62e1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
@@ -16,12 +16,19 @@
 package com.google.android.exoplayer2.testutil;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertTrue;
 
+import android.os.ConditionVariable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaPeriod.Callback;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 
 /**
  * Unit test for {@link Timeline}.
@@ -36,6 +43,10 @@ private TimelineAsserts() {}
   public static void assertEmpty(Timeline timeline) {
     assertWindowIds(timeline);
     assertPeriodCounts(timeline);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      assertEquals(C.INDEX_UNSET, timeline.getFirstWindowIndex(shuffled));
+      assertEquals(C.INDEX_UNSET, timeline.getLastWindowIndex(shuffled));
+    }
   }
 
   /**
@@ -56,7 +67,7 @@ public static void assertWindowIds(Timeline timeline, Object... expectedWindowId
   }
 
   /**
-   * Asserts that window properties {@link Window}.isDynamic are set correctly..
+   * Asserts that window properties {@link Window}.isDynamic are set correctly.
    */
   public static void assertWindowIsDynamic(Timeline timeline, boolean... windowIsDynamic) {
     Window window = new Window();
@@ -67,33 +78,34 @@ public static void assertWindowIsDynamic(Timeline timeline, boolean... windowIsD
   }
 
   /**
-   * Asserts that previous window indices for each window are set correctly depending on the repeat
-   * mode.
+   * Asserts that previous window indices for each window depending on the repeat mode and the
+   * shuffle mode are equal to the given sequence.
    */
   public static void assertPreviousWindowIndices(Timeline timeline,
-      @Player.RepeatMode int repeatMode, int... expectedPreviousWindowIndices) {
+      @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled,
+      int... expectedPreviousWindowIndices) {
     for (int i = 0; i < timeline.getWindowCount(); i++) {
       assertEquals(expectedPreviousWindowIndices[i],
-          timeline.getPreviousWindowIndex(i, repeatMode));
+          timeline.getPreviousWindowIndex(i, repeatMode, shuffleModeEnabled));
     }
   }
 
   /**
-   * Asserts that next window indices for each window are set correctly depending on the repeat
-   * mode.
+   * Asserts that next window indices for each window depending on the repeat mode and the
+   * shuffle mode are equal to the given sequence.
    */
   public static void assertNextWindowIndices(Timeline timeline, @Player.RepeatMode int repeatMode,
-      int... expectedNextWindowIndices) {
+      boolean shuffleModeEnabled, int... expectedNextWindowIndices) {
     for (int i = 0; i < timeline.getWindowCount(); i++) {
       assertEquals(expectedNextWindowIndices[i],
-          timeline.getNextWindowIndex(i, repeatMode));
+          timeline.getNextWindowIndex(i, repeatMode, shuffleModeEnabled));
     }
   }
 
   /**
    * Asserts that period counts for each window are set correctly. Also asserts that
    * {@link Window#firstPeriodIndex} and {@link Window#lastPeriodIndex} are set correctly, and it
-   * asserts the correct behavior of {@link Timeline#getNextWindowIndex(int, int)}.
+   * asserts the correct behavior of {@link Timeline#getNextWindowIndex(int, int, boolean)}.
    */
   public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCounts) {
     int windowCount = timeline.getWindowCount();
@@ -118,31 +130,73 @@ public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCo
         expectedWindowIndex++;
       }
       assertEquals(expectedWindowIndex, period.windowIndex);
-      if (i < accumulatedPeriodCounts[expectedWindowIndex + 1] - 1) {
-        assertEquals(i + 1, timeline.getNextPeriodIndex(i, period, window, Player.REPEAT_MODE_OFF));
-        assertEquals(i + 1, timeline.getNextPeriodIndex(i, period, window, Player.REPEAT_MODE_ONE));
-        assertEquals(i + 1, timeline.getNextPeriodIndex(i, period, window, Player.REPEAT_MODE_ALL));
-      } else {
-        int nextWindowOff = timeline.getNextWindowIndex(expectedWindowIndex,
-            Player.REPEAT_MODE_OFF);
-        int nextWindowOne = timeline.getNextWindowIndex(expectedWindowIndex,
-            Player.REPEAT_MODE_ONE);
-        int nextWindowAll = timeline.getNextWindowIndex(expectedWindowIndex,
-            Player.REPEAT_MODE_ALL);
-        int nextPeriodOff = nextWindowOff == C.INDEX_UNSET ? C.INDEX_UNSET
-            : accumulatedPeriodCounts[nextWindowOff];
-        int nextPeriodOne = nextWindowOne == C.INDEX_UNSET ? C.INDEX_UNSET
-            : accumulatedPeriodCounts[nextWindowOne];
-        int nextPeriodAll = nextWindowAll == C.INDEX_UNSET ? C.INDEX_UNSET
-            : accumulatedPeriodCounts[nextWindowAll];
-        assertEquals(nextPeriodOff, timeline.getNextPeriodIndex(i, period, window,
-            Player.REPEAT_MODE_OFF));
-        assertEquals(nextPeriodOne, timeline.getNextPeriodIndex(i, period, window,
-            Player.REPEAT_MODE_ONE));
-        assertEquals(nextPeriodAll, timeline.getNextPeriodIndex(i, period, window,
-            Player.REPEAT_MODE_ALL));
+      assertEquals(i, timeline.getIndexOfPeriod(period.uid));
+      for (@Player.RepeatMode int repeatMode
+          : new int[] {Player.REPEAT_MODE_OFF, Player.REPEAT_MODE_ONE, Player.REPEAT_MODE_ALL}) {
+        if (i < accumulatedPeriodCounts[expectedWindowIndex + 1] - 1) {
+          assertEquals(i + 1, timeline.getNextPeriodIndex(i, period, window, repeatMode, false));
+        } else {
+          int nextWindow = timeline.getNextWindowIndex(expectedWindowIndex, repeatMode, false);
+          int nextPeriod = nextWindow == C.INDEX_UNSET ? C.INDEX_UNSET
+              : accumulatedPeriodCounts[nextWindow];
+          assertEquals(nextPeriod, timeline.getNextPeriodIndex(i, period, window, repeatMode,
+              false));
+        }
+      }
+    }
+  }
+
+  /**
+   * Asserts that periods' {@link Period#getAdGroupCount()} are set correctly.
+   */
+  public static void assertAdGroupCounts(Timeline timeline, int... expectedAdGroupCounts) {
+    Period period = new Period();
+    for (int i = 0; i < timeline.getPeriodCount(); i++) {
+      timeline.getPeriod(i, period);
+      assertEquals(expectedAdGroupCounts[i], period.getAdGroupCount());
+    }
+  }
+
+  /**
+   * Asserts that all period (including ad periods) can be created from the source, prepared, and
+   * released without exception and within timeout.
+   */
+  public static void assertAllPeriodsCanBeCreatedPreparedAndReleased(MediaSource mediaSource,
+      Timeline timeline, long timeoutMs) {
+    Period period = new Period();
+    for (int i = 0; i < timeline.getPeriodCount(); i++) {
+      assertPeriodCanBeCreatedPreparedAndReleased(mediaSource, new MediaPeriodId(i), timeoutMs);
+      timeline.getPeriod(i, period);
+      for (int adGroupIndex = 0; adGroupIndex < period.getAdGroupCount(); adGroupIndex++) {
+        for (int adIndex = 0; adIndex < period.getAdCountInAdGroup(adGroupIndex); adIndex++) {
+          assertPeriodCanBeCreatedPreparedAndReleased(mediaSource,
+              new MediaPeriodId(i, adGroupIndex, adIndex), timeoutMs);
+        }
       }
     }
   }
 
+  private static void assertPeriodCanBeCreatedPreparedAndReleased(MediaSource mediaSource,
+      MediaPeriodId mediaPeriodId, long timeoutMs) {
+    MediaPeriod mediaPeriod = mediaSource.createPeriod(mediaPeriodId, null);
+    assertNotNull(mediaPeriod);
+    final ConditionVariable mediaPeriodPrepared = new ConditionVariable();
+    mediaPeriod.prepare(new Callback() {
+      @Override
+      public void onPrepared(MediaPeriod mediaPeriod) {
+        mediaPeriodPrepared.open();
+      }
+      @Override
+      public void onContinueLoadingRequested(MediaPeriod source) {}
+    }, /* positionUs= */ 0);
+    assertTrue(mediaPeriodPrepared.block(timeoutMs));
+    // MediaSource is supposed to support multiple calls to createPeriod with the same id without an
+    // intervening call to releasePeriod.
+    MediaPeriod secondMediaPeriod = mediaSource.createPeriod(mediaPeriodId, null);
+    assertNotNull(secondMediaPeriod);
+    mediaSource.releasePeriod(secondMediaPeriod);
+    mediaSource.releasePeriod(mediaPeriod);
+  }
+
 }
+
