diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 4ab2bacc07..83e0e6675e 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -91,12 +91,13 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     ParsableByteArray stsz = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
 
     // Entries are byte offsets of chunks.
-    ParsableByteArray chunkOffsets;
+    boolean chunkOffsetsAreLongs = false;
     Atom.LeafAtom chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stco);
     if (chunkOffsetsAtom == null) {
+      chunkOffsetsAreLongs = true;
       chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_co64);
     }
-    chunkOffsets = chunkOffsetsAtom.data;
+    ParsableByteArray chunkOffsets = chunkOffsetsAtom.data;
     // Entries are (chunk number, number of samples per chunk, sample description index).
     ParsableByteArray stsc = stblAtom.getLeafAtomOfType(Atom.TYPE_stsc).data;
     // Entries are (number of samples, timestamp delta between those samples).
@@ -112,28 +113,12 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     stsz.setPosition(Atom.FULL_HEADER_SIZE);
     int fixedSampleSize = stsz.readUnsignedIntToInt();
     int sampleCount = stsz.readUnsignedIntToInt();
-
     if (sampleCount == 0) {
       return new TrackSampleTable(new long[0], new int[0], 0, new long[0], new int[0]);
     }
 
-    // Prepare to read chunk offsets.
-    chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
-    int chunkCount = chunkOffsets.readUnsignedIntToInt();
-
-    stsc.setPosition(Atom.FULL_HEADER_SIZE);
-    int remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt() - 1;
-    Assertions.checkState(stsc.readInt() == 1, "stsc first chunk must be 1");
-    int samplesPerChunk = stsc.readUnsignedIntToInt();
-    stsc.skipBytes(4); // Skip the sample description index.
-    int nextSamplesPerChunkChangeChunkIndex = -1;
-    if (remainingSamplesPerChunkChanges > 0) {
-      // Store the chunk index when the samples-per-chunk will next change.
-      nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
-    }
-
-    int chunkIndex = 0;
-    int remainingSamplesInChunk = samplesPerChunk;
+    // Prepare to read chunk information.
+    ChunkIterator chunkIterator = new ChunkIterator(stsc, chunkOffsets, chunkOffsetsAreLongs);
 
     // Prepare to read sample timestamps.
     stts.setPosition(Atom.FULL_HEADER_SIZE);
@@ -158,45 +143,37 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
     }
 
-    // Calculate the chunk offsets.
-    long offsetBytes;
-    if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
-      offsetBytes = chunkOffsets.readUnsignedInt();
-    } else {
-      offsetBytes = chunkOffsets.readUnsignedLongToLong();
-    }
-
     // True if we can rechunk fixed-sample-size data. Note that we only rechunk raw audio.
     boolean isRechunkable =
         fixedSampleSize != 0
-            && MimeTypes.AUDIO_RAW.equals(track.mediaFormat.mimeType)
-            && remainingTimestampDeltaChanges == 0
-            && remainingTimestampOffsetChanges == 0
-            && remainingSynchronizationSamples == 0;
+        && MimeTypes.AUDIO_RAW.equals(track.mediaFormat.mimeType)
+        && remainingTimestampDeltaChanges == 0
+        && remainingTimestampOffsetChanges == 0
+        && remainingSynchronizationSamples == 0;
 
-    long[] offsets = null;
-    int[] sizes = null;
+    long[] offsets;
+    int[] sizes;
     int maximumSize = 0;
-    long[] timestamps = null;
-    int[] flags = null;
-    // If we're rechunking fixed sample size data, we must store chunk offset and sample counts.
-    long[] chunkOffsetsBytes = null;
-    int[] chunkSampleCounts = null;
-    if (isRechunkable) {
-      chunkOffsetsBytes = new long[chunkCount];
-      chunkSampleCounts = new int[chunkCount];
-    } else {
+    long[] timestamps;
+    int[] flags;
+
+    if (!isRechunkable) {
       offsets = new long[sampleCount];
       sizes = new int[sampleCount];
       timestamps = new long[sampleCount];
       flags = new int[sampleCount];
-    }
+      long timestampTimeUnits = 0;
+      long offset = 0;
+      int remainingSamplesInChunk = 0;
+
+      for (int i = 0; i < sampleCount; i++) {
+        // Advance to the next chunk if necessary.
+        while (remainingSamplesInChunk == 0) {
+          Assertions.checkState(chunkIterator.moveNext());
+          offset = chunkIterator.offset;
+          remainingSamplesInChunk = chunkIterator.numSamples;
+        }
 
-    long timestampTimeUnits = 0;
-    int remainingSamples = sampleCount;
-    while (remainingSamples > 0) {
-      int i = sampleCount - remainingSamples;
-      if (!isRechunkable) {
         // Add on the timestamp offset if ctts is present.
         if (ctts != null) {
           while (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
@@ -212,7 +189,7 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
           remainingSamplesAtTimestampOffset--;
         }
 
-        offsets[i] = offsetBytes;
+        offsets[i] = offset;
         sizes[i] = fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
         if (sizes[i] > maximumSize) {
           maximumSize = sizes[i];
@@ -237,58 +214,26 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
           timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
           remainingTimestampDeltaChanges--;
         }
-        remainingSamplesInChunk--;
-        remainingSamples--;
-      } else {
-        // Store the latest chunk offset and sample count.
-        chunkOffsetsBytes[chunkIndex] = offsetBytes;
-        chunkSampleCounts[chunkIndex] = samplesPerChunk;
 
-        remainingSamplesAtTimestampDelta -= samplesPerChunk;
-        remainingSamplesInChunk -= samplesPerChunk;
-        remainingSamples -= samplesPerChunk;
+        offset += sizes[i];
+        remainingSamplesInChunk--;
       }
 
-      // If we're at the last sample in this chunk, move to the next chunk.
-      if (remainingSamplesInChunk == 0) {
-        chunkIndex++;
-        if (chunkIndex < chunkCount) {
-          if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
-            offsetBytes = chunkOffsets.readUnsignedInt();
-          } else {
-            offsetBytes = chunkOffsets.readUnsignedLongToLong();
-          }
-
-          // Change the samples-per-chunk if required.
-          if (chunkIndex == nextSamplesPerChunkChangeChunkIndex) {
-            samplesPerChunk = stsc.readUnsignedIntToInt();
-            stsc.skipBytes(4); // Skip the sample description index.
-            remainingSamplesPerChunkChanges--;
-            if (remainingSamplesPerChunkChanges > 0) {
-              nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
-            }
-          }
-
-          // Expect samplesPerChunk samples in the following chunk.
-          remainingSamplesInChunk = samplesPerChunk;
-        }
-      } else {
-        // The next sample follows the current one.
-        offsetBytes += sizes[i];
+      // Check all the expected samples have been seen.
+      Assertions.checkArgument(remainingSynchronizationSamples == 0);
+      Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
+      Assertions.checkArgument(remainingSamplesInChunk == 0);
+      Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
+      Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
+    } else {
+      long[] chunkOffsetsBytes = new long[chunkIterator.length];
+      int[] chunkSampleCounts = new int[chunkIterator.length];
+      while (chunkIterator.moveNext()) {
+        chunkOffsetsBytes[chunkIterator.index] = chunkIterator.offset;
+        chunkSampleCounts[chunkIterator.index] = chunkIterator.numSamples;
       }
-    }
-
-    // Check all the expected samples have been seen.
-    Assertions.checkArgument(remainingSynchronizationSamples == 0);
-    Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
-    Assertions.checkArgument(remainingSamplesInChunk == 0);
-    Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
-    Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
-
-    if (isRechunkable) {
-      FixedSampleSizeRechunker.Results rechunkedResults =
-          FixedSampleSizeRechunker.rechunk(
-              fixedSampleSize, chunkOffsetsBytes, chunkSampleCounts, timestampDeltaInTimeUnits);
+      FixedSampleSizeRechunker.Results rechunkedResults = FixedSampleSizeRechunker.rechunk(
+          fixedSampleSize, chunkOffsetsBytes, chunkSampleCounts, timestampDeltaInTimeUnits);
       offsets = rechunkedResults.offsets;
       sizes = rechunkedResults.sizes;
       maximumSize = rechunkedResults.maximumSize;
@@ -1076,6 +1021,51 @@ private AtomParsers() {
     // Prevent instantiation.
   }
 
+  private static final class ChunkIterator {
+
+    public final int length;
+
+    public int index;
+    public int numSamples;
+    public long offset;
+
+    private final boolean chunkOffsetsAreLongs;
+    private final ParsableByteArray chunkOffsets;
+    private final ParsableByteArray stsc;
+
+    private int nextSamplesPerChunkChangeIndex;
+    private int remainingSamplesPerChunkChanges;
+
+    public ChunkIterator(ParsableByteArray stsc, ParsableByteArray chunkOffsets,
+        boolean chunkOffsetsAreLongs) {
+      this.stsc = stsc;
+      this.chunkOffsets = chunkOffsets;
+      this.chunkOffsetsAreLongs = chunkOffsetsAreLongs;
+      chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
+      length = chunkOffsets.readUnsignedIntToInt();
+      stsc.setPosition(Atom.FULL_HEADER_SIZE);
+      remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt();
+      Assertions.checkState(stsc.readInt() == 1, "first_chunk must be 1");
+      index = -1;
+    }
+
+    public boolean moveNext() {
+      if (++index == length) {
+        return false;
+      }
+      offset = chunkOffsetsAreLongs ? chunkOffsets.readUnsignedLongToLong()
+          : chunkOffsets.readUnsignedInt();
+      if (index == nextSamplesPerChunkChangeIndex) {
+        numSamples = stsc.readUnsignedIntToInt();
+        stsc.skipBytes(4); // Skip sample_description_index
+        nextSamplesPerChunkChangeIndex = --remainingSamplesPerChunkChanges > 0
+            ? (stsc.readUnsignedIntToInt() - 1) : -1;
+      }
+      return true;
+    }
+
+  }
+
   /**
    * Holds data parsed from a tkhd atom.
    */
