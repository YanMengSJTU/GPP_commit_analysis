diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 5f7d5bea9c..41613f9cde 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -2,6 +2,9 @@
 
 ### dev-v2 (not yet released) ###
 
+* Surface information provided by methods `isHardwareAccelerated`,
+  `isSoftwareOnly` and `isVendor` added in Android Q in `MediaCodecInfo` class
+  ([#5839](https://github.com/google/ExoPlayer/issues/5839)).
 * Update `DefaultTrackSelector` to apply a viewport constraint for the default
   display by default.
 * Add `PlaybackStatsListener` to collect `PlaybackStats` for playbacks analysis
@@ -46,6 +49,8 @@
   postroll ad ([#6314](https://github.com/google/ExoPlayer/issues/6314)).
 * Fix audio selection issue where languages are compared by bit rate
   ([#6335](https://github.com/google/ExoPlayer/issues/6335)).
+* Add `HttpDataSource.getResponseCode` to provide the status code associated
+  with the most recent HTTP response.
 
 ### 2.10.4 ###
 
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
index d6fe6e2dc1..f92662f284 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
@@ -20,7 +20,6 @@
 import android.content.res.Resources;
 import android.os.Bundle;
 import androidx.annotation.Nullable;
-import com.google.android.material.tabs.TabLayout;
 import androidx.fragment.app.DialogFragment;
 import androidx.fragment.app.Fragment;
 import androidx.fragment.app.FragmentManager;
@@ -39,6 +38,7 @@
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.ui.TrackSelectionView;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.material.tabs.TabLayout;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index ed92523017..bff1672e62 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -392,6 +392,13 @@ public void clearAllRequestProperties() {
     requestProperties.clear();
   }
 
+  @Override
+  public int getResponseCode() {
+    return responseInfo == null || responseInfo.getHttpStatusCode() <= 0
+        ? -1
+        : responseInfo.getHttpStatusCode();
+  }
+
   @Override
   public Map<String, List<String>> getResponseHeaders() {
     return responseInfo == null ? Collections.emptyMap() : responseInfo.getAllHeaders();
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 791feabae9..da3cf33fb4 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -172,6 +172,11 @@ public Uri getUri() {
     return response == null ? null : Uri.parse(response.request().url().toString());
   }
 
+  @Override
+  public int getResponseCode() {
+    return response == null ? -1 : response.code();
+  }
+
   @Override
   public Map<String, List<String>> getResponseHeaders() {
     return response == null ? Collections.emptyMap() : response.headers().toMultimap();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
index c83214c8d5..6a65209841 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
@@ -28,10 +28,13 @@
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.EventDispatcher;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
@@ -47,6 +50,14 @@
 @TargetApi(18)
 public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T> {
 
+  /** Thrown when an unexpected exception or error is thrown during provisioning or key requests. */
+  public static final class UnexpectedDrmSessionException extends IOException {
+
+    public UnexpectedDrmSessionException(Throwable cause) {
+      super("Unexpected " + cause.getClass().getSimpleName() + ": " + cause.getMessage(), cause);
+    }
+  }
+
   /** Manages provisioning requests. */
   public interface ProvisioningManager<T extends ExoMediaCrypto> {
 
@@ -97,7 +108,7 @@
   private final @DefaultDrmSessionManager.Mode int mode;
   @Nullable private final HashMap<String, String> optionalKeyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
-  private final int initialDrmRequestRetryCount;
+  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
 
   /* package */ final MediaDrmCallback callback;
   /* package */ final UUID uuid;
@@ -164,8 +175,10 @@ public DefaultDrmSession(
     }
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.callback = callback;
-    this.initialDrmRequestRetryCount = initialDrmRequestRetryCount;
     this.eventDispatcher = eventDispatcher;
+    loadErrorHandlingPolicy =
+        new DefaultLoadErrorHandlingPolicy(
+            /* minimumLoadableRetryCount= */ initialDrmRequestRetryCount);
     state = STATE_OPENING;
     postResponseHandler = new PostResponseHandler(playbackLooper);
   }
@@ -531,7 +544,7 @@ public void handleMessage(Message msg) {
             throw new RuntimeException();
         }
       } catch (Exception e) {
-        if (maybeRetryRequest(msg)) {
+        if (maybeRetryRequest(msg, e)) {
           return;
         }
         response = e;
@@ -539,23 +552,27 @@ public void handleMessage(Message msg) {
       postResponseHandler.obtainMessage(msg.what, Pair.create(request, response)).sendToTarget();
     }
 
-    private boolean maybeRetryRequest(Message originalMsg) {
+    private boolean maybeRetryRequest(Message originalMsg, Exception e) {
       boolean allowRetry = originalMsg.arg1 == 1;
       if (!allowRetry) {
         return false;
       }
       int errorCount = originalMsg.arg2 + 1;
-      if (errorCount > initialDrmRequestRetryCount) {
+      if (errorCount > loadErrorHandlingPolicy.getMinimumLoadableRetryCount(C.DATA_TYPE_DRM)) {
         return false;
       }
       Message retryMsg = Message.obtain(originalMsg);
       retryMsg.arg2 = errorCount;
-      sendMessageDelayed(retryMsg, getRetryDelayMillis(errorCount));
-      return true;
-    }
 
-    private long getRetryDelayMillis(int errorCount) {
-      return Math.min((errorCount - 1) * 1000, 5000);
+      IOException ioException =
+          e instanceof IOException ? (IOException) e : new UnexpectedDrmSessionException(e);
+      // TODO: Add loadDurationMs calculation before allowing user-provided load error handling
+      // policies.
+      long retryDelayMs =
+          loadErrorHandlingPolicy.getRetryDelayMsFor(
+              C.DATA_TYPE_DRM, /* loadDurationMs= */ C.TIME_UNSET, ioException, errorCount);
+      sendMessageDelayed(retryMsg, retryDelayMs);
+      return true;
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index c700259b13..6dcbf896c9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -93,6 +93,33 @@
   /** Whether this instance describes a passthrough codec. */
   public final boolean passthrough;
 
+  /**
+   * Whether the codec is hardware accelerated.
+   *
+   * <p>This could be an approximation as the exact information is only provided in API levels 29+.
+   *
+   * @see android.media.MediaCodecInfo#isHardwareAccelerated()
+   */
+  public final boolean hardwareAccelerated;
+
+  /**
+   * Whether the codec is software only.
+   *
+   * <p>This could be an approximation as the exact information is only provided in API levels 29+.
+   *
+   * @see android.media.MediaCodecInfo#isSoftwareOnly()
+   */
+  public final boolean softwareOnly;
+
+  /**
+   * Whether the codec is from the vendor.
+   *
+   * <p>This could be an approximation as the exact information is only provided in API levels 29+.
+   *
+   * @see android.media.MediaCodecInfo#isVendor()
+   */
+  public final boolean vendor;
+
   private final boolean isVideo;
 
   /**
@@ -108,6 +135,9 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
         /* codecMimeType= */ null,
         /* capabilities= */ null,
         /* passthrough= */ true,
+        /* hardwareAccelerated= */ false,
+        /* softwareOnly= */ true,
+        /* vendor= */ false,
         /* forceDisableAdaptive= */ false,
         /* forceSecure= */ false);
   }
@@ -121,6 +151,9 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
    *     Equal to {@code mimeType} unless the codec is known to use a non-standard MIME type alias.
    * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type, or
    *     {@code null} if not known.
+   * @param hardwareAccelerated Whether the {@link MediaCodec} is hardware accelerated.
+   * @param softwareOnly Whether the {@link MediaCodec} is software only.
+   * @param vendor Whether the {@link MediaCodec} is provided by the vendor.
    * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
    * @param forceSecure Whether {@link #secure} should be forced to {@code true}.
    * @return The created instance.
@@ -130,6 +163,9 @@ public static MediaCodecInfo newInstance(
       String mimeType,
       String codecMimeType,
       @Nullable CodecCapabilities capabilities,
+      boolean hardwareAccelerated,
+      boolean softwareOnly,
+      boolean vendor,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     return new MediaCodecInfo(
@@ -138,6 +174,9 @@ public static MediaCodecInfo newInstance(
         codecMimeType,
         capabilities,
         /* passthrough= */ false,
+        hardwareAccelerated,
+        softwareOnly,
+        vendor,
         forceDisableAdaptive,
         forceSecure);
   }
@@ -148,6 +187,9 @@ private MediaCodecInfo(
       @Nullable String codecMimeType,
       @Nullable CodecCapabilities capabilities,
       boolean passthrough,
+      boolean hardwareAccelerated,
+      boolean softwareOnly,
+      boolean vendor,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     this.name = Assertions.checkNotNull(name);
@@ -155,6 +197,9 @@ private MediaCodecInfo(
     this.codecMimeType = codecMimeType;
     this.capabilities = capabilities;
     this.passthrough = passthrough;
+    this.hardwareAccelerated = hardwareAccelerated;
+    this.softwareOnly = softwareOnly;
+    this.vendor = vendor;
     adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
     tunneling = capabilities != null && isTunneling(capabilities);
     secure = forceSecure || (capabilities != null && isSecure(capabilities));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 9c42916cad..966e9fecc2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -312,6 +312,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
           if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {
             continue;
           }
+          boolean hardwareAccelerated = isHardwareAccelerated(codecInfo);
+          boolean softwareOnly = isSoftwareOnly(codecInfo);
+          boolean vendor = isVendor(codecInfo);
           boolean forceDisableAdaptive = codecNeedsDisableAdaptationWorkaround(name);
           if ((secureDecodersExplicit && key.secure == secureSupported)
               || (!secureDecodersExplicit && !key.secure)) {
@@ -321,6 +324,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
                     mimeType,
                     codecMimeType,
                     capabilities,
+                    hardwareAccelerated,
+                    softwareOnly,
+                    vendor,
                     forceDisableAdaptive,
                     /* forceSecure= */ false));
           } else if (!secureDecodersExplicit && secureSupported) {
@@ -330,6 +336,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
                     mimeType,
                     codecMimeType,
                     capabilities,
+                    hardwareAccelerated,
+                    softwareOnly,
+                    vendor,
                     forceDisableAdaptive,
                     /* forceSecure= */ true));
             // It only makes sense to have one synthesized secure decoder, return immediately.
@@ -532,6 +541,9 @@ private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decod
                 /* mimeType= */ MimeTypes.AUDIO_RAW,
                 /* codecMimeType= */ MimeTypes.AUDIO_RAW,
                 /* capabilities= */ null,
+                /* hardwareAccelerated= */ false,
+                /* softwareOnly= */ true,
+                /* vendor= */ false,
                 /* forceDisableAdaptive= */ false,
                 /* forceSecure= */ false));
       }
@@ -565,6 +577,69 @@ private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decod
     }
   }
 
+  /**
+   * The result of {@link android.media.MediaCodecInfo#isHardwareAccelerated()} for API levels 29+,
+   * or a best-effort approximation for lower levels.
+   */
+  private static boolean isHardwareAccelerated(android.media.MediaCodecInfo codecInfo) {
+    if (Util.SDK_INT >= 29) {
+      return isHardwareAcceleratedV29(codecInfo);
+    }
+    // codecInfo.isHardwareAccelerated() != codecInfo.isSoftwareOnly() is not necessarily true.
+    // However, we assume this to be true as an approximation.
+    return !isSoftwareOnly(codecInfo);
+  }
+
+  @TargetApi(29)
+  private static boolean isHardwareAcceleratedV29(android.media.MediaCodecInfo codecInfo) {
+    return codecInfo.isHardwareAccelerated();
+  }
+
+  /**
+   * The result of {@link android.media.MediaCodecInfo#isSoftwareOnly()} for API levels 29+, or a
+   * best-effort approximation for lower levels.
+   */
+  private static boolean isSoftwareOnly(android.media.MediaCodecInfo codecInfo) {
+    if (Util.SDK_INT >= 29) {
+      return isSoftwareOnlyV29(codecInfo);
+    }
+    String codecName = codecInfo.getName().toLowerCase();
+    if (codecName.startsWith("arc.")) { // App Runtime for Chrome (ARC) codecs
+      return false;
+    }
+    return codecName.startsWith("omx.google.")
+        || codecName.startsWith("omx.ffmpeg.")
+        || (codecName.startsWith("omx.sec.") && codecName.contains(".sw."))
+        || codecName.equals("omx.qcom.video.decoder.hevcswvdec")
+        || codecName.startsWith("c2.android.")
+        || codecName.startsWith("c2.google.")
+        || (!codecName.startsWith("omx.") && !codecName.startsWith("c2."));
+  }
+
+  @TargetApi(29)
+  private static boolean isSoftwareOnlyV29(android.media.MediaCodecInfo codecInfo) {
+    return codecInfo.isSoftwareOnly();
+  }
+
+  /**
+   * The result of {@link android.media.MediaCodecInfo#isVendor()} for API levels 29+, or a
+   * best-effort approximation for lower levels.
+   */
+  private static boolean isVendor(android.media.MediaCodecInfo codecInfo) {
+    if (Util.SDK_INT >= 29) {
+      return isVendorV29(codecInfo);
+    }
+    String codecName = codecInfo.getName().toLowerCase();
+    return !codecName.startsWith("omx.google.")
+        && !codecName.startsWith("c2.android.")
+        && !codecName.startsWith("c2.google.");
+  }
+
+  @TargetApi(29)
+  private static boolean isVendorV29(android.media.MediaCodecInfo codecInfo) {
+    return codecInfo.isVendor();
+  }
+
   /**
    * Returns whether the decoder is known to fail when adapting, despite advertising itself as an
    * adaptive decoder.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
index 38b373b26c..c36e62db86 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
@@ -61,6 +61,12 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
     return timeline.getWindow(windowIndex, window, defaultPositionProjectionUs);
   }
 
+  @Override
+  public final Window getWindow(
+      int windowIndex, Window window, boolean setIds, long defaultPositionProjectionUs) {
+    return getWindow(windowIndex, window, defaultPositionProjectionUs);
+  }
+
   @Override
   public int getPeriodCount() {
     return timeline.getPeriodCount();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index 6e7b19936f..f297bb468e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -24,6 +24,9 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Defines a region of data.
@@ -100,9 +103,10 @@
    */
   @Nullable public final byte[] httpBody;
 
-  /**
-   * The absolute position of the data in the full stream.
-   */
+  /** Immutable map containing the headers to use in HTTP requests. */
+  public final Map<String, String> httpRequestHeaders;
+
+  /** The absolute position of the data in the full stream. */
   public final long absoluteStreamPosition;
   /**
    * The position of the data when read from {@link #uri}.
@@ -233,7 +237,6 @@ public DataSpec(
    * @param key {@link #key}.
    * @param flags {@link #flags}.
    */
-  @SuppressWarnings("deprecation")
   public DataSpec(
       Uri uri,
       @HttpMethod int httpMethod,
@@ -243,6 +246,41 @@ public DataSpec(
       long length,
       @Nullable String key,
       @Flags int flags) {
+    this(
+        uri,
+        httpMethod,
+        httpBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags,
+        /* httpRequestHeaders= */ Collections.emptyMap());
+  }
+
+  /**
+   * Construct a data spec with request parameters to be used as HTTP headers inside HTTP requests.
+   *
+   * @param uri {@link #uri}.
+   * @param httpMethod {@link #httpMethod}.
+   * @param httpBody {@link #httpBody}.
+   * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
+   * @param position {@link #position}.
+   * @param length {@link #length}.
+   * @param key {@link #key}.
+   * @param flags {@link #flags}.
+   * @param httpRequestHeaders {@link #httpRequestHeaders}.
+   */
+  public DataSpec(
+      Uri uri,
+      @HttpMethod int httpMethod,
+      @Nullable byte[] httpBody,
+      long absoluteStreamPosition,
+      long position,
+      long length,
+      @Nullable String key,
+      @Flags int flags,
+      Map<String, String> httpRequestHeaders) {
     Assertions.checkArgument(absoluteStreamPosition >= 0);
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNSET);
@@ -254,6 +292,7 @@ public DataSpec(
     this.length = length;
     this.key = key;
     this.flags = flags;
+    this.httpRequestHeaders = Collections.unmodifiableMap(new HashMap<>(httpRequestHeaders));
   }
 
   /**
@@ -341,7 +380,8 @@ public DataSpec subrange(long offset, long length) {
           position + offset,
           length,
           key,
-          flags);
+          flags,
+          httpRequestHeaders);
     }
   }
 
@@ -353,6 +393,14 @@ public DataSpec subrange(long offset, long length) {
    */
   public DataSpec withUri(Uri uri) {
     return new DataSpec(
-        uri, httpMethod, httpBody, absoluteStreamPosition, position, length, key, flags);
+        uri,
+        httpMethod,
+        httpBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags,
+        httpRequestHeaders);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 3ee1ef7564..f38b0709f9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
@@ -36,6 +37,7 @@
 import java.net.ProtocolException;
 import java.net.URL;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -53,9 +55,7 @@
  */
 public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSource {
 
-  /**
-   * The default connection timeout, in milliseconds.
-   */
+  /** The default connection timeout, in milliseconds. */
   public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
   /**
    * The default read timeout, in milliseconds.
@@ -83,6 +83,7 @@
   @Nullable private HttpURLConnection connection;
   @Nullable private InputStream inputStream;
   private boolean opened;
+  private int responseCode;
 
   private long bytesToSkip;
   private long bytesToRead;
@@ -234,6 +235,11 @@ public Uri getUri() {
     return connection == null ? null : Uri.parse(connection.getURL().toString());
   }
 
+  @Override
+  public int getResponseCode() {
+    return connection == null || responseCode <= 0 ? -1 : responseCode;
+  }
+
   @Override
   public Map<String, List<String>> getResponseHeaders() {
     return connection == null ? Collections.emptyMap() : connection.getHeaderFields();
@@ -257,6 +263,13 @@ public void clearAllRequestProperties() {
     requestProperties.clear();
   }
 
+  /**
+   * Opens the source to read the specified data.
+   *
+   * <p>Note: HTTP request headers will be set using parameters passed via (in order of decreasing
+   * priority) the {@code dataSpec}, {@link #setRequestProperty} and the default parameters used to
+   * construct the instance.
+   */
   @Override
   public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.dataSpec = dataSpec;
@@ -270,7 +283,6 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
           dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
-    int responseCode;
     String responseMessage;
     try {
       responseCode = connection.getResponseCode();
@@ -369,6 +381,13 @@ public void close() throws HttpDataSourceException {
     }
   }
 
+  /** Creates an {@link HttpURLConnection} that is connected with the {@code url}. */
+  @VisibleForTesting
+  /* package */
+  HttpURLConnection openConnection(URL url) throws IOException {
+    return (HttpURLConnection) url.openConnection();
+  }
+
   /**
    * Returns the current connection, or null if the source is not currently opened.
    *
@@ -433,7 +452,8 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
           length,
           allowGzip,
           allowIcyMetadata,
-          /* followRedirects= */ true);
+          /* followRedirects= */ true,
+          dataSpec.httpRequestHeaders);
     }
 
     // We need to handle redirects ourselves to allow cross-protocol redirects.
@@ -448,7 +468,8 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
               length,
               allowGzip,
               allowIcyMetadata,
-              /* followRedirects= */ false);
+              /* followRedirects= */ false,
+              dataSpec.httpRequestHeaders);
       int responseCode = connection.getResponseCode();
       String location = connection.getHeaderField("Location");
       if ((httpMethod == DataSpec.HTTP_METHOD_GET || httpMethod == DataSpec.HTTP_METHOD_HEAD)
@@ -490,6 +511,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
    * @param allowGzip Whether to allow the use of gzip.
    * @param allowIcyMetadata Whether to allow ICY metadata.
    * @param followRedirects Whether to follow redirects.
+   * @param requestParameters parameters (HTTP headers) to include in request.
    */
   private HttpURLConnection makeConnection(
       URL url,
@@ -499,19 +521,24 @@ private HttpURLConnection makeConnection(
       long length,
       boolean allowGzip,
       boolean allowIcyMetadata,
-      boolean followRedirects)
+      boolean followRedirects,
+      Map<String, String> requestParameters)
       throws IOException {
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    HttpURLConnection connection = openConnection(url);
     connection.setConnectTimeout(connectTimeoutMillis);
     connection.setReadTimeout(readTimeoutMillis);
+
+    Map<String, String> requestHeaders = new HashMap<>();
     if (defaultRequestProperties != null) {
-      for (Map.Entry<String, String> property : defaultRequestProperties.getSnapshot().entrySet()) {
-        connection.setRequestProperty(property.getKey(), property.getValue());
-      }
+      requestHeaders.putAll(defaultRequestProperties.getSnapshot());
     }
-    for (Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {
+    requestHeaders.putAll(requestProperties.getSnapshot());
+    requestHeaders.putAll(requestParameters);
+
+    for (Map.Entry<String, String> property : requestHeaders.entrySet()) {
       connection.setRequestProperty(property.getKey(), property.getValue());
     }
+
     if (!(position == 0 && length == C.LENGTH_UNSET)) {
       String rangeRequest = "bytes=" + position + "-";
       if (length != C.LENGTH_UNSET) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index 17fb4ad7a1..778c116e01 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -357,6 +357,12 @@ public InvalidResponseCodeException(
    */
   void clearAllRequestProperties();
 
+  /**
+   * When the source is open, returns the HTTP response status code associated with the last {@link
+   * #open} call. Otherwise, returns a negative value.
+   */
+  int getResponseCode();
+
   @Override
   Map<String, List<String>> getResponseHeaders();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 6e20db7bf7..541c3b2d9d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -285,7 +285,7 @@ public long open(DataSpec dataSpec) throws IOException {
       }
       openNextSource(false);
       return bytesRemaining;
-    } catch (IOException e) {
+    } catch (Throwable e) {
       handleBeforeThrow(e);
       throw e;
     }
@@ -327,6 +327,9 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
       }
       handleBeforeThrow(e);
       throw e;
+    } catch (Throwable e) {
+      handleBeforeThrow(e);
+      throw e;
     }
   }
 
@@ -353,7 +356,7 @@ public void close() throws IOException {
     notifyBytesRead();
     try {
       closeCurrentSource();
-    } catch (IOException e) {
+    } catch (Throwable e) {
       handleBeforeThrow(e);
       throw e;
     }
@@ -520,7 +523,7 @@ private void closeCurrentSource() throws IOException {
     }
   }
 
-  private void handleBeforeThrow(IOException exception) {
+  private void handleBeforeThrow(Throwable exception) {
     if (isReadingFromCache() || exception instanceof CacheException) {
       seenCacheError = true;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index 47470c5de7..6277ec686f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -359,7 +359,7 @@ public static void remove(Cache cache, String key) {
     }
   }
 
-  /*package*/ static boolean isCausedByPositionOutOfRange(IOException e) {
+  /* package */ static boolean isCausedByPositionOutOfRange(IOException e) {
     Throwable cause = e;
     while (cause != null) {
       if (cause instanceof DataSourceException) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index 81212b731f..e618fcad75 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -697,9 +697,9 @@ private SimpleCacheSpan getSpan(String key, long position) {
     }
     while (true) {
       SimpleCacheSpan span = cachedContent.getSpan(position);
-      if (span.isCached && !span.file.exists()) {
-        // The file has been deleted from under us. It's likely that other files will have been
-        // deleted too, so scan the whole in-memory representation.
+      if (span.isCached && span.file.length() != span.length) {
+        // The file has been modified or deleted underneath us. It's likely that other files will
+        // have been modified too, so scan the whole in-memory representation.
         removeStaleSpans();
         continue;
       }
@@ -739,14 +739,14 @@ private void removeSpanInternal(CacheSpan span) {
   }
 
   /**
-   * Scans all of the cached spans in the in-memory representation, removing any for which files no
-   * longer exist.
+   * Scans all of the cached spans in the in-memory representation, removing any for which the
+   * underlying file lengths no longer match.
    */
   private void removeStaleSpans() {
     ArrayList<CacheSpan> spansToBeRemoved = new ArrayList<>();
     for (CachedContent cachedContent : contentIndex.getAll()) {
       for (CacheSpan span : cachedContent.getSpans()) {
-        if (!span.file.exists()) {
+        if (span.file.length() != span.length) {
           spansToBeRemoved.add(span);
         }
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
index 10ccb4eba2..3704a09da0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -66,6 +66,7 @@ public void init(
     this.timeUs = timeUs;
     this.mode = mode;
     if (supplementalData != null) {
+      addFlag(C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA);
       int size = supplementalData.limit();
       if (this.supplementalData == null || this.supplementalData.capacity() < size) {
         this.supplementalData = ByteBuffer.allocate(size);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java
new file mode 100644
index 0000000000..f6e30f814a
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.common.truth.Truth.assertThat;
+import static junit.framework.TestCase.fail;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit tests for {@link DataSpec}. */
+@RunWith(AndroidJUnit4.class)
+public class DataSpecTest {
+
+  @Test
+  public void createDataSpec_withDefaultValues_setsEmptyHttpRequestParameters() {
+    Uri uri = Uri.parse("www.google.com");
+    DataSpec dataSpec = new DataSpec(uri);
+
+    assertThat(dataSpec.httpRequestHeaders.isEmpty()).isTrue();
+
+    dataSpec = new DataSpec(uri, /*flags= */ 0);
+    assertThat(dataSpec.httpRequestHeaders.isEmpty()).isTrue();
+
+    dataSpec =
+        new DataSpec(
+            uri,
+            /* httpMethod= */ 0,
+            /* httpBody= */ new byte[] {0, 0, 0, 0},
+            /* absoluteStreamPosition= */ 0,
+            /* position= */ 0,
+            /* length= */ 1,
+            /* key= */ "key",
+            /* flags= */ 0);
+    assertThat(dataSpec.httpRequestHeaders.isEmpty()).isTrue();
+  }
+
+  @Test
+  public void createDataSpec_setsHttpRequestParameters() {
+    Map<String, String> httpRequestParameters = new HashMap<>();
+    httpRequestParameters.put("key1", "value1");
+    httpRequestParameters.put("key2", "value2");
+    httpRequestParameters.put("key3", "value3");
+
+    DataSpec dataSpec =
+        new DataSpec(
+            Uri.parse("www.google.com"),
+            /* httpMethod= */ 0,
+            /* httpBody= */ new byte[] {0, 0, 0, 0},
+            /* absoluteStreamPosition= */ 0,
+            /* position= */ 0,
+            /* length= */ 1,
+            /* key= */ "key",
+            /* flags= */ 0,
+            httpRequestParameters);
+
+    assertThat(dataSpec.httpRequestHeaders).isEqualTo(httpRequestParameters);
+  }
+
+  @Test
+  public void httpRequestParameters_areReadOnly() {
+    DataSpec dataSpec =
+        new DataSpec(
+            Uri.parse("www.google.com"),
+            /* httpMethod= */ 0,
+            /* httpBody= */ new byte[] {0, 0, 0, 0},
+            /* absoluteStreamPosition= */ 0,
+            /* position= */ 0,
+            /* length= */ 1,
+            /* key= */ "key",
+            /* flags= */ 0,
+            /* httpRequestHeaders= */ new HashMap<>());
+
+    try {
+      dataSpec.httpRequestHeaders.put("key", "value");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      // Expected
+    }
+  }
+
+  @Test
+  public void copyMethods_copiesHttpRequestHeaders() {
+    Map<String, String> httpRequestParameters = new HashMap<>();
+    httpRequestParameters.put("key1", "value1");
+    httpRequestParameters.put("key2", "value2");
+    httpRequestParameters.put("key3", "value3");
+
+    DataSpec dataSpec =
+        new DataSpec(
+            Uri.parse("www.google.com"),
+            /* httpMethod= */ 0,
+            /* httpBody= */ new byte[] {0, 0, 0, 0},
+            /* absoluteStreamPosition= */ 0,
+            /* position= */ 0,
+            /* length= */ 1,
+            /* key= */ "key",
+            /* flags= */ 0,
+            httpRequestParameters);
+
+    DataSpec dataSpecCopy = dataSpec.withUri(Uri.parse("www.new-uri.com"));
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestParameters);
+
+    dataSpecCopy = dataSpec.subrange(2);
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestParameters);
+
+    dataSpecCopy = dataSpec.subrange(2, 2);
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestParameters);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceTest.java
new file mode 100644
index 0000000000..7c2b63c941
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceTest.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.upstream;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentMatchers;
+import org.mockito.Mockito;
+
+/** Unit tests for {@link DefaultHttpDataSource}. */
+@RunWith(AndroidJUnit4.class)
+public class DefaultHttpDataSourceTest {
+
+  @Test
+  public void open_withSpecifiedRequestParameters_usesCorrectParameters() throws IOException {
+
+    /*
+     * This test will set HTTP request parameters in the HttpDataSourceFactory (default),
+     * in the DefaultHttpDataSource instance and in the DataSpec instance according to the table
+     * below. Values wrapped in '*' are the ones that should be set in the connection request.
+     *
+     * +-----------------------+---+-----+-----+-----+-----+-----+
+     * |                       |            Header Key           |
+     * +-----------------------+---+-----+-----+-----+-----+-----+
+     * |       Location        | 0 |  1  |  2  |  3  |  4  |  5  |
+     * +-----------------------+---+-----+-----+-----+-----+-----+
+     * | Default               |*Y*|  Y  |  Y  |     |     |     |
+     * | DefaultHttpDataSource |   | *Y* |  Y  |  Y  | *Y* |     |
+     * | DataSpec              |   |     | *Y* | *Y* |     | *Y* |
+     * +-----------------------+---+-----+-----+-----+-----+-----+
+     */
+
+    String defaultParameter = "Default";
+    String dataSourceInstanceParameter = "DefaultHttpDataSource";
+    String dataSpecParameter = "Dataspec";
+
+    HttpDataSource.RequestProperties defaultParameters = new HttpDataSource.RequestProperties();
+    defaultParameters.set("0", defaultParameter);
+    defaultParameters.set("1", defaultParameter);
+    defaultParameters.set("2", defaultParameter);
+
+    DefaultHttpDataSource defaultHttpDataSource =
+        Mockito.spy(
+            new DefaultHttpDataSource(
+                /* userAgent= */ "testAgent",
+                /* connectTimeoutMillis= */ 1000,
+                /* readTimeoutMillis= */ 1000,
+                /* allowCrossProtocolRedirects= */ false,
+                defaultParameters));
+
+    Map<String, String> sentRequestProperties = new HashMap<>();
+    HttpURLConnection mockHttpUrlConnection = makeMockHttpUrlConnection(sentRequestProperties);
+    Mockito.doReturn(mockHttpUrlConnection)
+        .when(defaultHttpDataSource)
+        .openConnection(ArgumentMatchers.any());
+
+    defaultHttpDataSource.setRequestProperty("1", dataSourceInstanceParameter);
+    defaultHttpDataSource.setRequestProperty("2", dataSourceInstanceParameter);
+    defaultHttpDataSource.setRequestProperty("3", dataSourceInstanceParameter);
+    defaultHttpDataSource.setRequestProperty("4", dataSourceInstanceParameter);
+
+    Map<String, String> dataSpecRequestProperties = new HashMap<>();
+    dataSpecRequestProperties.put("2", dataSpecParameter);
+    dataSpecRequestProperties.put("3", dataSpecParameter);
+    dataSpecRequestProperties.put("5", dataSpecParameter);
+
+    DataSpec dataSpec =
+        new DataSpec(
+            /* uri= */ Uri.parse("http://www.google.com"),
+            /* httpMethod= */ 1,
+            /* httpBody= */ new byte[] {0, 0, 0, 0},
+            /* absoluteStreamPosition= */ 0,
+            /* position= */ 0,
+            /* length= */ 1,
+            /* key= */ "key",
+            /* flags= */ 0,
+            dataSpecRequestProperties);
+
+    defaultHttpDataSource.open(dataSpec);
+
+    assertThat(sentRequestProperties.get("0")).isEqualTo(defaultParameter);
+    assertThat(sentRequestProperties.get("1")).isEqualTo(dataSourceInstanceParameter);
+    assertThat(sentRequestProperties.get("2")).isEqualTo(dataSpecParameter);
+    assertThat(sentRequestProperties.get("3")).isEqualTo(dataSpecParameter);
+    assertThat(sentRequestProperties.get("4")).isEqualTo(dataSourceInstanceParameter);
+    assertThat(sentRequestProperties.get("5")).isEqualTo(dataSpecParameter);
+  }
+
+  /**
+   * Creates a mock {@link HttpURLConnection} that stores all request parameters inside {@code
+   * requestProperties}.
+   */
+  private static HttpURLConnection makeMockHttpUrlConnection(Map<String, String> requestProperties)
+      throws IOException {
+    HttpURLConnection mockHttpUrlConnection = Mockito.mock(HttpURLConnection.class);
+    Mockito.when(mockHttpUrlConnection.usingProxy()).thenReturn(false);
+
+    Mockito.when(mockHttpUrlConnection.getInputStream())
+        .thenReturn(new ByteArrayInputStream(new byte[128]));
+
+    Mockito.when(mockHttpUrlConnection.getOutputStream()).thenReturn(new ByteArrayOutputStream());
+
+    Mockito.when(mockHttpUrlConnection.getResponseCode()).thenReturn(200);
+    Mockito.when(mockHttpUrlConnection.getResponseMessage()).thenReturn("OK");
+
+    Mockito.doAnswer(
+            (invocation) -> {
+              String key = invocation.getArgument(0);
+              String value = invocation.getArgument(1);
+              requestProperties.put(key, value);
+              return null;
+            })
+        .when(mockHttpUrlConnection)
+        .setRequestProperty(ArgumentMatchers.anyString(), ArgumentMatchers.anyString());
+
+    return mockHttpUrlConnection;
+  }
+}
