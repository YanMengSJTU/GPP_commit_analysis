diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index d0c9a6400c..973b039d92 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,16 @@
 # Release notes #
 
+### r1.5.13 ###
+
+* Improvements to the upstream cache package.
+* MP4: Support `.mp3` tracks
+  ([2066](https://github.com/google/ExoPlayer/issues/2066)).
+* SubRip: Don't fail playbacks if SubRip file contains negative timestamps
+  ([2145](https://github.com/google/ExoPlayer/issues/2145)).
+* MPEG-TS: Avoid failure when expected ID3 header not found
+  ([1966](https://github.com/google/ExoPlayer/issues/1966)).
+* Misc bugfixes.
+
 ### r1.5.12 ###
 
 * Improvements to Cronet network stack extension.
diff --git a/build.gradle b/build.gradle
index 40ffda09f6..3a2f30d408 100644
--- a/build.gradle
+++ b/build.gradle
@@ -19,7 +19,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.2'
+        classpath 'com.android.tools.build:gradle:2.2.1'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 79b070e161..fd6b3d0b83 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1512"
-    android:versionName="1.5.12"
+    android:versionCode="1513"
+    android:versionName="1.5.13"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo_ext/src/main/AndroidManifest.xml b/demo_ext/src/main/AndroidManifest.xml
index a86a742737..1a73d8c6ba 100644
--- a/demo_ext/src/main/AndroidManifest.xml
+++ b/demo_ext/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.ext"
-    android:versionCode="1511"
-    android:versionName="1.5.11"
+    android:versionCode="1513"
+    android:versionName="1.5.13"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/extensions/cronet/README.md b/extensions/cronet/README.md
index be79ac7d3e..a570385a52 100644
--- a/extensions/cronet/README.md
+++ b/extensions/cronet/README.md
@@ -21,8 +21,9 @@ git clone https://github.com/google/ExoPlayer.git
 
 1. Find the latest Cronet release [here][] and navigate to its `Release/cronet`
    directory
-1. Download `cronet.jar`, `cronet_api.jar` and the `libs` directory
-1. Copy the two jar files into the `libs` directory of this extension
+1. Download `cronet_api.jar`, `cronet_impl_common_java.jar`,
+   `cronet_impl_native_java.jar` and the `libs` directory
+1. Copy the three jar files into the `libs` directory of this extension
 1. Copy the content of the downloaded `libs` directory into the `jniLibs`
    directory of this extension
 
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 0b75639d73..2ae79ac7c2 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -42,7 +42,8 @@ android {
 dependencies {
     compile project(':library')
     compile files('libs/cronet_api.jar')
-    compile files('libs/cronet.jar')
+    compile files('libs/cronet_impl_common_java.jar')
+    compile files('libs/cronet_impl_native_java.jar')
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'org.mockito:mockito-core:1.9.5'
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
index 3c0851f5c9..78ec5866ec 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
@@ -22,7 +22,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
@@ -52,7 +51,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -62,6 +60,7 @@
 import org.chromium.net.UrlRequest;
 import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
+import org.chromium.net.impl.UrlResponseInfoImpl;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -88,20 +87,7 @@
   private Map<String, String> testResponseHeader;
   private UrlResponseInfo testUrlResponseInfo;
 
-  /**
-   * MockableCronetEngine is an abstract class for helping creating new Requests.
-   */
-  public abstract static class MockableCronetEngine extends CronetEngine {
-
-    @Override
-    public abstract UrlRequest createRequest(String url, UrlRequest.Callback callback,
-        Executor executor, int priority,
-        Collection<Object> connectionAnnotations,
-        boolean disableCache,
-        boolean disableConnectionMigration,
-        boolean allowDirectExecutor);
-  }
-
+  @Mock private UrlRequest.Builder mockUrlRequestBuilder;
   @Mock
   private UrlRequest mockUrlRequest;
   @Mock
@@ -114,8 +100,7 @@ public abstract UrlRequest createRequest(String url, UrlRequest.Callback callbac
   private Executor mockExecutor;
   @Mock
   private UrlRequestException mockUrlRequestException;
-  @Mock
-  private MockableCronetEngine mockCronetEngine;
+  @Mock private CronetEngine mockCronetEngine;
 
   private CronetDataSource dataSourceUnderTest;
 
@@ -135,15 +120,10 @@ public void setUp() throws Exception {
             true, // resetTimeoutOnRedirects
             mockClock));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
-    when(mockCronetEngine.createRequest(
-        anyString(),
-        any(UrlRequest.Callback.class),
-        any(Executor.class),
-        anyInt(),
-        eq(Collections.emptyList()),
-        any(Boolean.class),
-        any(Boolean.class),
-        any(Boolean.class))).thenReturn(mockUrlRequest);
+    when(mockCronetEngine.newUrlRequestBuilder(
+            anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
+        .thenReturn(mockUrlRequestBuilder);
+    when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest);
     mockStatusResponse();
 
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, C.LENGTH_UNBOUNDED, null);
@@ -159,7 +139,7 @@ public void setUp() throws Exception {
   private UrlResponseInfo createUrlResponseInfo(int statusCode) {
     ArrayList<Map.Entry<String, String>> responseHeaderList = new ArrayList<>();
     responseHeaderList.addAll(testResponseHeader.entrySet());
-    return new UrlResponseInfo(
+    return new UrlResponseInfoImpl(
         Collections.singletonList(TEST_URL),
         statusCode,
         null, // httpStatusText
@@ -184,15 +164,7 @@ public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
     dataSourceUnderTest.close();
     // Prepare a mock UrlRequest to be used in the second open() call.
     final UrlRequest mockUrlRequest2 = mock(UrlRequest.class);
-    when(mockCronetEngine.createRequest(
-        anyString(),
-        any(UrlRequest.Callback.class),
-        any(Executor.class),
-        anyInt(),
-        eq(Collections.emptyList()),
-        any(Boolean.class),
-        any(Boolean.class),
-        any(Boolean.class))).thenReturn(mockUrlRequest2);
+    when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest2);
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -215,15 +187,8 @@ public void testRequestStartCalled() throws HttpDataSourceException {
     mockResponseStartSuccess();
 
     dataSourceUnderTest.open(testDataSpec);
-    verify(mockCronetEngine).createRequest(
-        eq(TEST_URL),
-        any(UrlRequest.Callback.class),
-        any(Executor.class),
-        anyInt(),
-        eq(Collections.emptyList()),
-        any(Boolean.class),
-        any(Boolean.class),
-        any(Boolean.class));
+    verify(mockCronetEngine)
+        .newUrlRequestBuilder(eq(TEST_URL), any(UrlRequest.Callback.class), any(Executor.class));
     verify(mockUrlRequest).start();
   }
 
@@ -237,9 +202,9 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
 
     dataSourceUnderTest.open(testDataSpec);
     // The header value to add is current position to current position + length - 1.
-    verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
-    verify(mockUrlRequest).addHeader("firstHeader", "firstValue");
-    verify(mockUrlRequest).addHeader("secondHeader", "secondValue");
+    verify(mockUrlRequestBuilder).addHeader("Range", "bytes=1000-5999");
+    verify(mockUrlRequestBuilder).addHeader("firstHeader", "firstValue");
+    verify(mockUrlRequestBuilder).addHeader("secondHeader", "secondValue");
     verify(mockUrlRequest).start();
   }
 
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
index feec8686a8..d748d9e627 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
@@ -406,8 +406,8 @@ public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
   // Internal methods.
 
   private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
-    UrlRequest.Builder requestBuilder = new UrlRequest.Builder(dataSpec.uri.toString(), this,
-        executor, cronetEngine);
+    UrlRequest.Builder requestBuilder = cronetEngine.newUrlRequestBuilder(dataSpec.uri.toString(),
+        this, executor);
     // Set the headers.
     synchronized (requestProperties) {
       if (dataSpec.postBody != null && dataSpec.postBody.length != 0
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index 3a107c1555..113c859309 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -446,7 +446,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
   }
 
   private void setSurface(Surface surface) {
-    if (this.surface == surface) {
+    if (this.surface == surface && outputBufferRenderer == null) {
       return;
     }
     this.surface = surface;
@@ -459,7 +459,7 @@ private void setSurface(Surface surface) {
   }
 
   private void setOutputBufferRenderer(VpxOutputBufferRenderer outputBufferRenderer) {
-    if (this.outputBufferRenderer == outputBufferRenderer) {
+    if (this.outputBufferRenderer == outputBufferRenderer && surface == null) {
       return;
     }
     this.outputBufferRenderer = outputBufferRenderer;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 322063035e..c43c29ed0e 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -113,8 +113,11 @@ protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer
       return new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
     }
     outputBuffer.mode = outputMode;
-    if (vpxGetFrame(vpxDecContext, outputBuffer) != 0) {
+    int getFrameResult = vpxGetFrame(vpxDecContext, outputBuffer);
+    if (getFrameResult == 1) {
       outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    } else if (getFrameResult == -1) {
+      return new VpxDecoderException("Buffer initialization failed.");
     }
     return null;
   }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
index 0875f877fd..911a794e4f 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
@@ -54,10 +54,14 @@ public void release() {
 
   /**
    * Resizes the buffer based on the given dimensions. Called via JNI after decoding completes.
+   * @return Whether the buffer was resized successfully.
    */
-  /* package */ void initForRgbFrame(int width, int height) {
+  /* package */ boolean initForRgbFrame(int width, int height) {
     this.width = width;
     this.height = height;
+    if (!isSafeToMultiply(width, height) || !isSafeToMultiply(width * height, 2)) {
+      return false;
+    }
     int minimumRgbSize = width * height * 2;
     if (data == null || data.capacity() < minimumRgbSize) {
       data = ByteBuffer.allocateDirect(minimumRgbSize);
@@ -65,19 +69,28 @@ public void release() {
     }
     data.position(0);
     data.limit(minimumRgbSize);
+    return true;
   }
 
   /**
    * Resizes the buffer based on the given stride. Called via JNI after decoding completes.
+   * @return Whether the buffer was resized successfully.
    */
-  /* package */ void initForYuvFrame(int width, int height, int yStride, int uvStride,
-      int colorspace) {
+  /* package */ boolean initForYuvFrame(
+      int width, int height, int yStride, int uvStride, int colorspace) {
     this.width = width;
     this.height = height;
     this.colorspace = colorspace;
+    int uvHeight = (int) (((long) height + 1) / 2);
+    if (!isSafeToMultiply(yStride, height) || !isSafeToMultiply(uvStride, uvHeight)) {
+      return false;
+    }
     int yLength = yStride * height;
-    int uvLength = uvStride * ((height + 1) / 2);
+    int uvLength = uvStride * uvHeight;
     int minimumYuvSize = yLength + (uvLength * 2);
+    if (!isSafeToMultiply(uvLength, 2) || minimumYuvSize < yLength) {
+      return false;
+    }
     if (data == null || data.capacity() < minimumYuvSize) {
       data = ByteBuffer.allocateDirect(minimumYuvSize);
     }
@@ -101,6 +114,15 @@ public void release() {
     yuvStrides[0] = yStride;
     yuvStrides[1] = uvStride;
     yuvStrides[2] = uvStride;
+    return true;
+  }
+
+  /**
+   * Ensures that the result of multiplying individual numbers can fit into the size limit of an
+   * integer.
+   */
+  private boolean isSafeToMultiply(int a, int b) {
+    return a >= 0 && b >= 0 && !(b > 0 && a >= Integer.MAX_VALUE / b);
   }
 
 }
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index d15574c12c..358e884fbe 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -71,9 +71,9 @@ FUNC(jlong, vpxInit) {
   const jclass outputBufferClass = env->FindClass(
       "com/google/android/exoplayer/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
-                                     "(IIIII)V");
+                                     "(IIIII)Z");
   initForRgbFrame = env->GetMethodID(outputBufferClass, "initForRgbFrame",
-                                     "(II)V");
+                                     "(II)Z");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
@@ -116,7 +116,11 @@ FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
   int outputMode = env->GetIntField(jOutputBuffer, outputModeField);
   if (outputMode == kOutputModeRgb) {
     // resize buffer if required.
-    env->CallVoidMethod(jOutputBuffer, initForRgbFrame, img->d_w, img->d_h);
+    jboolean initResult = env->CallBooleanMethod(jOutputBuffer, initForRgbFrame,
+                                                 img->d_w, img->d_h);
+    if (initResult == JNI_FALSE) {
+      return -1;
+    }
 
     // get pointer to the data buffer.
     const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
@@ -145,9 +149,12 @@ FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     }
 
     // resize buffer if required.
-    env->CallVoidMethod(jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
-                        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U],
-                        colorspace);
+    jboolean initResult = env->CallBooleanMethod(
+        jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
+        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U], colorspace);
+    if (initResult == JNI_FALSE) {
+      return -1;
+    }
 
     // get pointer to the data buffer.
     const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index b60f1be2b9..b158535b86 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Sep 01 11:41:12 BST 2016
+#Mon Oct 24 14:44:33 BST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index 8237533173..a965743369 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -83,7 +83,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.12'
+    version = 'r1.5.13'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/assets/dash/sample_mpd_2 b/library/src/androidTest/assets/dash/sample_mpd_2
new file mode 100644
index 0000000000..d45ab14f52
--- /dev/null
+++ b/library/src/androidTest/assets/dash/sample_mpd_2
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:mpeg:DASH:schema:MPD:2011" xmlns:yt="http://youtube.com/yt/2012/10/10" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd" minBufferTime="PT1.500S" profiles="urn:mpeg:dash:profile:isoff-main:2011" type="dynamic" availabilityStartTime="2016-10-14T17:00:17" timeShiftBufferDepth="PT7200.000S" minimumUpdatePeriod="PT2.000S" yt:earliestMediaSequence="0" yt:mpdRequestTime="2016-10-14T18:29:17.082" yt:mpdResponseTime="2016-10-14T18:29:17.194">
+ <Period start="PT0.000S" yt:segmentIngestTime="2016-10-14T17:00:14.257">
+  <SegmentTemplate startNumber="0" timescale="1000" media="sq/$Number$">
+   <SegmentTimeline>
+    <S d="2002" t="6009" r="2"/>
+    <S d="1985"/>
+    <S d="2000"/>
+   </SegmentTimeline>
+  </SegmentTemplate>
+  <AdaptationSet id="0" mimeType="audio/mp4" subsegmentAlignment="true">
+   <Role schemeIdUri="urn:mpeg:DASH:role:2011" value="main"/>
+   <Representation id="140" codecs="mp4a.40.2" audioSamplingRate="48000" startWithSAP="1" bandwidth="144000">
+    <AudioChannelConfiguration schemeIdUri="urn:mpeg:dash:23003:3:audio_channel_configuration:2011" value="2"/>
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/140/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/audio%2Fmp4/live/1/gir/yes/noclen/1/signature/B5137EA0CC278C07DD056D204E863CC81EDEB39E.1AD5D242EBC94922EDA7165353A89A5E08A4103A/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+  </AdaptationSet>
+  <AdaptationSet id="1" mimeType="video/mp4" subsegmentAlignment="true">
+   <Role schemeIdUri="urn:mpeg:DASH:role:2011" value="main"/>
+   <Representation id="133" codecs="avc1.4d4015" width="426" height="240" startWithSAP="1" maxPlayoutRate="1" bandwidth="258000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/133/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/90154AE9C5C9D9D519CBF2E43AB0A1778375992D.40E2E855ADFB38FA7E95E168FEEEA6796B080BD7/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="134" codecs="avc1.4d401e" width="640" height="360" startWithSAP="1" maxPlayoutRate="1" bandwidth="646000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/134/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/5C094AEFDCEB1A4D2F3C05F8BD095C336EF0E1C3.7AE6B9951B0237AAE6F031927AACAC4974BAFFAA/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="135" codecs="avc1.4d401f" width="854" height="480" startWithSAP="1" maxPlayoutRate="1" bandwidth="1171000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/135/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/1F7660CA4E5B4AE4D60E18795680E34CDD2EF3C9.800B0A1D5F490DE142CCF4C88C64FD21D42129/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="160" codecs="avc1.42c00b" width="256" height="144" startWithSAP="1" maxPlayoutRate="1" bandwidth="124000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/160/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/94EB61673784DF0C4237A1A866F2E171C8A64ADB.AEC00AA06C2278FEA8702FB62693B70D8977F46C/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="136" codecs="avc1.4d401f" width="1280" height="720" startWithSAP="1" maxPlayoutRate="1" bandwidth="2326000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/136/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/6D8C34FC30A1F1A4F700B61180D1C4CCF6274844.29EBCB4A837DE626C52C66CF650519E61C2FF0BF/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+  </AdaptationSet>
+ </Period>
+</MPD>
diff --git a/library/src/androidTest/assets/subrip/typical_negative_timestamps b/library/src/androidTest/assets/subrip/typical_negative_timestamps
new file mode 100644
index 0000000000..4699d2dcc5
--- /dev/null
+++ b/library/src/androidTest/assets/subrip/typical_negative_timestamps
@@ -0,0 +1,12 @@
+1
+-0:00:04,567 --> -0:00:03,456
+This is the first subtitle.
+
+2
+-00:00:02,345 --> 00:00:01,234
+This is the second subtitle.
+Second subtitle with second line.
+
+3
+00:00:04,567 --> 00:00:08,901
+This is the third subtitle.
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
index 7ab71404bb..1110f2c625 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
@@ -187,10 +187,10 @@ public void testLiveEdgeLatency() {
   // Private methods.
 
   private static Representation buildVodRepresentation(Format format) {
-    RangedUri rangedUri = new RangedUri("https://example.com/1.mp4", null, 0, 100);
-    SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0,
-        "https://example.com/1.mp4", 0, -1);
-    return Representation.newInstance(null, 0, format, segmentBase);
+    String baseUrl = "https://example.com/1.mp4";
+    RangedUri rangedUri = new RangedUri("", 0, 100);
+    SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, 0, -1);
+    return Representation.newInstance(null, 0, format, baseUrl, segmentBase);
   }
 
   private static Representation buildSegmentTimelineRepresentation(long timelineDurationMs,
@@ -203,28 +203,29 @@ private static Representation buildSegmentTimelineRepresentation(long timelineDu
     int segmentCount = (int) Util.ceilDivide(timelineDurationMs, LIVE_SEGMENT_DURATION_MS);
     for (int i = 0; i < segmentCount - 1; i++) {
       segmentTimeline.add(new SegmentTimelineElement(segmentStartTimeMs, LIVE_SEGMENT_DURATION_MS));
-      mediaSegments.add(new RangedUri("", "", byteStart, 500L));
+      mediaSegments.add(new RangedUri("", byteStart, 500L));
       segmentStartTimeMs += LIVE_SEGMENT_DURATION_MS;
       byteStart += 500;
     }
     // The final segment duration is calculated so that the total duration is timelineDurationMs.
     long finalSegmentDurationMs = (timelineStartTimeMs + timelineDurationMs) - segmentStartTimeMs;
     segmentTimeline.add(new SegmentTimelineElement(segmentStartTimeMs, finalSegmentDurationMs));
-    mediaSegments.add(new RangedUri("", "", byteStart, 500L));
+    mediaSegments.add(new RangedUri("", byteStart, 500L));
     segmentStartTimeMs += finalSegmentDurationMs;
     byteStart += 500;
     // Construct the list.
     MultiSegmentBase segmentBase = new SegmentList(null, 1000, 0, 0, 0, segmentTimeline,
         mediaSegments);
-    return Representation.newInstance(null, 0, REGULAR_VIDEO, segmentBase);
+    return Representation.newInstance(null, 0, REGULAR_VIDEO, null, segmentBase);
   }
 
   private static Representation buildSegmentTemplateRepresentation() {
     UrlTemplate initializationTemplate = null;
     UrlTemplate mediaTemplate = UrlTemplate.compile("$RepresentationID$/$Number$");
     MultiSegmentBase segmentBase = new SegmentTemplate(null, 1000, 0, 0, LIVE_SEGMENT_DURATION_MS,
-        null, initializationTemplate, mediaTemplate, "http://www.youtube.com");
-    return Representation.newInstance(null, 0, REGULAR_VIDEO, segmentBase);
+        null, initializationTemplate, mediaTemplate);
+    return Representation.newInstance(null, 0, REGULAR_VIDEO, "http://www.youtube.com",
+        segmentBase, null);
   }
 
   private static MediaPresentationDescription buildMpd(long durationMs,
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
index d733576a15..4790e4dba7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
@@ -25,6 +25,7 @@
 public class MediaPresentationDescriptionParserTest extends InstrumentationTestCase {
 
   private static final String SAMPLE_MPD_1 = "dash/sample_mpd_1";
+  private static final String SAMPLE_MPD_2 = "dash/sample_mpd_2";
 
   public void testParseMediaPresentationDescription() throws IOException {
     MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
@@ -34,4 +35,31 @@ public void testParseMediaPresentationDescription() throws IOException {
     parser.parse("https://example.com/test.mpd", inputStream);
   }
 
+  public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IOException {
+    MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
+    InputStream inputStream =
+            getInstrumentation().getContext().getResources().getAssets().open(SAMPLE_MPD_2);
+    // Simple test to ensure that the sample manifest parses without throwing any exceptions.
+    MediaPresentationDescription mpd = parser.parse("https://example.com/test.mpd", inputStream);
+    assertEquals(1, mpd.getPeriodCount());
+
+    Period period = mpd.getPeriod(0);
+    assertNotNull(period);
+    assertEquals(2, period.adaptationSets.size());
+
+    for (AdaptationSet adaptationSet : period.adaptationSets) {
+      assertNotNull(adaptationSet);
+      for (Representation representation : adaptationSet.representations) {
+        if (representation instanceof Representation.MultiSegmentRepresentation) {
+          Representation.MultiSegmentRepresentation multiSegmentRepresentation =
+              (Representation.MultiSegmentRepresentation) representation;
+          int firstSegmentIndex = multiSegmentRepresentation.getFirstSegmentNum();
+          RangedUri uri = multiSegmentRepresentation.getSegmentUrl(firstSegmentIndex);
+          assertTrue(uri.resolveUriString(representation.baseUrl).contains(
+              "redirector.googlevideo.com"));
+        }
+      }
+    }
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
index 52d5c1dd07..8bdb49d420 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
@@ -21,57 +21,64 @@
  * Unit test for {@link RangedUri}.
  */
 public class RangedUriTest extends TestCase {
-
-  private static final String FULL_URI = "http://www.test.com/path/file.ext";
+  private static final String BASE_URI = "http://www.test.com/";
+  private static final String PARTIAL_URI = "path/file.ext";
+  private static final String FULL_URI = BASE_URI + PARTIAL_URI;
 
   public void testMerge() {
-    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    RangedUri rangeB = new RangedUri(null, FULL_URI, 10, 10);
-    RangedUri expected = new RangedUri(null, FULL_URI, 0, 20);
-    assertMerge(rangeA, rangeB, expected);
+    RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 10, 10);
+    RangedUri expected = new RangedUri(FULL_URI, 0, 20);
+    assertMerge(rangeA, rangeB, expected, null);
   }
 
   public void testMergeUnbounded() {
-    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    RangedUri rangeB = new RangedUri(null, FULL_URI, 10, -1);
-    RangedUri expected = new RangedUri(null, FULL_URI, 0, -1);
-    assertMerge(rangeA, rangeB, expected);
+    RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 10, -1);
+    RangedUri expected = new RangedUri(FULL_URI, 0, -1);
+    assertMerge(rangeA, rangeB, expected, null);
   }
 
   public void testNonMerge() {
     // A and B do not overlap, so should not merge
-    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    RangedUri rangeB = new RangedUri(null, FULL_URI, 11, 10);
-    assertNonMerge(rangeA, rangeB);
+    RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 11, 10);
+    assertNonMerge(rangeA, rangeB, null);
 
     // A and B do not overlap, so should not merge
-    rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    rangeB = new RangedUri(null, FULL_URI, 11, -1);
-    assertNonMerge(rangeA, rangeB);
+    rangeA = new RangedUri(FULL_URI, 0, 10);
+    rangeB = new RangedUri(FULL_URI, 11, -1);
+    assertNonMerge(rangeA, rangeB, null);
 
     // A and B are bounded but overlap, so should not merge
-    rangeA = new RangedUri(null, FULL_URI, 0, 11);
-    rangeB = new RangedUri(null, FULL_URI, 10, 10);
-    assertNonMerge(rangeA, rangeB);
+    rangeA = new RangedUri(FULL_URI, 0, 11);
+    rangeB = new RangedUri(FULL_URI, 10, 10);
+    assertNonMerge(rangeA, rangeB, null);
 
     // A and B overlap due to unboundedness, so should not merge
-    rangeA = new RangedUri(null, FULL_URI, 0, -1);
-    rangeB = new RangedUri(null, FULL_URI, 10, -1);
-    assertNonMerge(rangeA, rangeB);
+    rangeA = new RangedUri(FULL_URI, 0, -1);
+    rangeB = new RangedUri(FULL_URI, 10, -1);
+    assertNonMerge(rangeA, rangeB, null);
+  }
 
+  public void testMergeWithBaseUri() {
+    RangedUri rangeA = new RangedUri(PARTIAL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 10, 10);
+    RangedUri expected = new RangedUri(FULL_URI, 0, 20);
+    assertMerge(rangeA, rangeB, expected, BASE_URI);
   }
 
-  private void assertMerge(RangedUri rangeA, RangedUri rangeB, RangedUri expected) {
-    RangedUri merged = rangeA.attemptMerge(rangeB);
+  private void assertMerge(RangedUri rangeA, RangedUri rangeB, RangedUri expected, String baseUrl) {
+    RangedUri merged = rangeA.attemptMerge(rangeB, baseUrl);
     assertEquals(expected, merged);
-    merged = rangeB.attemptMerge(rangeA);
+    merged = rangeB.attemptMerge(rangeA, baseUrl);
     assertEquals(expected, merged);
   }
 
-  private void assertNonMerge(RangedUri rangeA, RangedUri rangeB) {
-    RangedUri merged = rangeA.attemptMerge(rangeB);
+  private void assertNonMerge(RangedUri rangeA, RangedUri rangeB, String baseUrl) {
+    RangedUri merged = rangeA.attemptMerge(rangeB, baseUrl);
     assertNull(merged);
-    merged = rangeB.attemptMerge(rangeA);
+    merged = rangeB.attemptMerge(rangeA, baseUrl);
     assertNull(merged);
   }
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
index 9ddd6131c9..50fd0a95b0 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
@@ -27,13 +27,14 @@
 
   public void testGetCacheKey() {
     String uri = "http://www.google.com";
-    SegmentBase base = new SingleSegmentBase(new RangedUri(uri, null, 0, 1), 1, 0, uri, 1, 1);
+    SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
     Format format = new Format("0", MimeTypes.VIDEO_MP4, 1920, 1080, -1, 0, 0, 2500000);
-    Representation representation = Representation.newInstance("test_stream_1", 3, format, base);
+    Representation representation = Representation.newInstance("test_stream_1", 3, format, uri,
+        base);
     assertEquals("test_stream_1.0.3", representation.getCacheKey());
 
     format = new Format("150", MimeTypes.VIDEO_MP4, 1920, 1080, -1, 0, 0, 2500000);
-    representation = Representation.newInstance("test_stream_1", -1, format, base);
+    representation = Representation.newInstance("test_stream_1", -1, format, uri, base);
     assertEquals("test_stream_1.150.-1", representation.getCacheKey());
   }
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
index 019b76835f..60508cd68b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
@@ -16,14 +16,17 @@
 package com.google.android.exoplayer.testutil;
 
 import android.app.Instrumentation;
+import android.content.Context;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Random;
+import junit.framework.Assert;
 import org.mockito.MockitoAnnotations;
 
 /**
@@ -104,4 +107,21 @@ public static void setUpMockito(InstrumentationTestCase instrumentationTestCase)
     return Util.toByteArray(is);
   }
 
+  public static void recursiveDelete(File fileOrDirectory) {
+    if (fileOrDirectory.isDirectory()) {
+      for (File child : fileOrDirectory.listFiles()) {
+        recursiveDelete(child);
+      }
+    }
+    fileOrDirectory.delete();
+  }
+
+  /** Creates an empty folder in the application specific cache directory. */
+  public static File createTempFolder(Context context) throws IOException {
+    File tempFolder = File.createTempFile("ExoPlayerTest", null, context.getCacheDir());
+    Assert.assertTrue(tempFolder.delete());
+    Assert.assertTrue(tempFolder.mkdir());
+    return tempFolder;
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
index 7423faf0ff..ae6fc55faa 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
@@ -30,6 +30,7 @@
   private static final String TYPICAL_EXTRA_BLANK_LINE = "subrip/typical_extra_blank_line";
   private static final String TYPICAL_MISSING_TIMECODE = "subrip/typical_missing_timecode";
   private static final String TYPICAL_MISSING_SEQUENCE = "subrip/typical_missing_sequence";
+  private static final String TYPICAL_NEGATIVE_TIMESTAMPS = "subrip/typical_negative_timestamps";
   private static final String NO_END_TIMECODES_FILE = "subrip/no_end_timecodes";
 
   public void testParseEmpty() throws IOException {
@@ -115,6 +116,15 @@ public void testParseNoEndTimecodes() throws IOException {
         subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
   }
 
+  public void testDecodeTypicalNegativeTimestamps() throws IOException {
+    // Parsing should succeed, parsing the third cue only.
+    SubripParser parser = new SubripParser();
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_NEGATIVE_TIMESTAMPS);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
+    assertEquals(2, subtitle.getEventTimeCount());
+    assertTypicalCue3(subtitle, 0);
+  }
+
   private static void assertTypicalCue1(SubripSubtitle subtitle, int eventIndex) {
     assertEquals(0, subtitle.getEventTime(eventIndex));
     assertEquals("This is the first subtitle.",
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/CachedContentIndexTest.java b/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/CachedContentIndexTest.java
new file mode 100644
index 0000000000..10b2c65456
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/CachedContentIndexTest.java
@@ -0,0 +1,221 @@
+package com.google.android.exoplayer.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
+import android.util.SparseArray;
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.testutil.TestUtil;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Set;
+import junit.framework.AssertionFailedError;
+
+/**
+ * Tests {@link CachedContentIndex}.
+ */
+public class CachedContentIndexTest extends InstrumentationTestCase {
+
+  private final byte[] testIndexV1File = {
+      0, 0, 0, 1, // version
+      0, 0, 0, 0, // flags
+      0, 0, 0, 2, // number_of_CachedContent
+      0, 0, 0, 5, // cache_id
+      0, 5, 65, 66, 67, 68, 69, // cache_key
+      0, 0, 0, 0, 0, 0, 0, 10, // original_content_length
+      0, 0, 0, 2, // cache_id
+      0, 5, 75, 76, 77, 78, 79, // cache_key
+      0, 0, 0, 0, 0, 0, 10, 00, // original_content_length
+      (byte) 0xF6, (byte) 0xFB, 0x50, 0x41 // hashcode_of_CachedContent_array
+  };
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  @Override
+  public void setUp() throws Exception {
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  public void testAddGetRemove() throws Exception {
+    final String key1 = "key1";
+    final String key2 = "key2";
+    final String key3 = "key3";
+
+    // Add two CachedContents with add methods
+    CachedContent cachedContent1 = new CachedContent(5, key1, 10);
+    index.addNew(cachedContent1);
+    CachedContent cachedContent2 = index.add(key2);
+    assertTrue(cachedContent1.id != cachedContent2.id);
+
+    // add a span
+    File cacheSpanFile = SimpleCacheSpanTest
+        .createCacheSpanFile(cacheDir, cachedContent1.id, 10, 20, 30);
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, index);
+    assertNotNull(span);
+    cachedContent1.addSpan(span);
+
+    // Check if they are added and get method returns null if the key isn't found
+    assertEquals(cachedContent1, index.get(key1));
+    assertEquals(cachedContent2, index.get(key2));
+    assertNull(index.get(key3));
+
+    // test getAll()
+    Collection<CachedContent> cachedContents = index.getAll();
+    assertEquals(2, cachedContents.size());
+    assertTrue(Arrays.asList(cachedContent1, cachedContent2).containsAll(cachedContents));
+
+    // test getKeys()
+    Set<String> keys = index.getKeys();
+    assertEquals(2, keys.size());
+    assertTrue(Arrays.asList(key1, key2).containsAll(keys));
+
+    // test getKeyForId()
+    assertEquals(key1, index.getKeyForId(cachedContent1.id));
+    assertEquals(key2, index.getKeyForId(cachedContent2.id));
+
+    // test remove()
+    index.removeEmpty(key2);
+    index.removeEmpty(key3);
+    assertEquals(cachedContent1, index.get(key1));
+    assertNull(index.get(key2));
+    assertTrue(cacheSpanFile.exists());
+
+    // test removeEmpty()
+    index.addNew(cachedContent2);
+    index.removeEmpty();
+    assertEquals(cachedContent1, index.get(key1));
+    assertNull(index.get(key2));
+    assertTrue(cacheSpanFile.exists());
+  }
+
+  public void testStoreAndLoad() throws Exception {
+    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir));
+  }
+
+  public void testLoadV1() throws Exception {
+    FileOutputStream fos = new FileOutputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
+    fos.write(testIndexV1File);
+    fos.close();
+
+    index.load();
+    assertEquals(2, index.getAll().size());
+    assertEquals(5, index.assignIdForKey("ABCDE"));
+    assertEquals(10, index.getContentLength("ABCDE"));
+    assertEquals(2, index.assignIdForKey("KLMNO"));
+    assertEquals(2560, index.getContentLength("KLMNO"));
+  }
+
+  public void testStoreV1() throws Exception {
+    index.addNew(new CachedContent(2, "KLMNO", 2560));
+    index.addNew(new CachedContent(5, "ABCDE", 10));
+
+    index.store();
+
+    byte[] buffer = new byte[testIndexV1File.length];
+    FileInputStream fos = new FileInputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
+    assertEquals(testIndexV1File.length, fos.read(buffer));
+    assertEquals(-1, fos.read());
+    fos.close();
+
+    // TODO: The order of the CachedContent stored in index file isn't defined so this test may fail
+    // on a different implementation of the underlying set
+    MoreAsserts.assertEquals(testIndexV1File, buffer);
+  }
+
+  public void testAssignIdForKeyAndGetKeyForId() throws Exception {
+    final String key1 = "key1";
+    final String key2 = "key2";
+    int id1 = index.assignIdForKey(key1);
+    int id2 = index.assignIdForKey(key2);
+    assertEquals(key1, index.getKeyForId(id1));
+    assertEquals(key2, index.getKeyForId(id2));
+    assertTrue(id1 != id2);
+    assertEquals(id1, index.assignIdForKey(key1));
+    assertEquals(id2, index.assignIdForKey(key2));
+  }
+
+  public void testSetGetContentLength() throws Exception {
+    final String key1 = "key1";
+    assertEquals(C.LENGTH_UNBOUNDED, index.getContentLength(key1));
+    index.setContentLength(key1, 10);
+    assertEquals(10, index.getContentLength(key1));
+  }
+
+  public void testGetNewId() throws Exception {
+    SparseArray<String> idToKey = new SparseArray<>();
+    assertEquals(0, CachedContentIndex.getNewId(idToKey));
+    idToKey.put(10, "");
+    assertEquals(11, CachedContentIndex.getNewId(idToKey));
+    idToKey.put(Integer.MAX_VALUE, "");
+    assertEquals(0, CachedContentIndex.getNewId(idToKey));
+    idToKey.put(0, "");
+    assertEquals(1, CachedContentIndex.getNewId(idToKey));
+  }
+
+  public void testEncryption() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key2 = "bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+
+    assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+        new CachedContentIndex(cacheDir, key));
+
+    // Rename the index file from the test above
+    File file1 = new File(cacheDir, CachedContentIndex.FILE_NAME);
+    File file2 = new File(cacheDir, "file2compare");
+    assertTrue(file1.renameTo(file2));
+
+    // Write a new index file
+    assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+        new CachedContentIndex(cacheDir, key));
+
+    assertEquals(file2.length(), file1.length());
+    // Assert file content is different
+    FileInputStream fis1 = new FileInputStream(file1);
+    FileInputStream fis2 = new FileInputStream(file2);
+    for (int b; (b = fis1.read()) == fis2.read();) {
+      assertTrue(b != -1);
+    }
+
+    boolean threw = false;
+    try {
+      assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+          new CachedContentIndex(cacheDir, key2));
+    } catch (AssertionFailedError e) {
+      threw = true;
+    }
+    assertTrue("Encrypted index file can not be read with different encryption key", threw);
+
+    try {
+      assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+          new CachedContentIndex(cacheDir));
+    } catch (AssertionFailedError e) {
+      threw = true;
+    }
+    assertTrue("Encrypted index file can not be read without encryption key", threw);
+
+    // Non encrypted index file can be read even when encryption key provided.
+    assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir),
+        new CachedContentIndex(cacheDir, key));
+  }
+
+  private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentIndex index2)
+      throws IOException {
+    index.addNew(new CachedContent(5, "key1", 10));
+    index.add("key2");
+    index.store();
+
+    index2.load();
+    Set<String> keys = index.getKeys();
+    Set<String> keys2 = index2.getKeys();
+    assertEquals(keys, keys2);
+    for (String key : keys) {
+      assertEquals(index.getContentLength(key), index2.getContentLength(key));
+      assertEquals(index.get(key).getSpans(), index2.get(key).getSpans());
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/SimpleCacheSpanTest.java b/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/SimpleCacheSpanTest.java
new file mode 100644
index 0000000000..588df4e136
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/SimpleCacheSpanTest.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer.testutil.TestUtil;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.TreeSet;
+
+/**
+ * Unit tests for {@link SimpleCacheSpan}.
+ */
+public class SimpleCacheSpanTest extends InstrumentationTestCase {
+
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  public static File createCacheSpanFile(File cacheDir, int id, long offset, int length,
+      long lastAccessTimestamp) throws IOException {
+    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastAccessTimestamp);
+    createTestFile(cacheFile, length);
+    return cacheFile;
+  }
+
+  public static CacheSpan createCacheSpan(CachedContentIndex index, File cacheDir, String key,
+      long offset, int length, long lastAccessTimestamp) throws IOException {
+    int id = index.assignIdForKey(key);
+    File cacheFile = createCacheSpanFile(cacheDir, id, offset, length, lastAccessTimestamp);
+    return SimpleCacheSpan.createCacheEntry(cacheFile, index);
+  }
+
+  @Override
+  protected void setUp() throws Exception {
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(cacheDir);
+  }
+
+  public void testCacheFile() throws Exception {
+    assertCacheSpan("key1", 0, 0);
+    assertCacheSpan("key2", 1, 2);
+    assertCacheSpan("<>:\"/\\|?*%", 1, 2);
+    assertCacheSpan("key3", 1, 2);
+
+    assertNullCacheSpan(new File("parent"), "key4", -1, 2);
+    assertNullCacheSpan(new File("parent"), "key5", 1, -2);
+
+    assertCacheSpan(
+        "A newline (line feed) character \n"
+            + "A carriage-return character followed immediately by a newline character \r\n"
+            + "A standalone carriage-return character \r"
+            + "A next-line character \u0085"
+            + "A line-separator character \u2028"
+            + "A paragraph-separator character \u2029", 1, 2);
+  }
+
+  public void testUpgradeFileName() throws Exception {
+    String key = "asd\u00aa";
+    int id = index.assignIdForKey(key);
+    File v3file = createTestFile(id + ".0.1.v3.exo");
+    File v2file = createTestFile("asd%aa.1.2.v2.exo");
+    File wrongEscapedV2file = createTestFile("asd%za.3.4.v2.exo");
+    File v1File = createTestFile("asd\u00aa.5.6.v1.exo");
+
+    for (File file : cacheDir.listFiles()) {
+      SimpleCacheSpan cacheEntry = SimpleCacheSpan.createCacheEntry(file, index);
+      if (file.equals(wrongEscapedV2file)) {
+        assertNull(cacheEntry);
+      } else {
+        assertNotNull(cacheEntry);
+      }
+    }
+
+    assertTrue(v3file.exists());
+    assertFalse(v2file.exists());
+    assertTrue(wrongEscapedV2file.exists());
+    assertFalse(v1File.exists());
+
+    File[] files = cacheDir.listFiles();
+    assertEquals(4, files.length);
+
+    Set<String> keys = index.getKeys();
+    assertEquals("There should be only one key for all files.", 1, keys.size());
+    assertTrue(keys.contains(key));
+
+    TreeSet<SimpleCacheSpan> spans = index.get(key).getSpans();
+    assertTrue("upgradeOldFiles() shouldn't add any spans.", spans.isEmpty());
+
+    HashMap<Long, Long> cachedPositions = new HashMap<>();
+    for (File file : files) {
+      SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(file, index);
+      if (cacheSpan != null) {
+        assertEquals(key, cacheSpan.key);
+        cachedPositions.put(cacheSpan.position, cacheSpan.lastAccessTimestamp);
+      }
+    }
+
+    assertEquals(1, (long) cachedPositions.get((long) 0));
+    assertEquals(2, (long) cachedPositions.get((long) 1));
+    assertEquals(6, (long) cachedPositions.get((long) 5));
+  }
+
+  private static void createTestFile(File file, int length) throws IOException {
+    FileOutputStream output = new FileOutputStream(file);
+    for (int i = 0; i < length; i++) {
+      output.write(i);
+    }
+    output.close();
+  }
+
+  private File createTestFile(String name) throws IOException {
+    File file = new File(cacheDir, name);
+    createTestFile(file, 1);
+    return file;
+  }
+
+  private void assertCacheSpan(String key, long offset, long lastAccessTimestamp)
+      throws IOException {
+    int id = index.assignIdForKey(key);
+    File cacheFile = createCacheSpanFile(cacheDir, id, offset, 1, lastAccessTimestamp);
+    SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
+    String message = cacheFile.toString();
+    assertNotNull(message, cacheSpan);
+    assertEquals(message, cacheDir, cacheFile.getParentFile());
+    assertEquals(message, key, cacheSpan.key);
+    assertEquals(message, offset, cacheSpan.position);
+    assertEquals(message, 1, cacheSpan.length);
+    assertTrue(message, cacheSpan.isCached);
+    assertEquals(message, cacheFile, cacheSpan.file);
+    assertEquals(message, lastAccessTimestamp, cacheSpan.lastAccessTimestamp);
+  }
+
+  private void assertNullCacheSpan(File parent, String key, long offset,
+      long lastAccessTimestamp) {
+    File cacheFile = SimpleCacheSpan.getCacheFile(parent, index.assignIdForKey(key), offset,
+        lastAccessTimestamp);
+    CacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
+    assertNull(cacheFile.toString(), cacheSpan);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/SimpleCacheTest.java b/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/SimpleCacheTest.java
new file mode 100644
index 0000000000..83fec7d0e0
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/upstream/cache/SimpleCacheTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer.testutil.TestUtil;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.NavigableSet;
+import java.util.Set;
+
+/**
+ * Unit tests for {@link SimpleCache}.
+ */
+public class SimpleCacheTest extends InstrumentationTestCase {
+
+  private static final String KEY_1 = "key1";
+
+  private File cacheDir;
+
+  @Override
+  protected void setUp() throws Exception {
+    this.cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(cacheDir);
+  }
+
+  public void testCommittingOneFile() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
+    assertFalse(cacheSpan.isCached);
+    assertTrue(cacheSpan.isOpenEnded());
+
+    assertNull(simpleCache.startReadWriteNonBlocking(KEY_1, 0));
+
+    assertEquals(0, simpleCache.getKeys().size());
+    NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
+    assertTrue(cachedSpans == null || cachedSpans.size() == 0);
+    assertEquals(0, simpleCache.getCacheSpace());
+    assertEquals(0, cacheDir.listFiles().length);
+
+    addCache(simpleCache, 0, 15);
+
+    Set<String> cachedKeys = simpleCache.getKeys();
+    assertEquals(1, cachedKeys.size());
+    assertTrue(cachedKeys.contains(KEY_1));
+    cachedSpans = simpleCache.getCachedSpans(KEY_1);
+    assertEquals(1, cachedSpans.size());
+    assertTrue(cachedSpans.contains(cacheSpan));
+    assertEquals(15, simpleCache.getCacheSpace());
+
+    cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
+    assertTrue(cacheSpan.isCached);
+    assertFalse(cacheSpan.isOpenEnded());
+    assertEquals(15, cacheSpan.length);
+  }
+
+  private SimpleCache getSimpleCache() {
+    return new SimpleCache(cacheDir, new NoOpCacheEvictor());
+  }
+
+  private void addCache(SimpleCache simpleCache, int position, int length) throws IOException {
+    File file = simpleCache.startFile(KEY_1, position, length);
+    FileOutputStream fos = new FileOutputStream(file);
+    fos.write(new byte[length]);
+    fos.close();
+    simpleCache.commitFile(file);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/AtomicFileTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/AtomicFileTest.java
new file mode 100644
index 0000000000..17925acb37
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/AtomicFileTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer.util;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer.testutil.TestUtil;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Tests {@link AtomicFile}.
+ */
+public class AtomicFileTest extends InstrumentationTestCase {
+
+  private File tempFolder;
+  private File file;
+  private AtomicFile atomicFile;
+
+  @Override
+  public void setUp() throws Exception {
+    tempFolder = TestUtil.createTempFolder(getInstrumentation().getContext());
+    file = new File(tempFolder, "atomicFile");
+    atomicFile = new AtomicFile(file);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(tempFolder);
+  }
+
+  public void testDelete() throws Exception {
+    assertTrue(file.createNewFile());
+    atomicFile.delete();
+    assertFalse(file.exists());
+  }
+
+  public void testWriteRead() throws Exception {
+    OutputStream output = atomicFile.startWrite();
+    output.write(5);
+    atomicFile.endWrite(output);
+    output.close();
+
+    assertRead();
+
+    output = atomicFile.startWrite();
+    output.write(5);
+    output.write(6);
+    output.close();
+
+    assertRead();
+
+    output = atomicFile.startWrite();
+    output.write(6);
+
+    assertRead();
+
+    output = atomicFile.startWrite();
+
+    assertRead();
+  }
+
+  private void assertRead() throws IOException {
+    InputStream input = atomicFile.openRead();
+    assertEquals(5, input.read());
+    assertEquals(-1, input.read());
+    input.close();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/ReusableBufferedOutputStreamTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/ReusableBufferedOutputStreamTest.java
new file mode 100644
index 0000000000..9c8a78e0b9
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/ReusableBufferedOutputStreamTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import android.test.MoreAsserts;
+import java.io.ByteArrayOutputStream;
+import junit.framework.TestCase;
+
+/**
+ * Tests {@link ReusableBufferedOutputStream}.
+ */
+public class ReusableBufferedOutputStreamTest extends TestCase {
+
+  private static final byte[] TEST_DATA_1 = "test data 1".getBytes();
+  private static final byte[] TEST_DATA_2 = "2 test data".getBytes();
+
+  public void testReset() throws Exception {
+    ByteArrayOutputStream byteArrayOutputStream1 = new ByteArrayOutputStream(1000);
+    ReusableBufferedOutputStream outputStream = new ReusableBufferedOutputStream(
+        byteArrayOutputStream1, 1000);
+    outputStream.write(TEST_DATA_1);
+    outputStream.close();
+
+    ByteArrayOutputStream byteArrayOutputStream2 = new ByteArrayOutputStream(1000);
+    outputStream.reset(byteArrayOutputStream2);
+    outputStream.write(TEST_DATA_2);
+    outputStream.close();
+
+    MoreAsserts.assertEquals(TEST_DATA_1, byteArrayOutputStream1.toByteArray());
+    MoreAsserts.assertEquals(TEST_DATA_2, byteArrayOutputStream2.toByteArray());
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
index 1c2ccb43dc..b2542731c7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
@@ -141,6 +141,8 @@ public void testParseXsDuration() {
   public void testParseXsDateTime() throws ParseException {
     assertEquals(1403219262000L, Util.parseXsDateTime("2014-06-19T23:07:42"));
     assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00Z"));
+    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-08:00"));
+    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-0800"));
   }
 
   public void testLongSplitting() {
diff --git a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
index c8a6d47e6c..c57dff8c95 100644
--- a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
@@ -185,8 +185,7 @@ public boolean update(Object loader, long playbackPositionUs, long nextLoadPosit
       updateControlState();
     }
 
-    return currentBufferSize < targetBufferSize && nextLoadPositionUs != -1
-        && nextLoadPositionUs <= maxLoadStartPositionUs;
+    return nextLoadPositionUs != -1 && nextLoadPositionUs <= maxLoadStartPositionUs;
   }
 
   private int getLoaderBufferState(long playbackPositionUs, long nextLoadPositionUs) {
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 874900942d..742e7e7448 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.12";
+  public static final String VERSION = "1.5.13";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  public static final int VERSION_INT = 1005012;
+  public static final int VERSION_INT = 1005013;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 03718b9c8e..aa803b18de 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -69,14 +69,14 @@
   }
 
   /**
-   * The type of a message that can be passed to an instance of this class via
+   * A type of a message that can be passed to an instance of this class via
    * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
    * should be a {@link Float} with 0 being silence and 1 being unity gain.
    */
   public static final int MSG_SET_VOLUME = 1;
 
   /**
-   * The type of a message that can be passed to an instance of this class via
+   * A type of a message that can be passed to an instance of this class via
    * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
    * should be a {@link android.media.PlaybackParams}, which will be used to configure the
    * underlying {@link android.media.AudioTrack}. The message object should not be modified by the
@@ -84,6 +84,18 @@
    */
   public static final int MSG_SET_PLAYBACK_PARAMS = 2;
 
+  /**
+   * A type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be an integer stream type accepted by {@link android.media.AudioTrack}'s constructor
+   * (see {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}).
+   * <p>
+   * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
+   * introduce a brief gap in audio output. Note also that tracks in the same audio session must
+   * share the same routing, so a new audio session id will be generated.
+   */
+  public static final int MSG_SET_STREAM_TYPE = 3;
+
   private final EventListener eventListener;
   private final AudioTrack audioTrack;
 
@@ -441,6 +453,12 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
       case MSG_SET_PLAYBACK_PARAMS:
         audioTrack.setPlaybackParams((PlaybackParams) message);
         break;
+      case MSG_SET_STREAM_TYPE:
+        int streamType = (Integer) message;
+        if (audioTrack.setStreamType(streamType)) {
+          audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+        }
+        break;
       default:
         super.handleMessage(messageType, message);
         break;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 85fa35ccb7..9143219368 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -1139,7 +1139,10 @@ private static boolean codecNeedsEosPropagationWorkaround(String name) {
    *     buffer with {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} set. False otherwise.
    */
   private static boolean codecNeedsEosFlushWorkaround(String name) {
-    return Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name);
+    return (Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name))
+        || (Util.SDK_INT <= 19 && "hb2000".equals(Util.DEVICE)
+            && ("OMX.amlogic.avc.decoder.awesome".equals(name)
+                || "OMX.amlogic.avc.decoder.awesome.secure".equals(name)));
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 593f513066..d7bff73b9d 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -202,6 +202,7 @@ private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
         && ("CIPAACDecoder".equals(name)
             || "CIPMP3Decoder".equals(name)
             || "CIPVorbisDecoder".equals(name)
+            || "CIPAMRNBDecoder".equals(name)
             || "AACDecoder".equals(name)
             || "MP3Decoder".equals(name))) {
       return false;
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index 39c4afe9a0..a0300142ea 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -184,7 +184,6 @@ public InvalidAudioTrackTimestampException(String message) {
   public static boolean failOnSpuriousAudioTimestamp = false;
 
   private final AudioCapabilities audioCapabilities;
-  private final int streamType;
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
@@ -197,6 +196,7 @@ public InvalidAudioTrackTimestampException(String message) {
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
+  private int streamType;
   private int sourceEncoding;
   private int targetEncoding;
   private boolean passthrough;
@@ -243,7 +243,6 @@ public AudioTrack() {
    */
   public AudioTrack(AudioCapabilities audioCapabilities, int streamType) {
     this.audioCapabilities = audioCapabilities;
-    this.streamType = streamType;
     releasingConditionVariable = new ConditionVariable(true);
     if (Util.SDK_INT >= 18) {
       try {
@@ -261,6 +260,7 @@ public AudioTrack(AudioCapabilities audioCapabilities, int streamType) {
       audioTrackUtil = new AudioTrackUtil();
     }
     playheadOffsets = new long[MAX_PLAYHEAD_OFFSET_COUNT];
+    this.streamType = streamType;
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
   }
@@ -702,6 +702,24 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
     audioTrackUtil.setPlaybackParameters(playbackParams);
   }
 
+  /**
+   * Sets the stream type for audio track. If the stream type has changed, {@link #isInitialized()}
+   * will return {@code false} and the caller must re-{@link #initialize(int)} the audio track
+   * before writing more data. The caller must not reuse the audio session identifier when
+   * re-initializing with a new stream type.
+   *
+   * @param streamType The stream type to use for audio output.
+   * @return Whether the stream type changed.
+   */
+  public boolean setStreamType(int streamType) {
+    if (this.streamType == streamType) {
+      return false;
+    }
+    this.streamType = streamType;
+    reset();
+    return true;
+  }
+
   /**
    * Sets the playback volume.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 53f5d99b1b..1bcb44d387 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -681,15 +681,15 @@ private Chunk newInitializationChunk(RangedUri initializationUri, RangedUri inde
     if (initializationUri != null) {
       // It's common for initialization and index data to be stored adjacently. Attempt to merge
       // the two requests together to request both at once.
-      requestUri = initializationUri.attemptMerge(indexUri);
+      requestUri = initializationUri.attemptMerge(indexUri, representation.baseUrl);
       if (requestUri == null) {
         requestUri = initializationUri;
       }
     } else {
       requestUri = indexUri;
     }
-    DataSpec dataSpec = new DataSpec(requestUri.getUri(), requestUri.start, requestUri.length,
-        representation.getCacheKey());
+    DataSpec dataSpec = new DataSpec(requestUri.resolveUri(representation.baseUrl),
+        requestUri.start, requestUri.length, representation.getCacheKey());
     return new InitializationChunk(dataSource, dataSpec, trigger, representation.format,
         extractor, manifestIndex);
   }
@@ -703,8 +703,8 @@ protected Chunk newMediaChunk(
     long startTimeUs = representationHolder.getSegmentStartTimeUs(segmentNum);
     long endTimeUs = representationHolder.getSegmentEndTimeUs(segmentNum);
     RangedUri segmentUri = representationHolder.getSegmentUrl(segmentNum);
-    DataSpec dataSpec = new DataSpec(segmentUri.getUri(), segmentUri.start, segmentUri.length,
-        representation.getCacheKey());
+    DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(representation.baseUrl),
+        segmentUri.start, segmentUri.length, representation.getCacheKey());
 
     long sampleOffsetUs = periodHolder.startTimeUs - representation.presentationTimeOffsetUs;
     if (mimeTypeIsRawText(format.mimeType)) {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
index 5542232e08..71a34c8381 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
@@ -58,7 +58,7 @@ public long getDurationUs(int segmentNum, long periodDurationUs) {
 
   @Override
   public RangedUri getSegmentUrl(int segmentNum) {
-    return new RangedUri(uri, null, chunkIndex.offsets[segmentNum], chunkIndex.sizes[segmentNum]);
+    return new RangedUri(null, chunkIndex.offsets[segmentNum], chunkIndex.sizes[segmentNum]);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index eefa71bc8c..602ee27260 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -54,7 +54,7 @@
 public class MediaPresentationDescriptionParser extends DefaultHandler
     implements UriLoadable.Parser<MediaPresentationDescription> {
 
-  private static final String TAG = "MediaPresentationDescriptionParser";
+  private static final String TAG = "MPDParser";
 
   private static final Pattern FRAME_RATE_PATTERN = Pattern.compile("(\\d+)(?:/(\\d+))?");
 
@@ -202,11 +202,11 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
       } else if (ParserUtil.isStartTag(xpp, "AdaptationSet")) {
         adaptationSets.add(parseAdaptationSet(xpp, baseUrl, segmentBase));
       } else if (ParserUtil.isStartTag(xpp, "SegmentBase")) {
-        segmentBase = parseSegmentBase(xpp, baseUrl, null);
+        segmentBase = parseSegmentBase(xpp, null);
       } else if (ParserUtil.isStartTag(xpp, "SegmentList")) {
-        segmentBase = parseSegmentList(xpp, baseUrl, null);
+        segmentBase = parseSegmentList(xpp, null);
       } else if (ParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, baseUrl, null);
+        segmentBase = parseSegmentTemplate(xpp, null);
       }
     } while (!ParserUtil.isEndTag(xpp, "Period"));
 
@@ -261,11 +261,11 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (ParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
         audioChannels = parseAudioChannelConfiguration(xpp);
       } else if (ParserUtil.isStartTag(xpp, "SegmentBase")) {
-        segmentBase = parseSegmentBase(xpp, baseUrl, (SingleSegmentBase) segmentBase);
+        segmentBase = parseSegmentBase(xpp, (SingleSegmentBase) segmentBase);
       } else if (ParserUtil.isStartTag(xpp, "SegmentList")) {
-        segmentBase = parseSegmentList(xpp, baseUrl, (SegmentList) segmentBase);
+        segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (ParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, baseUrl, (SegmentTemplate) segmentBase);
+        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
       } else if (ParserUtil.isStartTag(xpp)) {
         parseAdaptationSetChild(xpp);
       }
@@ -387,11 +387,11 @@ protected Representation parseRepresentation(XmlPullParser xpp, String baseUrl,
       } else if (ParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
         audioChannels = parseAudioChannelConfiguration(xpp);
       } else if (ParserUtil.isStartTag(xpp, "SegmentBase")) {
-        segmentBase = parseSegmentBase(xpp, baseUrl, (SingleSegmentBase) segmentBase);
+        segmentBase = parseSegmentBase(xpp, (SingleSegmentBase) segmentBase);
       } else if (ParserUtil.isStartTag(xpp, "SegmentList")) {
-        segmentBase = parseSegmentList(xpp, baseUrl, (SegmentList) segmentBase);
+        segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (ParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, baseUrl, (SegmentTemplate) segmentBase);
+        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
       } else if (ParserUtil.isStartTag(xpp, "ContentProtection")) {
         ContentProtection contentProtection = parseContentProtection(xpp);
         if (contentProtection != null) {
@@ -403,7 +403,7 @@ protected Representation parseRepresentation(XmlPullParser xpp, String baseUrl,
     Format format = buildFormat(id, mimeType, width, height, frameRate, audioChannels,
         audioSamplingRate, bandwidth, language, codecs);
     return buildRepresentation(contentId, -1, format,
-        segmentBase != null ? segmentBase : new SingleSegmentBase(baseUrl));
+        segmentBase != null ? segmentBase : new SingleSegmentBase(), baseUrl);
   }
 
   protected Format buildFormat(String id, String mimeType, int width, int height, float frameRate,
@@ -413,14 +413,14 @@ protected Format buildFormat(String id, String mimeType, int width, int height,
   }
 
   protected Representation buildRepresentation(String contentId, int revisionId, Format format,
-      SegmentBase segmentBase) {
-    return Representation.newInstance(contentId, revisionId, format, segmentBase);
+      SegmentBase segmentBase, String baseUrl) {
+    return Representation.newInstance(contentId, revisionId, format, baseUrl, segmentBase, null);
   }
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
 
-  protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, String baseUrl,
-      SingleSegmentBase parent) throws XmlPullParserException, IOException {
+  protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, SingleSegmentBase parent)
+      throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
@@ -439,21 +439,21 @@ protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, String baseUrl,
     do {
       xpp.next();
       if (ParserUtil.isStartTag(xpp, "Initialization")) {
-        initialization = parseInitialization(xpp, baseUrl);
+        initialization = parseInitialization(xpp);
       }
     } while (!ParserUtil.isEndTag(xpp, "SegmentBase"));
 
-    return buildSingleSegmentBase(initialization, timescale, presentationTimeOffset, baseUrl,
+    return buildSingleSegmentBase(initialization, timescale, presentationTimeOffset,
         indexStart, indexLength);
   }
 
   protected SingleSegmentBase buildSingleSegmentBase(RangedUri initialization, long timescale,
-      long presentationTimeOffset, String baseUrl, long indexStart, long indexLength) {
-    return new SingleSegmentBase(initialization, timescale, presentationTimeOffset, baseUrl,
-        indexStart, indexLength);
+      long presentationTimeOffset, long indexStart, long indexLength) {
+    return new SingleSegmentBase(initialization, timescale, presentationTimeOffset, indexStart,
+        indexLength);
   }
 
-  protected SegmentList parseSegmentList(XmlPullParser xpp, String baseUrl, SegmentList parent)
+  protected SegmentList parseSegmentList(XmlPullParser xpp, SegmentList parent)
       throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
@@ -469,14 +469,14 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, String baseUrl, Segmen
     do {
       xpp.next();
       if (ParserUtil.isStartTag(xpp, "Initialization")) {
-        initialization = parseInitialization(xpp, baseUrl);
+        initialization = parseInitialization(xpp);
       } else if (ParserUtil.isStartTag(xpp, "SegmentTimeline")) {
         timeline = parseSegmentTimeline(xpp);
       } else if (ParserUtil.isStartTag(xpp, "SegmentURL")) {
         if (segments == null) {
           segments = new ArrayList<>();
         }
-        segments.add(parseSegmentUrl(xpp, baseUrl));
+        segments.add(parseSegmentUrl(xpp));
       }
     } while (!ParserUtil.isEndTag(xpp, "SegmentList"));
 
@@ -497,8 +497,8 @@ protected SegmentList buildSegmentList(RangedUri initialization, long timescale,
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl,
-      SegmentTemplate parent) throws XmlPullParserException, IOException {
+  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplate parent)
+      throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
@@ -516,7 +516,7 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl
     do {
       xpp.next();
       if (ParserUtil.isStartTag(xpp, "Initialization")) {
-        initialization = parseInitialization(xpp, baseUrl);
+        initialization = parseInitialization(xpp);
       } else if (ParserUtil.isStartTag(xpp, "SegmentTimeline")) {
         timeline = parseSegmentTimeline(xpp);
       }
@@ -528,15 +528,15 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl
     }
 
     return buildSegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
+        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
   }
 
   protected SegmentTemplate buildSegmentTemplate(RangedUri initialization, long timescale,
       long presentationTimeOffset, int startNumber, long duration,
       List<SegmentTimelineElement> timeline, UrlTemplate initializationTemplate,
-      UrlTemplate mediaTemplate, String baseUrl) {
+      UrlTemplate mediaTemplate) {
     return new SegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
+        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
   }
 
   protected List<SegmentTimelineElement> parseSegmentTimeline(XmlPullParser xpp)
@@ -571,15 +571,15 @@ protected UrlTemplate parseUrlTemplate(XmlPullParser xpp, String name,
     return defaultValue;
   }
 
-  protected RangedUri parseInitialization(XmlPullParser xpp, String baseUrl) {
-    return parseRangedUrl(xpp, baseUrl, "sourceURL", "range");
+  protected RangedUri parseInitialization(XmlPullParser xpp) {
+    return parseRangedUrl(xpp, "sourceURL", "range");
   }
 
-  protected RangedUri parseSegmentUrl(XmlPullParser xpp, String baseUrl) {
-    return parseRangedUrl(xpp, baseUrl, "media", "mediaRange");
+  protected RangedUri parseSegmentUrl(XmlPullParser xpp) {
+    return parseRangedUrl(xpp, "media", "mediaRange");
   }
 
-  protected RangedUri parseRangedUrl(XmlPullParser xpp, String baseUrl, String urlAttribute,
+  protected RangedUri parseRangedUrl(XmlPullParser xpp, String urlAttribute,
       String rangeAttribute) {
     String urlText = xpp.getAttributeValue(null, urlAttribute);
     long rangeStart = 0;
@@ -592,12 +592,11 @@ protected RangedUri parseRangedUrl(XmlPullParser xpp, String baseUrl, String url
         rangeLength = Long.parseLong(rangeTextArray[1]) - rangeStart + 1;
       }
     }
-    return buildRangedUri(baseUrl, urlText, rangeStart, rangeLength);
+    return buildRangedUri(urlText, rangeStart, rangeLength);
   }
 
-  protected RangedUri buildRangedUri(String baseUrl, String urlText, long rangeStart,
-      long rangeLength) {
-    return new RangedUri(baseUrl, urlText, rangeStart, rangeLength);
+  protected RangedUri buildRangedUri(String urlText, long rangeStart, long rangeLength) {
+    return new RangedUri(urlText, rangeStart, rangeLength);
   }
 
   // AudioChannelConfiguration parsing.
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java
index 121cc9fe62..1ac6b76ca7 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java
@@ -16,11 +16,10 @@
 package com.google.android.exoplayer.dash.mpd;
 
 import android.net.Uri;
-import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.UriUtil;
 
 /**
- * Defines a range of data located at a {@link Uri}.
+ * Defines a range of data located at a reference uri.
  */
 public final class RangedUri {
 
@@ -34,12 +33,6 @@
    */
   public final long length;
 
-  // The URI is stored internally in two parts: reference URI and a base URI to use when
-  // resolving it. This helps optimize memory usage in the same way that DASH manifests allow many
-  // URLs to be expressed concisely in the form of a single BaseURL and many relative paths. Note
-  // that this optimization relies on the same object being passed as the base URI to many
-  // instances of this class.
-  private final String baseUri;
   private final String referenceUri;
 
   private int hashCode;
@@ -47,57 +40,57 @@
   /**
    * Constructs an ranged uri.
    *
-   * @param baseUri A uri that can form the base of the uri defined by the instance.
-   * @param referenceUri A reference uri that should be resolved with respect to {@code baseUri}.
+   * @param referenceUri The reference uri.
    * @param start The (zero based) index of the first byte of the range.
    * @param length The length of the range, or -1 to indicate that the range is unbounded.
    */
-  public RangedUri(String baseUri, String referenceUri, long start, long length) {
-    Assertions.checkArgument(baseUri != null || referenceUri != null);
-    this.baseUri = baseUri;
-    this.referenceUri = referenceUri;
+  public RangedUri(String referenceUri, long start, long length) {
+    this.referenceUri = referenceUri == null ? "" : referenceUri;
     this.start = start;
     this.length = length;
   }
 
   /**
-   * Returns the {@link Uri} represented by the instance.
+   * Returns the resolved {@link Uri} represented by the instance.
    *
-   * @return The {@link Uri} represented by the instance.
+   * @param baseUri The base Uri.
+   * @return The resolved {@link Uri} represented by the instance.
    */
-  public Uri getUri() {
+  public Uri resolveUri(String baseUri) {
     return UriUtil.resolveToUri(baseUri, referenceUri);
   }
 
   /**
-   * Returns the uri represented by the instance as a string.
+   * Returns the resolve uri represented by the instance as a string.
    *
-   * @return The uri represented by the instance.
+   * @param baseUri The base uri.
+   * @return The resolved uri represented by the instance.
    */
-  public String getUriString() {
+  public String resolveUriString(String baseUri) {
     return UriUtil.resolve(baseUri, referenceUri);
   }
 
   /**
-   * Attempts to merge this {@link RangedUri} with another.
+   * Attempts to merge this {@link RangedUri} with another and an optional common base uri.
    * <p>
-   * A merge is successful if both instances define the same {@link Uri}, and if one starte the
-   * byte after the other ends, forming a contiguous region with no overlap.
+   * A merge is successful if both instances define the same {@link Uri} after resolution with the
+   * base Uri, and if one starts the byte after the other ends, forming a contiguous region with
+   * no overlap.
    * <p>
    * If {@code other} is null then the merge is considered unsuccessful, and null is returned.
    *
    * @param other The {@link RangedUri} to merge.
+   * @param baseUri The optional base uri.
    * @return The merged {@link RangedUri} if the merge was successful. Null otherwise.
    */
-  public RangedUri attemptMerge(RangedUri other) {
-    if (other == null || !getUriString().equals(other.getUriString())) {
+  public RangedUri attemptMerge(RangedUri other, String baseUri) {
+    final String resolvedUri = resolveUriString(baseUri);
+    if (other == null || !resolvedUri.equals(other.resolveUriString(baseUri))) {
       return null;
     } else if (length != -1 && start + length == other.start) {
-      return new RangedUri(baseUri, referenceUri, start,
-          other.length == -1 ? -1 : length + other.length);
+      return new RangedUri(resolvedUri, start, other.length == -1 ? -1 : length + other.length);
     } else if (other.length != -1 && other.start + other.length == start) {
-      return new RangedUri(baseUri, referenceUri, other.start,
-          length == -1 ? -1 : other.length + length);
+      return new RangedUri(resolvedUri, other.start, length == -1 ? -1 : other.length + length);
     } else {
       return null;
     }
@@ -109,7 +102,7 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (int) start;
       result = 31 * result + (int) length;
-      result = 31 * result + getUriString().hashCode();
+      result = 31 * result + referenceUri.hashCode();
       hashCode = result;
     }
     return hashCode;
@@ -126,7 +119,6 @@ public boolean equals(Object obj) {
     RangedUri other = (RangedUri) obj;
     return this.start == other.start
         && this.length == other.length
-        && getUriString().equals(other.getUriString());
+        && this.referenceUri.equals(other.referenceUri);
   }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
index 0da4bcf40e..2fbe709219 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
@@ -51,6 +51,10 @@
    * The offset of the presentation timestamps in the media stream relative to media time.
    */
   public final long presentationTimeOffsetUs;
+  /**
+   * The base URL of the representation.
+   */
+  public final String baseUrl;
 
   private final String cacheKey;
   private final RangedUri initializationUri;
@@ -61,12 +65,13 @@
    * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
+   * @param baseUrl A base URL.
    * @param segmentBase A segment base element for the representation.
    * @return The constructed instance.
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase) {
-    return newInstance(contentId, revisionId, format, segmentBase, null);
+      String baseUrl, SegmentBase segmentBase) {
+    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, null);
   }
 
   /**
@@ -75,18 +80,19 @@ public static Representation newInstance(String contentId, long revisionId, Form
    * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
+   * @param baseUrl The base URL of the representation.
    * @param segmentBase A segment base element for the representation.
    * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
    * @return The constructed instance.
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase, String customCacheKey) {
+      String baseUrl, SegmentBase segmentBase, String customCacheKey) {
     if (segmentBase instanceof SingleSegmentBase) {
       return new SingleSegmentRepresentation(contentId, revisionId, format,
-          (SingleSegmentBase) segmentBase, customCacheKey, -1);
+          (SingleSegmentBase) segmentBase, customCacheKey, -1, baseUrl);
     } else if (segmentBase instanceof MultiSegmentBase) {
       return new MultiSegmentRepresentation(contentId, revisionId, format,
-          (MultiSegmentBase) segmentBase, customCacheKey);
+          (MultiSegmentBase) segmentBase, customCacheKey, baseUrl);
     } else {
       throw new IllegalArgumentException("segmentBase must be of type SingleSegmentBase or "
           + "MultiSegmentBase");
@@ -94,7 +100,7 @@ public static Representation newInstance(String contentId, long revisionId, Form
   }
 
   private Representation(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase, String customCacheKey) {
+      String baseUrl, SegmentBase segmentBase, String customCacheKey) {
     this.contentId = contentId;
     this.revisionId = revisionId;
     this.format = format;
@@ -102,6 +108,7 @@ private Representation(String contentId, long revisionId, Format format,
         : contentId + "." + format.id + "." + revisionId;
     initializationUri = segmentBase.getInitialization(this);
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
+    this.baseUrl = baseUrl;
   }
 
   @Override
@@ -178,12 +185,12 @@ public String getCacheKey() {
     public static SingleSegmentRepresentation newInstance(String contentId, long revisionId,
         Format format, String uri, long initializationStart, long initializationEnd,
         long indexStart, long indexEnd, String customCacheKey, long contentLength) {
-      RangedUri rangedUri = new RangedUri(uri, null, initializationStart,
+      RangedUri rangedUri = new RangedUri("", initializationStart,
           initializationEnd - initializationStart + 1);
-      SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, uri, indexStart,
+      SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, indexStart,
           indexEnd - indexStart + 1);
       return new SingleSegmentRepresentation(contentId, revisionId,
-          format, segmentBase, customCacheKey, contentLength);
+          format, segmentBase, customCacheKey, contentLength, uri);
     }
 
     /**
@@ -195,15 +202,15 @@ public static SingleSegmentRepresentation newInstance(String contentId, long rev
      * @param contentLength The content length, or -1 if unknown.
      */
     public SingleSegmentRepresentation(String contentId, long revisionId, Format format,
-        SingleSegmentBase segmentBase, String customCacheKey, long contentLength) {
-      super(contentId, revisionId, format, segmentBase, customCacheKey);
-      this.uri = Uri.parse(segmentBase.uri);
+        SingleSegmentBase segmentBase, String customCacheKey, long contentLength, String baseUrl) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, customCacheKey);
+      this.uri = Uri.parse(baseUrl);
       this.indexUri = segmentBase.getIndex();
       this.contentLength = contentLength;
       // If we have an index uri then the index is defined externally, and we shouldn't return one
       // directly. If we don't, then we can't do better than an index defining a single segment.
       segmentIndex = indexUri != null ? null
-          : new DashSingleSegmentIndex(new RangedUri(segmentBase.uri, null, 0, contentLength));
+          : new DashSingleSegmentIndex(new RangedUri("", 0, contentLength));
     }
 
     @Override
@@ -234,8 +241,8 @@ public DashSegmentIndex getIndex() {
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      */
     public MultiSegmentRepresentation(String contentId, long revisionId, Format format,
-        MultiSegmentBase segmentBase, String customCacheKey) {
-      super(contentId, revisionId, format, segmentBase, customCacheKey);
+        MultiSegmentBase segmentBase, String customCacheKey, String baseUrl) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, customCacheKey);
       this.segmentBase = segmentBase;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
index bc68f39b65..c4f9d9796f 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
@@ -66,12 +66,6 @@ public long getPresentationTimeOffsetUs() {
    * A {@link SegmentBase} that defines a single segment.
    */
   public static class SingleSegmentBase extends SegmentBase {
-
-    /**
-     * The uri of the segment.
-     */
-    public final String uri;
-
     /* package */ final long indexStart;
     /* package */ final long indexLength;
 
@@ -81,27 +75,22 @@ public long getPresentationTimeOffsetUs() {
      * @param timescale The timescale in units per second.
      * @param presentationTimeOffset The presentation time offset. The value in seconds is the
      *     division of this value and {@code timescale}.
-     * @param uri The uri of the segment.
      * @param indexStart The byte offset of the index data in the segment.
      * @param indexLength The length of the index data in bytes.
      */
     public SingleSegmentBase(RangedUri initialization, long timescale, long presentationTimeOffset,
-        String uri, long indexStart, long indexLength) {
+        long indexStart, long indexLength) {
       super(initialization, timescale, presentationTimeOffset);
-      this.uri = uri;
       this.indexStart = indexStart;
       this.indexLength = indexLength;
     }
 
-    /**
-     * @param uri The uri of the segment.
-     */
-    public SingleSegmentBase(String uri) {
-      this(null, 1, 0, uri, 0, -1);
+    public SingleSegmentBase() {
+      this(null, 1, 0, 0, -1);
     }
 
     public RangedUri getIndex() {
-      return indexLength <= 0 ? null : new RangedUri(uri, null, indexStart, indexLength);
+      return indexLength <= 0 ? null : new RangedUri(null, indexStart, indexLength);
     }
 
   }
@@ -281,8 +270,6 @@ public boolean isExplicit() {
     /* package */ final UrlTemplate initializationTemplate;
     /* package */ final UrlTemplate mediaTemplate;
 
-    private final String baseUrl;
-
     /**
      * @param initialization A {@link RangedUri} corresponding to initialization data, if such data
      *     exists. The value of this parameter is ignored if {@code initializationTemplate} is
@@ -301,16 +288,14 @@ public boolean isExplicit() {
      *     such data exists. If non-null then the {@code initialization} parameter is ignored. If
      *     null then {@code initialization} will be used.
      * @param mediaTemplate A template defining the location of each media segment.
-     * @param baseUrl A url to use as the base for relative urls generated by the templates.
      */
     public SegmentTemplate(RangedUri initialization, long timescale, long presentationTimeOffset,
         int startNumber, long duration, List<SegmentTimelineElement> segmentTimeline,
-        UrlTemplate initializationTemplate, UrlTemplate mediaTemplate, String baseUrl) {
+        UrlTemplate initializationTemplate, UrlTemplate mediaTemplate) {
       super(initialization, timescale, presentationTimeOffset, startNumber,
           duration, segmentTimeline);
       this.initializationTemplate = initializationTemplate;
       this.mediaTemplate = mediaTemplate;
-      this.baseUrl = baseUrl;
     }
 
     @Override
@@ -318,7 +303,7 @@ public RangedUri getInitialization(Representation representation) {
       if (initializationTemplate != null) {
         String urlString = initializationTemplate.buildUri(representation.format.id, 0,
             representation.format.bitrate, 0);
-        return new RangedUri(baseUrl, urlString, 0, -1);
+        return new RangedUri(urlString, 0, -1);
       } else {
         return super.getInitialization(representation);
       }
@@ -334,7 +319,7 @@ public RangedUri getSegmentUrl(Representation representation, int sequenceNumber
       }
       String uriString = mediaTemplate.buildUri(representation.format.id, sequenceNumber,
           representation.format.bitrate, time);
-      return new RangedUri(baseUrl, uriString, 0, -1);
+      return new RangedUri(uriString, 0, -1);
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 67f6bbf516..0d5270d2e1 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -52,6 +52,7 @@
   public static final int TYPE_d263 = Util.getIntegerCodeForString("d263");
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
+  public static final int TYPE__mp3 = Util.getIntegerCodeForString(".mp3");
   public static final int TYPE_wave = Util.getIntegerCodeForString("wave");
   public static final int TYPE_lpcm = Util.getIntegerCodeForString("lpcm");
   public static final int TYPE_sowt = Util.getIntegerCodeForString("sowt");
@@ -132,6 +133,7 @@
   public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
   public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
+  public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
   public static final int TYPE_DASHES = Util.getIntegerCodeForString("----");
 
   public final int type;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index a4afbce611..2740a16beb 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -58,7 +58,8 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
     int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
     if (trackType != Track.TYPE_soun && trackType != Track.TYPE_vide && trackType != Track.TYPE_text
-        && trackType != Track.TYPE_sbtl && trackType != Track.TYPE_subt) {
+        && trackType != Track.TYPE_sbtl && trackType != Track.TYPE_subt
+        && trackType != Track.TYPE_meta) {
       return null;
     }
 
@@ -584,7 +585,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
           || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
           || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
           || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
-          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt) {
+          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt
+          || childAtomType == Atom.TYPE__mp3) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             durationUs, language, isQuickTime, out, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
@@ -600,6 +602,9 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
         out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
             MimeTypes.APPLICATION_TTML, MediaFormat.NO_VALUE, durationUs, language,
             0 /* subsample timing is absolute */);
+      } else if (childAtomType == Atom.TYPE_camm) {
+        out.mediaFormat = MediaFormat.createFormatForMimeType(Integer.toString(trackId),
+            MimeTypes.APPLICATION_CAMERA_MOTION, MediaFormat.NO_VALUE, durationUs);
       }
       stsd.setPosition(childStartPosition + childAtomSize);
     }
@@ -876,6 +881,8 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_AMR_WB;
     } else if (atomType == Atom.TYPE_lpcm || atomType == Atom.TYPE_sowt) {
       mimeType = MimeTypes.AUDIO_RAW;
+    } else if (atomType == Atom.TYPE__mp3) {
+      mimeType = MimeTypes.AUDIO_MPEG;
     }
 
     byte[] initializationData = null;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
index 1459e71a31..84c43a2fd3 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
@@ -29,6 +29,7 @@
   public static final int TYPE_text = Util.getIntegerCodeForString("text");
   public static final int TYPE_sbtl = Util.getIntegerCodeForString("sbtl");
   public static final int TYPE_subt = Util.getIntegerCodeForString("subt");
+  public static final int TYPE_meta = Util.getIntegerCodeForString("meta");
 
   /**
    * The track identifier.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index 2ee6a54061..5cefb86633 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.ts;
 
+import android.util.Log;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
@@ -25,6 +26,8 @@
  */
 /* package */ final class Id3Reader extends ElementaryStreamReader {
 
+  private static final String TAG = "Id3Reader";
+
   private static final int ID3_HEADER_SIZE = 10;
 
   private final ParsableByteArray id3Header;
@@ -72,7 +75,14 @@ public void consume(ParsableByteArray data) {
           headerBytesAvailable);
       if (sampleBytesRead + headerBytesAvailable == ID3_HEADER_SIZE) {
         // We've finished reading the ID3 header. Extract the sample size.
-        id3Header.setPosition(6); // 'ID3' (3) + version (2) + flags (1)
+        id3Header.setPosition(0);
+        if ('I' != id3Header.readUnsignedByte() || 'D' != id3Header.readUnsignedByte()
+            || '3' != id3Header.readUnsignedByte()) {
+          Log.w(TAG, "Discarding invalid ID3 tag");
+          writingSample = false;
+          return;
+        }
+        id3Header.skipBytes(3); // version (2) + flags (1)
         sampleSize = ID3_HEADER_SIZE + id3Header.readSynchSafeInt();
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 8a6fbc5fb5..d8c4753202 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -41,7 +41,7 @@
   public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
   public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
   public static final int WORKAROUND_DETECT_ACCESS_UNITS = 8;
-  public static final int WORKAROUND_MAP_BY_TYPE = 16;
+  public static final int WORKAROUND_HLS_MODE = 16;
 
   private static final String TAG = "TsExtractor";
 
@@ -191,16 +191,22 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     tsScratch.skipBits(2); // transport_scrambling_control
     boolean adaptationFieldExists = tsScratch.readBit();
     boolean payloadExists = tsScratch.readBit();
+
+    // Discontinuity check.
     boolean discontinuityFound = false;
     int continuityCounter = tsScratch.readBits(4);
-    int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
-    continuityCounters.put(pid, continuityCounter);
-    if (previousCounter == continuityCounter) {
-      // Duplicate packet found.
-      tsPacketBuffer.setPosition(endOfPacket);
-      return RESULT_CONTINUE;
-    } else if (continuityCounter != (previousCounter + 1) % 16) {
-      discontinuityFound = true;
+    if ((workaroundFlags & WORKAROUND_HLS_MODE) == 0) {
+      int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+      continuityCounters.put(pid, continuityCounter);
+      if (previousCounter == continuityCounter) {
+        if (payloadExists) {
+          // Duplicate packet found.
+          tsPacketBuffer.setPosition(endOfPacket);
+          return RESULT_CONTINUE;
+        }
+      } else if (continuityCounter != (previousCounter + 1) % 16) {
+        discontinuityFound = true;
+      }
     }
 
     // Skip the adaptation field.
@@ -408,7 +414,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       // Skip the descriptors.
       sectionData.skipBytes(programInfoLength);
 
-      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 && id3Reader == null) {
+      if ((workaroundFlags & WORKAROUND_HLS_MODE) != 0 && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See b/20261500.
         id3Reader = new Id3Reader(output.track(TS_STREAM_TYPE_ID3));
@@ -430,7 +436,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           sectionData.skipBytes(esInfoLength);
         }
         remainingEntriesLength -= esInfoLength + 5;
-        int trackId = (workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 ? streamType : elementaryPid;
+        int trackId = (workaroundFlags & WORKAROUND_HLS_MODE) != 0 ? streamType : elementaryPid;
         if (trackIds.get(trackId)) {
           continue;
         }
@@ -471,7 +477,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
                 new SeiReader(output.track(nextEmbeddedTrackId++)));
             break;
           case TS_STREAM_TYPE_ID3:
-            if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
+            if ((workaroundFlags & WORKAROUND_HLS_MODE) != 0) {
               pesPayloadReader = id3Reader;
             } else {
               pesPayloadReader = new Id3Reader(output.track(nextEmbeddedTrackId++));
@@ -488,7 +494,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
               new PesReader(pesPayloadReader, ptsTimestampAdjuster));
         }
       }
-      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
+      if ((workaroundFlags & WORKAROUND_HLS_MODE) != 0) {
        if (!tracksEnded) {
          output.endTracks();
        }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index df981d6683..025a6d14e2 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -513,8 +513,8 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
         // The master source has yet to instantiate an adjuster for the discontinuity sequence.
         return;
       }
-      // This flag ensures the change of pid between streams does not affect the sample queues.
-      int workaroundFlags = TsExtractor.WORKAROUND_MAP_BY_TYPE;
+      // Enable HLS workarounds for the extractor.
+      int workaroundFlags = TsExtractor.WORKAROUND_HLS_MODE;
       String codecs = format.codecs;
       if (!TextUtils.isEmpty(codecs)) {
         // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
@@ -694,6 +694,10 @@ private int getLiveNextChunkSequenceNumber(int previousChunkIndex, int oldVarian
     }
     HlsMediaPlaylist oldMediaPlaylist = variantPlaylists[oldVariantIndex];
     HlsMediaPlaylist newMediaPlaylist = variantPlaylists[newVariantIndex];
+    if (previousChunkIndex < oldMediaPlaylist.mediaSequence) {
+      // We have fallen behind the live window.
+      return newMediaPlaylist.mediaSequence - 1;
+    }
     double offsetToLiveInstantSecs = 0;
     for (int i = previousChunkIndex - oldMediaPlaylist.mediaSequence;
          i < oldMediaPlaylist.segments.size(); i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
index 314ff9f6ec..6f49a8c759 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
@@ -68,7 +68,7 @@ public TsChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format for
     this.extractorWrapper = extractorWrapper;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
-    adjustedEndTimeUs = startTimeUs;
+    adjustedEndTimeUs = endTimeUs;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
index d4b0ea511e..81d663ee6e 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
@@ -35,9 +35,9 @@
 
   private static final String TAG = "SubripParser";
 
-  private static final Pattern SUBRIP_TIMING_LINE = Pattern.compile("(\\S*)\\s*-->\\s*(\\S*)");
-  private static final Pattern SUBRIP_TIMESTAMP =
-      Pattern.compile("(?:(\\d+):)?(\\d+):(\\d+),(\\d+)");
+  private static final String SUBRIP_TIMECODE = "(?:(\\d+):)?(\\d+):(\\d+),(\\d+)";
+  private static final Pattern SUBRIP_TIMING_LINE =
+      Pattern.compile("\\s*(" + SUBRIP_TIMECODE + ")\\s*-->\\s*(" + SUBRIP_TIMECODE + ")?\\s*");
 
   private final StringBuilder textBuilder;
 
@@ -56,7 +56,6 @@ public SubripSubtitle parse(byte[] bytes, int offset, int length) {
     LongArray cueTimesUs = new LongArray();
     ParsableByteArray subripData = new ParsableByteArray(bytes, offset + length);
     subripData.setPosition(offset);
-    boolean haveEndTimecode;
     String currentLine;
 
     while ((currentLine = subripData.readLine()) != null) {
@@ -74,15 +73,14 @@ public SubripSubtitle parse(byte[] bytes, int offset, int length) {
       }
 
       // Read and parse the timing line.
-      haveEndTimecode = false;
+      boolean haveEndTimecode = false;
       currentLine = subripData.readLine();
       Matcher matcher = SUBRIP_TIMING_LINE.matcher(currentLine);
-      if (matcher.find()) {
-        cueTimesUs.add(parseTimecode(matcher.group(1)));
-        String endTimecode = matcher.group(2);
-        if (!TextUtils.isEmpty(endTimecode)) {
+      if (matcher.matches()) {
+        cueTimesUs.add(parseTimecode(matcher, 1));
+        if (!TextUtils.isEmpty(matcher.group(6))) {
           haveEndTimecode = true;
-          cueTimesUs.add(parseTimecode(matcher.group(2)));
+          cueTimesUs.add(parseTimecode(matcher, 6));
         }
       } else {
         Log.w(TAG, "Skipping invalid timing: " + currentLine);
@@ -111,15 +109,11 @@ public SubripSubtitle parse(byte[] bytes, int offset, int length) {
     return new SubripSubtitle(cuesArray, cueTimesUsArray);
   }
 
-  private static long parseTimecode(String s) throws NumberFormatException {
-    Matcher matcher = SUBRIP_TIMESTAMP.matcher(s);
-    if (!matcher.matches()) {
-      throw new NumberFormatException("has invalid format");
-    }
-    long timestampMs = Long.parseLong(matcher.group(1)) * 60 * 60 * 1000;
-    timestampMs += Long.parseLong(matcher.group(2)) * 60 * 1000;
-    timestampMs += Long.parseLong(matcher.group(3)) * 1000;
-    timestampMs += Long.parseLong(matcher.group(4));
+  private static long parseTimecode(Matcher matcher, int groupOffset) {
+    long timestampMs = Long.parseLong(matcher.group(groupOffset + 1)) * 60 * 60 * 1000;
+    timestampMs += Long.parseLong(matcher.group(groupOffset + 2)) * 60 * 1000;
+    timestampMs += Long.parseLong(matcher.group(groupOffset + 3)) * 1000;
+    timestampMs += Long.parseLong(matcher.group(groupOffset + 4));
     return timestampMs * 1000;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/Cache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/Cache.java
index a818520282..15d7f73b17 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/Cache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/Cache.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.upstream.cache;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.NavigableSet;
 import java.util.Set;
 
@@ -27,7 +28,7 @@
   /**
    * Interface definition for a callback to be notified of {@link Cache} events.
    */
-  public interface Listener {
+  interface Listener {
 
     /**
      * Invoked when a {@link CacheSpan} is added to the cache.
@@ -60,6 +61,21 @@
     void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan);
 
   }
+  
+  /**
+   * Thrown when an error is encountered when writing data.
+   */
+  class CacheException extends IOException {
+
+    public CacheException(String message) {
+      super(message);
+    }
+
+    public CacheException(IOException cause) {
+      super(cause);
+    }
+
+  }
 
   /**
    * Registers a listener to listen for changes to a given key.
@@ -125,7 +141,7 @@
    * @return The {@link CacheSpan}.
    * @throws InterruptedException
    */
-  CacheSpan startReadWrite(String key, long position) throws InterruptedException;
+  CacheSpan startReadWrite(String key, long position) throws InterruptedException, CacheException;
 
   /**
    * Same as {@link #startReadWrite(String, long)}. However, if the cache entry is locked, then
@@ -135,7 +151,7 @@
    * @param position The position of the data being requested.
    * @return The {@link CacheSpan}. Or null if the cache entry is locked.
    */
-  CacheSpan startReadWriteNonBlocking(String key, long position);
+  CacheSpan startReadWriteNonBlocking(String key, long position) throws CacheException;
 
   /**
    * Obtains a cache file into which data can be written. Must only be called when holding a
@@ -147,7 +163,7 @@
    *     space in the cache.
    * @return The file into which data should be written.
    */
-  File startFile(String key, long position, long length);
+  File startFile(String key, long position, long length) throws CacheException;
 
   /**
    * Commits a file into the cache. Must only be called when holding a corresponding hole
@@ -155,7 +171,7 @@
    *
    * @param file A newly written cache file.
    */
-  void commitFile(File file);
+  void commitFile(File file) throws CacheException;
 
   /**
    * Releases a {@link CacheSpan} obtained from {@link #startReadWrite(String, long)} which
@@ -170,7 +186,7 @@
    *
    * @param span The {@link CacheSpan} to remove.
    */
-  void removeSpan(CacheSpan span);
+  void removeSpan(CacheSpan span) throws CacheException;
 
  /**
   * Queries if a range is entirely available in the cache.
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
index 1cf517ca24..979bd2beeb 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
@@ -18,12 +18,14 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.upstream.DataSink;
 import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ReusableBufferedOutputStream;
 import com.google.android.exoplayer.util.Util;
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 
 /**
  * Writes data into a cache.
@@ -32,17 +34,20 @@
 
   private final Cache cache;
   private final long maxCacheFileSize;
+  private final int bufferSize;
 
   private DataSpec dataSpec;
   private File file;
-  private FileOutputStream outputStream;
+  private OutputStream outputStream;
+  private FileOutputStream underlyingFileOutputStream;
   private long outputStreamBytesWritten;
   private long dataSpecBytesWritten;
+  private ReusableBufferedOutputStream bufferedOutputStream;
 
   /**
    * Thrown when IOException is encountered when writing data into sink.
    */
-  public static class CacheDataSinkException extends IOException {
+  public static class CacheDataSinkException extends CacheException {
 
     public CacheDataSinkException(IOException cause) {
       super(cause);
@@ -50,7 +55,6 @@ public CacheDataSinkException(IOException cause) {
 
   }
 
-
   /**
    * @param cache The cache into which data should be written.
    * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
@@ -58,8 +62,21 @@ public CacheDataSinkException(IOException cause) {
    *    multiple cache files.
    */
   public CacheDataSink(Cache cache, long maxCacheFileSize) {
+    this(cache, maxCacheFileSize, 0);
+  }
+
+  /**
+   * @param cache The cache into which data should be written.
+   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
+   *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
+   *    multiple cache files.
+   * @param bufferSize The buffer size in bytes for writing to a cache file. A zero or negative
+   *    value disables buffering.
+   */
+  public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
     this.cache = Assertions.checkNotNull(cache);
     this.maxCacheFileSize = maxCacheFileSize;
+    this.bufferSize = bufferSize;
   }
 
   @Override
@@ -72,7 +89,7 @@ public DataSink open(DataSpec dataSpec) throws CacheDataSinkException {
       dataSpecBytesWritten = 0;
       openNextOutputStream();
       return this;
-    } catch (FileNotFoundException e) {
+    } catch (IOException e) {
       throw new CacheDataSinkException(e);
     }
   }
@@ -107,13 +124,25 @@ public void close() throws CacheDataSinkException {
     }
   }
 
-  private void openNextOutputStream() throws FileNotFoundException {
+  private void openNextOutputStream() throws IOException {
     file = cache.startFile(dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten,
         Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize));
-    outputStream = new FileOutputStream(file);
+    underlyingFileOutputStream = new FileOutputStream(file);
+    if (bufferSize > 0) {
+      if (bufferedOutputStream == null) {
+        bufferedOutputStream = new ReusableBufferedOutputStream(underlyingFileOutputStream,
+            bufferSize);
+      } else {
+        bufferedOutputStream.reset(underlyingFileOutputStream);
+      }
+      outputStream = bufferedOutputStream;
+    } else {
+      outputStream = underlyingFileOutputStream;
+    }
     outputStreamBytesWritten = 0;
   }
 
+  @SuppressWarnings("ThrowFromFinallyBlock")
   private void closeCurrentOutputStream() throws IOException {
     if (outputStream == null) {
       return;
@@ -122,17 +151,18 @@ private void closeCurrentOutputStream() throws IOException {
     boolean success = false;
     try {
       outputStream.flush();
-      outputStream.getFD().sync();
+      underlyingFileOutputStream.getFD().sync();
       success = true;
     } finally {
       Util.closeQuietly(outputStream);
+      outputStream = null;
+      File fileToCommit = file;
+      file = null;
       if (success) {
-        cache.commitFile(file);
+        cache.commitFile(fileToCommit);
       } else {
-        file.delete();
+        fileToCommit.delete();
       }
-      outputStream = null;
-      file = null;
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
index 0887c90740..f50c1b3a80 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
@@ -23,7 +23,7 @@
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.upstream.FileDataSource;
 import com.google.android.exoplayer.upstream.TeeDataSource;
-import com.google.android.exoplayer.upstream.cache.CacheDataSink.CacheDataSinkException;
+import com.google.android.exoplayer.upstream.cache.Cache.CacheException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 
@@ -239,7 +239,7 @@ private void closeCurrentSource() throws IOException {
 
   private void handleBeforeThrow(IOException exception) {
     if (ignoreCacheOnError && (currentDataSource == cacheReadDataSource
-        || exception instanceof CacheDataSinkException)) {
+        || exception instanceof CacheException)) {
       // Ignore the cache from now on.
       ignoreCache = true;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java
index 5d3421899d..6211e7f1af 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java
@@ -21,7 +21,7 @@
  */
 public interface CacheEvictor extends Cache.Listener {
 
-  /** Invoked when cache has beeen initialized. */
+  /** Invoked when cache has been initialized. */
   void onCacheInitialized();
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
index 2d872c4df9..89a2b92c22 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
@@ -15,21 +15,13 @@
  */
 package com.google.android.exoplayer.upstream.cache;
 
-import com.google.android.exoplayer.util.Util;
+import com.google.android.exoplayer.C;
 import java.io.File;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * Defines a span of data that may or may not be cached (as indicated by {@link #isCached}).
  */
-public final class CacheSpan implements Comparable<CacheSpan> {
-
-  private static final String SUFFIX = ".v2.exo";
-  private static final Pattern CACHE_FILE_PATTERN_V1 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
-  private static final Pattern CACHE_FILE_PATTERN_V2 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
+public class CacheSpan implements Comparable<CacheSpan> {
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -40,7 +32,8 @@
    */
   public final long position;
   /**
-   * The length of the {@link CacheSpan}, or -1 if this is an open-ended hole.
+   * The length of the {@link CacheSpan}, or {@link C#LENGTH_UNBOUNDED} if this is an open-ended
+   * hole.
    */
   public final long length;
   /**
@@ -52,89 +45,54 @@
    */
   public final File file;
   /**
-   * The last access timestamp, or -1 if {@link #isCached} is false.
+   * The last access timestamp, or {@link C#UNKNOWN_TIME_US} if {@link #isCached} is false.
    */
   public final long lastAccessTimestamp;
 
-  public static File getCacheFileName(File cacheDir, String key, long offset,
-      long lastAccessTimestamp) {
-    return new File(cacheDir,
-        Util.escapeFileName(key) + "." + offset + "." + lastAccessTimestamp + SUFFIX);
-  }
-
-  public static CacheSpan createLookup(String key, long position) {
-    return new CacheSpan(key, position, -1, false, -1, null);
-  }
-
-  public static CacheSpan createOpenHole(String key, long position) {
-    return new CacheSpan(key, position, -1, false, -1, null);
-  }
-
-  public static CacheSpan createClosedHole(String key, long position, long length) {
-    return new CacheSpan(key, position, length, false, -1, null);
-  }
-
   /**
-   * Creates a cache span from an underlying cache file.
+   * Creates a hole CacheSpan which isn't cached, has no last access time and no file associated.
    *
-   * @param file The cache file.
-   * @return The span, or null if the file name is not correctly formatted.
+   * @param key The cache key that uniquely identifies the original stream.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNBOUNDED} if this is an
+   *     open-ended hole.
    */
-  public static CacheSpan createCacheEntry(File file) {
-    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(file.getName());
-    if (!matcher.matches()) {
-      return null;
-    }
-    String key = Util.unescapeFileName(matcher.group(1));
-    return key == null ? null : createCacheEntry(
-        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)), file);
+  public CacheSpan(String key, long position, long length) {
+    this(key, position, length, C.UNKNOWN_TIME_US, null);
   }
 
-  static File upgradeIfNeeded(File file) {
-    Matcher matcher = CACHE_FILE_PATTERN_V1.matcher(file.getName());
-    if (!matcher.matches()) {
-      return file;
-    }
-    String key = matcher.group(1); // Keys were not escaped in version 1.
-    File newCacheFile = getCacheFileName(file.getParentFile(), key,
-        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
-    file.renameTo(newCacheFile);
-    return newCacheFile;
-  }
-
-  private static CacheSpan createCacheEntry(String key, long position, long lastAccessTimestamp,
-      File file) {
-    return new CacheSpan(key, position, file.length(), true, lastAccessTimestamp, file);
-  }
-
-  // Visible for testing.
-  CacheSpan(String key, long position, long length, boolean isCached,
-      long lastAccessTimestamp, File file) {
+  /**
+   * Creates a CacheSpan.
+   *
+   * @param key The cache key that uniquely identifies the original stream.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNBOUNDED} if this is an
+   *     open-ended hole.
+   * @param lastAccessTimestamp The last access timestamp, or {@link C#UNKNOWN_TIME_US} if
+   *     {@link #isCached} is false.
+   * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
+   */
+  public CacheSpan(String key, long position, long length, long lastAccessTimestamp, File file) {
     this.key = key;
     this.position = position;
     this.length = length;
-    this.isCached = isCached;
+    this.isCached = file != null;
     this.file = file;
     this.lastAccessTimestamp = lastAccessTimestamp;
   }
 
   /**
-   * @return True if this is an open-ended {@link CacheSpan}. False otherwise.
+   * Returns whether this is an open-ended {@link CacheSpan}.
    */
-  public boolean isOpenEnded() {
-    return length == -1;
+  public final boolean isOpenEnded() {
+    return length == C.LENGTH_UNBOUNDED;
   }
 
   /**
-   * Renames the file underlying this cache span to update its last access time.
-   *
-   * @return A {@link CacheSpan} representing the updated cache file.
+   * Returns whether this is a hole {@link CacheSpan}.
    */
-  public CacheSpan touch() {
-    long now = System.currentTimeMillis();
-    File newCacheFile = getCacheFileName(file.getParentFile(), key, position, now);
-    file.renameTo(newCacheFile);
-    return CacheSpan.createCacheEntry(key, position, now, newCacheFile);
+  public final boolean isHoleSpan() {
+    return !isCached;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContent.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContent.java
new file mode 100644
index 0000000000..3a5f88eeb0
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContent.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream.cache;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer.util.Assertions;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.TreeSet;
+
+/**
+ * Defines the cached content for a single stream.
+ */
+/*package*/ final class CachedContent {
+
+  /**
+   * The cache file id that uniquely identifies the original stream.
+   */
+  public final int id;
+  /**
+   * The cache key that uniquely identifies the original stream.
+   */
+  public final String key;
+  /**
+   * The cached spans of this content.
+   */
+  private final TreeSet<SimpleCacheSpan> cachedSpans;
+  /**
+   * The length of the original stream, or {@link C#LENGTH_UNBOUNDED} if the length is unknown.
+   */
+  private long length;
+
+  /**
+   * Reads an instance from a {@link DataInputStream}.
+   *
+   * @param input Input stream containing values needed to initialize CachedContent instance.
+   * @throws IOException If an error occurs during reading values.
+   */
+  public CachedContent(DataInputStream input) throws IOException {
+    this(input.readInt(), input.readUTF(), input.readLong());
+  }
+
+  /**
+   * Creates a CachedContent.
+   *
+   * @param id The cache file id.
+   * @param key The cache stream key.
+   * @param length The length of the original stream.
+   */
+  public CachedContent(int id, String key, long length) {
+    this.id = id;
+    this.key = key;
+    this.length = length;
+    this.cachedSpans = new TreeSet<>();
+  }
+
+  /**
+   * Writes the instance to a {@link DataOutputStream}.
+   *
+   * @param output Output stream to store the values.
+   * @throws IOException If an error occurs during writing values to output.
+   */
+  public void writeToStream(DataOutputStream output) throws IOException {
+    output.writeInt(id);
+    output.writeUTF(key);
+    output.writeLong(length);
+  }
+
+  /** Returns the length of the content. */
+  public long getLength() {
+    return length;
+  }
+
+  /** Sets the length of the content. */
+  public void setLength(long length) {
+    this.length = length;
+  }
+
+  /** Adds the given {@link SimpleCacheSpan} which contains a part of the content. */
+  public void addSpan(SimpleCacheSpan span) {
+    cachedSpans.add(span);
+  }
+
+  /** Returns a set of all {@link SimpleCacheSpan}s. */
+  public TreeSet<SimpleCacheSpan> getSpans() {
+    return cachedSpans;
+  }
+
+  /**
+   * Returns the span containing the position. If there isn't one, it returns a hole span
+   * which defines the maximum extents of the hole in the cache.
+   */
+  public SimpleCacheSpan getSpan(long position) {
+    SimpleCacheSpan span = getSpanInternal(position);
+    if (!span.isCached) {
+      SimpleCacheSpan ceilEntry = cachedSpans.ceiling(span);
+      return ceilEntry == null ? SimpleCacheSpan.createOpenHole(key, position)
+          : SimpleCacheSpan.createClosedHole(key, position, ceilEntry.position - position);
+    }
+    return span;
+  }
+
+  /** Queries if a range is entirely available in the cache. */
+  public boolean isCached(long position, long length) {
+    SimpleCacheSpan floorSpan = getSpanInternal(position);
+    if (!floorSpan.isCached) {
+      // We don't have a span covering the start of the queried region.
+      return false;
+    }
+    long queryEndPosition = position + length;
+    long currentEndPosition = floorSpan.position + floorSpan.length;
+    if (currentEndPosition >= queryEndPosition) {
+      // floorSpan covers the queried region.
+      return true;
+    }
+    for (SimpleCacheSpan next : cachedSpans.tailSet(floorSpan, false)) {
+      if (next.position > currentEndPosition) {
+        // There's a hole in the cache within the queried region.
+        return false;
+      }
+      // We expect currentEndPosition to always equal (next.position + next.length), but
+      // perform a max check anyway to guard against the existence of overlapping spans.
+      currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
+      if (currentEndPosition >= queryEndPosition) {
+        // We've found spans covering the queried region.
+        return true;
+      }
+    }
+    // We ran out of spans before covering the queried region.
+    return false;
+  }
+
+  /**
+   * Copies the given span with an updated last access time. Passed span becomes invalid after this
+   * call.
+   *
+   * @param cacheSpan Span to be copied and updated.
+   * @return a span with the updated last access time.
+   * @throws CacheException If renaming of the underlying span file failed.
+   */
+  public SimpleCacheSpan touch(SimpleCacheSpan cacheSpan) throws CacheException {
+    // Remove the old span from the in-memory representation.
+    Assertions.checkState(cachedSpans.remove(cacheSpan));
+    // Obtain a new span with updated last access timestamp.
+    SimpleCacheSpan newCacheSpan = cacheSpan.copyWithUpdatedLastAccessTime(id);
+    // Rename the cache file
+    if (!cacheSpan.file.renameTo(newCacheSpan.file)) {
+      throw new CacheException("Renaming of " + cacheSpan.file + " to " + newCacheSpan.file
+          + " failed.");
+    }
+    // Add the updated span back into the in-memory representation.
+    cachedSpans.add(newCacheSpan);
+    return newCacheSpan;
+  }
+
+  /** Returns whether there are any spans cached. */
+  public boolean isEmpty() {
+    return cachedSpans.isEmpty();
+  }
+
+  /** Removes the given span from cache. */
+  public boolean removeSpan(CacheSpan span) {
+    if (cachedSpans.remove(span)) {
+      span.file.delete();
+      return true;
+    }
+    return false;
+  }
+
+  /** Calculates a hash code for the header of this {@code CachedContent}. */
+  public int headerHashCode() {
+    int result = id;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + (int) (length ^ (length >>> 32));
+    return result;
+  }
+
+  /**
+   * Returns the span containing the position. If there isn't one, it returns the lookup span it
+   * used for searching.
+   */
+  private SimpleCacheSpan getSpanInternal(long position) {
+    SimpleCacheSpan lookupSpan = SimpleCacheSpan.createLookup(key, position);
+    SimpleCacheSpan floorSpan = cachedSpans.floor(lookupSpan);
+    return floorSpan == null || floorSpan.position + floorSpan.length <= position ? lookupSpan
+        : floorSpan;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java
new file mode 100644
index 0000000000..cc70292f83
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream.cache;
+
+import android.util.Log;
+import android.util.SparseArray;
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.AtomicFile;
+import com.google.android.exoplayer.util.ReusableBufferedOutputStream;
+import com.google.android.exoplayer.util.Util;
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Set;
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * This class maintains the index of cached content.
+ */
+/*package*/ final class CachedContentIndex {
+
+  public static final String FILE_NAME = "cached_content_index.exi";
+
+  private static final int VERSION = 1;
+
+  private static final int FLAG_ENCRYPTED_INDEX = 1;
+
+  private static final String TAG = "CachedContentIndex";
+
+  private final HashMap<String, CachedContent> keyToContent;
+  private final SparseArray<String> idToKey;
+  private final AtomicFile atomicFile;
+  private final Cipher cipher;
+  private final SecretKeySpec secretKeySpec;
+  private boolean changed;
+  private ReusableBufferedOutputStream bufferedOutputStream;
+
+  /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
+  public CachedContentIndex(File cacheDir) {
+    this(cacheDir, null);
+  }
+
+  /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
+  public CachedContentIndex(File cacheDir, byte[] secretKey) {
+    if (secretKey != null) {
+      try {
+        cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
+        secretKeySpec = new SecretKeySpec(secretKey, "AES");
+      } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
+        throw new IllegalStateException(e); // Should never happen.
+      }
+    } else {
+      cipher = null;
+      secretKeySpec = null;
+    }
+    keyToContent = new HashMap<>();
+    idToKey = new SparseArray<>();
+    atomicFile = new AtomicFile(new File(cacheDir, FILE_NAME));
+  }
+
+  /** Loads the index file. */
+  public void load() {
+    Assertions.checkState(!changed);
+    if (!readFile()) {
+      atomicFile.delete();
+      keyToContent.clear();
+      idToKey.clear();
+    }
+  }
+
+  /** Stores the index data to index file if there is a change. */
+  public void store() throws CacheException {
+    if (!changed) {
+      return;
+    }
+    writeFile();
+    changed = false;
+  }
+
+  /**
+   * Adds the given key to the index if it isn't there already.
+   *
+   * @param key The cache key that uniquely identifies the original stream.
+   * @return A new or existing CachedContent instance with the given key.
+   */
+  public CachedContent add(String key) {
+    CachedContent cachedContent = keyToContent.get(key);
+    if (cachedContent == null) {
+      cachedContent = addNew(key, C.LENGTH_UNBOUNDED);
+    }
+    return cachedContent;
+  }
+
+  /** Returns a CachedContent instance with the given key or null if there isn't one. */
+  public CachedContent get(String key) {
+    return keyToContent.get(key);
+  }
+
+  /**
+   * Returns a Collection of all CachedContent instances in the index. The collection is backed by
+   * the {@code keyToContent} map, so changes to the map are reflected in the collection, and
+   * vice-versa. If the map is modified while an iteration over the collection is in progress
+   * (except through the iterator's own remove operation), the results of the iteration are
+   * undefined.
+   */
+  public Collection<CachedContent> getAll() {
+    return keyToContent.values();
+  }
+
+  /** Returns an existing or new id assigned to the given key. */
+  public int assignIdForKey(String key) {
+    return add(key).id;
+  }
+
+  /** Returns the key which has the given id assigned. */
+  public String getKeyForId(int id) {
+    return idToKey.get(id);
+  }
+
+  /**
+   * Removes {@link CachedContent} with the given key from index. It shouldn't contain any spans.
+   *
+   * @throws IllegalStateException If {@link CachedContent} isn't empty.
+   */
+  public void removeEmpty(String key) {
+    CachedContent cachedContent = keyToContent.remove(key);
+    if (cachedContent != null) {
+      Assertions.checkState(cachedContent.isEmpty());
+      idToKey.remove(cachedContent.id);
+      changed = true;
+    }
+  }
+
+  /** Removes empty {@link CachedContent} instances from index. */
+  public void removeEmpty() {
+    LinkedList<String> cachedContentToBeRemoved = new LinkedList<>();
+    for (CachedContent cachedContent : keyToContent.values()) {
+      if (cachedContent.isEmpty()) {
+        cachedContentToBeRemoved.add(cachedContent.key);
+      }
+    }
+    for (String key : cachedContentToBeRemoved) {
+      removeEmpty(key);
+    }
+  }
+
+  /**
+   * Returns a set of all content keys. The set is backed by the {@code keyToContent} map, so
+   * changes to the map are reflected in the set, and vice-versa. If the map is modified while an
+   * iteration over the set is in progress (except through the iterator's own remove operation), the
+   * results of the iteration are undefined.
+   */
+  public Set<String> getKeys() {
+    return keyToContent.keySet();
+  }
+
+  /**
+   * Sets the content length for the given key. A new {@link CachedContent} is added if there isn't
+   * one already with the given key.
+   */
+  public void setContentLength(String key, long length) {
+    CachedContent cachedContent = get(key);
+    if (cachedContent != null) {
+      if (cachedContent.getLength() != length) {
+        cachedContent.setLength(length);
+        changed = true;
+      }
+    } else {
+      addNew(key, length);
+    }
+  }
+
+  /**
+   * Returns the content length for the given key if one set, or {@link
+   * com.google.android.exoplayer.C#LENGTH_UNBOUNDED} otherwise.
+   */
+  public long getContentLength(String key) {
+    CachedContent cachedContent = get(key);
+    return cachedContent == null ? C.LENGTH_UNBOUNDED : cachedContent.getLength();
+  }
+
+  private boolean readFile() {
+    DataInputStream input = null;
+    try {
+      InputStream inputStream = new BufferedInputStream(atomicFile.openRead());
+      input = new DataInputStream(inputStream);
+      int version = input.readInt();
+      if (version != VERSION) {
+        // Currently there is no other version
+        return false;
+      }
+
+      int flags = input.readInt();
+      if ((flags & FLAG_ENCRYPTED_INDEX) != 0) {
+        if (cipher == null) {
+          return false;
+        }
+        byte[] initializationVector = new byte[16];
+        input.readFully(initializationVector);
+        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+        try {
+          cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
+        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+          throw new IllegalStateException(e);
+        }
+        input = new DataInputStream(new CipherInputStream(inputStream, cipher));
+      } else {
+        if (cipher != null) {
+          changed = true; // Force index to be rewritten encrypted after read.
+        }
+      }
+
+      int count = input.readInt();
+      int hashCode = 0;
+      for (int i = 0; i < count; i++) {
+        CachedContent cachedContent = new CachedContent(input);
+        add(cachedContent);
+        hashCode += cachedContent.headerHashCode();
+      }
+      if (input.readInt() != hashCode) {
+        return false;
+      }
+    } catch (FileNotFoundException e) {
+      return false;
+    } catch (IOException e) {
+      Log.e(TAG, "Error reading cache content index file.", e);
+      return false;
+    } finally {
+      if (input != null) {
+        Util.closeQuietly(input);
+      }
+    }
+    return true;
+  }
+
+  private void writeFile() throws CacheException {
+    DataOutputStream output = null;
+    try {
+      OutputStream outputStream = atomicFile.startWrite();
+      if (bufferedOutputStream == null) {
+        bufferedOutputStream = new ReusableBufferedOutputStream(outputStream);
+      } else {
+        bufferedOutputStream.reset(outputStream);
+      }
+      output = new DataOutputStream(bufferedOutputStream);
+      output.writeInt(VERSION);
+
+      int flags = cipher != null ? FLAG_ENCRYPTED_INDEX : 0;
+      output.writeInt(flags);
+
+      if (cipher != null) {
+        byte[] initializationVector = new byte[16];
+        new Random().nextBytes(initializationVector);
+        output.write(initializationVector);
+        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+        try {
+          cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
+        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+          throw new IllegalStateException(e); // Should never happen.
+        }
+        output.flush();
+        output = new DataOutputStream(new CipherOutputStream(bufferedOutputStream, cipher));
+      }
+
+      output.writeInt(keyToContent.size());
+      int hashCode = 0;
+      for (CachedContent cachedContent : keyToContent.values()) {
+        cachedContent.writeToStream(output);
+        hashCode += cachedContent.headerHashCode();
+      }
+      output.writeInt(hashCode);
+      atomicFile.endWrite(output);
+    } catch (IOException e) {
+      throw new CacheException(e);
+    } finally {
+      Util.closeQuietly(output);
+    }
+  }
+
+  private void add(CachedContent cachedContent) {
+    keyToContent.put(cachedContent.key, cachedContent);
+    idToKey.put(cachedContent.id, cachedContent.key);
+  }
+
+  /** Adds the given CachedContent to the index. */
+  /*package*/ void addNew(CachedContent cachedContent) {
+    add(cachedContent);
+    changed = true;
+  }
+
+  private CachedContent addNew(String key, long length) {
+    int id = getNewId(idToKey);
+    CachedContent cachedContent = new CachedContent(id, key, length);
+    addNew(cachedContent);
+    return cachedContent;
+  }
+
+  /**
+   * Returns an id which isn't used in the given array. If the maximum id in the array is smaller
+   * than {@link java.lang.Integer#MAX_VALUE} it just returns the next bigger integer. Otherwise it
+   * returns the smallest unused non-negative integer.
+   */
+  //@VisibleForTesting
+  public static int getNewId(SparseArray<String> idToKey) {
+    int size = idToKey.size();
+    int id = size == 0 ? 0 : (idToKey.keyAt(size - 1) + 1);
+    if (id < 0) { // In case if we pass max int value.
+      // TODO optimization: defragmentation or binary search?
+      for (id = 0; id < size; id++) {
+        if (id != idToKey.keyAt(id)) {
+          break;
+        }
+      }
+    }
+    return id;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 6e65df52b7..76fa6785cd 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.upstream.cache;
 
+import com.google.android.exoplayer.upstream.cache.Cache.CacheException;
 import java.util.Comparator;
 import java.util.TreeSet;
 
@@ -74,7 +75,11 @@ public int compare(CacheSpan lhs, CacheSpan rhs) {
 
   private void evictCache(Cache cache, long requiredSpace) {
     while (currentSize + requiredSpace > maxBytes) {
-      cache.removeSpan(leastRecentlyUsed.first());
+      try {
+        cache.removeSpan(leastRecentlyUsed.first());
+      } catch (CacheException e) {
+        // do nothing.
+      }
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
index 0c0f4b0cc5..8d4cd4787f 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
@@ -21,8 +21,7 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map.Entry;
+import java.util.LinkedList;
 import java.util.NavigableSet;
 import java.util.Set;
 import java.util.TreeSet;
@@ -35,21 +34,36 @@
   private final File cacheDir;
   private final CacheEvictor evictor;
   private final HashMap<String, CacheSpan> lockedSpans;
-  private final HashMap<String, TreeSet<CacheSpan>> cachedSpans;
+  private final CachedContentIndex index;
   private final HashMap<String, ArrayList<Listener>> listeners;
   private long totalSpace = 0;
+  private CacheException initializationException;
 
   /**
    * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
    * the directory cannot be used to store other files.
    *
    * @param cacheDir A dedicated cache directory.
+   * @param evictor The evictor to be used.
    */
   public SimpleCache(File cacheDir, CacheEvictor evictor) {
+    this(cacheDir, evictor, null);
+  }
+
+  /**
+   * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
+   * the directory cannot be used to store other files.
+   *
+   * @param cacheDir A dedicated cache directory.
+   * @param evictor The evictor to be used.
+   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
+   *     The key must be 16 bytes long.
+   */
+  public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey) {
     this.cacheDir = cacheDir;
     this.evictor = evictor;
     this.lockedSpans = new HashMap<>();
-    this.cachedSpans = new HashMap<>();
+    this.index = new CachedContentIndex(cacheDir, secretKey);
     this.listeners = new HashMap<>();
     // Start cache initialization.
     final ConditionVariable conditionVariable = new ConditionVariable();
@@ -58,7 +72,12 @@ public SimpleCache(File cacheDir, CacheEvictor evictor) {
       public void run() {
         synchronized (SimpleCache.this) {
           conditionVariable.open();
-          initialize();
+          try {
+            initialize();
+          } catch (CacheException e) {
+            initializationException = e;
+          }
+          SimpleCache.this.evictor.onCacheInitialized();
         }
       }
     }.start();
@@ -89,13 +108,13 @@ public synchronized void removeListener(String key, Listener listener) {
 
   @Override
   public synchronized NavigableSet<CacheSpan> getCachedSpans(String key) {
-    TreeSet<CacheSpan> spansForKey = cachedSpans.get(key);
-    return spansForKey == null ? null : new TreeSet<>(spansForKey);
+    CachedContent cachedContent = index.get(key);
+    return cachedContent == null ? null : new TreeSet<CacheSpan>(cachedContent.getSpans());
   }
 
   @Override
   public synchronized Set<String> getKeys() {
-    return new HashSet<>(cachedSpans.keySet());
+    return new HashSet<>(index.getKeys());
   }
 
   @Override
@@ -104,11 +123,10 @@ public synchronized long getCacheSpace() {
   }
 
   @Override
-  public synchronized CacheSpan startReadWrite(String key, long position)
-      throws InterruptedException {
-    CacheSpan lookupSpan = CacheSpan.createLookup(key, position);
+  public synchronized SimpleCacheSpan startReadWrite(String key, long position)
+      throws InterruptedException, CacheException {
     while (true) {
-      CacheSpan span = startReadWriteNonBlocking(lookupSpan);
+      SimpleCacheSpan span = startReadWriteNonBlocking(key, position);
       if (span != null) {
         return span;
       } else {
@@ -122,31 +140,26 @@ public synchronized CacheSpan startReadWrite(String key, long position)
   }
 
   @Override
-  public synchronized CacheSpan startReadWriteNonBlocking(String key, long position) {
-    return startReadWriteNonBlocking(CacheSpan.createLookup(key, position));
-  }
+  public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
+      throws CacheException {
+    if (initializationException != null) {
+      throw initializationException;
+    }
 
-  private synchronized CacheSpan startReadWriteNonBlocking(CacheSpan lookupSpan) {
-    CacheSpan spanningRegion = getSpan(lookupSpan);
+    SimpleCacheSpan cacheSpan = getSpan(key, position);
 
     // Read case.
-    if (spanningRegion.isCached) {
-      CacheSpan oldCacheSpan = spanningRegion;
-      // Remove the old span from the in-memory representation.
-      TreeSet<CacheSpan> spansForKey = cachedSpans.get(oldCacheSpan.key);
-      Assertions.checkState(spansForKey.remove(oldCacheSpan));
+    if (cacheSpan.isCached) {
       // Obtain a new span with updated last access timestamp.
-      spanningRegion = oldCacheSpan.touch();
-      // Add the updated span back into the in-memory representation.
-      spansForKey.add(spanningRegion);
-      notifySpanTouched(oldCacheSpan, spanningRegion);
-      return spanningRegion;
+      SimpleCacheSpan newCacheSpan = index.get(key).touch(cacheSpan);
+      notifySpanTouched(cacheSpan, newCacheSpan);
+      return newCacheSpan;
     }
 
     // Write case, lock available.
-    if (!lockedSpans.containsKey(lookupSpan.key)) {
-      lockedSpans.put(lookupSpan.key, spanningRegion);
-      return spanningRegion;
+    if (!lockedSpans.containsKey(key)) {
+      lockedSpans.put(key, cacheSpan);
+      return cacheSpan;
     }
 
     // Write case, lock not available.
@@ -154,20 +167,22 @@ private synchronized CacheSpan startReadWriteNonBlocking(CacheSpan lookupSpan) {
   }
 
   @Override
-  public synchronized File startFile(String key, long position, long length) {
+  public synchronized File startFile(String key, long position, long maxLength)
+      throws CacheException {
     Assertions.checkState(lockedSpans.containsKey(key));
     if (!cacheDir.exists()) {
       // For some reason the cache directory doesn't exist. Make a best effort to create it.
-      removeStaleSpans();
+      removeStaleSpansAndCachedContents();
       cacheDir.mkdirs();
     }
-    evictor.onStartFile(this, key, position, length);
-    return CacheSpan.getCacheFileName(cacheDir, key, position, System.currentTimeMillis());
+    evictor.onStartFile(this, key, position, maxLength);
+    return SimpleCacheSpan.getCacheFile(cacheDir, index.assignIdForKey(key), position,
+        System.currentTimeMillis());
   }
 
   @Override
-  public synchronized void commitFile(File file) {
-    CacheSpan span = CacheSpan.createCacheEntry(file);
+  public synchronized void commitFile(File file) throws CacheException {
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(file, index);
     Assertions.checkState(span != null);
     Assertions.checkState(lockedSpans.containsKey(span.key));
     // If the file doesn't exist, don't add it to the in-memory representation.
@@ -175,12 +190,12 @@ public synchronized void commitFile(File file) {
       return;
     }
     // If the file has length 0, delete it and don't add it to the in-memory representation.
-    long length = file.length();
-    if (length == 0) {
+    if (file.length() == 0) {
       file.delete();
       return;
     }
     addSpan(span);
+    index.store();
     notifyAll();
   }
 
@@ -191,68 +206,65 @@ public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
   }
 
   /**
-   * Returns the cache {@link CacheSpan} corresponding to the provided lookup {@link CacheSpan}.
-   * <p>
-   * If the lookup position is contained by an existing entry in the cache, then the returned
-   * {@link CacheSpan} defines the file in which the data is stored. If the lookup position is not
-   * contained by an existing entry, then the returned {@link CacheSpan} defines the maximum extents
-   * of the hole in the cache.
+   * Returns the cache {@link SimpleCacheSpan} corresponding to the provided lookup {@link
+   * SimpleCacheSpan}.
+   *
+   * <p>If the lookup position is contained by an existing entry in the cache, then the returned
+   * {@link SimpleCacheSpan} defines the file in which the data is stored. If the lookup position is
+   * not contained by an existing entry, then the returned {@link SimpleCacheSpan} defines the
+   * maximum extents of the hole in the cache.
    *
-   * @param lookupSpan A lookup {@link CacheSpan} specifying a key and position.
-   * @return The corresponding cache {@link CacheSpan}.
+   * @param key The key of the span being requested.
+   * @param position The position of the span being requested.
+   * @return The corresponding cache {@link SimpleCacheSpan}.
    */
-  private CacheSpan getSpan(CacheSpan lookupSpan) {
-    String key = lookupSpan.key;
-    long offset = lookupSpan.position;
-    TreeSet<CacheSpan> entries = cachedSpans.get(key);
-    if (entries == null) {
-      return CacheSpan.createOpenHole(key, lookupSpan.position);
+  private SimpleCacheSpan getSpan(String key, long position) throws CacheException {
+    CachedContent cachedContent = index.get(key);
+    if (cachedContent == null) {
+      return SimpleCacheSpan.createOpenHole(key, position);
     }
-    CacheSpan floorSpan = entries.floor(lookupSpan);
-    if (floorSpan != null &&
-        floorSpan.position <= offset && offset < floorSpan.position + floorSpan.length) {
-      // The lookup position is contained within floorSpan.
-      if (floorSpan.file.exists()) {
-        return floorSpan;
-      } else {
+    while (true) {
+      SimpleCacheSpan span = cachedContent.getSpan(position);
+      if (span.isCached && !span.file.exists()) {
         // The file has been deleted from under us. It's likely that other files will have been
         // deleted too, so scan the whole in-memory representation.
-        removeStaleSpans();
-        return getSpan(lookupSpan);
+        removeStaleSpansAndCachedContents();
+        continue;
       }
+      return span;
     }
-    CacheSpan ceilEntry = entries.ceiling(lookupSpan);
-    return ceilEntry == null ? CacheSpan.createOpenHole(key, lookupSpan.position) :
-        CacheSpan.createClosedHole(key, lookupSpan.position,
-            ceilEntry.position - lookupSpan.position);
   }
 
   /**
    * Ensures that the cache's in-memory representation has been initialized.
    */
-  private void initialize() {
+  private void initialize() throws CacheException {
     if (!cacheDir.exists()) {
       cacheDir.mkdirs();
+      return;
     }
+
+    index.load();
+
     File[] files = cacheDir.listFiles();
     if (files == null) {
       return;
     }
-    for (int i = 0; i < files.length; i++) {
-      File file = files[i];
-      if (file.length() == 0) {
-        file.delete();
+    for (File file : files) {
+      if (file.getName().equals(CachedContentIndex.FILE_NAME)) {
+        continue;
+      }
+      SimpleCacheSpan span = file.length() > 0
+          ? SimpleCacheSpan.createCacheEntry(file, index) : null;
+      if (span != null) {
+        addSpan(span);
       } else {
-        file = CacheSpan.upgradeIfNeeded(file);
-        CacheSpan span = CacheSpan.createCacheEntry(file);
-        if (span == null) {
-          file.delete();
-        } else {
-          addSpan(span);
-        }
+        file.delete();
       }
     }
-    evictor.onCacheInitialized();
+
+    index.removeEmpty();
+    index.store();
   }
 
   /**
@@ -260,55 +272,47 @@ private void initialize() {
    *
    * @param span The span to be added.
    */
-  private void addSpan(CacheSpan span) {
-    TreeSet<CacheSpan> spansForKey = cachedSpans.get(span.key);
-    if (spansForKey == null) {
-      spansForKey = new TreeSet<>();
-      cachedSpans.put(span.key, spansForKey);
-    }
-    spansForKey.add(span);
+  private void addSpan(SimpleCacheSpan span) {
+    index.add(span.key).addSpan(span);
     totalSpace += span.length;
     notifySpanAdded(span);
   }
 
-  @Override
-  public synchronized void removeSpan(CacheSpan span) {
-    TreeSet<CacheSpan> spansForKey = cachedSpans.get(span.key);
+  private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws CacheException {
+    CachedContent cachedContent = index.get(span.key);
+    Assertions.checkState(cachedContent.removeSpan(span));
     totalSpace -= span.length;
-    Assertions.checkState(spansForKey.remove(span));
-    span.file.delete();
-    if (spansForKey.isEmpty()) {
-      cachedSpans.remove(span.key);
+    if (removeEmptyCachedContent && cachedContent.isEmpty()) {
+      index.removeEmpty(cachedContent.key);
+      index.store();
     }
     notifySpanRemoved(span);
   }
 
+  @Override
+  public synchronized void removeSpan(CacheSpan span) throws CacheException {
+    removeSpan(span, true);
+  }
+
   /**
    * Scans all of the cached spans in the in-memory representation, removing any for which files
    * no longer exist.
    */
-  private void removeStaleSpans() {
-    Iterator<Entry<String, TreeSet<CacheSpan>>> iterator = cachedSpans.entrySet().iterator();
-    while (iterator.hasNext()) {
-      Entry<String, TreeSet<CacheSpan>> next = iterator.next();
-      Iterator<CacheSpan> spanIterator = next.getValue().iterator();
-      boolean isEmpty = true;
-      while (spanIterator.hasNext()) {
-        CacheSpan span = spanIterator.next();
+  private void removeStaleSpansAndCachedContents() throws CacheException {
+    LinkedList<CacheSpan> spansToBeRemoved = new LinkedList<>();
+    for (CachedContent cachedContent : index.getAll()) {
+      for (CacheSpan span : cachedContent.getSpans()) {
         if (!span.file.exists()) {
-          spanIterator.remove();
-          if (span.isCached) {
-            totalSpace -= span.length;
-          }
-          notifySpanRemoved(span);
-        } else {
-          isEmpty = false;
+          spansToBeRemoved.add(span);
         }
       }
-      if (isEmpty) {
-        iterator.remove();
-      }
     }
+    for (CacheSpan span : spansToBeRemoved) {
+      // Remove span but not CachedContent to prevent multiple index.store() calls.
+      removeSpan(span, false);
+    }
+    index.removeEmpty();
+    index.store();
   }
 
   private void notifySpanRemoved(CacheSpan span) {
@@ -321,7 +325,7 @@ private void notifySpanRemoved(CacheSpan span) {
     evictor.onSpanRemoved(this, span);
   }
 
-  private void notifySpanAdded(CacheSpan span) {
+  private void notifySpanAdded(SimpleCacheSpan span) {
     ArrayList<Listener> keyListeners = listeners.get(span.key);
     if (keyListeners != null) {
       for (int i = keyListeners.size() - 1; i >= 0; i--) {
@@ -331,7 +335,7 @@ private void notifySpanAdded(CacheSpan span) {
     evictor.onSpanAdded(this, span);
   }
 
-  private void notifySpanTouched(CacheSpan oldSpan, CacheSpan newSpan) {
+  private void notifySpanTouched(SimpleCacheSpan oldSpan, CacheSpan newSpan) {
     ArrayList<Listener> keyListeners = listeners.get(oldSpan.key);
     if (keyListeners != null) {
       for (int i = keyListeners.size() - 1; i >= 0; i--) {
@@ -343,39 +347,8 @@ private void notifySpanTouched(CacheSpan oldSpan, CacheSpan newSpan) {
 
   @Override
   public synchronized boolean isCached(String key, long position, long length) {
-    TreeSet<CacheSpan> entries = cachedSpans.get(key);
-    if (entries == null) {
-      return false;
-    }
-    CacheSpan lookupSpan = CacheSpan.createLookup(key, position);
-    CacheSpan floorSpan = entries.floor(lookupSpan);
-    if (floorSpan == null || floorSpan.position + floorSpan.length <= position) {
-      // We don't have a span covering the start of the queried region.
-      return false;
-    }
-    long queryEndPosition = position + length;
-    long currentEndPosition = floorSpan.position + floorSpan.length;
-    if (currentEndPosition >= queryEndPosition) {
-      // floorSpan covers the queried region.
-      return true;
-    }
-    Iterator<CacheSpan> iterator = entries.tailSet(floorSpan, false).iterator();
-    while (iterator.hasNext()) {
-      CacheSpan next = iterator.next();
-      if (next.position > currentEndPosition) {
-        // There's a hole in the cache within the queried region.
-        return false;
-      }
-      // We expect currentEndPosition to always equal (next.position + next.length), but
-      // perform a max check anyway to guard against the existence of overlapping spans.
-      currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
-      if (currentEndPosition >= queryEndPosition) {
-        // We've found spans covering the queried region.
-        return true;
-      }
-    }
-    // We ran out of spans before covering the queried region.
-    return false;
+    CachedContent cachedContent = index.get(key);
+    return cachedContent != null && cachedContent.isCached(position, length);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCacheSpan.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCacheSpan.java
new file mode 100644
index 0000000000..c9817b33e3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCacheSpan.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream.cache;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+import java.io.File;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * This class stores span metadata in filename.
+ */
+/*package*/ final class SimpleCacheSpan extends CacheSpan {
+
+  private static final String SUFFIX = ".v3.exo";
+  private static final Pattern CACHE_FILE_PATTERN_V1 = Pattern.compile(
+      "^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
+  private static final Pattern CACHE_FILE_PATTERN_V2 = Pattern.compile(
+      "^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
+  private static final Pattern CACHE_FILE_PATTERN_V3 = Pattern.compile(
+      "^(\\d+)\\.(\\d+)\\.(\\d+)\\.v3\\.exo$", Pattern.DOTALL);
+
+  public static File getCacheFile(File cacheDir, int id, long position,
+      long lastAccessTimestamp) {
+    return new File(cacheDir, id + "." + position + "." + lastAccessTimestamp + SUFFIX);
+  }
+
+  public static SimpleCacheSpan createLookup(String key, long position) {
+    return new SimpleCacheSpan(key, position, C.LENGTH_UNBOUNDED, C.UNKNOWN_TIME_US, null);
+  }
+
+  public static SimpleCacheSpan createOpenHole(String key, long position) {
+    return new SimpleCacheSpan(key, position, C.LENGTH_UNBOUNDED, C.UNKNOWN_TIME_US, null);
+  }
+
+  public static SimpleCacheSpan createClosedHole(String key, long position, long length) {
+    return new SimpleCacheSpan(key, position, length, C.UNKNOWN_TIME_US, null);
+  }
+
+  /**
+   * Creates a cache span from an underlying cache file. Upgrades the file if necessary.
+   *
+   * @param file The cache file.
+   * @param index Cached content index.
+   * @return The span, or null if the file name is not correctly formatted, or if the id is not
+   *     present in the content index.
+   */
+  public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex index) {
+    String name = file.getName();
+    if (!name.endsWith(SUFFIX)) {
+      file = upgradeFile(file, index);
+      if (file == null) {
+        return null;
+      }
+      name = file.getName();
+    }
+
+    Matcher matcher = CACHE_FILE_PATTERN_V3.matcher(name);
+    if (!matcher.matches()) {
+      return null;
+    }
+    long length = file.length();
+    int id = Integer.parseInt(matcher.group(1));
+    String key = index.getKeyForId(id);
+    return key == null ? null : new SimpleCacheSpan(key, Long.parseLong(matcher.group(2)), length,
+        Long.parseLong(matcher.group(3)), file);
+  }
+
+  private static File upgradeFile(File file, CachedContentIndex index) {
+    String key;
+    String filename = file.getName();
+    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(filename);
+    if (matcher.matches()) {
+      key = Util.unescapeFileName(matcher.group(1));
+      if (key == null) {
+        return null;
+      }
+    } else {
+      matcher = CACHE_FILE_PATTERN_V1.matcher(filename);
+      if (!matcher.matches()) {
+        return null;
+      }
+      key = matcher.group(1); // Keys were not escaped in version 1.
+    }
+
+    File newCacheFile = getCacheFile(file.getParentFile(), index.assignIdForKey(key),
+        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
+    if (!file.renameTo(newCacheFile)) {
+      return null;
+    }
+    return newCacheFile;
+  }
+
+  private SimpleCacheSpan(String key, long position, long length, long lastAccessTimestamp,
+      File file) {
+    super(key, position, length, lastAccessTimestamp, file);
+  }
+
+  /**
+   * Returns a copy of this CacheSpan whose last access time stamp is set to current time. This
+   * doesn't copy or change the underlying cache file.
+   *
+   * @param id The cache file id.
+   * @return A {@link SimpleCacheSpan} with updated last access time stamp.
+   * @throws IllegalStateException If called on a non-cached span (i.e. {@link #isCached} is false).
+   */
+  public SimpleCacheSpan copyWithUpdatedLastAccessTime(int id) {
+    Assertions.checkState(isCached);
+    long now = System.currentTimeMillis();
+    File newCacheFile = getCacheFile(file.getParentFile(), id, position, now);
+    return new SimpleCacheSpan(key, position, length, now, newCacheFile);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/AtomicFile.java b/library/src/main/java/com/google/android/exoplayer/util/AtomicFile.java
new file mode 100644
index 0000000000..db948e06aa
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/AtomicFile.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer.util;
+
+import android.util.Log;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * A helper class for performing atomic operations on a file by creating a backup file until a write
+ * has successfully completed.
+ *
+ * <p>Atomic file guarantees file integrity by ensuring that a file has been completely written and
+ * sync'd to disk before removing its backup. As long as the backup file exists, the original file
+ * is considered to be invalid (left over from a previous attempt to write the file).
+ *
+ * <p>Atomic file does not confer any file locking semantics. Do not use this class when the file
+ * may be accessed or modified concurrently by multiple threads or processes. The caller is
+ * responsible for ensuring appropriate mutual exclusion invariants whenever it accesses the file.
+ */
+public final class AtomicFile {
+
+  private static final String TAG = "AtomicFile";
+
+  private final File baseName;
+  private final File backupName;
+
+  /**
+   * Create a new AtomicFile for a file located at the given File path. The secondary backup file
+   * will be the same file path with ".bak" appended.
+   */
+  public AtomicFile(File baseName) {
+    this.baseName = baseName;
+    backupName = new File(baseName.getPath() + ".bak");
+  }
+
+  /** Delete the atomic file. This deletes both the base and backup files. */
+  public void delete() {
+    baseName.delete();
+    backupName.delete();
+  }
+
+  /**
+   * Start a new write operation on the file. This returns an {@link OutputStream} to which you can
+   * write the new file data. If the whole data is written successfully you <em>must</em> call
+   * {@link #endWrite(OutputStream)}. On failure you should call {@link OutputStream#close()}
+   * only to free up resources used by it.
+   *
+   * <p>Example usage:
+   *
+   * <pre>
+   *   DataOutputStream dataOutput = null;
+   *   try {
+   *     OutputStream outputStream = atomicFile.startWrite();
+   *     dataOutput = new DataOutputStream(outputStream); // Wrapper stream
+   *     dataOutput.write(data1);
+   *     dataOutput.write(data2);
+   *     atomicFile.endWrite(dataOutput); // Pass wrapper stream
+   *   } finally{
+   *     if (dataOutput != null) {
+   *       dataOutput.close();
+   *     }
+   *   }
+   * </pre>
+   *
+   * <p>Note that if another thread is currently performing a write, this will simply replace
+   * whatever that thread is writing with the new file being written by this thread, and when the
+   * other thread finishes the write the new write operation will no longer be safe (or will be
+   * lost). You must do your own threading protection for access to AtomicFile.
+   */
+  public OutputStream startWrite() throws IOException {
+    // Rename the current file so it may be used as a backup during the next read
+    if (baseName.exists()) {
+      if (!backupName.exists()) {
+        if (!baseName.renameTo(backupName)) {
+          Log.w(TAG, "Couldn't rename file " + baseName + " to backup file " + backupName);
+        }
+      } else {
+        baseName.delete();
+      }
+    }
+    OutputStream str = null;
+    try {
+      str = new AtomicFileOutputStream(baseName);
+    } catch (FileNotFoundException e) {
+      File parent = baseName.getParentFile();
+      if (!parent.mkdirs()) {
+        throw new IOException("Couldn't create directory " + baseName);
+      }
+      try {
+        str = new AtomicFileOutputStream(baseName);
+      } catch (FileNotFoundException e2) {
+        throw new IOException("Couldn't create " + baseName);
+      }
+    }
+    return str;
+  }
+
+  /**
+   * Call when you have successfully finished writing to the stream returned by {@link
+   * #startWrite()}. This will close, sync, and commit the new data. The next attempt to read the
+   * atomic file will return the new file stream.
+   *
+   * @param str Outer-most wrapper OutputStream used to write to the stream returned by {@link
+   *     #startWrite()}.
+   * @see #startWrite()
+   */
+  public void endWrite(OutputStream str) throws IOException {
+    str.close();
+    // If close() throws exception, the next line is skipped.
+    backupName.delete();
+  }
+
+  /**
+   * Open the atomic file for reading. If there previously was an incomplete write, this will roll
+   * back to the last good data before opening for read.
+   *
+   * <p>Note that if another thread is currently performing a write, this will incorrectly consider
+   * it to be in the state of a bad write and roll back, causing the new data currently being
+   * written to be dropped. You must do your own threading protection for access to AtomicFile.
+   */
+  public InputStream openRead() throws FileNotFoundException {
+    restoreBackup();
+    return new FileInputStream(baseName);
+  }
+
+  private void restoreBackup() {
+    if (backupName.exists()) {
+      baseName.delete();
+      backupName.renameTo(baseName);
+    }
+  }
+
+  private static final class AtomicFileOutputStream extends OutputStream {
+
+    private final FileOutputStream fileOutputStream;
+    private boolean closed = false;
+
+    public AtomicFileOutputStream(File file) throws FileNotFoundException {
+      fileOutputStream = new FileOutputStream(file);
+    }
+
+    @Override
+    public void close() throws IOException {
+      if (closed) {
+        return;
+      }
+      closed = true;
+      flush();
+      try {
+        fileOutputStream.getFD().sync();
+      } catch (IOException e) {
+        Log.w(TAG, "Failed to sync file descriptor:", e);
+      }
+      fileOutputStream.close();
+    }
+
+    @Override
+    public void flush() throws IOException {
+      fileOutputStream.flush();
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+      fileOutputStream.write(b);
+    }
+
+    @Override
+    public void write(byte[] b) throws IOException {
+      fileOutputStream.write(b);
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+      fileOutputStream.write(b, off, len);
+    }
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 8fe7a87bdb..f247809c4b 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -71,6 +71,7 @@
   public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4vtt";
   public static final String APPLICATION_VOBSUB = BASE_TYPE_APPLICATION + "/vobsub";
   public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
+  public static final String APPLICATION_CAMERA_MOTION = BASE_TYPE_APPLICATION + "/x-camera-motion";
 
   private MimeTypes() {}
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ReusableBufferedOutputStream.java b/library/src/main/java/com/google/android/exoplayer/util/ReusableBufferedOutputStream.java
new file mode 100644
index 0000000000..9ca7547486
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/ReusableBufferedOutputStream.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This is a subclass of {@link BufferedOutputStream} with a {@link #reset(OutputStream)} method
+ * that allows an instance to be re-used with another underlying output stream.
+ */
+public final class ReusableBufferedOutputStream extends BufferedOutputStream {
+
+  private boolean closed;
+
+  public ReusableBufferedOutputStream(OutputStream out) {
+    super(out);
+  }
+
+  public ReusableBufferedOutputStream(OutputStream out, int size) {
+    super(out, size);
+  }
+
+  @Override
+  public void close() throws IOException {
+    closed = true;
+
+    Throwable thrown = null;
+    try {
+      flush();
+    } catch (Throwable e) {
+      thrown = e;
+    }
+    try {
+      out.close();
+    } catch (Throwable e) {
+      if (thrown == null) {
+        thrown = e;
+      }
+    }
+    if (thrown != null) {
+      Util.sneakyThrow(thrown);
+    }
+  }
+
+  /**
+   * Resets this stream and uses the given output stream for writing. This stream must be closed
+   * before resetting.
+   *
+   * @param out New output stream to be used for writing.
+   * @throws IllegalStateException If the stream isn't closed.
+   */
+  public void reset(OutputStream out) {
+    Assertions.checkState(closed);
+    this.out = out;
+    closed = false;
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 24991ddc67..825b07360a 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -66,7 +67,7 @@
    * overridden for local testing.
    */
   public static final int SDK_INT =
-      (Build.VERSION.SDK_INT == 23 && Build.VERSION.CODENAME.charAt(0) == 'N') ? 24
+      (Build.VERSION.SDK_INT == 25 && Build.VERSION.CODENAME.charAt(0) == 'O') ? 26
       : Build.VERSION.SDK_INT;
 
   /**
@@ -112,7 +113,7 @@
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
       + "(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d+))?"
-      + "([Zz]|((\\+|\\-)(\\d\\d):(\\d\\d)))?");
+      + "([Zz]|((\\+|\\-)(\\d\\d):?(\\d\\d)))?");
   private static final Pattern XS_DURATION_PATTERN =
       Pattern.compile("^(-)?P(([0-9]*)Y)?(([0-9]*)M)?(([0-9]*)D)?"
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
@@ -228,20 +229,25 @@ public Thread newThread(Runnable r) {
    */
   public static void closeQuietly(DataSource dataSource) {
     try {
-      dataSource.close();
+      if (dataSource != null) {
+        dataSource.close();
+      }
     } catch (IOException e) {
       // Ignore.
     }
   }
 
   /**
-   * Closes an {@link OutputStream}, suppressing any {@link IOException} that may occur.
+   * Closes a {@link Closeable}, suppressing any {@link IOException} that may occur. Both {@link
+   * java.io.OutputStream} and {@link InputStream} are {@code Closeable}.
    *
-   * @param outputStream The {@link OutputStream} to close.
+   * @param closeable The {@link Closeable} to close.
    */
-  public static void closeQuietly(OutputStream outputStream) {
+  public static void closeQuietly(Closeable closeable) {
     try {
-      outputStream.close();
+      if (closeable != null) {
+        closeable.close();
+      }
     } catch (IOException e) {
       // Ignore.
     }
@@ -913,6 +919,19 @@ public static String unescapeFileName(String fileName) {
     return builder.toString();
   }
 
+  /**
+   * A hacky method that always throws {@code t} even if {@code t} is a checked exception,
+   * and is not declared to be thrown.
+   */
+  public static void sneakyThrow(Throwable t) {
+    Util.<RuntimeException>sneakyThrowInternal(t);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T extends Throwable> void sneakyThrowInternal(Throwable t) throws T {
+    throw (T) t;
+  }
+
   /**
    * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
    * order.
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 06beaaec0b..ae2dc223ab 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1512"
-    android:versionName="1.5.12">
+    android:versionCode="1513"
+    android:versionName="1.5.13">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
