diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index 198b37b9a3..10f90ec13b 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -145,7 +145,7 @@ public void onSingleManifest(HlsPlaylist manifest) {
       DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       HlsChunkSource chunkSource = new HlsChunkSource(true /* isMaster */, dataSource, manifest,
           DefaultHlsTrackSelector.newDefaultInstance(context), bandwidthMeter,
-          timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+          timestampAdjusterProvider);
       HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl,
           MAIN_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_VIDEO);
       MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context,
@@ -160,7 +160,7 @@ public void onSingleManifest(HlsPlaylist manifest) {
         DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
         HlsChunkSource audioChunkSource = new HlsChunkSource(false /* isMaster */, audioDataSource,
             manifest, DefaultHlsTrackSelector.newAudioInstance(), bandwidthMeter,
-            timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+            timestampAdjusterProvider);
         HlsSampleSource audioSampleSource = new HlsSampleSource(audioChunkSource, loadControl,
             AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
             DemoPlayer.TYPE_AUDIO);
@@ -180,7 +180,7 @@ public void onSingleManifest(HlsPlaylist manifest) {
         DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
         HlsChunkSource textChunkSource = new HlsChunkSource(false /* isMaster */, textDataSource,
             manifest, DefaultHlsTrackSelector.newSubtitleInstance(), bandwidthMeter,
-            timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+            timestampAdjusterProvider);
         HlsSampleSource textSampleSource = new HlsSampleSource(textChunkSource, loadControl,
             TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_TEXT);
         textRenderer = new TextTrackRenderer(textSampleSource, player, mainHandler.getLooper());
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
index 7eaaa107a6..160bfffa56 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
@@ -43,10 +43,6 @@ public MediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format
         Chunk.NO_PARENT_ID);
   }
 
-  public int getNextChunkIndex() {
-    return chunkIndex + 1;
-  }
-
   /**
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
@@ -66,4 +62,12 @@ public MediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format
     this.chunkIndex = chunkIndex;
   }
 
+  public int getNextChunkIndex() {
+    return chunkIndex + 1;
+  }
+
+  public long getDurationUs() {
+    return endTimeUs - startTimeUs;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 239c248096..c69ed78245 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -71,40 +71,6 @@
 
   }
 
-  /**
-   * Adaptive switching is disabled.
-   * <p>
-   * The initially selected variant will be used throughout playback.
-   */
-  public static final int ADAPTIVE_MODE_NONE = 0;
-
-  /**
-   * Adaptive switches splice overlapping segments of the old and new variants.
-   * <p>
-   * When performing a switch from one variant to another, overlapping segments will be requested
-   * from both the old and new variants. These segments will then be spliced together, allowing
-   * a seamless switch from one variant to another even if keyframes are misaligned or if keyframes
-   * are not positioned at the start of each segment.
-   * <p>
-   * Note that where it can be guaranteed that the source content has keyframes positioned at the
-   * start of each segment, {@link #ADAPTIVE_MODE_ABRUPT} should always be used in preference to
-   * this mode.
-   */
-  public static final int ADAPTIVE_MODE_SPLICE = 1;
-
-  /**
-   * Adaptive switches are performed at segment boundaries.
-   * <p>
-   * For this mode to perform seamless switches, the source content is required to have keyframes
-   * positioned at the start of each segment. If this is not the case a visual discontinuity may
-   * be experienced when switching from one variant to another.
-   * <p>
-   * Note that where it can be guaranteed that the source content does have keyframes positioned at
-   * the start of each segment, this mode should always be used in preference to
-   * {@link #ADAPTIVE_MODE_SPLICE} because it requires fetching less data.
-   */
-  public static final int ADAPTIVE_MODE_ABRUPT = 3;
-
   /**
    * The default minimum duration of media that needs to be buffered for a switch to a higher
    * quality variant to be considered.
@@ -122,6 +88,12 @@
    */
   public static final long DEFAULT_PLAYLIST_BLACKLIST_MS = 60000;
 
+  /**
+   * Subtracted value to lookup position when switching between variants in live streams to avoid
+   * gaps in playback in case playlist drift apart.
+   */
+  private static final double LIVE_VARIANT_SWITCH_SAFETY_EXTRA_SECS = 2.0;
+
   private static final String TAG = "HlsChunkSource";
   private static final String AAC_FILE_EXTENSION = ".aac";
   private static final String MP3_FILE_EXTENSION = ".mp3";
@@ -136,7 +108,6 @@
   private final HlsTrackSelector trackSelector;
   private final BandwidthMeter bandwidthMeter;
   private final PtsTimestampAdjusterProvider timestampAdjusterProvider;
-  private final int adaptiveMode;
   private final String baseUri;
   private final long minBufferDurationToSwitchUpUs;
   private final long maxBufferDurationToSwitchDownUs;
@@ -181,15 +152,12 @@
    * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
-   * @param adaptiveMode The mode for switching from one variant to another. One of
-   *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
-   *     {@link #ADAPTIVE_MODE_SPLICE}.
    */
   public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playlist,
       HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
-      PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode) {
+      PtsTimestampAdjusterProvider timestampAdjusterProvider) {
     this(isMaster, dataSource, playlist, trackSelector, bandwidthMeter,
-        timestampAdjusterProvider, adaptiveMode, DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS,
+        timestampAdjusterProvider, DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS,
         DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS, null, null);
   }
 
@@ -204,9 +172,6 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
    * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
-   * @param adaptiveMode The mode for switching from one variant to another. One of
-   *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
-   *     {@link #ADAPTIVE_MODE_SPLICE}.
    * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be buffered
    *     for a switch to a higher quality variant to be considered.
    * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
@@ -214,10 +179,10 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
    */
   public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playlist,
       HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
-      PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode,
-      long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs) {
+      PtsTimestampAdjusterProvider timestampAdjusterProvider, long minBufferDurationToSwitchUpMs,
+      long maxBufferDurationToSwitchDownMs) {
     this(isMaster, dataSource, playlist, trackSelector, bandwidthMeter,
-         timestampAdjusterProvider, adaptiveMode, minBufferDurationToSwitchUpMs,
+         timestampAdjusterProvider, minBufferDurationToSwitchUpMs,
          maxBufferDurationToSwitchDownMs, null, null);
   }
 
@@ -232,9 +197,6 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
    * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
-   * @param adaptiveMode The mode for switching from one variant to another. One of
-   *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
-   *     {@link #ADAPTIVE_MODE_SPLICE}.
    * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be buffered
    *     for a switch to a higher quality variant to be considered.
    * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
@@ -245,7 +207,7 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
    */
   public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playlist,
       HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
-      PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode,
+      PtsTimestampAdjusterProvider timestampAdjusterProvider,
       long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs,
       Handler eventHandler, EventListener eventListener) {
     this.isMaster = isMaster;
@@ -253,7 +215,6 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
     this.trackSelector = trackSelector;
     this.bandwidthMeter = bandwidthMeter;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
-    this.adaptiveMode = adaptiveMode;
     this.eventListener = eventListener;
     this.eventHandler = eventHandler;
     minBufferDurationToSwitchUpUs = minBufferDurationToSwitchUpMs * 1000;
@@ -430,17 +391,11 @@ public void reset() {
    */
   public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
       ChunkOperationHolder out) {
-    int nextVariantIndex;
-    boolean switchingVariantSpliced;
-    if (adaptiveMode == ADAPTIVE_MODE_NONE) {
-      nextVariantIndex = selectedVariantIndex;
-      switchingVariantSpliced = false;
-    } else {
-      nextVariantIndex = getNextVariantIndex(previousTsChunk, playbackPositionUs);
-      switchingVariantSpliced = previousTsChunk != null
-          && !variants[nextVariantIndex].format.equals(previousTsChunk.format)
-          && adaptiveMode == ADAPTIVE_MODE_SPLICE;
-    }
+    int previousChunkVariantIndex =
+        previousTsChunk == null ? -1 : getVariantIndex(previousTsChunk.format);
+    int nextVariantIndex = getNextVariantIndex(previousTsChunk, playbackPositionUs);
+    boolean switchingVariant = previousTsChunk != null
+        && previousChunkVariantIndex != nextVariantIndex;
 
     HlsMediaPlaylist mediaPlaylist = variantPlaylists[nextVariantIndex];
     if (mediaPlaylist == null) {
@@ -450,13 +405,13 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
     }
 
     selectedVariantIndex = nextVariantIndex;
-    int chunkMediaSequence = 0;
+    int chunkMediaSequence;
     if (live) {
       if (previousTsChunk == null) {
-        chunkMediaSequence = getLiveStartChunkMediaSequence(nextVariantIndex);
+        chunkMediaSequence = getLiveStartChunkSequenceNumber(selectedVariantIndex);
       } else {
-        chunkMediaSequence = switchingVariantSpliced
-            ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
+        chunkMediaSequence = getLiveNextChunkSequenceNumber(previousTsChunk.chunkIndex,
+            previousChunkVariantIndex, selectedVariantIndex);
         if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
           fatalError = new BehindLiveWindowException();
           return;
@@ -467,9 +422,11 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
       if (previousTsChunk == null) {
         chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
             true, true) + mediaPlaylist.mediaSequence;
+      } else if (switchingVariant) {
+        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
+            previousTsChunk.startTimeUs, true, true) + mediaPlaylist.mediaSequence;
       } else {
-        chunkMediaSequence = switchingVariantSpliced
-            ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
+        chunkMediaSequence = previousTsChunk.getNextChunkIndex();
       }
     }
 
@@ -477,8 +434,8 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
     if (chunkIndex >= mediaPlaylist.segments.size()) {
       if (!mediaPlaylist.live) {
         out.endOfStream = true;
-      } else if (shouldRerequestLiveMediaPlaylist(nextVariantIndex)) {
-        out.chunk = newMediaPlaylistChunk(nextVariantIndex);
+      } else if (shouldRerequestLiveMediaPlaylist(selectedVariantIndex)) {
+        out.chunk = newMediaPlaylistChunk(selectedVariantIndex);
       }
       return;
     }
@@ -510,10 +467,9 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
     if (live) {
       if (previousTsChunk == null) {
         startTimeUs = 0;
-      } else if (switchingVariantSpliced) {
-        startTimeUs = previousTsChunk.startTimeUs;
       } else {
-        startTimeUs = previousTsChunk.endTimeUs;
+        startTimeUs = previousTsChunk.getAdjustedEndTimeUs()
+            - (switchingVariant ? previousTsChunk.getDurationUs() : 0);
       }
     } else /* Not live */ {
       startTimeUs = segment.startTimeUs;
@@ -531,11 +487,11 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
       // case below.
       Extractor extractor = new AdtsExtractor(startTimeUs);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+          switchingVariant, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
     } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
       Extractor extractor = new Mp3Extractor(startTimeUs);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+          switchingVariant, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
     } else if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
         || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
       PtsTimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(isMaster,
@@ -548,7 +504,7 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
       }
       Extractor extractor = new WebvttExtractor(timestampAdjuster);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+          switchingVariant, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
     } else if (previousTsChunk == null
         || previousTsChunk.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
         || !format.equals(previousTsChunk.format)) {
@@ -575,12 +531,11 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
       Extractor extractor = new TsExtractor(timestampAdjuster, workaroundFlags);
       ExposedTrack selectedTrack = tracks.get(selectedTrackIndex);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, selectedTrack.adaptiveMaxWidth, selectedTrack.adaptiveMaxHeight);
+          switchingVariant, selectedTrack.adaptiveMaxWidth, selectedTrack.adaptiveMaxHeight);
     } else {
       // MPEG-2 TS segments, and we need to continue using the same extractor.
       extractorWrapper = previousTsChunk.extractorWrapper;
     }
-
     out.chunk = new TsChunk(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs,
         chunkMediaSequence, segment.discontinuitySequenceNumber, extractorWrapper, encryptionKey,
         encryptionIv);
@@ -717,6 +672,55 @@ protected int computeDefaultVariantIndex(HlsMasterPlaylist playlist, Variant[] v
   
   // Private methods.
 
+  private int getLiveStartChunkSequenceNumber(int variantIndex) {
+    // For live start playback from the third chunk from the end.
+    HlsMediaPlaylist mediaPlaylist = variantPlaylists[variantIndex];
+    int chunkIndex = mediaPlaylist.segments.size() > 3 ? mediaPlaylist.segments.size() - 3 : 0;
+    return chunkIndex + mediaPlaylist.mediaSequence;
+  }
+
+  /**
+   * Returns the media sequence number of a chunk in a new variant for a live stream variant switch.
+   *
+   * @param previousChunkIndex The index of the last chunk in the old variant.
+   * @param oldVariantIndex The index of the old variant.
+   * @param newVariantIndex The index of the new variant.
+   * @return Media sequence number of the chunk to switch to in a live stream in the variant that
+   *     corresponds to the given {@code newVariantIndex}.
+   */
+  private int getLiveNextChunkSequenceNumber(int previousChunkIndex, int oldVariantIndex,
+      int newVariantIndex) {
+    if (oldVariantIndex == newVariantIndex) {
+      return previousChunkIndex + 1;
+    }
+    HlsMediaPlaylist oldMediaPlaylist = variantPlaylists[oldVariantIndex];
+    HlsMediaPlaylist newMediaPlaylist = variantPlaylists[newVariantIndex];
+    double offsetToLiveInstantSecs = 0;
+    for (int i = previousChunkIndex - oldMediaPlaylist.mediaSequence;
+         i < oldMediaPlaylist.segments.size(); i++) {
+      offsetToLiveInstantSecs += oldMediaPlaylist.segments.get(i).durationSecs;
+    }
+    long currentTimeMs = SystemClock.elapsedRealtime();
+    offsetToLiveInstantSecs +=
+        (double) (currentTimeMs - variantLastPlaylistLoadTimesMs[oldVariantIndex]) / 1000;
+    offsetToLiveInstantSecs += LIVE_VARIANT_SWITCH_SAFETY_EXTRA_SECS;
+    offsetToLiveInstantSecs -=
+        (double) (currentTimeMs - variantLastPlaylistLoadTimesMs[newVariantIndex]) / 1000;
+    if (offsetToLiveInstantSecs < 0) {
+      // The instant we are looking for is not contained in the playlist, we need it to be
+      // refreshed.
+      return newMediaPlaylist.mediaSequence + newMediaPlaylist.segments.size() + 1;
+    }
+    for (int i = newMediaPlaylist.segments.size() - 1; i >= 0; i--) {
+      offsetToLiveInstantSecs -= newMediaPlaylist.segments.get(i).durationSecs;
+      if (offsetToLiveInstantSecs < 0) {
+        return newMediaPlaylist.mediaSequence + i;
+      }
+    }
+    // We have fallen behind the live window.
+    return newMediaPlaylist.mediaSequence - 1;
+  }
+
   private int getNextVariantIndex(TsChunk previousTsChunk, long playbackPositionUs) {
     clearStaleBlacklistedVariants();
     long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
@@ -739,9 +743,8 @@ private int getNextVariantIndex(TsChunk previousTsChunk, long playbackPositionUs
     }
     // We're not using the ideal variant for the available bandwidth, but only switch if the
     // conditions are appropriate.
-    long bufferedPositionUs = adaptiveMode == ADAPTIVE_MODE_SPLICE ? previousTsChunk.startTimeUs
-        : previousTsChunk.endTimeUs;
-    long bufferedUs = bufferedPositionUs - playbackPositionUs;
+    long bufferedUs = previousTsChunk.getAdjustedEndTimeUs() - previousTsChunk.getDurationUs()
+        - playbackPositionUs;
     if (variantBlacklistTimes[selectedVariantIndex] != 0
         || (idealIndex > selectedVariantIndex && bufferedUs < maxBufferDurationToSwitchDownUs)
         || (idealIndex < selectedVariantIndex && bufferedUs > minBufferDurationToSwitchUpUs)) {
@@ -780,13 +783,6 @@ private boolean shouldRerequestLiveMediaPlaylist(int nextVariantIndex) {
     return timeSinceLastMediaPlaylistLoadMs >= (mediaPlaylist.targetDurationSecs * 1000) / 2;
   }
 
-  private int getLiveStartChunkMediaSequence(int variantIndex) {
-    // For live start playback from the third chunk from the end.
-    HlsMediaPlaylist mediaPlaylist = variantPlaylists[variantIndex];
-    int chunkIndex = mediaPlaylist.segments.size() > 3 ? mediaPlaylist.segments.size() - 3 : 0;
-    return chunkIndex + mediaPlaylist.mediaSequence;
-  }
-
   private MediaPlaylistChunk newMediaPlaylistChunk(int variantIndex) {
     Uri mediaPlaylistUri = UriUtil.resolveToUri(baseUri, variants[variantIndex].url);
     DataSpec dataSpec = new DataSpec(mediaPlaylistUri, 0, C.LENGTH_UNBOUNDED, null,
@@ -835,8 +831,8 @@ private void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist)
   }
 
   private boolean allVariantsBlacklisted() {
-    for (int i = 0; i < variantBlacklistTimes.length; i++) {
-      if (variantBlacklistTimes[i] == 0) {
+    for (long variantBlacklistTime : variantBlacklistTimes) {
+      if (variantBlacklistTime == 0) {
         return false;
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
index cb0b95f0c5..aada4c3039 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
@@ -242,6 +242,15 @@ public int read(ExtractorInput input) throws IOException, InterruptedException {
     return result;
   }
 
+  public long getAdjustedEndTimeUs() {
+    long largestAdjustedPtsParsed = Long.MIN_VALUE;
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      largestAdjustedPtsParsed = Math.max(largestAdjustedPtsParsed,
+          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
+    }
+    return largestAdjustedPtsParsed;
+  }
+
   // ExtractorOutput implementation.
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
index 8354e312d0..3388a09d95 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
@@ -44,6 +44,7 @@
   private final boolean isEncrypted;
 
   private int bytesLoaded;
+  private long adjustedEndTimeUs;
   private volatile boolean loadCanceled;
 
   /**
@@ -68,6 +69,7 @@ public TsChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format for
     this.extractorWrapper = extractorWrapper;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+    adjustedEndTimeUs = startTimeUs;
   }
 
   @Override
@@ -114,6 +116,10 @@ public void load() throws IOException, InterruptedException {
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
           result = extractorWrapper.read(input);
         }
+        long tsChunkEndTimeUs = extractorWrapper.getAdjustedEndTimeUs();
+        if (tsChunkEndTimeUs != Long.MIN_VALUE) {
+          adjustedEndTimeUs = tsChunkEndTimeUs;
+        }
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
@@ -122,6 +128,10 @@ public void load() throws IOException, InterruptedException {
     }
   }
 
+  public long getAdjustedEndTimeUs() {
+    return adjustedEndTimeUs;
+  }
+
   // Private methods
 
   /**
