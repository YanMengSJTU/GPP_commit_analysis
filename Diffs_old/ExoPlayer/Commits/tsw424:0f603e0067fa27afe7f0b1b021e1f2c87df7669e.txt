diff --git a/ISSUE_TEMPLATE b/ISSUE_TEMPLATE
new file mode 100644
index 0000000000..3667c8cc96
--- /dev/null
+++ b/ISSUE_TEMPLATE
@@ -0,0 +1,17 @@
+Please search the existing issues before filing a new one, including issues that
+are closed. When filing a new issue please include all of the following, unless
+you're certain that they're not useful for the particular issue being reported.
+
+- A description of the issue.
+- Steps describing how the issue can be reproduced, ideally in the ExoPlayer
+  demo app.
+- A link to content that reproduces the issue. If you don't wish to post it
+  publicly, please submit the issue, then email the link to
+  dev.exoplayer@gmail.com including the issue number in the subject line.
+- The version of ExoPlayer being used.
+- The device(s) and version(s) of Android on which the issue can be reproduced,
+  and how easily it reproduces. If possible, please test on multiple devices and
+  Android versions.
+- A bug report taken from the device just after the issue occurs, attached as a
+  file. A bug report can be captured using "adb bugreport". Output from "adb
+  logcat" or a log snippet is not sufficient.
diff --git a/README.md b/README.md
index 58b954f350..edb10d4e58 100644
--- a/README.md
+++ b/README.md
@@ -7,12 +7,6 @@ supported by Androidâ€™s MediaPlayer API, including DASH and SmoothStreaming
 adaptive playbacks. Unlike the MediaPlayer API, ExoPlayer is easy to customize
 and extend, and can be updated through Play Store application updates.
 
-## News ##
-
-Read news, hints and tips on the [news][] page.
-
-[news]: https://google.github.io/ExoPlayer/news.html
-
 ## Documentation ##
 
 * The [developer guide][] provides a wealth of information to help you get
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 7325abae89..7aa0cf345a 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,13 @@
 # Release notes #
 
+### r1.5.9 ###
+
+* MP4: Fixed incorrect sniffing in some cases (#1523).
+* MP4: Improved file compatibility (#1567).
+* ID3: Support for TIT2 and APIC frames.
+* Fixed querying of platform decoders on some devices.
+* Misc bug fixes.
+
 ### r1.5.8 ###
 
 * HLS: Fix handling of HTTP redirects.
diff --git a/build.gradle b/build.gradle
index ca11487c42..04247da05f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -20,7 +20,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
+        classpath 'com.android.tools.build:gradle:2.1.0'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 42a97407e1..eb82362593 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1508"
-    android:versionName="1.5.8"
+    android:versionCode="1509"
+    android:versionName="1.5.9"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index a104cc04e4..15529e2bad 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -30,9 +30,11 @@
 import com.google.android.exoplayer.demo.player.HlsRendererBuilder;
 import com.google.android.exoplayer.demo.player.SmoothStreamingRendererBuilder;
 import com.google.android.exoplayer.drm.UnsupportedDrmException;
+import com.google.android.exoplayer.metadata.id3.ApicFrame;
 import com.google.android.exoplayer.metadata.id3.GeobFrame;
 import com.google.android.exoplayer.metadata.id3.Id3Frame;
 import com.google.android.exoplayer.metadata.id3.PrivFrame;
+import com.google.android.exoplayer.metadata.id3.TextInformationFrame;
 import com.google.android.exoplayer.metadata.id3.TxxxFrame;
 import com.google.android.exoplayer.text.CaptionStyleCompat;
 import com.google.android.exoplayer.text.Cue;
@@ -646,6 +648,14 @@ public void onId3Metadata(List<Id3Frame> id3Frames) {
         GeobFrame geobFrame = (GeobFrame) id3Frame;
         Log.i(TAG, String.format("ID3 TimedMetadata %s: mimeType=%s, filename=%s, description=%s",
             geobFrame.id, geobFrame.mimeType, geobFrame.filename, geobFrame.description));
+      } else if (id3Frame instanceof ApicFrame) {
+        ApicFrame apicFrame = (ApicFrame) id3Frame;
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: mimeType=%s, description=%s",
+                apicFrame.id, apicFrame.mimeType, apicFrame.description));
+      } else if (id3Frame instanceof TextInformationFrame) {
+        TextInformationFrame textInformationFrame = (TextInformationFrame) id3Frame;
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: description=%s", textInformationFrame.id,
+            textInformationFrame.description));
       } else {
         Log.i(TAG, String.format("ID3 TimedMetadata %s", id3Frame.id));
       }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index 9be0c43b76..acedb96c87 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -240,6 +240,18 @@ public Sample(String name, String contentId, String provider, String uri, int ty
         + "sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature="
         + "513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300"
         + "&key=ik0", Util.TYPE_OTHER),
+    new Sample("Screens 360P (WebM,VP9,No Audio)",
+        "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segmen"
+        + "t/video-vp9-360.webm", Util.TYPE_OTHER),
+    new Sample("Screens 480p (FMP4,H264,No Audio)",
+        "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segmen"
+        + "t/video-avc-baseline-480.mp4", Util.TYPE_OTHER),
+    new Sample("Screens 1080p (FMP4,H264, No Audio)",
+        "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segmen"
+        + "t/video-137.mp4", Util.TYPE_OTHER),
+    new Sample("Screens (FMP4,AAC Audio)",
+        "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segmen"
+        + "t/audio-141.mp4", Util.TYPE_OTHER),
     new Sample("Google Play (MP3 Audio)",
         "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3", Util.TYPE_OTHER),
     new Sample("Google Play (Ogg/Vorbis Audio)",
diff --git a/demo_ext/src/main/AndroidManifest.xml b/demo_ext/src/main/AndroidManifest.xml
index 98acb700ea..62bddea0b8 100644
--- a/demo_ext/src/main/AndroidManifest.xml
+++ b/demo_ext/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.ext"
-    android:versionCode="1508"
-    android:versionName="1.5.8"
+    android:versionCode="1509"
+    android:versionName="1.5.9"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index 4e4692fd56..06e6406796 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -263,6 +263,9 @@ private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
       return false;
     }
 
+    if (inputBuffer.sampleHolder.isDecodeOnly()) {
+      inputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
     decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
diff --git a/extensions/opus/README.md b/extensions/opus/README.md
index 8b1409c423..bdf5fb2602 100644
--- a/extensions/opus/README.md
+++ b/extensions/opus/README.md
@@ -26,6 +26,8 @@ OPUS_EXT_PATH="${EXOPLAYER_ROOT}/extensions/opus/src/main"
 
 * Download the [Android NDK][] and set its location in an environment variable:
 
+[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
+
 ```
 NDK_PATH="<path to Android NDK>"
 ```
@@ -34,7 +36,7 @@ NDK_PATH="<path to Android NDK>"
 
 ```
 cd "${OPUS_EXT_PATH}/jni" && \
-git clone git://git.opus-codec.org/opus.git libopus
+git clone https://git.xiph.org/opus.git libopus
 ```
 
 * Run the script to convert arm assembly to NDK compatible format:
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index c67eed99ae..8903232d2b 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -275,6 +275,9 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
       return false;
     }
 
+    if (inputBuffer.sampleHolder.isDecodeOnly()) {
+      inputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
     decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 28252fdfda..1937d47b2b 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -26,6 +26,8 @@ VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 
 * Download the [Android NDK][] and set its location in an environment variable:
 
+[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
+
 ```
 NDK_PATH="<path to Android NDK>"
 ```
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index 2dc9c6e6f0..cb7963f8fa 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -288,7 +288,7 @@ private boolean processOutputBuffer(long positionUs)
 
   private void renderBuffer() {
     codecCounters.renderedOutputBufferCount++;
-    notifyIfVideoSizeChanged(outputBuffer);
+    notifyIfVideoSizeChanged(outputBuffer.width, outputBuffer.height);
     if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_RGB && surface != null) {
       renderRgbFrame(outputBuffer, scaleToFit);
       if (!drawnToSurface) {
@@ -350,6 +350,9 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
 
     inputBuffer.width = format.width;
     inputBuffer.height = format.height;
+    if (inputBuffer.sampleHolder.isDecodeOnly()) {
+      inputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
     decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
@@ -462,16 +465,16 @@ private void setOutputBufferRenderer(VpxOutputBufferRenderer outputBufferRendere
     }
   }
 
-  private void notifyIfVideoSizeChanged(final VpxOutputBuffer outputBuffer) {
-    if (previousWidth == -1 || previousHeight == -1
-        || previousWidth != outputBuffer.width || previousHeight != outputBuffer.height) {
-      previousWidth = outputBuffer.width;
-      previousHeight = outputBuffer.height;
+  private void notifyIfVideoSizeChanged(final int width, final int height) {
+    if (previousWidth == -1 || previousHeight == -1 || previousWidth != width
+        || previousHeight != height) {
+      previousWidth = width;
+      previousHeight = height;
       if (eventHandler != null && eventListener != null) {
         eventHandler.post(new Runnable()  {
           @Override
           public void run() {
-            eventListener.onVideoSizeChanged(outputBuffer.width, outputBuffer.height);
+            eventListener.onVideoSizeChanged(width, height);
           }
         });
       }
diff --git a/library/build.gradle b/library/build.gradle
index 65f3ad2d60..a0d11bddcf 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.8'
+    version = 'r1.5.9'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java
index 6946ba3b07..083ec2d939 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer.metadata.id3;
 
+import com.google.android.exoplayer.ParserException;
+
+import android.test.MoreAsserts;
 import junit.framework.TestCase;
 
 import java.util.List;
@@ -24,21 +27,42 @@
  */
 public class Id3ParserTest extends TestCase {
 
-  public void testParseTxxxFrames() {
-    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31,
-        0, 0, 3, 0, 109, 100, 105, 97, 108, 111, 103, 95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50,
-        55, 54, 54, 52, 95, 115, 116, 97, 114, 116, 0};
+  public void testParseTxxxFrame() throws ParserException {
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31, 0, 0,
+        3, 0, 109, 100, 105, 97, 108, 111, 103, 95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50, 55, 54,
+        54, 52, 95, 115, 116, 97, 114, 116, 0};
+    Id3Parser parser = new Id3Parser();
+    List<Id3Frame> id3Frames = parser.parse(rawId3, rawId3.length);
+    assertEquals(1, id3Frames.size());
+    TxxxFrame txxxFrame = (TxxxFrame) id3Frames.get(0);
+    assertEquals("", txxxFrame.description);
+    assertEquals("mdialog_VINDICO1527664_start", txxxFrame.value);
+  }
+
+  public void testParseApicFrame() throws ParserException {
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 45, 65, 80, 73, 67, 0, 0, 0, 35, 0, 0,
+        3, 105, 109, 97, 103, 101, 47, 106, 112, 101, 103, 0, 16, 72, 101, 108, 108, 111, 32, 87,
+        111, 114, 108, 100, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
+    Id3Parser parser = new Id3Parser();
+    List<Id3Frame> id3Frames = parser.parse(rawId3, rawId3.length);
+    assertEquals(1, id3Frames.size());
+    ApicFrame apicFrame = (ApicFrame) id3Frames.get(0);
+    assertEquals("image/jpeg", apicFrame.mimeType);
+    assertEquals(16, apicFrame.pictureType);
+    assertEquals("Hello World", apicFrame.description);
+    assertEquals(10, apicFrame.pictureData.length);
+    MoreAsserts.assertEquals(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}, apicFrame.pictureData);
+  }
+
+  public void testParseTextInformationFrame() throws ParserException {
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 23, 84, 73, 84, 50, 0, 0, 0, 13, 0, 0,
+        3, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0};
     Id3Parser parser = new Id3Parser();
-    try {
-      List<Id3Frame> id3Frames = parser.parse(rawId3, rawId3.length);
-      assertNotNull(id3Frames);
-      assertEquals(1, id3Frames.size());
-      TxxxFrame txxxFrame = (TxxxFrame) id3Frames.get(0);
-      assertEquals("", txxxFrame.description);
-      assertEquals("mdialog_VINDICO1527664_start", txxxFrame.value);
-    } catch (Exception exception) {
-      fail(exception.getMessage());
-    }
+    List<Id3Frame> id3Frames = parser.parse(rawId3, rawId3.length);
+    assertEquals(1, id3Frames.size());
+    TextInformationFrame textInformationFrame = (TextInformationFrame) id3Frames.get(0);
+    assertEquals("TIT2", textInformationFrame.id);
+    assertEquals("Hello World", textInformationFrame.description);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
index e4cf3f6eab..6dd79fb509 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
@@ -31,7 +31,7 @@
  * <a name="Assumptions"></a>
  * <h3>Assumptions and player construction</h3>
  *
- * <p>The implementation is designed make no assumptions about (and hence impose no restrictions
+ * <p>The implementation is designed to make no assumptions about (and hence impose no restrictions
  * on) the type of the media being played, how and where it is stored, or how it is rendered.
  * Rather than implementing the loading and rendering of media directly, {@link ExoPlayer} instead
  * delegates this work to one or more {@link TrackRenderer}s, which are injected when the player
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index cf3717df6e..2c146cbcb6 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.8";
+  public static final String VERSION = "1.5.9";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  public static final int VERSION_INT = 1005008;
+  public static final int VERSION_INT = 1005009;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 55cecdc367..0468d1ed03 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -214,7 +214,7 @@ protected boolean handlesTrack(MediaCodecSelector mediaCodecSelector, MediaForma
       throws DecoderQueryException {
     String mimeType = mediaFormat.mimeType;
     return MimeTypes.isAudio(mimeType) && (MimeTypes.AUDIO_UNKNOWN.equals(mimeType)
-        || (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderName() != null)
+        || (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderInfo() != null)
         || mediaCodecSelector.getDecoderInfo(mimeType, false) != null);
   }
 
@@ -222,10 +222,10 @@ protected boolean handlesTrack(MediaCodecSelector mediaCodecSelector, MediaForma
   protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, String mimeType,
       boolean requiresSecureDecoder) throws DecoderQueryException {
     if (allowPassthrough(mimeType)) {
-      String passthroughDecoderName = mediaCodecSelector.getPassthroughDecoderName();
-      if (passthroughDecoderName != null) {
+      DecoderInfo passthroughDecoderInfo = mediaCodecSelector.getPassthroughDecoderInfo();
+      if (passthroughDecoderInfo != null) {
         passthroughEnabled = true;
-        return new DecoderInfo(passthroughDecoderName, null);
+        return passthroughDecoderInfo;
       }
     }
     passthroughEnabled = false;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
index 7341b989e0..292a405179 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
@@ -27,12 +27,7 @@
   /**
    * Default implementation of {@link MediaCodecSelector}.
    */
-  public static final MediaCodecSelector DEFAULT = new MediaCodecSelector() {
-
-    /**
-     * The name for the raw (passthrough) decoder OMX component.
-     */
-    private static final String RAW_DECODER_NAME = "OMX.google.raw.decoder";
+  MediaCodecSelector DEFAULT = new MediaCodecSelector() {
 
     @Override
     public DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
@@ -41,9 +36,8 @@ public DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder
     }
 
     @Override
-    public String getPassthroughDecoderName() throws DecoderQueryException {
-      // TODO: Return null if the raw decoder doesn't exist.
-      return RAW_DECODER_NAME;
+    public DecoderInfo getPassthroughDecoderInfo() throws DecoderQueryException {
+      return MediaCodecUtil.getPassthroughDecoderInfo();
     }
 
   };
@@ -53,20 +47,18 @@ public String getPassthroughDecoderName() throws DecoderQueryException {
    *
    * @param mimeType The mime type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
-   * @return A {@link DecoderInfo} describing the decoder to instantiate, or null if no suitable
-   *     decoder exists.
+   * @return A {@link DecoderInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
   DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
       throws DecoderQueryException;
 
   /**
-   * Gets the name of a decoder suitable for audio passthrough.
+   * Selects a decoder to instantiate for audio passthrough.
    *
-   * @return The name of a decoder suitable for audio passthrough, or null if no suitable decoder
-   *     exists.
+   * @return A {@link DecoderInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  String getPassthroughDecoderName() throws DecoderQueryException;
+  DecoderInfo getPassthroughDecoderInfo() throws DecoderQueryException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index d11255bfd1..e32675083c 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -525,7 +525,7 @@ private void readFormat(long positionUs) throws ExoPlaybackException {
     }
   }
 
-  private void flushCodec() throws ExoPlaybackException {
+  protected void flushCodec() throws ExoPlaybackException {
     codecHotswapTimeMs = -1;
     inputIndex = -1;
     outputIndex = -1;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index abd97b22cf..71610d8e44 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -55,6 +55,8 @@ private DecoderQueryException(Throwable cause) {
   }
 
   private static final String TAG = "MediaCodecUtil";
+  private static final DecoderInfo PASSTHROUGH_DECODER_INFO =
+      new DecoderInfo("OMX.google.raw.decoder", null);
 
   private static final Map<CodecKey, List<DecoderInfo>> decoderInfosCache = new HashMap<>();
 
@@ -63,20 +65,6 @@ private DecoderQueryException(Throwable cause) {
 
   private MediaCodecUtil() {}
 
-  /**
-   * Get information about the decoder that will be used for a given mime type.
-   *
-   * @param mimeType The mime type.
-   * @param secure Whether the decoder is required to support secure decryption. Always pass false
-   *     unless secure decryption really is required.
-   * @return Information about the decoder that will be used, or null if no decoder exists.
-   */
-  public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
-      throws DecoderQueryException {
-    List<DecoderInfo> decoderInfos = getDecoderInfos(mimeType, secure);
-    return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
-  }
-
   /**
    * Optional call to warm the codec cache for a given mime type.
    * <p>
@@ -96,12 +84,38 @@ public static void warmCodec(String mimeType, boolean secure) {
   }
 
   /**
-   * Returns all @{link DecoderInfo}s for the given mime type, in the order given by MediaCodecList.
+   * Gets information about a decoder suitable for audio passthrough.
+   **
+   * @return A {@link DecoderInfo} describing the decoder, or null if no suitable decoder exists.
+   */
+  public static DecoderInfo getPassthroughDecoderInfo() {
+    // TODO: Return null if the raw decoder doesn't exist.
+    return PASSTHROUGH_DECODER_INFO;
+  }
+
+  /**
+   * Get information about the preferred decoder for a given mime type.
    *
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
-   * @return A list of all @{link DecoderInfo}s for the given mime type,
+   * @return A {@link DecoderInfo} describing the decoder, or null if no suitable decoder exists.
+   */
+  public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
+      throws DecoderQueryException {
+    List<DecoderInfo> decoderInfos = getDecoderInfos(mimeType, secure);
+    return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
+  }
+
+  /**
+   * Returns all @{link DecoderInfo}s for a given mime type, in the order given by
+   * {@link MediaCodecList}.
+   *
+   * @param mimeType The mime type.
+   * @param secure Whether the decoders are required to support secure decryption. Always pass false
+   *     unless secure decryption really is required.
+   * @return A list of all @{link DecoderInfo}s for the given mime type. May be empty if no suitable
+   *     decoders exist.
    */
   public static synchronized List<DecoderInfo> getDecoderInfos(String mimeType, boolean secure)
       throws DecoderQueryException {
@@ -116,8 +130,6 @@ public static void warmCodec(String mimeType, boolean secure) {
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
-      // TODO: Verify that the issue cannot occur on API levels 22 and 23, and tighten this block
-      // to execute on API level 21 only if confirmed.
       mediaCodecList = new MediaCodecListCompatV16();
       decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
       if (!decoderInfos.isEmpty()) {
@@ -144,15 +156,27 @@ public static void warmCodec(String mimeType, boolean secure) {
         if (isCodecUsableDecoder(codecInfo, codecName, secureDecodersExplicit)) {
           for (String supportedType : codecInfo.getSupportedTypes()) {
             if (supportedType.equalsIgnoreCase(mimeType)) {
-              CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
-              boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
-              if ((secureDecodersExplicit && key.secure == secure)
-                  || (!secureDecodersExplicit && !key.secure)) {
-                decoderInfos.add(new DecoderInfo(codecName, capabilities));
-              } else if (!secureDecodersExplicit && secure) {
-                decoderInfos.add(new DecoderInfo(codecName + ".secure", capabilities));
-                // It only makes sense to have one synthesized secure decoder, return immediately.
-                return decoderInfos;
+              try {
+                CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+                boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
+                if ((secureDecodersExplicit && key.secure == secure)
+                    || (!secureDecodersExplicit && !key.secure)) {
+                  decoderInfos.add(new DecoderInfo(codecName, capabilities));
+                } else if (!secureDecodersExplicit && secure) {
+                  decoderInfos.add(new DecoderInfo(codecName + ".secure", capabilities));
+                  // It only makes sense to have one synthesized secure decoder, return immediately.
+                  return decoderInfos;
+                }
+              } catch (Exception e) {
+                if (Util.SDK_INT <= 23 && !decoderInfos.isEmpty()) {
+                  // Suppress error querying secondary codec capabilities up to API level 23.
+                  Log.e(TAG, "Skipping codec " + codecName + " (failed to query capabilities)");
+                } else {
+                  // Rethrow error querying primary codec capabilities, or secondary codec
+                  // capabilities if API level is greater than 23.
+                  Log.e(TAG, "Failed to query codec " + codecName + " (" + supportedType + ")");
+                  throw e;
+                }
               }
             }
           }
@@ -184,9 +208,15 @@ private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
             || "MP3Decoder".equals(name)) {
       return false;
     }
+    // Work around https://github.com/google/ExoPlayer/issues/398
     if (Util.SDK_INT < 18 && "OMX.SEC.MP3.Decoder".equals(name)) {
       return false;
     }
+    // Work around https://github.com/google/ExoPlayer/issues/1528
+    if (Util.SDK_INT < 18 && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
+        && "a70".equals(Util.DEVICE)) {
+      return false;
+    }
 
     // Work around an issue where creating a particular MP3 decoder on some devices on platform API
     // version 16 crashes mediaserver.
@@ -300,6 +330,8 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
         for (CodecProfileLevel profileLevel : decoderInfo.capabilities.profileLevels) {
           result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
         }
+        // We assume support for at least 360p.
+        result = Math.max(result, 480 * 360);
       }
       maxH264DecodableFrameSize = result;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
index 0c585419e7..7589731a13 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
@@ -32,7 +32,7 @@
  * <p>
  * The wrapper allows switching of the {@link SingleTrackOutput} that receives parsed data.
  */
-public final class ChunkExtractorWrapper implements ExtractorOutput, TrackOutput {
+public class ChunkExtractorWrapper implements ExtractorOutput, TrackOutput {
 
   /**
    * Receives stream level data extracted by the wrapped {@link Extractor}.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index 67265e7695..cc3dad6a05 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -52,6 +52,8 @@
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
+  protected final DefaultTrackOutput sampleQueue;
+
   private static final int STATE_IDLE = 0;
   private static final int STATE_INITIALIZED = 1;
   private static final int STATE_PREPARED = 2;
@@ -65,7 +67,6 @@
   private final ChunkOperationHolder currentLoadableHolder;
   private final LinkedList<BaseMediaChunk> mediaChunks;
   private final List<BaseMediaChunk> readOnlyMediaChunks;
-  private final DefaultTrackOutput sampleQueue;
   private final int bufferSizeContribution;
   private final Handler eventHandler;
   private final EventListener eventListener;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index f6da60fab6..44ccbee400 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -82,6 +82,7 @@
   public static final int TYPE_moof = Util.getIntegerCodeForString("moof");
   public static final int TYPE_traf = Util.getIntegerCodeForString("traf");
   public static final int TYPE_mvex = Util.getIntegerCodeForString("mvex");
+  public static final int TYPE_mehd = Util.getIntegerCodeForString("mehd");
   public static final int TYPE_tkhd = Util.getIntegerCodeForString("tkhd");
   public static final int TYPE_edts = Util.getIntegerCodeForString("edts");
   public static final int TYPE_elst = Util.getIntegerCodeForString("elst");
@@ -98,6 +99,8 @@
   public static final int TYPE_frma = Util.getIntegerCodeForString("frma");
   public static final int TYPE_saiz = Util.getIntegerCodeForString("saiz");
   public static final int TYPE_saio = Util.getIntegerCodeForString("saio");
+  public static final int TYPE_sbgp = Util.getIntegerCodeForString("sbgp");
+  public static final int TYPE_sgpd = Util.getIntegerCodeForString("sgpd");
   public static final int TYPE_uuid = Util.getIntegerCodeForString("uuid");
   public static final int TYPE_senc = Util.getIntegerCodeForString("senc");
   public static final int TYPE_pasp = Util.getIntegerCodeForString("pasp");
@@ -122,6 +125,7 @@
   public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
+  public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
   public static final int TYPE_DASHES = Util.getIntegerCodeForString("----");
 
   public final int type;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 14e14e9952..d8f34b415d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -44,10 +44,13 @@
    *
    * @param trak Atom to parse.
    * @param mvhd Movie header atom, used to get the timescale.
+   * @param duration The duration in units of the timescale declared in the mvhd atom, or -1 if the
+   *     duration should be parsed from the tkhd atom.
    * @param isQuickTime True for QuickTime media. False otherwise.
    * @return A {@link Track} instance, or {@code null} if the track's type isn't supported.
    */
-  public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, boolean isQuickTime) {
+  public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long duration,
+      boolean isQuickTime) {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
     int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
     if (trackType != Track.TYPE_soun && trackType != Track.TYPE_vide && trackType != Track.TYPE_text
@@ -56,7 +59,9 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, boole
     }
 
     TkhdData tkhdData = parseTkhd(trak.getLeafAtomOfType(Atom.TYPE_tkhd).data);
-    long duration = tkhdData.duration;
+    if (duration == -1) {
+      duration = tkhdData.duration;
+    }
     long movieTimescale = parseMvhd(mvhd.data);
     long durationUs;
     if (duration == -1) {
@@ -219,12 +224,19 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         remainingSamplesInChunk--;
       }
 
+      Assertions.checkArgument(remainingSamplesAtTimestampOffset == 0);
+      // Remove trailing ctts entries with 0-valued sample counts.
+      while (remainingTimestampOffsetChanges > 0) {
+        Assertions.checkArgument(ctts.readUnsignedIntToInt() == 0);
+        ctts.readInt(); // Ignore offset.
+        remainingTimestampOffsetChanges--;
+      }
+
       // Check all the expected samples have been seen.
       Assertions.checkArgument(remainingSynchronizationSamples == 0);
       Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
       Assertions.checkArgument(remainingSamplesInChunk == 0);
       Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
-      Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
     } else {
       long[] chunkOffsetsBytes = new long[chunkIterator.length];
       int[] chunkSampleCounts = new int[chunkIterator.length];
@@ -457,6 +469,11 @@ private static TkhdData parseTkhd(ParsableByteArray tkhd) {
       duration = -1;
     } else {
       duration = version == 0 ? tkhd.readUnsignedInt() : tkhd.readUnsignedLongToLong();
+      if (duration == 0) {
+        // 0 duration normally indicates that the file is fully fragmented (i.e. all of the media
+        // samples are in fragments). Treat as unknown.
+        duration = -1;
+      }
     }
 
     tkhd.skipBytes(16);
@@ -539,8 +556,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
           || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v
           || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1
           || childAtomType == Atom.TYPE_s263) {
-        parseVideoSampleEntry(stsd, childStartPosition, childAtomSize, trackId, durationUs,
-            rotationDegrees, out, i);
+        parseVideoSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
+            durationUs, rotationDegrees, out, i);
       } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3
           || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
@@ -568,8 +585,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
     return out;
   }
 
-  private static void parseVideoSampleEntry(ParsableByteArray parent, int position, int size,
-      int trackId, long durationUs, int rotationDegrees, StsdData out, int entryIndex) {
+  private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType, int position,
+      int size, int trackId, long durationUs, int rotationDegrees, StsdData out, int entryIndex) {
     parent.setPosition(position + Atom.HEADER_SIZE);
 
     parent.skipBytes(24);
@@ -579,8 +596,13 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int position
     float pixelWidthHeightRatio = 1;
     parent.skipBytes(50);
 
-    List<byte[]> initializationData = null;
     int childPosition = parent.getPosition();
+    if (atomType == Atom.TYPE_encv) {
+      parseSampleEntryEncryptionData(parent, position, size, out, entryIndex);
+      parent.setPosition(childPosition);
+    }
+
+    List<byte[]> initializationData = null;
     String mimeType = null;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
@@ -616,9 +638,6 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int position
             parseEsdsFromParent(parent, childStartPosition);
         mimeType = mimeTypeAndInitializationData.first;
         initializationData = Collections.singletonList(mimeTypeAndInitializationData.second);
-      } else if (childAtomType == Atom.TYPE_sinf) {
-        out.trackEncryptionBoxes[entryIndex] =
-            parseSinfFromParent(parent, childStartPosition, childAtomSize);
       } else if (childAtomType == Atom.TYPE_pasp) {
         pixelWidthHeightRatio = parsePaspFromParent(parent, childStartPosition);
         pixelWidthHeightRatioFromPasp = true;
@@ -740,30 +759,6 @@ private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int positi
     return Pair.create(editListDurations, editListMediaTimes);
   }
 
-  private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
-      int size) {
-    int childPosition = position + Atom.HEADER_SIZE;
-
-    TrackEncryptionBox trackEncryptionBox = null;
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_frma) {
-        parent.readInt(); // dataFormat.
-      } else if (childAtomType == Atom.TYPE_schm) {
-        parent.skipBytes(4);
-        parent.readInt(); // schemeType. Expect cenc
-        parent.readInt(); // schemeVersion. Expect 0x00010000
-      } else if (childAtomType == Atom.TYPE_schi) {
-        trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
-      }
-      childPosition += childAtomSize;
-    }
-
-    return trackEncryptionBox;
-  }
-
   private static float parsePaspFromParent(ParsableByteArray parent, int position) {
     parent.setPosition(position + Atom.HEADER_SIZE);
     int hSpacing = parent.readUnsignedIntToInt();
@@ -771,27 +766,6 @@ private static float parsePaspFromParent(ParsableByteArray parent, int position)
     return (float) hSpacing / vSpacing;
   }
 
-  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
-      int size) {
-    int childPosition = position + Atom.HEADER_SIZE;
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_tenc) {
-        parent.skipBytes(4);
-        int firstInt = parent.readInt();
-        boolean defaultIsEncrypted = (firstInt >> 8) == 1;
-        int defaultInitVectorSize = firstInt & 0xFF;
-        byte[] defaultKeyId = new byte[16];
-        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
-        return new TrackEncryptionBox(defaultIsEncrypted, defaultInitVectorSize, defaultKeyId);
-      }
-      childPosition += childAtomSize;
-    }
-    return null;
-  }
-
   private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
       int size, int trackId, long durationUs, String language, boolean isQuickTime, StsdData out,
       int entryIndex) {
@@ -831,6 +805,12 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       return;
     }
 
+    int childPosition = parent.getPosition();
+    if (atomType == Atom.TYPE_enca) {
+      atomType = parseSampleEntryEncryptionData(parent, position, size, out, entryIndex);
+      parent.setPosition(childPosition);
+    }
+
     // If the atom type determines a MIME type, set it immediately.
     String mimeType = null;
     if (atomType == Atom.TYPE_ac_3) {
@@ -852,19 +832,14 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
     }
 
     byte[] initializationData = null;
-    int childAtomPosition = parent.getPosition();
-    while (childAtomPosition - position < size) {
-      parent.setPosition(childAtomPosition);
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
       int childAtomSize = parent.readInt();
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = parent.readInt();
-      if (atomType == Atom.TYPE_mp4a || atomType == Atom.TYPE_enca) {
-        int esdsAtomPosition = -1;
-        if (childAtomType == Atom.TYPE_esds) {
-          esdsAtomPosition = childAtomPosition;
-        } else if (isQuickTime && childAtomType == Atom.TYPE_wave) {
-          esdsAtomPosition = findEsdsPosition(parent, childAtomPosition, childAtomSize);
-        }
+      if (childAtomType == Atom.TYPE_esds || (isQuickTime && childAtomType == Atom.TYPE_wave)) {
+        int esdsAtomPosition = childAtomType == Atom.TYPE_esds ? childPosition
+            : findEsdsPosition(parent, childPosition, childAtomSize);
         if (esdsAtomPosition != -1) {
           Pair<String, byte[]> mimeTypeAndInitializationData =
               parseEsdsFromParent(parent, esdsAtomPosition);
@@ -878,46 +853,32 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
             sampleRate = audioSpecificConfig.first;
             channelCount = audioSpecificConfig.second;
           }
-        } else if (childAtomType == Atom.TYPE_sinf) {
-          out.trackEncryptionBoxes[entryIndex] = parseSinfFromParent(parent, childAtomPosition,
-              childAtomSize);
         }
-      } else if (atomType == Atom.TYPE_ac_3 && childAtomType == Atom.TYPE_dac3) {
-        // TODO: Choose the right AC-3 track based on the contents of dac3/dec3.
-        // TODO: Add support for encryption (by setting out.trackEncryptionBoxes).
-        parent.setPosition(Atom.HEADER_SIZE + childAtomPosition);
+      } else if (childAtomType == Atom.TYPE_dac3) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
         out.mediaFormat = Ac3Util.parseAc3AnnexFFormat(parent, Integer.toString(trackId),
             durationUs, language);
-        return;
-      } else if (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
-        parent.setPosition(Atom.HEADER_SIZE + childAtomPosition);
+      } else if (childAtomType == Atom.TYPE_dec3) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
         out.mediaFormat = Ac3Util.parseEAc3AnnexFFormat(parent, Integer.toString(trackId),
             durationUs, language);
-        return;
-      } else if ((atomType == Atom.TYPE_dtsc || atomType == Atom.TYPE_dtse
-          || atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl)
-          && childAtomType == Atom.TYPE_ddts) {
+      } else if (childAtomType == Atom.TYPE_ddts) {
         out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate, null,
             language);
-        return;
       }
-      childAtomPosition += childAtomSize;
+      childPosition += childAtomSize;
     }
 
-    // If the media type was not recognized, ignore the track.
-    if (mimeType == null) {
-      return;
+    if (out.mediaFormat == null && mimeType != null) {
+      // TODO: Determine the correct PCM encoding.
+      int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
+          : MediaFormat.NO_VALUE;
+      out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
+          MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate,
+          initializationData == null ? null : Collections.singletonList(initializationData),
+          language, pcmEncoding);
     }
-
-    // TODO: Determine the correct PCM encoding.
-    int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
-        : MediaFormat.NO_VALUE;
-
-    out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate,
-        initializationData == null ? null : Collections.singletonList(initializationData),
-        language, pcmEncoding);
   }
 
   /** Returns the position of the esds box within a parent, or -1 if no esds box is found */
@@ -1010,6 +971,77 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
     return Pair.create(mimeType, initializationData);
   }
 
+  /**
+   * Parses encryption data from an audio/video sample entry, populating {@code out} and returning
+   * the unencrypted atom type, or 0 if no sinf atom was present.
+   */
+  private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int position,
+      int size, StsdData out, int entryIndex) {
+    int childPosition = parent.getPosition();
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_sinf) {
+        Pair<Integer, TrackEncryptionBox> result = parseSinfFromParent(parent, childPosition,
+            childAtomSize);
+        Integer dataFormat = result.first;
+        Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
+        out.trackEncryptionBoxes[entryIndex] = result.second;
+        return dataFormat;
+      }
+      childPosition += childAtomSize;
+    }
+    // This enca/encv box does not have a data format so return an invalid atom type.
+    return 0;
+  }
+
+  private static Pair<Integer, TrackEncryptionBox> parseSinfFromParent(ParsableByteArray parent,
+      int position, int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+
+    TrackEncryptionBox trackEncryptionBox = null;
+    Integer dataFormat = null;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_frma) {
+        dataFormat = parent.readInt();
+      } else if (childAtomType == Atom.TYPE_schm) {
+        parent.skipBytes(4);
+        parent.readInt(); // schemeType. Expect cenc
+        parent.readInt(); // schemeVersion. Expect 0x00010000
+      } else if (childAtomType == Atom.TYPE_schi) {
+        trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
+      }
+      childPosition += childAtomSize;
+    }
+
+    return Pair.create(dataFormat, trackEncryptionBox);
+  }
+
+  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
+      int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_tenc) {
+        parent.skipBytes(6);
+        boolean defaultIsEncrypted = parent.readUnsignedByte() == 1;
+        int defaultInitVectorSize = parent.readUnsignedByte();
+        byte[] defaultKeyId = new byte[16];
+        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
+        return new TrackEncryptionBox(defaultIsEncrypted, defaultInitVectorSize, defaultKeyId);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
   /** Parses the size of an expandable class, as specified by ISO 14496-1 subsection 8.3.3. */
   private static int parseExpandableClassSize(ParsableByteArray data) {
     int currentByte = data.readUnsignedByte();
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 4ca0266824..0fa337e7e0 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -47,9 +47,10 @@
 /**
  * Facilitates the extraction of data from the fragmented mp4 container format.
  */
-public final class FragmentedMp4Extractor implements Extractor {
+public class FragmentedMp4Extractor implements Extractor {
 
   private static final String TAG = "FragmentedMp4Extractor";
+  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
 
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -146,12 +147,12 @@ public FragmentedMp4Extractor(int flags, Track sideloadedTrack) {
   }
 
   @Override
-  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+  public final boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     return Sniffer.sniffFragmented(input);
   }
 
   @Override
-  public void init(ExtractorOutput output) {
+  public final void init(ExtractorOutput output) {
     extractorOutput = output;
     if (sideloadedTrack != null) {
       TrackBundle bundle = new TrackBundle(output.track(0));
@@ -162,18 +163,22 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek() {
+  public final void seek() {
+    int trackCount = trackBundles.size();
+    for (int i = 0; i < trackCount; i++) {
+      trackBundles.valueAt(i).reset();
+    }
     containerAtoms.clear();
     enterReadingAtomHeaderState();
   }
 
   @Override
-  public void release() {
+  public final void release() {
     // Do nothing
   }
 
   @Override
-  public int read(ExtractorInput input, PositionHolder seekPosition)
+  public final int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
     while (true) {
       switch (parserState) {
@@ -298,6 +303,8 @@ private void onLeafAtomRead(LeafAtom leaf, long inputPosition) throws ParserExce
       ChunkIndex segmentIndex = parseSidx(leaf.data, inputPosition);
       extractorOutput.seekMap(segmentIndex);
       haveOutputSeekMap = true;
+    } else if (leaf.type == Atom.TYPE_emsg) {
+      parseEmsg(leaf.data, inputPosition);
     }
   }
 
@@ -340,12 +347,15 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
     // Read declaration of track fragments in the Moov box.
     ContainerAtom mvex = moov.getContainerAtomOfType(Atom.TYPE_mvex);
     SparseArray<DefaultSampleValues> defaultSampleValuesArray = new SparseArray<>();
+    long duration = -1;
     int mvexChildrenSize = mvex.leafChildren.size();
     for (int i = 0; i < mvexChildrenSize; i++) {
       Atom.LeafAtom atom = mvex.leafChildren.get(i);
       if (atom.type == Atom.TYPE_trex) {
         Pair<Integer, DefaultSampleValues> trexData = parseTrex(atom.data);
         defaultSampleValuesArray.put(trexData.first, trexData.second);
+      } else if (atom.type == Atom.TYPE_mehd) {
+        duration = parseMehd(atom.data);
       }
     }
 
@@ -355,7 +365,8 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
     for (int i = 0; i < moovContainerChildrenSize; i++) {
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
       if (atom.type == Atom.TYPE_trak) {
-        Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd), false);
+        Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd), duration,
+            false);
         if (track != null) {
           tracks.put(track.id, track);
         }
@@ -399,6 +410,16 @@ private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException
         defaultSampleDuration, defaultSampleSize, defaultSampleFlags));
   }
 
+  /**
+   * Parses an mehd atom (defined in 14496-12).
+   */
+  private static long parseMehd(ParsableByteArray mehd) {
+    mehd.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = mehd.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+    return version == 0 ? mehd.readUnsignedInt() : mehd.readUnsignedLongToLong();
+  }
+
   private static void parseMoof(ContainerAtom moof, SparseArray<TrackBundle> trackBundleArray,
       int flags, byte[] extendedTypeScratch) throws ParserException {
     int moofContainerChildrenSize = moof.containerChildren.size();
@@ -424,15 +445,13 @@ private static void parseTraf(ContainerAtom traf, SparseArray<TrackBundle> track
     if (trackBundle == null) {
       return;
     }
+
     TrackFragment fragment = trackBundle.fragment;
-    trackBundle.currentSampleIndex = 0;
-    fragment.reset();
+    long decodeTime = fragment.nextFragmentDecodeTime;
+    trackBundle.reset();
 
     LeafAtom tfdtAtom = traf.getLeafAtomOfType(Atom.TYPE_tfdt);
-    long decodeTime;
-    if (tfdtAtom == null || (flags & FLAG_WORKAROUND_IGNORE_TFDT_BOX) != 0) {
-      decodeTime = 0;
-    } else {
+    if (tfdtAtom != null && (flags & FLAG_WORKAROUND_IGNORE_TFDT_BOX) == 0) {
       decodeTime = parseTfdt(traf.getLeafAtomOfType(Atom.TYPE_tfdt).data);
     }
 
@@ -456,6 +475,12 @@ private static void parseTraf(ContainerAtom traf, SparseArray<TrackBundle> track
       parseSenc(senc.data, fragment);
     }
 
+    LeafAtom sbgp = traf.getLeafAtomOfType(Atom.TYPE_sbgp);
+    LeafAtom sgpd = traf.getLeafAtomOfType(Atom.TYPE_sgpd);
+    if (sbgp != null && sgpd != null) {
+      parseSgpd(sbgp.data, sgpd.data, fragment);
+    }
+
     int childrenSize = traf.leafChildren.size();
     for (int i = 0; i < childrenSize; i++) {
       LeafAtom atom = traf.leafChildren.get(i);
@@ -658,6 +683,7 @@ private static void parseTrun(TrackBundle trackBundle, long decodeTime, int flag
           && (!workaroundEveryVideoFrameIsSyncFrame || i == 0);
       cumulativeTime += sampleDuration;
     }
+    fragment.nextFragmentDecodeTime = cumulativeTime;
   }
 
   private static void parseUuid(ParsableByteArray uuid, TrackFragment out,
@@ -702,6 +728,55 @@ private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment
     out.fillEncryptionData(senc);
   }
 
+  private static void parseSgpd(ParsableByteArray sbgp, ParsableByteArray sgpd, TrackFragment out)
+      throws ParserException {
+    sbgp.setPosition(Atom.HEADER_SIZE);
+    int sbgpFullAtom = sbgp.readInt();
+    if (sbgp.readInt() != SAMPLE_GROUP_TYPE_seig) {
+      // Only seig grouping type is supported.
+      return;
+    }
+    if (Atom.parseFullAtomVersion(sbgpFullAtom) == 1) {
+      sbgp.skipBytes(4);
+    }
+    if (sbgp.readInt() != 1) {
+      throw new ParserException("Entry count in sbgp != 1 (unsupported).");
+    }
+
+    sgpd.setPosition(Atom.HEADER_SIZE);
+    int sgpdFullAtom = sgpd.readInt();
+    if (sgpd.readInt() != SAMPLE_GROUP_TYPE_seig) {
+      // Only seig grouping type is supported.
+      return;
+    }
+    int sgpdVersion = Atom.parseFullAtomVersion(sgpdFullAtom);
+    if (sgpdVersion == 1) {
+      if (sgpd.readUnsignedInt() == 0) {
+        throw new ParserException("Variable length decription in sgpd found (unsupported)");
+      }
+    } else if (sgpdVersion >= 2) {
+      sgpd.skipBytes(4);
+    }
+    if (sgpd.readUnsignedInt() != 1) {
+      throw new ParserException("Entry count in sgpd != 1 (unsupported).");
+    }
+    // CencSampleEncryptionInformationGroupEntry
+    sgpd.skipBytes(2);
+    boolean isProtected = sgpd.readUnsignedByte() == 1;
+    if (!isProtected) {
+      return;
+    }
+    int initVectorSize = sgpd.readUnsignedByte();
+    byte[] keyId = new byte[16];
+    sgpd.readBytes(keyId, 0, keyId.length);
+    out.definesEncryptionData = true;
+    out.trackEncryptionBox = new TrackEncryptionBox(isProtected, initVectorSize, keyId);
+  }
+
+  protected void parseEmsg(ParsableByteArray atom, long inputPosition) throws ParserException {
+    // Do nothing.
+  }
+
   /**
    * Parses a sidx atom (defined in 14496-12).
    */
@@ -878,8 +953,12 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     int sampleFlags = (fragment.definesEncryptionData ? C.SAMPLE_FLAG_ENCRYPTED : 0)
         | (fragment.sampleIsSyncFrameTable[sampleIndex] ? C.SAMPLE_FLAG_SYNC : 0);
     int sampleDescriptionIndex = fragment.header.sampleDescriptionIndex;
-    byte[] encryptionKey = fragment.definesEncryptionData
-        ? track.sampleDescriptionEncryptionBoxes[sampleDescriptionIndex].keyId : null;
+    byte[] encryptionKey = null;
+    if (fragment.definesEncryptionData) {
+      encryptionKey = fragment.trackEncryptionBox != null
+          ? fragment.trackEncryptionBox.keyId
+          : track.sampleDescriptionEncryptionBoxes[sampleDescriptionIndex].keyId;
+    }
     output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
 
     currentTrackBundle.currentSampleIndex++;
@@ -926,8 +1005,9 @@ private int appendSampleEncryptionData(TrackBundle trackBundle) {
     TrackFragment trackFragment = trackBundle.fragment;
     ParsableByteArray sampleEncryptionData = trackFragment.sampleEncryptionData;
     int sampleDescriptionIndex = trackFragment.header.sampleDescriptionIndex;
-    TrackEncryptionBox encryptionBox = trackBundle.track
-        .sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
+    TrackEncryptionBox encryptionBox = trackFragment.trackEncryptionBox != null
+        ? trackFragment.trackEncryptionBox
+        : trackBundle.track.sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
     int vectorSize = encryptionBox.initializationVectorSize;
     boolean subsampleEncryption = trackFragment
         .sampleHasSubsampleEncryptionTable[trackBundle.currentSampleIndex];
@@ -957,8 +1037,9 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_sidx || atom == Atom.TYPE_stsd || atom == Atom.TYPE_tfdt
         || atom == Atom.TYPE_tfhd || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_trex
         || atom == Atom.TYPE_trun || atom == Atom.TYPE_pssh || atom == Atom.TYPE_saiz
-        || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid
-        || atom == Atom.TYPE_elst;
+        || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_sbgp
+        || atom == Atom.TYPE_sgpd || atom == Atom.TYPE_uuid || atom == Atom.TYPE_elst
+        || atom == Atom.TYPE_mehd || atom == Atom.TYPE_emsg;
   }
 
   /** Returns whether the extractor should parse a container atom with type {@code atom}. */
@@ -989,6 +1070,10 @@ public void init(Track track, DefaultSampleValues defaultSampleValues) {
       this.track = Assertions.checkNotNull(track);
       this.defaultSampleValues = Assertions.checkNotNull(defaultSampleValues);
       output.format(track.mediaFormat);
+      reset();
+    }
+
+    public void reset() {
       fragment.reset();
       currentSampleIndex = 0;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index ff25ea03bc..bde4d5f129 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -301,7 +301,7 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
         continue;
       }
 
-      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd),
+      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd), -1,
           isQuickTime);
       if (track == null) {
         continue;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java
index 96878b82d9..9c29413d7c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java
@@ -28,9 +28,18 @@
  */
 /* package */ final class Sniffer {
 
+  /**
+   * The maximum number of bytes to peek when sniffing.
+   */
+  private static final int SEARCH_LENGTH = 4 * 1024;
+
   private static final int[] COMPATIBLE_BRANDS = new int[] {
       Util.getIntegerCodeForString("isom"),
       Util.getIntegerCodeForString("iso2"),
+      Util.getIntegerCodeForString("iso3"),
+      Util.getIntegerCodeForString("iso4"),
+      Util.getIntegerCodeForString("iso5"),
+      Util.getIntegerCodeForString("iso6"),
       Util.getIntegerCodeForString("avc1"),
       Util.getIntegerCodeForString("hvc1"),
       Util.getIntegerCodeForString("hev1"),
@@ -62,7 +71,7 @@
    */
   public static boolean sniffFragmented(ExtractorInput input)
       throws IOException, InterruptedException {
-    return sniffInternal(input, 4 * 1024, true);
+    return sniffInternal(input, true);
   }
 
   /**
@@ -76,19 +85,19 @@ public static boolean sniffFragmented(ExtractorInput input)
    */
   public static boolean sniffUnfragmented(ExtractorInput input)
       throws IOException, InterruptedException {
-    return sniffInternal(input, 128, false);
+    return sniffInternal(input, false);
   }
 
-  private static boolean sniffInternal(ExtractorInput input, int searchLength, boolean fragmented)
+  private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
       throws IOException, InterruptedException {
     long inputLength = input.getLength();
-    int bytesToSearch = (int) (inputLength == C.LENGTH_UNBOUNDED || inputLength > searchLength
-        ? searchLength : inputLength);
+    int bytesToSearch = (int) (inputLength == C.LENGTH_UNBOUNDED || inputLength > SEARCH_LENGTH
+        ? SEARCH_LENGTH : inputLength);
 
     ParsableByteArray buffer = new ParsableByteArray(64);
     int bytesSearched = 0;
     boolean foundGoodFileType = false;
-    boolean foundFragment = false;
+    boolean isFragmented = false;
     while (bytesSearched < bytesToSearch) {
       // Read an atom header.
       int headerSize = Atom.HEADER_SIZE;
@@ -97,48 +106,64 @@ private static boolean sniffInternal(ExtractorInput input, int searchLength, boo
       long atomSize = buffer.readUnsignedInt();
       int atomType = buffer.readInt();
       if (atomSize == Atom.LONG_SIZE_PREFIX) {
-        input.peekFully(buffer.data, headerSize, Atom.LONG_HEADER_SIZE - headerSize);
         headerSize = Atom.LONG_HEADER_SIZE;
-        atomSize = buffer.readLong();
+        input.peekFully(buffer.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
+        atomSize = buffer.readUnsignedLongToLong();
       }
-      // Check the atom size is large enough to include its header.
+
       if (atomSize < headerSize) {
+        // The file is invalid because the atom size is too small for its header.
         return false;
       }
-      int atomDataSize = (int) atomSize - headerSize;
+      bytesSearched += headerSize;
+
+      if (atomType == Atom.TYPE_moov) {
+        // Check for an mvex atom inside the moov atom to identify whether the file is fragmented.
+        continue;
+      }
+
+      if (atomType == Atom.TYPE_moof || atomType == Atom.TYPE_mvex) {
+        // The movie is fragmented. Stop searching as we must have read any ftyp atom already.
+        isFragmented = true;
+        break;
+      }
+
+      if (bytesSearched + atomSize - headerSize >= bytesToSearch) {
+        // Stop searching as peeking this atom would exceed the search limit.
+        break;
+      }
+
+      int atomDataSize = (int) (atomSize - headerSize);
+      bytesSearched += atomDataSize;
       if (atomType == Atom.TYPE_ftyp) {
+        // Parse the atom and check the file type/brand is compatible with the extractors.
         if (atomDataSize < 8) {
           return false;
         }
-        int compatibleBrandsCount = (atomDataSize - 8) / 4;
-        input.peekFully(buffer.data, 0, 4 * (compatibleBrandsCount + 2));
-        for (int i = 0; i < compatibleBrandsCount + 2; i++) {
+        if (buffer.capacity() < atomDataSize) {
+          buffer.reset(new byte[atomDataSize], atomDataSize);
+        }
+        input.peekFully(buffer.data, 0, atomDataSize);
+        int brandsCount = atomDataSize / 4;
+        for (int i = 0; i < brandsCount; i++) {
           if (i == 1) {
             // This index refers to the minorVersion, not a brand, so skip it.
-            continue;
-          }
-          if (isCompatibleBrand(buffer.readInt())) {
+            buffer.skipBytes(4);
+          } else if (isCompatibleBrand(buffer.readInt())) {
             foundGoodFileType = true;
             break;
           }
         }
-        // There is only one ftyp box, so reject the file if the file type in this box was invalid.
         if (!foundGoodFileType) {
+          // The types were not compatible and there is only one ftyp atom, so reject the file.
           return false;
         }
-      } else if (atomType == Atom.TYPE_moof) {
-        foundFragment = true;
-        break;
       } else if (atomDataSize != 0) {
-        // Stop searching if reading this atom would exceed the search limit.
-        if (bytesSearched + atomSize >= bytesToSearch) {
-          break;
-        }
+        // Skip the atom.
         input.advancePeekPosition(atomDataSize);
       }
-      bytesSearched += atomSize;
     }
-    return foundGoodFileType && fragmented == foundFragment;
+    return foundGoodFileType && fragmented == isFragmented;
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java
index 074802924e..fed1dca88c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java
@@ -16,7 +16,8 @@
 package com.google.android.exoplayer.extractor.mp4;
 
 /**
- * Encapsulates information parsed from a track encryption (tenc) box in an MP4 stream.
+ * Encapsulates information parsed from a track encryption (tenc) box or sample group description 
+ * (sgpd) box in an MP4 stream.
  */
 public final class TrackEncryptionBox {
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java
index c128495707..32671e3e0f 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java
@@ -80,17 +80,29 @@
    * Whether {@link #sampleEncryptionData} needs populating with the actual encryption data.
    */
   public boolean sampleEncryptionDataNeedsFill;
+  /**
+   * Fragment specific track encryption. May be null.
+   */
+  public TrackEncryptionBox trackEncryptionBox;
+
+  /**
+   * The absolute decode time of the start of the next fragment.
+   */
+  public long nextFragmentDecodeTime;
 
   /**
    * Resets the fragment.
    * <p>
-   * The {@link #length} is set to 0, and both {@link #definesEncryptionData} and
-   * {@link #sampleEncryptionDataNeedsFill} is set to false.
+   * {@link #length} and {@link #nextFragmentDecodeTime} are set to 0, both
+   * {@link #definesEncryptionData} and {@link #sampleEncryptionDataNeedsFill} is set to false,
+   * and {@link #trackEncryptionBox} is set to null.
    */
   public void reset() {
     length = 0;
+    nextFragmentDecodeTime = 0;
     definesEncryptionData = false;
     sampleEncryptionDataNeedsFill = false;
+    trackEncryptionBox = null;
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index a39d02bd00..1a38078bea 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -254,13 +254,17 @@ private void parseAdtsHeader() {
 
     if (!hasOutputFormat) {
       int audioObjectType = adtsScratch.readBits(2) + 1;
-      if (audioObjectType == 1) {
-        // The stream indicates AAC Main but it's more likely that the stream contains HE-AAC.
-        // HE-AAC cannot be represented correctly in the ADTS header because it has an
-        // audioObjectType value of 5 whereas an ADTS header can only represent values up to 4.
-        // Since most Android devices don't support AAC Main anyway, we pretend that we're dealing
-        // with AAC LC and hope for the best. In practice this often works.
-        Log.w(TAG, "Detected AAC Main audio, but assuming AAC LC.");
+      if (audioObjectType != 2) {
+        // The stream indicates AAC-Main (1), AAC-SSR (3) or AAC-LTP (4). When the stream indicates
+        // AAC-Main it's more likely that the stream contains HE-AAC (5), which cannot be
+        // represented correctly in the 2 bit audio_object_type field in the ADTS header. In
+        // practice when the stream indicates AAC-SSR or AAC-LTP it more commonly contains AAC-LC or
+        // HE-AAC. Since most Android devices don't support AAC-Main, AAC-SSR or AAC-LTP, and since
+        // indicating AAC-LC works for HE-AAC streams, we pretend that we're dealing with AAC-LC and
+        // hope for the best. In practice this often works.
+        // See: https://github.com/google/ExoPlayer/issues/774
+        // See: https://github.com/google/ExoPlayer/issues/1383
+        Log.w(TAG, "Detected audio object type: " + audioObjectType + ", but assuming AAC LC.");
         audioObjectType = 2;
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
index 2c1e6e0635..cc6000f8af 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -150,14 +150,15 @@ public void packetFinished() {
   }
 
   private void startNalUnit(long position, int offset, int nalUnitType, long pesTimeUs) {
-    if (!hasOutputFormat) {
+    if (hasOutputFormat) {
+      sampleReader.startNalUnit(position, offset, nalUnitType, pesTimeUs);
+    } else {
       vps.startNalUnit(nalUnitType);
       sps.startNalUnit(nalUnitType);
       pps.startNalUnit(nalUnitType);
     }
     prefixSei.startNalUnit(nalUnitType);
     suffixSei.startNalUnit(nalUnitType);
-    sampleReader.startNalUnit(position, offset, nalUnitType, pesTimeUs);
   }
 
   private void nalUnitData(byte[] dataArray, int offset, int limit) {
@@ -393,10 +394,12 @@ private static void skipShortTermRefPicSets(ParsableBitArray bitArray) {
     private int nalUnitBytesRead;
     private long nalUnitTimeUs;
     private boolean lookingForFirstSliceFlag;
-    private boolean firstSliceFlag;
+    private boolean isFirstSlice;
+    private boolean isFirstParameterSet;
 
     // Per sample state that gets reset at the start of each sample.
     private boolean readingSample;
+    private boolean writingParameterSets;
     private long samplePosition;
     private long sampleTimeUs;
     private boolean sampleIsKeyframe;
@@ -407,20 +410,32 @@ public SampleReader(TrackOutput output) {
 
     public void reset() {
       lookingForFirstSliceFlag = false;
-      firstSliceFlag = false;
+      isFirstSlice = false;
+      isFirstParameterSet = false;
       readingSample = false;
+      writingParameterSets = false;
     }
 
     public void startNalUnit(long position, int offset, int nalUnitType, long pesTimeUs) {
-      firstSliceFlag = false;
+      isFirstSlice = false;
+      isFirstParameterSet = false;
       nalUnitTimeUs = pesTimeUs;
       nalUnitBytesRead = 0;
       nalUnitStartPosition = position;
-      // Flush the previous sample when reading a non-VCL NAL unit.
-      if (nalUnitType >= VPS_NUT && readingSample) {
-        outputSample(offset);
-        readingSample = false;
+
+      if (nalUnitType >= VPS_NUT) {
+        if (!writingParameterSets && readingSample) {
+          // This is a non-VCL NAL unit, so flush the previous sample.
+          outputSample(offset);
+          readingSample = false;
+        }
+        if (nalUnitType <= PPS_NUT) {
+          // This sample will have parameter sets at the start.
+          isFirstParameterSet = !writingParameterSets;
+          writingParameterSets = true;
+        }
       }
+
       // Look for the flag if this NAL unit contains a slice_segment_layer_rbsp.
       nalUnitHasKeyframeData = (nalUnitType >= BLA_W_LP && nalUnitType <= CRA_NUT);
       lookingForFirstSliceFlag = nalUnitHasKeyframeData || nalUnitType <= RASL_R;
@@ -430,7 +445,7 @@ public void readNalUnitData(byte[] data, int offset, int limit) {
       if (lookingForFirstSliceFlag) {
         int headerOffset = offset + FIRST_SLICE_FLAG_OFFSET - nalUnitBytesRead;
         if (headerOffset < limit) {
-          firstSliceFlag = (data[headerOffset] & 0x80) != 0;
+          isFirstSlice = (data[headerOffset] & 0x80) != 0;
           lookingForFirstSliceFlag = false;
         } else {
           nalUnitBytesRead += limit - offset;
@@ -439,9 +454,14 @@ public void readNalUnitData(byte[] data, int offset, int limit) {
     }
 
     public void endNalUnit(long position, int offset) {
-      if (firstSliceFlag) {
-        // If the NAL unit ending is the start of a new sample, output the previous one.
+      if (writingParameterSets && isFirstSlice) {
+        // This sample has parameter sets. Reset the key-frame flag based on the first slice.
+        sampleIsKeyframe = nalUnitHasKeyframeData;
+        writingParameterSets = false;
+      } else if (isFirstParameterSet || isFirstSlice) {
+        // This NAL unit is at the start of a new sample (access unit).
         if (readingSample) {
+          // Output the sample ending before this NAL unit.
           int nalUnitLength = (int) (position - nalUnitStartPosition);
           outputSample(offset + nalUnitLength);
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index e3a1c15954..2ee6a54061 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -77,8 +77,9 @@ public void consume(ParsableByteArray data) {
       }
     }
     // Write data to the output.
-    output.sampleData(data, bytesAvailable);
-    sampleBytesRead += bytesAvailable;
+    int bytesToWrite = Math.min(bytesAvailable, sampleSize - sampleBytesRead);
+    output.sampleData(data, bytesToWrite);
+    sampleBytesRead += bytesToWrite;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
index 4ebdfcbc45..94230d24b5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
@@ -30,7 +30,7 @@
   private final int blockAlignment;
   /** Bits per sample for the audio data. */
   private final int bitsPerSample;
-  /** The pcm encoding */
+  /** The PCM encoding */
   private final int encoding;
 
   /** Offset to the start of sample data. */
@@ -55,22 +55,8 @@ public WavHeader(
 
   /** Returns the duration in microseconds of this WAV. */
   public long getDurationUs() {
-    return (getNumFrames() * C.MICROS_PER_SECOND) / sampleRateHz;
-  }
-
-  /** Returns the number of samples in this WAV. */
-  public long getNumSamples() {
-    return dataSize / getBytesPerSample();
-  }
-
-  /** Returns the number of frames in this WAV. */
-  public long getNumFrames() {
-    return getNumSamples() / getNumChannels();
-  }
-
-  /** Returns the bytes per sample of this WAV. */
-  public int getBytesPerSample() {
-    return blockAlignment / numChannels;
+    long numFrames = dataSize / blockAlignment;
+    return (numFrames * C.MICROS_PER_SECOND) / sampleRateHz;
   }
 
   /** Returns the bytes per frame of this WAV. */
@@ -97,7 +83,7 @@ public int getNumChannels() {
   public long getPosition(long timeUs) {
     long unroundedPosition = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
     // Round down to nearest frame.
-    return (unroundedPosition / numChannels) * numChannels + dataStartPosition;
+    return (unroundedPosition / blockAlignment) * blockAlignment + dataStartPosition;
   }
 
   /** Returns the time in microseconds for the given position in bytes in this WAV. */
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index fc9af7cd89..239c248096 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.BehindLiveWindowException;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.chunk.BaseChunkSampleSourceEventListener;
 import com.google.android.exoplayer.chunk.Chunk;
 import com.google.android.exoplayer.chunk.ChunkOperationHolder;
 import com.google.android.exoplayer.chunk.DataChunk;
@@ -38,6 +37,7 @@
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
+import android.os.Handler;
 import android.os.SystemClock;
 import android.text.TextUtils;
 import android.util.Log;
@@ -60,7 +60,16 @@
   /**
    * Interface definition for a callback to be notified of {@link HlsChunkSource} events.
    */
-  public interface EventListener extends BaseChunkSampleSourceEventListener {}
+  public interface EventListener {
+
+    /**
+     * Invoked when a media playlist has been loaded.
+    *
+     * @param rawResponse The raw data of the media playlist
+     */
+    void onMediaPlaylistLoadCompleted(byte[] rawResponse);
+
+  }
 
   /**
    * Adaptive switching is disabled.
@@ -158,6 +167,8 @@
   private byte[] encryptionKey;
   private String encryptionIvString;
   private byte[] encryptionIv;
+  private final EventListener eventListener;
+  private final Handler eventHandler;
 
   /**
    * @param isMaster True if this is the master source for the playback. False otherwise. Each
@@ -179,7 +190,7 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
       PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode) {
     this(isMaster, dataSource, playlist, trackSelector, bandwidthMeter,
         timestampAdjusterProvider, adaptiveMode, DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS,
-        DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS);
+        DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS, null, null);
   }
 
   /**
@@ -205,12 +216,46 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playl
       HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
       PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode,
       long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs) {
+    this(isMaster, dataSource, playlist, trackSelector, bandwidthMeter,
+         timestampAdjusterProvider, adaptiveMode, minBufferDurationToSwitchUpMs,
+         maxBufferDurationToSwitchDownMs, null, null);
+  }
+
+  /**
+   * @param isMaster True if this is the master source for the playback. False otherwise. Each
+   *     playback must have exactly one master source, which should be the source providing video
+   *     chunks (or audio chunks for audio only playbacks).
+   * @param dataSource A {@link DataSource} suitable for loading the media data.
+   * @param playlist The HLS playlist.
+   * @param trackSelector Selects tracks to be exposed by this source.
+   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+   * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
+   *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
+   *     same provider.
+   * @param adaptiveMode The mode for switching from one variant to another. One of
+   *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
+   *     {@link #ADAPTIVE_MODE_SPLICE}.
+   * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be buffered
+   *     for a switch to a higher quality variant to be considered.
+   * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
+   *     for a switch to a lower quality variant to be considered.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playlist,
+      HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
+      PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode,
+      long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs,
+      Handler eventHandler, EventListener eventListener) {
     this.isMaster = isMaster;
     this.dataSource = dataSource;
     this.trackSelector = trackSelector;
     this.bandwidthMeter = bandwidthMeter;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
     this.adaptiveMode = adaptiveMode;
+    this.eventListener = eventListener;
+    this.eventHandler = eventHandler;
     minBufferDurationToSwitchUpUs = minBufferDurationToSwitchUpMs * 1000;
     maxBufferDurationToSwitchDownUs = maxBufferDurationToSwitchDownMs * 1000;
     baseUri = playlist.baseUri;
@@ -552,6 +597,15 @@ public void onChunkLoadCompleted(Chunk chunk) {
       MediaPlaylistChunk mediaPlaylistChunk = (MediaPlaylistChunk) chunk;
       scratchSpace = mediaPlaylistChunk.getDataHolder();
       setMediaPlaylist(mediaPlaylistChunk.variantIndex, mediaPlaylistChunk.getResult());
+      if (eventHandler != null && eventListener != null) {
+        final byte[] rawResponse = mediaPlaylistChunk.getRawResponse();
+        eventHandler.post(new Runnable()  {
+          @Override
+          public void run() {
+            eventListener.onMediaPlaylistLoadCompleted(rawResponse);
+          }
+        });
+      }
     } else if (chunk instanceof EncryptionKeyChunk) {
       EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
       scratchSpace = encryptionKeyChunk.getDataHolder();
@@ -843,6 +897,7 @@ public ExposedTrack(Variant[] adaptiveVariants, int defaultVariantIndex, int max
     private final HlsPlaylistParser playlistParser;
     private final String playlistUrl;
 
+    private byte[] rawResponse;
     private HlsMediaPlaylist result;
 
     public MediaPlaylistChunk(DataSource dataSource, DataSpec dataSpec, byte[] scratchSpace,
@@ -856,8 +911,13 @@ public MediaPlaylistChunk(DataSource dataSource, DataSpec dataSpec, byte[] scrat
 
     @Override
     protected void consume(byte[] data, int limit) throws IOException {
+      rawResponse = Arrays.copyOf(data, limit);
       result = (HlsMediaPlaylist) playlistParser.parse(playlistUrl,
-          new ByteArrayInputStream(data, 0, limit));
+          new ByteArrayInputStream(rawResponse));
+    }
+
+    public byte[] getRawResponse() {
+      return rawResponse;
     }
 
     public HlsMediaPlaylist getResult() {
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index a873d30783..603dc0168b 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -306,7 +306,6 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         segmentByterangeLength = C.LENGTH_UNBOUNDED;
       } else if (line.equals(ENDLIST_TAG)) {
         live = false;
-        break;
       }
     }
     return new HlsMediaPlaylist(baseUri, mediaSequence, targetDurationSecs, version, live,
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
index 654f549b18..f934493dc4 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer.metadata;
 
-import java.io.IOException;
+import com.google.android.exoplayer.ParserException;
 
 /**
  * Parses objects of type <T> from binary data.
@@ -38,8 +38,8 @@
    * @param data The raw binary data from which to parse the metadata.
    * @param size The size of the input data.
    * @return @return A parsed metadata object of type <T>.
-   * @throws IOException If a problem occurred parsing the data.
+   * @throws ParserException If a problem occurred parsing the data.
    */
-  public T parse(byte[] data, int size) throws IOException;
+  public T parse(byte[] data, int size) throws ParserException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/id3/ApicFrame.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/ApicFrame.java
new file mode 100644
index 0000000000..d279a2e189
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/ApicFrame.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata.id3;
+
+/**
+ * APIC (Attached Picture) ID3 frame.
+ */
+public final class ApicFrame extends Id3Frame {
+
+  public static final String ID = "APIC";
+
+  public final String mimeType;
+  public final String description;
+  public final int pictureType;
+  public final byte[] pictureData;
+
+  public ApicFrame(String mimeType, String description, int pictureType, byte[] pictureData) {
+    super(ID);
+    this.mimeType = mimeType;
+    this.description = description;
+    this.pictureType = pictureType;
+    this.pictureData = pictureData;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
index deac62d8e5..7998c8eb60 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
@@ -22,6 +22,7 @@
 
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
@@ -42,8 +43,7 @@ public boolean canParse(String mimeType) {
   }
 
   @Override
-  public List<Id3Frame> parse(byte[] data, int size) throws UnsupportedEncodingException,
-      ParserException {
+  public List<Id3Frame> parse(byte[] data, int size) throws ParserException {
     List<Id3Frame> id3Frames = new ArrayList<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
     int id3Size = parseId3Header(id3Data);
@@ -60,94 +60,62 @@ public boolean canParse(String mimeType) {
 
       // Skip frame flags.
       id3Data.skipBytes(2);
-      // Check Frame ID == TXXX.
-      if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
-        int encoding = id3Data.readUnsignedByte();
-        String charset = getCharsetName(encoding);
-        byte[] frame = new byte[frameSize - 1];
-        id3Data.readBytes(frame, 0, frameSize - 1);
-
-        int firstZeroIndex = indexOfEOS(frame, 0, encoding);
-        String description = new String(frame, 0, firstZeroIndex, charset);
-        int valueStartIndex = firstZeroIndex + delimiterLength(encoding);
-        int valueEndIndex = indexOfEOS(frame, valueStartIndex, encoding);
-        String value = new String(frame, valueStartIndex, valueEndIndex - valueStartIndex, charset);
-        id3Frames.add(new TxxxFrame(description, value));
-      } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
-        // Check frame ID == PRIV
-        byte[] frame = new byte[frameSize];
-        id3Data.readBytes(frame, 0, frameSize);
-
-        int firstZeroIndex = indexOf(frame, 0, (byte) 0);
-        String owner = new String(frame, 0, firstZeroIndex, "ISO-8859-1");
-        byte[] privateData = new byte[frameSize - firstZeroIndex - 1];
-        System.arraycopy(frame, firstZeroIndex + 1, privateData, 0, frameSize - firstZeroIndex - 1);
-        id3Frames.add(new PrivFrame(owner, privateData));
-      } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
-        // Check frame ID == GEOB
-        int encoding = id3Data.readUnsignedByte();
-        String charset = getCharsetName(encoding);
-        byte[] frame = new byte[frameSize - 1];
-        id3Data.readBytes(frame, 0, frameSize - 1);
-
-        int firstZeroIndex = indexOf(frame, 0, (byte) 0);
-        String mimeType = new String(frame, 0, firstZeroIndex, "ISO-8859-1");
-        int filenameStartIndex = firstZeroIndex + 1;
-        int filenameEndIndex = indexOfEOS(frame, filenameStartIndex, encoding);
-        String filename = new String(frame, filenameStartIndex,
-            filenameEndIndex - filenameStartIndex, charset);
-        int descriptionStartIndex = filenameEndIndex + delimiterLength(encoding);
-        int descriptionEndIndex = indexOfEOS(frame, descriptionStartIndex, encoding);
-        String description = new String(frame, descriptionStartIndex,
-            descriptionEndIndex - descriptionStartIndex, charset);
-
-        int objectDataSize = frameSize - 1 /* encoding byte */ - descriptionEndIndex
-            - delimiterLength(encoding);
-        byte[] objectData = new byte[objectDataSize];
-        System.arraycopy(frame, descriptionEndIndex + delimiterLength(encoding), objectData, 0,
-            objectDataSize);
-        id3Frames.add(new GeobFrame(mimeType, filename, description, objectData));
-      } else {
-        String type = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
-        byte[] frame = new byte[frameSize];
-        id3Data.readBytes(frame, 0, frameSize);
-        id3Frames.add(new BinaryFrame(type, frame));
-      }
 
-      id3Size -= frameSize + 10 /* header size */;
+      try {
+        Id3Frame frame;
+        if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
+          frame = parseTxxxFrame(id3Data, frameSize);
+        } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
+          frame = parsePrivFrame(id3Data, frameSize);
+        } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
+          frame = parseGeobFrame(id3Data, frameSize);
+        } else if (frameId0 == 'A' && frameId1 == 'P' && frameId2 == 'I' && frameId3 == 'C') {
+          frame = parseApicFrame(id3Data, frameSize);
+        } else if (frameId0 == 'T') {
+          String id = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+          frame = parseTextInformationFrame(id3Data, frameSize, id);
+        } else {
+          String id = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+          frame = parseBinaryFrame(id3Data, frameSize, id);
+        }
+        id3Frames.add(frame);
+        id3Size -= frameSize + 10 /* header size */;
+      } catch (UnsupportedEncodingException e) {
+        throw new ParserException(e);
+      }
     }
 
     return Collections.unmodifiableList(id3Frames);
   }
 
-  private static int indexOf(byte[] data, int fromIndex, byte key) {
-    for (int i = fromIndex; i < data.length; i++) {
-      if (data[i] == key) {
-        return i;
-      }
-    }
-    return data.length;
-  }
-
-  private static int indexOfEOS(byte[] data, int fromIndex, int encodingByte) {
-    int terminationPos = indexOf(data, fromIndex, (byte) 0);
+  private static int indexOfEos(byte[] data, int fromIndex, int encoding) {
+    int terminationPos = indexOfZeroByte(data, fromIndex);
 
-    // For single byte encoding charsets, we are done
-    if (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8) {
+    // For single byte encoding charsets, we're done.
+    if (encoding == ID3_TEXT_ENCODING_ISO_8859_1 || encoding == ID3_TEXT_ENCODING_UTF_8) {
       return terminationPos;
     }
 
-    // Otherwise, look for a two zero bytes
+    // Otherwise look for a second zero byte.
     while (terminationPos < data.length - 1) {
       if (data[terminationPos + 1] == (byte) 0) {
         return terminationPos;
       }
-      terminationPos = indexOf(data, terminationPos + 1, (byte) 0);
+      terminationPos = indexOfZeroByte(data, terminationPos + 1);
     }
 
     return data.length;
   }
 
+  private static int indexOfZeroByte(byte[] data, int fromIndex) {
+    for (int i = fromIndex; i < data.length; i++) {
+      if (data[i] == (byte) 0) {
+        return i;
+      }
+    }
+    return data.length;
+  }
+
   private static int delimiterLength(int encodingByte) {
     return (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8)
         ? 1 : 2;
@@ -190,6 +158,110 @@ private static int parseId3Header(ParsableByteArray id3Buffer) throws ParserExce
     return id3Size;
   }
 
+  private static TxxxFrame parseTxxxFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int descriptionEndIndex = indexOfEos(data, 0, encoding);
+    String description = new String(data, 0, descriptionEndIndex, charset);
+
+    int valueStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
+    String value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+
+    return new TxxxFrame(description, value);
+  }
+
+  private static PrivFrame parsePrivFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    byte[] data = new byte[frameSize];
+    id3Data.readBytes(data, 0, frameSize);
+
+    int ownerEndIndex = indexOfZeroByte(data, 0);
+    String owner = new String(data, 0, ownerEndIndex, "ISO-8859-1");
+
+    int privateDataStartIndex = ownerEndIndex + 1;
+    byte[] privateData = Arrays.copyOfRange(data, privateDataStartIndex, data.length);
+
+    return new PrivFrame(owner, privateData);
+  }
+
+  private static GeobFrame parseGeobFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int mimeTypeEndIndex = indexOfZeroByte(data, 0);
+    String mimeType = new String(data, 0, mimeTypeEndIndex, "ISO-8859-1");
+
+    int filenameStartIndex = mimeTypeEndIndex + 1;
+    int filenameEndIndex = indexOfEos(data, filenameStartIndex, encoding);
+    String filename = new String(data, filenameStartIndex, filenameEndIndex - filenameStartIndex,
+        charset);
+
+    int descriptionStartIndex = filenameEndIndex + delimiterLength(encoding);
+    int descriptionEndIndex = indexOfEos(data, descriptionStartIndex, encoding);
+    String description = new String(data, descriptionStartIndex,
+        descriptionEndIndex - descriptionStartIndex, charset);
+
+    int objectDataStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    byte[] objectData = Arrays.copyOfRange(data, objectDataStartIndex, data.length);
+
+    return new GeobFrame(mimeType, filename, description, objectData);
+  }
+
+  private static ApicFrame parseApicFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int mimeTypeEndIndex = indexOfZeroByte(data, 0);
+    String mimeType = new String(data, 0, mimeTypeEndIndex, "ISO-8859-1");
+
+    int pictureType = data[mimeTypeEndIndex + 1] & 0xFF;
+
+    int descriptionStartIndex = mimeTypeEndIndex + 2;
+    int descriptionEndIndex = indexOfEos(data, descriptionStartIndex, encoding);
+    String description = new String(data, descriptionStartIndex,
+        descriptionEndIndex - descriptionStartIndex, charset);
+
+    int pictureDataStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    byte[] pictureData = Arrays.copyOfRange(data, pictureDataStartIndex, data.length);
+
+    return new ApicFrame(mimeType, description, pictureType, pictureData);
+  }
+
+  private static TextInformationFrame parseTextInformationFrame(ParsableByteArray id3Data,
+      int frameSize, String id) throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int descriptionEndIndex = indexOfEos(data, 0, encoding);
+    String description = new String(data, 0, descriptionEndIndex, charset);
+
+    return new TextInformationFrame(id, description);
+  }
+
+  private static BinaryFrame parseBinaryFrame(ParsableByteArray id3Data, int frameSize, String id) {
+    byte[] frame = new byte[frameSize];
+    id3Data.readBytes(frame, 0, frameSize);
+
+    return new BinaryFrame(id, frame);
+  }
+
   /**
    * Maps encoding byte from ID3v2 frame to a Charset.
    * @param encodingByte The value of encoding byte from ID3v2 frame.
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/id3/TextInformationFrame.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/TextInformationFrame.java
new file mode 100644
index 0000000000..3d47c5aa68
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/TextInformationFrame.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata.id3;
+
+/**
+ * Text information ("T000" - "TZZZ", excluding "TXXX") ID3 frame.
+ */
+public final class TextInformationFrame extends Id3Frame {
+
+  public final String description;
+
+  public TextInformationFrame(String id, String description) {
+    super(id);
+    this.description = description;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java
index 5b4231ad71..5d3421899d 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheEvictor.java
@@ -21,6 +21,9 @@
  */
 public interface CacheEvictor extends Cache.Listener {
 
+  /** Invoked when cache has beeen initialized. */
+  void onCacheInitialized();
+
   /**
    * Invoked when a writer starts writing to the cache.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 4998f09fc2..6e65df52b7 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -33,6 +33,11 @@ public LeastRecentlyUsedCacheEvictor(long maxBytes) {
     this.leastRecentlyUsed = new TreeSet<>(this);
   }
 
+  @Override
+  public void onCacheInitialized() {
+    // Do nothing.
+  }
+
   @Override
   public void onStartFile(Cache cache, String key, long position, long length) {
     evictCache(cache, length);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java
index 56e4e33400..9fe9d5e49f 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java
@@ -24,6 +24,11 @@
  */
 public final class NoOpCacheEvictor implements CacheEvictor {
 
+  @Override
+  public void onCacheInitialized() {
+    // Do nothing.
+  }
+
   @Override
   public void onStartFile(Cache cache, String key, long position, long length) {
     // Do nothing.
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
index 4e60d78698..eff50a7bf0 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
@@ -254,6 +254,7 @@ private void initialize() {
         }
       }
     }
+    evictor.onCacheInitialized();
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index ce6636471e..63f9af1ea4 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -396,6 +396,29 @@ public String readLine() {
     return line;
   }
 
+  /**
+   * Reads a null-terminated string using the default character set.
+   * @return A String, not including any null characters, or null if the end of the stream has
+   *     been reached.
+   */
+  public String readNullTerminatedString() {
+    if (bytesLeft() == 0) {
+      return null;
+    }
+    int stringLimit = position;
+    while (stringLimit < limit && data[stringLimit] != 0) {
+      stringLimit++;
+    }
+    final int length = stringLimit - position;
+    String result = new String(data, position, length, Charset.defaultCharset());
+    position = stringLimit;
+    if (position == limit) {
+      return result;
+    }
+    position++;
+    return result;
+  }
+
   /**
    * Reads a long value encoded by UTF-8 encoding
    * @throws NumberFormatException if there is a problem with decoding
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
index 03b3e0690b..883398c707 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.util.extensions;
 
-import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.util.Assertions;
 
 import java.util.LinkedList;
@@ -226,8 +225,8 @@ private boolean decode() throws InterruptedException {
     if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
     } else {
-      if (inputBuffer.getFlag(C.SAMPLE_FLAG_DECODE_ONLY)) {
-        outputBuffer.setFlag(C.SAMPLE_FLAG_DECODE_ONLY);
+      if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
+        outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
       }
       exception = decode(inputBuffer, outputBuffer, resetDecoder);
       if (exception != null) {
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 7ce85ab729..43102af605 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1508"
-    android:versionName="1.5.8">
+    android:versionCode="1509"
+    android:versionName="1.5.9">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index 090151e1b8..f855a0ee2b 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -357,7 +357,7 @@ private void testDashPlayback(HostActivity activity, String streamName,
       ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
       String audioFormat, boolean canIncludeAdditionalVideoFormats, String... videoFormats)
       throws IOException {
-    MediaPresentationDescription mpd = TestUtil.loadManifest(activity,
+    MediaPresentationDescription mpd = TestUtil.loadManifest(activity, TAG,
         MANIFEST_URL_PREFIX + manifestFileName, new MediaPresentationDescriptionParser());
     MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG,
         REPORT_NAME, streamName);
@@ -460,7 +460,7 @@ public DashHostedTest(String streamName, MediaPresentationDescription mpd,
           MIN_LOADABLE_RETRY_COUNT);
       DebugMediaCodecVideoTrackRenderer videoRenderer = new DebugMediaCodecVideoTrackRenderer(host,
           videoSampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
-          0, handler, logger, 50, fullPlaybackNoSeeking);
+          0, handler, logger, 50);
       videoCounters = videoRenderer.codecCounters;
       player.sendMessage(videoRenderer, DebugMediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
 
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
index 9f7bb3dab8..c930c74fd3 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.playbacktests.util;
 
+import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.SampleSource;
@@ -34,46 +35,57 @@
 
   private static final int ARRAY_SIZE = 1000;
 
-  public final long[] timestampsList = new long[ARRAY_SIZE];
+  private final long[] timestampsList = new long[ARRAY_SIZE];
 
   private int startIndex;
   private int queueSize;
   private int bufferCount;
-  private boolean enableBufferTimestampAssertions;
 
   public DebugMediaCodecVideoTrackRenderer(Context context, SampleSource source,
       MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs,
-      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify,
-      boolean enableBufferTimestampAssertions) {
+      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify) {
     super(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
         eventHandler, eventListener, maxDroppedFrameCountToNotify);
-    this.enableBufferTimestampAssertions = enableBufferTimestampAssertions;
     startIndex = 0;
     queueSize = 0;
   }
 
+  @Override
+  protected void releaseCodec() {
+    super.releaseCodec();
+    clearTimestamps();
+  }
+
+  @Override
+  protected void flushCodec() throws ExoPlaybackException {
+    super.flushCodec();
+    clearTimestamps();
+  }
+
   @Override
   protected void onQueuedInputBuffer(
       long presentationTimeUs, ByteBuffer buffer, int bufferSize, boolean sampleEncrypted) {
-    if (enableBufferTimestampAssertions) {
-      insertTimestamp(presentationTimeUs);
-      maybeShiftTimestampsList();
-    }
+    insertTimestamp(presentationTimeUs);
+    maybeShiftTimestampsList();
   }
 
   @Override
   protected void onProcessedOutputBuffer(long presentationTimeUs) {
     bufferCount++;
-    if (enableBufferTimestampAssertions) {
-      long expectedTimestampUs = dequeueTimestamp();
-      if (expectedTimestampUs != presentationTimeUs) {
-        throw new IllegalStateException("Expected buffer with presentation timestamp: "
-            + expectedTimestampUs + ". Instead got: " + presentationTimeUs + " (Processed buffers: "
-            + bufferCount + ")");
-      }
+    long expectedTimestampUs = dequeueTimestamp();
+    if (expectedTimestampUs != presentationTimeUs) {
+      throw new IllegalStateException("Expected to dequeue video buffer with presentation "
+          + "timestamp: " + expectedTimestampUs + ". Instead got: " + presentationTimeUs
+          + " (Processed buffers since last flush: " + bufferCount + ").");
     }
   }
 
+  private void clearTimestamps() {
+    startIndex = 0;
+    queueSize = 0;
+    bufferCount = 0;
+  }
+
   private void insertTimestamp(long presentationTimeUs) {
     for (int i = startIndex + queueSize - 1; i >= startIndex; i--) {
       if (presentationTimeUs >= timestampsList[i]) {
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
index a9d41c4056..4bf9de1db1 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
@@ -125,13 +125,15 @@ public void run() {
         hostedTest.onFinished();
         Log.d(TAG, "Pass conditions checked.");
       } else {
-        Log.e(TAG, "Test released before it finished. Activity may have been paused whilst test "
-            + "was in progress.");
-        fail();
+        String message = "Test released before it finished. Activity may have been paused whilst "
+            + "test was in progress.";
+        Log.e(TAG, message);
+        fail(message);
       }
     } else {
-      Log.e(TAG, "Test timed out after " + timeoutMs + " ms.");
-      fail();
+      String message = "Test timed out after " + timeoutMs + " ms.";
+      Log.e(TAG, message);
+      fail(message);
     }
   }
 
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/TestUtil.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/TestUtil.java
index b5027b9309..77432e369a 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/TestUtil.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/TestUtil.java
@@ -23,14 +23,18 @@
 
 import android.content.Context;
 import android.os.ConditionVariable;
+import android.util.Log;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 
 /**
  * Utility methods for ExoPlayer playback tests.
  */
 public final class TestUtil {
 
+  private static final int MANIFEST_LOAD_MAX_RETRY_COUNT = 5;
+
   private TestUtil() {}
 
   /**
@@ -47,19 +51,39 @@ public static String getUserAgent(Context context) {
    * Loads a manifest.
    *
    * @param context A context.
+   * @param tag A tag to use for logging.
    * @param url The manifest url.
    * @param parser A suitable parser for the manifest.
    * @return The parser manifest.
    * @throws IOException If an error occurs loading the manifest.
    */
-  public static <T> T loadManifest(Context context, String url, UriLoadable.Parser<T> parser)
-      throws IOException {
+  public static <T> T loadManifest(Context context, String tag, String url,
+      UriLoadable.Parser<T> parser) throws IOException {
     String userAgent = getUserAgent(context);
-    DefaultUriDataSource manifestDataSource = new DefaultUriDataSource(context, userAgent);
-    ManifestFetcher<T> manifestFetcher = new ManifestFetcher<>(url, manifestDataSource, parser);
-    SyncManifestCallback<T> callback = new SyncManifestCallback<>();
-    manifestFetcher.singleLoad(context.getMainLooper(), callback);
-    return callback.getResult();
+    int retryCount = 0;
+    while (true) {
+      try {
+        DefaultUriDataSource manifestDataSource = new DefaultUriDataSource(context, userAgent);
+        ManifestFetcher<T> manifestFetcher = new ManifestFetcher<>(url, manifestDataSource, parser);
+        SyncManifestCallback<T> callback = new SyncManifestCallback<>();
+        manifestFetcher.singleLoad(context.getMainLooper(), callback);
+        return callback.getResult();
+      } catch (IOException e) {
+        if (retryCount++ < MANIFEST_LOAD_MAX_RETRY_COUNT) {
+          // Sleep, then try again.
+          Log.e(tag, "Failed to load manifest", e);
+          try {
+            Thread.sleep(5000);
+          } catch (InterruptedException e2) {
+            // Never happens.
+            throw new InterruptedIOException();
+          }
+        } else {
+          // Give up.
+          throw e;
+        }
+      }
+    }
   }
 
   /**
