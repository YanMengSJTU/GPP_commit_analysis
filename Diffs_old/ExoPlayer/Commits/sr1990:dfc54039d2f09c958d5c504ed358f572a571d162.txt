diff --git a/.github/ISSUE_TEMPLATE/bug.md b/.github/ISSUE_TEMPLATE/bug.md
index 690069ffa8..c0980df440 100644
--- a/.github/ISSUE_TEMPLATE/bug.md
+++ b/.github/ISSUE_TEMPLATE/bug.md
@@ -8,9 +8,12 @@ assignees: ''
 
 Before filing a bug:
 -----------------------
-- Search existing issues, including issues that are closed.
-- Consult our FAQs, supported devices and supported formats pages. These can be
-  found at https://exoplayer.dev/.
+- Search existing issues, including issues that are closed:
+  https://github.com/google/ExoPlayer/issues?q=is%3Aissue
+- Consult our developer website, which can be found at https://exoplayer.dev/.
+  It provides detailed information about supported formats and devices.
+- Learn how to create useful log output by using the EventLogger:
+  https://exoplayer.dev/listening-to-player-events.html#using-eventlogger
 - Rule out issues in your own code. A good way to do this is to try and
   reproduce the issue in the ExoPlayer demo app. Information about the ExoPlayer
   demo app can be found here:
@@ -33,16 +36,17 @@ or a small sample app that you’re able to share as source code on GitHub.
 Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
 media that reproduces the issue. If you don't wish to post it publicly, please
 submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
-in the format "Issue #1234". Provide all the metadata we'd need to play the
-content like drm license urls or similar. If the content is accessible only in
-certain countries or regions, please say so.
+in the format "Issue #1234", where "#1234" should be replaced with your issue
+number. Provide all the metadata we'd need to play the content like drm license
+urls or similar. If the content is accessible only in certain countries or
+regions, please say so.
 
 ### [REQUIRED] A full bug report captured from the device
 Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
 log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
 bug report to dev.exoplayer@gmail.com using a subject in the format
-"Issue #1234".
+"Issue #1234", where "#1234" should be replaced with your issue number.
 
 ### [REQUIRED] Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
diff --git a/.github/ISSUE_TEMPLATE/content_not_playing.md b/.github/ISSUE_TEMPLATE/content_not_playing.md
index f326e7cd46..c8d4668a6a 100644
--- a/.github/ISSUE_TEMPLATE/content_not_playing.md
+++ b/.github/ISSUE_TEMPLATE/content_not_playing.md
@@ -8,9 +8,12 @@ assignees: ''
 
 Before filing a content issue:
 ------------------------------
-- Search existing issues, including issues that are closed.
+- Search existing issues, including issues that are closed:
+  https://github.com/google/ExoPlayer/issues?q=is%3Aissue
 - Consult our supported formats page, which can be found at
   https://exoplayer.dev/supported-formats.html.
+- Learn how to create useful log output by using the EventLogger:
+  https://exoplayer.dev/listening-to-player-events.html#using-eventlogger
 - Try playing your content in the ExoPlayer demo app. Information about the
   ExoPlayer demo app can be found here:
   http://exoplayer.dev/demo-application.html.
@@ -30,9 +33,10 @@ and you expect to play, like 5.1 audio track, text tracks or drm systems.
 Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
 media that reproduces the issue. If you don't wish to post it publicly, please
 submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
-in the format "Issue #1234". Provide all the metadata we'd need to play the
-content like drm license urls or similar. If the content is accessible only in
-certain countries or regions, please say so.
+in the format "Issue #1234", where "#1234" should be replaced with your issue
+number. Provide all the metadata we'd need to play the content like drm license
+urls or similar. If the content is accessible only in certain countries or
+regions, please say so.
 
 ### [REQUIRED] Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
@@ -41,6 +45,13 @@ Specify the absolute version number. Avoid using terms such as "latest".
 Specify the devices and versions of Android on which you expect the content to
 play. If possible, please test on multiple devices and Android versions.
 
+### [REQUIRED] A full bug report captured from the device
+Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
+log snippet is NOT sufficient. Please attach the captured bug report as a file.
+If you don't wish to post it publicly, please submit the issue, then email the
+bug report to dev.exoplayer@gmail.com using a subject in the format
+"Issue #1234", where "#1234" should be replaced with your issue number.
+
 <!-- DO NOT DELETE
 validate_template=true
 template_path=.github/ISSUE_TEMPLATE/content_not_playing.md
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
index 089de35910..d481de33ce 100644
--- a/.github/ISSUE_TEMPLATE/feature_request.md
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -8,8 +8,9 @@ assignees: ''
 
 Before filing a feature request:
 -----------------------
-- Search existing open issues, specifically with the label ‘enhancement’.
-- Search existing pull requests.
+- Search existing open issues, specifically with the label ‘enhancement’:
+  https://github.com/google/ExoPlayer/labels/enhancement
+- Search existing pull requests: https://github.com/google/ExoPlayer/pulls
 
 When filing a feature request:
 -----------------------
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
index 3ed569862f..b5f40884d8 100644
--- a/.github/ISSUE_TEMPLATE/question.md
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -12,8 +12,12 @@ Before filing a question:
   a general Android development question, please do so on Stack Overflow.
 - Search existing issues, including issues that are closed. It’s often the
   quickest way to get an answer!
-- Consult our FAQs, developer guide and the class reference of ExoPlayer. These
-  can be found at https://exoplayer.dev/.
+  https://github.com/google/ExoPlayer/issues?q=is%3Aissue
+- Consult our developer website, which can be found at https://exoplayer.dev/.
+  It provides detailed information about supported formats, devices as well as
+  information about how to use the ExoPlayer library.
+- The ExoPlayer library Javadoc can be found at
+  https://exoplayer.dev/doc/reference/
 
 When filing a question:
 -----------------------
@@ -28,6 +32,23 @@ important for us to know this so that we can improve our documentation.
 ### [REQUIRED] Question
 Describe your question in detail.
 
+### A full bug report captured from the device
+In case your question refers to a problem you are seeing in your app, capture a
+full bug report using "adb bugreport". Please attach the captured bug report as
+a file. If you don't wish to post it publicly, please submit the issue, then
+email the bug report to dev.exoplayer@gmail.com using a subject in the format
+"Issue #1234", where "#1234" should be replaced with your issue number.
+
+### Link to test content
+In case your question is related to a piece of media, which you are trying to
+play, please provide a JSON snippet for the demo app’s media.exolist.json file,
+or a link to media that reproduces the issue. If you don't wish to post it
+publicly, please submit the issue, then email the link to
+dev.exoplayer@gmail.com using a subject in the format "Issue #1234", where
+"#1234" should be replaced with your issue number. Provide all the metadata we'd
+need to play the content like drm license urls or similar. If the content is
+accessible only in certain countries or regions, please say so.
+
 <!-- DO NOT DELETE
 validate_template=true
 template_path=.github/ISSUE_TEMPLATE/question.md
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 9e69bcc917..a3f6c1ebfc 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,117 @@
 # Release notes #
 
+### 2.10.4 ###
+
+* Offline: Add `Scheduler` implementation that uses `WorkManager`.
+* Add ability to specify a description when creating notification channels via
+  ExoPlayer library classes.
+* Switch normalized BCP-47 language codes to use 2-letter ISO 639-1 language
+  tags instead of 3-letter ISO 639-2 language tags.
+* Ensure the `SilenceMediaSource` position is in range
+  ([#6229](https://github.com/google/ExoPlayer/issues/6229)).
+* WAV: Calculate correct duration for clipped streams
+  ([#6241](https://github.com/google/ExoPlayer/issues/6241)).
+* MP3: Use CBR header bitrate, not calculated bitrate. This reverts a change
+  from 2.9.3 ([#6238](https://github.com/google/ExoPlayer/issues/6238)).
+* Flac extension: Parse `VORBIS_COMMENT` and `PICTURE` metadata
+  ([#5527](https://github.com/google/ExoPlayer/issues/5527)).
+* Fix issue where initial seek positions get ignored when playing a preroll ad
+  ([#6201](https://github.com/google/ExoPlayer/issues/6201)).
+* Fix issue where invalid language tags were normalized to "und" instead of
+  keeping the original
+  ([#6153](https://github.com/google/ExoPlayer/issues/6153)).
+* Fix `DataSchemeDataSource` re-opening and range requests
+  ([#6192](https://github.com/google/ExoPlayer/issues/6192)).
+* Fix Flac and ALAC playback on some LG devices
+  ([#5938](https://github.com/google/ExoPlayer/issues/5938)).
+* Fix issue when calling `performClick` on `PlayerView` without
+  `PlayerControlView`
+  ([#6260](https://github.com/google/ExoPlayer/issues/6260)).
+* Fix issue where playback speeds are not used in adaptive track selections
+  after manual selection changes for other renderers
+  ([#6256](https://github.com/google/ExoPlayer/issues/6256)).
+
+### 2.10.3 ###
+
+* Display last frame when seeking to end of stream
+  ([#2568](https://github.com/google/ExoPlayer/issues/2568)).
+* Audio:
+  * Fix an issue where not all audio was played out when the configuration
+    for the underlying track was changing (e.g., at some period transitions).
+  * Fix an issue where playback speed was applied inaccurately in playlists
+    ([#6117](https://github.com/google/ExoPlayer/issues/6117)).
+* UI: Fix `PlayerView` incorrectly consuming touch events if no controller is
+  attached ([#6109](https://github.com/google/ExoPlayer/issues/6109)).
+* CEA608: Fix repetition of special North American characters
+  ([#6133](https://github.com/google/ExoPlayer/issues/6133)).
+* FLV: Fix bug that caused playback of some live streams to not start
+  ([#6111](https://github.com/google/ExoPlayer/issues/6111)).
+* SmoothStreaming: Parse text stream `Subtype` into `Format.roleFlags`.
+* MediaSession extension: Fix `MediaSessionConnector.play()` not resuming
+  playback ([#6093](https://github.com/google/ExoPlayer/issues/6093)).
+
+### 2.10.2 ###
+
+* Add `ResolvingDataSource` for just-in-time resolution of `DataSpec`s
+  ([#5779](https://github.com/google/ExoPlayer/issues/5779)).
+* Add `SilenceMediaSource` that can be used to play silence of a given
+  duration ([#5735](https://github.com/google/ExoPlayer/issues/5735)).
+* Offline:
+  * Prevent unexpected `DownloadHelper.Callback.onPrepared` callbacks after
+    preparation of a `DownloadHelper` fails
+    ([#5915](https://github.com/google/ExoPlayer/issues/5915)).
+  * Fix `CacheUtil.cache()` downloading too much data
+    ([#5927](https://github.com/google/ExoPlayer/issues/5927)).
+  * Fix misreporting cached bytes when caching is paused
+    ([#5573](https://github.com/google/ExoPlayer/issues/5573)).
+* UI:
+  * Allow setting `DefaultTimeBar` attributes on `PlayerView` and
+    `PlayerControlView`.
+  * Change playback controls toggle from touch down to touch up events
+    ([#5784](https://github.com/google/ExoPlayer/issues/5784)).
+  * Fix issue where playback controls were not kept visible on key presses
+    ([#5963](https://github.com/google/ExoPlayer/issues/5963)).
+* Subtitles:
+  * CEA-608: Handle XDS and TEXT modes
+    ([#5807](https://github.com/google/ExoPlayer/pull/5807)).
+  * TTML: Fix bitmap rendering
+    ([#5633](https://github.com/google/ExoPlayer/pull/5633)).
+* IMA: Fix ad pod index offset calculation without preroll
+  ([#5928](https://github.com/google/ExoPlayer/issues/5928)).
+* Add a `playWhenReady` flag to MediaSessionConnector.PlaybackPreparer methods
+  to indicate whether a controller sent a play or only a prepare command. This
+  allows to take advantage of decoder reuse with the MediaSessionConnector
+  ([#5891](https://github.com/google/ExoPlayer/issues/5891)).
+* Add `ProgressUpdateListener` to `PlayerControlView`
+  ([#5834](https://github.com/google/ExoPlayer/issues/5834)).
+* Add support for auto-detecting UDP streams in `DefaultDataSource`
+  ([#6036](https://github.com/google/ExoPlayer/pull/6036)).
+* Allow enabling decoder fallback with `DefaultRenderersFactory`
+  ([#5942](https://github.com/google/ExoPlayer/issues/5942)).
+* Gracefully handle revoked `ACCESS_NETWORK_STATE` permission
+  ([#6019](https://github.com/google/ExoPlayer/issues/6019)).
+* Fix decoding problems when seeking back after seeking beyond a mid-roll ad
+  ([#6009](https://github.com/google/ExoPlayer/issues/6009)).
+* Fix application of `maxAudioBitrate` for adaptive audio track groups
+  ([#6006](https://github.com/google/ExoPlayer/issues/6006)).
+* Fix bug caused by parallel adaptive track selection using `Format`s without
+  bitrate information
+  ([#5971](https://github.com/google/ExoPlayer/issues/5971)).
+* Fix bug in `CastPlayer.getCurrentWindowIndex()`
+  ([#5955](https://github.com/google/ExoPlayer/issues/5955)).
+
+### 2.10.1 ###
+
+* Offline: Add option to remove all downloads.
+* HLS: Fix `NullPointerException` when using HLS chunkless preparation
+  ([#5868](https://github.com/google/ExoPlayer/issues/5868)).
+* Fix handling of empty values and line terminators in SHOUTcast ICY metadata
+  ([#5876](https://github.com/google/ExoPlayer/issues/5876)).
+* Fix DVB subtitles for SDK 28
+  ([#5862](https://github.com/google/ExoPlayer/issues/5862)).
+* Add a workaround for a decoder failure on ZTE Axon7 mini devices when playing
+  48kHz audio ([#5821](https://github.com/google/ExoPlayer/issues/5821)).
+
 ### 2.10.0 ###
 
 * Core library:
diff --git a/build.gradle b/build.gradle
index 4761a1fbe0..1d0b459bf5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -21,14 +21,6 @@ buildscript {
         classpath 'com.novoda:bintray-release:0.9'
         classpath 'com.google.android.gms:strict-version-matcher-plugin:1.1.0'
     }
-    // Workaround for the following test coverage issue. Remove when fixed:
-    // https://code.google.com/p/android/issues/detail?id=226070
-    configurations.all {
-        resolutionStrategy {
-            force 'org.jacoco:org.jacoco.report:0.7.4.201502262128'
-            force 'org.jacoco:org.jacoco.core:0.7.4.201502262128'
-        }
-    }
 }
 allprojects {
     repositories {
@@ -36,7 +28,7 @@ allprojects {
         jcenter()
     }
     project.ext {
-        exoplayerPublishEnabled = true
+        exoplayerPublishEnabled = false
     }
     if (it.hasProperty('externalBuildDir')) {
         if (!new File(externalBuildDir).isAbsolute()) {
@@ -44,6 +36,7 @@ allprojects {
         }
         buildDir = "${externalBuildDir}/${project.name}"
     }
+    group = 'com.google.android.exoplayer'
 }
 
 apply from: 'javadoc_combined.gradle'
diff --git a/constants.gradle b/constants.gradle
index 5063c59141..9e532e053b 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.10.0'
-    releaseVersionCode = 2010000
+    releaseVersion = '2.10.4'
+    releaseVersionCode = 2010004
     minSdkVersion = 16
     targetSdkVersion = 28
     compileSdkVersion = 28
diff --git a/core_settings.gradle b/core_settings.gradle
index 4d90fa962a..38889e1a21 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -38,6 +38,7 @@ include modulePrefix + 'extension-vp9'
 include modulePrefix + 'extension-rtmp'
 include modulePrefix + 'extension-leanback'
 include modulePrefix + 'extension-jobdispatcher'
+include modulePrefix + 'extension-workmanager'
 
 project(modulePrefix + 'library').projectDir = new File(rootDir, 'library/all')
 project(modulePrefix + 'library-core').projectDir = new File(rootDir, 'library/core')
@@ -60,3 +61,4 @@ project(modulePrefix + 'extension-vp9').projectDir = new File(rootDir, 'extensio
 project(modulePrefix + 'extension-rtmp').projectDir = new File(rootDir, 'extensions/rtmp')
 project(modulePrefix + 'extension-leanback').projectDir = new File(rootDir, 'extensions/leanback')
 project(modulePrefix + 'extension-jobdispatcher').projectDir = new File(rootDir, 'extensions/jobdispatcher')
+project(modulePrefix + 'extension-workmanager').projectDir = new File(rootDir, 'extensions/workmanager')
diff --git a/demos/cast/build.gradle b/demos/cast/build.gradle
index 03a54947cf..85e60f2796 100644
--- a/demos/cast/build.gradle
+++ b/demos/cast/build.gradle
@@ -47,17 +47,6 @@ android {
         // The demo app isn't indexed and doesn't have translations.
         disable 'GoogleAppIndexingWarning','MissingTranslation'
     }
-
-    flavorDimensions "receiver"
-
-    productFlavors {
-        defaultCast {
-            dimension "receiver"
-            manifestPlaceholders =
-                    [castOptionsProvider: "com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider"]
-        }
-    }
-
 }
 
 dependencies {
diff --git a/demos/cast/src/main/AndroidManifest.xml b/demos/cast/src/main/AndroidManifest.xml
index 856b0b1235..dbfdd833f6 100644
--- a/demos/cast/src/main/AndroidManifest.xml
+++ b/demos/cast/src/main/AndroidManifest.xml
@@ -25,7 +25,7 @@
       android:largeHeap="true" android:allowBackup="false">
 
     <meta-data android:name="com.google.android.gms.cast.framework.OPTIONS_PROVIDER_CLASS_NAME"
-        android:value="${castOptionsProvider}" />
+        android:value="com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider"/>
 
     <activity android:name="com.google.android.exoplayer2.castdemo.MainActivity"
         android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
index 4b71b3a001..df153a1423 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DefaultReceiverPlayerManager.java
@@ -66,7 +66,6 @@
   private final Listener listener;
   private final ConcatenatingMediaSource concatenatingMediaSource;
 
-  private boolean castMediaQueueCreationPending;
   private int currentItemIndex;
   private Player currentPlayer;
 
@@ -268,9 +267,6 @@ public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
   public void onTimelineChanged(
       Timeline timeline, @Nullable Object manifest, @TimelineChangeReason int reason) {
     updateCurrentItemIndex();
-    if (currentPlayer == castPlayer && timeline.isEmpty()) {
-      castMediaQueueCreationPending = true;
-    }
   }
 
   // CastPlayer.SessionAvailabilityListener implementation.
@@ -332,7 +328,6 @@ private void setCurrentPlayer(Player currentPlayer) {
     this.currentPlayer = currentPlayer;
 
     // Media queue management.
-    castMediaQueueCreationPending = currentPlayer == castPlayer;
     if (currentPlayer == exoPlayer) {
       exoPlayer.prepare(concatenatingMediaSource);
     }
@@ -352,12 +347,11 @@ private void setCurrentPlayer(Player currentPlayer) {
    */
   private void setCurrentItem(int itemIndex, long positionMs, boolean playWhenReady) {
     maybeSetCurrentItemAndNotify(itemIndex);
-    if (castMediaQueueCreationPending) {
+    if (currentPlayer == castPlayer && castPlayer.getCurrentTimeline().isEmpty()) {
       MediaQueueItem[] items = new MediaQueueItem[mediaQueue.size()];
       for (int i = 0; i < items.length; i++) {
         items[i] = buildMediaQueueItem(mediaQueue.get(i));
       }
-      castMediaQueueCreationPending = false;
       castPlayer.loadItems(items, itemIndex, positionMs, Player.REPEAT_MODE_OFF);
     } else {
       currentPlayer.seekTo(itemIndex, positionMs);
diff --git a/demos/ima/build.gradle b/demos/ima/build.gradle
index 33161b4121..124555d9b5 100644
--- a/demos/ima/build.gradle
+++ b/demos/ima/build.gradle
@@ -53,7 +53,7 @@ dependencies {
     implementation project(modulePrefix + 'library-hls')
     implementation project(modulePrefix + 'library-smoothstreaming')
     implementation project(modulePrefix + 'extension-ima')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
 }
 
 apply plugin: 'com.google.android.gms.strict-version-matcher-plugin'
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index 7089d4d731..06c5d1ffb7 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -62,7 +62,7 @@ android {
 }
 
 dependencies {
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'androidx.legacy:legacy-support-core-ui:1.0.0'
     implementation 'androidx.fragment:fragment:1.0.0'
     implementation 'com.google.android.material:material:1.0.0'
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
index 3886ef5c44..c3909dfe46 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
@@ -41,7 +41,8 @@ public DemoDownloadService() {
         FOREGROUND_NOTIFICATION_ID,
         DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL,
         CHANNEL_ID,
-        R.string.exo_download_notification_channel_name);
+        R.string.exo_download_notification_channel_name,
+        /* channelDescriptionResourceId= */ 0);
     nextNotificationId = FOREGROUND_NOTIFICATION_ID + 1;
   }
 
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
index f372a47df6..a913a9b891 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
@@ -30,15 +30,12 @@
 import com.google.android.exoplayer2.offline.DownloadManager;
 import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.offline.DownloadService;
-import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.List;
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /** Tracks media that has been downloaded. */
@@ -86,11 +83,9 @@ public boolean isDownloaded(Uri uri) {
   }
 
   @SuppressWarnings("unchecked")
-  public List<StreamKey> getOfflineStreamKeys(Uri uri) {
+  public DownloadRequest getDownloadRequest(Uri uri) {
     Download download = downloads.get(uri);
-    return download != null && download.state != Download.STATE_FAILED
-        ? download.request.streamKeys
-        : Collections.emptyList();
+    return download != null && download.state != Download.STATE_FAILED ? download.request : null;
   }
 
   public void toggleDownload(
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index acb24adebe..35307eb5d8 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -45,7 +45,8 @@
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
-import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -75,7 +76,6 @@
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
-import java.util.List;
 import java.util.UUID;
 
 /** An activity that plays media using {@link SimpleExoPlayer}. */
@@ -457,33 +457,26 @@ private MediaSource buildMediaSource(Uri uri) {
   }
 
   private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
+    DownloadRequest downloadRequest =
+        ((DemoApplication) getApplication()).getDownloadTracker().getDownloadRequest(uri);
+    if (downloadRequest != null) {
+      return DownloadHelper.createMediaSource(downloadRequest, dataSourceFactory);
+    }
     @ContentType int type = Util.inferContentType(uri, overrideExtension);
-    List<StreamKey> offlineStreamKeys = getOfflineStreamKeys(uri);
     switch (type) {
       case C.TYPE_DASH:
-        return new DashMediaSource.Factory(dataSourceFactory)
-            .setStreamKeys(offlineStreamKeys)
-            .createMediaSource(uri);
+        return new DashMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_SS:
-        return new SsMediaSource.Factory(dataSourceFactory)
-            .setStreamKeys(offlineStreamKeys)
-            .createMediaSource(uri);
+        return new SsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_HLS:
-        return new HlsMediaSource.Factory(dataSourceFactory)
-            .setStreamKeys(offlineStreamKeys)
-            .createMediaSource(uri);
+        return new HlsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
       case C.TYPE_OTHER:
         return new ProgressiveMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
-      default: {
+      default:
         throw new IllegalStateException("Unsupported type: " + type);
-      }
     }
   }
 
-  private List<StreamKey> getOfflineStreamKeys(Uri uri) {
-    return ((DemoApplication) getApplication()).getDownloadTracker().getOfflineStreamKeys(uri);
-  }
-
   private DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(
       UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
       throws UnsupportedDrmException {
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
index a7dd1a0df8..bc409410c3 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionDialog.java
@@ -306,7 +306,7 @@ public CharSequence getPageTitle(int position) {
     }
   }
 
-  /** Fragment to show a track seleciton in tab of the track selection dialog. */
+  /** Fragment to show a track selection in tab of the track selection dialog. */
   public static final class TrackSelectionViewFragment extends Fragment
       implements TrackSelectionView.TrackSelectionListener {
 
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index 4dc463ff81..68a7494a3f 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -31,8 +31,8 @@ android {
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:16.1.2'
-    implementation 'androidx.annotation:annotation:1.0.2'
+    api 'com.google.android.gms:play-services-cast-framework:17.0.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 14bb433d2b..bc0987322b 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -45,8 +45,11 @@
 import com.google.android.gms.cast.framework.media.RemoteMediaClient.MediaChannelResult;
 import com.google.android.gms.common.api.PendingResult;
 import com.google.android.gms.common.api.ResultCallback;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * {@link Player} implementation that communicates with a Cast receiver app.
@@ -80,17 +83,18 @@
   private final CastTimelineTracker timelineTracker;
   private final Timeline.Period period;
 
-  private RemoteMediaClient remoteMediaClient;
-
   // Result callbacks.
   private final StatusListener statusListener;
   private final SeekResultCallback seekResultCallback;
 
-  // Listeners.
-  private final CopyOnWriteArraySet<EventListener> listeners;
-  private SessionAvailabilityListener sessionAvailabilityListener;
+  // Listeners and notification.
+  private final CopyOnWriteArrayList<ListenerHolder> listeners;
+  private final ArrayList<ListenerNotificationTask> notificationsBatch;
+  private final ArrayDeque<ListenerNotificationTask> ongoingNotificationsTasks;
+  @Nullable private SessionAvailabilityListener sessionAvailabilityListener;
 
   // Internal state.
+  @Nullable private RemoteMediaClient remoteMediaClient;
   private CastTimeline currentTimeline;
   private TrackGroupArray currentTrackGroups;
   private TrackSelectionArray currentTrackSelection;
@@ -113,7 +117,9 @@ public CastPlayer(CastContext castContext) {
     period = new Timeline.Period();
     statusListener = new StatusListener();
     seekResultCallback = new SeekResultCallback();
-    listeners = new CopyOnWriteArraySet<>();
+    listeners = new CopyOnWriteArrayList<>();
+    notificationsBatch = new ArrayList<>();
+    ongoingNotificationsTasks = new ArrayDeque<>();
 
     SessionManager sessionManager = castContext.getSessionManager();
     sessionManager.addSessionManagerListener(statusListener, CastSession.class);
@@ -141,6 +147,7 @@ public CastPlayer(CastContext castContext) {
    *     starts at position 0.
    * @return The Cast {@code PendingResult}, or null if no session is available.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> loadItem(MediaQueueItem item, long positionMs) {
     return loadItems(new MediaQueueItem[] {item}, 0, positionMs, REPEAT_MODE_OFF);
   }
@@ -156,8 +163,9 @@ public CastPlayer(CastContext castContext) {
    * @param repeatMode The repeat mode for the created media queue.
    * @return The Cast {@code PendingResult}, or null if no session is available.
    */
-  public PendingResult<MediaChannelResult> loadItems(MediaQueueItem[] items, int startIndex,
-      long positionMs, @RepeatMode int repeatMode) {
+  @Nullable
+  public PendingResult<MediaChannelResult> loadItems(
+      MediaQueueItem[] items, int startIndex, long positionMs, @RepeatMode int repeatMode) {
     if (remoteMediaClient != null) {
       positionMs = positionMs != C.TIME_UNSET ? positionMs : 0;
       waitingForInitialTimeline = true;
@@ -173,6 +181,7 @@ public CastPlayer(CastContext castContext) {
    * @param items The items to append.
    * @return The Cast {@code PendingResult}, or null if no media queue exists.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> addItems(MediaQueueItem... items) {
     return addItems(MediaQueueItem.INVALID_ITEM_ID, items);
   }
@@ -187,6 +196,7 @@ public CastPlayer(CastContext castContext) {
    * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
    *     periodId} exist.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> addItems(int periodId, MediaQueueItem... items) {
     if (getMediaStatus() != null && (periodId == MediaQueueItem.INVALID_ITEM_ID
         || currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET)) {
@@ -204,6 +214,7 @@ public CastPlayer(CastContext castContext) {
    * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
    *     periodId} exist.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> removeItem(int periodId) {
     if (getMediaStatus() != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET) {
       return remoteMediaClient.queueRemoveItem(periodId, null);
@@ -222,6 +233,7 @@ public CastPlayer(CastContext castContext) {
    * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
    *     periodId} exist.
    */
+  @Nullable
   public PendingResult<MediaChannelResult> moveItem(int periodId, int newIndex) {
     Assertions.checkArgument(newIndex >= 0 && newIndex < currentTimeline.getPeriodCount());
     if (getMediaStatus() != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET) {
@@ -239,6 +251,7 @@ public CastPlayer(CastContext castContext) {
    * @return The item that corresponds to the period with the given id, or null if no media queue or
    *     period with id {@code periodId} exist.
    */
+  @Nullable
   public MediaQueueItem getItem(int periodId) {
     MediaStatus mediaStatus = getMediaStatus();
     return mediaStatus != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET
@@ -257,9 +270,9 @@ public boolean isCastSessionAvailable() {
   /**
    * Sets a listener for updates on the cast session availability.
    *
-   * @param listener The {@link SessionAvailabilityListener}.
+   * @param listener The {@link SessionAvailabilityListener}, or null to clear the listener.
    */
-  public void setSessionAvailabilityListener(SessionAvailabilityListener listener) {
+  public void setSessionAvailabilityListener(@Nullable SessionAvailabilityListener listener) {
     sessionAvailabilityListener = listener;
   }
 
@@ -296,12 +309,17 @@ public Looper getApplicationLooper() {
 
   @Override
   public void addListener(EventListener listener) {
-    listeners.add(listener);
+    listeners.addIfAbsent(new ListenerHolder(listener));
   }
 
   @Override
   public void removeListener(EventListener listener) {
-    listeners.remove(listener);
+    for (ListenerHolder listenerHolder : listeners) {
+      if (listenerHolder.listener.equals(listener)) {
+        listenerHolder.release();
+        listeners.remove(listenerHolder);
+      }
+    }
   }
 
   @Override
@@ -310,6 +328,7 @@ public int getPlaybackState() {
   }
 
   @Override
+  @Nullable
   public ExoPlaybackException getPlaybackError() {
     return null;
   }
@@ -347,14 +366,13 @@ public void seekTo(int windowIndex, long positionMs) {
       pendingSeekCount++;
       pendingSeekWindowIndex = windowIndex;
       pendingSeekPositionMs = positionMs;
-      for (EventListener listener : listeners) {
-        listener.onPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPositionDiscontinuity(DISCONTINUITY_REASON_SEEK)));
     } else if (pendingSeekCount == 0) {
-      for (EventListener listener : listeners) {
-        listener.onSeekProcessed();
-      }
+      notificationsBatch.add(new ListenerNotificationTask(EventListener::onSeekProcessed));
     }
+    flushNotifications();
   }
 
   @Override
@@ -518,7 +536,7 @@ public long getContentBufferedPosition() {
 
   // Internal methods.
 
-  public void updateInternalState() {
+  private void updateInternalState() {
     if (remoteMediaClient == null) {
       // There is no session. We leave the state of the player as it is now.
       return;
@@ -530,30 +548,40 @@ public void updateInternalState() {
         || this.playWhenReady != playWhenReady) {
       this.playbackState = playbackState;
       this.playWhenReady = playWhenReady;
-      for (EventListener listener : listeners) {
-        listener.onPlayerStateChanged(this.playWhenReady, this.playbackState);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPlayerStateChanged(this.playWhenReady, this.playbackState)));
     }
     @RepeatMode int repeatMode = fetchRepeatMode(remoteMediaClient);
     if (this.repeatMode != repeatMode) {
       this.repeatMode = repeatMode;
-      for (EventListener listener : listeners) {
-        listener.onRepeatModeChanged(repeatMode);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(listener -> listener.onRepeatModeChanged(this.repeatMode)));
+    }
+    maybeUpdateTimelineAndNotify();
+
+    int currentWindowIndex = C.INDEX_UNSET;
+    MediaQueueItem currentItem = remoteMediaClient.getCurrentItem();
+    if (currentItem != null) {
+      currentWindowIndex = currentTimeline.getIndexOfPeriod(currentItem.getItemId());
+    }
+    if (currentWindowIndex == C.INDEX_UNSET) {
+      // The timeline is empty. Fall back to index 0, which is what ExoPlayer would do.
+      currentWindowIndex = 0;
     }
-    int currentWindowIndex = fetchCurrentWindowIndex(getMediaStatus());
     if (this.currentWindowIndex != currentWindowIndex && pendingSeekCount == 0) {
       this.currentWindowIndex = currentWindowIndex;
-      for (EventListener listener : listeners) {
-        listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener ->
+                  listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION)));
     }
     if (updateTracksAndSelections()) {
-      for (EventListener listener : listeners) {
-        listener.onTracksChanged(currentTrackGroups, currentTrackSelection);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onTracksChanged(currentTrackGroups, currentTrackSelection)));
     }
-    maybeUpdateTimelineAndNotify();
+    flushNotifications();
   }
 
   private void maybeUpdateTimelineAndNotify() {
@@ -561,9 +589,10 @@ private void maybeUpdateTimelineAndNotify() {
       @Player.TimelineChangeReason int reason = waitingForInitialTimeline
           ? Player.TIMELINE_CHANGE_REASON_PREPARED : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
       waitingForInitialTimeline = false;
-      for (EventListener listener : listeners) {
-        listener.onTimelineChanged(currentTimeline, null, reason);
-      }
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener ->
+                  listener.onTimelineChanged(currentTimeline, /* manifest= */ null, reason)));
     }
   }
 
@@ -653,7 +682,8 @@ private void setRemoteMediaClient(@Nullable RemoteMediaClient remoteMediaClient)
     }
   }
 
-  private @Nullable MediaStatus getMediaStatus() {
+  @Nullable
+  private MediaStatus getMediaStatus() {
     return remoteMediaClient != null ? remoteMediaClient.getMediaStatus() : null;
   }
 
@@ -701,16 +731,6 @@ private static int fetchRepeatMode(RemoteMediaClient remoteMediaClient) {
     }
   }
 
-  /**
-   * Retrieves the current item index from {@code mediaStatus} and maps it into a window index. If
-   * there is no media session, returns 0.
-   */
-  private static int fetchCurrentWindowIndex(@Nullable MediaStatus mediaStatus) {
-    Integer currentItemId = mediaStatus != null
-        ? mediaStatus.getIndexById(mediaStatus.getCurrentItemId()) : null;
-    return currentItemId != null ? currentItemId : 0;
-  }
-
   private static boolean isTrackActive(long id, long[] activeTrackIds) {
     for (long activeTrackId : activeTrackIds) {
       if (activeTrackId == id) {
@@ -826,7 +846,23 @@ public void onSessionResuming(CastSession castSession, String s) {
 
   }
 
-  // Result callbacks hooks.
+  // Internal methods.
+
+  private void flushNotifications() {
+    boolean recursiveNotification = !ongoingNotificationsTasks.isEmpty();
+    ongoingNotificationsTasks.addAll(notificationsBatch);
+    notificationsBatch.clear();
+    if (recursiveNotification) {
+      // This will be handled once the current notification task is finished.
+      return;
+    }
+    while (!ongoingNotificationsTasks.isEmpty()) {
+      ongoingNotificationsTasks.peekFirst().execute();
+      ongoingNotificationsTasks.removeFirst();
+    }
+  }
+
+  // Internal classes.
 
   private final class SeekResultCallback implements ResultCallback<MediaChannelResult> {
 
@@ -840,9 +876,25 @@ public void onResult(@NonNull MediaChannelResult result) {
       if (--pendingSeekCount == 0) {
         pendingSeekWindowIndex = C.INDEX_UNSET;
         pendingSeekPositionMs = C.TIME_UNSET;
-        for (EventListener listener : listeners) {
-          listener.onSeekProcessed();
-        }
+        notificationsBatch.add(new ListenerNotificationTask(EventListener::onSeekProcessed));
+        flushNotifications();
+      }
+    }
+  }
+
+  private final class ListenerNotificationTask {
+
+    private final Iterator<ListenerHolder> listenersSnapshot;
+    private final ListenerInvocation listenerInvocation;
+
+    private ListenerNotificationTask(ListenerInvocation listenerInvocation) {
+      this.listenersSnapshot = listeners.iterator();
+      this.listenerInvocation = listenerInvocation;
+    }
+
+    public void execute() {
+      while (listenersSnapshot.hasNext()) {
+        listenersSnapshot.next().invoke(listenerInvocation);
       }
     }
   }
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java
index 06f0bec971..4ce45a92b1 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java
@@ -20,6 +20,7 @@
 import com.google.android.gms.cast.framework.CastOptions;
 import com.google.android.gms.cast.framework.OptionsProvider;
 import com.google.android.gms.cast.framework.SessionProvider;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -36,7 +37,7 @@ public CastOptions getCastOptions(Context context) {
 
   @Override
   public List<SessionProvider> getAdditionalSessionProviders(Context context) {
-    return null;
+    return Collections.emptyList();
   }
 
 }
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 76972a3530..b2dd6bc889 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -31,9 +31,9 @@ android {
 }
 
 dependencies {
-    api 'org.chromium.net:cronet-embedded:73.3683.76'
+    api 'org.chromium.net:cronet-embedded:75.3770.101'
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'library')
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index a9995af0e4..ca196b1d2f 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -113,7 +113,7 @@ public InterruptedIOException(InterruptedException e) {
 
   private final CronetEngine cronetEngine;
   private final Executor executor;
-  private final Predicate<String> contentTypePredicate;
+  @Nullable private final Predicate<String> contentTypePredicate;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
@@ -146,6 +146,18 @@ public InterruptedIOException(InterruptedException e) {
 
   private volatile long currentConnectTimeoutMs;
 
+  /**
+   * @param cronetEngine A CronetEngine.
+   * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
+   *     be a direct executor (i.e. executes tasks on the calling thread) in order to avoid a thread
+   *     hop from Cronet's internal network thread to the response handling thread. However, to
+   *     avoid slowing down overall network performance, care must be taken to make sure response
+   *     handling is a fast operation when using a direct executor.
+   */
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor) {
+    this(cronetEngine, executor, /* contentTypePredicate= */ null);
+  }
+
   /**
    * @param cronetEngine A CronetEngine.
    * @param executor The {@link java.util.concurrent.Executor} that will handle responses. This may
@@ -158,7 +170,9 @@ public InterruptedIOException(InterruptedException e) {
    *     #open(DataSpec)}.
    */
   public CronetDataSource(
-      CronetEngine cronetEngine, Executor executor, Predicate<String> contentTypePredicate) {
+      CronetEngine cronetEngine,
+      Executor executor,
+      @Nullable Predicate<String> contentTypePredicate) {
     this(
         cronetEngine,
         executor,
@@ -188,7 +202,7 @@ public CronetDataSource(
   public CronetDataSource(
       CronetEngine cronetEngine,
       Executor executor,
-      Predicate<String> contentTypePredicate,
+      @Nullable Predicate<String> contentTypePredicate,
       int connectTimeoutMs,
       int readTimeoutMs,
       boolean resetTimeoutOnRedirects,
@@ -225,7 +239,7 @@ public CronetDataSource(
   public CronetDataSource(
       CronetEngine cronetEngine,
       Executor executor,
-      Predicate<String> contentTypePredicate,
+      @Nullable Predicate<String> contentTypePredicate,
       int connectTimeoutMs,
       int readTimeoutMs,
       boolean resetTimeoutOnRedirects,
@@ -246,7 +260,7 @@ public CronetDataSource(
   /* package */ CronetDataSource(
       CronetEngine cronetEngine,
       Executor executor,
-      Predicate<String> contentTypePredicate,
+      @Nullable Predicate<String> contentTypePredicate,
       int connectTimeoutMs,
       int readTimeoutMs,
       boolean resetTimeoutOnRedirects,
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index ffecdcd16f..15952b1860 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -38,7 +38,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 7c5864420a..35b67e1068 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -172,28 +172,49 @@ public int getSampleRate() {
   private static @Nullable byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
-      case MimeTypes.AUDIO_ALAC:
       case MimeTypes.AUDIO_OPUS:
         return initializationData.get(0);
+      case MimeTypes.AUDIO_ALAC:
+        return getAlacExtraData(initializationData);
       case MimeTypes.AUDIO_VORBIS:
-        byte[] header0 = initializationData.get(0);
-        byte[] header1 = initializationData.get(1);
-        byte[] extraData = new byte[header0.length + header1.length + 6];
-        extraData[0] = (byte) (header0.length >> 8);
-        extraData[1] = (byte) (header0.length & 0xFF);
-        System.arraycopy(header0, 0, extraData, 2, header0.length);
-        extraData[header0.length + 2] = 0;
-        extraData[header0.length + 3] = 0;
-        extraData[header0.length + 4] =  (byte) (header1.length >> 8);
-        extraData[header0.length + 5] = (byte) (header1.length & 0xFF);
-        System.arraycopy(header1, 0, extraData, header0.length + 6, header1.length);
-        return extraData;
+        return getVorbisExtraData(initializationData);
       default:
         // Other codecs do not require extra data.
         return null;
     }
   }
 
+  private static byte[] getAlacExtraData(List<byte[]> initializationData) {
+    // FFmpeg's ALAC decoder expects an ALAC atom, which contains the ALAC "magic cookie", as extra
+    // data. initializationData[0] contains only the magic cookie, and so we need to package it into
+    // an ALAC atom. See:
+    // https://ffmpeg.org/doxygen/0.6/alac_8c.html
+    // https://github.com/macosforge/alac/blob/master/ALACMagicCookieDescription.txt
+    byte[] magicCookie = initializationData.get(0);
+    int alacAtomLength = 12 + magicCookie.length;
+    ByteBuffer alacAtom = ByteBuffer.allocate(alacAtomLength);
+    alacAtom.putInt(alacAtomLength);
+    alacAtom.putInt(0x616c6163); // type=alac
+    alacAtom.putInt(0); // version=0, flags=0
+    alacAtom.put(magicCookie, /* offset= */ 0, magicCookie.length);
+    return alacAtom.array();
+  }
+
+  private static byte[] getVorbisExtraData(List<byte[]> initializationData) {
+    byte[] header0 = initializationData.get(0);
+    byte[] header1 = initializationData.get(1);
+    byte[] extraData = new byte[header0.length + header1.length + 6];
+    extraData[0] = (byte) (header0.length >> 8);
+    extraData[1] = (byte) (header0.length & 0xFF);
+    System.arraycopy(header0, 0, extraData, 2, header0.length);
+    extraData[header0.length + 2] = 0;
+    extraData[header0.length + 3] = 0;
+    extraData[header0.length + 4] = (byte) (header1.length >> 8);
+    extraData[header0.length + 5] = (byte) (header1.length & 0xFF);
+    System.arraycopy(header1, 0, extraData, header0.length + 6, header1.length);
+    return extraData;
+  }
+
   private native long ffmpegInitialize(
       String codecName,
       @Nullable byte[] extraData,
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index 06a5888404..c67de27697 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -39,7 +39,8 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     androidTestImplementation project(modulePrefix + 'testutils')
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
diff --git a/extensions/flac/proguard-rules.txt b/extensions/flac/proguard-rules.txt
index ee0a9fa5b5..3e52f643e7 100644
--- a/extensions/flac/proguard-rules.txt
+++ b/extensions/flac/proguard-rules.txt
@@ -9,6 +9,9 @@
 -keep class com.google.android.exoplayer2.ext.flac.FlacDecoderJni {
     *;
 }
--keep class com.google.android.exoplayer2.util.FlacStreamInfo {
+-keep class com.google.android.exoplayer2.util.FlacStreamMetadata {
+    *;
+}
+-keep class com.google.android.exoplayer2.metadata.flac.PictureFrame {
     *;
 }
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
index 435279fc45..a3770afc78 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeekerTest.java
@@ -52,7 +52,10 @@ public void testGetSeekMap_returnsSeekMapWithCorrectDuration()
 
     FlacBinarySearchSeeker seeker =
         new FlacBinarySearchSeeker(
-            decoderJni.decodeMetadata(), /* firstFramePosition= */ 0, data.length, decoderJni);
+            decoderJni.decodeStreamMetadata(),
+            /* firstFramePosition= */ 0,
+            data.length,
+            decoderJni);
 
     SeekMap seekMap = seeker.getSeekMap();
     assertThat(seekMap).isNotNull();
@@ -70,7 +73,10 @@ public void testSetSeekTargetUs_returnsSeekPending()
     decoderJni.setData(input);
     FlacBinarySearchSeeker seeker =
         new FlacBinarySearchSeeker(
-            decoderJni.decodeMetadata(), /* firstFramePosition= */ 0, data.length, decoderJni);
+            decoderJni.decodeStreamMetadata(),
+            /* firstFramePosition= */ 0,
+            data.length,
+            decoderJni);
 
     seeker.setSeekTargetUs(/* timeUs= */ 1000);
     assertThat(seeker.isSeeking()).isTrue();
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
index d9cbac6ad5..97f152cea4 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
@@ -28,7 +28,7 @@
 public class FlacExtractorTest {
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     if (!FlacLibrary.isAvailable()) {
       fail("Flac library not available.");
     }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java
index b9c6ea06dd..4bfcc003ec 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacBinarySearchSeeker.java
@@ -19,7 +19,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.FlacStreamInfo;
+import com.google.android.exoplayer2.util.FlacStreamMetadata;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
@@ -34,20 +34,20 @@
   private final FlacDecoderJni decoderJni;
 
   public FlacBinarySearchSeeker(
-      FlacStreamInfo streamInfo,
+      FlacStreamMetadata streamMetadata,
       long firstFramePosition,
       long inputLength,
       FlacDecoderJni decoderJni) {
     super(
-        new FlacSeekTimestampConverter(streamInfo),
+        new FlacSeekTimestampConverter(streamMetadata),
         new FlacTimestampSeeker(decoderJni),
-        streamInfo.durationUs(),
+        streamMetadata.durationUs(),
         /* floorTimePosition= */ 0,
-        /* ceilingTimePosition= */ streamInfo.totalSamples,
+        /* ceilingTimePosition= */ streamMetadata.totalSamples,
         /* floorBytePosition= */ firstFramePosition,
         /* ceilingBytePosition= */ inputLength,
-        /* approxBytesPerFrame= */ streamInfo.getApproxBytesPerFrame(),
-        /* minimumSearchRange= */ Math.max(1, streamInfo.minFrameSize));
+        /* approxBytesPerFrame= */ streamMetadata.getApproxBytesPerFrame(),
+        /* minimumSearchRange= */ Math.max(1, streamMetadata.minFrameSize));
     this.decoderJni = Assertions.checkNotNull(decoderJni);
   }
 
@@ -112,15 +112,15 @@ public TimestampSearchResult searchForTimestamp(
    * the timestamp for a stream seek time position.
    */
   private static final class FlacSeekTimestampConverter implements SeekTimestampConverter {
-    private final FlacStreamInfo streamInfo;
+    private final FlacStreamMetadata streamMetadata;
 
-    public FlacSeekTimestampConverter(FlacStreamInfo streamInfo) {
-      this.streamInfo = streamInfo;
+    public FlacSeekTimestampConverter(FlacStreamMetadata streamMetadata) {
+      this.streamMetadata = streamMetadata;
     }
 
     @Override
     public long timeUsToTargetTime(long timeUs) {
-      return Assertions.checkNotNull(streamInfo).getSampleIndex(timeUs);
+      return Assertions.checkNotNull(streamMetadata).getSampleIndex(timeUs);
     }
   }
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
index 2d74bce5f1..50eb048d98 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
@@ -15,11 +15,13 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
-import com.google.android.exoplayer2.util.FlacStreamInfo;
+import com.google.android.exoplayer2.util.FlacStreamMetadata;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
@@ -56,21 +58,20 @@ public FlacDecoder(
     }
     decoderJni = new FlacDecoderJni();
     decoderJni.setData(ByteBuffer.wrap(initializationData.get(0)));
-    FlacStreamInfo streamInfo;
+    FlacStreamMetadata streamMetadata;
     try {
-      streamInfo = decoderJni.decodeMetadata();
+      streamMetadata = decoderJni.decodeStreamMetadata();
+    } catch (ParserException e) {
+      throw new FlacDecoderException("Failed to decode StreamInfo", e);
     } catch (IOException | InterruptedException e) {
       // Never happens.
       throw new IllegalStateException(e);
     }
-    if (streamInfo == null) {
-      throw new FlacDecoderException("Metadata decoding failed");
-    }
 
     int initialInputBufferSize =
-        maxInputBufferSize != Format.NO_VALUE ? maxInputBufferSize : streamInfo.maxFrameSize;
+        maxInputBufferSize != Format.NO_VALUE ? maxInputBufferSize : streamMetadata.maxFrameSize;
     setInitialInputBufferSize(initialInputBufferSize);
-    maxOutputBufferSize = streamInfo.maxDecodedFrameSize();
+    maxOutputBufferSize = streamMetadata.maxDecodedFrameSize();
   }
 
   @Override
@@ -94,6 +95,7 @@ protected FlacDecoderException createUnexpectedDecodeException(Throwable error)
   }
 
   @Override
+  @Nullable
   protected FlacDecoderException decode(
       DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
index de038921aa..f454e28c68 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
@@ -15,9 +15,12 @@
  */
 package com.google.android.exoplayer2.ext.flac;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.util.FlacStreamInfo;
+import com.google.android.exoplayer2.util.FlacStreamMetadata;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
@@ -37,14 +40,14 @@ public FlacFrameDecodeException(String message, int errorCode) {
     }
   }
 
-  private static final int TEMP_BUFFER_SIZE = 8192; // The same buffer size which libflac has
+  private static final int TEMP_BUFFER_SIZE = 8192; // The same buffer size as libflac.
 
   private final long nativeDecoderContext;
 
-  private ByteBuffer byteBufferData;
-  private ExtractorInput extractorInput;
+  @Nullable private ByteBuffer byteBufferData;
+  @Nullable private ExtractorInput extractorInput;
+  @Nullable private byte[] tempBuffer;
   private boolean endOfExtractorInput;
-  private byte[] tempBuffer;
 
   public FlacDecoderJni() throws FlacDecoderException {
     if (!FlacLibrary.isAvailable()) {
@@ -57,67 +60,79 @@ public FlacDecoderJni() throws FlacDecoderException {
   }
 
   /**
-   * Sets data to be parsed by libflac.
-   * @param byteBufferData Source {@link ByteBuffer}
+   * Sets the data to be parsed.
+   *
+   * @param byteBufferData Source {@link ByteBuffer}.
    */
   public void setData(ByteBuffer byteBufferData) {
     this.byteBufferData = byteBufferData;
     this.extractorInput = null;
-    this.tempBuffer = null;
   }
 
   /**
-   * Sets data to be parsed by libflac.
-   * @param extractorInput Source {@link ExtractorInput}
+   * Sets the data to be parsed.
+   *
+   * @param extractorInput Source {@link ExtractorInput}.
    */
   public void setData(ExtractorInput extractorInput) {
     this.byteBufferData = null;
     this.extractorInput = extractorInput;
+    endOfExtractorInput = false;
     if (tempBuffer == null) {
-      this.tempBuffer = new byte[TEMP_BUFFER_SIZE];
+      tempBuffer = new byte[TEMP_BUFFER_SIZE];
     }
-    endOfExtractorInput = false;
   }
 
+  /**
+   * Returns whether the end of the data to be parsed has been reached, or true if no data was set.
+   */
   public boolean isEndOfData() {
     if (byteBufferData != null) {
       return byteBufferData.remaining() == 0;
     } else if (extractorInput != null) {
       return endOfExtractorInput;
+    } else {
+      return true;
     }
-    return true;
+  }
+
+  /** Clears the data to be parsed. */
+  public void clearData() {
+    byteBufferData = null;
+    extractorInput = null;
   }
 
   /**
    * Reads up to {@code length} bytes from the data source.
-   * <p>
-   * This method blocks until at least one byte of data can be read, the end of the input is
+   *
+   * <p>This method blocks until at least one byte of data can be read, the end of the input is
    * detected or an exception is thrown.
-   * <p>
-   * This method is called from the native code.
    *
    * @param target A target {@link ByteBuffer} into which data should be written.
-   * @return Returns the number of bytes read, or -1 on failure. It's not an error if this returns
-   * zero; it just means all the data read from the source.
+   * @return Returns the number of bytes read, or -1 on failure. If all of the data has already been
+   *     read from the source, then 0 is returned.
    */
+  @SuppressWarnings("unused") // Called from native code.
   public int read(ByteBuffer target) throws IOException, InterruptedException {
     int byteCount = target.remaining();
     if (byteBufferData != null) {
       byteCount = Math.min(byteCount, byteBufferData.remaining());
       int originalLimit = byteBufferData.limit();
       byteBufferData.limit(byteBufferData.position() + byteCount);
-
       target.put(byteBufferData);
-
       byteBufferData.limit(originalLimit);
     } else if (extractorInput != null) {
+      ExtractorInput extractorInput = this.extractorInput;
+      byte[] tempBuffer = Util.castNonNull(this.tempBuffer);
       byteCount = Math.min(byteCount, TEMP_BUFFER_SIZE);
-      int read = readFromExtractorInput(0, byteCount);
+      int read = readFromExtractorInput(extractorInput, tempBuffer, /* offset= */ 0, byteCount);
       if (read < 4) {
         // Reading less than 4 bytes, most of the time, happens because of getting the bytes left in
         // the buffer of the input. Do another read to reduce the number of calls to this method
         // from the native code.
-        read += readFromExtractorInput(read, byteCount - read);
+        read +=
+            readFromExtractorInput(
+                extractorInput, tempBuffer, read, /* length= */ byteCount - read);
       }
       byteCount = read;
       target.put(tempBuffer, 0, byteCount);
@@ -127,9 +142,13 @@ public int read(ByteBuffer target) throws IOException, InterruptedException {
     return byteCount;
   }
 
-  /** Decodes and consumes the StreamInfo section from the FLAC stream. */
-  public FlacStreamInfo decodeMetadata() throws IOException, InterruptedException {
-    return flacDecodeMetadata(nativeDecoderContext);
+  /** Decodes and consumes the metadata from the FLAC stream. */
+  public FlacStreamMetadata decodeStreamMetadata() throws IOException, InterruptedException {
+    FlacStreamMetadata streamMetadata = flacDecodeMetadata(nativeDecoderContext);
+    if (streamMetadata == null) {
+      throw new ParserException("Failed to decode stream metadata");
+    }
+    return streamMetadata;
   }
 
   /**
@@ -234,7 +253,8 @@ public void release() {
     flacRelease(nativeDecoderContext);
   }
 
-  private int readFromExtractorInput(int offset, int length)
+  private int readFromExtractorInput(
+      ExtractorInput extractorInput, byte[] tempBuffer, int offset, int length)
       throws IOException, InterruptedException {
     int read = extractorInput.read(tempBuffer, offset, length);
     if (read == C.RESULT_END_OF_INPUT) {
@@ -246,7 +266,7 @@ private int readFromExtractorInput(int offset, int length)
 
   private native long flacInit();
 
-  private native FlacStreamInfo flacDecodeMetadata(long context)
+  private native FlacStreamMetadata flacDecodeMetadata(long context)
       throws IOException, InterruptedException;
 
   private native int flacDecodeToBuffer(long context, ByteBuffer outputBuffer)
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index bb72e114fe..cd91b06288 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -21,7 +21,7 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
+import com.google.android.exoplayer2.extractor.BinarySearchSeeker.OutputFrameHolder;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -33,7 +33,8 @@
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
-import com.google.android.exoplayer2.util.FlacStreamInfo;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.FlacStreamMetadata;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
@@ -42,6 +43,9 @@
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * Facilitates the extraction of data from the FLAC container format.
@@ -74,23 +78,20 @@
    */
   private static final byte[] FLAC_SIGNATURE = {'f', 'L', 'a', 'C', 0, 0, 0, 0x22};
 
+  private final ParsableByteArray outputBuffer;
   private final Id3Peeker id3Peeker;
-  private final boolean isId3MetadataDisabled;
+  private final boolean id3MetadataDisabled;
 
-  private FlacDecoderJni decoderJni;
+  @Nullable private FlacDecoderJni decoderJni;
+  private @MonotonicNonNull ExtractorOutput extractorOutput;
+  private @MonotonicNonNull TrackOutput trackOutput;
 
-  private ExtractorOutput extractorOutput;
-  private TrackOutput trackOutput;
+  private boolean streamMetadataDecoded;
+  private @MonotonicNonNull FlacStreamMetadata streamMetadata;
+  private @MonotonicNonNull OutputFrameHolder outputFrameHolder;
 
-  private ParsableByteArray outputBuffer;
-  private ByteBuffer outputByteBuffer;
-  private BinarySearchSeeker.OutputFrameHolder outputFrameHolder;
-  private FlacStreamInfo streamInfo;
-
-  private Metadata id3Metadata;
-  private @Nullable FlacBinarySearchSeeker flacBinarySearchSeeker;
-
-  private boolean readPastStreamInfo;
+  @Nullable private Metadata id3Metadata;
+  @Nullable private FlacBinarySearchSeeker binarySearchSeeker;
 
   /** Constructs an instance with flags = 0. */
   public FlacExtractor() {
@@ -103,8 +104,9 @@ public FlacExtractor() {
    * @param flags Flags that control the extractor's behavior.
    */
   public FlacExtractor(int flags) {
+    outputBuffer = new ParsableByteArray();
     id3Peeker = new Id3Peeker();
-    isId3MetadataDisabled = (flags & FLAG_DISABLE_ID3_METADATA) != 0;
+    id3MetadataDisabled = (flags & FLAG_DISABLE_ID3_METADATA) != 0;
   }
 
   @Override
@@ -130,48 +132,53 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public int read(final ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    if (input.getPosition() == 0 && !isId3MetadataDisabled && id3Metadata == null) {
+    if (input.getPosition() == 0 && !id3MetadataDisabled && id3Metadata == null) {
       id3Metadata = peekId3Data(input);
     }
 
-    decoderJni.setData(input);
-    readPastStreamInfo(input);
+    FlacDecoderJni decoderJni = initDecoderJni(input);
+    try {
+      decodeStreamMetadata(input);
 
-    if (flacBinarySearchSeeker != null && flacBinarySearchSeeker.isSeeking()) {
-      return handlePendingSeek(input, seekPosition);
-    }
+      if (binarySearchSeeker != null && binarySearchSeeker.isSeeking()) {
+        return handlePendingSeek(input, seekPosition, outputBuffer, outputFrameHolder, trackOutput);
+      }
 
-    long lastDecodePosition = decoderJni.getDecodePosition();
-    try {
-      decoderJni.decodeSampleWithBacktrackPosition(outputByteBuffer, lastDecodePosition);
-    } catch (FlacDecoderJni.FlacFrameDecodeException e) {
-      throw new IOException("Cannot read frame at position " + lastDecodePosition, e);
-    }
-    int outputSize = outputByteBuffer.limit();
-    if (outputSize == 0) {
-      return RESULT_END_OF_INPUT;
-    }
+      ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
+      long lastDecodePosition = decoderJni.getDecodePosition();
+      try {
+        decoderJni.decodeSampleWithBacktrackPosition(outputByteBuffer, lastDecodePosition);
+      } catch (FlacDecoderJni.FlacFrameDecodeException e) {
+        throw new IOException("Cannot read frame at position " + lastDecodePosition, e);
+      }
+      int outputSize = outputByteBuffer.limit();
+      if (outputSize == 0) {
+        return RESULT_END_OF_INPUT;
+      }
 
-    writeLastSampleToOutput(outputSize, decoderJni.getLastFrameTimestamp());
-    return decoderJni.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
+      outputSample(outputBuffer, outputSize, decoderJni.getLastFrameTimestamp(), trackOutput);
+      return decoderJni.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
+    } finally {
+      decoderJni.clearData();
+    }
   }
 
   @Override
   public void seek(long position, long timeUs) {
     if (position == 0) {
-      readPastStreamInfo = false;
+      streamMetadataDecoded = false;
     }
     if (decoderJni != null) {
       decoderJni.reset(position);
     }
-    if (flacBinarySearchSeeker != null) {
-      flacBinarySearchSeeker.setSeekTargetUs(timeUs);
+    if (binarySearchSeeker != null) {
+      binarySearchSeeker.setSeekTargetUs(timeUs);
     }
   }
 
   @Override
   public void release() {
-    flacBinarySearchSeeker = null;
+    binarySearchSeeker = null;
     if (decoderJni != null) {
       decoderJni.release();
       decoderJni = null;
@@ -179,123 +186,141 @@ public void release() {
   }
 
   /**
-   * Peeks ID3 tag data (if present) at the beginning of the input.
+   * Peeks ID3 tag data at the beginning of the input.
    *
-   * @return The first ID3 tag decoded into a {@link Metadata} object. May be null if ID3 tag is not
-   *     present in the input.
+   * @return The first ID3 tag {@link Metadata}, or null if an ID3 tag is not present in the input.
    */
   @Nullable
   private Metadata peekId3Data(ExtractorInput input) throws IOException, InterruptedException {
     input.resetPeekPosition();
     Id3Decoder.FramePredicate id3FramePredicate =
-        isId3MetadataDisabled ? Id3Decoder.NO_FRAMES_PREDICATE : null;
+        id3MetadataDisabled ? Id3Decoder.NO_FRAMES_PREDICATE : null;
     return id3Peeker.peekId3Data(input, id3FramePredicate);
   }
 
-  /**
-   * Peeks from the beginning of the input to see if {@link #FLAC_SIGNATURE} is present.
-   *
-   * @return Whether the input begins with {@link #FLAC_SIGNATURE}.
-   */
-  private boolean peekFlacSignature(ExtractorInput input) throws IOException, InterruptedException {
-    byte[] header = new byte[FLAC_SIGNATURE.length];
-    input.peekFully(header, 0, FLAC_SIGNATURE.length);
-    return Arrays.equals(header, FLAC_SIGNATURE);
+  @EnsuresNonNull({"decoderJni", "extractorOutput", "trackOutput"}) // Ensures initialized.
+  @SuppressWarnings({"contracts.postcondition.not.satisfied"})
+  private FlacDecoderJni initDecoderJni(ExtractorInput input) {
+    FlacDecoderJni decoderJni = Assertions.checkNotNull(this.decoderJni);
+    decoderJni.setData(input);
+    return decoderJni;
   }
 
-  private void readPastStreamInfo(ExtractorInput input) throws InterruptedException, IOException {
-    if (readPastStreamInfo) {
+  @RequiresNonNull({"decoderJni", "extractorOutput", "trackOutput"}) // Requires initialized.
+  @EnsuresNonNull({"streamMetadata", "outputFrameHolder"}) // Ensures stream metadata decoded.
+  @SuppressWarnings({"contracts.postcondition.not.satisfied"})
+  private void decodeStreamMetadata(ExtractorInput input) throws InterruptedException, IOException {
+    if (streamMetadataDecoded) {
       return;
     }
 
-    FlacStreamInfo streamInfo = decodeStreamInfo(input);
-    readPastStreamInfo = true;
-    if (this.streamInfo == null) {
-      updateFlacStreamInfo(input, streamInfo);
+    FlacStreamMetadata streamMetadata;
+    try {
+      streamMetadata = decoderJni.decodeStreamMetadata();
+    } catch (IOException e) {
+      decoderJni.reset(/* newPosition= */ 0);
+      input.setRetryPosition(/* position= */ 0, e);
+      throw e;
     }
-  }
 
-  private void updateFlacStreamInfo(ExtractorInput input, FlacStreamInfo streamInfo) {
-    this.streamInfo = streamInfo;
-    outputSeekMap(input, streamInfo);
-    outputFormat(streamInfo);
-    outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
-    outputByteBuffer = ByteBuffer.wrap(outputBuffer.data);
-    outputFrameHolder = new BinarySearchSeeker.OutputFrameHolder(outputByteBuffer);
+    streamMetadataDecoded = true;
+    if (this.streamMetadata == null) {
+      this.streamMetadata = streamMetadata;
+      binarySearchSeeker =
+          outputSeekMap(decoderJni, streamMetadata, input.getLength(), extractorOutput);
+      Metadata metadata = id3MetadataDisabled ? null : id3Metadata;
+      if (streamMetadata.metadata != null) {
+        metadata = streamMetadata.metadata.copyWithAppendedEntriesFrom(metadata);
+      }
+      outputFormat(streamMetadata, metadata, trackOutput);
+      outputBuffer.reset(streamMetadata.maxDecodedFrameSize());
+      outputFrameHolder = new OutputFrameHolder(ByteBuffer.wrap(outputBuffer.data));
+    }
   }
 
-  private FlacStreamInfo decodeStreamInfo(ExtractorInput input)
+  @RequiresNonNull("binarySearchSeeker")
+  private int handlePendingSeek(
+      ExtractorInput input,
+      PositionHolder seekPosition,
+      ParsableByteArray outputBuffer,
+      OutputFrameHolder outputFrameHolder,
+      TrackOutput trackOutput)
       throws InterruptedException, IOException {
-    try {
-      FlacStreamInfo streamInfo = decoderJni.decodeMetadata();
-      if (streamInfo == null) {
-        throw new IOException("Metadata decoding failed");
-      }
-      return streamInfo;
-    } catch (IOException e) {
-      decoderJni.reset(0);
-      input.setRetryPosition(0, e);
-      throw e;
+    int seekResult = binarySearchSeeker.handlePendingSeek(input, seekPosition, outputFrameHolder);
+    ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
+    if (seekResult == RESULT_CONTINUE && outputByteBuffer.limit() > 0) {
+      outputSample(outputBuffer, outputByteBuffer.limit(), outputFrameHolder.timeUs, trackOutput);
     }
+    return seekResult;
   }
 
-  private void outputSeekMap(ExtractorInput input, FlacStreamInfo streamInfo) {
-    boolean hasSeekTable = decoderJni.getSeekPosition(0) != -1;
-    SeekMap seekMap =
-        hasSeekTable
-            ? new FlacSeekMap(streamInfo.durationUs(), decoderJni)
-            : getSeekMapForNonSeekTableFlac(input, streamInfo);
-    extractorOutput.seekMap(seekMap);
+  /**
+   * Peeks from the beginning of the input to see if {@link #FLAC_SIGNATURE} is present.
+   *
+   * @return Whether the input begins with {@link #FLAC_SIGNATURE}.
+   */
+  private static boolean peekFlacSignature(ExtractorInput input)
+      throws IOException, InterruptedException {
+    byte[] header = new byte[FLAC_SIGNATURE.length];
+    input.peekFully(header, /* offset= */ 0, FLAC_SIGNATURE.length);
+    return Arrays.equals(header, FLAC_SIGNATURE);
   }
 
-  private SeekMap getSeekMapForNonSeekTableFlac(ExtractorInput input, FlacStreamInfo streamInfo) {
-    long inputLength = input.getLength();
-    if (inputLength != C.LENGTH_UNSET) {
+  /**
+   * Outputs a {@link SeekMap} and returns a {@link FlacBinarySearchSeeker} if one is required to
+   * handle seeks.
+   */
+  @Nullable
+  private static FlacBinarySearchSeeker outputSeekMap(
+      FlacDecoderJni decoderJni,
+      FlacStreamMetadata streamMetadata,
+      long streamLength,
+      ExtractorOutput output) {
+    boolean hasSeekTable = decoderJni.getSeekPosition(/* timeUs= */ 0) != -1;
+    FlacBinarySearchSeeker binarySearchSeeker = null;
+    SeekMap seekMap;
+    if (hasSeekTable) {
+      seekMap = new FlacSeekMap(streamMetadata.durationUs(), decoderJni);
+    } else if (streamLength != C.LENGTH_UNSET) {
       long firstFramePosition = decoderJni.getDecodePosition();
-      flacBinarySearchSeeker =
-          new FlacBinarySearchSeeker(streamInfo, firstFramePosition, inputLength, decoderJni);
-      return flacBinarySearchSeeker.getSeekMap();
-    } else { // can't seek at all, because there's no SeekTable and the input length is unknown.
-      return new SeekMap.Unseekable(streamInfo.durationUs());
+      binarySearchSeeker =
+          new FlacBinarySearchSeeker(streamMetadata, firstFramePosition, streamLength, decoderJni);
+      seekMap = binarySearchSeeker.getSeekMap();
+    } else {
+      seekMap = new SeekMap.Unseekable(streamMetadata.durationUs());
     }
+    output.seekMap(seekMap);
+    return binarySearchSeeker;
   }
 
-  private void outputFormat(FlacStreamInfo streamInfo) {
+  private static void outputFormat(
+      FlacStreamMetadata streamMetadata, @Nullable Metadata metadata, TrackOutput output) {
     Format mediaFormat =
         Format.createAudioSampleFormat(
             /* id= */ null,
             MimeTypes.AUDIO_RAW,
             /* codecs= */ null,
-            streamInfo.bitRate(),
-            streamInfo.maxDecodedFrameSize(),
-            streamInfo.channels,
-            streamInfo.sampleRate,
-            getPcmEncoding(streamInfo.bitsPerSample),
+            streamMetadata.bitRate(),
+            streamMetadata.maxDecodedFrameSize(),
+            streamMetadata.channels,
+            streamMetadata.sampleRate,
+            getPcmEncoding(streamMetadata.bitsPerSample),
             /* encoderDelay= */ 0,
             /* encoderPadding= */ 0,
             /* initializationData= */ null,
             /* drmInitData= */ null,
             /* selectionFlags= */ 0,
             /* language= */ null,
-            isId3MetadataDisabled ? null : id3Metadata);
-    trackOutput.format(mediaFormat);
-  }
-
-  private int handlePendingSeek(ExtractorInput input, PositionHolder seekPosition)
-      throws InterruptedException, IOException {
-    int seekResult =
-        flacBinarySearchSeeker.handlePendingSeek(input, seekPosition, outputFrameHolder);
-    ByteBuffer outputByteBuffer = outputFrameHolder.byteBuffer;
-    if (seekResult == RESULT_CONTINUE && outputByteBuffer.limit() > 0) {
-      writeLastSampleToOutput(outputByteBuffer.limit(), outputFrameHolder.timeUs);
-    }
-    return seekResult;
+            metadata);
+    output.format(mediaFormat);
   }
 
-  private void writeLastSampleToOutput(int size, long lastSampleTimestamp) {
-    outputBuffer.setPosition(0);
-    trackOutput.sampleData(outputBuffer, size);
-    trackOutput.sampleMetadata(lastSampleTimestamp, C.BUFFER_FLAG_KEY_FRAME, size, 0, null);
+  private static void outputSample(
+      ParsableByteArray sampleData, int size, long timeUs, TrackOutput output) {
+    sampleData.setPosition(0);
+    output.sampleData(sampleData, size);
+    output.sampleMetadata(
+        timeUs, C.BUFFER_FLAG_KEY_FRAME, size, /* offset= */ 0, /* encryptionData= */ null);
   }
 
   /** A {@link SeekMap} implementation using a SeekTable within the Flac stream. */
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index 298719d48d..d60a7cead2 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -14,9 +14,12 @@
  * limitations under the License.
  */
 
-#include <jni.h>
 #include <android/log.h>
+#include <jni.h>
+
 #include <cstdlib>
+#include <cstring>
+
 #include "include/flac_parser.h"
 
 #define LOG_TAG "flac_jni"
@@ -95,19 +98,68 @@ DECODER_FUNC(jobject, flacDecodeMetadata, jlong jContext) {
     return NULL;
   }
 
+  jclass arrayListClass = env->FindClass("java/util/ArrayList");
+  jmethodID arrayListConstructor =
+      env->GetMethodID(arrayListClass, "<init>", "()V");
+  jobject commentList = env->NewObject(arrayListClass, arrayListConstructor);
+  jmethodID arrayListAddMethod =
+      env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
+
+  if (context->parser->areVorbisCommentsValid()) {
+    std::vector<std::string> vorbisComments =
+        context->parser->getVorbisComments();
+    for (std::vector<std::string>::const_iterator vorbisComment =
+             vorbisComments.begin();
+         vorbisComment != vorbisComments.end(); ++vorbisComment) {
+      jstring commentString = env->NewStringUTF((*vorbisComment).c_str());
+      env->CallBooleanMethod(commentList, arrayListAddMethod, commentString);
+      env->DeleteLocalRef(commentString);
+    }
+  }
+
+  jobject pictureFrames = env->NewObject(arrayListClass, arrayListConstructor);
+  bool picturesValid = context->parser->arePicturesValid();
+  if (picturesValid) {
+    std::vector<FlacPicture> pictures = context->parser->getPictures();
+    jclass pictureFrameClass = env->FindClass(
+        "com/google/android/exoplayer2/metadata/flac/PictureFrame");
+    jmethodID pictureFrameConstructor =
+        env->GetMethodID(pictureFrameClass, "<init>",
+                         "(ILjava/lang/String;Ljava/lang/String;IIII[B)V");
+    for (std::vector<FlacPicture>::const_iterator picture = pictures.begin();
+         picture != pictures.end(); ++picture) {
+      jstring mimeType = env->NewStringUTF(picture->mimeType.c_str());
+      jstring description = env->NewStringUTF(picture->description.c_str());
+      jbyteArray pictureData = env->NewByteArray(picture->data.size());
+      env->SetByteArrayRegion(pictureData, 0, picture->data.size(),
+                              (signed char *)&picture->data[0]);
+      jobject pictureFrame = env->NewObject(
+          pictureFrameClass, pictureFrameConstructor, picture->type, mimeType,
+          description, picture->width, picture->height, picture->depth,
+          picture->colors, pictureData);
+      env->CallBooleanMethod(pictureFrames, arrayListAddMethod, pictureFrame);
+      env->DeleteLocalRef(mimeType);
+      env->DeleteLocalRef(description);
+      env->DeleteLocalRef(pictureData);
+    }
+  }
+
   const FLAC__StreamMetadata_StreamInfo &streamInfo =
       context->parser->getStreamInfo();
 
-  jclass cls = env->FindClass(
+  jclass flacStreamMetadataClass = env->FindClass(
       "com/google/android/exoplayer2/util/"
-      "FlacStreamInfo");
-  jmethodID constructor = env->GetMethodID(cls, "<init>", "(IIIIIIIJ)V");
-
-  return env->NewObject(cls, constructor, streamInfo.min_blocksize,
-                        streamInfo.max_blocksize, streamInfo.min_framesize,
-                        streamInfo.max_framesize, streamInfo.sample_rate,
-                        streamInfo.channels, streamInfo.bits_per_sample,
-                        streamInfo.total_samples);
+      "FlacStreamMetadata");
+  jmethodID flacStreamMetadataConstructor =
+      env->GetMethodID(flacStreamMetadataClass, "<init>",
+                       "(IIIIIIIJLjava/util/List;Ljava/util/List;)V");
+
+  return env->NewObject(flacStreamMetadataClass, flacStreamMetadataConstructor,
+                        streamInfo.min_blocksize, streamInfo.max_blocksize,
+                        streamInfo.min_framesize, streamInfo.max_framesize,
+                        streamInfo.sample_rate, streamInfo.channels,
+                        streamInfo.bits_per_sample, streamInfo.total_samples,
+                        commentList, pictureFrames);
 }
 
 DECODER_FUNC(jint, flacDecodeToBuffer, jlong jContext, jobject jOutputBuffer) {
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index 83d3367415..830f3e2178 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -172,6 +172,43 @@ void FLACParser::metadataCallback(const FLAC__StreamMetadata *metadata) {
     case FLAC__METADATA_TYPE_SEEKTABLE:
       mSeekTable = &metadata->data.seek_table;
       break;
+    case FLAC__METADATA_TYPE_VORBIS_COMMENT:
+      if (!mVorbisCommentsValid) {
+        FLAC__StreamMetadata_VorbisComment vorbisComment =
+            metadata->data.vorbis_comment;
+        for (FLAC__uint32 i = 0; i < vorbisComment.num_comments; ++i) {
+          FLAC__StreamMetadata_VorbisComment_Entry vorbisCommentEntry =
+              vorbisComment.comments[i];
+          if (vorbisCommentEntry.entry != NULL) {
+            std::string comment(
+                reinterpret_cast<char *>(vorbisCommentEntry.entry),
+                vorbisCommentEntry.length);
+            mVorbisComments.push_back(comment);
+          }
+        }
+        mVorbisCommentsValid = true;
+      } else {
+        ALOGE("FLACParser::metadataCallback unexpected VORBISCOMMENT");
+      }
+      break;
+    case FLAC__METADATA_TYPE_PICTURE: {
+      const FLAC__StreamMetadata_Picture *parsedPicture =
+          &metadata->data.picture;
+      FlacPicture picture;
+      picture.mimeType.assign(std::string(parsedPicture->mime_type));
+      picture.description.assign(
+          std::string((char *)parsedPicture->description));
+      picture.data.assign(parsedPicture->data,
+                          parsedPicture->data + parsedPicture->data_length);
+      picture.width = parsedPicture->width;
+      picture.height = parsedPicture->height;
+      picture.depth = parsedPicture->depth;
+      picture.colors = parsedPicture->colors;
+      picture.type = parsedPicture->type;
+      mPictures.push_back(picture);
+      mPicturesValid = true;
+      break;
+    }
     default:
       ALOGE("FLACParser::metadataCallback unexpected type %u", metadata->type);
       break;
@@ -233,6 +270,8 @@ FLACParser::FLACParser(DataSource *source)
       mCurrentPos(0LL),
       mEOF(false),
       mStreamInfoValid(false),
+      mVorbisCommentsValid(false),
+      mPicturesValid(false),
       mWriteRequested(false),
       mWriteCompleted(false),
       mWriteBuffer(NULL),
@@ -266,6 +305,10 @@ bool FLACParser::init() {
                                             FLAC__METADATA_TYPE_STREAMINFO);
   FLAC__stream_decoder_set_metadata_respond(mDecoder,
                                             FLAC__METADATA_TYPE_SEEKTABLE);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_VORBIS_COMMENT);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_PICTURE);
   FLAC__StreamDecoderInitStatus initStatus;
   initStatus = FLAC__stream_decoder_init_stream(
       mDecoder, read_callback, seek_callback, tell_callback, length_callback,
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
index cea7fbe33b..14ba9e8725 100644
--- a/extensions/flac/src/main/jni/include/flac_parser.h
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -19,6 +19,10 @@
 
 #include <stdint.h>
 
+#include <cstdlib>
+#include <string>
+#include <vector>
+
 // libFLAC parser
 #include "FLAC/stream_decoder.h"
 
@@ -26,6 +30,17 @@
 
 typedef int status_t;
 
+struct FlacPicture {
+  int type;
+  std::string mimeType;
+  std::string description;
+  FLAC__uint32 width;
+  FLAC__uint32 height;
+  FLAC__uint32 depth;
+  FLAC__uint32 colors;
+  std::vector<char> data;
+};
+
 class FLACParser {
  public:
   FLACParser(DataSource *source);
@@ -44,6 +59,14 @@ class FLACParser {
     return mStreamInfo;
   }
 
+  bool areVorbisCommentsValid() const { return mVorbisCommentsValid; }
+
+  std::vector<std::string> getVorbisComments() { return mVorbisComments; }
+
+  bool arePicturesValid() const { return mPicturesValid; }
+
+  const std::vector<FlacPicture> &getPictures() const { return mPictures; }
+
   int64_t getLastFrameTimestamp() const {
     return (1000000LL * mWriteHeader.number.sample_number) / getSampleRate();
   }
@@ -71,6 +94,10 @@ class FLACParser {
       mEOF = false;
       if (newPosition == 0) {
         mStreamInfoValid = false;
+        mVorbisCommentsValid = false;
+        mPicturesValid = false;
+        mVorbisComments.clear();
+        mPictures.clear();
         FLAC__stream_decoder_reset(mDecoder);
       } else {
         FLAC__stream_decoder_flush(mDecoder);
@@ -116,6 +143,14 @@ class FLACParser {
   const FLAC__StreamMetadata_SeekTable *mSeekTable;
   uint64_t firstFrameOffset;
 
+  // cached when the VORBIS_COMMENT metadata is parsed by libFLAC
+  std::vector<std::string> mVorbisComments;
+  bool mVorbisCommentsValid;
+
+  // cached when the PICTURE metadata is parsed by libFLAC
+  std::vector<FlacPicture> mPictures;
+  bool mPicturesValid;
+
   // cached when a decoded PCM block is "written" by libFLAC parser
   bool mWriteRequested;
   bool mWriteCompleted;
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index 50acd6c040..1031d6f4b7 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -33,7 +33,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     api 'com.google.vr:sdk-base:1.190.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
 }
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index a91bbbd981..0ef9f281c9 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -34,6 +34,7 @@ android {
 dependencies {
     api 'com.google.ads.interactivemedia.v3:interactivemedia:3.11.2'
     implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'com.google.android.gms:play-services-ads-identifier:16.0.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 465ad51ac5..68e48b8d33 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -948,8 +948,8 @@ public void resumeAd() {
   @Override
   public void onTimelineChanged(
       Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
-    if (reason == Player.TIMELINE_CHANGE_REASON_RESET) {
-      // The player is being reset and this source will be released.
+    if (timeline.isEmpty()) {
+      // The player is being reset or contains no media.
       return;
     }
     Assertions.checkArgument(timeline.getPeriodCount() == 1);
@@ -1054,13 +1054,8 @@ private void startAdPlayback() {
     long contentPositionMs = player.getCurrentPosition();
     int adGroupIndexForPosition =
         adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
-    if (adGroupIndexForPosition == 0) {
-      podIndexOffset = 0;
-    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
-      // There is no preroll and midroll pod indices start at 1.
-      podIndexOffset = -1;
-    } else /* adGroupIndexForPosition > 0 */ {
-      // Skip ad groups before the one at or immediately before the playback position.
+    if (adGroupIndexForPosition > 0 && adGroupIndexForPosition != C.INDEX_UNSET) {
+      // Skip any ad groups before the one at or immediately before the playback position.
       for (int i = 0; i < adGroupIndexForPosition; i++) {
         adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
       }
@@ -1070,9 +1065,18 @@ private void startAdPlayback() {
       long adGroupBeforeTimeUs = adGroupTimesUs[adGroupIndexForPosition - 1];
       double midpointTimeUs = (adGroupForPositionTimeUs + adGroupBeforeTimeUs) / 2d;
       adsRenderingSettings.setPlayAdsAfterTime(midpointTimeUs / C.MICROS_PER_SECOND);
+    }
 
-      // We're removing one or more ads, which means that the earliest ad (if any) will be a
-      // midroll/postroll. Midroll pod indices start at 1.
+    // IMA indexes any remaining midroll ad pods from 1. A preroll (if present) has index 0.
+    // Store an index offset as we want to index all ads (including skipped ones) from 0.
+    if (adGroupIndexForPosition == 0 && adGroupTimesUs[0] == 0) {
+      // We are playing a preroll.
+      podIndexOffset = 0;
+    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
+      // There's no ad to play which means there's no preroll.
+      podIndexOffset = -1;
+    } else {
+      // We are playing a midroll and any ads before it were skipped.
       podIndexOffset = adGroupIndexForPosition - 1;
     }
 
diff --git a/extensions/jobdispatcher/README.md b/extensions/jobdispatcher/README.md
index f70125ba38..a6f0c3966a 100644
--- a/extensions/jobdispatcher/README.md
+++ b/extensions/jobdispatcher/README.md
@@ -1,7 +1,11 @@
 # ExoPlayer Firebase JobDispatcher extension #
 
+**DEPRECATED - Please use [WorkManager extension][] or [PlatformScheduler][] instead.**
+
 This extension provides a Scheduler implementation which uses [Firebase JobDispatcher][].
 
+[WorkManager extension]: https://github.com/google/ExoPlayer/blob/release-v2/extensions/workmanager/README.md
+[PlatformScheduler]: https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
 [Firebase JobDispatcher]: https://github.com/firebase/firebase-jobdispatcher-android
 
 ## Getting the extension ##
@@ -20,4 +24,3 @@ locally. Instructions for doing this can be found in ExoPlayer's
 [top level README][].
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
-
diff --git a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
index d79dead0d7..c8975275f1 100644
--- a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
+++ b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/JobDispatcherScheduler.java
@@ -54,7 +54,10 @@
  *
  * @see <a
  *     href="https://developers.google.com/android/reference/com/google/android/gms/common/GoogleApiAvailability#isGooglePlayServicesAvailable(android.content.Context)">GoogleApiAvailability</a>
+ * @deprecated Use com.google.android.exoplayer2.ext.workmanager.WorkManagerScheduler or {@link
+ *     com.google.android.exoplayer2.scheduler.PlatformScheduler}.
  */
+@Deprecated
 public final class JobDispatcherScheduler implements Scheduler {
 
   private static final boolean DEBUG = false;
diff --git a/extensions/leanback/build.gradle b/extensions/leanback/build.gradle
index c6f5a216ce..ecaa78e25b 100644
--- a/extensions/leanback/build.gradle
+++ b/extensions/leanback/build.gradle
@@ -32,7 +32,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'androidx.leanback:leanback:1.0.0'
 }
 
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 9c80fabc50..7e72904078 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -172,7 +172,7 @@ boolean onCommand(
         ResultReceiver cb);
   }
 
-  /** Interface to which playback preparation actions are delegated. */
+  /** Interface to which playback preparation and play actions are delegated. */
   public interface PlaybackPreparer extends CommandReceiver {
 
     long ACTIONS =
@@ -197,14 +197,36 @@ boolean onCommand(
      * @return The bitmask of the supported media actions.
      */
     long getSupportedPrepareActions();
-    /** See {@link MediaSessionCompat.Callback#onPrepare()}. */
-    void onPrepare();
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}. */
-    void onPrepareFromMediaId(String mediaId, Bundle extras);
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}. */
-    void onPrepareFromSearch(String query, Bundle extras);
-    /** See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}. */
-    void onPrepareFromUri(Uri uri, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepare()}.
+     *
+     * @param playWhenReady Whether playback should be started after preparation.
+     */
+    void onPrepare(boolean playWhenReady);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromMediaId(String, Bundle)}.
+     *
+     * @param mediaId The media id of the media item to be prepared.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromMediaId(String mediaId, boolean playWhenReady, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromSearch(String, Bundle)}.
+     *
+     * @param query The search query.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromSearch(String query, boolean playWhenReady, Bundle extras);
+    /**
+     * See {@link MediaSessionCompat.Callback#onPrepareFromUri(Uri, Bundle)}.
+     *
+     * @param uri The {@link Uri} of the media item to be prepared.
+     * @param playWhenReady Whether playback should be started after preparation.
+     * @param extras A {@link Bundle} of extras passed by the media controller.
+     */
+    void onPrepareFromUri(Uri uri, boolean playWhenReady, Bundle extras);
   }
 
   /**
@@ -355,6 +377,13 @@ void onCustomAction(
     /**
      * Gets the {@link MediaMetadataCompat} to be published to the session.
      *
+     * <p>An app may need to load metadata resources like artwork bitmaps asynchronously. In such a
+     * case the app should return a {@link MediaMetadataCompat} object that does not contain these
+     * resources as a placeholder. The app should start an asynchronous operation to download the
+     * bitmap and put it into a cache. Finally, the app should call {@link
+     * #invalidateMediaSessionMetadata()}. This causes this callback to be called again and the app
+     * can now return a {@link MediaMetadataCompat} object with all the resources included.
+     *
      * @param player The player connected to the media session.
      * @return The {@link MediaMetadataCompat} to be published to the session.
      */
@@ -834,13 +863,6 @@ private boolean canDispatchMediaButtonEvent() {
     return player != null && mediaButtonEventHandler != null;
   }
 
-  private void stopPlayerForPrepare(boolean playWhenReady) {
-    if (player != null) {
-      player.stop();
-      player.setPlayWhenReady(playWhenReady);
-    }
-  }
-
   private void rewind(Player player) {
     if (player.isCurrentWindowSeekable() && rewindMs > 0) {
       seekTo(player, player.getCurrentPosition() - rewindMs);
@@ -1047,12 +1069,13 @@ public void onPlay() {
       if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_PLAY)) {
         if (player.getPlaybackState() == Player.STATE_IDLE) {
           if (playbackPreparer != null) {
-            playbackPreparer.onPrepare();
+            playbackPreparer.onPrepare(/* playWhenReady= */ true);
           }
         } else if (player.getPlaybackState() == Player.STATE_ENDED) {
           controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
-        controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ true);
+        controlDispatcher.dispatchSetPlayWhenReady(
+            Assertions.checkNotNull(player), /* playWhenReady= */ true);
       }
     }
 
@@ -1182,56 +1205,49 @@ public void onCommand(String command, Bundle extras, ResultReceiver cb) {
     @Override
     public void onPrepare() {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepare();
+        playbackPreparer.onPrepare(/* playWhenReady= */ false);
       }
     }
 
     @Override
     public void onPrepareFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromMediaId(mediaId, extras);
+        playbackPreparer.onPrepareFromMediaId(mediaId, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPrepareFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_SEARCH)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromSearch(query, extras);
+        playbackPreparer.onPrepareFromSearch(query, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPrepareFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PREPARE_FROM_URI)) {
-        stopPlayerForPrepare(/* playWhenReady= */ false);
-        playbackPreparer.onPrepareFromUri(uri, extras);
+        playbackPreparer.onPrepareFromUri(uri, /* playWhenReady= */ false, extras);
       }
     }
 
     @Override
     public void onPlayFromMediaId(String mediaId, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromMediaId(mediaId, extras);
+        playbackPreparer.onPrepareFromMediaId(mediaId, /* playWhenReady= */ true, extras);
       }
     }
 
     @Override
     public void onPlayFromSearch(String query, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_SEARCH)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromSearch(query, extras);
+        playbackPreparer.onPrepareFromSearch(query, /* playWhenReady= */ true, extras);
       }
     }
 
     @Override
     public void onPlayFromUri(Uri uri, Bundle extras) {
       if (canDispatchToPlaybackPreparer(PlaybackStateCompat.ACTION_PLAY_FROM_URI)) {
-        stopPlayerForPrepare(/* playWhenReady= */ true);
-        playbackPreparer.onPrepareFromUri(uri, extras);
+        playbackPreparer.onPrepareFromUri(uri, /* playWhenReady= */ true, extras);
       }
     }
 
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index db2e073c8a..68bd422185 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -33,7 +33,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     api 'com.squareup.okhttp3:okhttp:3.12.1'
 }
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index a749495184..8eb8bba920 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -73,6 +73,15 @@
   private long bytesSkipped;
   private long bytesRead;
 
+  /**
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the source.
+   * @param userAgent An optional User-Agent string.
+   */
+  public OkHttpDataSource(Call.Factory callFactory, @Nullable String userAgent) {
+    this(callFactory, userAgent, /* contentTypePredicate= */ null);
+  }
+
   /**
    * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
    *     by the source.
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 56acbdb7d3..28f7b05465 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -39,6 +39,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
index f8ec477b88..dbce33b923 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.opus;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.CryptoInfo;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
@@ -150,6 +151,7 @@ protected OpusDecoderException createUnexpectedDecodeException(Throwable error)
   }
 
   @Override
+  @Nullable
   protected OpusDecoderException decode(
       DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
index 285be96388..2c2c8f6972 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.opus;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.util.LibraryLoader;
 
@@ -49,9 +50,8 @@ public static boolean isAvailable() {
     return LOADER.isAvailable();
   }
 
-  /**
-   * Returns the version of the underlying library if available, or null otherwise.
-   */
+  /** Returns the version of the underlying library if available, or null otherwise. */
+  @Nullable
   public static String getVersion() {
     return isAvailable() ? opusGetVersion() : null;
   }
diff --git a/extensions/rtmp/build.gradle b/extensions/rtmp/build.gradle
index ca734c3657..b74be659ee 100644
--- a/extensions/rtmp/build.gradle
+++ b/extensions/rtmp/build.gradle
@@ -33,7 +33,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'net.butterflytv.utils:rtmp-client:3.0.1'
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 0de29eea32..be75eae359 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -29,6 +29,7 @@ VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 ```
 
 * Download the [Android NDK][] and set its location in an environment variable.
+  The build configuration has been tested with Android NDK r19c.
 
 ```
 NDK_PATH="<path to Android NDK>"
@@ -54,7 +55,7 @@ git checkout tags/v1.8.0 -b v1.8.0
 
 ```
 cd ${VP9_EXT_PATH}/jni && \
-./generate_libvpx_android_configs.sh "${NDK_PATH}"
+./generate_libvpx_android_configs.sh
 ```
 
 * Build the JNI native libraries from the command line:
@@ -66,7 +67,6 @@ ${NDK_PATH}/ndk-build APP_ABI=all -j4
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
 [Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
-[#3520]: https://github.com/google/ExoPlayer/issues/3520
 
 ## Notes ##
 
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 02b68b831d..92450f0381 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -39,7 +39,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersion
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 57e5481b55..0e13e82630 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
+import androidx.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.CryptoInfo;
@@ -120,8 +121,9 @@ protected VpxDecoderException createUnexpectedDecodeException(Throwable error) {
   }
 
   @Override
-  protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer,
-      boolean reset) {
+  @Nullable
+  protected VpxDecoderException decode(
+      VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer, boolean reset) {
     ByteBuffer inputData = inputBuffer.data;
     int inputSize = inputData.limit();
     CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
index 5a65fc56ff..db056d5110 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.util.LibraryLoader;
 
@@ -49,9 +50,8 @@ public static boolean isAvailable() {
     return LOADER.isAvailable();
   }
 
-  /**
-   * Returns the version of the underlying library if available, or null otherwise.
-   */
+  /** Returns the version of the underlying library if available, or null otherwise. */
+  @Nullable
   public static String getVersion() {
     return isAvailable() ? vpxGetVersion() : null;
   }
@@ -60,6 +60,7 @@ public static String getVersion() {
    * Returns the configuration string with which the underlying library was built if available, or
    * null otherwise.
    */
+  @Nullable
   public static String getBuildConfig() {
     return isAvailable() ? vpxGetBuildConfig() : null;
   }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index 22330e0a05..30d7b8e92c 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -60,8 +60,8 @@ public void release() {
    * Initializes the buffer.
    *
    * @param timeUs The presentation timestamp for the buffer, in microseconds.
-   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE} and {@link
-   *     VpxDecoder#OUTPUT_MODE_YUV}.
+   * @param mode The output mode. One of {@link VpxDecoder#OUTPUT_MODE_NONE}, {@link
+   *     VpxDecoder#OUTPUT_MODE_YUV} and {@link VpxDecoder#OUTPUT_MODE_SURFACE_YUV}.
    */
   public void init(long timeUs, int mode) {
     this.timeUs = timeUs;
@@ -110,6 +110,15 @@ public boolean initForYuvFrame(int width, int height, int yStride, int uvStride,
     return true;
   }
 
+  /**
+   * Configures the buffer for the given frame dimensions when passing actual frame data via {@link
+   * #decoderPrivate}. Called via JNI after decoding completes.
+   */
+  public void initForPrivateFrame(int width, int height) {
+    this.width = width;
+    this.height = height;
+  }
+
   private void initData(int size) {
     if (data == null || data.capacity() < size) {
       data = ByteBuffer.allocateDirect(size);
diff --git a/extensions/vp9/src/main/jni/Application.mk b/extensions/vp9/src/main/jni/Application.mk
index 59bf5f8f87..ed28f07acb 100644
--- a/extensions/vp9/src/main/jni/Application.mk
+++ b/extensions/vp9/src/main/jni/Application.mk
@@ -15,6 +15,6 @@
 #
 
 APP_OPTIM := release
-APP_STL := gnustl_static
+APP_STL := c++_static
 APP_CPPFLAGS := -frtti
-APP_PLATFORM := android-9
+APP_PLATFORM := android-16
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
index eab6862555..18f1dd5c69 100755
--- a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -20,46 +20,33 @@
 
 set -e
 
-if [ $# -ne 1 ]; then
-  echo "Usage: ${0} <path_to_android_ndk>"
+if [ $# -ne 0 ]; then
+  echo "Usage: ${0}"
   exit
 fi
 
-ndk="${1}"
-shift 1
-
 # configuration parameters common to all architectures
 common_params="--disable-examples --disable-docs --enable-realtime-only"
 common_params+=" --disable-vp8 --disable-vp9-encoder --disable-webm-io"
 common_params+=" --disable-libyuv --disable-runtime-cpu-detect"
+common_params+=" --enable-external-build"
 
 # configuration parameters for various architectures
 arch[0]="armeabi-v7a"
-config[0]="--target=armv7-android-gcc --sdk-path=$ndk --enable-neon"
-config[0]+=" --enable-neon-asm"
+config[0]="--target=armv7-android-gcc --enable-neon --enable-neon-asm"
 
-arch[1]="armeabi"
-config[1]="--target=armv7-android-gcc --sdk-path=$ndk --disable-neon"
-config[1]+=" --disable-neon-asm"
+arch[1]="x86"
+config[1]="--force-target=x86-android-gcc --disable-sse2"
+config[1]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
+config[1]+=" --disable-avx2 --enable-pic"
 
-arch[2]="mips"
-config[2]="--force-target=mips32-android-gcc --sdk-path=$ndk"
+arch[2]="arm64-v8a"
+config[2]="--force-target=armv8-android-gcc --enable-neon"
 
-arch[3]="x86"
-config[3]="--force-target=x86-android-gcc --sdk-path=$ndk --disable-sse2"
+arch[3]="x86_64"
+config[3]="--force-target=x86_64-android-gcc --disable-sse2"
 config[3]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
-config[3]+=" --disable-avx2 --enable-pic"
-
-arch[4]="arm64-v8a"
-config[4]="--force-target=armv8-android-gcc --sdk-path=$ndk --enable-neon"
-
-arch[5]="x86_64"
-config[5]="--force-target=x86_64-android-gcc --sdk-path=$ndk --disable-sse2"
-config[5]+=" --disable-sse3 --disable-ssse3 --disable-sse4_1 --disable-avx"
-config[5]+=" --disable-avx2 --enable-pic --disable-neon --disable-neon-asm"
-
-arch[6]="mips64"
-config[6]="--force-target=mips64-android-gcc --sdk-path=$ndk"
+config[3]+=" --disable-avx2 --enable-pic --disable-neon --disable-neon-asm"
 
 limit=$((${#arch[@]} - 1))
 
@@ -102,10 +89,7 @@ for i in $(seq 0 ${limit}); do
   # configure and make
   echo "build_android_configs: "
   echo "configure ${config[${i}]} ${common_params}"
-  ../../libvpx/configure ${config[${i}]} ${common_params} --extra-cflags=" \
-    -isystem $ndk/sysroot/usr/include/arm-linux-androideabi \
-    -isystem $ndk/sysroot/usr/include \
-    "
+  ../../libvpx/configure ${config[${i}]} ${common_params}
   rm -f libvpx_srcs.txt
   for f in ${allowed_files}; do
     # the build system supports multiple different configurations. avoid
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 82c023afbc..9fc8b09a18 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -60,6 +60,7 @@
 
 // JNI references for VpxOutputBuffer class.
 static jmethodID initForYuvFrame;
+static jmethodID initForPrivateFrame;
 static jfieldID dataField;
 static jfieldID outputModeField;
 static jfieldID decoderPrivateField;
@@ -481,6 +482,8 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
       "com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
                                      "(IIIII)Z");
+  initForPrivateFrame =
+      env->GetMethodID(outputBufferClass, "initForPrivateFrame", "(II)V");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
@@ -602,6 +605,10 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     }
     jfb->d_w = img->d_w;
     jfb->d_h = img->d_h;
+    env->CallVoidMethod(jOutputBuffer, initForPrivateFrame, img->d_w, img->d_h);
+    if (env->ExceptionCheck()) {
+      return -1;
+    }
     env->SetIntField(jOutputBuffer, decoderPrivateField,
                      id + kDecoderPrivateBase);
   }
diff --git a/extensions/workmanager/README.md b/extensions/workmanager/README.md
new file mode 100644
index 0000000000..bd2dbc71ad
--- /dev/null
+++ b/extensions/workmanager/README.md
@@ -0,0 +1,22 @@
+# ExoPlayer WorkManager extension
+
+This extension provides a Scheduler implementation which uses [WorkManager][].
+
+[WorkManager]: https://developer.android.com/topic/libraries/architecture/workmanager.html
+
+## Getting the extension
+
+The easiest way to use the extension is to add it as a gradle dependency:
+
+```gradle
+implementation 'com.google.android.exoplayer:extension-workmanager:2.X.X'
+```
+
+where `2.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
+
+Alternatively, you can clone the ExoPlayer repository and depend on the module
+locally. Instructions for doing this can be found in ExoPlayer's
+[top level README][].
+
+[top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
diff --git a/extensions/workmanager/build.gradle b/extensions/workmanager/build.gradle
new file mode 100644
index 0000000000..ea7564316f
--- /dev/null
+++ b/extensions/workmanager/build.gradle
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    testOptions.unitTests.includeAndroidResources = true
+}
+
+dependencies {
+    implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.work:work-runtime:2.1.0'
+}
+
+ext {
+    javadocTitle = 'WorkManager extension'
+}
+apply from: '../../javadoc_library.gradle'
+
+ext {
+    releaseArtifact = 'extension-workmanager'
+    releaseDescription = 'WorkManager extension for ExoPlayer.'
+}
+apply from: '../../publish.gradle'
diff --git a/extensions/workmanager/src/main/AndroidManifest.xml b/extensions/workmanager/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..1daf50bd00
--- /dev/null
+++ b/extensions/workmanager/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest package="com.google.android.exoplayer2.ext.workmanager"/>
diff --git a/extensions/workmanager/src/main/java/com/google/android/exoplayer2/ext/workmanager/WorkManagerScheduler.java b/extensions/workmanager/src/main/java/com/google/android/exoplayer2/ext/workmanager/WorkManagerScheduler.java
new file mode 100644
index 0000000000..01801c9897
--- /dev/null
+++ b/extensions/workmanager/src/main/java/com/google/android/exoplayer2/ext/workmanager/WorkManagerScheduler.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.workmanager;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.Intent;
+import androidx.work.Constraints;
+import androidx.work.Data;
+import androidx.work.ExistingWorkPolicy;
+import androidx.work.NetworkType;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkManager;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+import com.google.android.exoplayer2.scheduler.Requirements;
+import com.google.android.exoplayer2.scheduler.Scheduler;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+
+/** A {@link Scheduler} that uses {@link WorkManager}. */
+public final class WorkManagerScheduler implements Scheduler {
+
+  private static final boolean DEBUG = false;
+  private static final String TAG = "WorkManagerScheduler";
+  private static final String KEY_SERVICE_ACTION = "service_action";
+  private static final String KEY_SERVICE_PACKAGE = "service_package";
+  private static final String KEY_REQUIREMENTS = "requirements";
+
+  private final String workName;
+
+  /**
+   * @param workName A name for work scheduled by this instance. If the same name was used by a
+   *     previous instance, anything scheduled by the previous instance will be canceled by this
+   *     instance if {@link #schedule(Requirements, String, String)} or {@link #cancel()} are
+   *     called.
+   */
+  public WorkManagerScheduler(String workName) {
+    this.workName = workName;
+  }
+
+  @Override
+  public boolean schedule(Requirements requirements, String servicePackage, String serviceAction) {
+    Constraints constraints = buildConstraints(requirements);
+    Data inputData = buildInputData(requirements, servicePackage, serviceAction);
+    OneTimeWorkRequest workRequest = buildWorkRequest(constraints, inputData);
+    logd("Scheduling work: " + workName);
+    WorkManager.getInstance().enqueueUniqueWork(workName, ExistingWorkPolicy.REPLACE, workRequest);
+    return true;
+  }
+
+  @Override
+  public boolean cancel() {
+    logd("Canceling work: " + workName);
+    WorkManager.getInstance().cancelUniqueWork(workName);
+    return true;
+  }
+
+  private static Constraints buildConstraints(Requirements requirements) {
+    Constraints.Builder builder = new Constraints.Builder();
+
+    if (requirements.isUnmeteredNetworkRequired()) {
+      builder.setRequiredNetworkType(NetworkType.UNMETERED);
+    } else if (requirements.isNetworkRequired()) {
+      builder.setRequiredNetworkType(NetworkType.CONNECTED);
+    } else {
+      builder.setRequiredNetworkType(NetworkType.NOT_REQUIRED);
+    }
+
+    if (requirements.isChargingRequired()) {
+      builder.setRequiresCharging(true);
+    }
+
+    if (requirements.isIdleRequired() && Util.SDK_INT >= 23) {
+      setRequiresDeviceIdle(builder);
+    }
+
+    return builder.build();
+  }
+
+  @TargetApi(23)
+  private static void setRequiresDeviceIdle(Constraints.Builder builder) {
+    builder.setRequiresDeviceIdle(true);
+  }
+
+  private static Data buildInputData(
+      Requirements requirements, String servicePackage, String serviceAction) {
+    Data.Builder builder = new Data.Builder();
+
+    builder.putInt(KEY_REQUIREMENTS, requirements.getRequirements());
+    builder.putString(KEY_SERVICE_PACKAGE, servicePackage);
+    builder.putString(KEY_SERVICE_ACTION, serviceAction);
+
+    return builder.build();
+  }
+
+  private static OneTimeWorkRequest buildWorkRequest(Constraints constraints, Data inputData) {
+    OneTimeWorkRequest.Builder builder = new OneTimeWorkRequest.Builder(SchedulerWorker.class);
+
+    builder.setConstraints(constraints);
+    builder.setInputData(inputData);
+
+    return builder.build();
+  }
+
+  private static void logd(String message) {
+    if (DEBUG) {
+      Log.d(TAG, message);
+    }
+  }
+
+  /** A {@link Worker} that starts the target service if the requirements are met. */
+  // This class needs to be public so that WorkManager can instantiate it.
+  public static final class SchedulerWorker extends Worker {
+
+    private final WorkerParameters workerParams;
+    private final Context context;
+
+    public SchedulerWorker(Context context, WorkerParameters workerParams) {
+      super(context, workerParams);
+      this.workerParams = workerParams;
+      this.context = context;
+    }
+
+    @Override
+    public Result doWork() {
+      logd("SchedulerWorker is started");
+      Data inputData = workerParams.getInputData();
+      Assertions.checkNotNull(inputData, "Work started without input data.");
+      Requirements requirements = new Requirements(inputData.getInt(KEY_REQUIREMENTS, 0));
+      if (requirements.checkRequirements(context)) {
+        logd("Requirements are met");
+        String serviceAction = inputData.getString(KEY_SERVICE_ACTION);
+        String servicePackage = inputData.getString(KEY_SERVICE_PACKAGE);
+        Assertions.checkNotNull(serviceAction, "Service action missing.");
+        Assertions.checkNotNull(servicePackage, "Service package missing.");
+        Intent intent = new Intent(serviceAction).setPackage(servicePackage);
+        logd("Starting service action: " + serviceAction + " package: " + servicePackage);
+        Util.startForegroundService(context, intent);
+        return Result.success();
+      } else {
+        logd("Requirements are not met");
+        return Result.retry();
+      }
+    }
+  }
+}
diff --git a/gradle.properties b/gradle.properties
index 4b9bfa8fa2..31ff0ad6b6 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -3,3 +3,4 @@ android.useAndroidX=true
 android.enableJetifier=true
 android.enableUnitTestBinaryResources=true
 buildDir=buildout
+org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m
diff --git a/issues/player-accessed-on-wrong-thread.md b/issues/player-accessed-on-wrong-thread.md
new file mode 100644
index 0000000000..d4f1e74f45
--- /dev/null
+++ b/issues/player-accessed-on-wrong-thread.md
@@ -0,0 +1,5 @@
+---
+permalink: /issues/player-accessed-on-wrong-thread
+redirect_to:
+  - https://exoplayer.dev/troubleshooting.html#what-do-player-is-accessed-on-the-wrong-thread-warnings-mean
+---
diff --git a/javadoc_library.gradle b/javadoc_library.gradle
index a818ea390e..74fcc3dd6c 100644
--- a/javadoc_library.gradle
+++ b/javadoc_library.gradle
@@ -18,10 +18,13 @@ android.libraryVariants.all { variant ->
     if (!name.equals("release")) {
         return; // Skip non-release builds.
     }
+    def allSourceDirs = variant.sourceSets.inject ([]) {
+        acc, val -> acc << val.javaDirectories
+    }
     task("generateJavadoc", type: Javadoc) {
         description = "Generates Javadoc for the ${javadocTitle}."
         title = "ExoPlayer ${javadocTitle}"
-        source = variant.javaCompileProvider.get().source
+        source = allSourceDirs
         options {
             links "http://docs.oracle.com/javase/7/docs/api/"
             linksOffline "https://developer.android.com/reference",
diff --git a/library/core/build.gradle b/library/core/build.gradle
index 68ff8cc977..e633e12057 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -58,7 +58,7 @@ android {
 }
 
 dependencies {
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersion
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
index 07ba438182..8c11810506 100644
--- a/library/core/proguard-rules.txt
+++ b/library/core/proguard-rules.txt
@@ -46,18 +46,21 @@
 
 # Constructors accessed via reflection in DownloadHelper
 -dontnote com.google.android.exoplayer2.source.dash.DashMediaSource$Factory
--keepclassmembers class com.google.android.exoplayer2.source.dash.DashMediaSource$Factory {
+-keepclasseswithmembers class com.google.android.exoplayer2.source.dash.DashMediaSource$Factory {
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  ** setStreamKeys(java.util.List);
   com.google.android.exoplayer2.source.dash.DashMediaSource createMediaSource(android.net.Uri);
 }
 -dontnote com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory
--keepclassmembers class com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory {
+-keepclasseswithmembers class com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory {
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  ** setStreamKeys(java.util.List);
   com.google.android.exoplayer2.source.hls.HlsMediaSource createMediaSource(android.net.Uri);
 }
 -dontnote com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory
--keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory {
+-keepclasseswithmembers class com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory {
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
+  ** setStreamKeys(java.util.List);
   com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource createMediaSource(android.net.Uri);
 }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 04a90b38d8..0120451bc1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -146,8 +146,8 @@ private C() {}
    * {@link #ENCODING_INVALID}, {@link #ENCODING_PCM_8BIT}, {@link #ENCODING_PCM_16BIT}, {@link
    * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
    * #ENCODING_PCM_MU_LAW}, {@link #ENCODING_PCM_A_LAW}, {@link #ENCODING_AC3}, {@link
-   * #ENCODING_E_AC3}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or
-   * {@link #ENCODING_DOLBY_TRUEHD}.
+   * #ENCODING_E_AC3}, {@link #ENCODING_E_AC3_JOC}, {@link #ENCODING_AC4}, {@link #ENCODING_DTS},
+   * {@link #ENCODING_DTS_HD} or {@link #ENCODING_DOLBY_TRUEHD}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -163,6 +163,7 @@ private C() {}
     ENCODING_PCM_A_LAW,
     ENCODING_AC3,
     ENCODING_E_AC3,
+    ENCODING_E_AC3_JOC,
     ENCODING_AC4,
     ENCODING_DTS,
     ENCODING_DTS_HD,
@@ -210,6 +211,8 @@ private C() {}
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
   /** @see AudioFormat#ENCODING_E_AC3 */
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+  /** @see AudioFormat#ENCODING_E_AC3_JOC */
+  public static final int ENCODING_E_AC3_JOC = AudioFormat.ENCODING_E_AC3_JOC;
   /** @see AudioFormat#ENCODING_AC4 */
   public static final int ENCODING_AC4 = AudioFormat.ENCODING_AC4;
   /** @see AudioFormat#ENCODING_DTS */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 2a977f5bba..490d961396 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.audio.DefaultAudioSink;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -90,6 +91,7 @@
   @ExtensionRendererMode private int extensionRendererMode;
   private long allowedVideoJoiningTimeMs;
   private boolean playClearSamplesWithoutKeys;
+  private boolean enableDecoderFallback;
   private MediaCodecSelector mediaCodecSelector;
 
   /** @param context A {@link Context}. */
@@ -202,6 +204,19 @@ public DefaultRenderersFactory setPlayClearSamplesWithoutKeys(
     return this;
   }
 
+  /**
+   * Sets whether to enable fallback to lower-priority decoders if decoder initialization fails.
+   * This may result in using a decoder that is less efficient or slower than the primary decoder.
+   *
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setEnableDecoderFallback(boolean enableDecoderFallback) {
+    this.enableDecoderFallback = enableDecoderFallback;
+    return this;
+  }
+
   /**
    * Sets a {@link MediaCodecSelector} for use by {@link MediaCodec} based renderers.
    *
@@ -248,6 +263,7 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         eventHandler,
         videoRendererEventListener,
         allowedVideoJoiningTimeMs,
@@ -258,6 +274,7 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
+        enableDecoderFallback,
         buildAudioProcessors(),
         eventHandler,
         audioRendererEventListener,
@@ -282,6 +299,9 @@ public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoi
    * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
    *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
    *     the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
    * @param eventHandler A handler associated with the main thread's looper.
    * @param eventListener An event listener.
    * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
@@ -294,6 +314,7 @@ protected void buildVideoRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
       long allowedVideoJoiningTimeMs,
@@ -305,6 +326,7 @@ protected void buildVideoRenderers(
             allowedVideoJoiningTimeMs,
             drmSessionManager,
             playClearSamplesWithoutKeys,
+            enableDecoderFallback,
             eventHandler,
             eventListener,
             MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
@@ -356,6 +378,9 @@ protected void buildVideoRenderers(
    * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
    *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
    *     the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
    * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
    *     before output. May be empty.
    * @param eventHandler A handler to use when invoking event listeners and outputs.
@@ -368,6 +393,7 @@ protected void buildAudioRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       AudioProcessor[] audioProcessors,
       Handler eventHandler,
       AudioRendererEventListener eventListener,
@@ -378,10 +404,10 @@ protected void buildAudioRenderers(
             mediaCodecSelector,
             drmSessionManager,
             playClearSamplesWithoutKeys,
+            enableDecoderFallback,
             eventHandler,
             eventListener,
-            AudioCapabilities.getCapabilities(context),
-            audioProcessors));
+            new DefaultAudioSink(AudioCapabilities.getCapabilities(context), audioProcessors)));
 
     if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
       return;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 15deb8ea47..a10416fac8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -510,7 +510,7 @@ public long getBufferedPosition() {
 
   @Override
   public long getTotalBufferedDuration() {
-    return Math.max(0, C.usToMs(playbackInfo.totalBufferedDurationUs));
+    return C.usToMs(playbackInfo.totalBufferedDurationUs);
   }
 
   @Override
@@ -532,7 +532,9 @@ public int getCurrentAdIndexInAdGroup() {
   public long getContentPosition() {
     if (isPlayingAd()) {
       playbackInfo.timeline.getPeriodByUid(playbackInfo.periodId.periodUid, period);
-      return period.getPositionInWindowMs() + C.usToMs(playbackInfo.contentPositionUs);
+      return playbackInfo.contentPositionUs == C.TIME_UNSET
+          ? playbackInfo.timeline.getWindow(getCurrentWindowIndex(), window).getDefaultPositionMs()
+          : period.getPositionInWindowMs() + C.usToMs(playbackInfo.contentPositionUs);
     } else {
       return getCurrentPosition();
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 37774bccb5..65a6866a9f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -729,13 +729,20 @@ private long seekToPeriodPosition(
       newPlayingPeriodHolder = queue.advancePlayingPeriod();
     }
 
-    // Disable all the renderers if the period being played is changing, or if forced.
-    if (oldPlayingPeriodHolder != newPlayingPeriodHolder || forceDisableRenderers) {
+    // Disable all renderers if the period being played is changing, if the seek results in negative
+    // renderer timestamps, or if forced.
+    if (forceDisableRenderers
+        || oldPlayingPeriodHolder != newPlayingPeriodHolder
+        || (newPlayingPeriodHolder != null
+            && newPlayingPeriodHolder.toRendererTime(periodPositionUs) < 0)) {
       for (Renderer renderer : enabledRenderers) {
         disableRenderer(renderer);
       }
       enabledRenderers = new Renderer[0];
       oldPlayingPeriodHolder = null;
+      if (newPlayingPeriodHolder != null) {
+        newPlayingPeriodHolder.setRendererOffset(/* rendererPositionOffsetUs= */ 0);
+      }
     }
 
     // Update the holders.
@@ -1053,11 +1060,14 @@ private void maybeTriggerPendingMessages(long oldPeriodPositionUs, long newPerio
         && nextInfo.resolvedPeriodIndex == currentPeriodIndex
         && nextInfo.resolvedPeriodTimeUs > oldPeriodPositionUs
         && nextInfo.resolvedPeriodTimeUs <= newPeriodPositionUs) {
-      sendMessageToTarget(nextInfo.message);
-      if (nextInfo.message.getDeleteAfterDelivery() || nextInfo.message.isCanceled()) {
-        pendingMessages.remove(nextPendingMessageIndex);
-      } else {
-        nextPendingMessageIndex++;
+      try {
+        sendMessageToTarget(nextInfo.message);
+      } finally {
+        if (nextInfo.message.getDeleteAfterDelivery() || nextInfo.message.isCanceled()) {
+          pendingMessages.remove(nextPendingMessageIndex);
+        } else {
+          nextPendingMessageIndex++;
+        }
       }
       nextInfo =
           nextPendingMessageIndex < pendingMessages.size()
@@ -1294,8 +1304,11 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       Pair<Object, Long> defaultPosition =
           getPeriodPosition(
               timeline, timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
-      newContentPositionUs = defaultPosition.second;
-      newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, newContentPositionUs);
+      newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, defaultPosition.second);
+      if (!newPeriodId.isAd()) {
+        // Keep unset start position if we need to play an ad first.
+        newContentPositionUs = defaultPosition.second;
+      }
     } else if (timeline.getIndexOfPeriod(newPeriodId.periodUid) == C.INDEX_UNSET) {
       // The current period isn't in the new timeline. Attempt to resolve a subsequent period whose
       // window we can restart from.
@@ -1795,9 +1808,12 @@ private long getTotalBufferedDurationUs() {
 
   private long getTotalBufferedDurationUs(long bufferedPositionInLoadingPeriodUs) {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    return loadingPeriodHolder == null
-        ? 0
-        : bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    if (loadingPeriodHolder == null) {
+      return 0;
+    }
+    long totalBufferedDurationUs =
+        bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    return Math.max(0, totalBufferedDurationUs);
   }
 
   private void updateLoadControlTrackSelection(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 72760db31b..f420f20767 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.10.0";
+  public static final String VERSION = "2.10.4";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.0";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.4";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2010000;
+  public static final int VERSION_INT = 2010004;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 5950bc627f..a21afc4b51 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -67,8 +67,7 @@
    * Creates a new holder with information required to play it as part of a timeline.
    *
    * @param rendererCapabilities The renderer capabilities.
-   * @param rendererPositionOffsetUs The time offset of the start of the media period to provide to
-   *     renderers.
+   * @param rendererPositionOffsetUs The renderer time of the start of the period, in microseconds.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
    * @param mediaSource The media source that produced the media period.
@@ -82,7 +81,7 @@ public MediaPeriodHolder(
       MediaSource mediaSource,
       MediaPeriodInfo info) {
     this.rendererCapabilities = rendererCapabilities;
-    this.rendererPositionOffsetUs = rendererPositionOffsetUs - info.startPositionUs;
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs;
     this.trackSelector = trackSelector;
     this.mediaSource = mediaSource;
     this.uid = info.id.periodUid;
@@ -115,6 +114,15 @@ public long getRendererOffset() {
     return rendererPositionOffsetUs;
   }
 
+  /**
+   * Sets the renderer time of the start of the period, in microseconds.
+   *
+   * @param rendererPositionOffsetUs The new renderer position offset, in microseconds.
+   */
+  public void setRendererOffset(long rendererPositionOffsetUs) {
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs;
+  }
+
   /** Returns start position of period in renderer time. */
   public long getStartPositionRendererTime() {
     return info.startPositionUs + rendererPositionOffsetUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
index bc1ea7b1e1..2733df7ba6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
@@ -29,7 +29,8 @@
   public final long startPositionUs;
   /**
    * If this is an ad, the position to play in the next content media period. {@link C#TIME_UNSET}
-   * otherwise.
+   * if this is not an ad or the next content media period should be played from its default
+   * position.
    */
   public final long contentPositionUs;
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 249548340e..2927d03114 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -144,8 +144,10 @@ public MediaPeriod enqueueNextMediaPeriod(
       MediaPeriodInfo info) {
     long rendererPositionOffsetUs =
         loading == null
-            ? info.startPositionUs
-            : (loading.getRendererOffset() + loading.info.durationUs);
+            ? (info.id.isAd() && info.contentPositionUs != C.TIME_UNSET
+                ? info.contentPositionUs
+                : 0)
+            : (loading.getRendererOffset() + loading.info.durationUs - info.startPositionUs);
     MediaPeriodHolder newPeriodHolder =
         new MediaPeriodHolder(
             rendererCapabilities,
@@ -560,6 +562,7 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
       }
 
       long startPositionUs;
+      long contentPositionUs;
       int nextWindowIndex =
           timeline.getPeriod(nextPeriodIndex, period, /* setIds= */ true).windowIndex;
       Object nextPeriodUid = period.uid;
@@ -568,6 +571,7 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
         // We're starting to buffer a new window. When playback transitions to this window we'll
         // want it to be from its default start position, so project the default start position
         // forward by the duration of the buffer, and start buffering from this point.
+        contentPositionUs = C.TIME_UNSET;
         Pair<Object, Long> defaultPosition =
             timeline.getPeriodPosition(
                 window,
@@ -587,12 +591,13 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
           windowSequenceNumber = nextWindowSequenceNumber++;
         }
       } else {
+        // We're starting to buffer a new period within the same window.
         startPositionUs = 0;
+        contentPositionUs = 0;
       }
       MediaPeriodId periodId =
           resolveMediaPeriodIdForAds(nextPeriodUid, startPositionUs, windowSequenceNumber);
-      return getMediaPeriodInfo(
-          periodId, /* contentPositionUs= */ startPositionUs, startPositionUs);
+      return getMediaPeriodInfo(periodId, contentPositionUs, startPositionUs);
     }
 
     MediaPeriodId currentPeriodId = mediaPeriodInfo.id;
@@ -616,13 +621,11 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
                 mediaPeriodInfo.contentPositionUs,
                 currentPeriodId.windowSequenceNumber);
       } else {
-        // Play content from the ad group position. As a special case, if we're transitioning from a
-        // preroll ad group to content and there are no other ad groups, project the start position
-        // forward as if this were a transition to a new window. No attempt is made to handle
-        // midrolls in live streams, as it's unclear what content position should play after an ad
-        // (server-side dynamic ad insertion is more appropriate for this use case).
+        // Play content from the ad group position.
         long startPositionUs = mediaPeriodInfo.contentPositionUs;
-        if (period.getAdGroupCount() == 1 && period.getAdGroupTimeUs(0) == 0) {
+        if (startPositionUs == C.TIME_UNSET) {
+          // If we're transitioning from an ad group to content starting from its default position,
+          // project the start position forward as if this were a transition to a new window.
           Pair<Object, Long> defaultPosition =
               timeline.getPeriodPosition(
                   window,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index 0792bf0c7d..7107963c83 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -48,7 +48,8 @@
   /**
    * If {@link #periodId} refers to an ad, the position of the suspended content relative to the
    * start of the associated period in the {@link #timeline}, in microseconds. {@link C#TIME_UNSET}
-   * if {@link #periodId} does not refer to an ad.
+   * if {@link #periodId} does not refer to an ad or if the suspended content should be played from
+   * its default position.
    */
   public final long contentPositionUs;
   /** The current playback state. One of the {@link Player}.STATE_ constants. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 910404a875..f1b6b5bc90 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -1231,8 +1231,7 @@ private void verifyApplicationThread() {
       Log.w(
           TAG,
           "Player is accessed on the wrong thread. See "
-              + "https://exoplayer.dev/faqs.html#"
-              + "what-do-player-is-accessed-on-the-wrong-thread-warnings-mean",
+              + "https://exoplayer.dev/issues/player-accessed-on-wrong-thread",
           hasNotifiedFullWrongThreadWarning ? null : new IllegalStateException());
       hasNotifiedFullWrongThreadWarning = true;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
index 7f74216cc8..3400cf25b6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
@@ -59,7 +59,7 @@
     public final Timeline timeline;
 
     /**
-     * Window index in the {@code timeline} this event belongs to, or the prospective window index
+     * Window index in the {@link #timeline} this event belongs to, or the prospective window index
      * if the timeline is not yet known and empty.
      */
     public final int windowIndex;
@@ -76,7 +76,7 @@
     public final long eventPlaybackPositionMs;
 
     /**
-     * Position in the current timeline window ({@code timeline.getCurrentWindowIndex()} or the
+     * Position in the current timeline window ({@link Player#getCurrentWindowIndex()}) or the
      * currently playing ad at the time of the event, in milliseconds.
      */
     public final long currentPlaybackPositionMs;
@@ -91,15 +91,15 @@
      * @param realtimeMs Elapsed real-time as returned by {@code SystemClock.elapsedRealtime()} at
      *     the time of the event, in milliseconds.
      * @param timeline Timeline at the time of the event.
-     * @param windowIndex Window index in the {@code timeline} this event belongs to, or the
+     * @param windowIndex Window index in the {@link #timeline} this event belongs to, or the
      *     prospective window index if the timeline is not yet known and empty.
      * @param mediaPeriodId Media period identifier for the media period this event belongs to, or
      *     {@code null} if the event is not associated with a specific media period.
      * @param eventPlaybackPositionMs Position in the window or ad this event belongs to at the time
      *     of the event, in milliseconds.
-     * @param currentPlaybackPositionMs Position in the current timeline window ({@code
-     *     timeline.getCurrentWindowIndex()} or the currently playing ad at the time of the event,
-     *     in milliseconds.
+     * @param currentPlaybackPositionMs Position in the current timeline window ({@link
+     *     Player#getCurrentWindowIndex()}) or the currently playing ad at the time of the event, in
+     *     milliseconds.
      * @param totalBufferedDurationMs Total buffered duration from {@link
      *     #currentPlaybackPositionMs} at the time of the event, in milliseconds. This includes
      *     pre-buffered data for subsequent ads and windows.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index ffcd893e7b..be1b7d3d53 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -272,6 +272,7 @@ public long getSkippedOutputFrameCount() {
   private int preV21OutputBufferOffset;
   private int drainingAudioProcessorIndex;
   private boolean handledEndOfStream;
+  private boolean stoppedAudioTrack;
 
   private boolean playing;
   private int audioSessionId;
@@ -465,19 +466,15 @@ public void configure(
             processingEnabled,
             canApplyPlaybackParameters,
             availableAudioProcessors);
-    if (isInitialized()) {
-      if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
-        // We need a new AudioTrack before we can handle more input. We should first stop() the
-        // track and wait for audio to play out (tracked by [Internal: b/33161961]), but for now we
-        // discard the audio track immediately.
-        flush();
-      } else if (flushAudioProcessors) {
-        // We don't need a new AudioTrack but audio processors need to be drained and flushed.
-        this.pendingConfiguration = pendingConfiguration;
-        return;
-      }
+    // If we have a pending configuration already, we always drain audio processors as the preceding
+    // configuration may have required it (even if this one doesn't).
+    boolean drainAudioProcessors = flushAudioProcessors || this.pendingConfiguration != null;
+    if (isInitialized()
+        && (!pendingConfiguration.canReuseAudioTrack(configuration) || drainAudioProcessors)) {
+      this.pendingConfiguration = pendingConfiguration;
+    } else {
+      configuration = pendingConfiguration;
     }
-    configuration = pendingConfiguration;
   }
 
   private void setupAudioProcessors() {
@@ -504,7 +501,7 @@ private void flushAudioProcessors() {
     }
   }
 
-  private void initialize() throws InitializationException {
+  private void initialize(long presentationTimeUs) throws InitializationException {
     // If we're asynchronously releasing a previous audio track then we block until it has been
     // released. This guarantees that we cannot end up in a state where we have multiple audio
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
@@ -536,11 +533,7 @@ private void initialize() throws InitializationException {
       }
     }
 
-    playbackParameters =
-        configuration.canApplyPlaybackParameters
-            ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
-            : PlaybackParameters.DEFAULT;
-    setupAudioProcessors();
+    applyPlaybackParameters(playbackParameters, presentationTimeUs);
 
     audioTrackPositionTracker.setAudioTrack(
         audioTrack,
@@ -579,21 +572,27 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
     Assertions.checkArgument(inputBuffer == null || buffer == inputBuffer);
 
     if (pendingConfiguration != null) {
-      // We are waiting for audio processors to drain before applying a the new configuration.
       if (!drainAudioProcessorsToEndOfStream()) {
+        // There's still pending data in audio processors to write to the track.
         return false;
+      } else if (!pendingConfiguration.canReuseAudioTrack(configuration)) {
+        playPendingData();
+        if (hasPendingData()) {
+          // We're waiting for playout on the current audio track to finish.
+          return false;
+        }
+        flush();
+      } else {
+        // The current audio track can be reused for the new configuration.
+        configuration = pendingConfiguration;
+        pendingConfiguration = null;
       }
-      configuration = pendingConfiguration;
-      pendingConfiguration = null;
-      playbackParameters =
-          configuration.canApplyPlaybackParameters
-              ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
-              : PlaybackParameters.DEFAULT;
-      setupAudioProcessors();
+      // Re-apply playback parameters.
+      applyPlaybackParameters(playbackParameters, presentationTimeUs);
     }
 
     if (!isInitialized()) {
-      initialize();
+      initialize(presentationTimeUs);
       if (playing) {
         play();
       }
@@ -629,15 +628,7 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         }
         PlaybackParameters newPlaybackParameters = afterDrainPlaybackParameters;
         afterDrainPlaybackParameters = null;
-        newPlaybackParameters = audioProcessorChain.applyPlaybackParameters(newPlaybackParameters);
-        // Store the position and corresponding media time from which the parameters will apply.
-        playbackParametersCheckpoints.add(
-            new PlaybackParametersCheckpoint(
-                newPlaybackParameters,
-                Math.max(0, presentationTimeUs),
-                configuration.framesToDurationUs(getWrittenFrames())));
-        // Update the set of active audio processors to take into account the new parameters.
-        setupAudioProcessors();
+        applyPlaybackParameters(newPlaybackParameters, presentationTimeUs);
       }
 
       if (startMediaTimeState == START_NOT_SET) {
@@ -786,15 +777,8 @@ private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throw
 
   @Override
   public void playToEndOfStream() throws WriteException {
-    if (handledEndOfStream || !isInitialized()) {
-      return;
-    }
-
-    if (drainAudioProcessorsToEndOfStream()) {
-      // The audio processors have drained, so drain the underlying audio track.
-      audioTrackPositionTracker.handleEndOfStream(getWrittenFrames());
-      audioTrack.stop();
-      bytesUntilNextAvSync = 0;
+    if (!handledEndOfStream && isInitialized() && drainAudioProcessorsToEndOfStream()) {
+      playPendingData();
       handledEndOfStream = true;
     }
   }
@@ -858,8 +842,9 @@ public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParam
         // parameters apply.
         afterDrainPlaybackParameters = playbackParameters;
       } else {
-        // Update the playback parameters now.
-        this.playbackParameters = audioProcessorChain.applyPlaybackParameters(playbackParameters);
+        // Update the playback parameters now. They will be applied to the audio processors during
+        // initialization.
+        this.playbackParameters = playbackParameters;
       }
     }
     return this.playbackParameters;
@@ -976,6 +961,7 @@ public void flush() {
       flushAudioProcessors();
       inputBuffer = null;
       outputBuffer = null;
+      stoppedAudioTrack = false;
       handledEndOfStream = false;
       drainingAudioProcessorIndex = C.INDEX_UNSET;
       avSyncHeader = null;
@@ -1040,6 +1026,21 @@ public void run() {
     }.start();
   }
 
+  private void applyPlaybackParameters(
+      PlaybackParameters playbackParameters, long presentationTimeUs) {
+    PlaybackParameters newPlaybackParameters =
+        configuration.canApplyPlaybackParameters
+            ? audioProcessorChain.applyPlaybackParameters(playbackParameters)
+            : PlaybackParameters.DEFAULT;
+    // Store the position and corresponding media time from which the parameters will apply.
+    playbackParametersCheckpoints.add(
+        new PlaybackParametersCheckpoint(
+            newPlaybackParameters,
+            /* mediaTimeUs= */ Math.max(0, presentationTimeUs),
+            /* positionUs= */ configuration.framesToDurationUs(getWrittenFrames())));
+    setupAudioProcessors();
+  }
+
   private long applySpeedup(long positionUs) {
     @Nullable PlaybackParametersCheckpoint checkpoint = null;
     while (!playbackParametersCheckpoints.isEmpty()
@@ -1125,6 +1126,7 @@ private static int getMaximumEncodedRateBytesPerSecond(@C.Encoding int encoding)
       case C.ENCODING_AC3:
         return 640 * 1000 / 8;
       case C.ENCODING_E_AC3:
+      case C.ENCODING_E_AC3_JOC:
         return 6144 * 1000 / 8;
       case C.ENCODING_AC4:
         return 2688 * 1000 / 8;
@@ -1154,7 +1156,7 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
       return DtsUtil.parseDtsAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC3) {
       return Ac3Util.getAc3SyncframeAudioSampleCount();
-    } else if (encoding == C.ENCODING_E_AC3) {
+    } else if (encoding == C.ENCODING_E_AC3 || encoding == C.ENCODING_E_AC3_JOC) {
       return Ac3Util.parseEAc3SyncframeAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC4) {
       return Ac4Util.parseAc4SyncframeAudioSampleCount(buffer);
@@ -1177,11 +1179,10 @@ private static int writeNonBlockingV21(AudioTrack audioTrack, ByteBuffer buffer,
   @TargetApi(21)
   private int writeNonBlockingWithAvSyncV21(AudioTrack audioTrack, ByteBuffer buffer, int size,
       long presentationTimeUs) {
-    // TODO: Uncomment this when [Internal ref: b/33627517] is clarified or fixed.
-    // if (Util.SDK_INT >= 23) {
-    //   // The underlying platform AudioTrack writes AV sync headers directly.
-    //   return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
-    // }
+    if (Util.SDK_INT >= 26) {
+      // The underlying platform AudioTrack writes AV sync headers directly.
+      return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
+    }
     if (avSyncHeader == null) {
       avSyncHeader = ByteBuffer.allocate(16);
       avSyncHeader.order(ByteOrder.BIG_ENDIAN);
@@ -1223,6 +1224,15 @@ private static void setVolumeInternalV3(AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
+  private void playPendingData() {
+    if (!stoppedAudioTrack) {
+      stoppedAudioTrack = true;
+      audioTrackPositionTracker.handleEndOfStream(getWrittenFrames());
+      audioTrack.stop();
+      bytesUntilNextAvSync = 0;
+    }
+  }
+
   /** Stores playback parameters with the position and media time at which they apply. */
   private static final class PlaybackParametersCheckpoint {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 07769e7d85..07a1438519 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -245,12 +245,50 @@ public MediaCodecAudioRenderer(
       @Nullable Handler eventHandler,
       @Nullable AudioRendererEventListener eventListener,
       AudioSink audioSink) {
+    this(
+        context,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        /* enableDecoderFallback= */ false,
+        eventHandler,
+        eventListener,
+        audioSink);
+  }
+
+  /**
+   * @param context A context.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
+   *     content is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioSink The sink to which audio will be output.
+   */
+  public MediaCodecAudioRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      AudioSink audioSink) {
     super(
         C.TRACK_TYPE_AUDIO,
         mediaCodecSelector,
         drmSessionManager,
         playClearSamplesWithoutKeys,
-        /* enableDecoderFallback= */ false,
+        enableDecoderFallback,
         /* assumedMinimumCodecOperatingRate= */ 44100);
     this.context = context.getApplicationContext();
     this.audioSink = audioSink;
@@ -326,8 +364,17 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         return Collections.singletonList(passthroughDecoderInfo);
       }
     }
-    return mediaCodecSelector.getDecoderInfos(
-        format.sampleMimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
+    List<MediaCodecInfo> decoderInfos =
+        mediaCodecSelector.getDecoderInfos(
+            format.sampleMimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(format.sampleMimeType)) {
+      // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
+      List<MediaCodecInfo> eac3DecoderInfos =
+          mediaCodecSelector.getDecoderInfos(
+              MimeTypes.AUDIO_E_AC3, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
+      decoderInfos.addAll(eac3DecoderInfos);
+    }
+    return Collections.unmodifiableList(decoderInfos);
   }
 
   /**
@@ -341,7 +388,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @return Whether passthrough playback is supported.
    */
   protected boolean allowPassthrough(int channelCount, String mimeType) {
-    return audioSink.supportsOutput(channelCount, MimeTypes.getEncoding(mimeType));
+    return getPassthroughEncoding(channelCount, mimeType) != C.ENCODING_INVALID;
   }
 
   @Override
@@ -355,7 +402,7 @@ protected void configureCodec(
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
     codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);
     passthroughEnabled = codecInfo.passthrough;
-    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
+    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.codecMimeType;
     MediaFormat mediaFormat =
         getMediaFormat(format, codecMimeType, codecMaxInputSize, codecOperatingRate);
     codec.configure(mediaFormat, /* surface= */ null, crypto, /* flags= */ 0);
@@ -437,11 +484,14 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     @C.Encoding int encoding;
     MediaFormat format;
     if (passthroughMediaFormat != null) {
-      encoding = MimeTypes.getEncoding(passthroughMediaFormat.getString(MediaFormat.KEY_MIME));
       format = passthroughMediaFormat;
+      encoding =
+          getPassthroughEncoding(
+              format.getInteger(MediaFormat.KEY_CHANNEL_COUNT),
+              format.getString(MediaFormat.KEY_MIME));
     } else {
-      encoding = pcmEncoding;
       format = outputFormat;
+      encoding = pcmEncoding;
     }
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
@@ -463,6 +513,28 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     }
   }
 
+  /**
+   * Returns the {@link C.Encoding} constant to use for passthrough of the given format, or {@link
+   * C#ENCODING_INVALID} if passthrough is not possible.
+   */
+  @C.Encoding
+  protected int getPassthroughEncoding(int channelCount, String mimeType) {
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
+      if (audioSink.supportsOutput(channelCount, C.ENCODING_E_AC3_JOC)) {
+        return MimeTypes.getEncoding(MimeTypes.AUDIO_E_AC3_JOC);
+      }
+      // E-AC3 receivers can decode JOC streams, but in 2-D rather than 3-D, so try to fall back.
+      mimeType = MimeTypes.AUDIO_E_AC3;
+    }
+
+    @C.Encoding int encoding = MimeTypes.getEncoding(mimeType);
+    if (audioSink.supportsOutput(channelCount, encoding)) {
+      return encoding;
+    } else {
+      return C.ENCODING_INVALID;
+    }
+  }
+
   /**
    * Called when the audio session id becomes known. The default implementation is a no-op. One
    * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
@@ -632,7 +704,8 @@ protected boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException {
     if (codecNeedsEosBufferTimestampWorkaround
@@ -648,7 +721,7 @@ protected boolean processOutputBuffer(
       return true;
     }
 
-    if (shouldSkip) {
+    if (isDecodeOnlyBuffer) {
       codec.releaseOutputBuffer(bufferIndex, false);
       decoderCounters.skippedOutputBufferCount++;
       audioSink.handleDiscontinuity();
@@ -786,7 +859,7 @@ protected MediaFormat getMediaFormat(
     // Set codec configuration values.
     if (Util.SDK_INT >= 23) {
       mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 /* realtime priority */);
-      if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET) {
+      if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET && !deviceDoesntSupportOperatingRate()) {
         mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
       }
     }
@@ -809,6 +882,17 @@ private void updateCurrentPosition() {
     }
   }
 
+  /**
+   * Returns whether the device's decoders are known to not support setting the codec operating
+   * rate.
+   *
+   * <p>See <a href="https://github.com/google/ExoPlayer/issues/5821">GitHub issue #5821</a>.
+   */
+  private static boolean deviceDoesntSupportOperatingRate() {
+    return Util.SDK_INT == 23
+        && ("ZTE B2017G".equals(Util.MODEL) || "AXON 7 mini".equals(Util.MODEL));
+  }
+
   /**
    * Returns whether the decoder is known to output six audio channels when provided with input with
    * fewer than six channels.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java
index 0bf6baa4d0..6cd46bb705 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java
@@ -30,6 +30,7 @@
   private static final int MINIMUM_PITCH = 65;
   private static final int MAXIMUM_PITCH = 400;
   private static final int AMDF_FREQUENCY = 4000;
+  private static final int BYTES_PER_SAMPLE = 2;
 
   private final int inputSampleRateHz;
   private final int channelCount;
@@ -157,9 +158,9 @@ public void flush() {
     maxDiff = 0;
   }
 
-  /** Returns the number of output frames that can be read with {@link #getOutput(ShortBuffer)}. */
-  public int getFramesAvailable() {
-    return outputFrameCount;
+  /** Returns the size of output that can be read with {@link #getOutput(ShortBuffer)}, in bytes. */
+  public int getOutputSize() {
+    return outputFrameCount * channelCount * BYTES_PER_SAMPLE;
   }
 
   // Internal methods.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
index 0d938d33f4..bd32e5ee6f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
@@ -210,7 +210,7 @@ public void queueInput(ByteBuffer inputBuffer) {
       sonic.queueInput(shortBuffer);
       inputBuffer.position(inputBuffer.position() + inputSize);
     }
-    int outputSize = sonic.getFramesAvailable() * channelCount * 2;
+    int outputSize = sonic.getOutputSize();
     if (outputSize > 0) {
       if (buffer.capacity() < outputSize) {
         buffer = ByteBuffer.allocateDirect(outputSize).order(ByteOrder.nativeOrder());
@@ -243,7 +243,7 @@ public ByteBuffer getOutput() {
 
   @Override
   public boolean isEnded() {
-    return inputEnded && (sonic == null || sonic.getFramesAvailable() == 0);
+    return inputEnded && (sonic == null || sonic.getOutputSize() == 0);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
index f8204f6be3..b5650860e9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
@@ -301,5 +301,6 @@ private void releaseOutputBufferInternal(O outputBuffer) {
    * @param reset Whether the decoder must be reset before decoding.
    * @return A decoder exception if an error occurred, or null if decoding was successful.
    */
-  protected abstract @Nullable E decode(I inputBuffer, O outputBuffer, boolean reset);
+  @Nullable
+  protected abstract E decode(I inputBuffer, O outputBuffer, boolean reset);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 3820836e49..fb684f627f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -544,7 +544,7 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(
         ExoMediaDrm<? extends T> md,
-        byte[] sessionId,
+        @Nullable byte[] sessionId,
         int event,
         int extra,
         @Nullable byte[] data) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
index 49915f3af5..6bd8d9688f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
@@ -80,7 +80,7 @@
      */
     void onEvent(
         ExoMediaDrm<? extends T> mediaDrm,
-        byte[] sessionId,
+        @Nullable byte[] sessionId,
         int event,
         int extra,
         @Nullable byte[] data);
@@ -215,6 +215,7 @@ KeyRequest getKeyRequest(
       throws NotProvisionedException;
 
   /** @see MediaDrm#provideKeyResponse(byte[], byte[]) */
+  @Nullable
   byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index 615aa0e7b1..2cb7e66a2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -84,8 +84,6 @@ private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
     }
   }
 
-  // FIXME: incompatible types in argument.
-  @SuppressWarnings("nullness:argument.type.incompatible")
   @Override
   public void setOnEventListener(
       final ExoMediaDrm.OnEventListener<? super FrameworkMediaCrypto> listener) {
@@ -160,8 +158,7 @@ public KeyRequest getKeyRequest(
     return new KeyRequest(requestData, licenseServerUrl);
   }
 
-  // FIXME: incompatible types in return.
-  @SuppressWarnings("nullness:return.type.incompatible")
+  @Nullable
   @Override
   public byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
index 87bb992082..e454bd51c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
@@ -186,10 +186,6 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
       }
     }
 
-    // Calculate the bitrate in the same way Mp3Extractor calculates sample timestamps so that
-    // seeking to a given timestamp and playing from the start up to that timestamp give the same
-    // results for CBR streams. See also [internal: b/120390268].
-    bitrate = 8 * frameSize * sampleRate / samplesPerFrame;
     String mimeType = MIME_TYPE_BY_LAYER[3 - layer];
     int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
     header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
index d7a1c75302..0d5a168197 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
@@ -119,7 +119,7 @@ int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
    * Called to write sample data to the output.
    *
    * @param data A {@link ParsableByteArray} from which to read the sample data.
-   * @param length The number of bytes to read.
+   * @param length The number of bytes to read, starting from {@code data.getPosition()}.
    */
   void sampleData(ParsableByteArray data, int length);
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
index ec5ad88aeb..b10f2bf80b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
@@ -86,11 +86,12 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     if (audioFormat == AUDIO_FORMAT_MP3) {
       int sampleSize = data.bytesLeft();
       output.sampleData(data, sampleSize);
       output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+      return true;
     } else {
       int packetType = data.readUnsignedByte();
       if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
@@ -104,12 +105,15 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
             Collections.singletonList(audioSpecificConfig), null, 0, null);
         output.format(format);
         hasOutputFormat = true;
+        return false;
       } else if (audioFormat != AUDIO_FORMAT_AAC || packetType == AAC_PACKET_TYPE_AAC_RAW) {
         int sampleSize = data.bytesLeft();
         output.sampleData(data, sampleSize);
         output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+        return true;
+      } else {
+        return false;
       }
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 0a2c0c46f6..de6ed2710a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -74,6 +74,7 @@
 
   private ExtractorOutput extractorOutput;
   private @States int state;
+  private boolean outputFirstSample;
   private long mediaTagTimestampOffsetUs;
   private int bytesToNextTagHeader;
   private int tagType;
@@ -90,7 +91,6 @@ public FlvExtractor() {
     tagData = new ParsableByteArray();
     metadataReader = new ScriptTagPayloadReader();
     state = STATE_READING_FLV_HEADER;
-    mediaTagTimestampOffsetUs = C.TIME_UNSET;
   }
 
   @Override
@@ -132,7 +132,7 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek(long position, long timeUs) {
     state = STATE_READING_FLV_HEADER;
-    mediaTagTimestampOffsetUs = C.TIME_UNSET;
+    outputFirstSample = false;
     bytesToNextTagHeader = 0;
   }
 
@@ -253,14 +253,16 @@ private boolean readTagHeader(ExtractorInput input) throws IOException, Interrup
    */
   private boolean readTagData(ExtractorInput input) throws IOException, InterruptedException {
     boolean wasConsumed = true;
+    boolean wasSampleOutput = false;
+    long timestampUs = getCurrentTimestampUs();
     if (tagType == TAG_TYPE_AUDIO && audioReader != null) {
       ensureReadyForMediaOutput();
-      audioReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+      wasSampleOutput = audioReader.consume(prepareTagData(input), timestampUs);
     } else if (tagType == TAG_TYPE_VIDEO && videoReader != null) {
       ensureReadyForMediaOutput();
-      videoReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+      wasSampleOutput = videoReader.consume(prepareTagData(input), timestampUs);
     } else if (tagType == TAG_TYPE_SCRIPT_DATA && !outputSeekMap) {
-      metadataReader.consume(prepareTagData(input), tagTimestampUs);
+      wasSampleOutput = metadataReader.consume(prepareTagData(input), timestampUs);
       long durationUs = metadataReader.getDurationUs();
       if (durationUs != C.TIME_UNSET) {
         extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
@@ -270,6 +272,11 @@ private boolean readTagData(ExtractorInput input) throws IOException, Interrupte
       input.skipFully(tagDataSize);
       wasConsumed = false;
     }
+    if (!outputFirstSample && wasSampleOutput) {
+      outputFirstSample = true;
+      mediaTagTimestampOffsetUs =
+          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
+    }
     bytesToNextTagHeader = 4; // There's a 4 byte previous tag size before the next header.
     state = STATE_SKIPPING_TO_TAG_HEADER;
     return wasConsumed;
@@ -292,10 +299,11 @@ private void ensureReadyForMediaOutput() {
       extractorOutput.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
       outputSeekMap = true;
     }
-    if (mediaTagTimestampOffsetUs == C.TIME_UNSET) {
-      mediaTagTimestampOffsetUs =
-          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
-    }
   }
 
+  private long getCurrentTimestampUs() {
+    return outputFirstSample
+        ? (mediaTagTimestampOffsetUs + tagTimestampUs)
+        : (metadataReader.getDurationUs() == C.TIME_UNSET ? 0 : tagTimestampUs);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
index 2dec85ffcc..806cc9fad4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
 import java.util.Date;
@@ -44,7 +46,7 @@
   private long durationUs;
 
   public ScriptTagPayloadReader() {
-    super(null);
+    super(new DummyTrackOutput());
     durationUs = C.TIME_UNSET;
   }
 
@@ -63,7 +65,7 @@ protected boolean parseHeader(ParsableByteArray data) {
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int nameType = readAmfType(data);
     if (nameType != AMF_TYPE_STRING) {
       // Should never happen.
@@ -72,12 +74,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
     String name = readAmfString(data);
     if (!NAME_METADATA.equals(name)) {
       // We're only interested in metadata.
-      return;
+      return false;
     }
     int type = readAmfType(data);
     if (type != AMF_TYPE_ECMA_ARRAY) {
       // We're not interested in this metadata.
-      return;
+      return false;
     }
     // Set the duration to the value contained in the metadata, if present.
     Map<String, Object> metadata = readAmfEcmaArray(data);
@@ -87,6 +89,7 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
         durationUs = (long) (durationSeconds * C.MICROS_PER_SECOND);
       }
     }
+    return false;
   }
 
   private static int readAmfType(ParsableByteArray data) {
@@ -137,7 +140,10 @@ private static String readAmfString(ParsableByteArray data) {
     ArrayList<Object> list = new ArrayList<>(count);
     for (int i = 0; i < count; i++) {
       int type = readAmfType(data);
-      list.add(readAmfData(data, type));
+      Object value = readAmfData(data, type);
+      if (value != null) {
+        list.add(value);
+      }
     }
     return list;
   }
@@ -156,7 +162,10 @@ private static String readAmfString(ParsableByteArray data) {
       if (type == AMF_TYPE_END_MARKER) {
         break;
       }
-      array.put(key, readAmfData(data, type));
+      Object value = readAmfData(data, type);
+      if (value != null) {
+        array.put(key, value);
+      }
     }
     return array;
   }
@@ -173,7 +182,10 @@ private static String readAmfString(ParsableByteArray data) {
     for (int i = 0; i < count; i++) {
       String key = readAmfString(data);
       int type = readAmfType(data);
-      array.put(key, readAmfData(data, type));
+      Object value = readAmfData(data, type);
+      if (value != null) {
+        array.put(key, value);
+      }
     }
     return array;
   }
@@ -190,6 +202,7 @@ private static Date readAmfDate(ParsableByteArray data) {
     return date;
   }
 
+  @Nullable
   private static Object readAmfData(ParsableByteArray data, int type) {
     switch (type) {
       case AMF_TYPE_NUMBER:
@@ -207,8 +220,8 @@ private static Object readAmfData(ParsableByteArray data, int type) {
       case AMF_TYPE_DATE:
         return readAmfDate(data);
       default:
+        // We don't log a warning because there are types that we knowingly don't support.
         return null;
     }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java
index e8652d653f..48914b7c2c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/TagPayloadReader.java
@@ -58,12 +58,11 @@ protected TagPayloadReader(TrackOutput output) {
    *
    * @param data The payload data to consume.
    * @param timeUs The timestamp associated with the payload.
+   * @return Whether a sample was output.
    * @throws ParserException If an error occurs parsing the data.
    */
-  public final void consume(ParsableByteArray data, long timeUs) throws ParserException {
-    if (parseHeader(data)) {
-      parsePayload(data, timeUs);
-    }
+  public final boolean consume(ParsableByteArray data, long timeUs) throws ParserException {
+    return parseHeader(data) && parsePayload(data, timeUs);
   }
 
   /**
@@ -78,10 +77,11 @@ public final void consume(ParsableByteArray data, long timeUs) throws ParserExce
   /**
    * Parses tag payload.
    *
-   * @param data Buffer where tag payload is stored
-   * @param timeUs Time position of the frame
+   * @param data Buffer where tag payload is stored.
+   * @param timeUs Time position of the frame.
+   * @return Whether a sample was output.
    * @throws ParserException If an error occurs parsing the payload.
    */
-  protected abstract void parsePayload(ParsableByteArray data, long timeUs) throws ParserException;
-
+  protected abstract boolean parsePayload(ParsableByteArray data, long timeUs)
+      throws ParserException;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
index 92db91e20b..5ddaafb4a8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/VideoTagPayloadReader.java
@@ -47,6 +47,7 @@
 
   // State variables.
   private boolean hasOutputFormat;
+  private boolean hasOutputKeyframe;
   private int frameType;
 
   /**
@@ -60,7 +61,7 @@ public VideoTagPayloadReader(TrackOutput output) {
 
   @Override
   public void seek() {
-    // Do nothing.
+    hasOutputKeyframe = false;
   }
 
   @Override
@@ -77,7 +78,7 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   }
 
   @Override
-  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+  protected boolean parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
     int packetType = data.readUnsignedByte();
     int compositionTimeMs = data.readInt24();
 
@@ -94,7 +95,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
           avcConfig.initializationData, Format.NO_VALUE, avcConfig.pixelWidthAspectRatio, null);
       output.format(format);
       hasOutputFormat = true;
+      return false;
     } else if (packetType == AVC_PACKET_TYPE_AVC_NALU && hasOutputFormat) {
+      boolean isKeyframe = frameType == VIDEO_FRAME_KEYFRAME;
+      if (!hasOutputKeyframe && !isKeyframe) {
+        return false;
+      }
       // TODO: Deduplicate with Mp4Extractor.
       // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
       // they're only 1 or 2 bytes long.
@@ -123,8 +129,12 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
         output.sampleData(data, bytesToWrite);
         bytesWritten += bytesToWrite;
       }
-      output.sampleMetadata(timeUs, frameType == VIDEO_FRAME_KEYFRAME ? C.BUFFER_FLAG_KEY_FRAME : 0,
-          bytesWritten, 0, null);
+      output.sampleMetadata(
+          timeUs, isKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0, bytesWritten, 0, null);
+      hasOutputKeyframe = true;
+      return true;
+    } else {
+      return false;
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index c65ad0bc67..bc218e26ad 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -117,6 +117,7 @@
   private Seeker seeker;
   private long basisTimeUs;
   private long samplesRead;
+  private long firstSamplePosition;
   private int sampleBytesRemaining;
 
   public Mp3Extractor() {
@@ -214,6 +215,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
               /* selectionFlags= */ 0,
               /* language= */ null,
               (flags & FLAG_DISABLE_ID3_METADATA) != 0 ? null : metadata));
+      firstSamplePosition = input.getPosition();
+    } else if (firstSamplePosition != 0) {
+      long inputPosition = input.getPosition();
+      if (inputPosition < firstSamplePosition) {
+        // Skip past the seek frame.
+        input.skipFully((int) (firstSamplePosition - inputPosition));
+      }
     }
     return readSample(input);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 0185a6d8af..70873825e3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -60,7 +60,7 @@
    * The threshold number of samples to trim from the start/end of an audio track when applying an
    * edit below which gapless info can be used (rather than removing samples from the sample table).
    */
-  private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 3;
+  private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 4;
 
   /** The magic signature for an Opus Identification header, as defined in RFC-7845. */
   private static final byte[] opusMagic = Util.getUtf8Bytes("OpusHead");
@@ -1140,10 +1140,6 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
             language);
-      } else if (childAtomType == Atom.TYPE_alac) {
-        initializationData = new byte[childAtomSize];
-        parent.setPosition(childPosition);
-        parent.readBytes(initializationData, /* offset= */ 0, childAtomSize);
       } else if (childAtomType == Atom.TYPE_dOps) {
         // Build an Opus Identification Header (defined in RFC-7845) by concatenating the Opus Magic
         // Signature and the body of the dOps atom.
@@ -1152,7 +1148,7 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         System.arraycopy(opusMagic, 0, initializationData, 0, opusMagic.length);
         parent.setPosition(childPosition + Atom.HEADER_SIZE);
         parent.readBytes(initializationData, opusMagic.length, childAtomBodySize);
-      } else if (childAtomSize == Atom.TYPE_dfLa) {
+      } else if (childAtomSize == Atom.TYPE_dfLa || childAtomType == Atom.TYPE_alac) {
         int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
         initializationData = new byte[childAtomBodySize];
         parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 9d3635e8b3..7676926c4d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -123,6 +123,7 @@ public Track(int id, int type, long timescale, long movieTimescale, long duratio
    * @return The {@link TrackEncryptionBox} for the given sample description index. Maybe null if no
    *     such entry exists.
    */
+  @Nullable
   public TrackEncryptionBox getSampleDescriptionEncryptionBox(int sampleDescriptionIndex) {
     return sampleDescriptionEncryptionBoxes == null ? null
         : sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
index 5bd29c6e75..a35d211aa4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackEncryptionBox.java
@@ -52,7 +52,7 @@
    * If {@link #perSampleIvSize} is 0, holds the default initialization vector as defined in the
    * track encryption box or sample group description box. Null otherwise.
    */
-  public final byte[] defaultInitializationVector;
+  @Nullable public final byte[] defaultInitializationVector;
 
   /**
    * @param isEncrypted See {@link #isEncrypted}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
index c83662ee83..51ab94ba0e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
@@ -16,29 +16,32 @@
 package com.google.android.exoplayer2.extractor.ogg;
 
 import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 
 /** Seeks in an Ogg stream. */
 /* package */ final class DefaultOggSeeker implements OggSeeker {
 
-  @VisibleForTesting public static final int MATCH_RANGE = 72000;
-  @VisibleForTesting public static final int MATCH_BYTE_RANGE = 100000;
+  private static final int MATCH_RANGE = 72000;
+  private static final int MATCH_BYTE_RANGE = 100000;
   private static final int DEFAULT_OFFSET = 30000;
 
   private static final int STATE_SEEK_TO_END = 0;
   private static final int STATE_READ_LAST_PAGE = 1;
   private static final int STATE_SEEK = 2;
-  private static final int STATE_IDLE = 3;
+  private static final int STATE_SKIP = 3;
+  private static final int STATE_IDLE = 4;
 
   private final OggPageHeader pageHeader = new OggPageHeader();
-  private final long startPosition;
-  private final long endPosition;
+  private final long payloadStartPosition;
+  private final long payloadEndPosition;
   private final StreamReader streamReader;
 
   private int state;
@@ -54,26 +57,27 @@
   /**
    * Constructs an OggSeeker.
    *
-   * @param startPosition Start position of the payload (inclusive).
-   * @param endPosition End position of the payload (exclusive).
    * @param streamReader The {@link StreamReader} that owns this seeker.
+   * @param payloadStartPosition Start position of the payload (inclusive).
+   * @param payloadEndPosition End position of the payload (exclusive).
    * @param firstPayloadPageSize The total size of the first payload page, in bytes.
    * @param firstPayloadPageGranulePosition The granule position of the first payload page.
-   * @param firstPayloadPageIsLastPage Whether the first payload page is also the last page in the
-   *     ogg stream.
+   * @param firstPayloadPageIsLastPage Whether the first payload page is also the last page.
    */
   public DefaultOggSeeker(
-      long startPosition,
-      long endPosition,
       StreamReader streamReader,
+      long payloadStartPosition,
+      long payloadEndPosition,
       long firstPayloadPageSize,
       long firstPayloadPageGranulePosition,
       boolean firstPayloadPageIsLastPage) {
-    Assertions.checkArgument(startPosition >= 0 && endPosition > startPosition);
+    Assertions.checkArgument(
+        payloadStartPosition >= 0 && payloadEndPosition > payloadStartPosition);
     this.streamReader = streamReader;
-    this.startPosition = startPosition;
-    this.endPosition = endPosition;
-    if (firstPayloadPageSize == endPosition - startPosition || firstPayloadPageIsLastPage) {
+    this.payloadStartPosition = payloadStartPosition;
+    this.payloadEndPosition = payloadEndPosition;
+    if (firstPayloadPageSize == payloadEndPosition - payloadStartPosition
+        || firstPayloadPageIsLastPage) {
       totalGranules = firstPayloadPageGranulePosition;
       state = STATE_IDLE;
     } else {
@@ -90,7 +94,7 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
         positionBeforeSeekToEnd = input.getPosition();
         state = STATE_READ_LAST_PAGE;
         // Seek to the end just before the last page of stream to get the duration.
-        long lastPageSearchPosition = endPosition - OggPageHeader.MAX_PAGE_SIZE;
+        long lastPageSearchPosition = payloadEndPosition - OggPageHeader.MAX_PAGE_SIZE;
         if (lastPageSearchPosition > positionBeforeSeekToEnd) {
           return lastPageSearchPosition;
         }
@@ -100,145 +104,110 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
         state = STATE_IDLE;
         return positionBeforeSeekToEnd;
       case STATE_SEEK:
-        long currentGranule;
-        if (targetGranule == 0) {
-          currentGranule = 0;
-        } else {
-          long position = getNextSeekPosition(targetGranule, input);
-          if (position >= 0) {
-            return position;
-          }
-          currentGranule = skipToPageOfGranule(input, targetGranule, -(position + 2));
+        long position = getNextSeekPosition(input);
+        if (position != C.POSITION_UNSET) {
+          return position;
         }
+        state = STATE_SKIP;
+        // Fall through.
+      case STATE_SKIP:
+        skipToPageOfTargetGranule(input);
         state = STATE_IDLE;
-        return -(currentGranule + 2);
+        return -(startGranule + 2);
       default:
         // Never happens.
         throw new IllegalStateException();
     }
   }
 
-  @Override
-  public long startSeek(long timeUs) {
-    Assertions.checkArgument(state == STATE_IDLE || state == STATE_SEEK);
-    targetGranule = timeUs == 0 ? 0 : streamReader.convertTimeToGranule(timeUs);
-    state = STATE_SEEK;
-    resetSeeking();
-    return targetGranule;
-  }
-
   @Override
   public OggSeekMap createSeekMap() {
     return totalGranules != 0 ? new OggSeekMap() : null;
   }
 
-  @VisibleForTesting
-  public void resetSeeking() {
-    start = startPosition;
-    end = endPosition;
+  @Override
+  public void startSeek(long targetGranule) {
+    this.targetGranule = Util.constrainValue(targetGranule, 0, totalGranules - 1);
+    state = STATE_SEEK;
+    start = payloadStartPosition;
+    end = payloadEndPosition;
     startGranule = 0;
     endGranule = totalGranules;
   }
 
   /**
-   * Returns a position converging to the {@code targetGranule} to which the {@link ExtractorInput}
-   * has to seek and then be passed for another call until a negative number is returned. If a
-   * negative number is returned the input is at a position which is before the target page and at
-   * which it is sensible to just skip pages to the target granule and pre-roll instead of doing
-   * another seek request.
+   * Performs a single step of a seeking binary search, returning the byte position from which data
+   * should be provided for the next step, or {@link C#POSITION_UNSET} if the search has converged.
+   * If the search has converged then {@link #skipToPageOfTargetGranule(ExtractorInput)} should be
+   * called to skip to the target page.
    *
-   * @param targetGranule the target granule position to seek to.
-   * @param input the {@link ExtractorInput} to read from.
-   * @return the position to seek the {@link ExtractorInput} to for a next call or -(currentGranule
-   *     + 2) if it's close enough to skip to the target page.
-   * @throws IOException thrown if reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while reading from the input.
+   * @param input The {@link ExtractorInput} to read from.
+   * @return The byte position from which data should be provided for the next step, or {@link
+   *     C#POSITION_UNSET} if the search has converged.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
    */
-  @VisibleForTesting
-  public long getNextSeekPosition(long targetGranule, ExtractorInput input)
-      throws IOException, InterruptedException {
+  private long getNextSeekPosition(ExtractorInput input) throws IOException, InterruptedException {
     if (start == end) {
-      return -(startGranule + 2);
+      return C.POSITION_UNSET;
     }
 
-    long initialPosition = input.getPosition();
+    long currentPosition = input.getPosition();
     if (!skipToNextPage(input, end)) {
-      if (start == initialPosition) {
+      if (start == currentPosition) {
         throw new IOException("No ogg page can be found.");
       }
       return start;
     }
 
-    pageHeader.populate(input, false);
+    pageHeader.populate(input, /* quiet= */ false);
     input.resetPeekPosition();
 
     long granuleDistance = targetGranule - pageHeader.granulePosition;
     int pageSize = pageHeader.headerSize + pageHeader.bodySize;
-    if (granuleDistance < 0 || granuleDistance > MATCH_RANGE) {
-      if (granuleDistance < 0) {
-        end = initialPosition;
-        endGranule = pageHeader.granulePosition;
-      } else {
-        start = input.getPosition() + pageSize;
-        startGranule = pageHeader.granulePosition;
-        if (end - start + pageSize < MATCH_BYTE_RANGE) {
-          input.skipFully(pageSize);
-          return -(startGranule + 2);
-        }
-      }
-
-      if (end - start < MATCH_BYTE_RANGE) {
-        end = start;
-        return start;
-      }
-
-      long offset = pageSize * (granuleDistance <= 0 ? 2L : 1L);
-      long nextPosition = input.getPosition() - offset
-          + (granuleDistance * (end - start) / (endGranule - startGranule));
-
-      nextPosition = Math.max(nextPosition, start);
-      nextPosition = Math.min(nextPosition, end - 1);
-      return nextPosition;
+    if (0 <= granuleDistance && granuleDistance < MATCH_RANGE) {
+      return C.POSITION_UNSET;
     }
 
-    // position accepted (before target granule and within MATCH_RANGE)
-    input.skipFully(pageSize);
-    return -(pageHeader.granulePosition + 2);
-  }
-
-  private long getEstimatedPosition(long position, long granuleDistance, long offset) {
-    position += (granuleDistance * (endPosition - startPosition) / totalGranules) - offset;
-    if (position < startPosition) {
-      position = startPosition;
-    }
-    if (position >= endPosition) {
-      position = endPosition - 1;
+    if (granuleDistance < 0) {
+      end = currentPosition;
+      endGranule = pageHeader.granulePosition;
+    } else {
+      start = input.getPosition() + pageSize;
+      startGranule = pageHeader.granulePosition;
     }
-    return position;
-  }
 
-  private class OggSeekMap implements SeekMap {
-
-    @Override
-    public boolean isSeekable() {
-      return true;
+    if (end - start < MATCH_BYTE_RANGE) {
+      end = start;
+      return start;
     }
 
-    @Override
-    public SeekPoints getSeekPoints(long timeUs) {
-      if (timeUs == 0) {
-        return new SeekPoints(new SeekPoint(0, startPosition));
-      }
-      long granule = streamReader.convertTimeToGranule(timeUs);
-      long estimatedPosition = getEstimatedPosition(startPosition, granule, DEFAULT_OFFSET);
-      return new SeekPoints(new SeekPoint(timeUs, estimatedPosition));
-    }
+    long offset = pageSize * (granuleDistance <= 0 ? 2L : 1L);
+    long nextPosition =
+        input.getPosition()
+            - offset
+            + (granuleDistance * (end - start) / (endGranule - startGranule));
+    return Util.constrainValue(nextPosition, start, end - 1);
+  }
 
-    @Override
-    public long getDurationUs() {
-      return streamReader.convertGranuleToTime(totalGranules);
+  /**
+   * Skips forward to the start of the page containing the {@code targetGranule}.
+   *
+   * @param input The {@link ExtractorInput} to read from.
+   * @throws ParserException If populating the page header fails.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   */
+  private void skipToPageOfTargetGranule(ExtractorInput input)
+      throws IOException, InterruptedException {
+    pageHeader.populate(input, /* quiet= */ false);
+    while (pageHeader.granulePosition <= targetGranule) {
+      input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
+      start = input.getPosition();
+      startGranule = pageHeader.granulePosition;
+      pageHeader.populate(input, /* quiet= */ false);
     }
-
+    input.resetPeekPosition();
   }
 
   /**
@@ -251,7 +220,7 @@ public long getDurationUs() {
    */
   @VisibleForTesting
   void skipToNextPage(ExtractorInput input) throws IOException, InterruptedException {
-    if (!skipToNextPage(input, endPosition)) {
+    if (!skipToNextPage(input, payloadEndPosition)) {
       // Not found until eof.
       throw new EOFException();
     }
@@ -263,13 +232,12 @@ void skipToNextPage(ExtractorInput input) throws IOException, InterruptedExcepti
    * @param input The {@code ExtractorInput} to skip to the next page.
    * @param limit The limit up to which the search should take place.
    * @return Whether the next page was found.
-   * @throws IOException thrown if peeking/reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while peeking/reading from the input.
+   * @throws IOException If peeking/reading from the input fails.
+   * @throws InterruptedException If interrupted while peeking/reading from the input.
    */
-  @VisibleForTesting
-  boolean skipToNextPage(ExtractorInput input, long limit)
+  private boolean skipToNextPage(ExtractorInput input, long limit)
       throws IOException, InterruptedException {
-    limit = Math.min(limit + 3, endPosition);
+    limit = Math.min(limit + 3, payloadEndPosition);
     byte[] buffer = new byte[2048];
     int peekLength = buffer.length;
     while (true) {
@@ -310,39 +278,35 @@ boolean skipToNextPage(ExtractorInput input, long limit)
   long readGranuleOfLastPage(ExtractorInput input) throws IOException, InterruptedException {
     skipToNextPage(input);
     pageHeader.reset();
-    while ((pageHeader.type & 0x04) != 0x04 && input.getPosition() < endPosition) {
-      pageHeader.populate(input, false);
+    while ((pageHeader.type & 0x04) != 0x04 && input.getPosition() < payloadEndPosition) {
+      pageHeader.populate(input, /* quiet= */ false);
       input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
     }
     return pageHeader.granulePosition;
   }
 
-  /**
-   * Skips to the position of the start of the page containing the {@code targetGranule} and returns
-   * the granule of the page previous to the target page.
-   *
-   * @param input the {@link ExtractorInput} to read from.
-   * @param targetGranule the target granule.
-   * @param currentGranule the current granule or -1 if it's unknown.
-   * @return the granule of the prior page or the {@code currentGranule} if there isn't a prior
-   *     page.
-   * @throws ParserException thrown if populating the page header fails.
-   * @throws IOException thrown if reading from the input fails.
-   * @throws InterruptedException thrown if interrupted while reading from the input.
-   */
-  @VisibleForTesting
-  long skipToPageOfGranule(ExtractorInput input, long targetGranule, long currentGranule)
-      throws IOException, InterruptedException {
-    pageHeader.populate(input, false);
-    while (pageHeader.granulePosition < targetGranule) {
-      input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
-      // Store in a member field to be able to resume after IOExceptions.
-      currentGranule = pageHeader.granulePosition;
-      // Peek next header.
-      pageHeader.populate(input, false);
+  private final class OggSeekMap implements SeekMap {
+
+    @Override
+    public boolean isSeekable() {
+      return true;
     }
-    input.resetPeekPosition();
-    return currentGranule;
-  }
 
+    @Override
+    public SeekPoints getSeekPoints(long timeUs) {
+      long targetGranule = streamReader.convertTimeToGranule(timeUs);
+      long estimatedPosition =
+          payloadStartPosition
+              + (targetGranule * (payloadEndPosition - payloadStartPosition) / totalGranules)
+              - DEFAULT_OFFSET;
+      estimatedPosition =
+          Util.constrainValue(estimatedPosition, payloadStartPosition, payloadEndPosition - 1);
+      return new SeekPoints(new SeekPoint(timeUs, estimatedPosition));
+    }
+
+    @Override
+    public long getDurationUs() {
+      return streamReader.convertGranuleToTime(totalGranules);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
index 5eb0727908..4efd5c5e11 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
@@ -19,7 +19,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.SeekPoint;
-import com.google.android.exoplayer2.util.FlacStreamInfo;
+import com.google.android.exoplayer2.util.FlacStreamMetadata;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -38,7 +38,7 @@
 
   private static final int FRAME_HEADER_SAMPLE_NUMBER_OFFSET = 4;
 
-  private FlacStreamInfo streamInfo;
+  private FlacStreamMetadata streamMetadata;
   private FlacOggSeeker flacOggSeeker;
 
   public static boolean verifyBitstreamType(ParsableByteArray data) {
@@ -50,7 +50,7 @@ public static boolean verifyBitstreamType(ParsableByteArray data) {
   protected void reset(boolean headerData) {
     super.reset(headerData);
     if (headerData) {
-      streamInfo = null;
+      streamMetadata = null;
       flacOggSeeker = null;
     }
   }
@@ -71,14 +71,24 @@ protected long preparePayload(ParsableByteArray packet) {
   protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
       throws IOException, InterruptedException {
     byte[] data = packet.data;
-    if (streamInfo == null) {
-      streamInfo = new FlacStreamInfo(data, 17);
+    if (streamMetadata == null) {
+      streamMetadata = new FlacStreamMetadata(data, 17);
       byte[] metadata = Arrays.copyOfRange(data, 9, packet.limit());
       metadata[4] = (byte) 0x80; // Set the last metadata block flag, ignore the other blocks
       List<byte[]> initializationData = Collections.singletonList(metadata);
-      setupData.format = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_FLAC, null,
-          Format.NO_VALUE, streamInfo.bitRate(), streamInfo.channels, streamInfo.sampleRate,
-          initializationData, null, 0, null);
+      setupData.format =
+          Format.createAudioSampleFormat(
+              null,
+              MimeTypes.AUDIO_FLAC,
+              null,
+              Format.NO_VALUE,
+              streamMetadata.bitRate(),
+              streamMetadata.channels,
+              streamMetadata.sampleRate,
+              initializationData,
+              null,
+              0,
+              null);
     } else if ((data[0] & 0x7F) == SEEKTABLE_PACKET_TYPE) {
       flacOggSeeker = new FlacOggSeeker();
       flacOggSeeker.parseSeekTable(packet);
@@ -175,11 +185,9 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
     }
 
     @Override
-    public long startSeek(long timeUs) {
-      long granule = convertTimeToGranule(timeUs);
-      int index = Util.binarySearchFloor(seekPointGranules, granule, true, true);
+    public void startSeek(long targetGranule) {
+      int index = Util.binarySearchFloor(seekPointGranules, targetGranule, true, true);
       pendingSeekGranule = seekPointGranules[index];
-      return granule;
     }
 
     @Override
@@ -211,7 +219,7 @@ public SeekPoints getSeekPoints(long timeUs) {
 
     @Override
     public long getDurationUs() {
-      return streamInfo.durationUs();
+      return streamMetadata.durationUs();
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java
index bbf7e2fc6b..bb84909f67 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeader.java
@@ -38,7 +38,13 @@
 
   public int revision;
   public int type;
+  /**
+   * The absolute granule position of the page. This is the total number of samples from the start
+   * of the file up to the <em>end</em> of the page. Samples partially in the page that continue on
+   * the next page do not count.
+   */
   public long granulePosition;
+
   public long streamSerialNumber;
   public long pageSequenceNumber;
   public long pageChecksum;
@@ -72,10 +78,10 @@ public void reset() {
    * Peeks an Ogg page header and updates this {@link OggPageHeader}.
    *
    * @param input The {@link ExtractorInput} to read from.
-   * @param quiet If {@code true}, no exceptions are thrown but {@code false} is returned if
-   *     something goes wrong.
-   * @return {@code true} if the read was successful. The read fails if the end of the input is
-   *     encountered without reading data.
+   * @param quiet Whether to return {@code false} rather than throwing an exception if the header
+   *     cannot be populated.
+   * @return Whether the read was successful. The read fails if the end of the input is encountered
+   *     without reading data.
    * @throws IOException If reading data fails or the stream is invalid.
    * @throws InterruptedException If the thread is interrupted.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java
index aa88e5bf89..e4c3a163e6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java
@@ -33,16 +33,14 @@
   SeekMap createSeekMap();
 
   /**
-   * Initializes a seek operation.
+   * Starts a seek operation.
    *
-   * @param timeUs The seek position in microseconds.
-   * @return The granule position targeted by the seek.
+   * @param targetGranule The target granule position.
    */
-  long startSeek(long timeUs);
+  void startSeek(long targetGranule);
 
   /**
-   * Reads data from the {@link ExtractorInput} to build the {@link SeekMap} or to continue a
-   * progressive seek.
+   * Reads data from the {@link ExtractorInput} to build the {@link SeekMap} or to continue a seek.
    * <p/>
    * If more data is required or if the position of the input needs to be modified then a position
    * from which data should be provided is returned. Else a negative value is returned. If a seek
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
index e459ad1e58..d2671125e4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
@@ -91,7 +91,8 @@ final void seek(long position, long timeUs) {
       reset(!seekMapSet);
     } else {
       if (state != STATE_READ_HEADERS) {
-        targetGranule = oggSeeker.startSeek(timeUs);
+        targetGranule = convertTimeToGranule(timeUs);
+        oggSeeker.startSeek(targetGranule);
         state = STATE_READ_PAYLOAD;
       }
     }
@@ -147,9 +148,9 @@ private int readHeaders(ExtractorInput input) throws IOException, InterruptedExc
       boolean isLastPage = (firstPayloadPageHeader.type & 0x04) != 0; // Type 4 is end of stream.
       oggSeeker =
           new DefaultOggSeeker(
+              this,
               payloadStartPosition,
               input.getLength(),
-              this,
               firstPayloadPageHeader.headerSize + firstPayloadPageHeader.bodySize,
               firstPayloadPageHeader.granulePosition,
               isLastPage);
@@ -248,13 +249,13 @@ protected void onSeekEnd(long currentGranule) {
   private static final class UnseekableOggSeeker implements OggSeeker {
 
     @Override
-    public long read(ExtractorInput input) throws IOException, InterruptedException {
+    public long read(ExtractorInput input) {
       return -1;
     }
 
     @Override
-    public long startSeek(long timeUs) {
-      return 0;
+    public void startSeek(long targetGranule) {
+      // Do nothing.
     }
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
index 68d252e318..91097c9e5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
@@ -87,12 +87,14 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     if (!wavHeader.hasDataBounds()) {
       WavHeaderReader.skipToData(input, wavHeader);
       extractorOutput.seekMap(wavHeader);
+    } else if (input.getPosition() == 0) {
+      input.skipFully(wavHeader.getDataStartPosition());
     }
 
-    long dataLimit = wavHeader.getDataLimit();
-    Assertions.checkState(dataLimit != C.POSITION_UNSET);
+    long dataEndPosition = wavHeader.getDataEndPosition();
+    Assertions.checkState(dataEndPosition != C.POSITION_UNSET);
 
-    long bytesLeft = dataLimit - input.getPosition();
+    long bytesLeft = dataEndPosition - input.getPosition();
     if (bytesLeft <= 0) {
       return Extractor.RESULT_END_OF_INPUT;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
index c60117be60..6e3c5988a9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
@@ -33,23 +33,29 @@
   private final int blockAlignment;
   /** Bits per sample for the audio data. */
   private final int bitsPerSample;
-  /** The PCM encoding */
-  @C.PcmEncoding
-  private final int encoding;
-
-  /** Offset to the start of sample data. */
-  private long dataStartPosition;
-  /** Total size in bytes of the sample data. */
-  private long dataSize;
-
-  public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, int blockAlignment,
-      int bitsPerSample, @C.PcmEncoding int encoding) {
+  /** The PCM encoding. */
+  @C.PcmEncoding private final int encoding;
+
+  /** Position of the start of the sample data, in bytes. */
+  private int dataStartPosition;
+  /** Position of the end of the sample data (exclusive), in bytes. */
+  private long dataEndPosition;
+
+  public WavHeader(
+      int numChannels,
+      int sampleRateHz,
+      int averageBytesPerSecond,
+      int blockAlignment,
+      int bitsPerSample,
+      @C.PcmEncoding int encoding) {
     this.numChannels = numChannels;
     this.sampleRateHz = sampleRateHz;
     this.averageBytesPerSecond = averageBytesPerSecond;
     this.blockAlignment = blockAlignment;
     this.bitsPerSample = bitsPerSample;
     this.encoding = encoding;
+    dataStartPosition = C.POSITION_UNSET;
+    dataEndPosition = C.POSITION_UNSET;
   }
 
   // Data bounds.
@@ -57,22 +63,33 @@ public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, i
   /**
    * Sets the data start position and size in bytes of sample data in this WAV.
    *
-   * @param dataStartPosition The data start position in bytes.
-   * @param dataSize The data size in bytes.
+   * @param dataStartPosition The position of the start of the sample data, in bytes.
+   * @param dataEndPosition The position of the end of the sample data (exclusive), in bytes.
    */
-  public void setDataBounds(long dataStartPosition, long dataSize) {
+  public void setDataBounds(int dataStartPosition, long dataEndPosition) {
     this.dataStartPosition = dataStartPosition;
-    this.dataSize = dataSize;
+    this.dataEndPosition = dataEndPosition;
+  }
+
+  /**
+   * Returns the position of the start of the sample data, in bytes, or {@link C#POSITION_UNSET} if
+   * the data bounds have not been set.
+   */
+  public int getDataStartPosition() {
+    return dataStartPosition;
   }
 
-  /** Returns the data limit, or {@link C#POSITION_UNSET} if the data bounds have not been set. */
-  public long getDataLimit() {
-    return hasDataBounds() ? (dataStartPosition + dataSize) : C.POSITION_UNSET;
+  /**
+   * Returns the position of the end of the sample data (exclusive), in bytes, or {@link
+   * C#POSITION_UNSET} if the data bounds have not been set.
+   */
+  public long getDataEndPosition() {
+    return dataEndPosition;
   }
 
   /** Returns whether the data start position and size have been set. */
   public boolean hasDataBounds() {
-    return dataStartPosition != 0 && dataSize != 0;
+    return dataStartPosition != C.POSITION_UNSET;
   }
 
   // SeekMap implementation.
@@ -84,12 +101,13 @@ public boolean isSeekable() {
 
   @Override
   public long getDurationUs() {
-    long numFrames = dataSize / blockAlignment;
+    long numFrames = (dataEndPosition - dataStartPosition) / blockAlignment;
     return (numFrames * C.MICROS_PER_SECOND) / sampleRateHz;
   }
 
   @Override
   public SeekPoints getSeekPoints(long timeUs) {
+    long dataSize = dataEndPosition - dataStartPosition;
     long positionOffset = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
     // Constrain to nearest preceding frame offset.
     positionOffset = (positionOffset / blockAlignment) * blockAlignment;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
index c7b7a40ead..bbcb75aa2d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
@@ -22,7 +22,6 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /** Reads a {@code WavHeader} from an input stream; supports resuming from input failures. */
@@ -92,8 +91,8 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
     // If present, skip extensionSize, validBitsPerSample, channelMask, subFormatGuid, ...
     input.advancePeekPosition((int) chunkHeader.size - 16);
 
-    return new WavHeader(numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment,
-        bitsPerSample, encoding);
+    return new WavHeader(
+        numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment, bitsPerSample, encoding);
   }
 
   /**
@@ -122,11 +121,13 @@ public static void skipToData(ExtractorInput input, WavHeader wavHeader)
     ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
     // Skip all chunks until we hit the data header.
     ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
-    while (chunkHeader.id != Util.getIntegerCodeForString("data")) {
-      Log.w(TAG, "Ignoring unknown WAV chunk: " + chunkHeader.id);
+    while (chunkHeader.id != WavUtil.DATA_FOURCC) {
+      if (chunkHeader.id != WavUtil.RIFF_FOURCC && chunkHeader.id != WavUtil.FMT_FOURCC) {
+        Log.w(TAG, "Ignoring unknown WAV chunk: " + chunkHeader.id);
+      }
       long bytesToSkip = ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;
       // Override size of RIFF chunk, since it describes its size as the entire file.
-      if (chunkHeader.id == Util.getIntegerCodeForString("RIFF")) {
+      if (chunkHeader.id == WavUtil.RIFF_FOURCC) {
         bytesToSkip = ChunkHeader.SIZE_IN_BYTES + 4;
       }
       if (bytesToSkip > Integer.MAX_VALUE) {
@@ -138,7 +139,14 @@ public static void skipToData(ExtractorInput input, WavHeader wavHeader)
     // Skip past the "data" header.
     input.skipFully(ChunkHeader.SIZE_IN_BYTES);
 
-    wavHeader.setDataBounds(input.getPosition(), chunkHeader.size);
+    int dataStartPosition = (int) input.getPosition();
+    long dataEndPosition = dataStartPosition + chunkHeader.size;
+    long inputLength = input.getLength();
+    if (inputLength != C.LENGTH_UNSET && dataEndPosition > inputLength) {
+      Log.w(TAG, "Data exceeds input length: " + dataEndPosition + ", " + inputLength);
+      dataEndPosition = inputLength;
+    }
+    wavHeader.setDataBounds(dataStartPosition, dataEndPosition);
   }
 
   private WavHeaderReader() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 08ba94f257..7fc748485b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -54,8 +54,15 @@
   public final @Nullable String mimeType;
 
   /**
-   * The capabilities of the decoder, like the profiles/levels it supports, or {@code null} if this
-   * is a passthrough codec.
+   * The MIME type that the codec uses for media of type {@link #mimeType}, or {@code null} if this
+   * is a passthrough codec. Equal to {@link #mimeType} unless the codec is known to use a
+   * non-standard MIME type alias.
+   */
+  @Nullable public final String codecMimeType;
+
+  /**
+   * The capabilities of the decoder, like the profiles/levels it supports, or {@code null} if not
+   * known.
    */
   public final @Nullable CodecCapabilities capabilities;
 
@@ -98,6 +105,7 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
     return new MediaCodecInfo(
         name,
         /* mimeType= */ null,
+        /* codecMimeType= */ null,
         /* capabilities= */ null,
         /* passthrough= */ true,
         /* forceDisableAdaptive= */ false,
@@ -109,26 +117,10 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
    *
    * @param name The name of the {@link MediaCodec}.
    * @param mimeType A mime type supported by the {@link MediaCodec}.
-   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
-   * @return The created instance.
-   */
-  public static MediaCodecInfo newInstance(String name, String mimeType,
-      CodecCapabilities capabilities) {
-    return new MediaCodecInfo(
-        name,
-        mimeType,
-        capabilities,
-        /* passthrough= */ false,
-        /* forceDisableAdaptive= */ false,
-        /* forceSecure= */ false);
-  }
-
-  /**
-   * Creates an instance.
-   *
-   * @param name The name of the {@link MediaCodec}.
-   * @param mimeType A mime type supported by the {@link MediaCodec}.
-   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
+   * @param codecMimeType The MIME type that the codec uses for media of type {@code #mimeType}.
+   *     Equal to {@code mimeType} unless the codec is known to use a non-standard MIME type alias.
+   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type, or
+   *     {@code null} if not known.
    * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
    * @param forceSecure Whether {@link #secure} should be forced to {@code true}.
    * @return The created instance.
@@ -136,22 +128,31 @@ public static MediaCodecInfo newInstance(String name, String mimeType,
   public static MediaCodecInfo newInstance(
       String name,
       String mimeType,
-      CodecCapabilities capabilities,
+      String codecMimeType,
+      @Nullable CodecCapabilities capabilities,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     return new MediaCodecInfo(
-        name, mimeType, capabilities, /* passthrough= */ false, forceDisableAdaptive, forceSecure);
+        name,
+        mimeType,
+        codecMimeType,
+        capabilities,
+        /* passthrough= */ false,
+        forceDisableAdaptive,
+        forceSecure);
   }
 
   private MediaCodecInfo(
       String name,
       @Nullable String mimeType,
+      @Nullable String codecMimeType,
       @Nullable CodecCapabilities capabilities,
       boolean passthrough,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     this.name = Assertions.checkNotNull(name);
     this.mimeType = mimeType;
+    this.codecMimeType = codecMimeType;
     this.capabilities = capabilities;
     this.passthrough = passthrough;
     adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
@@ -518,9 +519,15 @@ private static boolean isSecureV21(CodecCapabilities capabilities) {
   @TargetApi(21)
   private static boolean areSizeAndRateSupportedV21(VideoCapabilities capabilities, int width,
       int height, double frameRate) {
-    return frameRate == Format.NO_VALUE || frameRate <= 0
-        ? capabilities.isSizeSupported(width, height)
-        : capabilities.areSizeAndRateSupported(width, height, frameRate);
+    if (frameRate == Format.NO_VALUE || frameRate <= 0) {
+      return capabilities.isSizeSupported(width, height);
+    } else {
+      // The signaled frame rate may be slightly higher than the actual frame rate, so we take the
+      // floor to avoid situations where a range check in areSizeAndRateSupported fails due to
+      // slightly exceeding the limits for a standard format (e.g., 1080p at 30 fps).
+      double floorFrameRate = Math.floor(frameRate);
+      return capabilities.areSizeAndRateSupported(width, height, floorFrameRate);
+    }
   }
 
   @TargetApi(23)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index f7855810d4..a8cf0f12e2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -53,7 +53,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -329,14 +328,16 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private int inputIndex;
   private int outputIndex;
   private ByteBuffer outputBuffer;
-  private boolean shouldSkipOutputBuffer;
+  private boolean isDecodeOnlyOutputBuffer;
+  private boolean isLastOutputBuffer;
   private boolean codecReconfigured;
   @ReconfigurationState private int codecReconfigurationState;
   @DrainState private int codecDrainState;
   @DrainAction private int codecDrainAction;
   private boolean codecReceivedBuffers;
   private boolean codecReceivedEos;
-
+  private long lastBufferInStreamPresentationTimeUs;
+  private long largestQueuedPresentationTimeUs;
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
@@ -454,15 +455,13 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
   protected abstract void configureCodec(
       MediaCodecInfo codecInfo,
       MediaCodec codec,
       Format format,
       MediaCrypto crypto,
-      float codecOperatingRate)
-      throws DecoderQueryException;
+      float codecOperatingRate);
 
   protected final void maybeInitCodec() throws ExoPlaybackException {
     if (codec != null || inputFormat == null) {
@@ -601,6 +600,8 @@ protected void releaseCodec() {
     waitingForKeys = false;
     codecHotswapDeadlineMs = C.TIME_UNSET;
     decodeOnlyPresentationTimestamps.clear();
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     try {
       if (codec != null) {
         decoderCounters.decoderReleaseCount++;
@@ -707,10 +708,13 @@ protected boolean flushOrReleaseCodec() {
     waitingForFirstSyncSample = true;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    shouldSkipOutputBuffer = false;
+    isDecodeOnlyOutputBuffer = false;
+    isLastOutputBuffer = false;
 
     waitingForKeys = false;
     decodeOnlyPresentationTimestamps.clear();
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     codecDrainState = DRAIN_STATE_NONE;
     codecDrainAction = DRAIN_ACTION_NONE;
     // Reconfiguration data sent shortly before the flush may not have been processed by the
@@ -742,11 +746,11 @@ private void maybeInitCodecWithFallback(
       try {
         List<MediaCodecInfo> allAvailableCodecInfos =
             getAvailableCodecInfos(mediaCryptoRequiresSecureDecoder);
+        availableCodecInfos = new ArrayDeque<>();
         if (enableDecoderFallback) {
-          availableCodecInfos = new ArrayDeque<>(allAvailableCodecInfos);
-        } else {
-          availableCodecInfos =
-              new ArrayDeque<>(Collections.singletonList(allAvailableCodecInfos.get(0)));
+          availableCodecInfos.addAll(allAvailableCodecInfos);
+        } else if (!allAvailableCodecInfos.isEmpty()) {
+          availableCodecInfos.add(allAvailableCodecInfos.get(0));
         }
         preferredDecoderInitializationException = null;
       } catch (DecoderQueryException e) {
@@ -884,7 +888,8 @@ private void initCodec(MediaCodecInfo codecInfo, MediaCrypto crypto) throws Exce
     codecDrainAction = DRAIN_ACTION_NONE;
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
-    shouldSkipOutputBuffer = false;
+    isDecodeOnlyOutputBuffer = false;
+    isLastOutputBuffer = false;
     waitingForFirstSyncSample = true;
 
     decoderCounters.decoderInitCount++;
@@ -1019,6 +1024,11 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       result = readSource(formatHolder, buffer, false);
     }
 
+    if (hasReadStreamToEnd()) {
+      // Notify output queue of the last buffer's timestamp.
+      lastBufferInStreamPresentationTimeUs = largestQueuedPresentationTimeUs;
+    }
+
     if (result == C.RESULT_NOTHING_READ) {
       return false;
     }
@@ -1091,6 +1101,8 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         formatQueue.add(presentationTimeUs, inputFormat);
         waitingForFirstSampleInFormat = false;
       }
+      largestQueuedPresentationTimeUs =
+          Math.max(largestQueuedPresentationTimeUs, presentationTimeUs);
 
       buffer.flip();
       onQueueInputBuffer(buffer);
@@ -1461,7 +1473,9 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         outputBuffer.position(outputBufferInfo.offset);
         outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);
       }
-      shouldSkipOutputBuffer = shouldSkipOutputBuffer(outputBufferInfo.presentationTimeUs);
+      isDecodeOnlyOutputBuffer = isDecodeOnlyBuffer(outputBufferInfo.presentationTimeUs);
+      isLastOutputBuffer =
+          lastBufferInStreamPresentationTimeUs == outputBufferInfo.presentationTimeUs;
       updateOutputFormatForTime(outputBufferInfo.presentationTimeUs);
     }
 
@@ -1477,7 +1491,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
                 outputIndex,
                 outputBufferInfo.flags,
                 outputBufferInfo.presentationTimeUs,
-                shouldSkipOutputBuffer,
+                isDecodeOnlyOutputBuffer,
+                isLastOutputBuffer,
                 outputFormat);
       } catch (IllegalStateException e) {
         processEndOfStream();
@@ -1497,7 +1512,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
               outputIndex,
               outputBufferInfo.flags,
               outputBufferInfo.presentationTimeUs,
-              shouldSkipOutputBuffer,
+              isDecodeOnlyOutputBuffer,
+              isLastOutputBuffer,
               outputFormat);
     }
 
@@ -1564,7 +1580,9 @@ private void processOutputBuffersChanged() {
    * @param bufferIndex The index of the output buffer.
    * @param bufferFlags The flags attached to the output buffer.
    * @param bufferPresentationTimeUs The presentation time of the output buffer in microseconds.
-   * @param shouldSkip Whether the buffer should be skipped (i.e. not rendered).
+   * @param isDecodeOnlyBuffer Whether the buffer was marked with {@link C#BUFFER_FLAG_DECODE_ONLY}
+   *     by the source.
+   * @param isLastBuffer Whether the buffer is the last sample of the current stream.
    * @param format The format associated with the buffer.
    * @return Whether the output buffer was fully processed (e.g. rendered or skipped).
    * @throws ExoPlaybackException If an error occurs processing the output buffer.
@@ -1577,7 +1595,8 @@ protected abstract boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException;
 
@@ -1657,7 +1676,7 @@ private void updateDrmSessionOrReinitializeCodecV23() throws ExoPlaybackExceptio
     codecDrainAction = DRAIN_ACTION_NONE;
   }
 
-  private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
+  private boolean isDecodeOnlyBuffer(long presentationTimeUs) {
     // We avoid using decodeOnlyPresentationTimestamps.remove(presentationTimeUs) because it would
     // box presentationTimeUs, creating a Long object that would need to be garbage collected.
     int size = decodeOnlyPresentationTimestamps.size();
@@ -1787,9 +1806,8 @@ private static boolean codecNeedsDiscardToSpsWorkaround(String name, Format form
    */
   private static boolean codecNeedsEosPropagationWorkaround(MediaCodecInfo codecInfo) {
     String name = codecInfo.name;
-    return (Util.SDK_INT <= 17
-            && ("OMX.rk.video_decoder.avc".equals(name)
-                || "OMX.allwinner.video.decoder.avc".equals(name)))
+    return (Util.SDK_INT <= 25 && "OMX.rk.video_decoder.avc".equals(name))
+        || (Util.SDK_INT <= 17 && "OMX.allwinner.video.decoder.avc".equals(name))
         || ("Amazon".equals(Util.MANUFACTURER) && "AFTS".equals(Util.MODEL) && codecInfo.secure);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 3211f7ea8e..a6391e4cc7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -161,24 +161,17 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boo
         Util.SDK_INT >= 21
             ? new MediaCodecListCompatV21(secure, tunneling)
             : new MediaCodecListCompatV16();
-    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
+    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
       mediaCodecList = new MediaCodecListCompatV16();
-      decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
+      decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
       if (!decoderInfos.isEmpty()) {
         Log.w(TAG, "MediaCodecList API didn't list secure decoder for: " + mimeType
             + ". Assuming: " + decoderInfos.get(0).name);
       }
     }
-    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
-      // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
-      CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure, key.tunneling);
-      ArrayList<MediaCodecInfo> eac3DecoderInfos =
-          getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);
-      decoderInfos.addAll(eac3DecoderInfos);
-    }
     applyWorkarounds(mimeType, decoderInfos);
     List<MediaCodecInfo> unmodifiableDecoderInfos = Collections.unmodifiableList(decoderInfos);
     decoderInfosCache.put(key, unmodifiableDecoderInfos);
@@ -249,13 +242,11 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
    *
    * @param key The codec key.
    * @param mediaCodecList The codec list.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
    * @return The codec information for usable codecs matching the specified key.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
   private static ArrayList<MediaCodecInfo> getDecoderInfosInternal(CodecKey key,
-      MediaCodecListCompat mediaCodecList, String requestedMimeType) throws DecoderQueryException {
+      MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
     try {
       ArrayList<MediaCodecInfo> decoderInfos = new ArrayList<>();
       String mimeType = key.mimeType;
@@ -265,28 +256,27 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       for (int i = 0; i < numberOfCodecs; i++) {
         android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
         String name = codecInfo.getName();
-        String supportedType =
-            getCodecSupportedType(codecInfo, name, secureDecodersExplicit, requestedMimeType);
-        if (supportedType == null) {
+        String codecMimeType = getCodecMimeType(codecInfo, name, secureDecodersExplicit, mimeType);
+        if (codecMimeType == null) {
           continue;
         }
         try {
-          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(codecMimeType);
           boolean tunnelingSupported =
               mediaCodecList.isFeatureSupported(
-                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);
           boolean tunnelingRequired =
               mediaCodecList.isFeatureRequired(
-                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);
           if ((!key.tunneling && tunnelingRequired) || (key.tunneling && !tunnelingSupported)) {
             continue;
           }
           boolean secureSupported =
               mediaCodecList.isFeatureSupported(
-                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);
           boolean secureRequired =
               mediaCodecList.isFeatureRequired(
-                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);
           if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {
             continue;
           }
@@ -295,12 +285,18 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
               || (!secureDecodersExplicit && !key.secure)) {
             decoderInfos.add(
                 MediaCodecInfo.newInstance(
-                    name, mimeType, capabilities, forceDisableAdaptive, /* forceSecure= */ false));
+                    name,
+                    mimeType,
+                    codecMimeType,
+                    capabilities,
+                    forceDisableAdaptive,
+                    /* forceSecure= */ false));
           } else if (!secureDecodersExplicit && secureSupported) {
             decoderInfos.add(
                 MediaCodecInfo.newInstance(
                     name + ".secure",
                     mimeType,
+                    codecMimeType,
                     capabilities,
                     forceDisableAdaptive,
                     /* forceSecure= */ true));
@@ -314,7 +310,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
           } else {
             // Rethrow error querying primary codec capabilities, or secondary codec
             // capabilities if API level is greater than 23.
-            Log.e(TAG, "Failed to query codec " + name + " (" + supportedType + ")");
+            Log.e(TAG, "Failed to query codec " + name + " (" + codecMimeType + ")");
             throw e;
           }
         }
@@ -328,42 +324,49 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
   }
 
   /**
-   * Returns the codec's supported type for decoding {@code requestedMimeType} on the current
-   * device, or {@code null} if the codec can't be used.
+   * Returns the codec's supported MIME type for media of type {@code mimeType}, or {@code null} if
+   * the codec can't be used.
    *
    * @param info The codec information.
    * @param name The name of the codec
    * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
-   * @return The codec's supported type for decoding {@code requestedMimeType}, or {@code null} if
-   *     the codec can't be used.
+   * @param mimeType The MIME type.
+   * @return The codec's supported MIME type for media of type {@code mimeType}, or {@code null} if
+   *     the codec can't be used. If non-null, the returned type will be equal to {@code mimeType}
+   *     except in cases where the codec is known to use a non-standard MIME type alias.
    */
   @Nullable
-  private static String getCodecSupportedType(
+  private static String getCodecMimeType(
       android.media.MediaCodecInfo info,
       String name,
       boolean secureDecodersExplicit,
-      String requestedMimeType) {
-    if (isCodecUsableDecoder(info, name, secureDecodersExplicit, requestedMimeType)) {
-      if (requestedMimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
-        // Handle decoders that declare support for DV via MIME types that aren't
-        // video/dolby-vision.
-        if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
-          return "video/hevcdv";
-        } else if ("OMX.RTK.video.decoder".equals(name)
-            || "OMX.realtek.video.decoder.tunneled".equals(name)) {
-          return "video/dv_hevc";
-        }
+      String mimeType) {
+    if (!isCodecUsableDecoder(info, name, secureDecodersExplicit, mimeType)) {
+      return null;
+    }
+
+    String[] supportedTypes = info.getSupportedTypes();
+    for (String supportedType : supportedTypes) {
+      if (supportedType.equalsIgnoreCase(mimeType)) {
+        return supportedType;
       }
+    }
 
-      String[] supportedTypes = info.getSupportedTypes();
-      for (String supportedType : supportedTypes) {
-        if (supportedType.equalsIgnoreCase(requestedMimeType)) {
-          return supportedType;
-        }
+    if (mimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
+      // Handle decoders that declare support for DV via MIME types that aren't
+      // video/dolby-vision.
+      if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
+        return "video/hevcdv";
+      } else if ("OMX.RTK.video.decoder".equals(name)
+          || "OMX.realtek.video.decoder.tunneled".equals(name)) {
+        return "video/dv_hevc";
       }
+    } else if (mimeType.equals(MimeTypes.AUDIO_ALAC) && "OMX.lge.alac.decoder".equals(name)) {
+      return "audio/x-lg-alac";
+    } else if (mimeType.equals(MimeTypes.AUDIO_FLAC) && "OMX.lge.flac.decoder".equals(name)) {
+      return "audio/x-lg-flac";
     }
+
     return null;
   }
 
@@ -373,12 +376,14 @@ private static String getCodecSupportedType(
    * @param info The codec information.
    * @param name The name of the codec
    * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
+   * @param mimeType The MIME type.
    * @return Whether the specified codec is usable for decoding on the current device.
    */
-  private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, String name,
-      boolean secureDecodersExplicit, String requestedMimeType) {
+  private static boolean isCodecUsableDecoder(
+      android.media.MediaCodecInfo info,
+      String name,
+      boolean secureDecodersExplicit,
+      String mimeType) {
     if (info.isEncoder() || (!secureDecodersExplicit && name.endsWith(".secure"))) {
       return false;
     }
@@ -386,11 +391,11 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     // Work around broken audio decoders.
     if (Util.SDK_INT < 21
         && ("CIPAACDecoder".equals(name)
-            || "CIPMP3Decoder".equals(name)
-            || "CIPVorbisDecoder".equals(name)
-            || "CIPAMRNBDecoder".equals(name)
-            || "AACDecoder".equals(name)
-            || "MP3Decoder".equals(name))) {
+        || "CIPMP3Decoder".equals(name)
+        || "CIPVorbisDecoder".equals(name)
+        || "CIPAMRNBDecoder".equals(name)
+        || "AACDecoder".equals(name)
+        || "MP3Decoder".equals(name))) {
       return false;
     }
 
@@ -399,7 +404,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     if (Util.SDK_INT < 18
         && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
         && ("a70".equals(Util.DEVICE)
-            || ("Xiaomi".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith("HM")))) {
+        || ("Xiaomi".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith("HM")))) {
       return false;
     }
 
@@ -408,17 +413,17 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     if (Util.SDK_INT == 16
         && "OMX.qcom.audio.decoder.mp3".equals(name)
         && ("dlxu".equals(Util.DEVICE) // HTC Butterfly
-            || "protou".equals(Util.DEVICE) // HTC Desire X
-            || "ville".equals(Util.DEVICE) // HTC One S
-            || "villeplus".equals(Util.DEVICE)
-            || "villec2".equals(Util.DEVICE)
-            || Util.DEVICE.startsWith("gee") // LGE Optimus G
-            || "C6602".equals(Util.DEVICE) // Sony Xperia Z
-            || "C6603".equals(Util.DEVICE)
-            || "C6606".equals(Util.DEVICE)
-            || "C6616".equals(Util.DEVICE)
-            || "L36h".equals(Util.DEVICE)
-            || "SO-02E".equals(Util.DEVICE))) {
+        || "protou".equals(Util.DEVICE) // HTC Desire X
+        || "ville".equals(Util.DEVICE) // HTC One S
+        || "villeplus".equals(Util.DEVICE)
+        || "villec2".equals(Util.DEVICE)
+        || Util.DEVICE.startsWith("gee") // LGE Optimus G
+        || "C6602".equals(Util.DEVICE) // Sony Xperia Z
+        || "C6603".equals(Util.DEVICE)
+        || "C6606".equals(Util.DEVICE)
+        || "C6616".equals(Util.DEVICE)
+        || "L36h".equals(Util.DEVICE)
+        || "SO-02E".equals(Util.DEVICE))) {
       return false;
     }
 
@@ -426,9 +431,9 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     if (Util.SDK_INT == 16
         && "OMX.qcom.audio.decoder.aac".equals(name)
         && ("C1504".equals(Util.DEVICE) // Sony Xperia E
-            || "C1505".equals(Util.DEVICE)
-            || "C1604".equals(Util.DEVICE) // Sony Xperia E dual
-            || "C1605".equals(Util.DEVICE))) {
+        || "C1505".equals(Util.DEVICE)
+        || "C1604".equals(Util.DEVICE) // Sony Xperia E dual
+        || "C1605".equals(Util.DEVICE))) {
       return false;
     }
 
@@ -437,13 +442,13 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
         && ("OMX.SEC.aac.dec".equals(name) || "OMX.Exynos.AAC.Decoder".equals(name))
         && "samsung".equals(Util.MANUFACTURER)
         && (Util.DEVICE.startsWith("zeroflte") // Galaxy S6
-            || Util.DEVICE.startsWith("zerolte") // Galaxy S6 Edge
-            || Util.DEVICE.startsWith("zenlte") // Galaxy S6 Edge+
-            || "SC-05G".equals(Util.DEVICE) // Galaxy S6
-            || "marinelteatt".equals(Util.DEVICE) // Galaxy S6 Active
-            || "404SC".equals(Util.DEVICE) // Galaxy S6 Edge
-            || "SC-04G".equals(Util.DEVICE)
-            || "SCV31".equals(Util.DEVICE))) {
+        || Util.DEVICE.startsWith("zerolte") // Galaxy S6 Edge
+        || Util.DEVICE.startsWith("zenlte") // Galaxy S6 Edge+
+        || "SC-05G".equals(Util.DEVICE) // Galaxy S6
+        || "marinelteatt".equals(Util.DEVICE) // Galaxy S6 Active
+        || "404SC".equals(Util.DEVICE) // Galaxy S6 Edge
+        || "SC-04G".equals(Util.DEVICE)
+        || "SCV31".equals(Util.DEVICE))) {
       return false;
     }
 
@@ -453,10 +458,10 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
         && "OMX.SEC.vp8.dec".equals(name)
         && "samsung".equals(Util.MANUFACTURER)
         && (Util.DEVICE.startsWith("d2")
-            || Util.DEVICE.startsWith("serrano")
-            || Util.DEVICE.startsWith("jflte")
-            || Util.DEVICE.startsWith("santos")
-            || Util.DEVICE.startsWith("t0"))) {
+        || Util.DEVICE.startsWith("serrano")
+        || Util.DEVICE.startsWith("jflte")
+        || Util.DEVICE.startsWith("santos")
+        || Util.DEVICE.startsWith("t0"))) {
       return false;
     }
 
@@ -467,7 +472,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     }
 
     // MTK E-AC3 decoder doesn't support decoding JOC streams in 2-D. See [Internal: b/69400041].
-    if (MimeTypes.AUDIO_E_AC3_JOC.equals(requestedMimeType)
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)
         && "OMX.MTK.AUDIO.DECODER.DSPAC3".equals(name)) {
       return false;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/flac/PictureFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/flac/PictureFrame.java
new file mode 100644
index 0000000000..ce134614ad
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/flac/PictureFrame.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.flac;
+
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.metadata.Metadata;
+import java.util.Arrays;
+
+/** A picture parsed from a FLAC file. */
+public final class PictureFrame implements Metadata.Entry {
+
+  /** The type of the picture. */
+  public final int pictureType;
+  /** The mime type of the picture. */
+  public final String mimeType;
+  /** A description of the picture. */
+  public final String description;
+  /** The width of the picture in pixels. */
+  public final int width;
+  /** The height of the picture in pixels. */
+  public final int height;
+  /** The color depth of the picture in bits-per-pixel. */
+  public final int depth;
+  /** For indexed-color pictures (e.g. GIF), the number of colors used. 0 otherwise. */
+  public final int colors;
+  /** The encoded picture data. */
+  public final byte[] pictureData;
+
+  public PictureFrame(
+      int pictureType,
+      String mimeType,
+      String description,
+      int width,
+      int height,
+      int depth,
+      int colors,
+      byte[] pictureData) {
+    this.pictureType = pictureType;
+    this.mimeType = mimeType;
+    this.description = description;
+    this.width = width;
+    this.height = height;
+    this.depth = depth;
+    this.colors = colors;
+    this.pictureData = pictureData;
+  }
+
+  /* package */ PictureFrame(Parcel in) {
+    this.pictureType = in.readInt();
+    this.mimeType = castNonNull(in.readString());
+    this.description = castNonNull(in.readString());
+    this.width = in.readInt();
+    this.height = in.readInt();
+    this.depth = in.readInt();
+    this.colors = in.readInt();
+    this.pictureData = castNonNull(in.createByteArray());
+  }
+
+  @Override
+  public String toString() {
+    return "Picture: mimeType=" + mimeType + ", description=" + description;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    PictureFrame other = (PictureFrame) obj;
+    return (pictureType == other.pictureType)
+        && mimeType.equals(other.mimeType)
+        && description.equals(other.description)
+        && (width == other.width)
+        && (height == other.height)
+        && (depth == other.depth)
+        && (colors == other.colors)
+        && Arrays.equals(pictureData, other.pictureData);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + pictureType;
+    result = 31 * result + mimeType.hashCode();
+    result = 31 * result + description.hashCode();
+    result = 31 * result + width;
+    result = 31 * result + height;
+    result = 31 * result + depth;
+    result = 31 * result + colors;
+    result = 31 * result + Arrays.hashCode(pictureData);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(pictureType);
+    dest.writeString(mimeType);
+    dest.writeString(description);
+    dest.writeInt(width);
+    dest.writeInt(height);
+    dest.writeInt(depth);
+    dest.writeInt(colors);
+    dest.writeByteArray(pictureData);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<PictureFrame> CREATOR =
+      new Parcelable.Creator<PictureFrame>() {
+
+        @Override
+        public PictureFrame createFromParcel(Parcel in) {
+          return new PictureFrame(in);
+        }
+
+        @Override
+        public PictureFrame[] newArray(int size) {
+          return new PictureFrame[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/flac/VorbisComment.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/flac/VorbisComment.java
new file mode 100644
index 0000000000..9f44cdf393
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/flac/VorbisComment.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.flac;
+
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.metadata.Metadata;
+
+/** A vorbis comment. */
+public final class VorbisComment implements Metadata.Entry {
+
+  /** The key. */
+  public final String key;
+
+  /** The value. */
+  public final String value;
+
+  /**
+   * @param key The key.
+   * @param value The value.
+   */
+  public VorbisComment(String key, String value) {
+    this.key = key;
+    this.value = value;
+  }
+
+  /* package */ VorbisComment(Parcel in) {
+    this.key = castNonNull(in.readString());
+    this.value = castNonNull(in.readString());
+  }
+
+  @Override
+  public String toString() {
+    return "VC: " + key + "=" + value;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    VorbisComment other = (VorbisComment) obj;
+    return key.equals(other.key) && value.equals(other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(key);
+    dest.writeString(value);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<VorbisComment> CREATOR =
+      new Parcelable.Creator<VorbisComment>() {
+
+        @Override
+        public VorbisComment createFromParcel(Parcel in) {
+          return new VorbisComment(in);
+        }
+
+        @Override
+        public VorbisComment[] newArray(int size) {
+          return new VorbisComment[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
index d04cd3a999..3d873926bb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
@@ -31,7 +31,7 @@
 
   private static final String TAG = "IcyDecoder";
 
-  private static final Pattern METADATA_ELEMENT = Pattern.compile("(.+?)='(.+?)';");
+  private static final Pattern METADATA_ELEMENT = Pattern.compile("(.+?)='(.*?)';", Pattern.DOTALL);
   private static final String STREAM_KEY_NAME = "streamtitle";
   private static final String STREAM_KEY_URL = "streamurl";
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
index 06f308d1e9..ef4bd00f20 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
@@ -233,6 +233,19 @@ public void setDownloadingStatesToQueued() throws DatabaseIOException {
     }
   }
 
+  @Override
+  public void setStatesToRemoving() throws DatabaseIOException {
+    ensureInitialized();
+    try {
+      ContentValues values = new ContentValues();
+      values.put(COLUMN_STATE, Download.STATE_REMOVING);
+      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
+      writableDatabase.update(tableName, values, /* whereClause= */ null, /* whereArgs= */ null);
+    } catch (SQLException e) {
+      throw new DatabaseIOException(e);
+    }
+  }
+
   @Override
   public void setStopReason(int stopReason) throws DatabaseIOException {
     ensureInitialized();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
index 8a15c82c89..821696aae7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
@@ -20,7 +20,6 @@
 import android.os.HandlerThread;
 import android.os.Message;
 import androidx.annotation.Nullable;
-import android.util.Pair;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -32,6 +31,7 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSource.Factory;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -106,30 +107,13 @@
     void onPrepareError(DownloadHelper helper, IOException e);
   }
 
-  @Nullable private static final Constructor<?> DASH_FACTORY_CONSTRUCTOR;
-  @Nullable private static final Constructor<?> HLS_FACTORY_CONSTRUCTOR;
-  @Nullable private static final Constructor<?> SS_FACTORY_CONSTRUCTOR;
-  @Nullable private static final Method DASH_FACTORY_CREATE_METHOD;
-  @Nullable private static final Method HLS_FACTORY_CREATE_METHOD;
-  @Nullable private static final Method SS_FACTORY_CREATE_METHOD;
-
-  static {
-    Pair<@NullableType Constructor<?>, @NullableType Method> dashFactoryMethods =
-        getMediaSourceFactoryMethods(
-            "com.google.android.exoplayer2.source.dash.DashMediaSource$Factory");
-    DASH_FACTORY_CONSTRUCTOR = dashFactoryMethods.first;
-    DASH_FACTORY_CREATE_METHOD = dashFactoryMethods.second;
-    Pair<@NullableType Constructor<?>, @NullableType Method> hlsFactoryMethods =
-        getMediaSourceFactoryMethods(
-            "com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory");
-    HLS_FACTORY_CONSTRUCTOR = hlsFactoryMethods.first;
-    HLS_FACTORY_CREATE_METHOD = hlsFactoryMethods.second;
-    Pair<@NullableType Constructor<?>, @NullableType Method> ssFactoryMethods =
-        getMediaSourceFactoryMethods(
-            "com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory");
-    SS_FACTORY_CONSTRUCTOR = ssFactoryMethods.first;
-    SS_FACTORY_CREATE_METHOD = ssFactoryMethods.second;
-  }
+  private static final MediaSourceFactory DASH_FACTORY =
+      getMediaSourceFactory("com.google.android.exoplayer2.source.dash.DashMediaSource$Factory");
+  private static final MediaSourceFactory SS_FACTORY =
+      getMediaSourceFactory(
+          "com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource$Factory");
+  private static final MediaSourceFactory HLS_FACTORY =
+      getMediaSourceFactory("com.google.android.exoplayer2.source.hls.HlsMediaSource$Factory");
 
   /**
    * Creates a {@link DownloadHelper} for progressive streams.
@@ -202,8 +186,7 @@ public static DownloadHelper forDash(
         DownloadRequest.TYPE_DASH,
         uri,
         /* cacheKey= */ null,
-        createMediaSource(
-            uri, dataSourceFactory, DASH_FACTORY_CONSTRUCTOR, DASH_FACTORY_CREATE_METHOD),
+        DASH_FACTORY.createMediaSource(uri, dataSourceFactory, /* streamKeys= */ null),
         trackSelectorParameters,
         Util.getRendererCapabilities(renderersFactory, drmSessionManager));
   }
@@ -252,8 +235,7 @@ public static DownloadHelper forHls(
         DownloadRequest.TYPE_HLS,
         uri,
         /* cacheKey= */ null,
-        createMediaSource(
-            uri, dataSourceFactory, HLS_FACTORY_CONSTRUCTOR, HLS_FACTORY_CREATE_METHOD),
+        HLS_FACTORY.createMediaSource(uri, dataSourceFactory, /* streamKeys= */ null),
         trackSelectorParameters,
         Util.getRendererCapabilities(renderersFactory, drmSessionManager));
   }
@@ -302,11 +284,42 @@ public static DownloadHelper forSmoothStreaming(
         DownloadRequest.TYPE_SS,
         uri,
         /* cacheKey= */ null,
-        createMediaSource(uri, dataSourceFactory, SS_FACTORY_CONSTRUCTOR, SS_FACTORY_CREATE_METHOD),
+        SS_FACTORY.createMediaSource(uri, dataSourceFactory, /* streamKeys= */ null),
         trackSelectorParameters,
         Util.getRendererCapabilities(renderersFactory, drmSessionManager));
   }
 
+  /**
+   * Utility method to create a MediaSource which only contains the tracks defined in {@code
+   * downloadRequest}.
+   *
+   * @param downloadRequest A {@link DownloadRequest}.
+   * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+   * @return A MediaSource which only contains the tracks defined in {@code downloadRequest}.
+   */
+  public static MediaSource createMediaSource(
+      DownloadRequest downloadRequest, DataSource.Factory dataSourceFactory) {
+    MediaSourceFactory factory;
+    switch (downloadRequest.type) {
+      case DownloadRequest.TYPE_DASH:
+        factory = DASH_FACTORY;
+        break;
+      case DownloadRequest.TYPE_SS:
+        factory = SS_FACTORY;
+        break;
+      case DownloadRequest.TYPE_HLS:
+        factory = HLS_FACTORY;
+        break;
+      case DownloadRequest.TYPE_PROGRESSIVE:
+        return new ProgressiveMediaSource.Factory(dataSourceFactory)
+            .createMediaSource(downloadRequest.uri);
+      default:
+        throw new IllegalStateException("Unsupported type: " + downloadRequest.type);
+    }
+    return factory.createMediaSource(
+        downloadRequest.uri, dataSourceFactory, downloadRequest.streamKeys);
+  }
+
   private final String downloadType;
   private final Uri uri;
   @Nullable private final String cacheKey;
@@ -739,35 +752,54 @@ private TrackSelectorResult runTrackSelection(int periodIndex) {
     }
   }
 
-  private static Pair<@NullableType Constructor<?>, @NullableType Method>
-      getMediaSourceFactoryMethods(String className) {
+  private static MediaSourceFactory getMediaSourceFactory(String className) {
     Constructor<?> constructor = null;
+    Method setStreamKeysMethod = null;
     Method createMethod = null;
     try {
       // LINT.IfChange
       Class<?> factoryClazz = Class.forName(className);
-      constructor = factoryClazz.getConstructor(DataSource.Factory.class);
+      constructor = factoryClazz.getConstructor(Factory.class);
+      setStreamKeysMethod = factoryClazz.getMethod("setStreamKeys", List.class);
       createMethod = factoryClazz.getMethod("createMediaSource", Uri.class);
       // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
-    } catch (Exception e) {
+    } catch (ClassNotFoundException e) {
       // Expected if the app was built without the respective module.
+    } catch (NoSuchMethodException | SecurityException e) {
+      // Something is wrong with the library or the proguard configuration.
+      throw new IllegalStateException(e);
     }
-    return Pair.create(constructor, createMethod);
+    return new MediaSourceFactory(constructor, setStreamKeysMethod, createMethod);
   }
 
-  private static MediaSource createMediaSource(
-      Uri uri,
-      DataSource.Factory dataSourceFactory,
-      @Nullable Constructor<?> factoryConstructor,
-      @Nullable Method createMediaSourceMethod) {
-    if (factoryConstructor == null || createMediaSourceMethod == null) {
-      throw new IllegalStateException("Module missing to create media source.");
+  private static final class MediaSourceFactory {
+    @Nullable private final Constructor<?> constructor;
+    @Nullable private final Method setStreamKeysMethod;
+    @Nullable private final Method createMethod;
+
+    public MediaSourceFactory(
+        @Nullable Constructor<?> constructor,
+        @Nullable Method setStreamKeysMethod,
+        @Nullable Method createMethod) {
+      this.constructor = constructor;
+      this.setStreamKeysMethod = setStreamKeysMethod;
+      this.createMethod = createMethod;
     }
-    try {
-      Object factory = factoryConstructor.newInstance(dataSourceFactory);
-      return (MediaSource) Assertions.checkNotNull(createMediaSourceMethod.invoke(factory, uri));
-    } catch (Exception e) {
-      throw new IllegalStateException("Failed to instantiate media source.", e);
+
+    private MediaSource createMediaSource(
+        Uri uri, Factory dataSourceFactory, @Nullable List<StreamKey> streamKeys) {
+      if (constructor == null || setStreamKeysMethod == null || createMethod == null) {
+        throw new IllegalStateException("Module missing to create media source.");
+      }
+      try {
+        Object factory = constructor.newInstance(dataSourceFactory);
+        if (streamKeys != null) {
+          setStreamKeysMethod.invoke(factory, streamKeys);
+        }
+        return (MediaSource) Assertions.checkNotNull(createMethod.invoke(factory, uri));
+      } catch (Exception e) {
+        throw new IllegalStateException("Failed to instantiate media source.", e);
+      }
     }
   }
 
@@ -785,10 +817,10 @@ private static MediaSource createMediaSource(
     private final MediaSource mediaSource;
     private final DownloadHelper downloadHelper;
     private final Allocator allocator;
+    private final ArrayList<MediaPeriod> pendingMediaPeriods;
+    private final Handler downloadHelperHandler;
     private final HandlerThread mediaSourceThread;
     private final Handler mediaSourceHandler;
-    private final Handler downloadHelperHandler;
-    private final ArrayList<MediaPeriod> pendingMediaPeriods;
 
     @Nullable public Object manifest;
     public @MonotonicNonNull Timeline timeline;
@@ -800,6 +832,7 @@ public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
       this.mediaSource = mediaSource;
       this.downloadHelper = downloadHelper;
       allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
+      pendingMediaPeriods = new ArrayList<>();
       @SuppressWarnings("methodref.receiver.bound.invalid")
       Handler downloadThreadHandler = Util.createHandler(this::handleDownloadHelperCallbackMessage);
       this.downloadHelperHandler = downloadThreadHandler;
@@ -807,7 +840,6 @@ public MediaPreparer(MediaSource mediaSource, DownloadHelper downloadHelper) {
       mediaSourceThread.start();
       mediaSourceHandler = Util.createHandler(mediaSourceThread.getLooper(), /* callback= */ this);
       mediaSourceHandler.sendEmptyMessage(MESSAGE_PREPARE_SOURCE);
-      pendingMediaPeriods = new ArrayList<>();
     }
 
     public void release() {
@@ -919,6 +951,7 @@ private boolean handleDownloadHelperCallbackMessage(Message msg) {
           downloadHelper.onMediaPrepared();
           return true;
         case DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED:
+          release();
           downloadHelper.onMediaPreparationFailed((IOException) Util.castNonNull(msg.obj));
           return true;
         default:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
index 3bf03dd3e8..ec5ff81d97 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
@@ -133,10 +133,11 @@ default void onRequirementsStateChanged(
   private static final int MSG_SET_MIN_RETRY_COUNT = 5;
   private static final int MSG_ADD_DOWNLOAD = 6;
   private static final int MSG_REMOVE_DOWNLOAD = 7;
-  private static final int MSG_TASK_STOPPED = 8;
-  private static final int MSG_CONTENT_LENGTH_CHANGED = 9;
-  private static final int MSG_UPDATE_PROGRESS = 10;
-  private static final int MSG_RELEASE = 11;
+  private static final int MSG_REMOVE_ALL_DOWNLOADS = 8;
+  private static final int MSG_TASK_STOPPED = 9;
+  private static final int MSG_CONTENT_LENGTH_CHANGED = 10;
+  private static final int MSG_UPDATE_PROGRESS = 11;
+  private static final int MSG_RELEASE = 12;
 
   private static final String TAG = "DownloadManager";
 
@@ -446,6 +447,12 @@ public void removeDownload(String id) {
     internalHandler.obtainMessage(MSG_REMOVE_DOWNLOAD, id).sendToTarget();
   }
 
+  /** Cancels all pending downloads and removes all downloaded data. */
+  public void removeAllDownloads() {
+    pendingMessages++;
+    internalHandler.obtainMessage(MSG_REMOVE_ALL_DOWNLOADS).sendToTarget();
+  }
+
   /**
    * Stops the downloads and releases resources. Waits until the downloads are persisted to the
    * download index. The manager must not be accessed after this method has been called.
@@ -652,6 +659,9 @@ public void handleMessage(Message message) {
           id = (String) message.obj;
           removeDownload(id);
           break;
+        case MSG_REMOVE_ALL_DOWNLOADS:
+          removeAllDownloads();
+          break;
         case MSG_TASK_STOPPED:
           Task task = (Task) message.obj;
           onTaskStopped(task);
@@ -797,6 +807,36 @@ private void removeDownload(String id) {
       syncTasks();
     }
 
+    private void removeAllDownloads() {
+      List<Download> terminalDownloads = new ArrayList<>();
+      try (DownloadCursor cursor = downloadIndex.getDownloads(STATE_COMPLETED, STATE_FAILED)) {
+        while (cursor.moveToNext()) {
+          terminalDownloads.add(cursor.getDownload());
+        }
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to load downloads.");
+      }
+      for (int i = 0; i < downloads.size(); i++) {
+        downloads.set(i, copyDownloadWithState(downloads.get(i), STATE_REMOVING));
+      }
+      for (int i = 0; i < terminalDownloads.size(); i++) {
+        downloads.add(copyDownloadWithState(terminalDownloads.get(i), STATE_REMOVING));
+      }
+      Collections.sort(downloads, InternalHandler::compareStartTimes);
+      try {
+        downloadIndex.setStatesToRemoving();
+      } catch (IOException e) {
+        Log.e(TAG, "Failed to update index.", e);
+      }
+      ArrayList<Download> updateList = new ArrayList<>(downloads);
+      for (int i = 0; i < downloads.size(); i++) {
+        DownloadUpdate update =
+            new DownloadUpdate(downloads.get(i), /* isRemove= */ false, updateList);
+        mainHandler.obtainMessage(MSG_DOWNLOAD_UPDATE, update).sendToTarget();
+      }
+      syncTasks();
+    }
+
     private void release() {
       for (Task task : activeTasks.values()) {
         task.cancel(/* released= */ true);
@@ -1057,16 +1097,7 @@ private Download putDownloadWithState(Download download, @Download.State int sta
       // to set STATE_STOPPED either, because it doesn't have a stopReason argument.
       Assertions.checkState(
           state != STATE_COMPLETED && state != STATE_FAILED && state != STATE_STOPPED);
-      return putDownload(
-          new Download(
-              download.request,
-              state,
-              download.startTimeMs,
-              /* updateTimeMs= */ System.currentTimeMillis(),
-              download.contentLength,
-              /* stopReason= */ 0,
-              FAILURE_REASON_NONE,
-              download.progress));
+      return putDownload(copyDownloadWithState(download, state));
     }
 
     private Download putDownload(Download download) {
@@ -1120,6 +1151,18 @@ private int getDownloadIndex(String id) {
       return C.INDEX_UNSET;
     }
 
+    private static Download copyDownloadWithState(Download download, @Download.State int state) {
+      return new Download(
+          download.request,
+          state,
+          download.startTimeMs,
+          /* updateTimeMs= */ System.currentTimeMillis(),
+          download.contentLength,
+          /* stopReason= */ 0,
+          FAILURE_REASON_NONE,
+          download.progress);
+    }
+
     private static int compareStartTimes(Download first, Download second) {
       return Util.compareLong(first.startTimeMs, second.startTimeMs);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
index fdd7163a2c..6587984f0c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
@@ -77,6 +77,16 @@
   public static final String ACTION_REMOVE_DOWNLOAD =
       "com.google.android.exoplayer.downloadService.action.REMOVE_DOWNLOAD";
 
+  /**
+   * Removes all downloads. Extras:
+   *
+   * <ul>
+   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
+   * </ul>
+   */
+  public static final String ACTION_REMOVE_ALL_DOWNLOADS =
+      "com.google.android.exoplayer.downloadService.action.REMOVE_ALL_DOWNLOADS";
+
   /**
    * Resumes all downloads except those that have a non-zero {@link Download#stopReason}. Extras:
    *
@@ -164,6 +174,7 @@
   @Nullable private final ForegroundNotificationUpdater foregroundNotificationUpdater;
   @Nullable private final String channelId;
   @StringRes private final int channelNameResourceId;
+  @StringRes private final int channelDescriptionResourceId;
 
   private DownloadManager downloadManager;
   private int lastStartId;
@@ -204,7 +215,23 @@ protected DownloadService(
         foregroundNotificationId,
         foregroundNotificationUpdateInterval,
         /* channelId= */ null,
-        /* channelNameResourceId= */ 0);
+        /* channelNameResourceId= */ 0,
+        /* channelDescriptionResourceId= */ 0);
+  }
+
+  /** @deprecated Use {@link #DownloadService(int, long, String, int, int)}. */
+  @Deprecated
+  protected DownloadService(
+      int foregroundNotificationId,
+      long foregroundNotificationUpdateInterval,
+      @Nullable String channelId,
+      @StringRes int channelNameResourceId) {
+    this(
+        foregroundNotificationId,
+        foregroundNotificationUpdateInterval,
+        channelId,
+        channelNameResourceId,
+        /* channelDescriptionResourceId= */ 0);
   }
 
   /**
@@ -220,25 +247,33 @@ protected DownloadService(
    *     unique per package. The value may be truncated if it's too long. Ignored if {@code
    *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
    * @param channelNameResourceId A string resource identifier for the user visible name of the
-   *     channel, if {@code channelId} is specified. The recommended maximum length is 40
-   *     characters. The value may be truncated if it is too long. Ignored if {@code
+   *     notification channel. The recommended maximum length is 40 characters. The value may be
+   *     truncated if it's too long. Ignored if {@code channelId} is null or if {@code
    *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
+   * @param channelDescriptionResourceId A string resource identifier for the user visible
+   *     description of the notification channel, or 0 if no description is provided. The
+   *     recommended maximum length is 300 characters. The value may be truncated if it is too long.
+   *     Ignored if {@code channelId} is null or if {@code foregroundNotificationId} is {@link
+   *     #FOREGROUND_NOTIFICATION_ID_NONE}.
    */
   protected DownloadService(
       int foregroundNotificationId,
       long foregroundNotificationUpdateInterval,
       @Nullable String channelId,
-      @StringRes int channelNameResourceId) {
+      @StringRes int channelNameResourceId,
+      @StringRes int channelDescriptionResourceId) {
     if (foregroundNotificationId == FOREGROUND_NOTIFICATION_ID_NONE) {
       this.foregroundNotificationUpdater = null;
       this.channelId = null;
       this.channelNameResourceId = 0;
+      this.channelDescriptionResourceId = 0;
     } else {
       this.foregroundNotificationUpdater =
           new ForegroundNotificationUpdater(
               foregroundNotificationId, foregroundNotificationUpdateInterval);
       this.channelId = channelId;
       this.channelNameResourceId = channelNameResourceId;
+      this.channelDescriptionResourceId = channelDescriptionResourceId;
     }
   }
 
@@ -296,6 +331,19 @@ public static Intent buildRemoveDownloadIntent(
         .putExtra(KEY_CONTENT_ID, id);
   }
 
+  /**
+   * Builds an {@link Intent} for removing all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service being targeted by the intent.
+   * @param foreground Whether this intent will be used to start the service in the foreground.
+   * @return The created intent.
+   */
+  public static Intent buildRemoveAllDownloadsIntent(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    return getIntent(context, clazz, ACTION_REMOVE_ALL_DOWNLOADS, foreground);
+  }
+
   /**
    * Builds an {@link Intent} for resuming all downloads.
    *
@@ -414,6 +462,19 @@ public static void sendRemoveDownload(
     startService(context, intent, foreground);
   }
 
+  /**
+   * Starts the service if not started already and removes all downloads.
+   *
+   * @param context A {@link Context}.
+   * @param clazz The concrete download service to be started.
+   * @param foreground Whether the service is started in the foreground.
+   */
+  public static void sendRemoveAllDownloads(
+      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
+    Intent intent = buildRemoveAllDownloadsIntent(context, clazz, foreground);
+    startService(context, intent, foreground);
+  }
+
   /**
    * Starts the service if not started already and resumes all downloads.
    *
@@ -507,7 +568,11 @@ public static void startForeground(Context context, Class<? extends DownloadServ
   public void onCreate() {
     if (channelId != null) {
       NotificationUtil.createNotificationChannel(
-          this, channelId, channelNameResourceId, NotificationUtil.IMPORTANCE_LOW);
+          this,
+          channelId,
+          channelNameResourceId,
+          channelDescriptionResourceId,
+          NotificationUtil.IMPORTANCE_LOW);
     }
     Class<? extends DownloadService> clazz = getClass();
     DownloadManagerHelper downloadManagerHelper = downloadManagerListeners.get(clazz);
@@ -560,6 +625,9 @@ public int onStartCommand(Intent intent, int flags, int startId) {
           downloadManager.removeDownload(contentId);
         }
         break;
+      case ACTION_REMOVE_ALL_DOWNLOADS:
+        downloadManager.removeAllDownloads();
+        break;
       case ACTION_RESUME_DOWNLOADS:
         downloadManager.resumeDownloads();
         break;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
index ae634f8544..dc7085c85e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
@@ -44,6 +44,13 @@
    */
   void setDownloadingStatesToQueued() throws IOException;
 
+  /**
+   * Sets all states to {@link Download#STATE_REMOVING}.
+   *
+   * @throws IOException If an error occurs updating the state.
+   */
+  void setStatesToRemoving() throws IOException;
+
   /**
    * Sets the stop reason of the downloads in a terminal state ({@link Download#STATE_COMPLETED},
    * {@link Download#STATE_FAILED}).
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
index 8572c9c7ca..752239c991 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/PlatformScheduler.java
@@ -25,6 +25,7 @@
 import android.content.Intent;
 import android.os.PersistableBundle;
 import androidx.annotation.RequiresPermission;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 
@@ -36,7 +37,7 @@
  * <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
  * <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
  *
- * <service android:name="com.google.android.exoplayer2.util.scheduler.PlatformScheduler$PlatformSchedulerService"
+ * <service android:name="com.google.android.exoplayer2.scheduler.PlatformScheduler$PlatformSchedulerService"
  *     android:permission="android.permission.BIND_JOB_SERVICE"
  *     android:exported="true"/>
  * }</pre>
@@ -129,9 +130,8 @@ public boolean onStartJob(JobParameters params) {
         logd("Requirements are met");
         String serviceAction = extras.getString(KEY_SERVICE_ACTION);
         String servicePackage = extras.getString(KEY_SERVICE_PACKAGE);
-        // FIXME: incompatible types in argument.
-        @SuppressWarnings("nullness:argument.type.incompatible")
-        Intent intent = new Intent(serviceAction).setPackage(servicePackage);
+        Intent intent =
+            new Intent(Assertions.checkNotNull(serviceAction)).setPackage(servicePackage);
         logd("Starting service action: " + serviceAction + " package: " + servicePackage);
         Util.startForegroundService(this, intent);
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
index 30cf452572..5db86935f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
@@ -27,6 +27,7 @@
 import android.os.Parcelable;
 import android.os.PowerManager;
 import androidx.annotation.IntDef;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -128,7 +129,7 @@ private int getNotMetNetworkRequirements(Context context) {
 
     ConnectivityManager connectivityManager =
         (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+    NetworkInfo networkInfo = Assertions.checkNotNull(connectivityManager).getActiveNetworkInfo();
     if (networkInfo == null
         || !networkInfo.isConnected()
         || !isInternetConnectivityValidated(connectivityManager)) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
index f0d0f37cdf..9bd550f868 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/RequirementsWatcher.java
@@ -28,6 +28,7 @@
 import android.os.Looper;
 import android.os.PowerManager;
 import androidx.annotation.RequiresApi;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -126,7 +127,8 @@ public Requirements getRequirements() {
   @TargetApi(23)
   private void registerNetworkCallbackV23() {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        Assertions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
     NetworkRequest request =
         new NetworkRequest.Builder()
             .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index b40bbb35d1..c84847f755 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -106,13 +106,16 @@
    * Performs a track selection.
    *
    * <p>The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
-   * indicating whether the existing {@code SampleStream} can be retained for each selection, and
+   * indicating whether the existing {@link SampleStream} can be retained for each selection, and
    * the existing {@code stream}s themselves. The call will update {@code streams} to reflect the
    * provided selections, clearing, setting and replacing entries as required. If an existing sample
    * stream is retained but with the requirement that the consuming renderer be reset, then the
    * corresponding flag in {@code streamResetFlags} will be set to true. This flag will also be set
    * if a new sample stream is created.
    *
+   * <p>Note that previously received {@link TrackSelection TrackSelections} are no longer valid and
+   * references need to be replaced even if the corresponding {@link SampleStream} is kept.
+   *
    * <p>This method is only called after the period has been prepared.
    *
    * @param selections The renderer track selections.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
index d9f0008a7f..4dafa0ba76 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
@@ -733,7 +733,7 @@ private void startLoading() {
     if (prepared) {
       SeekMap seekMap = getPreparedState().seekMap;
       Assertions.checkState(isPendingReset());
-      if (durationUs != C.TIME_UNSET && pendingResetPositionUs >= durationUs) {
+      if (durationUs != C.TIME_UNSET && pendingResetPositionUs > durationUs) {
         loadingFinished = true;
         pendingResetPositionUs = C.TIME_UNSET;
         return;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
new file mode 100644
index 0000000000..72095c2c54
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
+
+/** Media source with a single period consisting of silent raw audio of a given duration. */
+public final class SilenceMediaSource extends BaseMediaSource {
+
+  private static final int SAMPLE_RATE_HZ = 44100;
+  @C.PcmEncoding private static final int ENCODING = C.ENCODING_PCM_16BIT;
+  private static final int CHANNEL_COUNT = 2;
+  private static final Format FORMAT =
+      Format.createAudioSampleFormat(
+          /* id=*/ null,
+          MimeTypes.AUDIO_RAW,
+          /* codecs= */ null,
+          /* bitrate= */ Format.NO_VALUE,
+          /* maxInputSize= */ Format.NO_VALUE,
+          CHANNEL_COUNT,
+          SAMPLE_RATE_HZ,
+          ENCODING,
+          /* initializationData= */ null,
+          /* drmInitData= */ null,
+          /* selectionFlags= */ 0,
+          /* language= */ null);
+  private static final byte[] SILENCE_SAMPLE =
+      new byte[Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT) * 1024];
+
+  private final long durationUs;
+
+  /**
+   * Creates a new media source providing silent audio of the given duration.
+   *
+   * @param durationUs The duration of silent audio to output, in microseconds.
+   */
+  public SilenceMediaSource(long durationUs) {
+    Assertions.checkArgument(durationUs >= 0);
+    this.durationUs = durationUs;
+  }
+
+  @Override
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    refreshSourceInfo(
+        new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false),
+        /* manifest= */ null);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() {}
+
+  @Override
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+    return new SilenceMediaPeriod(durationUs);
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {}
+
+  @Override
+  public void releaseSourceInternal() {}
+
+  private static final class SilenceMediaPeriod implements MediaPeriod {
+
+    private static final TrackGroupArray TRACKS = new TrackGroupArray(new TrackGroup(FORMAT));
+
+    private final long durationUs;
+    private final ArrayList<SampleStream> sampleStreams;
+
+    public SilenceMediaPeriod(long durationUs) {
+      this.durationUs = durationUs;
+      sampleStreams = new ArrayList<>();
+    }
+
+    @Override
+    public void prepare(Callback callback, long positionUs) {
+      callback.onPrepared(/* mediaPeriod= */ this);
+    }
+
+    @Override
+    public void maybeThrowPrepareError() {}
+
+    @Override
+    public TrackGroupArray getTrackGroups() {
+      return TRACKS;
+    }
+
+    @Override
+    public long selectTracks(
+        @NullableType TrackSelection[] selections,
+        boolean[] mayRetainStreamFlags,
+        @NullableType SampleStream[] streams,
+        boolean[] streamResetFlags,
+        long positionUs) {
+      positionUs = constrainSeekPosition(positionUs);
+      for (int i = 0; i < selections.length; i++) {
+        if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+          sampleStreams.remove(streams[i]);
+          streams[i] = null;
+        }
+        if (streams[i] == null && selections[i] != null) {
+          SilenceSampleStream stream = new SilenceSampleStream(durationUs);
+          stream.seekTo(positionUs);
+          sampleStreams.add(stream);
+          streams[i] = stream;
+          streamResetFlags[i] = true;
+        }
+      }
+      return positionUs;
+    }
+
+    @Override
+    public void discardBuffer(long positionUs, boolean toKeyframe) {}
+
+    @Override
+    public long readDiscontinuity() {
+      return C.TIME_UNSET;
+    }
+
+    @Override
+    public long seekToUs(long positionUs) {
+      positionUs = constrainSeekPosition(positionUs);
+      for (int i = 0; i < sampleStreams.size(); i++) {
+        ((SilenceSampleStream) sampleStreams.get(i)).seekTo(positionUs);
+      }
+      return positionUs;
+    }
+
+    @Override
+    public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+      return constrainSeekPosition(positionUs);
+    }
+
+    @Override
+    public long getBufferedPositionUs() {
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public long getNextLoadPositionUs() {
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public boolean continueLoading(long positionUs) {
+      return false;
+    }
+
+    @Override
+    public void reevaluateBuffer(long positionUs) {}
+
+    private long constrainSeekPosition(long positionUs) {
+      return Util.constrainValue(positionUs, 0, durationUs);
+    }
+  }
+
+  private static final class SilenceSampleStream implements SampleStream {
+
+    private final long durationBytes;
+
+    private boolean sentFormat;
+    private long positionBytes;
+
+    public SilenceSampleStream(long durationUs) {
+      durationBytes = getAudioByteCount(durationUs);
+      seekTo(0);
+    }
+
+    public void seekTo(long positionUs) {
+      positionBytes = Util.constrainValue(getAudioByteCount(positionUs), 0, durationBytes);
+    }
+
+    @Override
+    public boolean isReady() {
+      return true;
+    }
+
+    @Override
+    public void maybeThrowError() {}
+
+    @Override
+    public int readData(
+        FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {
+      if (!sentFormat || formatRequired) {
+        formatHolder.format = FORMAT;
+        sentFormat = true;
+        return C.RESULT_FORMAT_READ;
+      }
+
+      long bytesRemaining = durationBytes - positionBytes;
+      if (bytesRemaining == 0) {
+        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+
+      int bytesToWrite = (int) Math.min(SILENCE_SAMPLE.length, bytesRemaining);
+      buffer.ensureSpaceForWrite(bytesToWrite);
+      buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
+      buffer.data.put(SILENCE_SAMPLE, /* offset= */ 0, bytesToWrite);
+      buffer.timeUs = getAudioPositionUs(positionBytes);
+      positionBytes += bytesToWrite;
+      return C.RESULT_BUFFER_READ;
+    }
+
+    @Override
+    public int skipData(long positionUs) {
+      long oldPositionBytes = positionBytes;
+      seekTo(positionUs);
+      return (int) ((positionBytes - oldPositionBytes) / SILENCE_SAMPLE.length);
+    }
+  }
+
+  private static long getAudioByteCount(long durationUs) {
+    long audioSampleCount = durationUs * SAMPLE_RATE_HZ / C.MICROS_PER_SECOND;
+    return Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT) * audioSampleCount;
+  }
+
+  private static long getAudioPositionUs(long bytes) {
+    long audioSampleCount = bytes / Util.getPcmFrameSize(ENCODING, CHANNEL_COUNT);
+    return audioSampleCount * C.MICROS_PER_SECOND / SAMPLE_RATE_HZ;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 4b54b3ea9a..3f6ff44248 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -28,9 +28,10 @@
  */
 public class Cue {
 
-  /**
-   * An unset position or width.
-   */
+  /** The empty cue. */
+  public static final Cue EMPTY = new Cue("");
+
+  /** An unset position or width. */
   public static final float DIMEN_UNSET = Float.MIN_VALUE;
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
index 38d6ff25cb..bd561afaf8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import java.nio.ByteBuffer;
@@ -69,6 +70,7 @@ protected final void releaseOutputBuffer(SubtitleOutputBuffer buffer) {
 
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
+  @Nullable
   protected final SubtitleDecoderException decode(
       SubtitleInputBuffer inputBuffer, SubtitleOutputBuffer outputBuffer, boolean reset) {
     try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleOutputBuffer.java
index 75b7a01673..843cfab045 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleOutputBuffer.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.decoder.OutputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import java.util.List;
 
 /**
@@ -45,22 +46,22 @@ public void setContent(long timeUs, Subtitle subtitle, long subsampleOffsetUs) {
 
   @Override
   public int getEventTimeCount() {
-    return subtitle.getEventTimeCount();
+    return Assertions.checkNotNull(subtitle).getEventTimeCount();
   }
 
   @Override
   public long getEventTime(int index) {
-    return subtitle.getEventTime(index) + subsampleOffsetUs;
+    return Assertions.checkNotNull(subtitle).getEventTime(index) + subsampleOffsetUs;
   }
 
   @Override
   public int getNextEventTimeIndex(long timeUs) {
-    return subtitle.getNextEventTimeIndex(timeUs - subsampleOffsetUs);
+    return Assertions.checkNotNull(subtitle).getNextEventTimeIndex(timeUs - subsampleOffsetUs);
   }
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return subtitle.getCues(timeUs - subsampleOffsetUs);
+    return Assertions.checkNotNull(subtitle).getCues(timeUs - subsampleOffsetUs);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 9316e4fb86..5a14063aa1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -80,6 +80,11 @@
    * at which point the non-displayed memory becomes the displayed memory (and vice versa).
    */
   private static final byte CTRL_RESUME_CAPTION_LOADING = 0x20;
+
+  private static final byte CTRL_BACKSPACE = 0x21;
+
+  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
+
   /**
    * Command initiating roll-up style captioning, with the maximum of 2 rows displayed
    * simultaneously.
@@ -95,25 +100,31 @@
    * simultaneously.
    */
   private static final byte CTRL_ROLL_UP_CAPTIONS_4_ROWS = 0x27;
+
   /**
    * Command initiating paint-on style captioning. Subsequent data should be addressed immediately
    * to displayed memory without need for the {@link #CTRL_RESUME_CAPTION_LOADING} command.
    */
   private static final byte CTRL_RESUME_DIRECT_CAPTIONING = 0x29;
   /**
-   * Command indicating the end of a pop-on style caption. At this point the caption loaded in
-   * non-displayed memory should be swapped with the one in displayed memory. If no
-   * {@link #CTRL_RESUME_CAPTION_LOADING} command has been received, this command forces the
-   * receiver into pop-on style.
+   * TEXT commands are switching to TEXT service. All consecutive incoming data must be filtered out
+   * until a command is received that switches back to the CAPTION service.
    */
-  private static final byte CTRL_END_OF_CAPTION = 0x2F;
+  private static final byte CTRL_TEXT_RESTART = 0x2A;
+
+  private static final byte CTRL_RESUME_TEXT_DISPLAY = 0x2B;
 
   private static final byte CTRL_ERASE_DISPLAYED_MEMORY = 0x2C;
   private static final byte CTRL_CARRIAGE_RETURN = 0x2D;
   private static final byte CTRL_ERASE_NON_DISPLAYED_MEMORY = 0x2E;
-  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
 
-  private static final byte CTRL_BACKSPACE = 0x21;
+  /**
+   * Command indicating the end of a pop-on style caption. At this point the caption loaded in
+   * non-displayed memory should be swapped with the one in displayed memory. If no {@link
+   * #CTRL_RESUME_CAPTION_LOADING} command has been received, this command forces the receiver into
+   * pop-on style.
+   */
+  private static final byte CTRL_END_OF_CAPTION = 0x2F;
 
   // Basic North American 608 CC char set, mostly ASCII. Indexed by (char-0x20).
   private static final int[] BASIC_CHARACTER_SET = new int[] {
@@ -231,12 +242,17 @@
   private int captionMode;
   private int captionRowCount;
 
-  private boolean captionValid;
+  private boolean isCaptionValid;
   private boolean repeatableControlSet;
   private byte repeatableControlCc1;
   private byte repeatableControlCc2;
   private int currentChannel;
 
+  // The incoming characters may belong to 3 different services based on the last received control
+  // codes. The 3 services are Captioning, Text and XDS. The decoder only processes Captioning
+  // service bytes and drops the rest.
+  private boolean isInCaptionService;
+
   public Cea608Decoder(String mimeType, int accessibilityChannel) {
     ccData = new ParsableByteArray();
     cueBuilders = new ArrayList<>();
@@ -268,6 +284,7 @@ public Cea608Decoder(String mimeType, int accessibilityChannel) {
 
     setCaptionMode(CC_MODE_UNKNOWN);
     resetCueBuilders();
+    isInCaptionService = true;
   }
 
   @Override
@@ -283,11 +300,12 @@ public void flush() {
     setCaptionMode(CC_MODE_UNKNOWN);
     setCaptionRowCount(DEFAULT_CAPTIONS_ROW_COUNT);
     resetCueBuilders();
-    captionValid = false;
+    isCaptionValid = false;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
     currentChannel = NTSC_CC_CHANNEL_1;
+    isInCaptionService = true;
   }
 
   @Override
@@ -340,13 +358,19 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         continue;
       }
 
-      boolean repeatedControlPossible = repeatableControlSet;
-      repeatableControlSet = false;
+      boolean previousIsCaptionValid = isCaptionValid;
+      isCaptionValid =
+          (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG
+              && ODD_PARITY_BYTE_TABLE[ccByte1]
+              && ODD_PARITY_BYTE_TABLE[ccByte2];
 
-      boolean previousCaptionValid = captionValid;
-      captionValid = (ccHeader & CC_VALID_FLAG) == CC_VALID_FLAG;
-      if (!captionValid) {
-        if (previousCaptionValid) {
+      if (isRepeatedCommand(isCaptionValid, ccData1, ccData2)) {
+        // Ignore repeated valid commands.
+        continue;
+      }
+
+      if (!isCaptionValid) {
+        if (previousIsCaptionValid) {
           // The encoder has flipped the validity bit to indicate captions are being turned off.
           resetCueBuilders();
           captionDataProcessed = true;
@@ -354,59 +378,41 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         continue;
       }
 
-      // If we've reached this point then there is data to process; flag that work has been done.
-      captionDataProcessed = true;
-
-      if (!ODD_PARITY_BYTE_TABLE[ccByte1] || !ODD_PARITY_BYTE_TABLE[ccByte2]) {
-        // The data is invalid.
-        resetCueBuilders();
+      maybeUpdateIsInCaptionService(ccData1, ccData2);
+      if (!isInCaptionService) {
+        // Only the Captioning service is supported. Drop all other bytes.
         continue;
       }
 
-      // Special North American character set.
-      // ccData1 - 0|0|0|1|C|0|0|1
-      // ccData2 - 0|0|1|1|X|X|X|X
-      if (((ccData1 & 0xF7) == 0x11) && ((ccData2 & 0xF0) == 0x30)) {
-        if (getChannel(ccData1) == selectedChannel) {
-          currentCueBuilder.append(getSpecialChar(ccData2));
-        }
+      if (!updateAndVerifyCurrentChannel(ccData1)) {
+        // Wrong channel.
         continue;
       }
 
-      // Extended Western European character set.
-      // ccData1 - 0|0|0|1|C|0|1|S
-      // ccData2 - 0|0|1|X|X|X|X|X
-      if (((ccData1 & 0xF6) == 0x12) && (ccData2 & 0xE0) == 0x20) {
-        if (getChannel(ccData1) == selectedChannel) {
-          // Remove standard equivalent of the special extended char before appending new one
+      if (isCtrlCode(ccData1)) {
+        if (isSpecialNorthAmericanChar(ccData1, ccData2)) {
+          currentCueBuilder.append(getSpecialNorthAmericanChar(ccData2));
+        } else if (isExtendedWestEuropeanChar(ccData1, ccData2)) {
+          // Remove standard equivalent of the special extended char before appending new one.
           currentCueBuilder.backspace();
-          if ((ccData1 & 0x01) == 0x00) {
-            // Extended Spanish/Miscellaneous and French character set (S = 0).
-            currentCueBuilder.append(getExtendedEsFrChar(ccData2));
-          } else {
-            // Extended Portuguese and German/Danish character set (S = 1).
-            currentCueBuilder.append(getExtendedPtDeChar(ccData2));
-          }
+          currentCueBuilder.append(getExtendedWestEuropeanChar(ccData1, ccData2));
+        } else if (isMidrowCtrlCode(ccData1, ccData2)) {
+          handleMidrowCtrl(ccData2);
+        } else if (isPreambleAddressCode(ccData1, ccData2)) {
+          handlePreambleAddressCode(ccData1, ccData2);
+        } else if (isTabCtrlCode(ccData1, ccData2)) {
+          currentCueBuilder.tabOffset = ccData2 - 0x20;
+        } else if (isMiscCode(ccData1, ccData2)) {
+          handleMiscCode(ccData2);
+        }
+      } else {
+        // Basic North American character set.
+        currentCueBuilder.append(getBasicChar(ccData1));
+        if ((ccData2 & 0xE0) != 0x00) {
+          currentCueBuilder.append(getBasicChar(ccData2));
         }
-        continue;
-      }
-
-      // Control character.
-      // ccData1 - 0|0|0|X|X|X|X|X
-      if ((ccData1 & 0xE0) == 0x00) {
-        handleCtrl(ccData1, ccData2, repeatedControlPossible);
-        continue;
-      }
-
-      if (currentChannel != selectedChannel) {
-        continue;
-      }
-
-      // Basic North American character set.
-      currentCueBuilder.append(getChar(ccData1));
-      if ((ccData2 & 0xE0) != 0x00) {
-        currentCueBuilder.append(getChar(ccData2));
       }
+      captionDataProcessed = true;
     }
 
     if (captionDataProcessed) {
@@ -416,15 +422,22 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
     }
   }
 
-  private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
-    currentChannel = getChannel(cc1);
+  private boolean updateAndVerifyCurrentChannel(byte cc1) {
+    if (isCtrlCode(cc1)) {
+      currentChannel = getChannel(cc1);
+    }
+    return currentChannel == selectedChannel;
+  }
+
+  private boolean isRepeatedCommand(boolean captionValid, byte cc1, byte cc2) {
     // Most control commands are sent twice in succession to ensure they are received properly. We
     // don't want to process duplicate commands, so if we see the same repeatable command twice in a
     // row then we ignore the second one.
-    if (isRepeatable(cc1)) {
-      if (repeatedControlPossible && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
+    if (captionValid && isRepeatable(cc1)) {
+      if (repeatableControlSet && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
         // This is a repeated command, so we ignore it.
-        return;
+        repeatableControlSet = false;
+        return true;
       } else {
         // This is the first occurrence of a repeatable command. Set the repeatable control
         // variables so that we can recognize and ignore a duplicate (if there is one), and then
@@ -433,21 +446,11 @@ private void handleCtrl(byte cc1, byte cc2, boolean repeatedControlPossible) {
         repeatableControlCc1 = cc1;
         repeatableControlCc2 = cc2;
       }
+    } else {
+      // This command is not repeatable.
+      repeatableControlSet = false;
     }
-
-    if (currentChannel != selectedChannel) {
-      return;
-    }
-
-    if (isMidrowCtrlCode(cc1, cc2)) {
-      handleMidrowCtrl(cc2);
-    } else if (isPreambleAddressCode(cc1, cc2)) {
-      handlePreambleAddressCode(cc1, cc2);
-    } else if (isTabCtrlCode(cc1, cc2)) {
-      currentCueBuilder.tabOffset = cc2 - 0x20;
-    } else if (isMiscCode(cc1, cc2)) {
-      handleMiscCode(cc2);
-    }
+    return false;
   }
 
   private void handleMidrowCtrl(byte cc2) {
@@ -629,16 +632,61 @@ private void resetCueBuilders() {
     cueBuilders.add(currentCueBuilder);
   }
 
-  private static char getChar(byte ccData) {
+  private void maybeUpdateIsInCaptionService(byte cc1, byte cc2) {
+    if (isXdsControlCode(cc1)) {
+      isInCaptionService = false;
+    } else if (isServiceSwitchCommand(cc1)) {
+      switch (cc2) {
+        case CTRL_TEXT_RESTART:
+        case CTRL_RESUME_TEXT_DISPLAY:
+          isInCaptionService = false;
+          break;
+        case CTRL_END_OF_CAPTION:
+        case CTRL_RESUME_CAPTION_LOADING:
+        case CTRL_RESUME_DIRECT_CAPTIONING:
+        case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
+        case CTRL_ROLL_UP_CAPTIONS_3_ROWS:
+        case CTRL_ROLL_UP_CAPTIONS_4_ROWS:
+          isInCaptionService = true;
+          break;
+        default:
+          // No update.
+      }
+    }
+  }
+
+  private static char getBasicChar(byte ccData) {
     int index = (ccData & 0x7F) - 0x20;
     return (char) BASIC_CHARACTER_SET[index];
   }
 
-  private static char getSpecialChar(byte ccData) {
+  private static boolean isSpecialNorthAmericanChar(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|0|1
+    // cc2 - 0|0|1|1|X|X|X|X
+    return ((cc1 & 0xF7) == 0x11) && ((cc2 & 0xF0) == 0x30);
+  }
+
+  private static char getSpecialNorthAmericanChar(byte ccData) {
     int index = ccData & 0x0F;
     return (char) SPECIAL_CHARACTER_SET[index];
   }
 
+  private static boolean isExtendedWestEuropeanChar(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|1|S
+    // cc2 - 0|0|1|X|X|X|X|X
+    return ((cc1 & 0xF6) == 0x12) && ((cc2 & 0xE0) == 0x20);
+  }
+
+  private static char getExtendedWestEuropeanChar(byte cc1, byte cc2) {
+    if ((cc1 & 0x01) == 0x00) {
+      // Extended Spanish/Miscellaneous and French character set (S = 0).
+      return getExtendedEsFrChar(cc2);
+    } else {
+      // Extended Portuguese and German/Danish character set (S = 1).
+      return getExtendedPtDeChar(cc2);
+    }
+  }
+
   private static char getExtendedEsFrChar(byte ccData) {
     int index = ccData & 0x1F;
     return (char) SPECIAL_ES_FR_CHARACTER_SET[index];
@@ -649,6 +697,11 @@ private static char getExtendedPtDeChar(byte ccData) {
     return (char) SPECIAL_PT_DE_CHARACTER_SET[index];
   }
 
+  private static boolean isCtrlCode(byte cc1) {
+    // cc1 - 0|0|0|X|X|X|X|X
+    return (cc1 & 0xE0) == 0x00;
+  }
+
   private static int getChannel(byte cc1) {
     // cc1 - X|X|X|X|C|X|X|X
     return (cc1 >> 3) & 0x1;
@@ -683,6 +736,15 @@ private static boolean isRepeatable(byte cc1) {
     return (cc1 & 0xF0) == 0x10;
   }
 
+  private static boolean isXdsControlCode(byte cc1) {
+    return 0x01 <= cc1 && cc1 <= 0x0F;
+  }
+
+  private static boolean isServiceSwitchCommand(byte cc1) {
+    // cc1 - 0|0|0|1|C|1|0|0
+    return (cc1 & 0xF7) == 0x14;
+  }
+
   private static class CueBuilder {
 
     // 608 captions define a 15 row by 32 column screen grid. These constants convert from 608
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
index eb956f06db..3f2fef454f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
@@ -21,7 +21,6 @@
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
-import android.graphics.Region;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.util.Log;
@@ -150,6 +149,8 @@ public void reset() {
     List<Cue> cues = new ArrayList<>();
     SparseArray<PageRegion> pageRegions = subtitleService.pageComposition.regions;
     for (int i = 0; i < pageRegions.size(); i++) {
+      // Save clean clipping state.
+      canvas.save();
       PageRegion pageRegion = pageRegions.valueAt(i);
       int regionId = pageRegions.keyAt(i);
       RegionComposition regionComposition = subtitleService.regions.get(regionId);
@@ -163,9 +164,7 @@ public void reset() {
           displayDefinition.horizontalPositionMaximum);
       int clipBottom = Math.min(baseVerticalAddress + regionComposition.height,
           displayDefinition.verticalPositionMaximum);
-      canvas.clipRect(baseHorizontalAddress, baseVerticalAddress, clipRight, clipBottom,
-          Region.Op.REPLACE);
-
+      canvas.clipRect(baseHorizontalAddress, baseVerticalAddress, clipRight, clipBottom);
       ClutDefinition clutDefinition = subtitleService.cluts.get(regionComposition.clutId);
       if (clutDefinition == null) {
         clutDefinition = subtitleService.ancillaryCluts.get(regionComposition.clutId);
@@ -214,9 +213,11 @@ public void reset() {
           (float) regionComposition.height / displayDefinition.height));
 
       canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+      // Restore clean clipping state.
+      canvas.restore();
     }
 
-    return cues;
+    return Collections.unmodifiableList(cues);
   }
 
   // Static parsing.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
index 091bda49f3..9ef3556c8f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.text.pgs;
 
 import android.graphics.Bitmap;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
 import com.google.android.exoplayer2.text.Subtitle;
@@ -41,7 +42,7 @@
   private final ParsableByteArray inflatedBuffer;
   private final CueBuilder cueBuilder;
 
-  private Inflater inflater;
+  @Nullable private Inflater inflater;
 
   public PgsDecoder() {
     super("PgsDecoder");
@@ -76,6 +77,7 @@ private void maybeInflateData(ParsableByteArray buffer) {
     }
   }
 
+  @Nullable
   private static Cue readNextSection(ParsableByteArray buffer, CueBuilder cueBuilder) {
     int limit = buffer.limit();
     int sectionType = buffer.readUnsignedByte();
@@ -197,6 +199,7 @@ private void parseIdentifierSection(ParsableByteArray buffer, int sectionLength)
       bitmapY = buffer.readUnsignedShort();
     }
 
+    @Nullable
     public Cue build() {
       if (planeWidth == 0
           || planeHeight == 0
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
index c25b26128c..b1af75f613 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text.ssa;
 
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
@@ -49,7 +50,7 @@
   private int formatTextIndex;
 
   public SsaDecoder() {
-    this(null);
+    this(/* initializationData= */ null);
   }
 
   /**
@@ -58,7 +59,7 @@ public SsaDecoder() {
    *     format line. The second must contain an SSA header that will be assumed common to all
    *     samples.
    */
-  public SsaDecoder(List<byte[]> initializationData) {
+  public SsaDecoder(@Nullable List<byte[]> initializationData) {
     super("SsaDecoder");
     if (initializationData != null && !initializationData.isEmpty()) {
       haveInitializationData = true;
@@ -201,7 +202,7 @@ private void parseDialogueLine(String dialogueLine, List<Cue> cues, LongArray cu
     cues.add(new Cue(text));
     cueTimesUs.add(startTimeUs);
     if (endTimeUs != C.TIME_UNSET) {
-      cues.add(null);
+      cues.add(Cue.EMPTY);
       cueTimesUs.add(endTimeUs);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java
index 339119ed6b..9a3756194f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java
@@ -32,7 +32,7 @@
   private final long[] cueTimesUs;
 
   /**
-   * @param cues The cues in the subtitle. Null entries may be used to represent empty cues.
+   * @param cues The cues in the subtitle.
    * @param cueTimesUs The cue times, in microseconds.
    */
   public SsaSubtitle(Cue[] cues, long[] cueTimesUs) {
@@ -61,7 +61,7 @@ public long getEventTime(int index) {
   @Override
   public List<Cue> getCues(long timeUs) {
     int index = Util.binarySearchFloor(cueTimesUs, timeUs, true, false);
-    if (index == -1 || cues[index] == null) {
+    if (index == -1 || cues[index] == Cue.EMPTY) {
       // timeUs is earlier than the start of the first cue, or we have an empty cue.
       return Collections.emptyList();
     } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
index 6f9fd366ec..5dfaecee1d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
@@ -111,11 +111,13 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
       // Read and parse the text and tags.
       textBuilder.setLength(0);
       tags.clear();
-      while (!TextUtils.isEmpty(currentLine = subripData.readLine())) {
+      currentLine = subripData.readLine();
+      while (!TextUtils.isEmpty(currentLine)) {
         if (textBuilder.length() > 0) {
           textBuilder.append("<br>");
         }
         textBuilder.append(processLine(currentLine, tags));
+        currentLine = subripData.readLine();
       }
 
       Spanned text = Html.fromHtml(textBuilder.toString());
@@ -132,7 +134,7 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
       cues.add(buildCue(text, alignmentTag));
 
       if (haveEndTimecode) {
-        cues.add(null);
+        cues.add(Cue.EMPTY);
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripSubtitle.java
index a79df478e5..01ed1711a9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripSubtitle.java
@@ -32,7 +32,7 @@
   private final long[] cueTimesUs;
 
   /**
-   * @param cues The cues in the subtitle. Null entries may be used to represent empty cues.
+   * @param cues The cues in the subtitle.
    * @param cueTimesUs The cue times, in microseconds.
    */
   public SubripSubtitle(Cue[] cues, long[] cueTimesUs) {
@@ -61,7 +61,7 @@ public long getEventTime(int index) {
   @Override
   public List<Cue> getCues(long timeUs) {
     int index = Util.binarySearchFloor(cueTimesUs, timeUs, true, false);
-    if (index == -1 || cues[index] == null) {
+    if (index == -1 || cues[index] == Cue.EMPTY) {
       // timeUs is earlier than the start of the first cue, or we have an empty cue.
       return Collections.emptyList();
     } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
index b39f467968..6e0c495466 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
@@ -429,6 +429,7 @@ private TtmlRegion parseRegionAttributes(
         /* lineType= */ Cue.LINE_TYPE_FRACTION,
         lineAnchor,
         width,
+        height,
         /* textSizeType= */ Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING,
         /* textSize= */ regionTextHeight);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
index ecf5c8b0a0..3b4d061aaa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
@@ -231,11 +231,11 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
           new Cue(
               bitmap,
               region.position,
-              Cue.ANCHOR_TYPE_MIDDLE,
+              Cue.ANCHOR_TYPE_START,
               region.line,
               region.lineAnchor,
               region.width,
-              /* height= */ Cue.DIMEN_UNSET));
+              region.height));
     }
 
     // Create text based cues.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
index 2b1e9cf99a..3cbc25d4b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
@@ -28,6 +28,7 @@
   public final @Cue.LineType int lineType;
   public final @Cue.AnchorType int lineAnchor;
   public final float width;
+  public final float height;
   public final @Cue.TextSizeType int textSizeType;
   public final float textSize;
 
@@ -39,6 +40,7 @@ public TtmlRegion(String id) {
         /* lineType= */ Cue.TYPE_UNSET,
         /* lineAnchor= */ Cue.TYPE_UNSET,
         /* width= */ Cue.DIMEN_UNSET,
+        /* height= */ Cue.DIMEN_UNSET,
         /* textSizeType= */ Cue.TYPE_UNSET,
         /* textSize= */ Cue.DIMEN_UNSET);
   }
@@ -50,6 +52,7 @@ public TtmlRegion(
       @Cue.LineType int lineType,
       @Cue.AnchorType int lineAnchor,
       float width,
+      float height,
       int textSizeType,
       float textSize) {
     this.id = id;
@@ -58,6 +61,7 @@ public TtmlRegion(
     this.lineType = lineType;
     this.lineAnchor = lineAnchor;
     this.width = width;
+    this.height = height;
     this.textSizeType = textSizeType;
     this.textSize = textSize;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java
index 9211dc51ce..ddc7a8f5f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoder.java
@@ -65,6 +65,7 @@
   private static final float DEFAULT_VERTICAL_PLACEMENT = 0.85f;
 
   private final ParsableByteArray parsableByteArray;
+
   private boolean customVerticalPlacement;
   private int defaultFontFace;
   private int defaultColorRgba;
@@ -80,10 +81,7 @@
   public Tx3gDecoder(List<byte[]> initializationData) {
     super("Tx3gDecoder");
     parsableByteArray = new ParsableByteArray();
-    decodeInitializationData(initializationData);
-  }
 
-  private void decodeInitializationData(List<byte[]> initializationData) {
     if (initializationData != null && initializationData.size() == 1
         && (initializationData.get(0).length == 48 || initializationData.get(0).length == 53)) {
       byte[] initializationBytes = initializationData.get(0);
@@ -151,8 +149,16 @@ protected Subtitle decode(byte[] bytes, int length, boolean reset)
       }
       parsableByteArray.setPosition(position + atomSize);
     }
-    return new Tx3gSubtitle(new Cue(cueText, null, verticalPlacement, Cue.LINE_TYPE_FRACTION,
-        Cue.ANCHOR_TYPE_START, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET));
+    return new Tx3gSubtitle(
+        new Cue(
+            cueText,
+            /* textAlignment= */ null,
+            verticalPlacement,
+            Cue.LINE_TYPE_FRACTION,
+            Cue.ANCHOR_TYPE_START,
+            Cue.DIMEN_UNSET,
+            Cue.TYPE_UNSET,
+            Cue.DIMEN_UNSET));
   }
 
   private static String readSubtitleText(ParsableByteArray parsableByteArray)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java
index 81c362bda5..f87710a44c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/CssParser.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -35,8 +37,8 @@
   private static final String PROPERTY_TEXT_DECORATION = "text-decoration";
   private static final String VALUE_BOLD = "bold";
   private static final String VALUE_UNDERLINE = "underline";
-  private static final String BLOCK_START = "{";
-  private static final String BLOCK_END = "}";
+  private static final String RULE_START = "{";
+  private static final String RULE_END = "}";
   private static final String PROPERTY_FONT_STYLE = "font-style";
   private static final String VALUE_ITALIC = "italic";
 
@@ -52,37 +54,47 @@ public CssParser() {
   }
 
   /**
-   * Takes a CSS style block and consumes up to the first empty line found. Attempts to parse the
-   * contents of the style block and returns a {@link WebvttCssStyle} instance if successful, or
-   * {@code null} otherwise.
+   * Takes a CSS style block and consumes up to the first empty line. Attempts to parse the contents
+   * of the style block and returns a list of {@link WebvttCssStyle} instances if successful. If
+   * parsing fails, it returns a list including only the styles which have been successfully parsed
+   * up to the style rule which was malformed.
    *
    * @param input The input from which the style block should be read.
-   * @return A {@link WebvttCssStyle} that represents the parsed block.
+   * @return A list of {@link WebvttCssStyle}s that represents the parsed block, or a list
+   *     containing the styles up to the parsing failure.
    */
-  public WebvttCssStyle parseBlock(ParsableByteArray input) {
+  public List<WebvttCssStyle> parseBlock(ParsableByteArray input) {
     stringBuilder.setLength(0);
     int initialInputPosition = input.getPosition();
     skipStyleBlock(input);
     styleInput.reset(input.data, input.getPosition());
     styleInput.setPosition(initialInputPosition);
-    String selector = parseSelector(styleInput, stringBuilder);
-    if (selector == null || !BLOCK_START.equals(parseNextToken(styleInput, stringBuilder))) {
-      return null;
-    }
-    WebvttCssStyle style = new WebvttCssStyle();
-    applySelectorToStyle(style, selector);
-    String token = null;
-    boolean blockEndFound = false;
-    while (!blockEndFound) {
-      int position = styleInput.getPosition();
-      token = parseNextToken(styleInput, stringBuilder);
-      blockEndFound = token == null || BLOCK_END.equals(token);
-      if (!blockEndFound) {
-        styleInput.setPosition(position);
-        parseStyleDeclaration(styleInput, style, stringBuilder);
+
+    List<WebvttCssStyle> styles = new ArrayList<>();
+    String selector;
+    while ((selector = parseSelector(styleInput, stringBuilder)) != null) {
+      if (!RULE_START.equals(parseNextToken(styleInput, stringBuilder))) {
+        return styles;
+      }
+      WebvttCssStyle style = new WebvttCssStyle();
+      applySelectorToStyle(style, selector);
+      String token = null;
+      boolean blockEndFound = false;
+      while (!blockEndFound) {
+        int position = styleInput.getPosition();
+        token = parseNextToken(styleInput, stringBuilder);
+        blockEndFound = token == null || RULE_END.equals(token);
+        if (!blockEndFound) {
+          styleInput.setPosition(position);
+          parseStyleDeclaration(styleInput, style, stringBuilder);
+        }
+      }
+      // Check that the style rule ended correctly.
+      if (RULE_END.equals(token)) {
+        styles.add(style);
       }
     }
-    return BLOCK_END.equals(token) ? style : null; // Check that the style block ended correctly.
+    return styles;
   }
 
   /**
@@ -107,7 +119,7 @@ private static String parseSelector(ParsableByteArray input, StringBuilder strin
     if (token == null) {
       return null;
     }
-    if (BLOCK_START.equals(token)) {
+    if (RULE_START.equals(token)) {
       input.setPosition(position);
       return "";
     }
@@ -156,7 +168,7 @@ private static void parseStyleDeclaration(ParsableByteArray input, WebvttCssStyl
     String token = parseNextToken(input, stringBuilder);
     if (";".equals(token)) {
       // The style declaration is well formed.
-    } else if (BLOCK_END.equals(token)) {
+    } else if (RULE_END.equals(token)) {
       // The style declaration is well formed and we can go on, but the closing bracket had to be
       // fed back.
       input.setPosition(position);
@@ -250,7 +262,7 @@ private static String parsePropertyValue(ParsableByteArray input, StringBuilder
         // Syntax error.
         return null;
       }
-      if (BLOCK_END.equals(token) || ";".equals(token)) {
+      if (RULE_END.equals(token) || ";".equals(token)) {
         input.setPosition(position);
         expressionEndFound = true;
       } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
index 06d3c14970..fe3c86bd1e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
@@ -80,10 +80,7 @@ protected WebvttSubtitle decode(byte[] bytes, int length, boolean reset)
           throw new SubtitleDecoderException("A style block was found after the first cue.");
         }
         parsableWebvttData.readLine(); // Consume the "STYLE" header.
-        WebvttCssStyle styleBlock = cssParser.parseBlock(parsableWebvttData);
-        if (styleBlock != null) {
-          definedStyles.add(styleBlock);
-        }
+        definedStyles.addAll(cssParser.parseBlock(parsableWebvttData));
       } else if (event == EVENT_CUE) {
         if (cueParser.parseCue(parsableWebvttData, webvttCueBuilder, definedStyles)) {
           subtitles.add(webvttCueBuilder.build());
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index bbf57c5602..0adadd87c2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -757,7 +757,7 @@ public long getAllocatedBandwidth() {
     for (int i = 0; i < values.length; i++) {
       logValues[i] = new double[values[i].length];
       for (int j = 0; j < values[i].length; j++) {
-        logValues[i][j] = Math.log(values[i][j]);
+        logValues[i][j] = values[i][j] == Format.NO_VALUE ? 0 : Math.log(values[i][j]);
       }
     }
     return logValues;
@@ -779,7 +779,8 @@ public long getAllocatedBandwidth() {
       double totalBitrateDiff = logBitrates[i][logBitrates[i].length - 1] - logBitrates[i][0];
       for (int j = 0; j < logBitrates[i].length - 1; j++) {
         double switchBitrate = 0.5 * (logBitrates[i][j] + logBitrates[i][j + 1]);
-        switchPoints[i][j] = (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
+        switchPoints[i][j] =
+            totalBitrateDiff == 0.0 ? 1.0 : (switchBitrate - logBitrates[i][0]) / totalBitrateDiff;
       }
     }
     return switchPoints;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 3200e40495..b8dd40f8bd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -1934,6 +1934,7 @@ private static boolean isSupportedAdaptiveVideoTrack(
           getAdaptiveAudioTracks(
               selectedGroup,
               formatSupports[selectedGroupIndex],
+              params.maxAudioBitrate,
               params.allowAudioMixedMimeTypeAdaptiveness,
               params.allowAudioMixedSampleRateAdaptiveness);
       if (adaptiveTracks.length > 0) {
@@ -1951,6 +1952,7 @@ private static boolean isSupportedAdaptiveVideoTrack(
   private static int[] getAdaptiveAudioTracks(
       TrackGroup group,
       int[] formatSupport,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness) {
     int selectedConfigurationTrackCount = 0;
@@ -1967,6 +1969,7 @@ private static boolean isSupportedAdaptiveVideoTrack(
                 group,
                 formatSupport,
                 configuration,
+                maxAudioBitrate,
                 allowMixedMimeTypeAdaptiveness,
                 allowMixedSampleRateAdaptiveness);
         if (configurationCount > selectedConfigurationTrackCount) {
@@ -1977,13 +1980,16 @@ private static boolean isSupportedAdaptiveVideoTrack(
     }
 
     if (selectedConfigurationTrackCount > 1) {
+      Assertions.checkNotNull(selectedConfiguration);
       int[] adaptiveIndices = new int[selectedConfigurationTrackCount];
       int index = 0;
       for (int i = 0; i < group.length; i++) {
+        Format format = group.getFormat(i);
         if (isSupportedAdaptiveAudioTrack(
-            group.getFormat(i),
+            format,
             formatSupport[i],
-            Assertions.checkNotNull(selectedConfiguration),
+            selectedConfiguration,
+            maxAudioBitrate,
             allowMixedMimeTypeAdaptiveness,
             allowMixedSampleRateAdaptiveness)) {
           adaptiveIndices[index++] = i;
@@ -1998,6 +2004,7 @@ private static int getAdaptiveAudioTrackCount(
       TrackGroup group,
       int[] formatSupport,
       AudioConfigurationTuple configuration,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness) {
     int count = 0;
@@ -2006,6 +2013,7 @@ private static int getAdaptiveAudioTrackCount(
           group.getFormat(i),
           formatSupport[i],
           configuration,
+          maxAudioBitrate,
           allowMixedMimeTypeAdaptiveness,
           allowMixedSampleRateAdaptiveness)) {
         count++;
@@ -2018,9 +2026,11 @@ private static boolean isSupportedAdaptiveAudioTrack(
       Format format,
       int formatSupport,
       AudioConfigurationTuple configuration,
+      int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness) {
     return isSupported(formatSupport, false)
+        && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxAudioBitrate)
         && (format.channelCount != Format.NO_VALUE
             && format.channelCount == configuration.channelCount)
         && (allowMixedMimeTypeAdaptiveness
@@ -2308,14 +2318,14 @@ protected static int getFormatLanguageScore(Format format, @Nullable String lang
     if (TextUtils.equals(format.language, language)) {
       return 3;
     }
-    // Partial match where one language is a subset of the other (e.g. "zho-hans" and "zho-hans-hk")
+    // Partial match where one language is a subset of the other (e.g. "zh-hans" and "zh-hans-hk")
     if (format.language.startsWith(language) || language.startsWith(format.language)) {
       return 2;
     }
-    // Partial match where only the main language tag is the same (e.g. "fra-fr" and "fra-ca")
-    if (format.language.length() >= 3
-        && language.length() >= 3
-        && format.language.substring(0, 3).equals(language.substring(0, 3))) {
+    // Partial match where only the main language tag is the same (e.g. "fr-fr" and "fr-ca")
+    String formatMainLanguage = Util.splitAtFirst(format.language, "-")[0];
+    String queryMainLanguage = Util.splitAtFirst(language, "-")[0];
+    if (formatMainLanguage.equals(queryMainLanguage)) {
       return 1;
     }
     return 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
index de4a75d607..94a6e21c86 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.net.Uri;
 import androidx.annotation.Nullable;
 import android.util.Base64;
@@ -29,9 +31,10 @@
 
   public static final String SCHEME_DATA = "data";
 
-  private @Nullable DataSpec dataSpec;
-  private int bytesRead;
-  private @Nullable byte[] data;
+  @Nullable private DataSpec dataSpec;
+  @Nullable private byte[] data;
+  private int endPosition;
+  private int readPosition;
 
   public DataSchemeDataSource() {
     super(/* isNetwork= */ false);
@@ -41,6 +44,7 @@ public DataSchemeDataSource() {
   public long open(DataSpec dataSpec) throws IOException {
     transferInitializing(dataSpec);
     this.dataSpec = dataSpec;
+    readPosition = (int) dataSpec.position;
     Uri uri = dataSpec.uri;
     String scheme = uri.getScheme();
     if (!SCHEME_DATA.equals(scheme)) {
@@ -61,8 +65,14 @@ public long open(DataSpec dataSpec) throws IOException {
       // TODO: Add support for other charsets.
       data = Util.getUtf8Bytes(URLDecoder.decode(dataString, C.ASCII_NAME));
     }
+    endPosition =
+        dataSpec.length != C.LENGTH_UNSET ? (int) dataSpec.length + readPosition : data.length;
+    if (endPosition > data.length || readPosition > endPosition) {
+      data = null;
+      throw new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE);
+    }
     transferStarted(dataSpec);
-    return data.length;
+    return (long) endPosition - readPosition;
   }
 
   @Override
@@ -70,29 +80,29 @@ public int read(byte[] buffer, int offset, int readLength) {
     if (readLength == 0) {
       return 0;
     }
-    int remainingBytes = data.length - bytesRead;
+    int remainingBytes = endPosition - readPosition;
     if (remainingBytes == 0) {
       return C.RESULT_END_OF_INPUT;
     }
     readLength = Math.min(readLength, remainingBytes);
-    System.arraycopy(data, bytesRead, buffer, offset, readLength);
-    bytesRead += readLength;
+    System.arraycopy(castNonNull(data), readPosition, buffer, offset, readLength);
+    readPosition += readLength;
     bytesTransferred(readLength);
     return readLength;
   }
 
   @Override
-  public @Nullable Uri getUri() {
+  @Nullable
+  public Uri getUri() {
     return dataSpec != null ? dataSpec.uri : null;
   }
 
   @Override
-  public void close() throws IOException {
+  public void close() {
     if (data != null) {
       data = null;
       transferEnded();
     }
     dataSpec = null;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index 8b4107850c..69db1cfdb1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -42,6 +42,7 @@
  *   <li>rtmp: For fetching data over RTMP. Only supported if the project using ExoPlayer has an
  *       explicit dependency on ExoPlayer's RTMP extension.
  *   <li>data: For parsing data inlined in the URI as defined in RFC 2397.
+ *   <li>udp: For fetching data over UDP (e.g. udp://something.com/media).
  *   <li>http(s): For fetching data over HTTP and HTTPS (e.g. https://www.something.com/media.mp4),
  *       if constructed using {@link #DefaultDataSource(Context, TransferListener, String,
  *       boolean)}, or any other schemes supported by a base data source if constructed using {@link
@@ -55,6 +56,7 @@
   private static final String SCHEME_ASSET = "asset";
   private static final String SCHEME_CONTENT = "content";
   private static final String SCHEME_RTMP = "rtmp";
+  private static final String SCHEME_UDP = "udp";
   private static final String SCHEME_RAW = RawResourceDataSource.RAW_RESOURCE_SCHEME;
 
   private final Context context;
@@ -62,12 +64,13 @@
   private final DataSource baseDataSource;
 
   // Lazily initialized.
-  private @Nullable DataSource fileDataSource;
-  private @Nullable DataSource assetDataSource;
-  private @Nullable DataSource contentDataSource;
-  private @Nullable DataSource rtmpDataSource;
-  private @Nullable DataSource dataSchemeDataSource;
-  private @Nullable DataSource rawResourceDataSource;
+  @Nullable private DataSource fileDataSource;
+  @Nullable private DataSource assetDataSource;
+  @Nullable private DataSource contentDataSource;
+  @Nullable private DataSource rtmpDataSource;
+  @Nullable private DataSource udpDataSource;
+  @Nullable private DataSource dataSchemeDataSource;
+  @Nullable private DataSource rawResourceDataSource;
 
   private @Nullable DataSource dataSource;
 
@@ -218,6 +221,7 @@ public void addTransferListener(TransferListener transferListener) {
     maybeAddListenerToDataSource(assetDataSource, transferListener);
     maybeAddListenerToDataSource(contentDataSource, transferListener);
     maybeAddListenerToDataSource(rtmpDataSource, transferListener);
+    maybeAddListenerToDataSource(udpDataSource, transferListener);
     maybeAddListenerToDataSource(dataSchemeDataSource, transferListener);
     maybeAddListenerToDataSource(rawResourceDataSource, transferListener);
   }
@@ -240,6 +244,8 @@ public long open(DataSpec dataSpec) throws IOException {
       dataSource = getContentDataSource();
     } else if (SCHEME_RTMP.equals(scheme)) {
       dataSource = getRtmpDataSource();
+    } else if (SCHEME_UDP.equals(scheme)) {
+      dataSource = getUdpDataSource();
     } else if (DataSchemeDataSource.SCHEME_DATA.equals(scheme)) {
       dataSource = getDataSchemeDataSource();
     } else if (SCHEME_RAW.equals(scheme)) {
@@ -277,6 +283,14 @@ public void close() throws IOException {
     }
   }
 
+  private DataSource getUdpDataSource() {
+    if (udpDataSource == null) {
+      udpDataSource = new UdpDataSource();
+      addListenersToDataSource(udpDataSource);
+    }
+    return udpDataSource;
+  }
+
   private DataSource getFileDataSource() {
     if (fileDataSource == null) {
       fileDataSource = new FileDataSource();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 6aad517004..66036b7a84 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -89,6 +89,11 @@
   private long bytesSkipped;
   private long bytesRead;
 
+  /** @param userAgent The User-Agent string that should be used. */
+  public DefaultHttpDataSource(String userAgent) {
+    this(userAgent, /* contentTypePredicate= */ null);
+  }
+
   /**
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
new file mode 100644
index 0000000000..99f0dee207
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import android.net.Uri;
+import androidx.annotation.Nullable;
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/** {@link DataSource} wrapper allowing just-in-time resolution of {@link DataSpec DataSpecs}. */
+public final class ResolvingDataSource implements DataSource {
+
+  /** Resolves {@link DataSpec DataSpecs}. */
+  public interface Resolver {
+
+    /**
+     * Resolves a {@link DataSpec} before forwarding it to the wrapped {@link DataSource}. This
+     * method is allowed to block until the {@link DataSpec} has been resolved.
+     *
+     * <p>Note that this method is called for every new connection, so caching of results is
+     * recommended, especially if network operations are involved.
+     *
+     * @param dataSpec The original {@link DataSpec}.
+     * @return The resolved {@link DataSpec}.
+     * @throws IOException If an {@link IOException} occurred while resolving the {@link DataSpec}.
+     */
+    DataSpec resolveDataSpec(DataSpec dataSpec) throws IOException;
+
+    /**
+     * Resolves a URI reported by {@link DataSource#getUri()} for event reporting and caching
+     * purposes.
+     *
+     * <p>Implementations do not need to overwrite this method unless they want to change the
+     * reported URI.
+     *
+     * <p>This method is <em>not</em> allowed to block.
+     *
+     * @param uri The URI as reported by {@link DataSource#getUri()}.
+     * @return The resolved URI used for event reporting and caching.
+     */
+    default Uri resolveReportedUri(Uri uri) {
+      return uri;
+    }
+  }
+
+  /** {@link DataSource.Factory} for {@link ResolvingDataSource} instances. */
+  public static final class Factory implements DataSource.Factory {
+
+    private final DataSource.Factory upstreamFactory;
+    private final Resolver resolver;
+
+    /**
+     * Creates factory for {@link ResolvingDataSource} instances.
+     *
+     * @param upstreamFactory The wrapped {@link DataSource.Factory} handling the resolved {@link
+     *     DataSpec DataSpecs}.
+     * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
+     */
+    public Factory(DataSource.Factory upstreamFactory, Resolver resolver) {
+      this.upstreamFactory = upstreamFactory;
+      this.resolver = resolver;
+    }
+
+    @Override
+    public DataSource createDataSource() {
+      return new ResolvingDataSource(upstreamFactory.createDataSource(), resolver);
+    }
+  }
+
+  private final DataSource upstreamDataSource;
+  private final Resolver resolver;
+
+  private boolean upstreamOpened;
+
+  /**
+   * @param upstreamDataSource The wrapped {@link DataSource}.
+   * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
+   */
+  public ResolvingDataSource(DataSource upstreamDataSource, Resolver resolver) {
+    this.upstreamDataSource = upstreamDataSource;
+    this.resolver = resolver;
+  }
+
+  @Override
+  public void addTransferListener(TransferListener transferListener) {
+    upstreamDataSource.addTransferListener(transferListener);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    DataSpec resolvedDataSpec = resolver.resolveDataSpec(dataSpec);
+    upstreamOpened = true;
+    return upstreamDataSource.open(resolvedDataSpec);
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    return upstreamDataSource.read(buffer, offset, readLength);
+  }
+
+  @Nullable
+  @Override
+  public Uri getUri() {
+    Uri reportedUri = upstreamDataSource.getUri();
+    return reportedUri == null ? null : resolver.resolveReportedUri(reportedUri);
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return upstreamDataSource.getResponseHeaders();
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (upstreamOpened) {
+      upstreamOpened = false;
+      upstreamDataSource.close();
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 2caf4c92f8..566c928b20 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -49,7 +49,6 @@
   private final long fragmentSize;
   private final int bufferSize;
 
-  private boolean syncFileDescriptor;
   private DataSpec dataSpec;
   private long dataSpecFragmentSize;
   private File file;
@@ -108,18 +107,6 @@ public CacheDataSink(Cache cache, long fragmentSize, int bufferSize) {
     this.cache = Assertions.checkNotNull(cache);
     this.fragmentSize = fragmentSize == C.LENGTH_UNSET ? Long.MAX_VALUE : fragmentSize;
     this.bufferSize = bufferSize;
-    syncFileDescriptor = true;
-  }
-
-  /**
-   * Sets whether file descriptors are synced when closing output streams.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   *
-   * @param syncFileDescriptor Whether file descriptors are synced when closing output streams.
-   */
-  public void experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
-    this.syncFileDescriptor = syncFileDescriptor;
   }
 
   @Override
@@ -208,9 +195,6 @@ private void closeCurrentOutputStream() throws IOException {
     boolean success = false;
     try {
       outputStream.flush();
-      if (syncFileDescriptor) {
-        underlyingFileOutputStream.getFD().sync();
-      }
       success = true;
     } finally {
       Util.closeQuietly(outputStream);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
index 856e9db168..ce9735badd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
@@ -26,8 +26,6 @@
   private final long fragmentSize;
   private final int bufferSize;
 
-  private boolean syncFileDescriptor;
-
   /** @see CacheDataSink#CacheDataSink(Cache, long) */
   public CacheDataSinkFactory(Cache cache, long fragmentSize) {
     this(cache, fragmentSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
@@ -40,20 +38,8 @@ public CacheDataSinkFactory(Cache cache, long fragmentSize, int bufferSize) {
     this.bufferSize = bufferSize;
   }
 
-  /**
-   * See {@link CacheDataSink#experimental_setSyncFileDescriptor(boolean)}.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   */
-  public CacheDataSinkFactory experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
-    this.syncFileDescriptor = syncFileDescriptor;
-    return this;
-  }
-
   @Override
   public DataSink createDataSink() {
-    CacheDataSink dataSink = new CacheDataSink(cache, fragmentSize, bufferSize);
-    dataSink.experimental_setSyncFileDescriptor(syncFileDescriptor);
-    return dataSink;
+    return new CacheDataSink(cache, fragmentSize, bufferSize);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 58b2d176cf..e5df8d55c3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -134,9 +134,9 @@
 
   private @Nullable DataSource currentDataSource;
   private boolean currentDataSpecLengthUnset;
-  private @Nullable Uri uri;
-  private @Nullable Uri actualUri;
-  private @HttpMethod int httpMethod;
+  @Nullable private Uri uri;
+  @Nullable private Uri actualUri;
+  @HttpMethod private int httpMethod;
   private int flags;
   private @Nullable String key;
   private long readPosition;
@@ -319,7 +319,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
       }
       return bytesRead;
     } catch (IOException e) {
-      if (currentDataSpecLengthUnset && isCausedByPositionOutOfRange(e)) {
+      if (currentDataSpecLengthUnset && CacheUtil.isCausedByPositionOutOfRange(e)) {
         setNoBytesRemainingAndMaybeStoreLength();
         return C.RESULT_END_OF_INPUT;
       }
@@ -484,20 +484,6 @@ private static Uri getRedirectedUriOrDefault(Cache cache, String key, Uri defaul
     return redirectedUri != null ? redirectedUri : defaultUri;
   }
 
-  private static boolean isCausedByPositionOutOfRange(IOException e) {
-    Throwable cause = e;
-    while (cause != null) {
-      if (cause instanceof DataSourceException) {
-        int reason = ((DataSourceException) cause).reason;
-        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
-          return true;
-        }
-      }
-      cause = cause.getCause();
-    }
-    return false;
-  }
-
   private boolean isReadingFromUpstream() {
     return !isReadingFromCache();
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index 219d736835..47470c5de7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -20,6 +20,7 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
@@ -78,13 +79,7 @@ public static String generateKey(Uri uri) {
       DataSpec dataSpec, Cache cache, @Nullable CacheKeyFactory cacheKeyFactory) {
     String key = buildCacheKey(dataSpec, cacheKeyFactory);
     long position = dataSpec.absoluteStreamPosition;
-    long requestLength;
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      requestLength = dataSpec.length;
-    } else {
-      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
-      requestLength = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
-    }
+    long requestLength = getRequestLength(dataSpec, cache, key);
     long bytesAlreadyCached = 0;
     long bytesLeft = requestLength;
     while (bytesLeft != 0) {
@@ -179,53 +174,66 @@ public static void cache(
     Assertions.checkNotNull(dataSource);
     Assertions.checkNotNull(buffer);
 
+    String key = buildCacheKey(dataSpec, cacheKeyFactory);
+    long bytesLeft;
     ProgressNotifier progressNotifier = null;
     if (progressListener != null) {
       progressNotifier = new ProgressNotifier(progressListener);
       Pair<Long, Long> lengthAndBytesAlreadyCached = getCached(dataSpec, cache, cacheKeyFactory);
       progressNotifier.init(lengthAndBytesAlreadyCached.first, lengthAndBytesAlreadyCached.second);
+      bytesLeft = lengthAndBytesAlreadyCached.first;
+    } else {
+      bytesLeft = getRequestLength(dataSpec, cache, key);
     }
 
-    String key = buildCacheKey(dataSpec, cacheKeyFactory);
     long position = dataSpec.absoluteStreamPosition;
-    long bytesLeft;
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      bytesLeft = dataSpec.length;
-    } else {
-      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
-      bytesLeft = contentLength == C.LENGTH_UNSET ? C.LENGTH_UNSET : contentLength - position;
-    }
+    boolean lengthUnset = bytesLeft == C.LENGTH_UNSET;
     while (bytesLeft != 0) {
       throwExceptionIfInterruptedOrCancelled(isCanceled);
       long blockLength =
-          cache.getCachedLength(
-              key, position, bytesLeft != C.LENGTH_UNSET ? bytesLeft : Long.MAX_VALUE);
+          cache.getCachedLength(key, position, lengthUnset ? Long.MAX_VALUE : bytesLeft);
       if (blockLength > 0) {
         // Skip already cached data.
       } else {
         // There is a hole in the cache which is at least "-blockLength" long.
         blockLength = -blockLength;
+        long length = blockLength == Long.MAX_VALUE ? C.LENGTH_UNSET : blockLength;
+        boolean isLastBlock = length == bytesLeft;
         long read =
             readAndDiscard(
                 dataSpec,
                 position,
-                blockLength,
+                length,
                 dataSource,
                 buffer,
                 priorityTaskManager,
                 priority,
                 progressNotifier,
+                isLastBlock,
                 isCanceled);
         if (read < blockLength) {
           // Reached to the end of the data.
-          if (enableEOFException && bytesLeft != C.LENGTH_UNSET) {
+          if (enableEOFException && !lengthUnset) {
             throw new EOFException();
           }
           break;
         }
       }
       position += blockLength;
-      bytesLeft -= bytesLeft == C.LENGTH_UNSET ? 0 : blockLength;
+      if (!lengthUnset) {
+        bytesLeft -= blockLength;
+      }
+    }
+  }
+
+  private static long getRequestLength(DataSpec dataSpec, Cache cache, String key) {
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      return dataSpec.length;
+    } else {
+      long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(key));
+      return contentLength == C.LENGTH_UNSET
+          ? C.LENGTH_UNSET
+          : contentLength - dataSpec.absoluteStreamPosition;
     }
   }
 
@@ -242,6 +250,7 @@ public static void cache(
    *     caching.
    * @param priority The priority of this task.
    * @param progressNotifier A notifier through which to report progress updates, or {@code null}.
+   * @param isLastBlock Whether this read block is the last block of the content.
    * @param isCanceled An optional flag that will interrupt caching if set to true.
    * @return Number of read bytes, or 0 if no data is available because the end of the opened range
    *     has been reached.
@@ -255,54 +264,64 @@ private static long readAndDiscard(
       PriorityTaskManager priorityTaskManager,
       int priority,
       @Nullable ProgressNotifier progressNotifier,
+      boolean isLastBlock,
       AtomicBoolean isCanceled)
       throws IOException, InterruptedException {
     long positionOffset = absoluteStreamPosition - dataSpec.absoluteStreamPosition;
+    long initialPositionOffset = positionOffset;
+    long endOffset = length != C.LENGTH_UNSET ? positionOffset + length : C.POSITION_UNSET;
     while (true) {
       if (priorityTaskManager != null) {
         // Wait for any other thread with higher priority to finish its job.
         priorityTaskManager.proceed(priority);
       }
+      throwExceptionIfInterruptedOrCancelled(isCanceled);
       try {
-        throwExceptionIfInterruptedOrCancelled(isCanceled);
-        // Create a new dataSpec setting length to C.LENGTH_UNSET to prevent getting an error in
-        // case the given length exceeds the end of input.
-        dataSpec =
-            new DataSpec(
-                dataSpec.uri,
-                dataSpec.httpMethod,
-                dataSpec.httpBody,
-                absoluteStreamPosition,
-                /* position= */ dataSpec.position + positionOffset,
-                C.LENGTH_UNSET,
-                dataSpec.key,
-                dataSpec.flags);
-        long resolvedLength = dataSource.open(dataSpec);
-        if (progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
+        long resolvedLength = C.LENGTH_UNSET;
+        boolean isDataSourceOpen = false;
+        if (endOffset != C.POSITION_UNSET) {
+          // If a specific length is given, first try to open the data source for that length to
+          // avoid more data then required to be requested. If the given length exceeds the end of
+          // input we will get a "position out of range" error. In that case try to open the source
+          // again with unset length.
+          try {
+            resolvedLength =
+                dataSource.open(dataSpec.subrange(positionOffset, endOffset - positionOffset));
+            isDataSourceOpen = true;
+          } catch (IOException exception) {
+            if (!isLastBlock || !isCausedByPositionOutOfRange(exception)) {
+              throw exception;
+            }
+            Util.closeQuietly(dataSource);
+          }
+        }
+        if (!isDataSourceOpen) {
+          resolvedLength = dataSource.open(dataSpec.subrange(positionOffset, C.LENGTH_UNSET));
+        }
+        if (isLastBlock && progressNotifier != null && resolvedLength != C.LENGTH_UNSET) {
           progressNotifier.onRequestLengthResolved(positionOffset + resolvedLength);
         }
-        long totalBytesRead = 0;
-        while (totalBytesRead != length) {
+        while (positionOffset != endOffset) {
           throwExceptionIfInterruptedOrCancelled(isCanceled);
           int bytesRead =
               dataSource.read(
                   buffer,
                   0,
-                  length != C.LENGTH_UNSET
-                      ? (int) Math.min(buffer.length, length - totalBytesRead)
+                  endOffset != C.POSITION_UNSET
+                      ? (int) Math.min(buffer.length, endOffset - positionOffset)
                       : buffer.length);
           if (bytesRead == C.RESULT_END_OF_INPUT) {
             if (progressNotifier != null) {
-              progressNotifier.onRequestLengthResolved(positionOffset + totalBytesRead);
+              progressNotifier.onRequestLengthResolved(positionOffset);
             }
             break;
           }
-          totalBytesRead += bytesRead;
+          positionOffset += bytesRead;
           if (progressNotifier != null) {
             progressNotifier.onBytesCached(bytesRead);
           }
         }
-        return totalBytesRead;
+        return positionOffset - initialPositionOffset;
       } catch (PriorityTaskManager.PriorityTooLowException exception) {
         // catch and try again
       } finally {
@@ -340,6 +359,20 @@ public static void remove(Cache cache, String key) {
     }
   }
 
+  /*package*/ static boolean isCausedByPositionOutOfRange(IOException e) {
+    Throwable cause = e;
+    while (cause != null) {
+      if (cause instanceof DataSourceException) {
+        int reason = ((DataSourceException) cause).reason;
+        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
+          return true;
+        }
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
   private static String buildCacheKey(
       DataSpec dataSpec, @Nullable CacheKeyFactory cacheKeyFactory) {
     return (cacheKeyFactory != null ? cacheKeyFactory : DEFAULT_CACHE_KEY_FACTORY)
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java
similarity index 64%
rename from library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java
rename to library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java
index 0df39e103d..2c814294af 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java
@@ -15,12 +15,18 @@
  */
 package com.google.android.exoplayer2.util;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.flac.PictureFrame;
+import com.google.android.exoplayer2.metadata.flac.VorbisComment;
+import java.util.ArrayList;
+import java.util.List;
 
-/**
- * Holder for FLAC stream info.
- */
-public final class FlacStreamInfo {
+/** Holder for FLAC metadata. */
+public final class FlacStreamMetadata {
+
+  private static final String TAG = "FlacStreamMetadata";
 
   public final int minBlockSize;
   public final int maxBlockSize;
@@ -30,16 +36,19 @@
   public final int channels;
   public final int bitsPerSample;
   public final long totalSamples;
+  @Nullable public final Metadata metadata;
+
+  private static final String SEPARATOR = "=";
 
   /**
-   * Constructs a FlacStreamInfo parsing the given binary FLAC stream info metadata structure.
+   * Parses binary FLAC stream info metadata.
    *
-   * @param data An array holding FLAC stream info metadata structure
-   * @param offset Offset of the structure in the array
+   * @param data An array containing binary FLAC stream info metadata.
+   * @param offset The offset of the stream info metadata in {@code data}.
    * @see <a href="https://xiph.org/flac/format.html#metadata_block_streaminfo">FLAC format
    *     METADATA_BLOCK_STREAMINFO</a>
    */
-  public FlacStreamInfo(byte[] data, int offset) {
+  public FlacStreamMetadata(byte[] data, int offset) {
     ParsableBitArray scratch = new ParsableBitArray(data);
     scratch.setPosition(offset * 8);
     this.minBlockSize = scratch.readBits(16);
@@ -49,14 +58,11 @@ public FlacStreamInfo(byte[] data, int offset) {
     this.sampleRate = scratch.readBits(20);
     this.channels = scratch.readBits(3) + 1;
     this.bitsPerSample = scratch.readBits(5) + 1;
-    this.totalSamples = ((scratch.readBits(4) & 0xFL) << 32)
-        | (scratch.readBits(32) & 0xFFFFFFFFL);
-    // Remaining 16 bytes is md5 value
+    this.totalSamples = ((scratch.readBits(4) & 0xFL) << 32) | (scratch.readBits(32) & 0xFFFFFFFFL);
+    this.metadata = null;
   }
 
   /**
-   * Constructs a FlacStreamInfo given the parameters.
-   *
    * @param minBlockSize Minimum block size of the FLAC stream.
    * @param maxBlockSize Maximum block size of the FLAC stream.
    * @param minFrameSize Minimum frame size of the FLAC stream.
@@ -65,10 +71,16 @@ public FlacStreamInfo(byte[] data, int offset) {
    * @param channels Number of channels of the FLAC stream.
    * @param bitsPerSample Number of bits per sample of the FLAC stream.
    * @param totalSamples Total samples of the FLAC stream.
+   * @param vorbisComments Vorbis comments. Each entry must be in key=value form.
+   * @param pictureFrames Picture frames.
    * @see <a href="https://xiph.org/flac/format.html#metadata_block_streaminfo">FLAC format
    *     METADATA_BLOCK_STREAMINFO</a>
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_vorbis_comment">FLAC format
+   *     METADATA_BLOCK_VORBIS_COMMENT</a>
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_picture">FLAC format
+   *     METADATA_BLOCK_PICTURE</a>
    */
-  public FlacStreamInfo(
+  public FlacStreamMetadata(
       int minBlockSize,
       int maxBlockSize,
       int minFrameSize,
@@ -76,7 +88,9 @@ public FlacStreamInfo(
       int sampleRate,
       int channels,
       int bitsPerSample,
-      long totalSamples) {
+      long totalSamples,
+      List<String> vorbisComments,
+      List<PictureFrame> pictureFrames) {
     this.minBlockSize = minBlockSize;
     this.maxBlockSize = maxBlockSize;
     this.minFrameSize = minFrameSize;
@@ -85,6 +99,7 @@ public FlacStreamInfo(
     this.channels = channels;
     this.bitsPerSample = bitsPerSample;
     this.totalSamples = totalSamples;
+    this.metadata = buildMetadata(vorbisComments, pictureFrames);
   }
 
   /** Returns the maximum size for a decoded frame from the FLAC stream. */
@@ -126,4 +141,27 @@ public long getApproxBytesPerFrame() {
     }
     return approxBytesPerFrame;
   }
+
+  @Nullable
+  private static Metadata buildMetadata(
+      List<String> vorbisComments, List<PictureFrame> pictureFrames) {
+    if (vorbisComments.isEmpty() && pictureFrames.isEmpty()) {
+      return null;
+    }
+
+    ArrayList<Metadata.Entry> metadataEntries = new ArrayList<>();
+    for (int i = 0; i < vorbisComments.size(); i++) {
+      String vorbisComment = vorbisComments.get(i);
+      String[] keyAndValue = Util.splitAtFirst(vorbisComment, SEPARATOR);
+      if (keyAndValue.length != 2) {
+        Log.w(TAG, "Failed to parse vorbis comment: " + vorbisComment);
+      } else {
+        VorbisComment entry = new VorbisComment(keyAndValue[0], keyAndValue[1]);
+        metadataEntries.add(entry);
+      }
+    }
+    metadataEntries.addAll(pictureFrames);
+
+    return metadataEntries.isEmpty() ? null : new Metadata(metadataEntries);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index e603f76dbc..61457c308d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -348,8 +348,9 @@ public static int getTrackType(@Nullable String mimeType) {
       case MimeTypes.AUDIO_AC3:
         return C.ENCODING_AC3;
       case MimeTypes.AUDIO_E_AC3:
-      case MimeTypes.AUDIO_E_AC3_JOC:
         return C.ENCODING_E_AC3;
+      case MimeTypes.AUDIO_E_AC3_JOC:
+        return C.ENCODING_E_AC3_JOC;
       case MimeTypes.AUDIO_AC4:
         return C.ENCODING_AC4;
       case MimeTypes.AUDIO_DTS:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
index 4cd03f566d..756494f9d0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
@@ -61,6 +61,14 @@
   /** @see NotificationManager#IMPORTANCE_HIGH */
   public static final int IMPORTANCE_HIGH = NotificationManager.IMPORTANCE_HIGH;
 
+  /** @deprecated Use {@link #createNotificationChannel(Context, String, int, int, int)}. */
+  @Deprecated
+  public static void createNotificationChannel(
+      Context context, String id, @StringRes int nameResourceId, @Importance int importance) {
+    createNotificationChannel(
+        context, id, nameResourceId, /* descriptionResourceId= */ 0, importance);
+  }
+
   /**
    * Creates a notification channel that notifications can be posted to. See {@link
    * NotificationChannel} and {@link
@@ -70,21 +78,33 @@
    * @param id The id of the channel. Must be unique per package. The value may be truncated if it's
    *     too long.
    * @param nameResourceId A string resource identifier for the user visible name of the channel.
-   *     You can rename this channel when the system locale changes by listening for the {@link
-   *     Intent#ACTION_LOCALE_CHANGED} broadcast. The recommended maximum length is 40 characters.
-   *     The value may be truncated if it is too long.
+   *     The recommended maximum length is 40 characters. The string may be truncated if it's too
+   *     long. You can rename the channel when the system locale changes by listening for the {@link
+   *     Intent#ACTION_LOCALE_CHANGED} broadcast.
+   * @param descriptionResourceId A string resource identifier for the user visible description of
+   *     the channel, or 0 if no description is provided. The recommended maximum length is 300
+   *     characters. The value may be truncated if it is too long. You can change the description of
+   *     the channel when the system locale changes by listening for the {@link
+   *     Intent#ACTION_LOCALE_CHANGED} broadcast.
    * @param importance The importance of the channel. This controls how interruptive notifications
    *     posted to this channel are. One of {@link #IMPORTANCE_UNSPECIFIED}, {@link
    *     #IMPORTANCE_NONE}, {@link #IMPORTANCE_MIN}, {@link #IMPORTANCE_LOW}, {@link
    *     #IMPORTANCE_DEFAULT} and {@link #IMPORTANCE_HIGH}.
    */
   public static void createNotificationChannel(
-      Context context, String id, @StringRes int nameResourceId, @Importance int importance) {
+      Context context,
+      String id,
+      @StringRes int nameResourceId,
+      @StringRes int descriptionResourceId,
+      @Importance int importance) {
     if (Util.SDK_INT >= 26) {
       NotificationManager notificationManager =
           (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
       NotificationChannel channel =
           new NotificationChannel(id, context.getString(nameResourceId), importance);
+      if (descriptionResourceId != 0) {
+        channel.setDescription(context.getString(descriptionResourceId));
+      }
       notificationManager.createNotificationChannel(channel);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index 97bcb68708..095394b2f5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -71,6 +71,7 @@
 import java.util.Collections;
 import java.util.Formatter;
 import java.util.GregorianCalendar;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.MissingResourceException;
@@ -135,6 +136,10 @@
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
   private static final Pattern ESCAPED_CHARACTER_PATTERN = Pattern.compile("%([A-Fa-f0-9]{2})");
 
+  // Android standardizes to ISO 639-1 2-letter codes and provides no way to map a 3-letter
+  // ISO 639-2 code back to the corresponding 2-letter code.
+  @Nullable private static HashMap<String, String> languageTagIso3ToIso2;
+
   private Util() {}
 
   /**
@@ -450,18 +455,31 @@ public static void writeBoolean(Parcel parcel, boolean value) {
     if (language == null) {
       return null;
     }
-    try {
-      Locale locale = getLocaleForLanguageTag(language);
-      int localeLanguageLength = locale.getLanguage().length();
-      String normLanguage = locale.getISO3Language();
-      if (normLanguage.isEmpty()) {
-        return toLowerInvariant(language);
+    // Locale data (especially for API < 21) may produce tags with '_' instead of the
+    // standard-conformant '-'.
+    String normalizedTag = language.replace('_', '-');
+    if (Util.SDK_INT >= 21) {
+      // Filters out ill-formed sub-tags, replaces deprecated tags and normalizes all valid tags.
+      normalizedTag = normalizeLanguageCodeSyntaxV21(normalizedTag);
+    }
+    if (normalizedTag.isEmpty() || "und".equals(normalizedTag)) {
+      // Tag isn't valid, keep using the original.
+      normalizedTag = language;
+    }
+    normalizedTag = Util.toLowerInvariant(normalizedTag);
+    String mainLanguage = Util.splitAtFirst(normalizedTag, "-")[0];
+    if (mainLanguage.length() == 3) {
+      // 3-letter ISO 639-2/B or ISO 639-2/T language codes will not be converted to 2-letter ISO
+      // 639-1 codes automatically.
+      if (languageTagIso3ToIso2 == null) {
+        languageTagIso3ToIso2 = createIso3ToIso2Map();
+      }
+      String iso2Language = languageTagIso3ToIso2.get(mainLanguage);
+      if (iso2Language != null) {
+        normalizedTag = iso2Language + normalizedTag.substring(/* beginIndex= */ 3);
       }
-      String normTag = getLocaleLanguageTag(locale);
-      return toLowerInvariant(normLanguage + normTag.substring(localeLanguageLength));
-    } catch (MissingResourceException e) {
-      return toLowerInvariant(language);
     }
+    return normalizedTag;
   }
 
   /**
@@ -1713,7 +1731,12 @@ public static int getNetworkType(Context context) {
     if (connectivityManager == null) {
       return C.NETWORK_TYPE_UNKNOWN;
     }
-    networkInfo = connectivityManager.getActiveNetworkInfo();
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (SecurityException e) {
+      // Expected if permission was revoked.
+      return C.NETWORK_TYPE_UNKNOWN;
+    }
     if (networkInfo == null || !networkInfo.isConnected()) {
       return C.NETWORK_TYPE_OFFLINE;
     }
@@ -1950,32 +1973,25 @@ private static void getDisplaySizeV16(Display display, Point outSize) {
   }
 
   private static String[] getSystemLocales() {
+    Configuration config = Resources.getSystem().getConfiguration();
     return SDK_INT >= 24
-        ? getSystemLocalesV24()
-        : new String[] {getLocaleLanguageTag(Resources.getSystem().getConfiguration().locale)};
+        ? getSystemLocalesV24(config)
+        : SDK_INT >= 21 ? getSystemLocaleV21(config) : new String[] {config.locale.toString()};
   }
 
   @TargetApi(24)
-  private static String[] getSystemLocalesV24() {
-    return Util.split(Resources.getSystem().getConfiguration().getLocales().toLanguageTags(), ",");
-  }
-
-  private static Locale getLocaleForLanguageTag(String languageTag) {
-    return Util.SDK_INT >= 21 ? getLocaleForLanguageTagV21(languageTag) : new Locale(languageTag);
+  private static String[] getSystemLocalesV24(Configuration config) {
+    return Util.split(config.getLocales().toLanguageTags(), ",");
   }
 
   @TargetApi(21)
-  private static Locale getLocaleForLanguageTagV21(String languageTag) {
-    return Locale.forLanguageTag(languageTag);
-  }
-
-  private static String getLocaleLanguageTag(Locale locale) {
-    return SDK_INT >= 21 ? getLocaleLanguageTagV21(locale) : locale.toString();
+  private static String[] getSystemLocaleV21(Configuration config) {
+    return new String[] {config.locale.toLanguageTag()};
   }
 
   @TargetApi(21)
-  private static String getLocaleLanguageTagV21(Locale locale) {
-    return locale.toLanguageTag();
+  private static String normalizeLanguageCodeSyntaxV21(String languageTag) {
+    return Locale.forLanguageTag(languageTag).toLanguageTag();
   }
 
   private static @C.NetworkType int getMobileNetworkType(NetworkInfo networkInfo) {
@@ -2008,6 +2024,54 @@ private static String getLocaleLanguageTagV21(Locale locale) {
     }
   }
 
+  private static HashMap<String, String> createIso3ToIso2Map() {
+    String[] iso2Languages = Locale.getISOLanguages();
+    HashMap<String, String> iso3ToIso2 =
+        new HashMap<>(
+            /* initialCapacity= */ iso2Languages.length + iso3BibliographicalToIso2.length);
+    for (String iso2 : iso2Languages) {
+      try {
+        // This returns the ISO 639-2/T code for the language.
+        String iso3 = new Locale(iso2).getISO3Language();
+        if (!TextUtils.isEmpty(iso3)) {
+          iso3ToIso2.put(iso3, iso2);
+        }
+      } catch (MissingResourceException e) {
+        // Shouldn't happen for list of known languages, but we don't want to throw either.
+      }
+    }
+    // Add additional ISO 639-2/B codes to mapping.
+    for (int i = 0; i < iso3BibliographicalToIso2.length; i += 2) {
+      iso3ToIso2.put(iso3BibliographicalToIso2[i], iso3BibliographicalToIso2[i + 1]);
+    }
+    return iso3ToIso2;
+  }
+
+  // See https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes.
+  private static final String[] iso3BibliographicalToIso2 =
+      new String[] {
+        "alb", "sq",
+        "arm", "hy",
+        "baq", "eu",
+        "bur", "my",
+        "tib", "bo",
+        "chi", "zh",
+        "cze", "cs",
+        "dut", "nl",
+        "ger", "de",
+        "gre", "el",
+        "fre", "fr",
+        "geo", "ka",
+        "ice", "is",
+        "mac", "mk",
+        "mao", "mi",
+        "may", "ms",
+        "per", "fa",
+        "rum", "ro",
+        "slo", "sk",
+        "wel", "cy"
+      };
+
   /**
    * Allows the CRC calculation to be done byte by byte instead of bit per bit being the order
    * "most significant bit first".
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 193fbddfec..b5a935c15f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -550,12 +550,13 @@ protected void configureCodec(
       MediaCodec codec,
       Format format,
       MediaCrypto crypto,
-      float codecOperatingRate)
-      throws DecoderQueryException {
+      float codecOperatingRate) {
+    String codecMimeType = codecInfo.codecMimeType;
     codecMaxValues = getCodecMaxValues(codecInfo, format, getStreamFormats());
     MediaFormat mediaFormat =
         getMediaFormat(
             format,
+            codecMimeType,
             codecMaxValues,
             codecOperatingRate,
             deviceNeedsNoPostProcessWorkaround,
@@ -680,7 +681,8 @@ protected boolean processOutputBuffer(
       int bufferIndex,
       int bufferFlags,
       long bufferPresentationTimeUs,
-      boolean shouldSkip,
+      boolean isDecodeOnlyBuffer,
+      boolean isLastBuffer,
       Format format)
       throws ExoPlaybackException {
     if (initialPositionUs == C.TIME_UNSET) {
@@ -689,7 +691,7 @@ protected boolean processOutputBuffer(
 
     long presentationTimeUs = bufferPresentationTimeUs - outputStreamOffsetUs;
 
-    if (shouldSkip) {
+    if (isDecodeOnlyBuffer && !isLastBuffer) {
       skipOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -737,10 +739,10 @@ protected boolean processOutputBuffer(
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
+    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs, isLastBuffer)
         && maybeDropBuffersToKeyframe(codec, bufferIndex, presentationTimeUs, positionUs)) {
       return false;
-    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
+    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs, isLastBuffer)) {
       dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
       return true;
     }
@@ -808,8 +810,8 @@ private void notifyFrameMetadataListener(
 
   /**
    * Returns the offset that should be subtracted from {@code bufferPresentationTimeUs} in {@link
-   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, Format)} to
-   * get the playback position with respect to the media.
+   * #processOutputBuffer(long, long, MediaCodec, ByteBuffer, int, int, long, boolean, boolean,
+   * Format)} to get the playback position with respect to the media.
    */
   protected long getOutputStreamOffsetUs() {
     return outputStreamOffsetUs;
@@ -861,9 +863,11 @@ protected void onProcessedOutputBuffer(long presentationTimeUs) {
    *     indicates that the buffer is late.
    * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
    *     measured at the start of the current iteration of the rendering loop.
+   * @param isLastBuffer Whether the buffer is the last buffer in the current stream.
    */
-  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferLate(earlyUs);
+  protected boolean shouldDropOutputBuffer(
+      long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {
+    return isBufferLate(earlyUs) && !isLastBuffer;
   }
 
   /**
@@ -874,9 +878,11 @@ protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
    *     negative value indicates that the buffer is late.
    * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
    *     measured at the start of the current iteration of the rendering loop.
+   * @param isLastBuffer Whether the buffer is the last buffer in the current stream.
    */
-  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferVeryLate(earlyUs);
+  protected boolean shouldDropBuffersToKeyframe(
+      long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {
+    return isBufferVeryLate(earlyUs) && !isLastBuffer;
   }
 
   /**
@@ -1107,6 +1113,7 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
    * Returns the framework {@link MediaFormat} that should be used to configure the decoder.
    *
    * @param format The format of media.
+   * @param codecMimeType The MIME type handled by the codec.
    * @param codecMaxValues Codec max values that should be used when configuring the decoder.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
@@ -1119,13 +1126,14 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
   @SuppressLint("InlinedApi")
   protected MediaFormat getMediaFormat(
       Format format,
+      String codecMimeType,
       CodecMaxValues codecMaxValues,
       float codecOperatingRate,
       boolean deviceNeedsNoPostProcessWorkaround,
       int tunnelingAudioSessionId) {
     MediaFormat mediaFormat = new MediaFormat();
     // Set format parameters that should always be set.
-    mediaFormat.setString(MediaFormat.KEY_MIME, format.sampleMimeType);
+    mediaFormat.setString(MediaFormat.KEY_MIME, codecMimeType);
     mediaFormat.setInteger(MediaFormat.KEY_WIDTH, format.width);
     mediaFormat.setInteger(MediaFormat.KEY_HEIGHT, format.height);
     MediaFormatUtil.setCsdBuffers(mediaFormat, format.initializationData);
@@ -1173,11 +1181,9 @@ protected MediaFormat getMediaFormat(
    * @param format The format for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
   protected CodecMaxValues getCodecMaxValues(
-      MediaCodecInfo codecInfo, Format format, Format[] streamFormats)
-      throws DecoderQueryException {
+      MediaCodecInfo codecInfo, Format format, Format[] streamFormats) {
     int maxWidth = format.width;
     int maxHeight = format.height;
     int maxInputSize = getMaxInputSize(codecInfo, format);
@@ -1227,17 +1233,15 @@ protected CodecMaxValues getCodecMaxValues(
   }
 
   /**
-   * Returns a maximum video size to use when configuring a codec for {@code format} in a way
-   * that will allow possible adaptation to other compatible formats that are expected to have the
-   * same aspect ratio, but whose sizes are unknown.
+   * Returns a maximum video size to use when configuring a codec for {@code format} in a way that
+   * will allow possible adaptation to other compatible formats that are expected to have the same
+   * aspect ratio, but whose sizes are unknown.
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format for which the codec is being configured.
    * @return The maximum video size to use, or null if the size of {@code format} should be used.
-   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
-      throws DecoderQueryException {
+  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format) {
     boolean isVerticalVideo = format.height > format.width;
     int formatLongEdgePx = isVerticalVideo ? format.height : format.width;
     int formatShortEdgePx = isVerticalVideo ? format.width : format.height;
@@ -1255,12 +1259,18 @@ private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
           return alignedSize;
         }
       } else {
-        // Conservatively assume the codec requires 16px width and height alignment.
-        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
-        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
-        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
-          return new Point(isVerticalVideo ? shortEdgePx : longEdgePx,
-              isVerticalVideo ? longEdgePx : shortEdgePx);
+        try {
+          // Conservatively assume the codec requires 16px width and height alignment.
+          longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
+          shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
+          if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
+            return new Point(
+                isVerticalVideo ? shortEdgePx : longEdgePx,
+                isVerticalVideo ? longEdgePx : shortEdgePx);
+          }
+        } catch (DecoderQueryException e) {
+          // We tried our best. Give up!
+          return null;
         }
       }
     }
@@ -1423,6 +1433,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
             case "1713":
             case "1714":
             case "A10-70F":
+            case "A10-70L":
             case "A1601":
             case "A2016a40":
             case "A7000-a":
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
index d4df3ffeba..96b0cd259c 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26122
+  duration = 26125
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/webvtt/with_css_styles b/library/core/src/test/assets/webvtt/with_css_styles
index 2056d50adf..c2d47d8192 100644
--- a/library/core/src/test/assets/webvtt/with_css_styles
+++ b/library/core/src/test/assets/webvtt/with_css_styles
@@ -13,8 +13,6 @@ STYLE
 ::cue(#id2) {
   color: peachpuff;
 }
-
-STYLE
 ::cue(v[voice="LaGord"]) { background-color: lime }
 
 STYLE
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index a715289a04..2203b34e86 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -20,6 +20,7 @@
 
 import android.content.Context;
 import android.graphics.SurfaceTexture;
+import android.net.Uri;
 import androidx.annotation.Nullable;
 import android.view.Surface;
 import androidx.test.core.app.ApplicationProvider;
@@ -2608,6 +2609,56 @@ public void run(SimpleExoPlayer player) {
     assertThat(bufferedPositionAtFirstDiscontinuityMs.get()).isEqualTo(C.usToMs(windowDurationUs));
   }
 
+  @Test
+  public void contentWithInitialSeekPositionAfterPrerollAdStartsAtSeekPosition() throws Exception {
+    AdPlaybackState adPlaybackState =
+        FakeTimeline.createAdPlaybackState(/* adsPerAdGroup= */ 3, /* adGroupTimesUs= */ 0)
+            .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, Uri.parse("https://ad1"))
+            .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 1, Uri.parse("https://ad2"))
+            .withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 2, Uri.parse("https://ad3"));
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount= */ 1,
+                /* id= */ 0,
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 10_000_000,
+                adPlaybackState));
+    final FakeMediaSource fakeMediaSource = new FakeMediaSource(fakeTimeline, null);
+    AtomicReference<Player> playerReference = new AtomicReference<>();
+    AtomicLong contentStartPositionMs = new AtomicLong(C.TIME_UNSET);
+    EventListener eventListener =
+        new EventListener() {
+          @Override
+          public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+            if (reason == Player.DISCONTINUITY_REASON_AD_INSERTION) {
+              contentStartPositionMs.set(playerReference.get().getContentPosition());
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("contentWithInitialSeekAfterPrerollAd")
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    playerReference.set(player);
+                    player.addListener(eventListener);
+                  }
+                })
+            .seek(5_000)
+            .build();
+    new ExoPlayerTestRunner.Builder()
+        .setMediaSource(fakeMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(contentStartPositionMs.get()).isAtLeast(5_000L);
+  }
+
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
index 8d1818845d..8ba0be26a0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
@@ -16,13 +16,16 @@
 package com.google.android.exoplayer2.extractor.ogg;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.OggTestData;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.Random;
 import org.junit.Test;
@@ -32,13 +35,15 @@
 @RunWith(AndroidJUnit4.class)
 public final class DefaultOggSeekerTest {
 
+  private final Random random = new Random(0);
+
   @Test
   public void testSetupWithUnsetEndPositionFails() {
     try {
       new DefaultOggSeeker(
-          /* startPosition= */ 0,
-          /* endPosition= */ C.LENGTH_UNSET,
           /* streamReader= */ new TestStreamReader(),
+          /* payloadStartPosition= */ 0,
+          /* payloadEndPosition= */ C.LENGTH_UNSET,
           /* firstPayloadPageSize= */ 1,
           /* firstPayloadPageGranulePosition= */ 1,
           /* firstPayloadPageIsLastPage= */ false);
@@ -56,17 +61,106 @@ public void testSeeking() throws IOException, InterruptedException {
     }
   }
 
+  @Test
+  public void testSkipToNextPage() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                TestUtil.buildTestData(4000, random),
+                new byte[] {'O', 'g', 'g', 'S'},
+                TestUtil.buildTestData(4000, random)),
+            false);
+    skipToNextPage(extractorInput);
+    assertThat(extractorInput.getPosition()).isEqualTo(4000);
+  }
+
+  @Test
+  public void testSkipToNextPageOverlap() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                TestUtil.buildTestData(2046, random),
+                new byte[] {'O', 'g', 'g', 'S'},
+                TestUtil.buildTestData(4000, random)),
+            false);
+    skipToNextPage(extractorInput);
+    assertThat(extractorInput.getPosition()).isEqualTo(2046);
+  }
+
+  @Test
+  public void testSkipToNextPageInputShorterThanPeekLength() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(new byte[] {'x', 'O', 'g', 'g', 'S'}), false);
+    skipToNextPage(extractorInput);
+    assertThat(extractorInput.getPosition()).isEqualTo(1);
+  }
+
+  @Test
+  public void testSkipToNextPageNoMatch() throws Exception {
+    FakeExtractorInput extractorInput =
+        OggTestData.createInput(new byte[] {'g', 'g', 'S', 'O', 'g', 'g'}, false);
+    try {
+      skipToNextPage(extractorInput);
+      fail();
+    } catch (EOFException e) {
+      // expected
+    }
+  }
+
+  @Test
+  public void testReadGranuleOfLastPage() throws IOException, InterruptedException {
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                TestUtil.buildTestData(100, random),
+                OggTestData.buildOggHeader(0x00, 20000, 66, 3),
+                TestUtil.createByteArray(254, 254, 254), // laces
+                TestUtil.buildTestData(3 * 254, random),
+                OggTestData.buildOggHeader(0x00, 40000, 67, 3),
+                TestUtil.createByteArray(254, 254, 254), // laces
+                TestUtil.buildTestData(3 * 254, random),
+                OggTestData.buildOggHeader(0x05, 60000, 68, 3),
+                TestUtil.createByteArray(254, 254, 254), // laces
+                TestUtil.buildTestData(3 * 254, random)),
+            false);
+    assertReadGranuleOfLastPage(input, 60000);
+  }
+
+  @Test
+  public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, InterruptedException {
+    FakeExtractorInput input = OggTestData.createInput(TestUtil.buildTestData(100, random), false);
+    try {
+      assertReadGranuleOfLastPage(input, 60000);
+      fail();
+    } catch (EOFException e) {
+      // Ignored.
+    }
+  }
+
+  @Test
+  public void testReadGranuleOfLastPageWithUnboundedLength()
+      throws IOException, InterruptedException {
+    FakeExtractorInput input = OggTestData.createInput(new byte[0], true);
+    try {
+      assertReadGranuleOfLastPage(input, 60000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Ignored.
+    }
+  }
+
   private void testSeeking(Random random) throws IOException, InterruptedException {
     OggTestFile testFile = OggTestFile.generate(random, 1000);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(testFile.data).build();
     TestStreamReader streamReader = new TestStreamReader();
     DefaultOggSeeker oggSeeker =
         new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ testFile.data.length,
             /* streamReader= */ streamReader,
+            /* payloadStartPosition= */ 0,
+            /* payloadEndPosition= */ testFile.data.length,
             /* firstPayloadPageSize= */ testFile.firstPayloadPageSize,
-            /* firstPayloadPageGranulePosition= */ testFile.firstPayloadPageGranulePosition,
+            /* firstPayloadPageGranulePosition= */ testFile.firstPayloadPageGranuleCount,
             /* firstPayloadPageIsLastPage= */ false);
     OggPageHeader pageHeader = new OggPageHeader();
 
@@ -78,89 +172,96 @@ private void testSeeking(Random random) throws IOException, InterruptedException
       input.setPosition((int) nextSeekPosition);
     }
 
-    // Test granule 0 from file start
-    assertThat(seekTo(input, oggSeeker, 0, 0)).isEqualTo(0);
+    // Test granule 0 from file start.
+    long granule = seekTo(input, oggSeeker, 0, 0);
+    assertThat(granule).isEqualTo(0);
     assertThat(input.getPosition()).isEqualTo(0);
 
-    // Test granule 0 from file end
-    assertThat(seekTo(input, oggSeeker, 0, testFile.data.length - 1)).isEqualTo(0);
+    // Test granule 0 from file end.
+    granule = seekTo(input, oggSeeker, 0, testFile.data.length - 1);
+    assertThat(granule).isEqualTo(0);
     assertThat(input.getPosition()).isEqualTo(0);
 
-    { // Test last granule
-      long currentGranule = seekTo(input, oggSeeker, testFile.lastGranule, 0);
-      long position = testFile.data.length;
-      assertThat(
-              (testFile.lastGranule > currentGranule && position > input.getPosition())
-                  || (testFile.lastGranule == currentGranule && position == input.getPosition()))
-          .isTrue();
-    }
-
-    { // Test exact granule
-      input.setPosition(testFile.data.length / 2);
-      oggSeeker.skipToNextPage(input);
-      assertThat(pageHeader.populate(input, true)).isTrue();
-      long position = input.getPosition() + pageHeader.headerSize + pageHeader.bodySize;
-      long currentGranule = seekTo(input, oggSeeker, pageHeader.granulePosition, 0);
-      assertThat(
-              (pageHeader.granulePosition > currentGranule && position > input.getPosition())
-                  || (pageHeader.granulePosition == currentGranule
-                      && position == input.getPosition()))
-          .isTrue();
-    }
+    // Test last granule.
+    granule = seekTo(input, oggSeeker, testFile.granuleCount - 1, 0);
+    assertThat(granule).isEqualTo(testFile.granuleCount - testFile.lastPayloadPageGranuleCount);
+    assertThat(input.getPosition()).isEqualTo(testFile.data.length - testFile.lastPayloadPageSize);
 
     for (int i = 0; i < 100; i += 1) {
-      long targetGranule = (long) (random.nextDouble() * testFile.lastGranule);
+      long targetGranule = random.nextInt(testFile.granuleCount);
       int initialPosition = random.nextInt(testFile.data.length);
-
-      long currentGranule = seekTo(input, oggSeeker, targetGranule, initialPosition);
+      granule = seekTo(input, oggSeeker, targetGranule, initialPosition);
       long currentPosition = input.getPosition();
-
-      assertWithMessage("getNextSeekPosition() didn't leave input on a page start.")
-          .that(pageHeader.populate(input, true))
-          .isTrue();
-
-      if (currentGranule == 0) {
+      if (granule == 0) {
         assertThat(currentPosition).isEqualTo(0);
       } else {
         int previousPageStart = testFile.findPreviousPageStart(currentPosition);
         input.setPosition(previousPageStart);
-        assertThat(pageHeader.populate(input, true)).isTrue();
-        assertThat(currentGranule).isEqualTo(pageHeader.granulePosition);
+        pageHeader.populate(input, false);
+        assertThat(granule).isEqualTo(pageHeader.granulePosition);
       }
 
       input.setPosition((int) currentPosition);
-      oggSeeker.skipToPageOfGranule(input, targetGranule, -1);
-      long positionDiff = Math.abs(input.getPosition() - currentPosition);
-
-      long granuleDiff = currentGranule - targetGranule;
-      if ((granuleDiff > DefaultOggSeeker.MATCH_RANGE || granuleDiff < 0)
-          && positionDiff > DefaultOggSeeker.MATCH_BYTE_RANGE) {
-        fail(
-            "granuleDiff ("
-                + granuleDiff
-                + ") or positionDiff ("
-                + positionDiff
-                + ") is more than allowed.");
+      pageHeader.populate(input, false);
+      // The target granule should be within the current page.
+      assertThat(granule).isAtMost(targetGranule);
+      assertThat(targetGranule).isLessThan(pageHeader.granulePosition);
+    }
+  }
+
+  private static void skipToNextPage(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* streamReader= */ new FlacReader(),
+            /* payloadStartPosition= */ 0,
+            /* payloadEndPosition= */ extractorInput.getLength(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
+    while (true) {
+      try {
+        oggSeeker.skipToNextPage(extractorInput);
+        break;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        /* ignored */
       }
     }
   }
 
-  private long seekTo(
+  private static void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
+      throws IOException, InterruptedException {
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            /* streamReader= */ new FlacReader(),
+            /* payloadStartPosition= */ 0,
+            /* payloadEndPosition= */ input.getLength(),
+            /* firstPayloadPageSize= */ 1,
+            /* firstPayloadPageGranulePosition= */ 2,
+            /* firstPayloadPageIsLastPage= */ false);
+    while (true) {
+      try {
+        assertThat(oggSeeker.readGranuleOfLastPage(input)).isEqualTo(expected);
+        break;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        // Ignored.
+      }
+    }
+  }
+
+  private static long seekTo(
       FakeExtractorInput input, DefaultOggSeeker oggSeeker, long targetGranule, int initialPosition)
       throws IOException, InterruptedException {
     long nextSeekPosition = initialPosition;
+    oggSeeker.startSeek(targetGranule);
     int count = 0;
-    oggSeeker.resetSeeking();
-
-    do {
-      input.setPosition((int) nextSeekPosition);
-      nextSeekPosition = oggSeeker.getNextSeekPosition(targetGranule, input);
-
+    while (nextSeekPosition >= 0) {
       if (count++ > 100) {
-        fail("infinite loop?");
+        fail("Seek failed to converge in 100 iterations");
       }
-    } while (nextSeekPosition >= 0);
-
+      input.setPosition((int) nextSeekPosition);
+      nextSeekPosition = oggSeeker.read(input);
+    }
     return -(nextSeekPosition + 2);
   }
 
@@ -171,8 +272,7 @@ protected long preparePayload(ParsableByteArray packet) {
     }
 
     @Override
-    protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
-        throws IOException, InterruptedException {
+    protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData) {
       return false;
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
deleted file mode 100644
index d6691f50f8..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.extractor.ogg;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.testutil.FakeExtractorInput;
-import com.google.android.exoplayer2.testutil.OggTestData;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Random;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Unit test for {@link DefaultOggSeeker} utility methods. */
-@RunWith(AndroidJUnit4.class)
-public final class DefaultOggSeekerUtilMethodsTest {
-
-  private final Random random = new Random(0);
-
-  @Test
-  public void testSkipToNextPage() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            TestUtil.buildTestData(4000, random),
-            new byte[] {'O', 'g', 'g', 'S'},
-            TestUtil.buildTestData(4000, random)
-        ), false);
-    skipToNextPage(extractorInput);
-    assertThat(extractorInput.getPosition()).isEqualTo(4000);
-  }
-
-  @Test
-  public void testSkipToNextPageOverlap() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            TestUtil.buildTestData(2046, random),
-            new byte[] {'O', 'g', 'g', 'S'},
-            TestUtil.buildTestData(4000, random)
-        ), false);
-    skipToNextPage(extractorInput);
-    assertThat(extractorInput.getPosition()).isEqualTo(2046);
-  }
-
-  @Test
-  public void testSkipToNextPageInputShorterThanPeekLength() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            new byte[] {'x', 'O', 'g', 'g', 'S'}
-        ), false);
-    skipToNextPage(extractorInput);
-    assertThat(extractorInput.getPosition()).isEqualTo(1);
-  }
-
-  @Test
-  public void testSkipToNextPageNoMatch() throws Exception {
-    FakeExtractorInput extractorInput = OggTestData.createInput(
-        new byte[] {'g', 'g', 'S', 'O', 'g', 'g'}, false);
-    try {
-      skipToNextPage(extractorInput);
-      fail();
-    } catch (EOFException e) {
-      // expected
-    }
-  }
-
-  private static void skipToNextPage(ExtractorInput extractorInput)
-      throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker =
-        new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ extractorInput.getLength(),
-            /* streamReader= */ new FlacReader(),
-            /* firstPayloadPageSize= */ 1,
-            /* firstPayloadPageGranulePosition= */ 2,
-            /* firstPayloadPageIsLastPage= */ false);
-    while (true) {
-      try {
-        oggSeeker.skipToNextPage(extractorInput);
-        break;
-      } catch (FakeExtractorInput.SimulatedIOException e) { /* ignored */ }
-    }
-  }
-
-  @Test
-  public void testSkipToPageOfGranule() throws IOException, InterruptedException {
-    byte[] packet = TestUtil.buildTestData(3 * 254, random);
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-
-    // expect to be granule of the previous page returned as elapsedSamples
-    skipToPageOfGranule(input, 54000, 40000);
-    // expect to be at the start of the third page
-    assertThat(input.getPosition()).isEqualTo(2 * (30 + (3 * 254)));
-  }
-
-  @Test
-  public void testSkipToPageOfGranulePreciseMatch() throws IOException, InterruptedException {
-    byte[] packet = TestUtil.buildTestData(3 * 254, random);
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-
-    skipToPageOfGranule(input, 40000, 20000);
-    // expect to be at the start of the second page
-    assertThat(input.getPosition()).isEqualTo(30 + (3 * 254));
-  }
-
-  @Test
-  public void testSkipToPageOfGranuleAfterTargetPage() throws IOException, InterruptedException {
-    byte[] packet = TestUtil.buildTestData(3 * 254, random);
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x01, 20000, 1000, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 40000, 1001, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet,
-        OggTestData.buildOggHeader(0x04, 60000, 1002, 0x03),
-        TestUtil.createByteArray(254, 254, 254), // Laces.
-        packet);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-
-    skipToPageOfGranule(input, 10000, -1);
-    assertThat(input.getPosition()).isEqualTo(0);
-  }
-
-  private void skipToPageOfGranule(ExtractorInput input, long granule,
-      long elapsedSamplesExpected) throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker =
-        new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ input.getLength(),
-            /* streamReader= */ new FlacReader(),
-            /* firstPayloadPageSize= */ 1,
-            /* firstPayloadPageGranulePosition= */ 2,
-            /* firstPayloadPageIsLastPage= */ false);
-    while (true) {
-      try {
-        assertThat(oggSeeker.skipToPageOfGranule(input, granule, -1))
-            .isEqualTo(elapsedSamplesExpected);
-        return;
-      } catch (FakeExtractorInput.SimulatedIOException e) {
-        input.resetPeekPosition();
-      }
-    }
-  }
-
-  @Test
-  public void testReadGranuleOfLastPage() throws IOException, InterruptedException {
-    FakeExtractorInput input = OggTestData.createInput(TestUtil.joinByteArrays(
-        TestUtil.buildTestData(100, random),
-        OggTestData.buildOggHeader(0x00, 20000, 66, 3),
-        TestUtil.createByteArray(254, 254, 254), // laces
-        TestUtil.buildTestData(3 * 254, random),
-        OggTestData.buildOggHeader(0x00, 40000, 67, 3),
-        TestUtil.createByteArray(254, 254, 254), // laces
-        TestUtil.buildTestData(3 * 254, random),
-        OggTestData.buildOggHeader(0x05, 60000, 68, 3),
-        TestUtil.createByteArray(254, 254, 254), // laces
-        TestUtil.buildTestData(3 * 254, random)
-    ), false);
-    assertReadGranuleOfLastPage(input, 60000);
-  }
-
-  @Test
-  public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, InterruptedException {
-    FakeExtractorInput input = OggTestData.createInput(TestUtil.buildTestData(100, random), false);
-    try {
-      assertReadGranuleOfLastPage(input, 60000);
-      fail();
-    } catch (EOFException e) {
-      // ignored
-    }
-  }
-
-  @Test
-  public void testReadGranuleOfLastPageWithUnboundedLength()
-      throws IOException, InterruptedException {
-    FakeExtractorInput input = OggTestData.createInput(new byte[0], true);
-    try {
-      assertReadGranuleOfLastPage(input, 60000);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // ignored
-    }
-  }
-
-  private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
-      throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker =
-        new DefaultOggSeeker(
-            /* startPosition= */ 0,
-            /* endPosition= */ input.getLength(),
-            /* streamReader= */ new FlacReader(),
-            /* firstPayloadPageSize= */ 1,
-            /* firstPayloadPageGranulePosition= */ 2,
-            /* firstPayloadPageIsLastPage= */ false);
-    while (true) {
-      try {
-        assertThat(oggSeeker.readGranuleOfLastPage(input)).isEqualTo(expected);
-        break;
-      } catch (FakeExtractorInput.SimulatedIOException e) {
-        // ignored
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
index e5512dda36..38e4332b16 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
@@ -30,35 +30,39 @@
   private static final int MAX_GRANULES_IN_PAGE = 100000;
 
   public final byte[] data;
-  public final long lastGranule;
-  public final int packetCount;
+  public final int granuleCount;
   public final int pageCount;
   public final int firstPayloadPageSize;
-  public final long firstPayloadPageGranulePosition;
+  public final int firstPayloadPageGranuleCount;
+  public final int lastPayloadPageSize;
+  public final int lastPayloadPageGranuleCount;
 
   private OggTestFile(
       byte[] data,
-      long lastGranule,
-      int packetCount,
+      int granuleCount,
       int pageCount,
       int firstPayloadPageSize,
-      long firstPayloadPageGranulePosition) {
+      int firstPayloadPageGranuleCount,
+      int lastPayloadPageSize,
+      int lastPayloadPageGranuleCount) {
     this.data = data;
-    this.lastGranule = lastGranule;
-    this.packetCount = packetCount;
+    this.granuleCount = granuleCount;
     this.pageCount = pageCount;
     this.firstPayloadPageSize = firstPayloadPageSize;
-    this.firstPayloadPageGranulePosition = firstPayloadPageGranulePosition;
+    this.firstPayloadPageGranuleCount = firstPayloadPageGranuleCount;
+    this.lastPayloadPageSize = lastPayloadPageSize;
+    this.lastPayloadPageGranuleCount = lastPayloadPageGranuleCount;
   }
 
   public static OggTestFile generate(Random random, int pageCount) {
     ArrayList<byte[]> fileData = new ArrayList<>();
     int fileSize = 0;
-    long granule = 0;
-    int packetLength = -1;
-    int packetCount = 0;
+    int granuleCount = 0;
     int firstPayloadPageSize = 0;
-    long firstPayloadPageGranulePosition = 0;
+    int firstPayloadPageGranuleCount = 0;
+    int lastPageloadPageSize = 0;
+    int lastPayloadPageGranuleCount = 0;
+    int packetLength = -1;
 
     for (int i = 0; i < pageCount; i++) {
       int headerType = 0x00;
@@ -71,17 +75,17 @@ public static OggTestFile generate(Random random, int pageCount) {
       if (i == pageCount - 1) {
         headerType |= 4;
       }
-      granule += random.nextInt(MAX_GRANULES_IN_PAGE - 1) + 1;
+      int pageGranuleCount = random.nextInt(MAX_GRANULES_IN_PAGE - 1) + 1;
       int pageSegmentCount = random.nextInt(MAX_SEGMENT_COUNT);
-      byte[] header = OggTestData.buildOggHeader(headerType, granule, 0, pageSegmentCount);
+      granuleCount += pageGranuleCount;
+      byte[] header = OggTestData.buildOggHeader(headerType, granuleCount, 0, pageSegmentCount);
       fileData.add(header);
-      fileSize += header.length;
+      int pageSize = header.length;
 
       byte[] laces = new byte[pageSegmentCount];
       int bodySize = 0;
       for (int j = 0; j < pageSegmentCount; j++) {
         if (packetLength < 0) {
-          packetCount++;
           if (i < pageCount - 1) {
             packetLength = random.nextInt(MAX_PACKET_LENGTH);
           } else {
@@ -96,14 +100,19 @@ public static OggTestFile generate(Random random, int pageCount) {
         packetLength -= 255;
       }
       fileData.add(laces);
-      fileSize += laces.length;
+      pageSize += laces.length;
 
       byte[] payload = TestUtil.buildTestData(bodySize, random);
       fileData.add(payload);
-      fileSize += payload.length;
+      pageSize += payload.length;
+
+      fileSize += pageSize;
       if (i == 0) {
-        firstPayloadPageSize = header.length + bodySize;
-        firstPayloadPageGranulePosition = granule;
+        firstPayloadPageSize = pageSize;
+        firstPayloadPageGranuleCount = pageGranuleCount;
+      } else if (i == pageCount - 1) {
+        lastPageloadPageSize = pageSize;
+        lastPayloadPageGranuleCount = pageGranuleCount;
       }
     }
 
@@ -115,11 +124,12 @@ public static OggTestFile generate(Random random, int pageCount) {
     }
     return new OggTestFile(
         file,
-        granule,
-        packetCount,
+        granuleCount,
         pageCount,
         firstPayloadPageSize,
-        firstPayloadPageGranulePosition);
+        firstPayloadPageGranuleCount,
+        lastPageloadPageSize,
+        lastPayloadPageGranuleCount);
   }
 
   public int findPreviousPageStart(long position) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/flac/PictureFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/flac/PictureFrameTest.java
new file mode 100644
index 0000000000..3f07dbc26d
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/flac/PictureFrameTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.flac;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link PictureFrame}. */
+@RunWith(AndroidJUnit4.class)
+public final class PictureFrameTest {
+
+  @Test
+  public void testParcelable() {
+    PictureFrame pictureFrameToParcel = new PictureFrame(0, "", "", 0, 0, 0, 0, new byte[0]);
+
+    Parcel parcel = Parcel.obtain();
+    pictureFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    PictureFrame pictureFrameFromParcel = PictureFrame.CREATOR.createFromParcel(parcel);
+    assertThat(pictureFrameFromParcel).isEqualTo(pictureFrameToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/flac/VorbisCommentTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/flac/VorbisCommentTest.java
new file mode 100644
index 0000000000..bb118e381a
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/flac/VorbisCommentTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.flac;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Test for {@link VorbisComment}. */
+@RunWith(AndroidJUnit4.class)
+public final class VorbisCommentTest {
+
+  @Test
+  public void testParcelable() {
+    VorbisComment vorbisCommentFrameToParcel = new VorbisComment("key", "value");
+
+    Parcel parcel = Parcel.obtain();
+    vorbisCommentFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    VorbisComment vorbisCommentFrameFromParcel = VorbisComment.CREATOR.createFromParcel(parcel);
+    assertThat(vorbisCommentFrameFromParcel).isEqualTo(vorbisCommentFrameToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
index 9cbcea5814..4602d172a6 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
@@ -48,6 +48,17 @@ public void decode_titleOnly() {
     assertThat(streamInfo.url).isNull();
   }
 
+  @Test
+  public void decode_emptyTitle() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEmpty();
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
   @Test
   public void decode_semiColonInTitle() {
     IcyDecoder decoder = new IcyDecoder();
@@ -70,6 +81,17 @@ public void decode_quoteInTitle() {
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
 
+  @Test
+  public void decode_lineTerminatorInTitle() {
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode("StreamTitle='test\r\ntitle';StreamURL='test_url';");
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.title).isEqualTo("test\r\ntitle");
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
   @Test
   public void decode_notIcy() {
     IcyDecoder decoder = new IcyDecoder();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
index 2b9ef11235..de430d1416 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/offline/DownloadManagerTest.java
@@ -243,6 +243,27 @@ public void secondSameRemoveRequestIgnored() throws Throwable {
     downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
   }
 
+  @Test
+  public void removeAllDownloads_removesAllDownloads() throws Throwable {
+    // Finish one download and keep one running.
+    DownloadRunner runner1 = new DownloadRunner(uri1);
+    DownloadRunner runner2 = new DownloadRunner(uri2);
+    runner1.postDownloadRequest();
+    runner1.getDownloader(0).unblock();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+    runner2.postDownloadRequest();
+
+    runner1.postRemoveAllRequest();
+    runner1.getDownloader(1).unblock();
+    runner2.getDownloader(1).unblock();
+    downloadManagerListener.blockUntilTasksCompleteAndThrowAnyDownloadError();
+
+    runner1.getTask().assertRemoved();
+    runner2.getTask().assertRemoved();
+    assertThat(downloadManager.getCurrentDownloads()).isEmpty();
+    assertThat(downloadIndex.getDownloads().getCount()).isEqualTo(0);
+  }
+
   @Test
   public void differentDownloadRequestsMerged() throws Throwable {
     DownloadRunner runner = new DownloadRunner(uri1);
@@ -605,6 +626,11 @@ private DownloadRunner postRemoveRequest() {
       return this;
     }
 
+    private DownloadRunner postRemoveAllRequest() {
+      runOnMainThread(() -> downloadManager.removeAllDownloads());
+      return this;
+    }
+
     private DownloadRunner postDownloadRequest(StreamKey... keys) {
       DownloadRequest downloadRequest =
           new DownloadRequest(
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
index 000d0634ce..85af6482c0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
@@ -514,7 +514,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(24f / 100f);
     assertThat(cue.line).isEqualTo(28f / 100f);
     assertThat(cue.size).isEqualTo(51f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(12f / 100f);
 
     cues = subtitle.getCues(4000000);
     assertThat(cues).hasSize(1);
@@ -524,7 +524,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(21f / 100f);
     assertThat(cue.line).isEqualTo(35f / 100f);
     assertThat(cue.size).isEqualTo(57f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(6f / 100f);
 
     cues = subtitle.getCues(7500000);
     assertThat(cues).hasSize(1);
@@ -534,7 +534,7 @@ public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderExce
     assertThat(cue.position).isEqualTo(24f / 100f);
     assertThat(cue.line).isEqualTo(28f / 100f);
     assertThat(cue.size).isEqualTo(51f / 100f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(12f / 100f);
   }
 
   @Test
@@ -549,7 +549,7 @@ public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException
     assertThat(cue.position).isEqualTo(307f / 1280f);
     assertThat(cue.line).isEqualTo(562f / 720f);
     assertThat(cue.size).isEqualTo(653f / 1280f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(86f / 720f);
 
     cues = subtitle.getCues(4000000);
     assertThat(cues).hasSize(1);
@@ -559,7 +559,7 @@ public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException
     assertThat(cue.position).isEqualTo(269f / 1280f);
     assertThat(cue.line).isEqualTo(612f / 720f);
     assertThat(cue.size).isEqualTo(730f / 1280f);
-    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(43f / 720f);
   }
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
index fb9e1a875f..72be083181 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
@@ -21,6 +21,7 @@
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -87,21 +88,32 @@ public void testGetInputLimit() {
 
   @Test
   public void testParseMethodSimpleInput() {
-    String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     WebvttCssStyle expectedStyle = new WebvttCssStyle();
+    String styleBlock1 = " ::cue { color : black; background-color: PapayaWhip }";
     expectedStyle.setFontColor(0xFF000000);
     expectedStyle.setBackgroundColor(0xFFFFEFD5);
-    assertParserProduces(expectedStyle, styleBlock1);
+    assertParserProduces(styleBlock1, expectedStyle);
 
     String styleBlock2 = " ::cue { color : black }\n\n::cue { color : invalid }";
     expectedStyle = new WebvttCssStyle();
     expectedStyle.setFontColor(0xFF000000);
-    assertParserProduces(expectedStyle, styleBlock2);
+    assertParserProduces(styleBlock2, expectedStyle);
 
-    String styleBlock3 = " \n::cue {\n background-color\n:#00fFFe}";
+    String styleBlock3 = "::cue {\n background-color\n:#00fFFe}";
     expectedStyle = new WebvttCssStyle();
     expectedStyle.setBackgroundColor(0xFF00FFFE);
-    assertParserProduces(expectedStyle, styleBlock3);
+    assertParserProduces(styleBlock3, expectedStyle);
+  }
+
+  @Test
+  public void testParseMethodMultipleRulesInBlockInput() {
+    String styleBlock =
+        "::cue {\n background-color\n:#00fFFe}      \n::cue {\n background-color\n:#00000000}\n";
+    WebvttCssStyle expectedStyle = new WebvttCssStyle();
+    expectedStyle.setBackgroundColor(0xFF00FFFE);
+    WebvttCssStyle secondExpectedStyle = new WebvttCssStyle();
+    secondExpectedStyle.setBackgroundColor(0x000000);
+    assertParserProduces(styleBlock, expectedStyle, secondExpectedStyle);
   }
 
   @Test
@@ -116,7 +128,7 @@ public void testMultiplePropertiesInBlock() {
     expectedStyle.setFontFamily("courier");
     expectedStyle.setBold(true);
 
-    assertParserProduces(expectedStyle, styleBlock);
+    assertParserProduces(styleBlock, expectedStyle);
   }
 
   @Test
@@ -128,7 +140,7 @@ public void testRgbaColorExpression() {
     expectedStyle.setBackgroundColor(0x190A0B0C);
     expectedStyle.setFontColor(0xFF010101);
 
-    assertParserProduces(expectedStyle, styleBlock);
+    assertParserProduces(styleBlock, expectedStyle);
   }
 
   @Test
@@ -203,25 +215,29 @@ private void assertInputLimit(String expectedLine, String s) {
     assertThat(input.readLine()).isEqualTo(expectedLine);
   }
 
-  private void assertParserProduces(WebvttCssStyle expected,
-      String styleBlock){
+  private void assertParserProduces(String styleBlock, WebvttCssStyle... expectedStyles) {
     ParsableByteArray input = new ParsableByteArray(Util.getUtf8Bytes(styleBlock));
-    WebvttCssStyle actualElem = parser.parseBlock(input);
-    assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
-    if (expected.hasBackgroundColor()) {
-      assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
-    }
-    assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
-    if (expected.hasFontColor()) {
-      assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
+    List<WebvttCssStyle> styles = parser.parseBlock(input);
+    assertThat(styles.size()).isEqualTo(expectedStyles.length);
+    for (int i = 0; i < expectedStyles.length; i++) {
+      WebvttCssStyle expected = expectedStyles[i];
+      WebvttCssStyle actualElem = styles.get(i);
+      assertThat(actualElem.hasBackgroundColor()).isEqualTo(expected.hasBackgroundColor());
+      if (expected.hasBackgroundColor()) {
+        assertThat(actualElem.getBackgroundColor()).isEqualTo(expected.getBackgroundColor());
+      }
+      assertThat(actualElem.hasFontColor()).isEqualTo(expected.hasFontColor());
+      if (expected.hasFontColor()) {
+        assertThat(actualElem.getFontColor()).isEqualTo(expected.getFontColor());
+      }
+      assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
+      assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
+      assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
+      assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
+      assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
+      assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
+      assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
     }
-    assertThat(actualElem.getFontFamily()).isEqualTo(expected.getFontFamily());
-    assertThat(actualElem.getFontSize()).isEqualTo(expected.getFontSize());
-    assertThat(actualElem.getFontSizeUnit()).isEqualTo(expected.getFontSizeUnit());
-    assertThat(actualElem.getStyle()).isEqualTo(expected.getStyle());
-    assertThat(actualElem.isLinethrough()).isEqualTo(expected.isLinethrough());
-    assertThat(actualElem.isUnderline()).isEqualTo(expected.isUnderline());
-    assertThat(actualElem.getTextAlign()).isEqualTo(expected.getTextAlign());
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index 83fe34db97..224b2965ba 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -341,6 +341,76 @@ public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
     assertFixedSelection(result.selections.get(0), trackGroups, formatWithSelectionFlag);
   }
 
+  /** Tests that adaptive audio track selections respect the maximum audio bitrate. */
+  public void testSelectAdaptiveAudioTrackGroupWithMaxBitrate() throws ExoPlaybackException {
+    Format format128k =
+        Format.createAudioSampleFormat(
+            /* id= */ "128",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 128 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    Format format192k =
+        Format.createAudioSampleFormat(
+            /* id= */ "192",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 192 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    Format format256k =
+        Format.createAudioSampleFormat(
+            /* id= */ "256",
+            /* sampleMimeType= */ MimeTypes.AUDIO_AAC,
+            /* codecs= */ "mp4a.40.2",
+            /* bitrate= */ 256 * 1024,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ null);
+    RendererCapabilities[] rendererCapabilities = {
+      ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES
+    };
+    TrackGroupArray trackGroups =
+        new TrackGroupArray(new TrackGroup(format192k, format128k, format256k));
+
+    TrackSelectorResult result =
+        trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1, 2);
+
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setMaxAudioBitrate(256 * 1024 - 1));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 0, 1);
+
+    trackSelector.setParameters(
+        trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024 - 1));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1);
+
+    trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(10));
+    result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);
+    assertAdaptiveSelection(result.selections.get(0), trackGroups.get(0), 1);
+  }
+
   /**
    * Tests that track selector will select audio track with language that match preferred language
    * given by {@link Parameters}.
@@ -893,7 +963,6 @@ public void testTextTrackSelectionFlags() throws ExoPlaybackException {
     Format forcedDefault =
         buildTextFormat("forcedDefault", "eng", C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT);
     Format defaultOnly = buildTextFormat("defaultOnly", "eng", C.SELECTION_FLAG_DEFAULT);
-    Format forcedOnlySpanish = buildTextFormat("forcedOnlySpanish", "spa", C.SELECTION_FLAG_FORCED);
     Format noFlag = buildTextFormat("noFlag", "eng");
 
     RendererCapabilities[] textRendererCapabilities =
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
index 2df9a608e9..8cb142f05d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
@@ -21,6 +21,7 @@
 
 import android.net.Uri;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import org.junit.Before;
@@ -31,6 +32,9 @@
 @RunWith(AndroidJUnit4.class)
 public final class DataSchemeDataSourceTest {
 
+  private static final String DATA_SCHEME_URI =
+      "data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiLCJjb250ZW50X2lkIjoiTWpBeE5WOTBaV"
+          + "0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiXX0=";
   private DataSource schemeDataDataSource;
 
   @Before
@@ -40,9 +44,7 @@ public void setUp() {
 
   @Test
   public void testBase64Data() throws IOException {
-    DataSpec dataSpec = buildDataSpec("data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiL"
-        + "CJjb250ZW50X2lkIjoiTWpBeE5WOTBaV0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwM"
-        + "DAwMDAwMDAwMDAiXX0=");
+    DataSpec dataSpec = buildDataSpec(DATA_SCHEME_URI);
     DataSourceAsserts.assertDataSourceContent(
         schemeDataDataSource,
         dataSpec,
@@ -72,6 +74,52 @@ public void testPartialReads() throws IOException {
     assertThat(Util.fromUtf8Bytes(buffer, 0, 18)).isEqualTo("012345678901234567");
   }
 
+  @Test
+  public void testSequentialRangeRequests() throws IOException {
+    DataSpec dataSpec =
+        buildDataSpec(DATA_SCHEME_URI, /* position= */ 1, /* length= */ C.LENGTH_UNSET);
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource,
+        dataSpec,
+        Util.getUtf8Bytes(
+            "\"provider\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
+                + "[\"00000000000000000000000000000000\"]}"));
+    dataSpec = buildDataSpec(DATA_SCHEME_URI, /* position= */ 10, /* length= */ C.LENGTH_UNSET);
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource,
+        dataSpec,
+        Util.getUtf8Bytes(
+            "\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
+                + "[\"00000000000000000000000000000000\"]}"));
+    dataSpec = buildDataSpec(DATA_SCHEME_URI, /* position= */ 15, /* length= */ 5);
+    DataSourceAsserts.assertDataSourceContent(
+        schemeDataDataSource, dataSpec, Util.getUtf8Bytes("devin"));
+  }
+
+  @Test
+  public void testInvalidStartPositionRequest() throws IOException {
+    try {
+      // Try to open a range starting one byte beyond the resource's length.
+      schemeDataDataSource.open(
+          buildDataSpec(DATA_SCHEME_URI, /* position= */ 108, /* length= */ C.LENGTH_UNSET));
+      fail();
+    } catch (DataSourceException e) {
+      assertThat(e.reason).isEqualTo(DataSourceException.POSITION_OUT_OF_RANGE);
+    }
+  }
+
+  @Test
+  public void testRangeExceedingResourceLengthRequest() throws IOException {
+    try {
+      // Try to open a range exceeding the resource's length.
+      schemeDataDataSource.open(
+          buildDataSpec(DATA_SCHEME_URI, /* position= */ 97, /* length= */ 11));
+      fail();
+    } catch (DataSourceException e) {
+      assertThat(e.reason).isEqualTo(DataSourceException.POSITION_OUT_OF_RANGE);
+    }
+  }
+
   @Test
   public void testIncorrectScheme() {
     try {
@@ -99,7 +147,11 @@ public void testMalformedData() {
   }
 
   private static DataSpec buildDataSpec(String uriString) {
-    return new DataSpec(Uri.parse(uriString));
+    return buildDataSpec(uriString, /* position= */ 0, /* length= */ C.LENGTH_UNSET);
+  }
+
+  private static DataSpec buildDataSpec(String uriString, int position, int length) {
+    return new DataSpec(Uri.parse(uriString), position, length, /* key= */ null);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
index 0392f8b26d..2a1c59e7df 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
@@ -28,7 +28,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-/** Unit test for <code>ColorParser</code>. */
+/** Unit test for {@link ColorParser}. */
 @RunWith(AndroidJUnit4.class)
 public final class ColorParserTest {
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/FlacStreamMetadataTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/FlacStreamMetadataTest.java
new file mode 100644
index 0000000000..72a80161f2
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/FlacStreamMetadataTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.flac.VorbisComment;
+import java.util.ArrayList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Unit test for {@link FlacStreamMetadata}. */
+@RunWith(AndroidJUnit4.class)
+public final class FlacStreamMetadataTest {
+
+  @Test
+  public void parseVorbisComments() {
+    ArrayList<String> commentsList = new ArrayList<>();
+    commentsList.add("Title=Song");
+    commentsList.add("Artist=Singer");
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata.length()).isEqualTo(2);
+    VorbisComment commentFrame = (VorbisComment) metadata.get(0);
+    assertThat(commentFrame.key).isEqualTo("Title");
+    assertThat(commentFrame.value).isEqualTo("Song");
+    commentFrame = (VorbisComment) metadata.get(1);
+    assertThat(commentFrame.key).isEqualTo("Artist");
+    assertThat(commentFrame.value).isEqualTo("Singer");
+  }
+
+  @Test
+  public void parseEmptyVorbisComments() {
+    ArrayList<String> commentsList = new ArrayList<>();
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata).isNull();
+  }
+
+  @Test
+  public void parseVorbisCommentWithEqualsInValue() {
+    ArrayList<String> commentsList = new ArrayList<>();
+    commentsList.add("Title=So=ng");
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata.length()).isEqualTo(1);
+    VorbisComment commentFrame = (VorbisComment) metadata.get(0);
+    assertThat(commentFrame.key).isEqualTo("Title");
+    assertThat(commentFrame.value).isEqualTo("So=ng");
+  }
+
+  @Test
+  public void parseInvalidVorbisComment() {
+    ArrayList<String> commentsList = new ArrayList<>();
+    commentsList.add("TitleSong");
+    commentsList.add("Artist=Singer");
+
+    Metadata metadata =
+        new FlacStreamMetadata(0, 0, 0, 0, 0, 0, 0, 0, commentsList, new ArrayList<>()).metadata;
+
+    assertThat(metadata.length()).isEqualTo(1);
+    VorbisComment commentFrame = (VorbisComment) metadata.get(0);
+    assertThat(commentFrame.key).isEqualTo("Artist");
+    assertThat(commentFrame.value).isEqualTo("Singer");
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
index 9abec0cd8f..5a13ed0dd8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -268,14 +268,19 @@ public void testInflate() {
   @Test
   @Config(sdk = 21)
   public void testNormalizeLanguageCodeV21() {
-    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("spa");
-    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("spa");
-    assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("spa-ar");
-    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("spa-ar");
-    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("spa-ar-dialect");
-    assertThat(Util.normalizeLanguageCode("es-419")).isEqualTo("spa-419");
-    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zho-hans-tw");
-    assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zho-tw");
+    assertThat(Util.normalizeLanguageCode(null)).isNull();
+    assertThat(Util.normalizeLanguageCode("")).isEmpty();
+    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("es");
+    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("es");
+    assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es_AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("spa_ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("es-ar-dialect");
+    assertThat(Util.normalizeLanguageCode("ES-419")).isEqualTo("es-419");
+    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zh-hans-tw");
+    assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zh-tw");
+    assertThat(Util.normalizeLanguageCode("zho-hans-tw")).isEqualTo("zh-hans-tw");
     assertThat(Util.normalizeLanguageCode("und")).isEqualTo("und");
     assertThat(Util.normalizeLanguageCode("DoesNotExist")).isEqualTo("doesnotexist");
   }
@@ -283,13 +288,49 @@ public void testNormalizeLanguageCodeV21() {
   @Test
   @Config(sdk = 16)
   public void testNormalizeLanguageCode() {
-    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("spa");
-    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("spa");
+    assertThat(Util.normalizeLanguageCode(null)).isNull();
+    assertThat(Util.normalizeLanguageCode("")).isEmpty();
+    assertThat(Util.normalizeLanguageCode("es")).isEqualTo("es");
+    assertThat(Util.normalizeLanguageCode("spa")).isEqualTo("es");
     assertThat(Util.normalizeLanguageCode("es-AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("SpA-ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es_AR")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("spa_ar")).isEqualTo("es-ar");
+    assertThat(Util.normalizeLanguageCode("es-AR-dialect")).isEqualTo("es-ar-dialect");
+    assertThat(Util.normalizeLanguageCode("ES-419")).isEqualTo("es-419");
+    assertThat(Util.normalizeLanguageCode("zh-hans-tw")).isEqualTo("zh-hans-tw");
+    // Doesn't work on API < 21 because we can't use Locale syntax verification.
+    // assertThat(Util.normalizeLanguageCode("zh-tw-hans")).isEqualTo("zh-tw");
+    assertThat(Util.normalizeLanguageCode("zho-hans-tw")).isEqualTo("zh-hans-tw");
     assertThat(Util.normalizeLanguageCode("und")).isEqualTo("und");
     assertThat(Util.normalizeLanguageCode("DoesNotExist")).isEqualTo("doesnotexist");
   }
 
+  @Test
+  public void testNormalizeIso6392BibliographicalAndTextualCodes() {
+    // See https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes.
+    assertThat(Util.normalizeLanguageCode("alb")).isEqualTo(Util.normalizeLanguageCode("sqi"));
+    assertThat(Util.normalizeLanguageCode("arm")).isEqualTo(Util.normalizeLanguageCode("hye"));
+    assertThat(Util.normalizeLanguageCode("baq")).isEqualTo(Util.normalizeLanguageCode("eus"));
+    assertThat(Util.normalizeLanguageCode("bur")).isEqualTo(Util.normalizeLanguageCode("mya"));
+    assertThat(Util.normalizeLanguageCode("chi")).isEqualTo(Util.normalizeLanguageCode("zho"));
+    assertThat(Util.normalizeLanguageCode("cze")).isEqualTo(Util.normalizeLanguageCode("ces"));
+    assertThat(Util.normalizeLanguageCode("dut")).isEqualTo(Util.normalizeLanguageCode("nld"));
+    assertThat(Util.normalizeLanguageCode("fre")).isEqualTo(Util.normalizeLanguageCode("fra"));
+    assertThat(Util.normalizeLanguageCode("geo")).isEqualTo(Util.normalizeLanguageCode("kat"));
+    assertThat(Util.normalizeLanguageCode("ger")).isEqualTo(Util.normalizeLanguageCode("deu"));
+    assertThat(Util.normalizeLanguageCode("gre")).isEqualTo(Util.normalizeLanguageCode("ell"));
+    assertThat(Util.normalizeLanguageCode("ice")).isEqualTo(Util.normalizeLanguageCode("isl"));
+    assertThat(Util.normalizeLanguageCode("mac")).isEqualTo(Util.normalizeLanguageCode("mkd"));
+    assertThat(Util.normalizeLanguageCode("mao")).isEqualTo(Util.normalizeLanguageCode("mri"));
+    assertThat(Util.normalizeLanguageCode("may")).isEqualTo(Util.normalizeLanguageCode("msa"));
+    assertThat(Util.normalizeLanguageCode("per")).isEqualTo(Util.normalizeLanguageCode("fas"));
+    assertThat(Util.normalizeLanguageCode("rum")).isEqualTo(Util.normalizeLanguageCode("ron"));
+    assertThat(Util.normalizeLanguageCode("slo")).isEqualTo(Util.normalizeLanguageCode("slk"));
+    assertThat(Util.normalizeLanguageCode("tib")).isEqualTo(Util.normalizeLanguageCode("bod"));
+    assertThat(Util.normalizeLanguageCode("wel")).isEqualTo(Util.normalizeLanguageCode("cym"));
+  }
+
   private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
     assertThat(escapeFileName(fileName)).isEqualTo(escapedFileName);
     assertThat(unescapeFileName(escapedFileName)).isEqualTo(fileName);
diff --git a/library/dash/README.md b/library/dash/README.md
index 7831033b99..1076716684 100644
--- a/library/dash/README.md
+++ b/library/dash/README.md
@@ -6,7 +6,9 @@ play DASH content, instantiate a `DashMediaSource` and pass it to
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.source.dash.*`
   belong to this module.
 
+[Developer Guide]: https://exoplayer.dev/dash.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/dash/build.gradle b/library/dash/build.gradle
index f6981a2220..9f5775d478 100644
--- a/library/dash/build.gradle
+++ b/library/dash/build.gradle
@@ -41,7 +41,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
index 40d4e468bd..f7edf62182 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
@@ -69,4 +69,11 @@ DashChunkSource createDashChunkSource(
    * @param newManifest The new manifest.
    */
   void updateManifest(DashManifest newManifest, int periodIndex);
+
+  /**
+   * Updates the track selection.
+   *
+   * @param trackSelection The new track selection instance. Must be equivalent to the previous one.
+   */
+  void updateTrackSelection(TrackSelection trackSelection);
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index 431a0a4bd9..8635005bfc 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -402,17 +402,27 @@ private void selectNewStreams(
       int[] streamIndexToTrackGroupIndex) {
     // Create newly selected primary and event streams.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
+      TrackSelection selection = selections[i];
+      if (selection == null) {
+        continue;
+      }
+      if (streams[i] == null) {
+        // Create new stream for selection.
         streamResetFlags[i] = true;
         int trackGroupIndex = streamIndexToTrackGroupIndex[i];
         TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
         if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_PRIMARY) {
-          streams[i] = buildSampleStream(trackGroupInfo, selections[i], positionUs);
+          streams[i] = buildSampleStream(trackGroupInfo, selection, positionUs);
         } else if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_MANIFEST_EVENTS) {
           EventStream eventStream = eventStreams.get(trackGroupInfo.eventStreamGroupIndex);
-          Format format = selections[i].getTrackGroup().getFormat(0);
+          Format format = selection.getTrackGroup().getFormat(0);
           streams[i] = new EventSampleStream(eventStream, format, manifest.dynamic);
         }
+      } else if (streams[i] instanceof ChunkSampleStream) {
+        // Update selection in existing stream.
+        @SuppressWarnings("unchecked")
+        ChunkSampleStream<DashChunkSource> stream = (ChunkSampleStream<DashChunkSource>) streams[i];
+        stream.getChunkSource().updateTrackSelection(selection);
       }
     }
     // Create newly selected embedded streams from the corresponding primary stream. Note that this
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 057f0262d0..396d16968f 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -111,7 +111,6 @@ public DashChunkSource createDashChunkSource(
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int[] adaptationSetIndices;
-  private final TrackSelection trackSelection;
   private final int trackType;
   private final DataSource dataSource;
   private final long elapsedRealtimeOffsetMs;
@@ -120,6 +119,7 @@ public DashChunkSource createDashChunkSource(
 
   protected final RepresentationHolder[] representationHolders;
 
+  private TrackSelection trackSelection;
   private DashManifest manifest;
   private int periodIndex;
   private IOException fatalError;
@@ -222,6 +222,11 @@ public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
     }
   }
 
+  @Override
+  public void updateTrackSelection(TrackSelection trackSelection) {
+    this.trackSelection = trackSelection;
+  }
+
   @Override
   public void maybeThrowError() throws IOException {
     if (fatalError != null) {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index c4f61a73cd..f03a443431 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -42,6 +42,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 import java.util.regex.Matcher;
@@ -242,7 +243,7 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, null);
+        segmentBase = parseSegmentTemplate(xpp, null, Collections.emptyList());
       } else {
         maybeSkipTag(xpp);
       }
@@ -323,6 +324,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
                 language,
                 roleDescriptors,
                 accessibilityDescriptors,
+                supplementalProperties,
                 segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
@@ -332,7 +334,8 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+        segmentBase =
+            parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase, supplementalProperties);
       } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
@@ -492,6 +495,7 @@ protected RepresentationInfo parseRepresentation(
       String adaptationSetLanguage,
       List<Descriptor> adaptationSetRoleDescriptors,
       List<Descriptor> adaptationSetAccessibilityDescriptors,
+      List<Descriptor> adaptationSetSupplementalProperties,
       SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
@@ -524,7 +528,9 @@ protected RepresentationInfo parseRepresentation(
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+        segmentBase =
+            parseSegmentTemplate(
+                xpp, (SegmentTemplate) segmentBase, adaptationSetSupplementalProperties);
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentProtection")) {
         Pair<String, SchemeData> contentProtection = parseContentProtection(xpp);
         if (contentProtection.first != null) {
@@ -763,13 +769,19 @@ protected SegmentList buildSegmentList(
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplate parent)
+  protected SegmentTemplate parseSegmentTemplate(
+      XmlPullParser xpp,
+      SegmentTemplate parent,
+      List<Descriptor> adaptationSetSupplementalProperties)
       throws XmlPullParserException, IOException {
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
         parent != null ? parent.presentationTimeOffset : 0);
     long duration = parseLong(xpp, "duration", parent != null ? parent.duration : C.TIME_UNSET);
     long startNumber = parseLong(xpp, "startNumber", parent != null ? parent.startNumber : 1);
+    long endNumber =
+        parseLastSegmentNumberSupplementalProperty(adaptationSetSupplementalProperties);
+
     UrlTemplate mediaTemplate = parseUrlTemplate(xpp, "media",
         parent != null ? parent.mediaTemplate : null);
     UrlTemplate initializationTemplate = parseUrlTemplate(xpp, "initialization",
@@ -794,8 +806,16 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
       timeline = timeline != null ? timeline : parent.segmentTimeline;
     }
 
-    return buildSegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
+    return buildSegmentTemplate(
+        initialization,
+        timescale,
+        presentationTimeOffset,
+        startNumber,
+        endNumber,
+        duration,
+        timeline,
+        initializationTemplate,
+        mediaTemplate);
   }
 
   protected SegmentTemplate buildSegmentTemplate(
@@ -803,12 +823,21 @@ protected SegmentTemplate buildSegmentTemplate(
       long timescale,
       long presentationTimeOffset,
       long startNumber,
+      long endNumber,
       long duration,
       List<SegmentTimelineElement> timeline,
       UrlTemplate initializationTemplate,
       UrlTemplate mediaTemplate) {
-    return new SegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
+    return new SegmentTemplate(
+        initialization,
+        timescale,
+        presentationTimeOffset,
+        startNumber,
+        endNumber,
+        duration,
+        timeline,
+        initializationTemplate,
+        mediaTemplate);
   }
 
   /**
@@ -1445,6 +1474,18 @@ protected static int parseDolbyChannelConfiguration(XmlPullParser xpp) {
     }
   }
 
+  protected static long parseLastSegmentNumberSupplementalProperty(
+      List<Descriptor> supplementalProperties) {
+    for (int i = 0; i < supplementalProperties.size(); i++) {
+      Descriptor descriptor = supplementalProperties.get(i);
+      if ("http://dashif.org/guidelines/last-segment-number"
+          .equalsIgnoreCase(descriptor.schemeIdUri)) {
+        return Long.parseLong(descriptor.value);
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
   /** A parsed Representation element. */
   protected static final class RepresentationInfo {
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
index f033232590..ba4faafd95 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
@@ -277,6 +277,7 @@ public boolean isExplicit() {
 
     /* package */ final UrlTemplate initializationTemplate;
     /* package */ final UrlTemplate mediaTemplate;
+    /* package */ final long endNumber;
 
     /**
      * @param initialization A {@link RangedUri} corresponding to initialization data, if such data
@@ -286,6 +287,9 @@ public boolean isExplicit() {
      * @param presentationTimeOffset The presentation time offset. The value in seconds is the
      *     division of this value and {@code timescale}.
      * @param startNumber The sequence number of the first segment.
+     * @param endNumber The sequence number of the last segment as specified by the
+     *     SupplementalProperty with schemeIdUri="http://dashif.org/guidelines/last-segment-number",
+     *     or {@link C#INDEX_UNSET}.
      * @param duration The duration of each segment in the case of fixed duration segments. The
      *     value in seconds is the division of this value and {@code timescale}. If {@code
      *     segmentTimeline} is non-null then this parameter is ignored.
@@ -302,14 +306,21 @@ public SegmentTemplate(
         long timescale,
         long presentationTimeOffset,
         long startNumber,
+        long endNumber,
         long duration,
         List<SegmentTimelineElement> segmentTimeline,
         UrlTemplate initializationTemplate,
         UrlTemplate mediaTemplate) {
-      super(initialization, timescale, presentationTimeOffset, startNumber,
-          duration, segmentTimeline);
+      super(
+          initialization,
+          timescale,
+          presentationTimeOffset,
+          startNumber,
+          duration,
+          segmentTimeline);
       this.initializationTemplate = initializationTemplate;
       this.mediaTemplate = mediaTemplate;
+      this.endNumber = endNumber;
     }
 
     @Override
@@ -340,6 +351,8 @@ public RangedUri getSegmentUrl(Representation representation, long sequenceNumbe
     public int getSegmentCount(long periodDurationUs) {
       if (segmentTimeline != null) {
         return segmentTimeline.size();
+      } else if (endNumber != C.INDEX_UNSET) {
+        return (int) (endNumber - startNumber + 1);
       } else if (periodDurationUs != C.TIME_UNSET) {
         long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
         return (int) Util.ceilDivide(periodDurationUs, durationUs);
@@ -347,7 +360,6 @@ public int getSegmentCount(long periodDurationUs) {
         return DashSegmentIndex.INDEX_UNBOUNDED;
       }
     }
-
   }
 
   /**
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
index b3a6b8271b..94dae35ed5 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
@@ -35,6 +35,7 @@
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.DownloaderFactory;
 import com.google.android.exoplayer2.offline.StreamKey;
+import com.google.android.exoplayer2.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
@@ -108,7 +109,7 @@ public void testDownloadRepresentation() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -127,7 +128,7 @@ public void testDownloadRepresentationInSmallParts() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -146,7 +147,7 @@ public void testDownloadRepresentations() throws Exception {
     DashDownloader dashDownloader =
         getDashDownloader(fakeDataSet, new StreamKey(0, 0, 0), new StreamKey(0, 1, 0));
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -167,7 +168,7 @@ public void testDownloadAllRepresentations() throws Exception {
 
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -256,7 +257,7 @@ public void testDownloadRepresentationFailure() throws Exception {
       // Expected.
     }
     dashDownloader.download(progressListener);
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
index 35db882e2a..280bc45b70 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DownloadManagerDashTest.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.scheduler.Requirements;
+import com.google.android.exoplayer2.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.DummyMainThread.TestRunnable;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
@@ -154,7 +155,7 @@ public void testSaveAndLoadActionFile() throws Throwable {
   public void testHandleDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1, fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -162,7 +163,7 @@ public void testHandleMultipleDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1);
     handleDownloadRequest(fakeStreamKey2);
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
@@ -176,7 +177,7 @@ public void testHandleInterferingDownloadRequest() throws Throwable {
     handleDownloadRequest(fakeStreamKey1);
 
     blockUntilTasksCompleteAndThrowAnyDownloadError();
-    assertCachedData(cache, fakeDataSet);
+    assertCachedData(cache, new RequestSet(fakeDataSet).useBoundedDataSpecFor("audio_init_data"));
   }
 
   @Test
diff --git a/library/hls/README.md b/library/hls/README.md
index 1dd1b7a62e..3470c29e3c 100644
--- a/library/hls/README.md
+++ b/library/hls/README.md
@@ -5,7 +5,9 @@ instantiate a `HlsMediaSource` and pass it to `ExoPlayer.prepare`.
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.source.hls.*`
   belong to this module.
 
+[Developer Guide]: https://exoplayer.dev/hls.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/hls/build.gradle b/library/hls/build.gradle
index 8e9696af70..82e09ab72c 100644
--- a/library/hls/build.gradle
+++ b/library/hls/build.gradle
@@ -39,7 +39,7 @@ android {
 }
 
 dependencies {
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     implementation project(modulePrefix + 'library-core')
     testImplementation project(modulePrefix + 'testutils-robolectric')
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 261c9b531c..ee5a5f0809 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -183,17 +183,15 @@ public TrackGroup getTrackGroup() {
   }
 
   /**
-   * Selects tracks for use.
+   * Sets the current track selection.
    *
-   * @param trackSelection The track selection.
+   * @param trackSelection The {@link TrackSelection}.
    */
-  public void selectTracks(TrackSelection trackSelection) {
+  public void setTrackSelection(TrackSelection trackSelection) {
     this.trackSelection = trackSelection;
   }
 
-  /**
-   * Returns the current track selection.
-   */
+  /** Returns the current {@link TrackSelection}. */
   public TrackSelection getTrackSelection() {
     return trackSelection;
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index ef233bb566..2cfd14c79d 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -802,7 +802,7 @@ private static Format deriveAudioFormat(
       if (isPrimaryTrackInVariant) {
         channelCount = variantFormat.channelCount;
         selectionFlags = variantFormat.selectionFlags;
-        roleFlags = mediaTagFormat.roleFlags;
+        roleFlags = variantFormat.roleFlags;
         language = variantFormat.language;
         label = variantFormat.label;
       }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 65039b9364..f7bc913527 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -292,14 +292,17 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     TrackSelection primaryTrackSelection = oldPrimaryTrackSelection;
     // Select new tracks.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
+      TrackSelection selection = selections[i];
+      if (selection == null) {
+        continue;
+      }
+      int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
+      if (trackGroupIndex == primaryTrackGroupIndex) {
+        primaryTrackSelection = selection;
+        chunkSource.setTrackSelection(selection);
+      }
+      if (streams[i] == null) {
         enabledTrackGroupCount++;
-        TrackSelection selection = selections[i];
-        int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
-        if (trackGroupIndex == primaryTrackGroupIndex) {
-          primaryTrackSelection = selection;
-          chunkSource.selectTracks(selection);
-        }
         streams[i] = new HlsSampleStream(this, trackGroupIndex);
         streamResetFlags[i] = true;
         if (trackGroupToSampleQueueIndex != null) {
@@ -322,6 +325,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     if (enabledTrackGroupCount == 0) {
       chunkSource.reset();
       downstreamTrackFormat = null;
+      pendingResetUpstreamFormats = true;
       mediaChunks.clear();
       if (loader.isLoading()) {
         if (sampleQueuesBuilt) {
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
index 7d77a78316..d06d047f66 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer2.offline.DownloaderFactory;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.testutil.CacheAsserts.RequestSet;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSource.Factory;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
@@ -129,12 +130,13 @@ public void testDownloadRepresentation() throws Exception {
 
     assertCachedData(
         cache,
-        fakeDataSet,
-        MASTER_PLAYLIST_URI,
-        MEDIA_PLAYLIST_1_URI,
-        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+        new RequestSet(fakeDataSet)
+            .subset(
+                MASTER_PLAYLIST_URI,
+                MEDIA_PLAYLIST_1_URI,
+                MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts"));
   }
 
   @Test
@@ -186,11 +188,12 @@ public void testDownloadMediaPlaylist() throws Exception {
 
     assertCachedData(
         cache,
-        fakeDataSet,
-        MEDIA_PLAYLIST_1_URI,
-        MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
-        MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
+        new RequestSet(fakeDataSet)
+            .subset(
+                MEDIA_PLAYLIST_1_URI,
+                MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
+                MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts"));
   }
 
   @Test
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 095739271e..254a2b2bd1 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -263,7 +263,7 @@ public void testPlaylistWithClosedCaption() throws IOException {
     Format closedCaptionFormat = playlist.muxedCaptionFormats.get(0);
     assertThat(closedCaptionFormat.sampleMimeType).isEqualTo(MimeTypes.APPLICATION_CEA708);
     assertThat(closedCaptionFormat.accessibilityChannel).isEqualTo(4);
-    assertThat(closedCaptionFormat.language).isEqualTo("spa");
+    assertThat(closedCaptionFormat.language).isEqualTo("es");
   }
 
   @Test
diff --git a/library/smoothstreaming/README.md b/library/smoothstreaming/README.md
index 4fa24543d6..d53471d17c 100644
--- a/library/smoothstreaming/README.md
+++ b/library/smoothstreaming/README.md
@@ -5,8 +5,10 @@ instantiate a `SsMediaSource` and pass it to `ExoPlayer.prepare`.
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching
   `com.google.android.exoplayer2.source.smoothstreaming.*` belong to this
   module.
 
+[Developer Guide]: https://exoplayer.dev/smoothstreaming.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/smoothstreaming/build.gradle b/library/smoothstreaming/build.gradle
index a2e81fb304..fa67ea1d01 100644
--- a/library/smoothstreaming/build.gradle
+++ b/library/smoothstreaming/build.gradle
@@ -41,7 +41,7 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index 59e18195e2..22dfb04f13 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -74,10 +74,10 @@ public SsChunkSource createChunkSource(
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int streamElementIndex;
-  private final TrackSelection trackSelection;
   private final ChunkExtractorWrapper[] extractorWrappers;
   private final DataSource dataSource;
 
+  private TrackSelection trackSelection;
   private SsManifest manifest;
   private int currentManifestChunkOffset;
 
@@ -155,6 +155,11 @@ public void updateManifest(SsManifest newManifest) {
     manifest = newManifest;
   }
 
+  @Override
+  public void updateTrackSelection(TrackSelection trackSelection) {
+    this.trackSelection = trackSelection;
+  }
+
   // ChunkSource implementation.
 
   @Override
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
index b763a484b8..111393140e 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
@@ -55,4 +55,11 @@ SsChunkSource createChunkSource(
    * @param newManifest The new manifest.
    */
   void updateManifest(SsManifest newManifest);
+
+  /**
+   * Updates the track selection.
+   *
+   * @param trackSelection The new track selection instance. Must be equivalent to the previous one.
+   */
+  void updateTrackSelection(TrackSelection trackSelection);
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 135ee4a58e..e325439d05 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -126,6 +126,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
           stream.release();
           streams[i] = null;
         } else {
+          stream.getChunkSource().updateTrackSelection(selections[i]);
           sampleStreamsList.add(stream);
         }
       }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 66731660f5..39e22f2982 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -586,6 +586,7 @@ private void parseStreamElementStartTag(XmlPullParser parser) throws ParserExcep
       } else {
         subType = parser.getAttributeValue(null, KEY_SUB_TYPE);
       }
+      putNormalizedAttribute(KEY_SUB_TYPE, subType);
       name = parser.getAttributeValue(null, KEY_NAME);
       url = parseRequiredString(parser, KEY_URL);
       maxWidth = parseInt(parser, KEY_MAX_WIDTH, Format.NO_VALUE);
@@ -645,6 +646,7 @@ public Object build() {
     private static final String KEY_CHANNELS = "Channels";
     private static final String KEY_FOUR_CC = "FourCC";
     private static final String KEY_TYPE = "Type";
+    private static final String KEY_SUB_TYPE = "Subtype";
     private static final String KEY_LANGUAGE = "Language";
     private static final String KEY_NAME = "Name";
     private static final String KEY_MAX_WIDTH = "MaxWidth";
@@ -709,6 +711,18 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* roleFlags= */ 0,
                 language);
       } else if (type == C.TRACK_TYPE_TEXT) {
+        String subType = (String) getNormalizedAttribute(KEY_SUB_TYPE);
+        @C.RoleFlags int roleFlags = 0;
+        switch (subType) {
+          case "CAPT":
+            roleFlags = C.ROLE_FLAG_CAPTION;
+            break;
+          case "DESC":
+            roleFlags = C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND;
+            break;
+          default:
+            break;
+        }
         String language = (String) getNormalizedAttribute(KEY_LANGUAGE);
         format =
             Format.createTextContainerFormat(
@@ -719,7 +733,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 /* codecs= */ null,
                 bitrate,
                 /* selectionFlags= */ 0,
-                /* roleFlags= */ 0,
+                roleFlags,
                 language);
       } else {
         format =
diff --git a/library/ui/README.md b/library/ui/README.md
index 341ea2fb16..16136b3d94 100644
--- a/library/ui/README.md
+++ b/library/ui/README.md
@@ -4,7 +4,9 @@ Provides UI components and resources for use with ExoPlayer.
 
 ## Links ##
 
+* [Developer Guide][].
 * [Javadoc][]: Classes matching `com.google.android.exoplayer2.ui.*`
   belong to this module.
 
+[Developer Guide]: https://exoplayer.dev/ui-components.html
 [Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index 49446b25de..5182dfccf5 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -40,8 +40,8 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.media:media:1.0.0'
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.media:media:1.0.1'
+    implementation 'androidx.annotation:annotation:1.1.0'
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index d4a37ea4ef..268219b6d5 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -18,6 +18,7 @@
 import android.content.Context;
 import android.content.res.TypedArray;
 import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 import java.lang.annotation.Documented;
@@ -97,16 +98,16 @@ void onAspectRatioUpdated(
 
   private final AspectRatioUpdateDispatcher aspectRatioUpdateDispatcher;
 
-  private AspectRatioListener aspectRatioListener;
+  @Nullable private AspectRatioListener aspectRatioListener;
 
   private float videoAspectRatio;
-  private @ResizeMode int resizeMode;
+  @ResizeMode private int resizeMode;
 
   public AspectRatioFrameLayout(Context context) {
-    this(context, null);
+    this(context, /* attrs= */ null);
   }
 
-  public AspectRatioFrameLayout(Context context, AttributeSet attrs) {
+  public AspectRatioFrameLayout(Context context, @Nullable AttributeSet attrs) {
     super(context, attrs);
     resizeMode = RESIZE_MODE_FIT;
     if (attrs != null) {
@@ -136,9 +137,10 @@ public void setAspectRatio(float widthHeightRatio) {
   /**
    * Sets the {@link AspectRatioListener}.
    *
-   * @param listener The listener to be notified about aspect ratios changes.
+   * @param listener The listener to be notified about aspect ratios changes, or null to clear a
+   *     listener that was previously set.
    */
-  public void setAspectRatioListener(AspectRatioListener listener) {
+  public void setAspectRatioListener(@Nullable AspectRatioListener listener) {
     this.aspectRatioListener = listener;
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index 328b5d6a49..5c70203788 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -220,11 +220,26 @@
   private @Nullable long[] adGroupTimesMs;
   private @Nullable boolean[] playedAdGroups;
 
-  /** Creates a new time bar. */
+  public DefaultTimeBar(Context context) {
+    this(context, null);
+  }
+
+  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs) {
+    this(context, attrs, 0);
+  }
+
+  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
+    this(context, attrs, defStyleAttr, attrs);
+  }
+
   // Suppress warnings due to usage of View methods in the constructor.
   @SuppressWarnings("nullness:method.invocation.invalid")
-  public DefaultTimeBar(Context context, AttributeSet attrs) {
-    super(context, attrs);
+  public DefaultTimeBar(
+      Context context,
+      @Nullable AttributeSet attrs,
+      int defStyleAttr,
+      @Nullable AttributeSet timebarAttrs) {
+    super(context, attrs, defStyleAttr);
     seekBounds = new Rect();
     progressBar = new Rect();
     bufferedBar = new Rect();
@@ -251,9 +266,9 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
     int defaultScrubberEnabledSize = dpToPx(density, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
     int defaultScrubberDisabledSize = dpToPx(density, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
     int defaultScrubberDraggedSize = dpToPx(density, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
-    if (attrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
-          0);
+    if (timebarAttrs != null) {
+      TypedArray a =
+          context.getTheme().obtainStyledAttributes(timebarAttrs, R.styleable.DefaultTimeBar, 0, 0);
       try {
         scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
         if (scrubberDrawable != null) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index a5deb808c1..73bb98a1a0 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -28,6 +28,7 @@
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewGroup;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.TextView;
@@ -97,6 +98,9 @@
  *         <li>Corresponding method: None
  *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
+ *   <li>All attributes that can be set on {@link DefaultTimeBar} can also be set on a
+ *       PlayerControlView, and will be propagated to the inflated {@link DefaultTimeBar} unless the
+ *       layout is overridden to specify a custom {@code exo_progress} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
@@ -154,7 +158,15 @@
  *       <ul>
  *         <li>Type: {@link TextView}
  *       </ul>
+ *   <li><b>{@code exo_progress_placeholder}</b> - A placeholder that's replaced with the inflated
+ *       {@link DefaultTimeBar}. Ignored if an {@code exo_progress} view exists.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
  *   <li><b>{@code exo_progress}</b> - Time bar that's updated during playback and allows seeking.
+ *       {@link DefaultTimeBar} attributes set on the PlayerControlView will not be automatically
+ *       propagated through to this instance. If a view exists with this id, any {@code
+ *       exo_progress_placeholder} view will be ignored.
  *       <ul>
  *         <li>Type: {@link TimeBar}
  *       </ul>
@@ -188,6 +200,18 @@
     void onVisibilityChange(int visibility);
   }
 
+  /** Listener to be notified when progress has been updated. */
+  public interface ProgressUpdateListener {
+
+    /**
+     * Called when progress needs to be updated.
+     *
+     * @param position The current position.
+     * @param bufferedPosition The current buffered position.
+     */
+    void onProgressUpdate(long position, long bufferedPosition);
+  }
+
   /** The default fast forward increment, in milliseconds. */
   public static final int DEFAULT_FAST_FORWARD_MS = 15000;
   /** The default rewind increment, in milliseconds. */
@@ -235,7 +259,8 @@
 
   @Nullable private Player player;
   private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
-  private VisibilityListener visibilityListener;
+  @Nullable private VisibilityListener visibilityListener;
+  @Nullable private ProgressUpdateListener progressUpdateListener;
   @Nullable private PlaybackPreparer playbackPreparer;
 
   private boolean isAttachedToWindow;
@@ -256,19 +281,22 @@
   private long currentWindowOffset;
 
   public PlayerControlView(Context context) {
-    this(context, null);
+    this(context, /* attrs= */ null);
   }
 
-  public PlayerControlView(Context context, AttributeSet attrs) {
+  public PlayerControlView(Context context, @Nullable AttributeSet attrs) {
     this(context, attrs, 0);
   }
 
-  public PlayerControlView(Context context, AttributeSet attrs, int defStyleAttr) {
+  public PlayerControlView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
     this(context, attrs, defStyleAttr, attrs);
   }
 
   public PlayerControlView(
-      Context context, AttributeSet attrs, int defStyleAttr, AttributeSet playbackAttrs) {
+      Context context,
+      @Nullable AttributeSet attrs,
+      int defStyleAttr,
+      @Nullable AttributeSet playbackAttrs) {
     super(context, attrs, defStyleAttr);
     int controllerLayoutId = R.layout.exo_player_control_view;
     rewindMs = DEFAULT_REWIND_MS;
@@ -317,9 +345,27 @@ public PlayerControlView(
     LayoutInflater.from(context).inflate(controllerLayoutId, this);
     setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
 
+    TimeBar customTimeBar = findViewById(R.id.exo_progress);
+    View timeBarPlaceholder = findViewById(R.id.exo_progress_placeholder);
+    if (customTimeBar != null) {
+      timeBar = customTimeBar;
+    } else if (timeBarPlaceholder != null) {
+      // Propagate attrs as timebarAttrs so that DefaultTimeBar's custom attributes are transferred,
+      // but standard attributes (e.g. background) are not.
+      DefaultTimeBar defaultTimeBar = new DefaultTimeBar(context, null, 0, playbackAttrs);
+      defaultTimeBar.setId(R.id.exo_progress);
+      defaultTimeBar.setLayoutParams(timeBarPlaceholder.getLayoutParams());
+      ViewGroup parent = ((ViewGroup) timeBarPlaceholder.getParent());
+      int timeBarIndex = parent.indexOfChild(timeBarPlaceholder);
+      parent.removeView(timeBarPlaceholder);
+      parent.addView(defaultTimeBar, timeBarIndex);
+      timeBar = defaultTimeBar;
+    } else {
+      timeBar = null;
+    }
     durationView = findViewById(R.id.exo_duration);
     positionView = findViewById(R.id.exo_position);
-    timeBar = findViewById(R.id.exo_progress);
+
     if (timeBar != null) {
       timeBar.addListener(componentListener);
     }
@@ -454,6 +500,15 @@ public void setVisibilityListener(VisibilityListener listener) {
     this.visibilityListener = listener;
   }
 
+  /**
+   * Sets the {@link ProgressUpdateListener}.
+   *
+   * @param listener The listener to be notified about when progress is updated.
+   */
+  public void setProgressUpdateListener(@Nullable ProgressUpdateListener listener) {
+    this.progressUpdateListener = listener;
+  }
+
   /**
    * Sets the {@link PlaybackPreparer}.
    *
@@ -855,6 +910,9 @@ private void updateProgress() {
       timeBar.setPosition(position);
       timeBar.setBufferedPosition(bufferedPosition);
     }
+    if (progressUpdateListener != null) {
+      progressUpdateListener.onProgressUpdate(position, bufferedPosition);
+    }
 
     // Cancel any pending updates and schedule a new one if necessary.
     removeCallbacks(updateProgressAction);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index 1dbd696b12..260fb9d398 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -385,6 +385,26 @@ public void onBitmap(final Bitmap bitmap) {
   private boolean wasPlayWhenReady;
   private int lastPlaybackState;
 
+  /**
+   * @deprecated Use {@link #createWithNotificationChannel(Context, String, int, int, int,
+   *     MediaDescriptionAdapter)}.
+   */
+  @Deprecated
+  public static PlayerNotificationManager createWithNotificationChannel(
+      Context context,
+      String channelId,
+      @StringRes int channelName,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter) {
+    return createWithNotificationChannel(
+        context,
+        channelId,
+        channelName,
+        /* channelDescription= */ 0,
+        notificationId,
+        mediaDescriptionAdapter);
+  }
+
   /**
    * Creates a notification manager and a low-priority notification channel with the specified
    * {@code channelId} and {@code channelName}.
@@ -397,8 +417,12 @@ public void onBitmap(final Bitmap bitmap) {
    *
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
-   * @param channelName A string resource identifier for the user visible name of the channel. The
-   *     recommended maximum length is 40 characters; the value may be truncated if it is too long.
+   * @param channelName A string resource identifier for the user visible name of the notification
+   *     channel. The recommended maximum length is 40 characters. The string may be truncated if
+   *     it's too long.
+   * @param channelDescription A string resource identifier for the user visible description of the
+   *     notification channel, or 0 if no description is provided. The recommended maximum length is
+   *     300 characters. The value may be truncated if it is too long.
    * @param notificationId The id of the notification.
    * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
    */
@@ -406,14 +430,37 @@ public static PlayerNotificationManager createWithNotificationChannel(
       Context context,
       String channelId,
       @StringRes int channelName,
+      @StringRes int channelDescription,
       int notificationId,
       MediaDescriptionAdapter mediaDescriptionAdapter) {
     NotificationUtil.createNotificationChannel(
-        context, channelId, channelName, NotificationUtil.IMPORTANCE_LOW);
+        context, channelId, channelName, channelDescription, NotificationUtil.IMPORTANCE_LOW);
     return new PlayerNotificationManager(
         context, channelId, notificationId, mediaDescriptionAdapter);
   }
 
+  /**
+   * @deprecated Use {@link #createWithNotificationChannel(Context, String, int, int, int,
+   *     MediaDescriptionAdapter, NotificationListener)}.
+   */
+  @Deprecated
+  public static PlayerNotificationManager createWithNotificationChannel(
+      Context context,
+      String channelId,
+      @StringRes int channelName,
+      int notificationId,
+      MediaDescriptionAdapter mediaDescriptionAdapter,
+      @Nullable NotificationListener notificationListener) {
+    return createWithNotificationChannel(
+        context,
+        channelId,
+        channelName,
+        /* channelDescription= */ 0,
+        notificationId,
+        mediaDescriptionAdapter,
+        notificationListener);
+  }
+
   /**
    * Creates a notification manager and a low-priority notification channel with the specified
    * {@code channelId} and {@code channelName}. The {@link NotificationListener} passed as the last
@@ -422,7 +469,9 @@ public static PlayerNotificationManager createWithNotificationChannel(
    * @param context The {@link Context}.
    * @param channelId The id of the notification channel.
    * @param channelName A string resource identifier for the user visible name of the channel. The
-   *     recommended maximum length is 40 characters; the value may be truncated if it is too long.
+   *     recommended maximum length is 40 characters. The string may be truncated if it's too long.
+   * @param channelDescription A string resource identifier for the user visible description of the
+   *     channel, or 0 if no description is provided.
    * @param notificationId The id of the notification.
    * @param mediaDescriptionAdapter The {@link MediaDescriptionAdapter}.
    * @param notificationListener The {@link NotificationListener}.
@@ -431,11 +480,12 @@ public static PlayerNotificationManager createWithNotificationChannel(
       Context context,
       String channelId,
       @StringRes int channelName,
+      @StringRes int channelDescription,
       int notificationId,
       MediaDescriptionAdapter mediaDescriptionAdapter,
       @Nullable NotificationListener notificationListener) {
     NotificationUtil.createNotificationChannel(
-        context, channelId, channelName, NotificationUtil.IMPORTANCE_LOW);
+        context, channelId, channelName, channelDescription, NotificationUtil.IMPORTANCE_LOW);
     return new PlayerNotificationManager(
         context, channelId, notificationId, mediaDescriptionAdapter, notificationListener);
   }
@@ -966,7 +1016,8 @@ private void stopNotification(boolean dismissedByUser) {
       @Nullable NotificationCompat.Builder builder,
       boolean ongoing,
       @Nullable Bitmap largeIcon) {
-    if (player.getPlaybackState() == Player.STATE_IDLE) {
+    if (player.getPlaybackState() == Player.STATE_IDLE
+        && (player.getCurrentTimeline().isEmpty() || playbackPreparer == null)) {
       builderActions = null;
       return null;
     }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 93461c1b24..95d2e1c1bb 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -35,7 +35,6 @@
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
-import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.TextureView;
 import android.view.View;
@@ -50,8 +49,8 @@
 import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
-import com.google.android.exoplayer2.Player.VideoComponent;
 import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.flac.PictureFrame;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.ads.AdsLoader;
@@ -165,9 +164,10 @@
  *         <li>Corresponding method: None
  *         <li>Default: {@code R.layout.exo_player_control_view}
  *       </ul>
- *   <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
- *       PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
- *       layout is overridden to specify a custom {@code exo_controller} (see below).
+ *   <li>All attributes that can be set on {@link PlayerControlView} and {@link DefaultTimeBar} can
+ *       also be set on a PlayerView, and will be propagated to the inflated {@link
+ *       PlayerControlView} unless the layout is overridden to specify a custom {@code
+ *       exo_controller} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
@@ -217,9 +217,10 @@
  *         <li>Type: {@link View}
  *       </ul>
  *   <li><b>{@code exo_controller}</b> - An already inflated {@link PlayerControlView}. Allows use
- *       of a custom extension of {@link PlayerControlView}. Note that attributes such as {@code
- *       rewind_increment} will not be automatically propagated through to this instance. If a view
- *       exists with this id, any {@code exo_controller_placeholder} view will be ignored.
+ *       of a custom extension of {@link PlayerControlView}. {@link PlayerControlView} and {@link
+ *       DefaultTimeBar} attributes set on the PlayerView will not be automatically propagated
+ *       through to this instance. If a view exists with this id, any {@code
+ *       exo_controller_placeholder} view will be ignored.
  *       <ul>
  *         <li>Type: {@link PlayerControlView}
  *       </ul>
@@ -303,6 +304,9 @@
   private boolean controllerHideDuringAds;
   private boolean controllerHideOnTouch;
   private int textureViewRotation;
+  private boolean isTouching;
+  private static final int PICTURE_TYPE_FRONT_COVER = 3;
+  private static final int PICTURE_TYPE_NOT_SET = -1;
 
   public PlayerView(Context context) {
     this(context, null);
@@ -405,7 +409,6 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
           break;
         case SURFACE_TYPE_MONO360_VIEW:
           SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
-          sphericalSurfaceView.setSurfaceListener(componentListener);
           sphericalSurfaceView.setSingleTapListener(componentListener);
           surfaceView = sphericalSurfaceView;
           break;
@@ -459,8 +462,9 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       this.controller = customController;
     } else if (controllerPlaceholder != null) {
       // Propagate attrs as playbackAttrs so that PlayerControlView's custom attributes are
-      // transferred, but standard FrameLayout attributes (e.g. background) are not.
+      // transferred, but standard attributes (e.g. background) are not.
       this.controller = new PlayerControlView(context, null, 0, attrs);
+      controller.setId(R.id.exo_controller);
       controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
       ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
       int controllerIndex = parent.indexOfChild(controllerPlaceholder);
@@ -771,11 +775,20 @@ public boolean dispatchKeyEvent(KeyEvent event) {
     if (player != null && player.isPlayingAd()) {
       return super.dispatchKeyEvent(event);
     }
-    boolean isDpadWhenControlHidden =
-        isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
-    boolean handled =
-        isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-    if (handled) {
+
+    boolean isDpadAndUseController = isDpadKey(event.getKeyCode()) && useController;
+    boolean handled = false;
+    if (isDpadAndUseController && !controller.isVisible()) {
+      // Handle the key event by showing the controller.
+      maybeShowController(true);
+      handled = true;
+    } else if (dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event)) {
+      // The key event was handled as a media key or by the super class. We should also show the
+      // controller, or extend its show timeout if already visible.
+      maybeShowController(true);
+      handled = true;
+    } else if (isDpadAndUseController) {
+      // The key event wasn't handled, but we should extend the controller's show timeout.
       maybeShowController(true);
     }
     return handled;
@@ -1039,11 +1052,24 @@ public SubtitleView getSubtitleView() {
   }
 
   @Override
-  public boolean onTouchEvent(MotionEvent ev) {
-    if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+  public boolean onTouchEvent(MotionEvent event) {
+    if (!useController || player == null) {
       return false;
     }
-    return performClick();
+    switch (event.getAction()) {
+      case MotionEvent.ACTION_DOWN:
+        isTouching = true;
+        return true;
+      case MotionEvent.ACTION_UP:
+        if (isTouching) {
+          isTouching = false;
+          performClick();
+          return true;
+        }
+        return false;
+      default:
+        return false;
+    }
   }
 
   @Override
@@ -1226,15 +1252,32 @@ private void updateForCurrentTrackSelections(boolean isNewPlayer) {
   }
 
   private boolean setArtworkFromMetadata(Metadata metadata) {
+    boolean isArtworkSet = false;
+    int currentPictureType = PICTURE_TYPE_NOT_SET;
     for (int i = 0; i < metadata.length(); i++) {
       Metadata.Entry metadataEntry = metadata.get(i);
+      int pictureType;
+      byte[] bitmapData;
       if (metadataEntry instanceof ApicFrame) {
-        byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
+        bitmapData = ((ApicFrame) metadataEntry).pictureData;
+        pictureType = ((ApicFrame) metadataEntry).pictureType;
+      } else if (metadataEntry instanceof PictureFrame) {
+        bitmapData = ((PictureFrame) metadataEntry).pictureData;
+        pictureType = ((PictureFrame) metadataEntry).pictureType;
+      } else {
+        continue;
+      }
+      // Prefer the first front cover picture. If there aren't any, prefer the first picture.
+      if (currentPictureType == PICTURE_TYPE_NOT_SET || pictureType == PICTURE_TYPE_FRONT_COVER) {
         Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        return setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
+        isArtworkSet = setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
+        currentPictureType = pictureType;
+        if (currentPictureType == PICTURE_TYPE_FRONT_COVER) {
+          break;
+        }
       }
     }
-    return false;
+    return isArtworkSet;
   }
 
   private boolean setDrawableArtwork(@Nullable Drawable drawable) {
@@ -1359,7 +1402,6 @@ private boolean isDpadKey(int keyCode) {
           TextOutput,
           VideoListener,
           OnLayoutChangeListener,
-          SphericalSurfaceView.SurfaceListener,
           SingleTapListener {
 
     // TextOutput implementation
@@ -1449,18 +1491,6 @@ public void onLayoutChange(
       applyTextureViewRotation((TextureView) view, textureViewRotation);
     }
 
-    // SphericalSurfaceView.SurfaceTextureListener implementation
-
-    @Override
-    public void surfaceChanged(@Nullable Surface surface) {
-      if (player != null) {
-        VideoComponent videoComponent = player.getVideoComponent();
-        if (videoComponent != null) {
-          videoComponent.setVideoSurface(surface);
-        }
-      }
-    }
-
     // SingleTapListener implementation
 
     @Override
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index 4f22362de6..9ed1bbd006 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -362,10 +362,16 @@ private void setupBitmapLayout() {
     int width = Math.round(parentWidth * cueSize);
     int height = cueBitmapHeight != Cue.DIMEN_UNSET ? Math.round(parentHeight * cueBitmapHeight)
         : Math.round(width * ((float) cueBitmap.getHeight() / cueBitmap.getWidth()));
-    int x = Math.round(cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width)
-        : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
-    int y = Math.round(cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - height)
-        : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
+    int x =
+        Math.round(
+            cuePositionAnchor == Cue.ANCHOR_TYPE_END
+                ? (anchorX - width)
+                : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
+    int y =
+        Math.round(
+            cueLineAnchor == Cue.ANCHOR_TYPE_END
+                ? (anchorY - height)
+                : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
     bitmapRect = new Rect(x, y, x + width, y + height);
   }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 5d99eda109..0bdc1acc88 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -53,8 +53,8 @@
 
   private final List<SubtitlePainter> painters;
 
-  private List<Cue> cues;
-  private @Cue.TextSizeType int textSizeType;
+  @Nullable private List<Cue> cues;
+  @Cue.TextSizeType private int textSizeType;
   private float textSize;
   private boolean applyEmbeddedStyles;
   private boolean applyEmbeddedFontSizes;
@@ -62,10 +62,10 @@
   private float bottomPaddingFraction;
 
   public SubtitleView(Context context) {
-    this(context, null);
+    this(context, /* attrs= */ null);
   }
 
-  public SubtitleView(Context context, AttributeSet attrs) {
+  public SubtitleView(Context context, @Nullable AttributeSet attrs) {
     super(context, attrs);
     painters = new ArrayList<>();
     textSizeType = Cue.TEXT_SIZE_TYPE_FRACTIONAL;
@@ -246,7 +246,11 @@ public void setBottomPaddingFraction(float bottomPaddingFraction) {
 
   @Override
   public void dispatchDraw(Canvas canvas) {
-    int cueCount = (cues == null) ? 0 : cues.size();
+    List<Cue> cues = this.cues;
+    if (cues == null || cues.isEmpty()) {
+      return;
+    }
+
     int rawViewHeight = getHeight();
 
     // Calculate the cue box bounds relative to the canvas after padding is taken into account.
@@ -267,6 +271,7 @@ public void dispatchDraw(Canvas canvas) {
       return;
     }
 
+    int cueCount = cues.size();
     for (int i = 0; i < cueCount; i++) {
       Cue cue = cues.get(i);
       float cueTextSizePx = resolveCueTextSize(cue, rawViewHeight, viewHeightMinusPadding);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
index 1029a28323..02b3043665 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
@@ -53,20 +53,6 @@
  */
 public final class SphericalSurfaceView extends GLSurfaceView {
 
-  /**
-   * This listener can be used to be notified when the {@link Surface} associated with this view is
-   * changed.
-   */
-  public interface SurfaceListener {
-    /**
-     * Invoked when the surface is changed or there isn't one anymore. Any previous surface
-     * shouldn't be used after this call.
-     *
-     * @param surface The new surface or null if there isn't one anymore.
-     */
-    void surfaceChanged(@Nullable Surface surface);
-  }
-
   // Arbitrary vertical field of view.
   private static final int FIELD_OF_VIEW_DEGREES = 90;
   private static final float Z_NEAR = .1f;
@@ -84,7 +70,6 @@
   private final Handler mainHandler;
   private final TouchTracker touchTracker;
   private final SceneRenderer scene;
-  private @Nullable SurfaceListener surfaceListener;
   private @Nullable SurfaceTexture surfaceTexture;
   private @Nullable Surface surface;
   private @Nullable Player.VideoComponent videoComponent;
@@ -156,15 +141,6 @@ public void setVideoComponent(@Nullable Player.VideoComponent newVideoComponent)
     }
   }
 
-  /**
-   * Sets the {@link SurfaceListener} used to listen to surface events.
-   *
-   * @param listener The listener for surface events.
-   */
-  public void setSurfaceListener(@Nullable SurfaceListener listener) {
-    surfaceListener = listener;
-  }
-
   /** Sets the {@link SingleTapListener} used to listen to single tap events on this view. */
   public void setSingleTapListener(@Nullable SingleTapListener listener) {
     touchTracker.setSingleTapListener(listener);
@@ -196,8 +172,8 @@ protected void onDetachedFromWindow() {
     mainHandler.post(
         () -> {
           if (surface != null) {
-            if (surfaceListener != null) {
-              surfaceListener.surfaceChanged(null);
+            if (videoComponent != null) {
+              videoComponent.clearVideoSurface(surface);
             }
             releaseSurface(surfaceTexture, surface);
             surfaceTexture = null;
@@ -214,8 +190,8 @@ private void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture) {
           Surface oldSurface = this.surface;
           this.surfaceTexture = surfaceTexture;
           this.surface = new Surface(surfaceTexture);
-          if (surfaceListener != null) {
-            surfaceListener.surfaceChanged(surface);
+          if (videoComponent != null) {
+            videoComponent.setVideoSurface(surface);
           }
           releaseSurface(oldSurfaceTexture, oldSurface);
         });
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index ed2fb8e2b2..027e57ee92 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -76,8 +76,7 @@
       android:includeFontPadding="false"
       android:textColor="#FFBEBEBE"/>
 
-    <com.google.android.exoplayer2.ui.DefaultTimeBar
-      android:id="@id/exo_progress"
+    <View android:id="@id/exo_progress_placeholder"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="26dp"/>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index f4a7976ebd..706fba0e0b 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -24,25 +24,43 @@
     <enum name="zoom" value="4"/>
   </attr>
 
-  <!-- Must be kept in sync with SimpleExoPlayerView -->
+  <!-- Must be kept in sync with PlayerView -->
   <attr name="surface_type" format="enum">
     <enum name="none" value="0"/>
     <enum name="surface_view" value="1"/>
     <enum name="texture_view" value="2"/>
     <enum name="spherical_view" value="3"/>
   </attr>
-  <attr name="show_timeout" format="integer"/>
-  <attr name="rewind_increment" format="integer"/>
-  <attr name="fastforward_increment" format="integer"/>
-  <attr name="player_layout_id" format="reference"/>
-  <attr name="controller_layout_id" format="reference"/>
+
+  <!-- Must be kept in sync with RepeatModeUtil -->
   <attr name="repeat_toggle_modes">
     <flag name="none" value="0"/>
     <flag name="one" value="1"/>
     <flag name="all" value="2"/>
   </attr>
+
+  <!-- PlayerControlView attributes -->
+  <attr name="show_timeout" format="integer"/>
+  <attr name="rewind_increment" format="integer"/>
+  <attr name="fastforward_increment" format="integer"/>
   <attr name="show_shuffle_button" format="boolean"/>
   <attr name="time_bar_min_update_interval" format="integer"/>
+  <attr name="controller_layout_id" format="reference"/>
+
+  <!-- DefaultTimeBar attributes -->
+  <attr name="bar_height" format="dimension"/>
+  <attr name="touch_target_height" format="dimension"/>
+  <attr name="ad_marker_width" format="dimension"/>
+  <attr name="scrubber_enabled_size" format="dimension"/>
+  <attr name="scrubber_disabled_size" format="dimension"/>
+  <attr name="scrubber_dragged_size" format="dimension"/>
+  <attr name="scrubber_drawable" format="reference"/>
+  <attr name="played_color" format="color"/>
+  <attr name="scrubber_color" format="color"/>
+  <attr name="buffered_color" format="color"/>
+  <attr name="unplayed_color" format="color"/>
+  <attr name="ad_marker_color" format="color"/>
+  <attr name="played_ad_marker_color" format="color"/>
 
   <declare-styleable name="PlayerView">
     <attr name="use_artwork" format="boolean"/>
@@ -58,9 +76,11 @@
       <enum name="always" value="2"/>
     </attr>
     <attr name="keep_content_on_player_reset" format="boolean"/>
-    <attr name="resize_mode"/>
+    <attr name="player_layout_id" format="reference"/>
+
     <attr name="surface_type"/>
-    <attr name="player_layout_id"/>
+    <!-- AspectRatioFrameLayout attributes -->
+    <attr name="resize_mode"/>
     <!-- PlayerControlView attributes -->
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
@@ -69,6 +89,20 @@
     <attr name="show_shuffle_button"/>
     <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
+    <!-- DefaultTimeBar attributes -->
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
   <declare-styleable name="AspectRatioFrameLayout">
@@ -83,22 +117,36 @@
     <attr name="show_shuffle_button"/>
     <attr name="time_bar_min_update_interval"/>
     <attr name="controller_layout_id"/>
+    <!-- DefaultTimeBar attributes -->
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
   <declare-styleable name="DefaultTimeBar">
-    <attr name="bar_height" format="dimension"/>
-    <attr name="touch_target_height" format="dimension"/>
-    <attr name="ad_marker_width" format="dimension"/>
-    <attr name="scrubber_enabled_size" format="dimension"/>
-    <attr name="scrubber_disabled_size" format="dimension"/>
-    <attr name="scrubber_dragged_size" format="dimension"/>
-    <attr name="scrubber_drawable" format="reference"/>
-    <attr name="played_color" format="color"/>
-    <attr name="scrubber_color" format="color"/>
-    <attr name="buffered_color" format="color"/>
-    <attr name="unplayed_color" format="color"/>
-    <attr name="ad_marker_color" format="color"/>
-    <attr name="played_ad_marker_color" format="color"/>
+    <attr name="bar_height"/>
+    <attr name="touch_target_height"/>
+    <attr name="ad_marker_width"/>
+    <attr name="scrubber_enabled_size"/>
+    <attr name="scrubber_disabled_size"/>
+    <attr name="scrubber_dragged_size"/>
+    <attr name="scrubber_drawable"/>
+    <attr name="played_color"/>
+    <attr name="scrubber_color"/>
+    <attr name="buffered_color" />
+    <attr name="unplayed_color"/>
+    <attr name="ad_marker_color"/>
+    <attr name="played_ad_marker_color"/>
   </declare-styleable>
 
 </resources>
diff --git a/library/ui/src/main/res/values/ids.xml b/library/ui/src/main/res/values/ids.xml
index e57301f946..17b55cd731 100644
--- a/library/ui/src/main/res/values/ids.xml
+++ b/library/ui/src/main/res/values/ids.xml
@@ -33,6 +33,7 @@
   <item name="exo_repeat_toggle" type="id"/>
   <item name="exo_duration" type="id"/>
   <item name="exo_position" type="id"/>
+  <item name="exo_progress_placeholder" type="id"/>
   <item name="exo_progress" type="id"/>
   <item name="exo_buffering" type="id"/>
   <item name="exo_error_message" type="id"/>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index dd5cfa64a7..5865d3c36d 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -34,7 +34,7 @@ android {
 dependencies {
     androidTestImplementation 'androidx.test:rules:' + androidXTestVersion
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
-    androidTestImplementation 'androidx.annotation:annotation:1.0.2'
+    androidTestImplementation 'androidx.annotation:annotation:1.1.0'
     androidTestImplementation project(modulePrefix + 'library-core')
     androidTestImplementation project(modulePrefix + 'library-dash')
     androidTestImplementation project(modulePrefix + 'library-hls')
diff --git a/publish.gradle b/publish.gradle
index 85cf87aa85..8cfc2b2ea1 100644
--- a/publish.gradle
+++ b/publish.gradle
@@ -23,6 +23,21 @@ if (project.ext.has("exoplayerPublishEnabled")
         groupId = 'com.google.android.exoplayer'
         website = 'https://github.com/google/ExoPlayer'
     }
+
+    gradle.taskGraph.whenReady { taskGraph ->
+        project.tasks
+                .findAll { task -> task.name.contains("generatePomFileFor") }
+                .forEach { task ->
+                    task.doLast {
+                        task.outputs.files
+                                .filter { File file ->
+                                    file.path.contains("publications") \
+                                        && file.name.matches("^pom-.+\\.xml\$")
+                                }
+                                .forEach { File file -> addLicense(file) }
+                    }
+                }
+    }
 }
 
 def getBintrayRepo() {
@@ -30,3 +45,24 @@ def getBintrayRepo() {
         property('publicRepo').toBoolean()
     return publicRepo ? 'exoplayer' : 'exoplayer-test'
 }
+
+static void addLicense(File pom) {
+    def licenseNode = new Node(null, "license")
+    licenseNode.append(
+        new Node(null, "name", "The Apache Software License, Version 2.0"))
+    licenseNode.append(
+        new Node(null, "url", "http://www.apache.org/licenses/LICENSE-2.0.txt"))
+    licenseNode.append(new Node(null, "distribution", "repo"))
+    def licensesNode = new Node(null, "licenses")
+    licensesNode.append(licenseNode)
+
+    def xml = new XmlParser().parse(pom)
+    xml.append(licensesNode)
+
+    def writer = new PrintWriter(new FileWriter(pom))
+    writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
+    def printer = new XmlNodePrinter(writer)
+    printer.preserveWhitespace = true
+    printer.print(xml)
+    writer.close()
+}
diff --git a/testutils/build.gradle b/testutils/build.gradle
index bdc26d5c19..1ec358b83d 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -41,7 +41,7 @@ dependencies {
     api 'org.mockito:mockito-core:' + mockitoVersion
     api 'androidx.test.ext:junit:' + androidXTestVersion
     api 'androidx.test.ext:truth:' + androidXTestVersion
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation project(modulePrefix + 'library-core')
     implementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
     annotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
index 70059114db..8b11a89d8d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
@@ -30,7 +30,6 @@
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
-import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.nio.ByteBuffer;
@@ -55,6 +54,7 @@ protected void buildVideoRenderers(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys,
+      boolean enableDecoderFallback,
       Handler eventHandler,
       VideoRendererEventListener eventListener,
       long allowedVideoJoiningTimeMs,
@@ -113,8 +113,7 @@ protected void configureCodec(
         MediaCodec codec,
         Format format,
         MediaCrypto crypto,
-        float operatingRate)
-        throws DecoderQueryException {
+        float operatingRate) {
       // If the codec is being initialized whilst the renderer is started, default behavior is to
       // render the first frame (i.e. the keyframe before the current position), then drop frames up
       // to the current playback position. For test runs that place a maximum limit on the number of
@@ -164,14 +163,15 @@ protected boolean processOutputBuffer(
         int bufferIndex,
         int bufferFlags,
         long bufferPresentationTimeUs,
-        boolean shouldSkip,
+        boolean isDecodeOnlyBuffer,
+        boolean isLastBuffer,
         Format format)
         throws ExoPlaybackException {
       if (skipToPositionBeforeRenderingFirstFrame && bufferPresentationTimeUs < positionUs) {
         // After the codec has been initialized, don't render the first frame until we've caught up
         // to the playback position. Else test runs on devices that do not support dummy surface
         // will drop frames between rendering the first one and catching up [Internal: b/66494991].
-        shouldSkip = true;
+        isDecodeOnlyBuffer = true;
       }
       return super.processOutputBuffer(
           positionUs,
@@ -181,7 +181,8 @@ protected boolean processOutputBuffer(
           bufferIndex,
           bufferFlags,
           bufferPresentationTimeUs,
-          shouldSkip,
+          isDecodeOnlyBuffer,
+          isLastBuffer,
           format);
     }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
index 517f1ce2e7..2f91c1926c 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
@@ -418,7 +418,7 @@ public ExoPlayerTestRunner start() {
             if (actionSchedule != null) {
               actionSchedule.start(player, trackSelector, null, handler, ExoPlayerTestRunner.this);
             }
-            player.prepare(mediaSource);
+            player.prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
           } catch (Exception e) {
             handleException(e);
           }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
index 3937dabcaf..a933121bc5 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
@@ -175,17 +175,26 @@ private static FakeExtractorOutput assertOutput(
       extractorOutput.assertOutput(context, file + ".0" + DUMP_EXTENSION);
     }
 
+    // Seeking to (timeUs=0, position=0) should always work, and cause the same data to be output.
+    extractorOutput.clearTrackOutputs();
+    input.reset();
+    consumeTestData(extractor, input, /* timeUs= */ 0, extractorOutput, false);
+    if (simulateUnknownLength && assetExists(context, file + UNKNOWN_LENGTH_EXTENSION)) {
+      extractorOutput.assertOutput(context, file + UNKNOWN_LENGTH_EXTENSION);
+    } else {
+      extractorOutput.assertOutput(context, file + ".0" + DUMP_EXTENSION);
+    }
+
+    // If the SeekMap is seekable, test seeking to 4 positions in the stream.
     SeekMap seekMap = extractorOutput.seekMap;
     if (seekMap.isSeekable()) {
       long durationUs = seekMap.getDurationUs();
       for (int j = 0; j < 4; j++) {
+        extractorOutput.clearTrackOutputs();
         long timeUs = (durationUs * j) / 3;
         long position = seekMap.getSeekPoints(timeUs).first.position;
+        input.reset();
         input.setPosition((int) position);
-        for (int i = 0; i < extractorOutput.numberOfTracks; i++) {
-          extractorOutput.trackOutputs.valueAt(i).clear();
-        }
-
         consumeTestData(extractor, input, timeUs, extractorOutput, false);
         extractorOutput.assertOutput(context, file + '.' + j + DUMP_EXTENSION);
       }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
index c467bd36af..1a127eeab5 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
@@ -80,6 +80,15 @@ private FakeExtractorInput(byte[] data, boolean simulateUnknownLength,
     failedPeekPositions = new SparseBooleanArray();
   }
 
+  /** Resets the input to its initial state. */
+  public void reset() {
+    readPosition = 0;
+    peekPosition = 0;
+    partiallySatisfiedTargetPositions.clear();
+    failedReadPositions.clear();
+    failedPeekPositions.clear();
+  }
+
   /**
    * Sets the read and peek positions.
    *
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
index c6543bd7a5..4022a0ccc1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
@@ -70,6 +70,12 @@ public void seekMap(SeekMap seekMap) {
     this.seekMap = seekMap;
   }
 
+  public void clearTrackOutputs() {
+    for (int i = 0; i < numberOfTracks; i++) {
+      trackOutputs.valueAt(i).clear();
+    }
+  }
+
   public void assertEquals(FakeExtractorOutput expected) {
     assertThat(numberOfTracks).isEqualTo(expected.numberOfTracks);
     assertThat(tracksEnded).isEqualTo(expected.tracksEnded);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 73e8ac4f3e..39429a8fa1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -166,7 +166,8 @@ public void runTest(
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     requestWindowFeature(Window.FEATURE_NO_TITLE);
-    setContentView(getResources().getIdentifier("host_activity", "layout", getPackageName()));
+    setContentView(
+        getResources().getIdentifier("exo_testutils_host_activity", "layout", getPackageName()));
     surfaceView = findViewById(
         getResources().getIdentifier("surface_view", "id", getPackageName()));
     surfaceView.getHolder().addCallback(this);
diff --git a/testutils/src/main/res/layout/host_activity.xml b/testutils/src/main/res/layout/exo_testutils_host_activity.xml
similarity index 100%
rename from testutils/src/main/res/layout/host_activity.xml
rename to testutils/src/main/res/layout/exo_testutils_host_activity.xml
diff --git a/testutils_robolectric/build.gradle b/testutils_robolectric/build.gradle
index a3859a9e48..758d22b5d9 100644
--- a/testutils_robolectric/build.gradle
+++ b/testutils_robolectric/build.gradle
@@ -41,5 +41,5 @@ dependencies {
     api 'org.robolectric:robolectric:' + robolectricVersion
     api project(modulePrefix + 'testutils')
     implementation project(modulePrefix + 'library-core')
-    implementation 'androidx.annotation:annotation:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
index 664532d3ff..00c9e60bd5 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
@@ -33,58 +33,89 @@
 /** Assertion methods for {@link Cache}. */
 public final class CacheAsserts {
 
-  /**
-   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
-    ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    Uri[] uris = new Uri[allData.size()];
-    for (int i = 0; i < allData.size(); i++) {
-      uris[i] = allData.get(i).uri;
+  /** Defines a set of data requests. */
+  public static final class RequestSet {
+
+    private final FakeDataSet fakeDataSet;
+    private DataSpec[] dataSpecs;
+
+    public RequestSet(FakeDataSet fakeDataSet) {
+      this.fakeDataSet = fakeDataSet;
+      ArrayList<FakeData> allData = fakeDataSet.getAllData();
+      dataSpecs = new DataSpec[allData.size()];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(allData.get(i).uri);
+      }
     }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
 
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   *
-   * @throws IOException If an error occurred reading from the Cache.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
-      throws IOException {
-    Uri[] uris = new Uri[uriStrings.length];
-    for (int i = 0; i < uriStrings.length; i++) {
-      uris[i] = Uri.parse(uriStrings[i]);
+    public RequestSet subset(String... uriStrings) {
+      dataSpecs = new DataSpec[uriStrings.length];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(Uri.parse(uriStrings[i]));
+      }
+      return this;
+    }
+
+    public RequestSet subset(Uri... uris) {
+      dataSpecs = new DataSpec[uris.length];
+      for (int i = 0; i < dataSpecs.length; i++) {
+        dataSpecs[i] = new DataSpec(uris[i]);
+      }
+      return this;
+    }
+
+    public RequestSet subset(DataSpec... dataSpecs) {
+      this.dataSpecs = dataSpecs;
+      return this;
+    }
+
+    public int getCount() {
+      return dataSpecs.length;
+    }
+
+    public byte[] getData(int i) {
+      return fakeDataSet.getData(dataSpecs[i].uri).getData();
+    }
+
+    public DataSpec getDataSpec(int i) {
+      return dataSpecs[i];
+    }
+
+    public RequestSet useBoundedDataSpecFor(String uriString) {
+      FakeData data = fakeDataSet.getData(uriString);
+      for (int i = 0; i < dataSpecs.length; i++) {
+        DataSpec spec = dataSpecs[i];
+        if (spec.uri.getPath().equals(uriString)) {
+          dataSpecs[i] = spec.subrange(0, data.getData().length);
+          return this;
+        }
+      }
+      throw new IllegalStateException();
     }
-    assertCachedData(cache, fakeDataSet, uris);
   }
 
   /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   * Asserts that the cache contains necessary data for the {@code requestSet}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
+  public static void assertCachedData(Cache cache, RequestSet requestSet) throws IOException {
     int totalLength = 0;
-    for (Uri uri : uris) {
-      byte[] data = fakeDataSet.getData(uri).getData();
-      assertDataCached(cache, uri, data);
+    for (int i = 0; i < requestSet.getCount(); i++) {
+      byte[] data = requestSet.getData(i);
+      assertDataCached(cache, requestSet.getDataSpec(i), data);
       totalLength += data.length;
     }
     assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
   }
 
   /**
-   * Asserts that the cache contains the given data for {@code uriString}.
+   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
    *
    * @throws IOException If an error occurred reading from the Cache.
    */
-  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    DataSpec dataSpec = new DataSpec(uri);
-    assertDataCached(cache, dataSpec, expected);
+  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
+    assertCachedData(cache, new RequestSet(fakeDataSet));
   }
 
   /**
@@ -95,15 +126,18 @@ public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throw
   public static void assertDataCached(Cache cache, DataSpec dataSpec, byte[] expected)
       throws IOException {
     DataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    dataSource.open(dataSpec);
+    byte[] bytes;
     try {
-      byte[] bytes = TestUtil.readToEnd(dataSource);
-      assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
-          .that(bytes)
-          .isEqualTo(expected);
+      dataSource.open(dataSpec);
+      bytes = TestUtil.readToEnd(dataSource);
+    } catch (IOException e) {
+      throw new IOException("Opening/reading cache failed: " + dataSpec, e);
     } finally {
       dataSource.close();
     }
+    assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
+        .that(bytes)
+        .isEqualTo(expected);
   }
 
   /**
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
index 6669504c07..fd7be241df 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaChunk.java
@@ -27,7 +27,7 @@
 /** Fake {@link MediaChunk}. */
 public final class FakeMediaChunk extends MediaChunk {
 
-  private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT", null);
+  private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT");
 
   public FakeMediaChunk(Format trackFormat, long startTimeUs, long endTimeUs) {
     this(new DataSpec(Uri.EMPTY), trackFormat, startTimeUs, endTimeUs);
