diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index 1c9a148226..dfc2b3822a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import android.os.Trace;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -23,10 +25,12 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -290,7 +294,9 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolea
           }
           // Write the sample data into the holder.
           buffer.ensureSpaceForWrite(extrasHolder.size);
+//          TraceUtil.beginSection("DefaultTrackOutput.readData(Move Allocation to DecodeInputBuffer):" + buffer.data.hashCode());
           readData(extrasHolder.offset, buffer.data, extrasHolder.size);
+//          TraceUtil.endSection();
           // Advance the read head.
           dropDownstreamTo(extrasHolder.nextOffset);
         }
@@ -409,8 +415,10 @@ private void readData(long absolutePosition, byte[] target, int length) {
       int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
       int toCopy = Math.min(length - bytesRead, allocationLength - positionInAllocation);
       Allocation allocation = dataQueue.peek();
+      TraceUtil.beginSection("DefaultTrackOutput.readData(dataQueue deque): " + String.valueOf(Arrays.hashCode(allocation.data)));
       System.arraycopy(allocation.data, allocation.translateOffset(positionInAllocation), target,
           bytesRead, toCopy);
+      TraceUtil.endSection();
       absolutePosition += toCopy;
       bytesRead += toCopy;
     }
@@ -481,8 +489,10 @@ public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
     }
     try {
       length = prepareForAppend(length);
+      TraceUtil.beginSection("DefaultTrackOutput.sampleData(Fetch data from upstream): " + String.valueOf(Arrays.hashCode(lastAllocation.data)));
       int bytesAppended = input.read(lastAllocation.data,
           lastAllocation.translateOffset(lastAllocationOffset), length);
+      TraceUtil.endSection();
       if (bytesAppended == C.RESULT_END_OF_INPUT) {
         if (allowEndOfInput) {
           return C.RESULT_END_OF_INPUT;
@@ -570,7 +580,9 @@ private int prepareForAppend(int length) {
     if (lastAllocationOffset == allocationLength) {
       lastAllocationOffset = 0;
       lastAllocation = allocator.allocate();
+      TraceUtil.beginSection("DefaultTrackOutput.prepareForAppend(dataQueue enque): " + String.valueOf(Arrays.hashCode(lastAllocation.data)));
       dataQueue.add(lastAllocation);
+      TraceUtil.endSection();
     }
     return Math.min(length, allocationLength - lastAllocationOffset);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java
index 08b42533cc..3f91b70c47 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.util.Log;
+
 /**
  * An allocation within a byte array.
  * <p>
@@ -31,6 +33,10 @@
 
   private final int offset;
 
+  public final int id;
+
+  private static String TAG = "Allocation";
+
   /**
    * @param data The array containing the allocated space.
    * @param offset The offset of the allocated space within the array.
@@ -38,6 +44,20 @@
   public Allocation(byte[] data, int offset) {
     this.data = data;
     this.offset = offset;
+    this.id = this.hashCode();
+    Log.i(TAG, "New id #hash :"+ this.id);
+  }
+
+  /**
+   * @param data The array containing the allocated space.
+   * @param offset The offset of the allocated space within the array.
+   * @param id The given ID for this allocation.
+   */
+  public Allocation(byte[] data, int offset, int id) {
+    this.data = data;
+    this.offset = offset;
+    this.id = id;
+    Log.d(TAG, "New id #id :" + this.id);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
index d9bd5873f0..634fc1b4b4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.util.Log;
+
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
@@ -35,6 +37,8 @@
   private int allocatedCount;
   private int availableCount;
   private Allocation[] availableAllocations;
+  private int allocationId;
+  private static String TAG = "DefaultAllocator";
 
   /**
    * Constructs an instance without creating any {@link Allocation}s up front.
@@ -61,6 +65,7 @@ public DefaultAllocator(boolean trimOnReset, int individualAllocationSize,
       int initialAllocationCount) {
     Assertions.checkArgument(individualAllocationSize > 0);
     Assertions.checkArgument(initialAllocationCount >= 0);
+    this.allocationId = 0;
     this.trimOnReset = trimOnReset;
     this.individualAllocationSize = individualAllocationSize;
     this.availableCount = initialAllocationCount;
@@ -69,12 +74,13 @@ public DefaultAllocator(boolean trimOnReset, int individualAllocationSize,
       initialAllocationBlock = new byte[initialAllocationCount * individualAllocationSize];
       for (int i = 0; i < initialAllocationCount; i++) {
         int allocationOffset = i * individualAllocationSize;
-        availableAllocations[i] = new Allocation(initialAllocationBlock, allocationOffset);
+        availableAllocations[i] = new Allocation(initialAllocationBlock, allocationOffset, this.allocationId++);
       }
     } else {
       initialAllocationBlock = null;
     }
     singleAllocationReleaseHolder = new Allocation[1];
+
   }
 
   public synchronized void reset() {
@@ -98,8 +104,10 @@ public synchronized Allocation allocate() {
     if (availableCount > 0) {
       allocation = availableAllocations[--availableCount];
       availableAllocations[availableCount] = null;
+      Log.d(TAG, "Reuse previous allocation #"+ allocation.id);
     } else {
-      allocation = new Allocation(new byte[individualAllocationSize], 0);
+      allocation = new Allocation(new byte[individualAllocationSize], 0, allocationId++);
+      Log.d(TAG, "Create new allocation #"+ allocation.id);
     }
     return allocation;
   }
@@ -121,6 +129,7 @@ public synchronized void release(Allocation[] allocations) {
       Assertions.checkArgument(allocation.data == initialAllocationBlock
           || allocation.data.length == individualAllocationSize);
       availableAllocations[availableCount++] = allocation;
+      Log.d(TAG, "Save used allocation as free space #"+ allocation.id);
     }
     allocatedCount -= allocations.length;
     // Wake up threads waiting for the allocated size to drop.
