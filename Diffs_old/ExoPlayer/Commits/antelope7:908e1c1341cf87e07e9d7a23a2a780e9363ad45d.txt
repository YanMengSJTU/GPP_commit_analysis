diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index ace9a1f05c..8fce4f9612 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -25,14 +25,13 @@
 import com.google.android.exoplayer.SampleSourceTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioTrack;
-import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.InputBuffer;
-import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.OutputBuffer;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
 
 import android.os.Handler;
 
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 import java.util.List;
 
 /**
@@ -76,6 +75,9 @@
    */
   public static final int MSG_SET_VOLUME = 1;
 
+  private static final int NUM_BUFFERS = 16;
+  private static final int INITIAL_INPUT_BUFFER_SIZE = 960 * 6;
+
   public final CodecCounters codecCounters = new CodecCounters();
 
   private final Handler eventHandler;
@@ -83,9 +85,9 @@
   private final MediaFormatHolder formatHolder;
 
   private MediaFormat format;
-  private OpusDecoderWrapper decoder;
+  private DecoderWrapper<InputBuffer, OpusOutputBuffer, OpusDecoderException> decoderWrapper;
   private InputBuffer inputBuffer;
-  private OutputBuffer outputBuffer;
+  private OpusOutputBuffer outputBuffer;
 
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
@@ -124,7 +126,7 @@ public LibopusAudioTrackRenderer(SampleSource source, Handler eventHandler,
    * Returns whether the underlying libopus library is available.
    */
   public static boolean isLibopusAvailable() {
-    return OpusDecoder.isLibopusAvailable();
+    return OpusDecoder.IS_AVAILABLE;
   }
 
   /**
@@ -159,7 +161,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
     }
 
     // If we don't have a decoder yet, we need to instantiate one.
-    if (decoder == null) {
+    if (decoderWrapper == null) {
       // For opus, the format can contain upto 3 entries in initializationData in the following
       // exact order:
       // 1) Opus Header Information (required)
@@ -169,24 +171,16 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
       if (initializationData.size() < 1) {
         throw new ExoPlaybackException("Missing initialization data");
       }
-      long codecDelayNs = -1;
-      long seekPreRollNs = -1;
-      if (initializationData.size() == 3) {
-        if (initializationData.get(1).length != 8 || initializationData.get(2).length != 8) {
-          throw new ExoPlaybackException("Invalid Codec Delay or Seek Preroll");
-        }
-        codecDelayNs =
-            ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.LITTLE_ENDIAN).getLong();
-        seekPreRollNs =
-            ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.LITTLE_ENDIAN).getLong();
-      }
+      OpusDecoder decoder;
       try {
-        decoder = new OpusDecoderWrapper(initializationData.get(0), codecDelayNs, seekPreRollNs);
+        decoder = new OpusDecoder(initializationData);
       } catch (OpusDecoderException e) {
         notifyDecoderError(e);
         throw new ExoPlaybackException(e);
       }
-      decoder.start();
+      decoderWrapper = new DecoderWrapper<>(decoder, new InputBuffer[NUM_BUFFERS],
+          new OpusOutputBuffer[NUM_BUFFERS], INITIAL_INPUT_BUFFER_SIZE);
+      decoderWrapper.start();
       codecCounters.codecInitCount++;
     }
 
@@ -214,16 +208,16 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
     }
 
     if (outputBuffer == null) {
-      outputBuffer = decoder.dequeueOutputBuffer();
+      outputBuffer = decoderWrapper.dequeueOutputBuffer();
       if (outputBuffer == null) {
         return;
       }
     }
 
-    if (outputBuffer.getFlag(OpusDecoderWrapper.FLAG_END_OF_STREAM)) {
+    if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputStreamEnded = true;
       audioTrack.handleEndOfStream();
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
       return;
     }
@@ -240,8 +234,8 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
     }
 
     int handleBufferResult;
-    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data,
-        outputBuffer.data.position(), outputBuffer.size, outputBuffer.timestampUs);
+    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.data.position(),
+        outputBuffer.size, outputBuffer.timestampUs);
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
@@ -250,8 +244,8 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
 
     // Release the buffer if it was consumed.
     if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
-      decoder.releaseOutputBuffer(outputBuffer);
       codecCounters.renderedOutputBufferCount++;
+      outputBuffer.release();
       outputBuffer = null;
     }
   }
@@ -262,7 +256,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoder.dequeueInputBuffer();
+      inputBuffer = decoderWrapper.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -277,26 +271,29 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
       return true;
     }
     if (result == SampleSource.END_OF_STREAM) {
-      inputBuffer.setFlag(OpusDecoderWrapper.FLAG_END_OF_STREAM);
-      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      decoderWrapper.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
       return false;
     }
     if (notifyDiscontinuityToDecoder) {
       notifyDiscontinuityToDecoder = false;
-      inputBuffer.setFlag(OpusDecoderWrapper.FLAG_RESET_DECODER);
+      inputBuffer.setFlag(Buffer.FLAG_RESET);
     }
 
-    decoder.queueInputBuffer(inputBuffer);
+    decoderWrapper.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
   }
 
   private void flushDecoder() {
     inputBuffer = null;
-    outputBuffer = null;
-    decoder.flush();
+    if (outputBuffer != null) {
+      outputBuffer.release();
+      outputBuffer = null;
+    }
+    decoderWrapper.flush();
     notifyDiscontinuityToDecoder = true;
   }
 
@@ -330,7 +327,7 @@ protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     outputStreamEnded = false;
     sourceIsReady = false;
-    if (decoder != null) {
+    if (decoderWrapper != null) {
       flushDecoder();
     }
   }
@@ -352,9 +349,9 @@ protected void onDisabled() throws ExoPlaybackException {
     format = null;
     audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
-      if (decoder != null) {
-        decoder.release();
-        decoder = null;
+      if (decoderWrapper != null) {
+        decoderWrapper.release();
+        decoderWrapper = null;
         codecCounters.codecReleaseCount++;
       }
       audioTrack.release();
@@ -384,7 +381,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
 
   private void notifyAudioTrackInitializationError(final AudioTrack.InitializationException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onAudioTrackInitializationError(e);
@@ -395,7 +392,7 @@ public void run() {
 
   private void notifyAudioTrackWriteError(final AudioTrack.WriteException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onAudioTrackWriteError(e);
@@ -406,7 +403,7 @@ public void run() {
 
   private void notifyDecoderError(final OpusDecoderException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onDecoderError(e);
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index d63da51700..bab15e79e5 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -15,16 +15,26 @@
  */
 package com.google.android.exoplayer.ext.opus;
 
-import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.OpusHeader;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.Decoder;
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
 
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.List;
 
 /**
- * JNI Wrapper for the libopus Opus decoder.
+ * JNI wrapper for the libopus Opus decoder.
  */
-/* package */ class OpusDecoder {
+/* package */ final class OpusDecoder implements Decoder<InputBuffer, OpusOutputBuffer,
+    OpusDecoderException> {
 
-  private static final boolean IS_AVAILABLE;
+  /**
+   * Whether the underlying libopus library is available.
+   */
+  public static final boolean IS_AVAILABLE;
   static {
     boolean isAvailable;
     try {
@@ -37,67 +47,155 @@
     IS_AVAILABLE = isAvailable;
   }
 
+  /**
+   * Returns the version string of the underlying libopus decoder.
+   */
+  public static native String getLibopusVersion();
+
+  private static final int DEFAULT_SEEK_PRE_ROLL_SAMPLES = 3840;
+
+  /**
+   * Opus streams are always decoded at 48000 Hz.
+   */
+  private static final int SAMPLE_RATE = 48000;
+
+  private final int channelCount;
+  private final int seekPreRollSamples;
   private final long nativeDecoderContext;
 
+  private int skipSamples;
+
+  private OpusDecoderException exception;
+
   /**
    * Creates the Opus Decoder.
    *
-   * @param opusHeader OpusHeader used to initialize the decoder.
-   * @throws OpusDecoderException if the decoder initialization fails.
+   * @param initializationData Codec-specific initialization data. The first element must contain an
+   *     opus header. Optionally, the list may contain two additional buffers, which must contain
+   *     the encoder delay and seek pre roll values in nanoseconds, encoded as longs.
+   * @throws OpusDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public OpusDecoder(OpusHeader opusHeader) throws OpusDecoderException {
-    nativeDecoderContext = opusInit(
-        opusHeader.sampleRate, opusHeader.channelCount, opusHeader.numStreams,
-        opusHeader.numCoupled, opusHeader.gain, opusHeader.streamMap);
+  public OpusDecoder(List<byte[]> initializationData) throws OpusDecoderException {
+    byte[] headerBytes = initializationData.get(0);
+    if (headerBytes.length < 19) {
+      throw new OpusDecoderException("Header size is too small.");
+    }
+    channelCount = headerBytes[9] & 0xFF;
+    if (channelCount > 8) {
+      throw new OpusDecoderException("Invalid channel count: " + channelCount);
+    }
+    skipSamples = readLittleEndian16(headerBytes, 10);
+    int gain = readLittleEndian16(headerBytes, 16);
+
+    byte[] streamMap = new byte[8];
+    int numStreams, numCoupled;
+    if (headerBytes[18] == 0) { // Channel mapping
+      // If there is no channel mapping, use the defaults.
+      if (channelCount > 2) { // Maximum channel count with default layout.
+        throw new OpusDecoderException("Invalid Header, missing stream map.");
+      }
+      numStreams = 1;
+      numCoupled = (channelCount == 2) ? 1 : 0;
+      streamMap[0] = 0;
+      streamMap[1] = 1;
+    } else {
+      if (headerBytes.length < 21 + channelCount) {
+        throw new OpusDecoderException("Header size is too small.");
+      }
+      // Read the channel mapping.
+      numStreams = headerBytes[19] & 0xFF;
+      numCoupled = headerBytes[20] & 0xFF;
+      for (int i = 0; i < channelCount; i++) {
+        streamMap[i] = headerBytes[21 + i];
+      }
+    }
+    if (initializationData.size() == 3) {
+      if (initializationData.get(1).length != 8 || initializationData.get(2).length != 8) {
+        throw new OpusDecoderException("Invalid Codec Delay or Seek Preroll");
+      }
+      long codecDelayNs =
+          ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.LITTLE_ENDIAN).getLong();
+      long seekPreRollNs =
+          ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.LITTLE_ENDIAN).getLong();
+      skipSamples = nsToSamples(codecDelayNs);
+      seekPreRollSamples = nsToSamples(seekPreRollNs);
+    } else {
+      seekPreRollSamples = DEFAULT_SEEK_PRE_ROLL_SAMPLES;
+    }
+    nativeDecoderContext = opusInit(SAMPLE_RATE, channelCount, numStreams, numCoupled, gain,
+        streamMap);
     if (nativeDecoderContext == 0) {
       throw new OpusDecoderException("Failed to initialize decoder");
     }
   }
 
-  /**
-   * Decodes an Opus Encoded Stream.
-   *
-   * @param inputBuffer buffer containing the encoded data. Must be allocated using allocateDirect.
-   * @param inputSize size of the input buffer.
-   * @param outputBuffer buffer to write the decoded data. Must be allocated using allocateDirect.
-   * @param outputSize Maximum capacity of the output buffer.
-   * @return number of decoded bytes.
-   * @throws OpusDecoderException if decode fails.
-   */
-  public int decode(ByteBuffer inputBuffer, int inputSize, ByteBuffer outputBuffer,
-      int outputSize) throws OpusDecoderException {
-    int result = opusDecode(nativeDecoderContext, inputBuffer, inputSize, outputBuffer, outputSize);
-    if (result < 0) {
-      throw new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
-    }
-    return result;
+  @Override
+  public InputBuffer createInputBuffer(int initialSize) {
+    return new InputBuffer(initialSize);
   }
 
-  /**
-   * Closes the native decoder.
-   */
-  public void close() {
-    opusClose(nativeDecoderContext);
+  @Override
+  public OpusOutputBuffer createOutputBuffer(
+      DecoderWrapper<InputBuffer, OpusOutputBuffer, OpusDecoderException> owner) {
+    return new OpusOutputBuffer(owner);
   }
 
-  /**
-   * Resets the native decode on discontinuity (during seek for example).
-   */
-  public void reset() {
-    opusReset(nativeDecoderContext);
+  @Override
+  public boolean decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
+    outputBuffer.reset();
+    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      return true;
+    }
+    if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
+      outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
+    if (inputBuffer.getFlag(Buffer.FLAG_RESET)) {
+      opusReset(nativeDecoderContext);
+      // When seeking to 0, skip number of samples as specified in opus header. When seeking to
+      // any other time, skip number of samples as specified by seek preroll.
+      skipSamples =
+          (inputBuffer.sampleHolder.timeUs == 0) ? skipSamples : seekPreRollSamples;
+    }
+    SampleHolder sampleHolder = inputBuffer.sampleHolder;
+    outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+    outputBuffer.init(sampleHolder.data.capacity() * 2);
+    int result = opusDecode(nativeDecoderContext, sampleHolder.data, sampleHolder.size,
+        outputBuffer.data, outputBuffer.data.capacity());
+    if (result < 0) {
+      exception = new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
+      return false;
+    }
+    outputBuffer.size = result;
+    outputBuffer.data.position(0);
+    if (skipSamples > 0) {
+      int bytesPerSample = channelCount * 2;
+      int skipBytes = skipSamples * bytesPerSample;
+      if (outputBuffer.size <= skipBytes) {
+        skipSamples -= outputBuffer.size / bytesPerSample;
+        outputBuffer.size = 0;
+        outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+      } else {
+        skipSamples = 0;
+        outputBuffer.size -= skipBytes;
+        outputBuffer.data.position(skipBytes);
+      }
+    }
+    return true;
   }
 
-  /**
-   * Returns whether the underlying libopus library is available.
-   */
-  public static boolean isLibopusAvailable() {
-    return IS_AVAILABLE;
+  @Override
+  public void maybeThrowException() throws OpusDecoderException {
+    if (exception != null) {
+      throw exception;
+    }
   }
 
-  /**
-   * Returns the version string of the underlying libopus decoder.
-   */
-  public static native String getLibopusVersion();
+  @Override
+  public void release() {
+    opusClose(nativeDecoderContext);
+  }
 
   private native long opusInit(int sampleRate, int channelCount, int numStreams, int numCoupled,
       int gain, byte[] streamMap);
@@ -107,4 +205,14 @@ private native int opusDecode(long decoder, ByteBuffer inputBuffer, int inputSiz
   private native void opusReset(long decoder);
   private native String opusGetErrorMessage(int errorCode);
 
+  private static int nsToSamples(long ns) {
+    return (int) (ns * SAMPLE_RATE / 1000000000);
+  }
+
+  private static int readLittleEndian16(byte[] input, int offset) {
+    int value = input[offset] & 0xFF;
+    value |= (input[offset + 1] & 0xFF) << 8;
+    return value;
+  }
+
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
index 13e7739df9..a3ff1b0688 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
@@ -18,10 +18,10 @@
 /**
  * Thrown when an Opus decoder error occurs.
  */
-public class OpusDecoderException extends Exception {
+public final class OpusDecoderException extends Exception {
 
-    public OpusDecoderException(String message) {
-      super(message);
-    }
+  /* package */ OpusDecoderException(String message) {
+    super(message);
+  }
 
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
deleted file mode 100644
index d4f6c8e306..0000000000
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.ext.opus;
-
-import com.google.android.exoplayer.SampleHolder;
-
-import java.nio.ByteBuffer;
-import java.util.LinkedList;
-
-/**
- * Wraps {@link OpusDecoder}, exposing a higher level decoder interface.
- */
-/* package */ class OpusDecoderWrapper extends Thread {
-
-  public static final int FLAG_END_OF_STREAM = 1;
-  public static final int FLAG_RESET_DECODER = 2;
-
-  private static final int INPUT_BUFFER_SIZE = 960 * 6;
-  private static final int OUTPUT_BUFFER_SIZE = 960 * 6 * 2;
-  private static final int NUM_BUFFERS = 16;
-  private static final int DEFAULT_SEEK_PRE_ROLL = 3840;
-
-  private final Object lock;
-  private final OpusHeader opusHeader;
-
-  private final LinkedList<InputBuffer> dequeuedInputBuffers;
-  private final LinkedList<InputBuffer> queuedInputBuffers;
-  private final LinkedList<OutputBuffer> queuedOutputBuffers;
-  private final LinkedList<OutputBuffer> dequeuedOutputBuffers;
-  private final InputBuffer[] availableInputBuffers;
-  private final OutputBuffer[] availableOutputBuffers;
-  private int availableInputBufferCount;
-  private int availableOutputBufferCount;
-
-  private int skipSamples;
-  private boolean flushDecodedOutputBuffer;
-  private boolean released;
-
-  private int seekPreRoll;
-
-  private OpusDecoderException decoderException;
-
-  /**
-   * @param headerBytes Opus header data that is used to initialize the decoder. For WebM Container,
-   *    this comes from the CodecPrivate Track element.
-   * @param codecDelayNs Delay in nanoseconds added by the codec at the beginning. For WebM
-   *    Container, this comes from the CodecDelay Track Element. Can be -1 in which case the value
-   *    from the codec header will be used.
-   * @param seekPreRollNs Duration in nanoseconds of samples to discard when there is a
-   *    discontinuity. For WebM Container, this comes from the SeekPreRoll Track Element. Can be -1
-   *    in which case the default value of 80ns will be used.
-   * @throws OpusDecoderException if an exception occurs when initializing the decoder.
-   */
-  public OpusDecoderWrapper(byte[] headerBytes, long codecDelayNs,
-      long seekPreRollNs) throws OpusDecoderException {
-    lock = new Object();
-    opusHeader = parseOpusHeader(headerBytes);
-    skipSamples = (codecDelayNs == -1) ? opusHeader.skipSamples
-        : nsToSamples(opusHeader, codecDelayNs);
-    seekPreRoll = (seekPreRoll == -1) ? DEFAULT_SEEK_PRE_ROLL
-        : nsToSamples(opusHeader, seekPreRollNs);
-    dequeuedInputBuffers = new LinkedList<>();
-    queuedInputBuffers = new LinkedList<>();
-    queuedOutputBuffers = new LinkedList<>();
-    dequeuedOutputBuffers = new LinkedList<>();
-    availableInputBuffers = new InputBuffer[NUM_BUFFERS];
-    availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
-    availableInputBufferCount = NUM_BUFFERS;
-    availableOutputBufferCount = NUM_BUFFERS;
-    for (int i = 0; i < NUM_BUFFERS; i++) {
-      availableInputBuffers[i] = new InputBuffer();
-      availableOutputBuffers[i] = new OutputBuffer();
-    }
-  }
-
-  public InputBuffer dequeueInputBuffer() throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      if (availableInputBufferCount == 0) {
-        return null;
-      }
-      InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
-      inputBuffer.reset();
-      dequeuedInputBuffers.addLast(inputBuffer);
-      return inputBuffer;
-    }
-  }
-
-  public void queueInputBuffer(InputBuffer inputBuffer) throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      dequeuedInputBuffers.remove(inputBuffer);
-      queuedInputBuffers.addLast(inputBuffer);
-      maybeNotifyDecodeLoop();
-    }
-  }
-
-  public OutputBuffer dequeueOutputBuffer() throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      if (queuedOutputBuffers.isEmpty()) {
-        return null;
-      }
-      OutputBuffer outputBuffer = queuedOutputBuffers.removeFirst();
-      dequeuedOutputBuffers.add(outputBuffer);
-      return outputBuffer;
-    }
-  }
-
-  public void releaseOutputBuffer(OutputBuffer outputBuffer) throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      outputBuffer.reset();
-      dequeuedOutputBuffers.remove(outputBuffer);
-      availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
-      maybeNotifyDecodeLoop();
-    }
-  }
-
-  public void flush() {
-    synchronized (lock) {
-      flushDecodedOutputBuffer = true;
-      while (!dequeuedInputBuffers.isEmpty()) {
-        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffers.removeFirst();
-      }
-      while (!queuedInputBuffers.isEmpty()) {
-        availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
-      }
-      while (!queuedOutputBuffers.isEmpty()) {
-        availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
-      }
-      while (!dequeuedOutputBuffers.isEmpty()) {
-        availableOutputBuffers[availableOutputBufferCount++] = dequeuedOutputBuffers.removeFirst();
-      }
-    }
-  }
-
-  public void release() {
-    synchronized (lock) {
-      released = true;
-      lock.notify();
-    }
-    try {
-      join();
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void maybeThrowDecoderError() throws OpusDecoderException {
-    if (decoderException != null) {
-      throw decoderException;
-    }
-  }
-
-  /**
-   * Notifies the decode loop if there exists a queued input buffer and an available output buffer
-   * to decode into.
-   * <p>
-   * Should only be called whilst synchronized on the lock object.
-   */
-  private void maybeNotifyDecodeLoop() {
-    if (!queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0) {
-      lock.notify();
-    }
-  }
-
-  @Override
-  public void run() {
-    OpusDecoder decoder = null;
-    try {
-      decoder = new OpusDecoder(opusHeader);
-      while (decodeBuffer(decoder)) {
-        // Do nothing.
-      }
-    } catch (OpusDecoderException e) {
-      synchronized (lock) {
-        decoderException = e;
-      }
-    } catch (InterruptedException e) {
-      // Shouldn't ever happen.
-    } finally {
-      if (decoder != null) {
-        decoder.close();
-      }
-    }
-  }
-
-  private boolean decodeBuffer(OpusDecoder decoder) throws InterruptedException,
-      OpusDecoderException {
-    InputBuffer inputBuffer;
-    OutputBuffer outputBuffer;
-
-    // Wait until we have an input buffer to decode, and an output buffer to decode into.
-    synchronized (lock) {
-      while (!released && (queuedInputBuffers.isEmpty() || availableOutputBufferCount == 0)) {
-        lock.wait();
-      }
-      if (released) {
-        return false;
-      }
-      inputBuffer = queuedInputBuffers.removeFirst();
-      outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
-      flushDecodedOutputBuffer = false;
-    }
-
-    // Decode.
-    boolean skipBuffer = false;
-    if (inputBuffer.getFlag(FLAG_END_OF_STREAM)) {
-      outputBuffer.setFlag(FLAG_END_OF_STREAM);
-    } else {
-      if (inputBuffer.getFlag(FLAG_RESET_DECODER)) {
-        decoder.reset();
-        // When seeking to 0, skip number of samples as specified in opus header. When seeking to
-        // any other time, skip number of samples as specified by seek preroll.
-        skipSamples = (inputBuffer.sampleHolder.timeUs == 0) ? opusHeader.skipSamples : seekPreRoll;
-      }
-      SampleHolder sampleHolder = inputBuffer.sampleHolder;
-      sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
-      outputBuffer.timestampUs = sampleHolder.timeUs;
-      outputBuffer.size = decoder.decode(sampleHolder.data, sampleHolder.size,
-          outputBuffer.data, outputBuffer.data.capacity());
-      outputBuffer.data.position(0);
-      if (skipSamples > 0) {
-        int bytesPerSample = opusHeader.channelCount * 2;
-        int skipBytes = skipSamples * bytesPerSample;
-        if (outputBuffer.size <= skipBytes) {
-          skipSamples -= outputBuffer.size / bytesPerSample;
-          outputBuffer.size = 0;
-          skipBuffer = true;
-        } else {
-          skipSamples = 0;
-          outputBuffer.size -= skipBytes;
-          outputBuffer.data.position(skipBytes);
-        }
-      }
-    }
-
-    synchronized (lock) {
-      if (flushDecodedOutputBuffer
-          || inputBuffer.sampleHolder.isDecodeOnly()
-          || skipBuffer) {
-        // In the following cases, we make the output buffer available again rather than queuing it
-        // to be consumed:
-        // 1) A flush occured whilst we were decoding.
-        // 2) The input sample has decodeOnly flag set.
-        // 3) We skip the entire buffer due to skipSamples being greater than bytes decoded.
-        outputBuffer.reset();
-        availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
-      } else {
-        // Queue the decoded output buffer to be consumed.
-        queuedOutputBuffers.addLast(outputBuffer);
-      }
-      // Make the input buffer available again.
-      availableInputBuffers[availableInputBufferCount++] = inputBuffer;
-    }
-
-    return true;
-  }
-
-  private static OpusHeader parseOpusHeader(byte[] headerBytes) throws OpusDecoderException {
-    final int maxChannelCount = 8;
-    final int maxChannelCountWithDefaultLayout = 2;
-    final int headerSize = 19;
-    final int headerChannelCountOffset = 9;
-    final int headerSkipSamplesOffset = 10;
-    final int headerGainOffset = 16;
-    final int headerChannelMappingOffset = 18;
-    final int headerNumStreamsOffset = headerSize;
-    final int headerNumCoupledOffset = headerNumStreamsOffset + 1;
-    final int headerStreamMapOffset = headerNumStreamsOffset + 2;
-    OpusHeader opusHeader = new OpusHeader();
-    try {
-      // Opus streams are always decoded at 48000 hz.
-      opusHeader.sampleRate = 48000;
-      opusHeader.channelCount = headerBytes[headerChannelCountOffset];
-      if (opusHeader.channelCount > maxChannelCount) {
-        throw new OpusDecoderException("Invalid channel count: " + opusHeader.channelCount);
-      }
-      opusHeader.skipSamples = readLittleEndian16(headerBytes, headerSkipSamplesOffset);
-      opusHeader.gain = readLittleEndian16(headerBytes, headerGainOffset);
-      opusHeader.channelMapping = headerBytes[headerChannelMappingOffset];
-
-      if (opusHeader.channelMapping == 0) {
-        // If there is no channel mapping, use the defaults.
-        if (opusHeader.channelCount > maxChannelCountWithDefaultLayout) {
-          throw new OpusDecoderException("Invalid Header, missing stream map.");
-        }
-        opusHeader.numStreams = 1;
-        opusHeader.numCoupled = (opusHeader.channelCount > 1) ? 1 : 0;
-        opusHeader.streamMap[0] = 0;
-        opusHeader.streamMap[1] = 1;
-      } else {
-        // Read the channel mapping.
-        opusHeader.numStreams = headerBytes[headerNumStreamsOffset];
-        opusHeader.numCoupled = headerBytes[headerNumCoupledOffset];
-        for (int i = 0; i < opusHeader.channelCount; i++) {
-          opusHeader.streamMap[i] = headerBytes[headerStreamMapOffset + i];
-        }
-      }
-      return opusHeader;
-    } catch (ArrayIndexOutOfBoundsException e) {
-      throw new OpusDecoderException("Header size is too small.");
-    }
-  }
-
-  private static int readLittleEndian16(byte[] input, int offset) {
-    int value = input[offset];
-    value |= input[offset + 1] << 8;
-    return value;
-  }
-
-  private static int nsToSamples(OpusHeader opusHeader, long ns) {
-    return (int) (ns * opusHeader.sampleRate / 1000000000);
-  }
-
-  /* package */ static final class InputBuffer {
-
-    public final SampleHolder sampleHolder;
-
-    public int flags;
-
-    public InputBuffer() {
-      sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
-      sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
-    }
-
-    public void reset() {
-      sampleHolder.clearData();
-      flags = 0;
-    }
-
-    public void setFlag(int flag) {
-      flags |= flag;
-    }
-
-    public boolean getFlag(int flag) {
-      return (flags & flag) == flag;
-    }
-
-  }
-
-  /* package */ static final class OutputBuffer {
-
-    public ByteBuffer data;
-    public int size;
-    public long timestampUs;
-    public int flags;
-
-    public OutputBuffer() {
-      data = ByteBuffer.allocateDirect(OUTPUT_BUFFER_SIZE);
-    }
-
-    public void reset() {
-      data.clear();
-      size = 0;
-      flags = 0;
-    }
-
-    public void setFlag(int flag) {
-      flags |= flag;
-    }
-
-    public boolean getFlag(int flag) {
-      return (flags & flag) == flag;
-    }
-
-  }
-
-  /* package */ static final class OpusHeader {
-
-    public int sampleRate;
-    public int channelCount;
-    public int skipSamples;
-    public int gain;
-    public int channelMapping;
-    public int numStreams;
-    public int numCoupled;
-    public byte[] streamMap;
-
-    public OpusHeader() {
-      streamMap = new byte[8];
-    }
-
-  }
-
-}
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
new file mode 100644
index 0000000000..dcbd6fc820
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.OutputBuffer;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Buffer for {@link OpusDecoder} output.
+ */
+public final class OpusOutputBuffer extends OutputBuffer {
+
+  private final DecoderWrapper<?, OpusOutputBuffer, ?> owner;
+
+  public ByteBuffer data;
+  public int size;
+
+  /* package */ OpusOutputBuffer(DecoderWrapper<?, OpusOutputBuffer, ?> owner) {
+    this.owner = owner;
+  }
+
+  /* package */ void init(int size) {
+    if (data == null || data.capacity() < size) {
+      data = ByteBuffer.allocateDirect(size);
+    }
+    data.position(0);
+    data.limit(size);
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    if (data != null) {
+      data.clear();
+    }
+  }
+
+  @Override
+  public void release() {
+    owner.releaseOutputBuffer(this);
+  }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index 2a1b29ef47..eae8de84e4 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -23,8 +23,9 @@
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.SampleSourceTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.VpxInputBuffer;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -105,6 +106,14 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
    */
   public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = 2;
 
+  /**
+   * The number of input buffers and the number of output buffers. The track renderer may limit the
+   * minimum possible value due to requiring multiple output buffers to be dequeued at a time for it
+   * to make progress.
+   */
+  private static final int NUM_BUFFERS = 16;
+  private static final int INITIAL_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
+
   public final CodecCounters codecCounters = new CodecCounters();
 
   private final boolean scaleToFit;
@@ -114,7 +123,8 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
   private final MediaFormatHolder formatHolder;
 
   private MediaFormat format;
-  private VpxDecoderWrapper decoder;
+  private VpxDecoder decoder;
+  private DecoderWrapper<VpxInputBuffer, VpxOutputBuffer, VpxDecoderException> decoderWrapper;
   private VpxInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
 
@@ -170,7 +180,7 @@ public LibvpxVideoTrackRenderer(SampleSource source, boolean scaleToFit,
    * Returns whether the underlying libvpx library is available.
    */
   public static boolean isLibvpxAvailable() {
-    return VpxDecoder.isLibvpxAvailable();
+    return VpxDecoder.IS_AVAILABLE;
   }
 
   /**
@@ -199,17 +209,18 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
       return;
     }
 
-    // If we don't have a decoder yet, we need to instantiate one.
-    if (decoder == null) {
-      long startElapsedRealtimeMs = SystemClock.elapsedRealtime();
-      decoder = new VpxDecoderWrapper(outputMode);
-      decoder.start();
-      notifyDecoderInitialized(startElapsedRealtimeMs, SystemClock.elapsedRealtime());
-      codecCounters.codecInitCount++;
-    }
-
-    // Rendering loop.
     try {
+      if (decoder == null) {
+        // If we don't have a decoder yet, we need to instantiate one.
+        long startElapsedRealtimeMs = SystemClock.elapsedRealtime();
+        decoder = new VpxDecoder();
+        decoder.setOutputMode(outputMode);
+        decoderWrapper = new DecoderWrapper<>(decoder, new VpxInputBuffer[NUM_BUFFERS],
+            new VpxOutputBuffer[NUM_BUFFERS], INITIAL_INPUT_BUFFER_SIZE);
+        decoderWrapper.start();
+        notifyDecoderInitialized(startElapsedRealtimeMs, SystemClock.elapsedRealtime());
+        codecCounters.codecInitCount++;
+      }
       processOutputBuffer(positionUs, elapsedRealtimeUs);
       while (feedInputBuffer(positionUs)) {}
     } catch (VpxDecoderException e) {
@@ -226,15 +237,15 @@ private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     if (outputBuffer == null) {
-      outputBuffer = decoder.dequeueOutputBuffer();
+      outputBuffer = decoderWrapper.dequeueOutputBuffer();
       if (outputBuffer == null) {
         return;
       }
     }
 
-    if (outputBuffer.flags == VpxDecoderWrapper.FLAG_END_OF_STREAM) {
+    if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputStreamEnded = true;
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
       return;
     }
@@ -249,7 +260,7 @@ private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
       if (droppedFrameCount == maxDroppedFrameCountToNotify) {
         notifyAndResetDroppedFrameCount();
       }
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
       return;
     }
@@ -318,7 +329,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoder.dequeueInputBuffer();
+      inputBuffer = decoderWrapper.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -333,8 +344,8 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
       return true;
     }
     if (result == SampleSource.END_OF_STREAM) {
-      inputBuffer.flags = VpxDecoderWrapper.FLAG_END_OF_STREAM;
-      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      decoderWrapper.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
       return false;
@@ -342,7 +353,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
 
     inputBuffer.width = format.width;
     inputBuffer.height = format.height;
-    decoder.queueInputBuffer(inputBuffer);
+    decoderWrapper.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
   }
@@ -350,10 +361,10 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
   private void flushDecoder() {
     inputBuffer = null;
     if (outputBuffer != null) {
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
     }
-    decoder.flush();
+    decoderWrapper.flush();
   }
 
   @Override
@@ -372,7 +383,7 @@ protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     outputStreamEnded = false;
     renderedFirstFrame = false;
-    if (decoder != null) {
+    if (decoderWrapper != null) {
       flushDecoder();
     }
   }
@@ -394,9 +405,9 @@ protected void onDisabled() throws ExoPlaybackException {
     outputBuffer = null;
     format = null;
     try {
-      if (decoder != null) {
-        decoder.release();
-        decoder = null;
+      if (decoderWrapper != null) {
+        decoderWrapper.release();
+        decoderWrapper = null;
         codecCounters.codecReleaseCount++;
       }
     } finally {
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 3e54003633..eeb02212a2 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -15,14 +15,27 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.Decoder;
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+
 import java.nio.ByteBuffer;
 
 /**
- * JNI Wrapper for the libvpx VP9 decoder.
+ * JNI wrapper for the libvpx VP9 decoder.
  */
-/* package */ class VpxDecoder {
+/* package */ final class VpxDecoder implements Decoder<VpxInputBuffer, VpxOutputBuffer,
+    VpxDecoderException> {
+
+  public static final int OUTPUT_MODE_UNKNOWN = -1;
+  public static final int OUTPUT_MODE_YUV = 0;
+  public static final int OUTPUT_MODE_RGB = 1;
 
-  private static final boolean IS_AVAILABLE;
+  /**
+   * Whether the underlying libvpx library is available.
+   */
+  public static final boolean IS_AVAILABLE;
   static {
     boolean isAvailable;
     try {
@@ -35,16 +48,20 @@
     IS_AVAILABLE = isAvailable;
   }
 
-  public static final int OUTPUT_MODE_UNKNOWN = -1;
-  public static final int OUTPUT_MODE_YUV = 0;
-  public static final int OUTPUT_MODE_RGB = 1;
+  /**
+   * Returns the version string of the underlying libvpx decoder.
+   */
+  public static native String getLibvpxVersion();
 
   private final long vpxDecContext;
 
+  private volatile int outputMode;
+  private VpxDecoderException exception;
+
   /**
    * Creates the VP9 Decoder.
    *
-   * @throws VpxDecoderException if the decoder fails to initialize.
+   * @throws VpxDecoderException Thrown if the decoder fails to initialize.
    */
   public VpxDecoder() throws VpxDecoderException {
     vpxDecContext = vpxInit();
@@ -54,40 +71,58 @@ public VpxDecoder() throws VpxDecoderException {
   }
 
   /**
-   * Decodes a vp9 encoded frame and converts it to RGB565.
+   * Sets the output mode for frames rendered by the decoder.
    *
-   * @param encoded The encoded buffer.
-   * @param size Size of the encoded buffer.
-   * @param outputBuffer The buffer into which the decoded frame should be written.
-   * @return 0 on success with a frame to render. 1 on success without a frame to render.
-   * @throws VpxDecoderException on decode failure.
+   * @param outputMode The output mode to use, which must be one of the {@code OUTPUT_MODE_*}
+   *     constants in {@link VpxDecoder}.
    */
-  public int decode(ByteBuffer encoded, int size, VpxOutputBuffer outputBuffer)
-      throws VpxDecoderException {
-    if (vpxDecode(vpxDecContext, encoded, size) != 0) {
-      throw new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
-    }
-    return vpxGetFrame(vpxDecContext, outputBuffer);
+  public void setOutputMode(int outputMode) {
+    this.outputMode = outputMode;
   }
 
-  /**
-   * Destroys the decoder.
-   */
-  public void close() {
-    vpxClose(vpxDecContext);
+  @Override
+  public VpxInputBuffer createInputBuffer(int initialSize) {
+    return new VpxInputBuffer(initialSize);
   }
 
-  /**
-   * Returns whether the underlying libvpx library is available.
-   */
-  public static boolean isLibvpxAvailable() {
-    return IS_AVAILABLE;
+  @Override
+  public VpxOutputBuffer createOutputBuffer(
+      DecoderWrapper<VpxInputBuffer, VpxOutputBuffer, VpxDecoderException> owner) {
+    return new VpxOutputBuffer(owner);
   }
 
-  /**
-   * Returns the version string of the underlying libvpx decoder.
-   */
-  public static native String getLibvpxVersion();
+  @Override
+  public boolean decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer) {
+    outputBuffer.reset();
+    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      return true;
+    }
+    SampleHolder sampleHolder = inputBuffer.sampleHolder;
+    outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+    if (vpxDecode(vpxDecContext, sampleHolder.data, sampleHolder.size) != 0) {
+      exception = new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
+      return false;
+    }
+    outputBuffer.mode = outputMode;
+    if (vpxGetFrame(vpxDecContext, outputBuffer) != 0) {
+      outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
+    return true;
+  }
+
+  @Override
+  public void maybeThrowException() throws VpxDecoderException {
+    if (exception != null) {
+      throw exception;
+    }
+  }
+
+  @Override
+  public void release() {
+    vpxClose(vpxDecContext);
+  }
 
   private native long vpxInit();
   private native long vpxClose(long context);
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
index 1afa01a6c7..6d08f1b0d1 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
@@ -20,7 +20,7 @@
  */
 public class VpxDecoderException extends Exception {
 
-    public VpxDecoderException(String message) {
+    /* package */ VpxDecoderException(String message) {
       super(message);
     }
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
new file mode 100644
index 0000000000..e8f04940ea
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+
+/**
+ * Input buffer to a {@link VpxDecoder}.
+ */
+/* package */ final class VpxInputBuffer extends InputBuffer {
+
+  public int width;
+  public int height;
+
+  public VpxInputBuffer(int initialSize) {
+    super(initialSize);
+  }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
index 1a2b40a069..21774db701 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
@@ -15,44 +15,43 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.OutputBuffer;
+
 import java.nio.ByteBuffer;
 
 /**
- * OutputBuffer for storing the video frame.
+ * Output buffer containing video frame data, populated by {@link VpxDecoder}.
  */
-public final class VpxOutputBuffer {
+public final class VpxOutputBuffer extends OutputBuffer {
 
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
   public static final int COLORSPACE_BT709 = 2;
 
-  private final VpxDecoderWrapper decoder;
-
-  /* package */ VpxOutputBuffer(VpxDecoderWrapper decoder) {
-    this.decoder = decoder;
-  }
+  private final DecoderWrapper<?, VpxOutputBuffer, ?> owner;
 
+  public int mode;
   /**
    * RGB buffer for RGB mode.
    */
   public ByteBuffer data;
-  public long timestampUs;
   public int width;
   public int height;
-  public int flags;
   /**
    * YUV planes for YUV mode.
    */
   public ByteBuffer[] yuvPlanes;
   public int[] yuvStrides;
-  public int mode;
   public int colorspace;
 
-  /**
-   * Releases the buffer back to the decoder, allowing it to be reused.
-   */
+  /* package */ VpxOutputBuffer(DecoderWrapper<?, VpxOutputBuffer, ?> owner) {
+    this.owner = owner;
+  }
+
+  @Override
   public void release() {
-    decoder.releaseOutputBuffer(this);
+    owner.releaseOutputBuffer(this);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
new file mode 100644
index 0000000000..241a02327b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+/**
+ * Base class for {@link Decoder} buffers with flags.
+ */
+public abstract class Buffer {
+
+  /**
+   * Flag for empty input/output buffers that signal that the end of the stream was reached.
+   */
+  public static final int FLAG_END_OF_STREAM = 1;
+  /**
+   * Flag for non-empty input buffers which signals that the decoder must be reset before decoding.
+   */
+  public static final int FLAG_RESET = 2;
+  /**
+   * Flag for non-empty input/output buffers that should only be decoded (not rendered).
+   */
+  public static final int FLAG_DECODE_ONLY = 4;
+
+  private int flags;
+
+  public void reset() {
+    flags = 0;
+  }
+
+  public final void setFlag(int flag) {
+    flags |= flag;
+  }
+
+  public final boolean getFlag(int flag) {
+    return (flags & flag) == flag;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
new file mode 100644
index 0000000000..29a64769b4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+/**
+ * Decoder interface for extensions that use a blocking/synchronous decoder. Implementations can be
+ * wrapped by {@link DecoderWrapper}, which exposes a higher level MediaCodec-like interface.
+ */
+public interface Decoder<I extends InputBuffer, O extends OutputBuffer, E extends Exception> {
+
+  /**
+   * Returns a new decoder input buffer for use by a {@link DecoderWrapper}.
+   *
+   * @return A new decoder input buffer.
+   */
+  I createInputBuffer(int size);
+
+  /**
+   * Returns a new decoder output buffer for use by a {@link DecoderWrapper}.
+   */
+  O createOutputBuffer(DecoderWrapper<I, O, E> owner);
+
+  /**
+   * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
+   *
+   * @param inputBuffer The buffer to decode.
+   * @param outputBuffer The output buffer to store decoded data. If the flag
+   *     {@link Buffer#FLAG_DECODE_ONLY} is set after this method returns, any output should not be
+   *     presented.
+   * @return True if decoding was successful. False if an exception was thrown, in which case
+   *     {@link #maybeThrowException()} will throw the error.
+   */
+  boolean decode(I inputBuffer, O outputBuffer);
+
+  /**
+   * Throws any exception that was previously thrown by the underlying decoder.
+   *
+   * @throws E Thrown if the underlying decoder encountered an error.
+   */
+  void maybeThrowException() throws E;
+
+  /**
+   * Releases the decoder and any associated resources.
+   */
+  void release();
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/DecoderWrapper.java
similarity index 51%
rename from extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
rename to library/src/main/java/com/google/android/exoplayer/util/extensions/DecoderWrapper.java
index 5dff64a846..0418339451 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/DecoderWrapper.java
@@ -13,86 +13,90 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.ext.vp9;
+package com.google.android.exoplayer.util.extensions;
 
-import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.util.Assertions;
 
-import java.nio.ByteBuffer;
 import java.util.LinkedList;
 
 /**
- * Wraps {@link VpxDecoder}, exposing a higher level decoder interface.
+ * Wraps a {@link Decoder}, exposing a higher level decoder interface.
  */
-/* package */ final class VpxDecoderWrapper extends Thread {
+public final class DecoderWrapper<I extends InputBuffer, O extends OutputBuffer,
+    E extends Exception> extends Thread {
 
-  public static final int FLAG_END_OF_STREAM = 1;
-
-  private static final int INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
   /**
-   * The number of input buffers and the number of output buffers. The track renderer may limit the
-   * minimum possible value due to requiring multiple output buffers to be dequeued at a time for it
-   * to make progress.
+   * Listener for {@link DecoderWrapper} events.
    */
-  private static final int NUM_BUFFERS = 16;
+  public interface EventListener<E> {
+
+    /**
+     * Invoked when the decoder encounters an error.
+     *
+     * @param e The corresponding exception.
+     */
+    void onDecoderError(E e);
 
+  }
+
+  private final Decoder<I, O, E> decoder;
   private final Object lock;
 
-  private final LinkedList<VpxInputBuffer> queuedInputBuffers;
-  private final LinkedList<VpxOutputBuffer> queuedOutputBuffers;
-  private final VpxInputBuffer[] availableInputBuffers;
-  private final VpxOutputBuffer[] availableOutputBuffers;
+  private final LinkedList<I> queuedInputBuffers;
+  private final LinkedList<O> queuedOutputBuffers;
+  private final I[] availableInputBuffers;
+  private final O[] availableOutputBuffers;
   private int availableInputBufferCount;
   private int availableOutputBufferCount;
-  private VpxInputBuffer dequeuedInputBuffer;
+  private I dequeuedInputBuffer;
 
   private boolean flushDecodedOutputBuffer;
   private boolean released;
-  private int outputMode;
-
-  private VpxDecoderException decoderException;
 
   /**
-   * @param outputMode One of OUTPUT_MODE_* constants from {@link VpxDecoderWrapper}
-   *     depending on the desired output mode.
+   * Creates a new wrapper around {@code decoder}, using the specified {@code inputBuffers} and
+   * {@code outputBuffers}. The arrays will be populated using buffers created by the decoder.
+   *
+   * @param decoder The decoder to wrap.
+   * @param inputBuffers An array of nulls that will be used to store references to input buffers.
+   * @param outputBuffers An array of nulls that will be used to store references to output buffers.
+   * @param initialInputBufferSize The initial size for each input buffer, in bytes.
    */
-  public VpxDecoderWrapper(int outputMode) {
+  public DecoderWrapper(Decoder<I, O, E> decoder, I[] inputBuffers, O[] outputBuffers,
+      int initialInputBufferSize) {
+    this.decoder = decoder;
     lock = new Object();
-    this.outputMode = outputMode;
     queuedInputBuffers = new LinkedList<>();
     queuedOutputBuffers = new LinkedList<>();
-    availableInputBuffers = new VpxInputBuffer[NUM_BUFFERS];
-    availableOutputBuffers = new VpxOutputBuffer[NUM_BUFFERS];
-    availableInputBufferCount = NUM_BUFFERS;
-    availableOutputBufferCount = NUM_BUFFERS;
-    for (int i = 0; i < NUM_BUFFERS; i++) {
-      availableInputBuffers[i] = new VpxInputBuffer();
-      availableOutputBuffers[i] = new VpxOutputBuffer(this);
+    availableInputBuffers = inputBuffers;
+    availableInputBufferCount = inputBuffers.length;
+    for (int i = 0; i < availableInputBufferCount; i++) {
+      availableInputBuffers[i] = decoder.createInputBuffer(initialInputBufferSize);
+    }
+    availableOutputBuffers = outputBuffers;
+    availableOutputBufferCount = outputBuffers.length;
+    for (int i = 0; i < availableOutputBufferCount; i++) {
+      availableOutputBuffers[i] = decoder.createOutputBuffer(this);
     }
   }
 
-  public void setOutputMode(int outputMode) {
-    this.outputMode = outputMode;
-  }
-
-  public VpxInputBuffer dequeueInputBuffer() throws VpxDecoderException {
+  public I dequeueInputBuffer() throws E {
     synchronized (lock) {
-      maybeThrowDecoderError();
+      decoder.maybeThrowException();
       Assertions.checkState(dequeuedInputBuffer == null);
       if (availableInputBufferCount == 0) {
         return null;
       }
-      VpxInputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
-      inputBuffer.flags = 0;
-      inputBuffer.sampleHolder.clearData();
+      I inputBuffer = availableInputBuffers[--availableInputBufferCount];
+      inputBuffer.reset();
       dequeuedInputBuffer = inputBuffer;
       return inputBuffer;
     }
   }
 
-  public void queueInputBuffer(VpxInputBuffer inputBuffer) throws VpxDecoderException {
+  public void queueInputBuffer(I inputBuffer) throws E {
     synchronized (lock) {
-      maybeThrowDecoderError();
+      decoder.maybeThrowException();
       Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
       queuedInputBuffers.addLast(inputBuffer);
       maybeNotifyDecodeLoop();
@@ -100,9 +104,9 @@ public void queueInputBuffer(VpxInputBuffer inputBuffer) throws VpxDecoderExcept
     }
   }
 
-  public VpxOutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
+  public O dequeueOutputBuffer() throws E {
     synchronized (lock) {
-      maybeThrowDecoderError();
+      decoder.maybeThrowException();
       if (queuedOutputBuffers.isEmpty()) {
         return null;
       }
@@ -110,7 +114,7 @@ public VpxOutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
     }
   }
 
-  public void releaseOutputBuffer(VpxOutputBuffer outputBuffer) {
+  public void releaseOutputBuffer(O outputBuffer) {
     synchronized (lock) {
       availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
       maybeNotifyDecodeLoop();
@@ -150,12 +154,6 @@ public void release() {
     }
   }
 
-  private void maybeThrowDecoderError() throws VpxDecoderException {
-    if (decoderException != null) {
-      throw decoderException;
-    }
-  }
-
   /**
    * Notifies the decode loop if there exists a queued input buffer and an available output buffer
    * to decode into.
@@ -170,29 +168,23 @@ private void maybeNotifyDecodeLoop() {
 
   @Override
   public void run() {
-    VpxDecoder decoder = null;
     try {
-      decoder = new VpxDecoder();
       while (decodeBuffer(decoder)) {
         // Do nothing.
       }
-    } catch (VpxDecoderException e) {
-      synchronized (lock) {
-        decoderException = e;
-      }
     } catch (InterruptedException e) {
-      // Shouldn't ever happen.
+      // Not expected.
+      throw new IllegalStateException(e);
     } finally {
       if (decoder != null) {
-        decoder.close();
+        decoder.release();
       }
     }
   }
 
-  private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
-      VpxDecoderException {
-    VpxInputBuffer inputBuffer;
-    VpxOutputBuffer outputBuffer;
+  private boolean decodeBuffer(Decoder<I, O, E> decoder) throws InterruptedException {
+    I inputBuffer;
+    O outputBuffer;
 
     // Wait until we have an input buffer to decode, and an output buffer to decode into.
     synchronized (lock) {
@@ -207,29 +199,17 @@ private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
       flushDecodedOutputBuffer = false;
     }
 
-    // Decode.
-    int decodeResult = -1;
-    if (inputBuffer.flags == FLAG_END_OF_STREAM) {
-      outputBuffer.flags = FLAG_END_OF_STREAM;
-    } else {
-      SampleHolder sampleHolder = inputBuffer.sampleHolder;
-      outputBuffer.timestampUs = sampleHolder.timeUs;
-      outputBuffer.flags = 0;
-      outputBuffer.mode = outputMode;
-      sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
-      decodeResult = decoder.decode(sampleHolder.data, sampleHolder.size, outputBuffer);
+    if (!decoder.decode(inputBuffer, outputBuffer)) {
+      // Memory barrier to ensure that the decoder exception is visible from the playback thread.
+      synchronized (lock) {}
+      return false;
     }
 
+    boolean decodeOnly = outputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY);
     synchronized (lock) {
-      if (flushDecodedOutputBuffer
-          || inputBuffer.sampleHolder.isDecodeOnly()
-          || decodeResult == 1) {
-        // In the following cases, we make the output buffer available again rather than queuing it
-        // to be consumed:
-        // 1) A flush occured whilst we were decoding.
-        // 2) The input sample has decodeOnly flag set.
-        // 3) The decode succeeded, but we did not get any frame back for rendering (happens in case
-        // of an unpacked altref frame).
+      if (flushDecodedOutputBuffer || decodeOnly) {
+        // If a flush occurred while decoding or the buffer was only for decoding (not presentation)
+        // then make the output buffer available again rather than queueing it to be consumed.
         availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
       } else {
         // Queue the decoded output buffer to be consumed.
@@ -246,19 +226,4 @@ private boolean canDecodeBuffer() {
     return !queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0;
   }
 
-  /* package */ static final class VpxInputBuffer {
-
-    public final SampleHolder sampleHolder;
-
-    public int width;
-    public int height;
-    public int flags;
-
-    public VpxInputBuffer() {
-      sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
-      sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
-    }
-
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
new file mode 100644
index 0000000000..2df85e56e6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+import com.google.android.exoplayer.SampleHolder;
+
+/**
+ * Input buffer to be decoded by a {@link Decoder}.
+ */
+public class InputBuffer extends Buffer {
+
+  public final SampleHolder sampleHolder;
+
+  public InputBuffer(int initialSize) {
+    sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
+    sampleHolder.ensureSpaceForWrite(initialSize);
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    sampleHolder.clearData();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/OutputBuffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/OutputBuffer.java
new file mode 100644
index 0000000000..c5ec800003
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/OutputBuffer.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+/**
+ * Output buffer decoded by a {@link Decoder}.
+ */
+public abstract class OutputBuffer extends Buffer {
+
+  /**
+   * The presentation timestamp for the buffer, in microseconds.
+   */
+  public long timestampUs;
+
+  /**
+   * Releases the output buffer for reuse. Must be called when the buffer is no longer needed.
+   */
+  public abstract void release();
+
+}
