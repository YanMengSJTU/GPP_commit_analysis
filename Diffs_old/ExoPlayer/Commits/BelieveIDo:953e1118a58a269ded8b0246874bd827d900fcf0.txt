diff --git a/README.md b/README.md
index 3a0e309a7f..d9c55904ae 100644
--- a/README.md
+++ b/README.md
@@ -58,7 +58,7 @@ accompanying demo application. To get started:
 ExoPlayer can also be built using Gradle. You can include it as a dependent project and build from source. e.g.
 
 ```
-// setting.gradle
+// settings.gradle
 include ':app', ':..:ExoPlayer:library'
 
 // app/build.gradle
diff --git a/demo/README.md b/demo/README.md
new file mode 100644
index 0000000000..ca37392623
--- /dev/null
+++ b/demo/README.md
@@ -0,0 +1,5 @@
+# Demo application #
+
+This folder contains a demo application that uses ExoPlayer to play a number
+of test streams. It can be used as a starting point or reference project when
+developing other applications that make use of the ExoPlayer library.
diff --git a/demo/assets/ic_launcher.svg b/demo/assets/ic_launcher.svg
new file mode 100644
index 0000000000..5486b27e29
--- /dev/null
+++ b/demo/assets/ic_launcher.svg
@@ -0,0 +1,660 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="192"
+   height="192"
+   id="svg3089"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="exoplayer.svg"
+   enable-background="new">
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="2.0893424"
+     inkscape:cx="79.970323"
+     inkscape:cy="85.448985"
+     inkscape:current-layer="layer2"
+     showgrid="true"
+     inkscape:grid-bbox="true"
+     inkscape:document-units="px"
+     showguides="true"
+     inkscape:guide-bbox="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1176"
+     inkscape:window-x="1920"
+     inkscape:window-y="24"
+     inkscape:window-maximized="1" />
+  <defs
+     id="defs3091">
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4624">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4626" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4628" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4498">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4500" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4502" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4511">
+      <stop
+         id="stop4513"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop4515"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0;" />
+    </linearGradient>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4219">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.5"
+         id="feFlood4221" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4223" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="2"
+         in="composite"
+         id="feGaussianBlur4225" />
+      <feOffset
+         result="offset"
+         dy="4"
+         dx="4"
+         id="feOffset4227" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4229" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4464">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4466" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4468" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4470" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4472" />
+      <feComposite
+         result="fbSourceGraphic"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4474" />
+      <feColorMatrix
+         id="feColorMatrix4476"
+         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
+         in="fbSourceGraphic"
+         result="fbSourceGraphicAlpha" />
+      <feFlood
+         in="fbSourceGraphic"
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4478" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="fbSourceGraphic"
+         id="feComposite4480" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4482" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4484" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="fbSourceGraphic"
+         in2="offset"
+         id="feComposite4486" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4494">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4496" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4498" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4500" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4502" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4504" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4535">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4537" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4539" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4541" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4543" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4545" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4557">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4559" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4561" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4563" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4565" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4567" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4575">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4577" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4579" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4581" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4583" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4585" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       id="filter4575-6"
+       color-interpolation-filters="sRGB">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4577-1" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4579-3" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         id="feGaussianBlur4581-3" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4583-6" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4585-9" />
+    </filter>
+    <filter
+       id="filter3896"
+       inkscape:collect="always">
+      <feBlend
+         id="feBlend3898"
+         in2="BackgroundImage"
+         mode="multiply"
+         inkscape:collect="always" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter3909">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood3911" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite3913" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur3915" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset3917" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite3919" />
+    </filter>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4498"
+       id="linearGradient4504"
+       x1="43.149372"
+       y1="63.20599"
+       x2="110.44475"
+       y2="130.50137"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4498-7"
+       id="linearGradient4504-7"
+       x1="43.149372"
+       y1="63.20599"
+       x2="110.44475"
+       y2="130.50137"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4498-7">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4500-0" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4502-0" />
+    </linearGradient>
+    <linearGradient
+       gradientTransform="translate(-0.12691481,66.675082)"
+       y2="130.50137"
+       x2="110.44475"
+       y1="63.20599"
+       x1="43.149372"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient4521"
+       xlink:href="#linearGradient4498-7"
+       inkscape:collect="always" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4624"
+       id="radialGradient4630"
+       cx="17.483059"
+       cy="18.005892"
+       fx="17.483059"
+       fy="18.005892"
+       r="88.000001"
+       gradientTransform="matrix(-0.00420028,0.99999118,-1.888314,-0.00793148,51.557271,20.787508)"
+       gradientUnits="userSpaceOnUse" />
+    <filter
+       id="filter4680"
+       style="color-interpolation-filters:sRGB;"
+       inkscape:label="Drop Shadow"
+       width="1.4100000000000001"
+       height="1.4700000000000002"
+       x="-0.23000000000000009"
+       y="-0.23000000000000009">
+      <feFlood
+         id="feFlood4682"
+         flood-opacity="0.2"
+         flood-color="rgb(0,0,0)"
+         result="flood" />
+      <feComposite
+         id="feComposite4684"
+         in2="SourceGraphic"
+         in="flood"
+         operator="in"
+         result="composite1" />
+      <feGaussianBlur
+         id="feGaussianBlur4686"
+         in="composite"
+         stdDeviation="6"
+         result="blur" />
+      <feOffset
+         id="feOffset4688"
+         dx="0"
+         dy="6"
+         result="offset" />
+      <feComposite
+         id="feComposite4690"
+         in2="offset"
+         in="SourceGraphic"
+         operator="over"
+         result="composite2" />
+    </filter>
+    <filter
+       id="filter4692"
+       style="color-interpolation-filters:sRGB;"
+       inkscape:label="Drop Shadow"
+       width="1.3600000000000001"
+       x="-0.2400000000000001"
+       y="-0.070000000000000034"
+       height="1.3600000000000001">
+      <feFlood
+         id="feFlood4694"
+         flood-opacity="0.2"
+         flood-color="rgb(0,0,0)"
+         result="flood" />
+      <feComposite
+         id="feComposite4696"
+         in2="SourceGraphic"
+         in="flood"
+         operator="in"
+         result="composite1" />
+      <feGaussianBlur
+         id="feGaussianBlur4698"
+         in="composite"
+         stdDeviation="6"
+         result="blur" />
+      <feOffset
+         id="feOffset4700"
+         dx="0"
+         dy="6"
+         result="offset" />
+      <feComposite
+         id="feComposite4702"
+         in2="offset"
+         in="SourceGraphic"
+         operator="over"
+         result="composite2" />
+    </filter>
+    <filter
+       id="filter4710"
+       style="color-interpolation-filters:sRGB;"
+       inkscape:label="Drop Shadow">
+      <feFlood
+         id="feFlood4712"
+         flood-opacity="0.2"
+         flood-color="rgb(0,0,0)"
+         result="flood" />
+      <feComposite
+         id="feComposite4714"
+         in2="SourceGraphic"
+         in="flood"
+         operator="in"
+         result="composite1" />
+      <feGaussianBlur
+         id="feGaussianBlur4716"
+         in="composite"
+         stdDeviation="6"
+         result="blur" />
+      <feOffset
+         id="feOffset4718"
+         dx="0"
+         dy="6"
+         result="offset" />
+      <feComposite
+         id="feComposite4720"
+         in2="offset"
+         in="SourceGraphic"
+         operator="over"
+         result="composite2" />
+    </filter>
+  </defs>
+  <metadata
+     id="metadata3094">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     style="display:none"
+     sodipodi:insensitive="true"
+     transform="translate(0,176)"
+     inkscape:groupmode="layer"
+     inkscape:label="Layer 1"
+     id="layer1">
+    <image
+       width="192"
+       height="192"
+       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAABHNCSVQICAgIfAhkiAAAIABJREFU eJztnVlXE1vax/9JZSBAAgljoAHbNBIwKHAOCsJSUZperr7qj3A+Tn+K8w2OV2fRx0YBFwioDEqE AA3vQRYUCCRQCZmH94KVLEBIatg1xfrdKVV771Sef2oPz6D797//nenr60MqlcKPTjgcBgCUlpZq /RU5er0e8/Pz0E1OTmZqamrQ3t4u95hk5+zsDABQVlam9VfkrKysIJFIQJ9KpdDe3g6v1yv3mGQn nU4jnU5r/RU5Xq8XHR0dSCaT0Gf/0+PxaCLQKHq8Xi88Hk/u3/qLf9REoFHMXDV+4IoAAE0EGsXJ dcYPXCMAQBOBRnFxk/EDNwgA+DFFYDabYTabtf6KiHzGDwCGfDdnRZCvATEJBAJYXl5GMBiEXq+H Xn+jXonAZ588O65EIgG/34/j42Po9XqUl5ejtLQUNptNUH8MwyAcDiMUCiGdTqOqqgoOhwNGo5Hz ro5U5wDZcVmtVnR2dsJut4va302wsd28AgDkEUEwGMTY2Bjq6+vR29sLi8UiSb9s98kjkQj29vbA MAxMJhNSqRQsFgt6e3tRWVkJiqKI9pcllUrh5OQEfr8fkUgEFEUhHo/DZrOhoaGh4HOS+hwgEolg aWkJ+/v7GB4ehtVqlaRfgJ3xAywEAEgrgqWlJdA0jX/961+i93WVm35NT05OsL29jVQqBZ1Oh8rK SrS0tMBgYPX4OPd3ExRFoaqqClVVVZf+P5lMYmdnBycnJ8hkMqAoCi0tLaisrBTUn1AsFgv6+/sB AKOjo3A6nejq6hK9Xy62qnvz5k1maGiIeMN8ePv2LRwOh2xTrmAwCIqiUFpaio2NDTAMAwCor69H Y2OjKP0BEOWXcXd3F/v7+wAAm82G1tZWhMNhpFIpSX+JL+L1euH3+/H48WNR+2BrP/Pz8+zeAFnE fBMsLS3JavwAsLGxgUgkApvNhjt37qh6wdjY2JgTbSwWw/LyMhiGgcViQU9PjyxjytrP0tKSKG8C PrbJ+R0uhgiCwSBomsaLFy+ItcmWr1+/4uDgACaTCc3NzSgrK5NszSEVZrMZnZ2diEQiODs7w6dP nxCPx1FXV4fm5mZJx+LxeDA6OgqXy0X0TcTXJnltq5DeIh0bG5PU+JPJJBYXFzE3N4eKigr09vbi /v37MJvNSCaTko1DapLJJMxmM+7fv4/e3l5UVFRgbm4Oi4uLkn7uFy9eYGxsjFh7Qn6Qea/iSL0J AoEA6uvrBbXBpS+fzwebzYbu7m5J+lQyFRUVePjwIQDgy5cvYBgGbrdbkm3L+vp6BAIBwX0JtUFB G+sk3gTLy8ui7wzQNI3Z2VkEAgH09/fj7t27ovanRu7evYv+/n4EAgHMzs6CpmlR++vq6sLy8rKg Nkj8AAs+WRIqgmAwKNqcm6ZpTE9PAwD6+vpw+/ZtUfopJm7fvo2+vj4AwPT0tGhCsFgsuV0wPpBa hxI5WhUiAjFOdwOBAN6+fQsAGBgYgNPpJN5HseN0OjEwMADgfHs6EAgQ74Pvd09yE4aY9fEVgdDD pIuk02nMz88jGAzi8ePHnA2/2H1z+PTndDrx+PFjBINBzM/PEz1M4/Pdk96B5HQQxoZ8A7zq22Mw GLC/v4/a2lre/WUyGRiNRqyuruLOnTugKIr3jkaxx+gK7c9gMCCVSmF9fR3t7e1IJBLQ6XS82spk Mjg9PUV5eTn0ej0r3yHSxj8/Pw+8efMmQ5rl5eVL/2YYJvPbb79l3r17lwmHw5f+9p///EdQX0dH R5mJiYlMNBoV1E4mk8mEQqFMKBQS3E6x9xeNRjMTExOZo6MjQe3Mzs5mYrFY7t/hcDjz7t27zG+/ /ZZhGObStVdtigQfP37MkJt/XODiFqmYvj2zs7OoqanBkydPiLQnta+MWvszm8148uQJNjc3sbGx kVs0cyWTyVwa002+Q2K64IjmX+zxePDrr7/CZDIRP+QKBAIYHx/HgwcP4HK5iLatwR6Xy4UHDx5g fHyc+CL5xYsXMJlM+PXXX0V1jxFNAEtLS7lDFpIsLi6CpmkMDQ2JHh+gURi9Xo+hoSHQNI3FxUXi 7T98+BBLS0vE280iigVlfXs6OjrQ0dFBxG0ilUrh9evXcLvd6OjoIDBKDZJ0dHTA7Xbj9evXRJKs ZVOXdHR0gKZpQWcG+RBFAFd9e4Qelh0fH2NqagrPnz8vOke1YsJiseD58+eYmZnB0dER73auzvlJ +w5dhLgAbvLt4SsCn8+Hw8NDYgtdDfEZHBzE0dERfD4f53tvWvBmfYdIQ1wA+Xx7uIpgamoKNTU1 cLvdpIanIRFutxs1NTWYmppifU++3R4SvkPXQVwAhXx72IpgbGwMDx8+/C78T0M9VFVV4eHDh6ym L4W2OoX6Dt0EcQGw2ZnJJ4JkMolXr15heHgYRqOR9PA0JMZoNGJ4eBivXr269oSeoijW+/xi7PoR b5Gtf4fH48H29val62OxGD58+ICRkRHSw2KFGnxz1NTfRUZGRvDhwwfEYrHc/5lMJvh8Ptb7/CT9 xrII8gUS6ttjMBjw7t079PX14fT0FAaDAWVlZbJlMFabb47S+7uKXq/H2dkZkskkKioq8PHjR3R3 d7PyJ8rw8B0qBOeg+Cz58vb88ccf+Mc//sG6rXQ6jdraWtjtdvz88898hkOMYs/Xr5T6AB8/fgRF URgeHsb9+/dhMplY3Tc3N4fu7u7c9STyDnEWAGnfntPTU9jtdpSXlxNpTwhq9c1Ran83UV5eDoZh cHp6ymlMbH2HuMBpDfD27VsYDAZivj2xWAwGgwE///wz3G73D5eL9EfE6/XC7XbjwYMHSCaTiMfj RNp98eIFDAZDLhCKLawFQDpvTzKZxMLCwqXX8Y+YkPdH4upuT3V1Nd6/f08sI4XH44HD4eDkO8RK AFnfHpJeeW/evEF/f/93r0BNBMXJdVudqVQKQ0NDePPmDbF+PB4PJ98hVgIgnbdnbGws71anJoLi It8+fyKRwMjICFFfHy6+QwUFQDpvz9TUFCu/Hk0ExQHbQ64nT55wcpsoBFvfoYICIJm3x+fzob29 nfUJryYCdcMlkstoNKK9vZ2XA911sPUdKigAUnl7jo+PAYCzb48mAnXCJ4wxaxtZWxECW9+hggIg 4X+RSqVy21980ESgLoTE8Ga3w0kE1bCxXUkEMDExIdifXxOBOiARwP7kyRNMTEwIHgsbFwvRg2oX Fxfx6NEjIm1pIlA2JLM3PHr0SHCMcUVFBaLRaN5rRBVAIBCA2WwmGsaoiUCZkE5dYrFYYDabBUWB yf4GWFpaEiWAXROBshArb09HR4eoGSEAEQUwOzsrahyvJgJlIHbduCdPnmB2dla09okLIJPJ4Pj4 GDU1NaLn7dFEIC9SVA7V6/WoqakRlGUib/ukGzQajfB6vZJlbNNEIA9S1o52uVzwer2ihMgSF8Dq 6irvXJF80UQgLVIXTgeA/v5+UdYDRAWQTqdlKy+qiUAa5DB+4Dyeua2tDZlMhmi7RAWwuLgIiqJI NskJTQTiIpfxZykpKSGef5SYAAKBAGpqamQvM6qJQBzkNn7gPIjKZrMRzRBHTADLy8uSF12+CU0E ZFGC8Wfp6OggmiGOiABomkZrayuJpoihZBGk02kEg0GcnZ3h7OwMwWBQMQHrV1GS8QNAPB5Ha2sr seqVRDINbW1t5SoKKglSxbz5sru7mwv8TyQSMBqNSKVSMJlMqKioyF2n0+lA0zTi8Tgoispdm63s 3tjYKMv4lWb8WZxOJ6anp4lU/xQsAJqmFV1/V0oRMAyDb9++Qa/Xw2g0oqGhIe+mQHZHo7y8/Ma0 MKlUCjs7O0gkErkcSjabTZTxX0Spxp/l9u3boGlasAgEC2B7e1vyfX+uiCmCZDKJzc1N6PV61NXV 4W9/+xvR9imKQlNTU+7fDMNgY2MD6XQaLpdLlHSBSjd+4PwtMDs7K68AAoGAoBKnUkJaBMFgELu7 u7BYLGhrayPSJhtsNlvuDbC9vY1IJILGxkZeWdGuQw3Gn6W2thaBQIB3akRA4CLY5/MpevpzFRIL 41AohNXVVSQSCbjdbrS0tBAaHXdaWlrgdruRSCSwurqKUCgkqD01GT9wPg0SGkPMWwDZPVm1IUQE Xq8XoVAI7e3tcDgchEfGH4fDgfb2doRCIUGfTU3Gn8Vmswk6e+ItgOXlZdy9e5d3x3LCVQQHBwdY W1uDx+MhmiKGNPX19fB4PFhbW8PBwQHr+9Rq/ABw9+5dQecCvAVAKqejXLAVwefPnyWf5wulra0N FosFnz9/Lnitmo0/ixBb5CWAr1+/FkXdrnwiiEajWFhYwL1791Q51bPZbLh37x4WFhZujIstBuMH zjNJfP36lde9vARwcHBw6SBHzVwVgU6ng9/vx+7uLnp6emQcGRl6enqwu7sLv99/KUa2WIwfOA9+ 5zLluwgvAbAtaKAWsiIwGAzY29tDLBaTLKBHClwuF2KxGPb29mAwGIrK+LPwtUlDOBzG2dnZtb4o ZrMZV/++sbGB5ubma7NuXXd9PrheLyYulwszMzNoamqC1WoVrTL5RbIVW6TAarUiFAphZmYG/f39 kny+QoTDYYRCISQSCcHXNzU1YWFh4ZJPWqH2w+EwtzcARVGIRCKyl9ghjU6nw87ODpqamkDTtKwx DWJBURRomkZTUxN2dnZYpQxREyUlJYhEIpy/O0NpaWleg776d5vNljfPT6H2hF4vBn6/H1arFVar FX/5y1+wubkp6RSB1CluPrxeL3p7e5FKpRAMBhGPx2U/yygtLUV5eTlKSkqIXG+z2S4VACx0fWlp Kbc3wMbGBu7cucPlFsUTjUYRCATgdDqRyWSQTCYV7UrNh+ycP5lMIpPJwOl0IhAIFMyapjbu3LmD jY0NTvdwEgDDMLLVmRWLlZWVaxe8xSKCmxa8LpcLKysrMoxIPMxmMxiG4XSP6LlBlcznz5/zbnWq XQSFdnt6enpYHZYVM6wFcHJyomg3AK4cHBzg1q1bBa9TqwjYbnXeunWL9x66Eqmvr8fJyQnr61kL YHt7W7bIJDE4OTlhfcKrNhFw2ee32WycDEbpNDY2Ynt7m/X1rAVAomCBUvB6vZx9e9QiAj6HXG1t bar4bGzhYqusBVAs+8ahUAjV1dW87lW6CISc8FZXVwuOJ1AKXGyVlQAikQgqKyt5D0hJ7OzsCFrL KFUEQt0b6uvrsbOzQ3BE8lFZWYlwOMzqWlYC2NvbuxSXqlaCwSDq6uoEt6M0EZDy7amrq1OEi4RQ mpqasLu7y+paVgJgGEaU4Gup2d3dJXb6qRQRkHRsczgcrA1HyRgMBjAMQ6ZCjF6vLwrvz2QySbRU EyC/CMTw6rRYLLKntySB2WwmVyWyGHaANjc3RQlgl0sEYrk0t7S0YHNzk3i7UpNKpcgIIJFIEP/l lAMxq9VILQKx/fnFruwjBSUlJaxCJQt+Ur/fL7vXoFAYhiGy+M2HVCKQIpilrq6Os0+N0nA4HPD7 /QWvKyiA4+Nj1W+Bfvv2TZK4XrFFIFUkl81mw7dv30TvR0wcDgerNOqs1gBqDxCR8pUulgikDmNU +zQoG7xViIKf8qakrWpCjOJq+SAtAjlieKV+ZmLAJtCmoAAuRtiokd3dXTQ0NEjeLykRyBXA3tDQ oPozATa2W1AAasyJc5FYLCbbFE6oCOTM3kBRFGKxmCx9k4KN7ap7oscCuU+w+YpACalL5H52QiEy BVI7bFNuiAlXESjB+AFlPDshsFnHFL0AlLKYYysCpRg/oJxnJyZFLwAluXEUEoGSjB9Q1rMTi6IW QDqdVpwj300iUJrxA+fpBuXO2Cc2RS2As7MzRSbxvZiLVMm5OisqKiRN3ygHeXODZk/TxMr1KXZu 0OyXl63GyPZ6KXC5XFhYWABwnp5EiblIxX4eJHOD8rm+YG5Qg8HA2ng0NNQI59yghVBablCdTsfZ nUOqXJ3ZpFxKzUWq0+mQyWREex6kc4NyvZ5zblC1UVZWhtPTU7mH8R0Xc3UqORfp6emp7ImLxaao BaDX6xVXy+ymBa8SRRCPx1XvFVqI4v50gKJcuQvt9ihNBEp6dmJR9AJQynE+261OJYlAKc9OTIpe AEo4zue6z68UESjh2QmBjYCLXgByp/jge8ilBBHI/eyEwqYASEEBqD042mw2y+bTIvSEV04RpFIp 1RdDYWO7BQXANseiUmlsbMTe3p7k/ZJyb5BLBHt7e6pPh8/GdgsKoBgyBku9mCPt2yOHCIphAUxk CpROp1XvFiulR6NYjm1Si0DtXqBsE7oVFEBVVZXqK4jU1tZKspYR26tTKhEwDIPa2lrR+xGTk5MT 2O32gtcVFADbDFtKxmaziV4HSyqXZilEcHBwoPpkCGwzGhYUgNFoZJVgSOmI+UqX2p9fbBGoffoD nM//2QRDsVoDFMORuMvl4lQ8jS1yBbOIJYLt7e1r6yarDYqiWAmZlQCU5lDGB4PBQPxNJncklxgi iEQiqk+HApzngyIiAOB8Dq32U0Hg/EyA1HpGbuPPQlIEfr9f9Xv/wPkJts1mYxXMxUoADQ0NRVFA zWq1ElkMK8X4s5ASwcHBgSTBQGKzs7PDWsisBGCxWFS/FZqlqakJ+/v7vO9XmvFnESqC/f39oiiE CJxvgbLNacvaGa5YYoPLy8txdHTE616lGn8WISI4OjoqikzgADdbZS2AYtgJyuLxeLC2tsbpHqUb fxY+IlhbW1PFZ2MLF1tlLYCWlhbVp8u+SGVlJevTYbUYfxYuImAYRvUVgC6yu7vLqRgiawFUVlYK mjsrjbq6Ovz5558Fr1Ob8WdhK4I///xT9PppUrK/v89J0EUfEJOPe/fu5ZJTXYdajT9LIREsLCzg 3r17Eo5IeXASgM1mU33RhKt0dHRcWxdX7caf5SYRbG5uoqOjQ4YRiUcsFuPsw8RJAK2trVhfX+fU gdIpKSmB3W4HTdPQ6XSKztXJl4u5SHU6HWiaht1uZ51gSi2sr6+jtbWV0z15c4Nezd1JURQYhkE4 HL42RkBpuUHZYjKZcHR0hFAoBJqm0dvbq8hcnUJwuVz48OEDnE5nLtubFJ8xHyRzfV5nm4Jzg14l lUrBYrGwirRRE5lMBk1NTdjZ2YHT6VR9ANB1pFIpOJ1O7OzsoKmpqWjOdbJEo1FYLBbO3x3n3KA9 PT349OkT7t+/z+r6QoidG5QtXq8X/f392NnZQTAYhNPplKxvKdwPaJpGJpNBf3+/5LlIb4Jkrs9P nz7lcq2ybZ93btBi8A69yMVcnQ0NDTCbzdcujNXK5uYmzGYzGhoaFJ2LVAh8bZKXAOrq6hSZdJYP Vxe8mUwGDocDjY2NebdI1cLCwgIaGxvhcDguTXuKSQSnp6e8zzJ4CaC5uRk+n49Xh0oi325PSUkJ enp68PnzZ1XmRmIYBp8/f0ZPT8+NU4BiEYHP50NzczOve3kfhCmt9hZX2G513rt3D5FIhLPvkJys ra0hEomwOuQqBhEIsUXeAujs7MSXL194dywnXPf56+rq0NbWBq/Xq2h3kP39fXi9XrS1tXGaEqhZ BF++fEFnZyfv+3kLwGAwqHJqIOSQy+PxoLy8HKurq4rKlOH3+7G6uory8nJBn02NImAYRlAIpyBf ILfbja2tLSFNSAqJE97y8nK0t7fDaDTC5/OJEmjPlu3tbfh8PhiNRrS3twv251ebCLa2tuB2uwW1 ISj62W63Y21tDbdv3xY0CCkg7d5gtVrhdruRTCaxtrYGvV6Puro60fPpMAyDg4MDpNNpuFwu4gHs WREo4ZygEN++fRNse4KfXktLC2ialvTgiCtifqEGgwFtbW0Azo3zf//7H/R6PYxGIxoaGgQHEqVS Kezt7SGRSCCdTqO2tpazvwtX1CACmqY5+f3fhGABOJ1OTE9PK1YAUn6RNpvt0htgd3cXsVgMBoMB iUQCRqMRqVQKJpPpUhFqnU6H09NTxONxUBSVuzaZTMJsNssSq6t0EWxtbWFgYEBwO0Ten7dv31bk W0DuL/CmzATpdPqSI1wmk4HT6VRcQTqlioCmaWLTbiJP3Ol0YmNjg0RTxFDiF5dFr9fDarWirKwM ZWVlsFqtijP+LEpbGJtMJmxsbBD7sSX21Ds7O/H161dSzQlCycavRpQkgpWVFUH7/lchJgC73Y7D w0PZ0+ppxi8OShBB9uyJTdpzthB973Z3d8vqS68Zv7jILYJoNIru7m6ibRIVgF6vx/r6uixxw5rx S4NcIojFYlhbW4NOpyPaLvGVV3t7O2ZnZ0k3mxfN+KVFDhHMzMygq6uLeLvEBZBIJODxeCQLKNGM Xx6kFEE2gk2Mwn3EBaDT6VBVVYXDw0PRA90145cXKUSQTqdxeHiI6upqUdoXbfO5r68Pk5OTYjWv Gb9CEFsEk5OT6OvrE619UU9furq6sLKyQrxdzfiVhVgiWFlZEWXefxFRBWC32xGLxYiWJtKMX5mQ FkEkEkEsFhO0589mx0j08/fu7m68e/eOSFua8SsbkiJ49+6d4D3/QCBQMOUKqyJ5Qnn69Kng9YBm /OqAhAgmJyfx9OlTwWMhUiOMhAAoioLH4+GdSUIzfnUhRAQ+nw8ej4dIQRYiVSKtViuROXxVVRUA 4Pj4mNN9mvGrEz4iyNpG1laEEIlEWGXcKyiAzs5OLC0tCR4QcB5DvLq6yvpAQzN+dcNFBIlEAqur q4JjfLMsLS2x8hotKAC73U40Fcjg4CCr9YBm/MUBWxFMTk5icHCQWL/7+/usdpBY7QINDw9jdHRU 8KAutvfq1asb/64Zf3GRTwRGoxGvXr3C8PAwsf5GR0dZt8dKAFarFU6nk+g+77NnzzAzM/NdJJRm /MXJdSKgKArj4+N49uwZsX68Xi+cTifrjNuszwG6urrg9/uJicBgMKCnp+dSbKxm/MXNVREcHR3h wYMHxIKovF4v/H4/p9NjTgdhjx8/RjKZJDYdMpvNSCaT+PjxY277S6O4yW6Hv3//HgaDgViO2dHR USSTSTx+/JjTfZyl19XVBZfLhZcvX6K+vh5dXV2wWCy5v3OtPFJRUZErb6PxY5BNZ8inPvHFKXMk EsHS0hL29/cxPDzMq9CI7s2bN5mhoSHONwLnR83Ly8sIBoPQ6/UwGAzw+/24desWKyGYTCb88ccf GB4exsnJCZLJJKqrq2ULqwyHwwDOK4do/ZGHoigcHR3ljH9ychIDAwOso7z29/dhNBqh1+uRTqdh tVrR2dnJ219ofn5eeGrEq6+c33//Hd3d3QVP4SiKgs/nQ3d3N+7fv490Oo14PI73799jaGhIlOCH QoRCIQAQnGNT6+97jEYjxsfHMTAwkJv2JJNJAMBPP/1U8EdPr9fjv//9L/75z38SHRfxFA56vZ7V vM7r9aKzsxN7e3u560tKSvD06VO8fv0aIyMjpIdWkKzopCofWuz9XeTVq1d49uzZpQWvTqfDTz/9 hLW1NVbrPzFyJxFvkY3/Rb7dHoPBgJGREYyNjcnyFtAgSyKRwNjYGEZGRq7d7UmlUqwPy8SIMCQu gEK+Q2y3OoeHhzE3N8fZd0hDORwfH2Nubo7VoVQhEbD17eEKcQHk8x3ius8/ODiIw8PDoqhH9qPh 8/lweHjIyb0hnwjY+vZwhbgAbvId4nvI5Xa7UV1djampKRLD05CAyclJ1NTU8HJsu0kEbH17uCJK RNhV3yGhJ7zV1dXo7+/H69eviYZXapAlEong9evXGBwcFOTSfFUEXHx7uCJKIs+s71A2IJ7ECS9F UXj+/DkWFxdhNpvR0dEhuE0NcqysrCAWi+H58+dE2vN4PDn74eLbwxXRYoK7urowNzdHvN3u7m44 nU6Mj4+LnndIozDpdBrj4+NwOp3E83YCwNzcnKiZIUQTgNfrxS+//IJ4PE7UlRo4X2cMDQ3h/fv3 kmWg0/iezc3N3MEl6fn56Ogo4vE4fvnlF1HzDokigItz/q6uLgwODuLly5eYmZn5bg7P1XfoIn19 faioqMDExIQsCXl/VGKxGCYmJlBRUSE4adVV356ZmRm8fPkSg4ODuV9+MZNvCfIFuo58C16hvkM3 YTQasbS0hLa2NpSUlOSO2LlS7L45QvszGAyIRqNYW1tDV1eX4INKrr49pN3l5+fnyQqAzwB///13 /P3vfycyn89kMlhcXITNZkNHRwfi8Tin+4vdN4dvfyaTCSsrK2AYBt3d3URSlPP17SEpAsHOcBfh OzC2vkNsefToEQKBAKamptDa2sqpllSx++bw6Y+maWxsbKCzs5N4vAYf3x7ShfuIrAGEDEiMnZyL XqrT09OgaZp4H8UOTdOYnp4GcB4IJcYhFN/vnuSaQLAAhKqRVN6h63A6nblasrOzs9ja2hKln2Ji a2srV+BkYGBAtNK3Qn17SIlAkABIvIpI5h26CafTib6+PtjtdszMzODLly+i9qdGvnz5gpmZGdjt dvT19Yle85mEbw8JEfBeA5Cah5HOO1Sor/7+fiSTSSwuLiIej8PtdqOiokKS/pXG6ekpfD4fTCYT Ojs7Ja3wub+/j/7+fsHtCF0T8PrEpLejsr5DL168INZmPgwGQ+7U8uvXr1hfX4fJZEJjYyPKysok GYMcGAwGnJ2dYWtrC/F4HHV1dXj48KHk4yDt2yNEBJwFIEbqkot5h6TODNHc3Izm5mYAwMLCAiKR CGw2G+7cuQOz2SzpWMQiFothfX0dDMPAYrGgp6dHtrFwzdvDFr4i4CQAMQ20q6sLb9++lTU3UGtr KyiKQmlpKTY2NnKZKurr69HY2CjLmPiyu7ubm1rabDZ0dnYiHA7LXsfZ7/dzTl3CFj4iYH0QJpVh Li0tgaZpyaZDFwkGgwDw3a/TyckJtre3kUqloNPpUFlZiaamJsFz5pv640oymcTOzg5OTk6QyWRA URRaWlq+SztCqj8+jI6Owul0il7yCGBvq6wPwqT8VS6Ud0gOKisrLxnlyVLcAAABS0lEQVRTOBzG //3f/4FhGJjNZqRSKZSUlMDhcKCyshJGo1GUcSQSCZycnMDv9yMajYKiKMRiMdhsNjQ2NuKvf/2r KP3yhUTeHj5weRMUfAPIOSW56juk0+lgt9sF+Q3lg6uvjE6ng16vh16vRzweh9/vRyAQQCQSQUlJ CUpLS2Gz2VBSUnKtKPL1l0gkEI1GwTAMwuEwotEoLBYL7HY7HA4HTCYT0uk00uk06+chtu+RTqdD IBBAJpMhkrdHKIVst+AbQO5cndflHYpGo6L1pxbfHCX3J0fKlZtg8ya4UQByG/9NiPmA1eCbo6b+ lEAhEVx7EqxU49fQ4EO+E+PvBKAZv0YxcpMILglAM36NYuY6EeQEoBm/xo/AVRHo9Xo9VlZWNOPX +GHIioCiKBjm5+fx/PlzzM/Pyz0u2VFbjK7S+1MyFEVhamoK/w+AyfN+zOygegAAAABJRU5ErkJg gg== "
+       id="image3116"
+       x="0"
+       y="-176" />
+  </g>
+  <g
+     style="display:inline"
+     inkscape:label="base"
+     id="layer2"
+     inkscape:groupmode="layer">
+    <g
+       id="g4704"
+       style="filter:url(#filter4710)">
+      <path
+         style="fill:#8097a2;fill-opacity:1;stroke:none;display:inline"
+         d="m 68,30.7 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,34.283686 180.39647,30.7 175.9375,30.7 l -107.937501,0 z"
+         id="path3938-4"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#546e7a;fill-opacity:1;stroke:none;display:inline"
+         d="m 68,33.3 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,36.883686 180.39647,33.3 175.9375,33.3 l -107.937501,0 z"
+         id="path3938-5"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#607d8b;fill-opacity:1;stroke:none"
+         d="m 68,32.000003 0,52 -60,0 L 8,108 l 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.937497 c 0,-4.447564 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937501,0 z"
+         id="path3938"
+         inkscape:connector-curvature="0" />
+      <path
+         sodipodi:nodetypes="cccc"
+         inkscape:connector-curvature="0"
+         d="m 107.07401,68.171344 0,55.657316 L 149.27466,96 z"
+         style="fill:#ffffff;stroke:none"
+         inkscape:label="Triangle"
+         id="path4262" />
+    </g>
+  </g>
+  <g
+     style="display:inline"
+     inkscape:label="Layer"
+     id="layer3"
+     inkscape:groupmode="layer"
+     sodipodi:insensitive="true">
+    <path
+       style="opacity:0.11522636;fill:url(#linearGradient4504);fill-opacity:1;stroke:none"
+       d="M 14.214274,89.623384 74.117285,35.304552 143.41187,104.59914 106.15739,181.5665 z"
+       id="path4488"
+       inkscape:connector-curvature="0" />
+    <path
+       style="opacity:0.11522636;fill:url(#linearGradient4521);fill-opacity:1;stroke:none;display:inline"
+       d="m 74,101.96875 -8.09375,7.34375 2.09375,0 0,49.375 0,1.3125 0,1.3125 65.3125,0 L 74,101.96875 z"
+       id="path4488-8"
+       inkscape:connector-curvature="0" />
+    <g
+       transform="translate(0,2.2931745)"
+       id="g4071"
+       style="filter:url(#filter4692)">
+      <path
+         style="fill:#08a0b5;fill-opacity:1;stroke:none;display:inline"
+         d="M 22.0625,154.3 C 17.60353,154.3 14,150.71631 14,146.26875 L 14,102.3 l 60,0 0,52 -51.9375,0 z"
+         id="rect3104-7-2-1"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#33c9dd;fill-opacity:1;stroke:none;display:inline"
+         d="M 22.0625,151.7 C 17.60353,151.7 14,148.11631 14,143.66875 L 14,99.7 l 60,0 0,52 -51.9375,0 z"
+         id="rect3104-7-2-8"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#00bcd4;fill-opacity:1;stroke:none"
+         d="M 22.0625,153 C 17.60353,153 14,149.41631 14,144.96875 L 14,101 l 60,0 0,52 -51.9375,0 z"
+         id="rect3104-7-2"
+         inkscape:connector-curvature="0" />
+    </g>
+    <g
+       transform="translate(-0.511613,5.6775255)"
+       id="g4111"
+       style="filter:url(#filter4680)">
+      <g
+         id="g4106">
+        <path
+           inkscape:connector-curvature="0"
+           id="rect3104-7-2-1-0"
+           d="m 22.574113,29.7293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
+           style="fill:#35baf6;fill-opacity:1;stroke:none;display:inline" />
+        <path
+           inkscape:connector-curvature="0"
+           id="rect3104-7-2-8-8"
+           d="m 22.574113,32.3293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
+           style="fill:#0a91ce;fill-opacity:1;stroke:none;display:inline" />
+        <path
+           inkscape:connector-curvature="0"
+           id="rect3104-7-2-2"
+           d="m 22.574113,31.0293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
+           style="fill:#03a9f4;fill-opacity:1;stroke:none" />
+      </g>
+    </g>
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer5"
+     inkscape:label="finish"
+     style="opacity:0.18656718;display:inline"
+     sodipodi:insensitive="true">
+    <path
+       inkscape:connector-curvature="0"
+       style="fill:url(#radialGradient4630);fill-opacity:1;stroke:none;display:inline"
+       d="m 67.999998,30.703125 0,1.28125 0,1.3125 0,2.09375 -45.937501,0 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,1.3125 0,1.3125 0,36.65625 -5.9999995,0 0,1.28125 0,1.3125 0,21.406255 0,1.28125 0,1.3125 5.9999995,0 0,36.65624 0,1.3125 0,1.28125 c 0,4.44756 3.60353,8.03125 8.0625,8.03125 l 45.937501,0 0,2.125 0,1.28125 0,1.3125 107.937502,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79915 7.21875,-7.96875 l 0,-1.3125 0,-1.28125 0,-109.343745 0,-1.3125 0,-1.28125 c 0,-4.44757 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937503,0 z"
+       id="path3938-4-0" />
+  </g>
+</svg>
diff --git a/demo/assets/ic_launcher.svg~ b/demo/assets/ic_launcher.svg~
new file mode 100644
index 0000000000..c01934f697
--- /dev/null
+++ b/demo/assets/ic_launcher.svg~
@@ -0,0 +1,665 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="192"
+   height="192"
+   id="svg3089"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="exoplayer.svg"
+   inkscape:export-filename="/usr/local/google/home/zakcohen/Documents/big.png"
+   inkscape:export-xdpi="225"
+   inkscape:export-ydpi="225"
+   enable-background="new">
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="2.0893424"
+     inkscape:cx="79.970323"
+     inkscape:cy="85.448985"
+     inkscape:current-layer="layer2"
+     showgrid="true"
+     inkscape:grid-bbox="true"
+     inkscape:document-units="px"
+     showguides="true"
+     inkscape:guide-bbox="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1176"
+     inkscape:window-x="1920"
+     inkscape:window-y="24"
+     inkscape:window-maximized="1" />
+  <defs
+     id="defs3091">
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4624">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4626" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop4628" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4498">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4500" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4502" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4511">
+      <stop
+         id="stop4513"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop4515"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0;" />
+    </linearGradient>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4219">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.5"
+         id="feFlood4221" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4223" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="2"
+         in="composite"
+         id="feGaussianBlur4225" />
+      <feOffset
+         result="offset"
+         dy="4"
+         dx="4"
+         id="feOffset4227" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4229" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4464">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4466" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4468" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4470" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4472" />
+      <feComposite
+         result="fbSourceGraphic"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4474" />
+      <feColorMatrix
+         id="feColorMatrix4476"
+         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
+         in="fbSourceGraphic"
+         result="fbSourceGraphicAlpha" />
+      <feFlood
+         in="fbSourceGraphic"
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4478" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="fbSourceGraphic"
+         id="feComposite4480" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4482" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4484" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="fbSourceGraphic"
+         in2="offset"
+         id="feComposite4486" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4494">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4496" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4498" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4500" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4502" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4504" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4535">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4537" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4539" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4541" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4543" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4545" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4557">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4559" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4561" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4563" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4565" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4567" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter4575">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4577" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4579" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur4581" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4583" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4585" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       id="filter4575-6"
+       color-interpolation-filters="sRGB">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood4577-1" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite4579-3" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         id="feGaussianBlur4581-3" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset4583-6" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite4585-9" />
+    </filter>
+    <filter
+       id="filter3896"
+       inkscape:collect="always">
+      <feBlend
+         id="feBlend3898"
+         in2="BackgroundImage"
+         mode="multiply"
+         inkscape:collect="always" />
+    </filter>
+    <filter
+       inkscape:label="Drop Shadow"
+       style="color-interpolation-filters:sRGB;"
+       id="filter3909">
+      <feFlood
+         result="flood"
+         flood-color="rgb(0,0,0)"
+         flood-opacity="0.2"
+         id="feFlood3911" />
+      <feComposite
+         result="composite1"
+         operator="in"
+         in="flood"
+         in2="SourceGraphic"
+         id="feComposite3913" />
+      <feGaussianBlur
+         result="blur"
+         stdDeviation="6"
+         in="composite"
+         id="feGaussianBlur3915" />
+      <feOffset
+         result="offset"
+         dy="6"
+         dx="0"
+         id="feOffset3917" />
+      <feComposite
+         result="composite2"
+         operator="over"
+         in="SourceGraphic"
+         in2="offset"
+         id="feComposite3919" />
+    </filter>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4498"
+       id="linearGradient4504"
+       x1="43.149372"
+       y1="63.20599"
+       x2="110.44475"
+       y2="130.50137"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4498-7"
+       id="linearGradient4504-7"
+       x1="43.149372"
+       y1="63.20599"
+       x2="110.44475"
+       y2="130.50137"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4498-7">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4500-0" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4502-0" />
+    </linearGradient>
+    <linearGradient
+       gradientTransform="translate(-0.12691481,66.675082)"
+       y2="130.50137"
+       x2="110.44475"
+       y1="63.20599"
+       x1="43.149372"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient4521"
+       xlink:href="#linearGradient4498-7"
+       inkscape:collect="always" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4624"
+       id="radialGradient4630"
+       cx="17.483059"
+       cy="18.005892"
+       fx="17.483059"
+       fy="18.005892"
+       r="88.000001"
+       gradientTransform="matrix(-0.00420028,0.99999118,-1.888314,-0.00793148,51.557271,20.787508)"
+       gradientUnits="userSpaceOnUse" />
+    <filter
+       id="filter4680"
+       style="color-interpolation-filters:sRGB;"
+       inkscape:label="Drop Shadow"
+       width="1.4100000000000001"
+       height="1.4700000000000002"
+       x="-0.23000000000000009"
+       y="-0.23000000000000009">
+      <feFlood
+         id="feFlood4682"
+         flood-opacity="0.2"
+         flood-color="rgb(0,0,0)"
+         result="flood" />
+      <feComposite
+         id="feComposite4684"
+         in2="SourceGraphic"
+         in="flood"
+         operator="in"
+         result="composite1" />
+      <feGaussianBlur
+         id="feGaussianBlur4686"
+         in="composite"
+         stdDeviation="6"
+         result="blur" />
+      <feOffset
+         id="feOffset4688"
+         dx="0"
+         dy="6"
+         result="offset" />
+      <feComposite
+         id="feComposite4690"
+         in2="offset"
+         in="SourceGraphic"
+         operator="over"
+         result="composite2" />
+    </filter>
+    <filter
+       id="filter4692"
+       style="color-interpolation-filters:sRGB;"
+       inkscape:label="Drop Shadow"
+       width="1.3600000000000001"
+       x="-0.2400000000000001"
+       y="-0.070000000000000034"
+       height="1.3600000000000001">
+      <feFlood
+         id="feFlood4694"
+         flood-opacity="0.2"
+         flood-color="rgb(0,0,0)"
+         result="flood" />
+      <feComposite
+         id="feComposite4696"
+         in2="SourceGraphic"
+         in="flood"
+         operator="in"
+         result="composite1" />
+      <feGaussianBlur
+         id="feGaussianBlur4698"
+         in="composite"
+         stdDeviation="6"
+         result="blur" />
+      <feOffset
+         id="feOffset4700"
+         dx="0"
+         dy="6"
+         result="offset" />
+      <feComposite
+         id="feComposite4702"
+         in2="offset"
+         in="SourceGraphic"
+         operator="over"
+         result="composite2" />
+    </filter>
+    <filter
+       id="filter4710"
+       style="color-interpolation-filters:sRGB;"
+       inkscape:label="Drop Shadow">
+      <feFlood
+         id="feFlood4712"
+         flood-opacity="0.2"
+         flood-color="rgb(0,0,0)"
+         result="flood" />
+      <feComposite
+         id="feComposite4714"
+         in2="SourceGraphic"
+         in="flood"
+         operator="in"
+         result="composite1" />
+      <feGaussianBlur
+         id="feGaussianBlur4716"
+         in="composite"
+         stdDeviation="6"
+         result="blur" />
+      <feOffset
+         id="feOffset4718"
+         dx="0"
+         dy="6"
+         result="offset" />
+      <feComposite
+         id="feComposite4720"
+         in2="offset"
+         in="SourceGraphic"
+         operator="over"
+         result="composite2" />
+    </filter>
+  </defs>
+  <metadata
+     id="metadata3094">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     style="display:none"
+     sodipodi:insensitive="true"
+     transform="translate(0,176)"
+     inkscape:groupmode="layer"
+     inkscape:label="Layer 1"
+     id="layer1">
+    <image
+       width="192"
+       height="192"
+       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAABHNCSVQICAgIfAhkiAAAIABJREFU eJztnVlXE1vax/9JZSBAAgljoAHbNBIwKHAOCsJSUZperr7qj3A+Tn+K8w2OV2fRx0YBFwioDEqE AA3vQRYUCCRQCZmH94KVLEBIatg1xfrdKVV771Sef2oPz6D797//nenr60MqlcKPTjgcBgCUlpZq /RU5er0e8/Pz0E1OTmZqamrQ3t4u95hk5+zsDABQVlam9VfkrKysIJFIQJ9KpdDe3g6v1yv3mGQn nU4jnU5r/RU5Xq8XHR0dSCaT0Gf/0+PxaCLQKHq8Xi88Hk/u3/qLf9REoFHMXDV+4IoAAE0EGsXJ dcYPXCMAQBOBRnFxk/EDNwgA+DFFYDabYTabtf6KiHzGDwCGfDdnRZCvATEJBAJYXl5GMBiEXq+H Xn+jXonAZ588O65EIgG/34/j42Po9XqUl5ejtLQUNptNUH8MwyAcDiMUCiGdTqOqqgoOhwNGo5Hz ro5U5wDZcVmtVnR2dsJut4va302wsd28AgDkEUEwGMTY2Bjq6+vR29sLi8UiSb9s98kjkQj29vbA MAxMJhNSqRQsFgt6e3tRWVkJiqKI9pcllUrh5OQEfr8fkUgEFEUhHo/DZrOhoaGh4HOS+hwgEolg aWkJ+/v7GB4ehtVqlaRfgJ3xAywEAEgrgqWlJdA0jX/961+i93WVm35NT05OsL29jVQqBZ1Oh8rK SrS0tMBgYPX4OPd3ExRFoaqqClVVVZf+P5lMYmdnBycnJ8hkMqAoCi0tLaisrBTUn1AsFgv6+/sB AKOjo3A6nejq6hK9Xy62qnvz5k1maGiIeMN8ePv2LRwOh2xTrmAwCIqiUFpaio2NDTAMAwCor69H Y2OjKP0BEOWXcXd3F/v7+wAAm82G1tZWhMNhpFIpSX+JL+L1euH3+/H48WNR+2BrP/Pz8+zeAFnE fBMsLS3JavwAsLGxgUgkApvNhjt37qh6wdjY2JgTbSwWw/LyMhiGgcViQU9PjyxjytrP0tKSKG8C PrbJ+R0uhgiCwSBomsaLFy+ItcmWr1+/4uDgACaTCc3NzSgrK5NszSEVZrMZnZ2diEQiODs7w6dP nxCPx1FXV4fm5mZJx+LxeDA6OgqXy0X0TcTXJnltq5DeIh0bG5PU+JPJJBYXFzE3N4eKigr09vbi /v37MJvNSCaTko1DapLJJMxmM+7fv4/e3l5UVFRgbm4Oi4uLkn7uFy9eYGxsjFh7Qn6Qea/iSL0J AoEA6uvrBbXBpS+fzwebzYbu7m5J+lQyFRUVePjwIQDgy5cvYBgGbrdbkm3L+vp6BAIBwX0JtUFB G+sk3gTLy8ui7wzQNI3Z2VkEAgH09/fj7t27ovanRu7evYv+/n4EAgHMzs6CpmlR++vq6sLy8rKg Nkj8AAs+WRIqgmAwKNqcm6ZpTE9PAwD6+vpw+/ZtUfopJm7fvo2+vj4AwPT0tGhCsFgsuV0wPpBa hxI5WhUiAjFOdwOBAN6+fQsAGBgYgNPpJN5HseN0OjEwMADgfHs6EAgQ74Pvd09yE4aY9fEVgdDD pIuk02nMz88jGAzi8ePHnA2/2H1z+PTndDrx+PFjBINBzM/PEz1M4/Pdk96B5HQQxoZ8A7zq22Mw GLC/v4/a2lre/WUyGRiNRqyuruLOnTugKIr3jkaxx+gK7c9gMCCVSmF9fR3t7e1IJBLQ6XS82spk Mjg9PUV5eTn0ej0r3yHSxj8/Pw+8efMmQ5rl5eVL/2YYJvPbb79l3r17lwmHw5f+9p///EdQX0dH R5mJiYlMNBoV1E4mk8mEQqFMKBQS3E6x9xeNRjMTExOZo6MjQe3Mzs5mYrFY7t/hcDjz7t27zG+/ /ZZhGObStVdtigQfP37MkJt/XODiFqmYvj2zs7OoqanBkydPiLQnta+MWvszm8148uQJNjc3sbGx kVs0cyWTyVwa002+Q2K64IjmX+zxePDrr7/CZDIRP+QKBAIYHx/HgwcP4HK5iLatwR6Xy4UHDx5g fHyc+CL5xYsXMJlM+PXXX0V1jxFNAEtLS7lDFpIsLi6CpmkMDQ2JHh+gURi9Xo+hoSHQNI3FxUXi 7T98+BBLS0vE280iigVlfXs6OjrQ0dFBxG0ilUrh9evXcLvd6OjoIDBKDZJ0dHTA7Xbj9evXRJKs ZVOXdHR0gKZpQWcG+RBFAFd9e4Qelh0fH2NqagrPnz8vOke1YsJiseD58+eYmZnB0dER73auzvlJ +w5dhLgAbvLt4SsCn8+Hw8NDYgtdDfEZHBzE0dERfD4f53tvWvBmfYdIQ1wA+Xx7uIpgamoKNTU1 cLvdpIanIRFutxs1NTWYmppifU++3R4SvkPXQVwAhXx72IpgbGwMDx8+/C78T0M9VFVV4eHDh6ym L4W2OoX6Dt0EcQGw2ZnJJ4JkMolXr15heHgYRqOR9PA0JMZoNGJ4eBivXr269oSeoijW+/xi7PoR b5Gtf4fH48H29val62OxGD58+ICRkRHSw2KFGnxz1NTfRUZGRvDhwwfEYrHc/5lMJvh8Ptb7/CT9 xrII8gUS6ttjMBjw7t079PX14fT0FAaDAWVlZbJlMFabb47S+7uKXq/H2dkZkskkKioq8PHjR3R3 d7PyJ8rw8B0qBOeg+Cz58vb88ccf+Mc//sG6rXQ6jdraWtjtdvz88898hkOMYs/Xr5T6AB8/fgRF URgeHsb9+/dhMplY3Tc3N4fu7u7c9STyDnEWAGnfntPTU9jtdpSXlxNpTwhq9c1Ran83UV5eDoZh cHp6ymlMbH2HuMBpDfD27VsYDAZivj2xWAwGgwE///wz3G73D5eL9EfE6/XC7XbjwYMHSCaTiMfj RNp98eIFDAZDLhCKLawFQDpvTzKZxMLCwqXX8Y+YkPdH4upuT3V1Nd6/f08sI4XH44HD4eDkO8RK AFnfHpJeeW/evEF/f/93r0BNBMXJdVudqVQKQ0NDePPmDbF+PB4PJ98hVgIgnbdnbGws71anJoLi It8+fyKRwMjICFFfHy6+QwUFQDpvz9TUFCu/Hk0ExQHbQ64nT55wcpsoBFvfoYICIJm3x+fzob29 nfUJryYCdcMlkstoNKK9vZ2XA911sPUdKigAUnl7jo+PAYCzb48mAnXCJ4wxaxtZWxECW9+hggIg 4X+RSqVy21980ESgLoTE8Ga3w0kE1bCxXUkEMDExIdifXxOBOiARwP7kyRNMTEwIHgsbFwvRg2oX Fxfx6NEjIm1pIlA2JLM3PHr0SHCMcUVFBaLRaN5rRBVAIBCA2WwmGsaoiUCZkE5dYrFYYDabBUWB yf4GWFpaEiWAXROBshArb09HR4eoGSEAEQUwOzsrahyvJgJlIHbduCdPnmB2dla09okLIJPJ4Pj4 GDU1NaLn7dFEIC9SVA7V6/WoqakRlGUib/ukGzQajfB6vZJlbNNEIA9S1o52uVzwer2ihMgSF8Dq 6irvXJF80UQgLVIXTgeA/v5+UdYDRAWQTqdlKy+qiUAa5DB+4Dyeua2tDZlMhmi7RAWwuLgIiqJI NskJTQTiIpfxZykpKSGef5SYAAKBAGpqamQvM6qJQBzkNn7gPIjKZrMRzRBHTADLy8uSF12+CU0E ZFGC8Wfp6OggmiGOiABomkZrayuJpoihZBGk02kEg0GcnZ3h7OwMwWBQMQHrV1GS8QNAPB5Ha2sr seqVRDINbW1t5SoKKglSxbz5sru7mwv8TyQSMBqNSKVSMJlMqKioyF2n0+lA0zTi8Tgoispdm63s 3tjYKMv4lWb8WZxOJ6anp4lU/xQsAJqmFV1/V0oRMAyDb9++Qa/Xw2g0oqGhIe+mQHZHo7y8/Ma0 MKlUCjs7O0gkErkcSjabTZTxX0Spxp/l9u3boGlasAgEC2B7e1vyfX+uiCmCZDKJzc1N6PV61NXV 4W9/+xvR9imKQlNTU+7fDMNgY2MD6XQaLpdLlHSBSjd+4PwtMDs7K68AAoGAoBKnUkJaBMFgELu7 u7BYLGhrayPSJhtsNlvuDbC9vY1IJILGxkZeWdGuQw3Gn6W2thaBQIB3akRA4CLY5/MpevpzFRIL 41AohNXVVSQSCbjdbrS0tBAaHXdaWlrgdruRSCSwurqKUCgkqD01GT9wPg0SGkPMWwDZPVm1IUQE Xq8XoVAI7e3tcDgchEfGH4fDgfb2doRCIUGfTU3Gn8Vmswk6e+ItgOXlZdy9e5d3x3LCVQQHBwdY W1uDx+MhmiKGNPX19fB4PFhbW8PBwQHr+9Rq/ABw9+5dQecCvAVAKqejXLAVwefPnyWf5wulra0N FosFnz9/Lnitmo0/ixBb5CWAr1+/FkXdrnwiiEajWFhYwL1791Q51bPZbLh37x4WFhZujIstBuMH zjNJfP36lde9vARwcHBw6SBHzVwVgU6ng9/vx+7uLnp6emQcGRl6enqwu7sLv99/KUa2WIwfOA9+ 5zLluwgvAbAtaKAWsiIwGAzY29tDLBaTLKBHClwuF2KxGPb29mAwGIrK+LPwtUlDOBzG2dnZtb4o ZrMZV/++sbGB5ubma7NuXXd9PrheLyYulwszMzNoamqC1WoVrTL5RbIVW6TAarUiFAphZmYG/f39 kny+QoTDYYRCISQSCcHXNzU1YWFh4ZJPWqH2w+EwtzcARVGIRCKyl9ghjU6nw87ODpqamkDTtKwx DWJBURRomkZTUxN2dnZYpQxREyUlJYhEIpy/O0NpaWleg776d5vNljfPT6H2hF4vBn6/H1arFVar FX/5y1+wubkp6RSB1CluPrxeL3p7e5FKpRAMBhGPx2U/yygtLUV5eTlKSkqIXG+z2S4VACx0fWlp Kbc3wMbGBu7cucPlFsUTjUYRCATgdDqRyWSQTCYV7UrNh+ycP5lMIpPJwOl0IhAIFMyapjbu3LmD jY0NTvdwEgDDMLLVmRWLlZWVaxe8xSKCmxa8LpcLKysrMoxIPMxmMxiG4XSP6LlBlcznz5/zbnWq XQSFdnt6enpYHZYVM6wFcHJyomg3AK4cHBzg1q1bBa9TqwjYbnXeunWL9x66Eqmvr8fJyQnr61kL YHt7W7bIJDE4OTlhfcKrNhFw2ee32WycDEbpNDY2Ynt7m/X1rAVAomCBUvB6vZx9e9QiAj6HXG1t bar4bGzhYqusBVAs+8ahUAjV1dW87lW6CISc8FZXVwuOJ1AKXGyVlQAikQgqKyt5D0hJ7OzsCFrL KFUEQt0b6uvrsbOzQ3BE8lFZWYlwOMzqWlYC2NvbuxSXqlaCwSDq6uoEt6M0EZDy7amrq1OEi4RQ mpqasLu7y+paVgJgGEaU4Gup2d3dJXb6qRQRkHRsczgcrA1HyRgMBjAMQ6ZCjF6vLwrvz2QySbRU EyC/CMTw6rRYLLKntySB2WwmVyWyGHaANjc3RQlgl0sEYrk0t7S0YHNzk3i7UpNKpcgIIJFIEP/l lAMxq9VILQKx/fnFruwjBSUlJaxCJQt+Ur/fL7vXoFAYhiGy+M2HVCKQIpilrq6Os0+N0nA4HPD7 /QWvKyiA4+Nj1W+Bfvv2TZK4XrFFIFUkl81mw7dv30TvR0wcDgerNOqs1gBqDxCR8pUulgikDmNU +zQoG7xViIKf8qakrWpCjOJq+SAtAjlieKV+ZmLAJtCmoAAuRtiokd3dXTQ0NEjeLykRyBXA3tDQ oPozATa2W1AAasyJc5FYLCbbFE6oCOTM3kBRFGKxmCx9k4KN7ap7oscCuU+w+YpACalL5H52QiEy BVI7bFNuiAlXESjB+AFlPDshsFnHFL0AlLKYYysCpRg/oJxnJyZFLwAluXEUEoGSjB9Q1rMTi6IW QDqdVpwj300iUJrxA+fpBuXO2Cc2RS2As7MzRSbxvZiLVMm5OisqKiRN3ygHeXODZk/TxMr1KXZu 0OyXl63GyPZ6KXC5XFhYWABwnp5EiblIxX4eJHOD8rm+YG5Qg8HA2ng0NNQI59yghVBablCdTsfZ nUOqXJ3ZpFxKzUWq0+mQyWREex6kc4NyvZ5zblC1UVZWhtPTU7mH8R0Xc3UqORfp6emp7ImLxaao BaDX6xVXy+ymBa8SRRCPx1XvFVqI4v50gKJcuQvt9ihNBEp6dmJR9AJQynE+261OJYlAKc9OTIpe AEo4zue6z68UESjh2QmBjYCLXgByp/jge8ilBBHI/eyEwqYASEEBqD042mw2y+bTIvSEV04RpFIp 1RdDYWO7BQXANseiUmlsbMTe3p7k/ZJyb5BLBHt7e6pPh8/GdgsKoBgyBku9mCPt2yOHCIphAUxk CpROp1XvFiulR6NYjm1Si0DtXqBsE7oVFEBVVZXqK4jU1tZKspYR26tTKhEwDIPa2lrR+xGTk5MT 2O32gtcVFADbDFtKxmaziV4HSyqXZilEcHBwoPpkCGwzGhYUgNFoZJVgSOmI+UqX2p9fbBGoffoD nM//2QRDsVoDFMORuMvl4lQ8jS1yBbOIJYLt7e1r6yarDYqiWAmZlQCU5lDGB4PBQPxNJncklxgi iEQiqk+HApzngyIiAOB8Dq32U0Hg/EyA1HpGbuPPQlIEfr9f9Xv/wPkJts1mYxXMxUoADQ0NRVFA zWq1ElkMK8X4s5ASwcHBgSTBQGKzs7PDWsisBGCxWFS/FZqlqakJ+/v7vO9XmvFnESqC/f39oiiE CJxvgbLNacvaGa5YYoPLy8txdHTE616lGn8WISI4OjoqikzgADdbZS2AYtgJyuLxeLC2tsbpHqUb fxY+IlhbW1PFZ2MLF1tlLYCWlhbVp8u+SGVlJevTYbUYfxYuImAYRvUVgC6yu7vLqRgiawFUVlYK mjsrjbq6Ovz5558Fr1Ob8WdhK4I///xT9PppUrK/v89J0EUfEJOPe/fu5ZJTXYdajT9LIREsLCzg 3r17Eo5IeXASgM1mU33RhKt0dHRcWxdX7caf5SYRbG5uoqOjQ4YRiUcsFuPsw8RJAK2trVhfX+fU gdIpKSmB3W4HTdPQ6XSKztXJl4u5SHU6HWiaht1uZ51gSi2sr6+jtbWV0z15c4Nezd1JURQYhkE4 HL42RkBpuUHZYjKZcHR0hFAoBJqm0dvbq8hcnUJwuVz48OEDnE5nLtubFJ8xHyRzfV5nm4Jzg14l lUrBYrGwirRRE5lMBk1NTdjZ2YHT6VR9ANB1pFIpOJ1O7OzsoKmpqWjOdbJEo1FYLBbO3x3n3KA9 PT349OkT7t+/z+r6QoidG5QtXq8X/f392NnZQTAYhNPplKxvKdwPaJpGJpNBf3+/5LlIb4Jkrs9P nz7lcq2ybZ93btBi8A69yMVcnQ0NDTCbzdcujNXK5uYmzGYzGhoaFJ2LVAh8bZKXAOrq6hSZdJYP Vxe8mUwGDocDjY2NebdI1cLCwgIaGxvhcDguTXuKSQSnp6e8zzJ4CaC5uRk+n49Xh0oi325PSUkJ enp68PnzZ1XmRmIYBp8/f0ZPT8+NU4BiEYHP50NzczOve3kfhCmt9hZX2G513rt3D5FIhLPvkJys ra0hEomwOuQqBhEIsUXeAujs7MSXL194dywnXPf56+rq0NbWBq/Xq2h3kP39fXi9XrS1tXGaEqhZ BF++fEFnZyfv+3kLwGAwqHJqIOSQy+PxoLy8HKurq4rKlOH3+7G6uory8nJBn02NImAYRlAIpyBf ILfbja2tLSFNSAqJE97y8nK0t7fDaDTC5/OJEmjPlu3tbfh8PhiNRrS3twv251ebCLa2tuB2uwW1 ISj62W63Y21tDbdv3xY0CCkg7d5gtVrhdruRTCaxtrYGvV6Puro60fPpMAyDg4MDpNNpuFwu4gHs WREo4ZygEN++fRNse4KfXktLC2ialvTgiCtifqEGgwFtbW0Azo3zf//7H/R6PYxGIxoaGgQHEqVS Kezt7SGRSCCdTqO2tpazvwtX1CACmqY5+f3fhGABOJ1OTE9PK1YAUn6RNpvt0htgd3cXsVgMBoMB iUQCRqMRqVQKJpPpUhFqnU6H09NTxONxUBSVuzaZTMJsNssSq6t0EWxtbWFgYEBwO0Ten7dv31bk W0DuL/CmzATpdPqSI1wmk4HT6VRcQTqlioCmaWLTbiJP3Ol0YmNjg0RTxFDiF5dFr9fDarWirKwM ZWVlsFqtijP+LEpbGJtMJmxsbBD7sSX21Ds7O/H161dSzQlCycavRpQkgpWVFUH7/lchJgC73Y7D w0PZ0+ppxi8OShBB9uyJTdpzthB973Z3d8vqS68Zv7jILYJoNIru7m6ibRIVgF6vx/r6uixxw5rx S4NcIojFYlhbW4NOpyPaLvGVV3t7O2ZnZ0k3mxfN+KVFDhHMzMygq6uLeLvEBZBIJODxeCQLKNGM Xx6kFEE2gk2Mwn3EBaDT6VBVVYXDw0PRA90145cXKUSQTqdxeHiI6upqUdoXbfO5r68Pk5OTYjWv Gb9CEFsEk5OT6OvrE619UU9furq6sLKyQrxdzfiVhVgiWFlZEWXefxFRBWC32xGLxYiWJtKMX5mQ FkEkEkEsFhO0589mx0j08/fu7m68e/eOSFua8SsbkiJ49+6d4D3/QCBQMOUKqyJ5Qnn69Kng9YBm /OqAhAgmJyfx9OlTwWMhUiOMhAAoioLH4+GdSUIzfnUhRAQ+nw8ej4dIQRYiVSKtViuROXxVVRUA 4Pj4mNN9mvGrEz4iyNpG1laEEIlEWGXcKyiAzs5OLC0tCR4QcB5DvLq6yvpAQzN+dcNFBIlEAqur q4JjfLMsLS2x8hotKAC73U40Fcjg4CCr9YBm/MUBWxFMTk5icHCQWL/7+/usdpBY7QINDw9jdHRU 8KAutvfq1asb/64Zf3GRTwRGoxGvXr3C8PAwsf5GR0dZt8dKAFarFU6nk+g+77NnzzAzM/NdJJRm /MXJdSKgKArj4+N49uwZsX68Xi+cTifrjNuszwG6urrg9/uJicBgMKCnp+dSbKxm/MXNVREcHR3h wYMHxIKovF4v/H4/p9NjTgdhjx8/RjKZJDYdMpvNSCaT+PjxY277S6O4yW6Hv3//HgaDgViO2dHR USSTSTx+/JjTfZyl19XVBZfLhZcvX6K+vh5dXV2wWCy5v3OtPFJRUZErb6PxY5BNZ8inPvHFKXMk EsHS0hL29/cxPDzMq9CI7s2bN5mhoSHONwLnR83Ly8sIBoPQ6/UwGAzw+/24desWKyGYTCb88ccf GB4exsnJCZLJJKqrq2ULqwyHwwDOK4do/ZGHoigcHR3ljH9ychIDAwOso7z29/dhNBqh1+uRTqdh tVrR2dnJ219ofn5eeGrEq6+c33//Hd3d3QVP4SiKgs/nQ3d3N+7fv490Oo14PI73799jaGhIlOCH QoRCIQAQnGNT6+97jEYjxsfHMTAwkJv2JJNJAMBPP/1U8EdPr9fjv//9L/75z38SHRfxFA56vZ7V vM7r9aKzsxN7e3u560tKSvD06VO8fv0aIyMjpIdWkKzopCofWuz9XeTVq1d49uzZpQWvTqfDTz/9 hLW1NVbrPzFyJxFvkY3/Rb7dHoPBgJGREYyNjcnyFtAgSyKRwNjYGEZGRq7d7UmlUqwPy8SIMCQu gEK+Q2y3OoeHhzE3N8fZd0hDORwfH2Nubo7VoVQhEbD17eEKcQHk8x3ius8/ODiIw8PDoqhH9qPh 8/lweHjIyb0hnwjY+vZwhbgAbvId4nvI5Xa7UV1djampKRLD05CAyclJ1NTU8HJsu0kEbH17uCJK RNhV3yGhJ7zV1dXo7+/H69eviYZXapAlEong9evXGBwcFOTSfFUEXHx7uCJKIs+s71A2IJ7ECS9F UXj+/DkWFxdhNpvR0dEhuE0NcqysrCAWi+H58+dE2vN4PDn74eLbwxXRYoK7urowNzdHvN3u7m44 nU6Mj4+LnndIozDpdBrj4+NwOp3E83YCwNzcnKiZIUQTgNfrxS+//IJ4PE7UlRo4X2cMDQ3h/fv3 kmWg0/iezc3N3MEl6fn56Ogo4vE4fvnlF1HzDokigItz/q6uLgwODuLly5eYmZn5bg7P1XfoIn19 faioqMDExIQsCXl/VGKxGCYmJlBRUSE4adVV356ZmRm8fPkSg4ODuV9+MZNvCfIFuo58C16hvkM3 YTQasbS0hLa2NpSUlOSO2LlS7L45QvszGAyIRqNYW1tDV1eX4INKrr49pN3l5+fnyQqAzwB///13 /P3vfycyn89kMlhcXITNZkNHRwfi8Tin+4vdN4dvfyaTCSsrK2AYBt3d3URSlPP17SEpAsHOcBfh OzC2vkNsefToEQKBAKamptDa2sqpllSx++bw6Y+maWxsbKCzs5N4vAYf3x7ShfuIrAGEDEiMnZyL XqrT09OgaZp4H8UOTdOYnp4GcB4IJcYhFN/vnuSaQLAAhKqRVN6h63A6nblasrOzs9ja2hKln2Ji a2srV+BkYGBAtNK3Qn17SIlAkABIvIpI5h26CafTib6+PtjtdszMzODLly+i9qdGvnz5gpmZGdjt dvT19Yle85mEbw8JEfBeA5Cah5HOO1Sor/7+fiSTSSwuLiIej8PtdqOiokKS/pXG6ekpfD4fTCYT Ojs7Ja3wub+/j/7+fsHtCF0T8PrEpLejsr5DL168INZmPgwGQ+7U8uvXr1hfX4fJZEJjYyPKysok GYMcGAwGnJ2dYWtrC/F4HHV1dXj48KHk4yDt2yNEBJwFIEbqkot5h6TODNHc3Izm5mYAwMLCAiKR CGw2G+7cuQOz2SzpWMQiFothfX0dDMPAYrGgp6dHtrFwzdvDFr4i4CQAMQ20q6sLb9++lTU3UGtr KyiKQmlpKTY2NnKZKurr69HY2CjLmPiyu7ubm1rabDZ0dnYiHA7LXsfZ7/dzTl3CFj4iYH0QJpVh Li0tgaZpyaZDFwkGgwDw3a/TyckJtre3kUqloNPpUFlZiaamJsFz5pv640oymcTOzg5OTk6QyWRA URRaWlq+SztCqj8+jI6Owul0il7yCGBvq6wPwqT8VS6Ud0gOKisrLxnlyVLcAAABS0lEQVRTOBzG //3f/4FhGJjNZqRSKZSUlMDhcKCyshJGo1GUcSQSCZycnMDv9yMajYKiKMRiMdhsNjQ2NuKvf/2r KP3yhUTeHj5weRMUfAPIOSW56juk0+lgt9sF+Q3lg6uvjE6ng16vh16vRzweh9/vRyAQQCQSQUlJ CUpLS2Gz2VBSUnKtKPL1l0gkEI1GwTAMwuEwotEoLBYL7HY7HA4HTCYT0uk00uk06+chtu+RTqdD IBBAJpMhkrdHKIVst+AbQO5cndflHYpGo6L1pxbfHCX3J0fKlZtg8ya4UQByG/9NiPmA1eCbo6b+ lEAhEVx7EqxU49fQ4EO+E+PvBKAZv0YxcpMILglAM36NYuY6EeQEoBm/xo/AVRHo9Xo9VlZWNOPX +GHIioCiKBjm5+fx/PlzzM/Pyz0u2VFbjK7S+1MyFEVhamoK/w+AyfN+zOygegAAAABJRU5ErkJg gg== "
+       id="image3116"
+       x="0"
+       y="-176" />
+  </g>
+  <g
+     style="display:inline"
+     inkscape:label="base"
+     id="layer2"
+     inkscape:groupmode="layer">
+    <g
+       id="g4704"
+       style="filter:url(#filter4710)">
+      <path
+         style="fill:#8097a2;fill-opacity:1;stroke:none;display:inline"
+         d="m 68,30.7 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,34.283686 180.39647,30.7 175.9375,30.7 l -107.937501,0 z"
+         id="path3938-4"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#546e7a;fill-opacity:1;stroke:none;display:inline"
+         d="m 68,33.3 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,36.883686 180.39647,33.3 175.9375,33.3 l -107.937501,0 z"
+         id="path3938-5"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#607d8b;fill-opacity:1;stroke:none"
+         d="m 68,32.000003 0,52 -60,0 L 8,108 l 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.937497 c 0,-4.447564 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937501,0 z"
+         id="path3938"
+         inkscape:connector-curvature="0" />
+      <path
+         sodipodi:nodetypes="cccc"
+         inkscape:connector-curvature="0"
+         d="m 107.07401,68.171344 0,55.657316 L 149.27466,96 z"
+         style="fill:#ffffff;stroke:none"
+         inkscape:label="Triangle"
+         id="path4262" />
+    </g>
+  </g>
+  <g
+     style="display:inline"
+     inkscape:label="Layer"
+     id="layer3"
+     inkscape:groupmode="layer"
+     sodipodi:insensitive="true">
+    <path
+       style="opacity:0.11522636;fill:url(#linearGradient4504);fill-opacity:1;stroke:none"
+       d="M 14.214274,89.623384 74.117285,35.304552 143.41187,104.59914 106.15739,181.5665 z"
+       id="path4488"
+       inkscape:connector-curvature="0" />
+    <path
+       style="opacity:0.11522636;fill:url(#linearGradient4521);fill-opacity:1;stroke:none;display:inline"
+       d="m 74,101.96875 -8.09375,7.34375 2.09375,0 0,49.375 0,1.3125 0,1.3125 65.3125,0 L 74,101.96875 z"
+       id="path4488-8"
+       inkscape:connector-curvature="0" />
+    <g
+       transform="translate(0,2.2931745)"
+       id="g4071"
+       style="filter:url(#filter4692)">
+      <path
+         style="fill:#08a0b5;fill-opacity:1;stroke:none;display:inline"
+         d="M 22.0625,154.3 C 17.60353,154.3 14,150.71631 14,146.26875 L 14,102.3 l 60,0 0,52 -51.9375,0 z"
+         id="rect3104-7-2-1"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#33c9dd;fill-opacity:1;stroke:none;display:inline"
+         d="M 22.0625,151.7 C 17.60353,151.7 14,148.11631 14,143.66875 L 14,99.7 l 60,0 0,52 -51.9375,0 z"
+         id="rect3104-7-2-8"
+         inkscape:connector-curvature="0" />
+      <path
+         style="fill:#00bcd4;fill-opacity:1;stroke:none"
+         d="M 22.0625,153 C 17.60353,153 14,149.41631 14,144.96875 L 14,101 l 60,0 0,52 -51.9375,0 z"
+         id="rect3104-7-2"
+         inkscape:connector-curvature="0" />
+    </g>
+    <g
+       transform="translate(-0.511613,5.6775255)"
+       id="g4111"
+       style="filter:url(#filter4680)">
+      <g
+         id="g4106">
+        <path
+           inkscape:connector-curvature="0"
+           id="rect3104-7-2-1-0"
+           d="m 22.574113,29.7293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
+           style="fill:#35baf6;fill-opacity:1;stroke:none;display:inline" />
+        <path
+           inkscape:connector-curvature="0"
+           id="rect3104-7-2-8-8"
+           d="m 22.574113,32.3293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
+           style="fill:#0a91ce;fill-opacity:1;stroke:none;display:inline" />
+        <path
+           inkscape:connector-curvature="0"
+           id="rect3104-7-2-2"
+           d="m 22.574113,31.0293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
+           style="fill:#03a9f4;fill-opacity:1;stroke:none" />
+      </g>
+    </g>
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer5"
+     inkscape:label="finish"
+     style="opacity:0.18656718;display:inline"
+     sodipodi:insensitive="true">
+    <path
+       inkscape:connector-curvature="0"
+       style="fill:url(#radialGradient4630);fill-opacity:1;stroke:none;display:inline"
+       d="m 67.999998,30.703125 0,1.28125 0,1.3125 0,2.09375 -45.937501,0 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,1.3125 0,1.3125 0,36.65625 -5.9999995,0 0,1.28125 0,1.3125 0,21.406255 0,1.28125 0,1.3125 5.9999995,0 0,36.65624 0,1.3125 0,1.28125 c 0,4.44756 3.60353,8.03125 8.0625,8.03125 l 45.937501,0 0,2.125 0,1.28125 0,1.3125 107.937502,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79915 7.21875,-7.96875 l 0,-1.3125 0,-1.28125 0,-109.343745 0,-1.3125 0,-1.28125 c 0,-4.44757 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937503,0 z"
+       id="path3938-4-0" />
+  </g>
+</svg>
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index ee2f978324..596cd5cacc 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1100"
-    android:versionName="1.1.00"
+    android:versionCode="1200"
+    android:versionName="1.2.00"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -29,6 +29,7 @@
 
   <application
       android:label="@string/application_name"
+      android:icon="@drawable/ic_launcher"
       android:largeHeap="true"
       android:allowBackup="false">
 
@@ -41,12 +42,7 @@
       </intent-filter>
     </activity>
 
-    <activity android:name="com.google.android.exoplayer.demo.simple.SimplePlayerActivity"
-        android:configChanges="keyboardHidden|orientation|screenSize"
-        android:label="@string/application_name"
-        android:theme="@style/PlayerTheme"/>
-
-    <activity android:name="com.google.android.exoplayer.demo.full.FullPlayerActivity"
+    <activity android:name="com.google.android.exoplayer.demo.PlayerActivity"
         android:configChanges="keyboardHidden|orientation|screenSize"
         android:label="@string/application_name"
         android:theme="@style/PlayerTheme"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java b/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
index a55e2c2cb0..dae5773100 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
@@ -44,14 +44,10 @@
 
   public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
 
-  public static final String CONTENT_TYPE_EXTRA = "content_type";
-  public static final String CONTENT_ID_EXTRA = "content_id";
-
   public static final int TYPE_DASH = 0;
   public static final int TYPE_SS = 1;
   public static final int TYPE_OTHER = 2;
-
-  public static final boolean EXPOSE_EXPERIMENTAL_FEATURES = false;
+  public static final int TYPE_HLS = 3;
 
   private static final CookieManager defaultCookieManager;
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
similarity index 90%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/EventLogger.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
index 7ccecc1285..c9ece110b1 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full;
+package com.google.android.exoplayer.demo;
 
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
 import com.google.android.exoplayer.audio.AudioTrack;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer;
+import com.google.android.exoplayer.demo.player.DemoPlayer;
 import com.google.android.exoplayer.util.VerboseLogUtil;
 
 import android.media.MediaCodec.CryptoException;
@@ -63,8 +63,8 @@ public void endSession() {
 
   @Override
   public void onStateChanged(boolean playWhenReady, int state) {
-    Log.d(TAG, "state [" + getSessionTimeString() + ", " + playWhenReady + ", " +
-        getStateString(state) + "]");
+    Log.d(TAG, "state [" + getSessionTimeString() + ", " + playWhenReady + ", "
+        + getStateString(state) + "]");
   }
 
   @Override
@@ -81,8 +81,8 @@ public void onVideoSizeChanged(int width, int height, float pixelWidthHeightRati
 
   @Override
   public void onBandwidthSample(int elapsedMs, long bytes, long bitrateEstimate) {
-    Log.d(TAG, "bandwidth [" + getSessionTimeString() + ", " + bytes +
-        ", " + getTimeString(elapsedMs) + ", " + bitrateEstimate + "]");
+    Log.d(TAG, "bandwidth [" + getSessionTimeString() + ", " + bytes + ", "
+        + getTimeString(elapsedMs) + ", " + bitrateEstimate + "]");
   }
 
   @Override
@@ -104,21 +104,21 @@ public void onLoadStarted(int sourceId, String formatId, int trigger, boolean is
   public void onLoadCompleted(int sourceId, long bytesLoaded) {
     if (VerboseLogUtil.isTagEnabled(TAG)) {
       long downloadTime = SystemClock.elapsedRealtime() - loadStartTimeMs[sourceId];
-      Log.v(TAG, "loadEnd [" + getSessionTimeString() + ", " + sourceId + ", " +
-          downloadTime + "]");
+      Log.v(TAG, "loadEnd [" + getSessionTimeString() + ", " + sourceId + ", " + downloadTime
+          + "]");
     }
   }
 
   @Override
   public void onVideoFormatEnabled(String formatId, int trigger, int mediaTimeMs) {
-    Log.d(TAG, "videoFormat [" + getSessionTimeString() + ", " + formatId + ", " +
-        Integer.toString(trigger) + "]");
+    Log.d(TAG, "videoFormat [" + getSessionTimeString() + ", " + formatId + ", "
+        + Integer.toString(trigger) + "]");
   }
 
   @Override
   public void onAudioFormatEnabled(String formatId, int trigger, int mediaTimeMs) {
-    Log.d(TAG, "audioFormat [" + getSessionTimeString() + ", " + formatId + ", " +
-        Integer.toString(trigger) + "]");
+    Log.d(TAG, "audioFormat [" + getSessionTimeString() + ", " + formatId + ", "
+        + Integer.toString(trigger) + "]");
   }
 
   // DemoPlayer.InternalErrorListener
@@ -153,6 +153,11 @@ public void onAudioTrackInitializationError(AudioTrack.InitializationException e
     printInternalError("audioTrackInitializationError", e);
   }
 
+  @Override
+  public void onAudioTrackWriteError(AudioTrack.WriteException e) {
+    printInternalError("audioTrackWriteError", e);
+  }
+
   @Override
   public void onCryptoError(CryptoException e) {
     printInternalError("cryptoError", e);
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/FullPlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
similarity index 77%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/FullPlayerActivity.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index 423af3d40e..6f04db8991 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/FullPlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -13,17 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full;
+package com.google.android.exoplayer.demo;
 
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.VideoSurfaceView;
-import com.google.android.exoplayer.demo.DemoUtil;
-import com.google.android.exoplayer.demo.R;
-import com.google.android.exoplayer.demo.full.player.DashRendererBuilder;
-import com.google.android.exoplayer.demo.full.player.DefaultRendererBuilder;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.full.player.SmoothStreamingRendererBuilder;
+import com.google.android.exoplayer.audio.AudioCapabilities;
+import com.google.android.exoplayer.audio.AudioCapabilitiesReceiver;
+import com.google.android.exoplayer.demo.player.DashRendererBuilder;
+import com.google.android.exoplayer.demo.player.DefaultRendererBuilder;
+import com.google.android.exoplayer.demo.player.DemoPlayer;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.demo.player.HlsRendererBuilder;
+import com.google.android.exoplayer.demo.player.SmoothStreamingRendererBuilder;
+import com.google.android.exoplayer.demo.player.UnsupportedDrmException;
+import com.google.android.exoplayer.metadata.TxxxMetadata;
 import com.google.android.exoplayer.text.CaptionStyleCompat;
 import com.google.android.exoplayer.text.SubtitleView;
 import com.google.android.exoplayer.util.Util;
@@ -37,6 +40,7 @@
 import android.net.Uri;
 import android.os.Bundle;
 import android.text.TextUtils;
+import android.util.Log;
 import android.view.Display;
 import android.view.Menu;
 import android.view.MenuItem;
@@ -52,12 +56,21 @@
 import android.widget.PopupMenu;
 import android.widget.PopupMenu.OnMenuItemClickListener;
 import android.widget.TextView;
+import android.widget.Toast;
+
+import java.util.Map;
 
 /**
  * An activity that plays media using {@link DemoPlayer}.
  */
-public class FullPlayerActivity extends Activity implements SurfaceHolder.Callback, OnClickListener,
-    DemoPlayer.Listener, DemoPlayer.TextListener {
+public class PlayerActivity extends Activity implements SurfaceHolder.Callback, OnClickListener,
+    DemoPlayer.Listener, DemoPlayer.TextListener, DemoPlayer.Id3MetadataListener,
+    AudioCapabilitiesReceiver.Listener {
+
+  public static final String CONTENT_TYPE_EXTRA = "content_type";
+  public static final String CONTENT_ID_EXTRA = "content_id";
+
+  private static final String TAG = "PlayerActivity";
 
   private static final float CAPTION_LINE_HEIGHT_RATIO = 0.0533f;
   private static final int MENU_GROUP_TRACKS = 1;
@@ -79,14 +92,16 @@
   private DemoPlayer player;
   private boolean playerNeedsPrepare;
 
-  private boolean autoPlay = true;
   private long playerPosition;
-  private boolean enableBackgroundAudio = false;
+  private boolean enableBackgroundAudio;
 
   private Uri contentUri;
   private int contentType;
   private String contentId;
 
+  private AudioCapabilitiesReceiver audioCapabilitiesReceiver;
+  private AudioCapabilities audioCapabilities;
+
   // Activity lifecycle
 
   @Override
@@ -95,21 +110,25 @@ public void onCreate(Bundle savedInstanceState) {
 
     Intent intent = getIntent();
     contentUri = intent.getData();
-    contentType = intent.getIntExtra(DemoUtil.CONTENT_TYPE_EXTRA, DemoUtil.TYPE_OTHER);
-    contentId = intent.getStringExtra(DemoUtil.CONTENT_ID_EXTRA);
+    contentType = intent.getIntExtra(CONTENT_TYPE_EXTRA, DemoUtil.TYPE_OTHER);
+    contentId = intent.getStringExtra(CONTENT_ID_EXTRA);
 
-    setContentView(R.layout.player_activity_full);
+    setContentView(R.layout.player_activity);
     View root = findViewById(R.id.root);
     root.setOnTouchListener(new OnTouchListener() {
       @Override
-      public boolean onTouch(View arg0, MotionEvent arg1) {
-        if (arg1.getAction() == MotionEvent.ACTION_DOWN) {
+      public boolean onTouch(View view, MotionEvent motionEvent) {
+        if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
           toggleControlsVisibility();
+        } else if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+          view.performClick();
         }
         return true;
       }
     });
 
+    audioCapabilitiesReceiver = new AudioCapabilitiesReceiver(getApplicationContext(), this);
+
     shutterView = findViewById(R.id.shutter);
     debugRootView = findViewById(R.id.controls_root);
 
@@ -135,7 +154,9 @@ public boolean onTouch(View arg0, MotionEvent arg1) {
   public void onResume() {
     super.onResume();
     configureSubtitleView();
-    preparePlayer();
+
+    // The player will be prepared on receiving audio capabilities.
+    audioCapabilitiesReceiver.register();
   }
 
   @Override
@@ -144,8 +165,10 @@ public void onPause() {
     if (!enableBackgroundAudio) {
       releasePlayer();
     } else {
-      player.blockingClearSurface();
+      player.setBackgrounded(true);
     }
+    audioCapabilitiesReceiver.unregister();
+    shutterView.setVisibility(View.VISIBLE);
   }
 
   @Override
@@ -159,11 +182,24 @@ public void onDestroy() {
   @Override
   public void onClick(View view) {
     if (view == retryButton) {
-      autoPlay = true;
       preparePlayer();
     }
   }
 
+  // AudioCapabilitiesReceiver.Listener methods
+
+  @Override
+  public void onAudioCapabilitiesChanged(AudioCapabilities audioCapabilities) {
+    boolean audioCapabilitiesChanged = !audioCapabilities.equals(this.audioCapabilities);
+    if (player == null || audioCapabilitiesChanged) {
+      this.audioCapabilities = audioCapabilities;
+      releasePlayer();
+      preparePlayer();
+    } else if (player != null) {
+      player.setBackgrounded(false);
+    }
+  }
+
   // Internal methods
 
   private RendererBuilder getRendererBuilder() {
@@ -174,7 +210,9 @@ private RendererBuilder getRendererBuilder() {
             new SmoothStreamingTestMediaDrmCallback(), debugTextView);
       case DemoUtil.TYPE_DASH:
         return new DashRendererBuilder(userAgent, contentUri.toString(), contentId,
-            new WidevineTestMediaDrmCallback(contentId), debugTextView);
+            new WidevineTestMediaDrmCallback(contentId), debugTextView, audioCapabilities);
+      case DemoUtil.TYPE_HLS:
+        return new HlsRendererBuilder(userAgent, contentUri.toString(), contentId);
       default:
         return new DefaultRendererBuilder(this, contentUri, debugTextView);
     }
@@ -185,6 +223,7 @@ private void preparePlayer() {
       player = new DemoPlayer(getRendererBuilder());
       player.addListener(this);
       player.setTextListener(this);
+      player.setMetadataListener(this);
       player.seekTo(playerPosition);
       playerNeedsPrepare = true;
       mediaController.setMediaPlayer(player.getPlayerControl());
@@ -201,15 +240,7 @@ private void preparePlayer() {
       updateButtonVisibilities();
     }
     player.setSurface(surfaceView.getHolder().getSurface());
-    maybeStartPlayback();
-  }
-
-  private void maybeStartPlayback() {
-    if (autoPlay && (player.getSurface().isValid()
-        || player.getSelectedTrackIndex(DemoPlayer.TYPE_VIDEO) == DemoPlayer.DISABLED_TRACK)) {
-      player.setPlayWhenReady(true);
-      autoPlay = false;
-    }
+    player.setPlayWhenReady(true);
   }
 
   private void releasePlayer() {
@@ -256,6 +287,16 @@ public void onStateChanged(boolean playWhenReady, int playbackState) {
 
   @Override
   public void onError(Exception e) {
+    if (e instanceof UnsupportedDrmException) {
+      // Special case DRM failures.
+      UnsupportedDrmException unsupportedDrmException = (UnsupportedDrmException) e;
+      int stringId = unsupportedDrmException.reason == UnsupportedDrmException.REASON_NO_DRM
+          ? R.string.drm_error_not_supported
+          : unsupportedDrmException.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
+          ? R.string.drm_error_unsupported_scheme
+          : R.string.drm_error_unknown;
+      Toast.makeText(getApplicationContext(), stringId, Toast.LENGTH_LONG).show();
+    }
     playerNeedsPrepare = true;
     updateButtonVisibilities();
     showControls();
@@ -401,13 +442,25 @@ public void onText(String text) {
     }
   }
 
+  // DemoPlayer.MetadataListener implementation
+
+  @Override
+  public void onId3Metadata(Map<String, Object> metadata) {
+    for (int i = 0; i < metadata.size(); i++) {
+      if (metadata.containsKey(TxxxMetadata.TYPE)) {
+        TxxxMetadata txxxMetadata = (TxxxMetadata) metadata.get(TxxxMetadata.TYPE);
+        Log.i(TAG, String.format("ID3 TimedMetadata: description=%s, value=%s",
+            txxxMetadata.description, txxxMetadata.value));
+      }
+    }
+  }
+
   // SurfaceHolder.Callback implementation
 
   @Override
   public void surfaceCreated(SurfaceHolder holder) {
     if (player != null) {
       player.setSurface(holder.getSurface());
-      maybeStartPlayback();
     }
   }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
index adb28ef0dc..3a9fdc5529 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
@@ -15,16 +15,17 @@
  */
 package com.google.android.exoplayer.demo;
 
+import com.google.android.exoplayer.MediaCodecUtil;
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.demo.Samples.Sample;
-import com.google.android.exoplayer.demo.full.FullPlayerActivity;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity;
-import com.google.android.exoplayer.util.Util;
+import com.google.android.exoplayer.util.MimeTypes;
 
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -33,13 +34,14 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
-import android.widget.Toast;
 
 /**
  * An activity for selecting from a number of samples.
  */
 public class SampleChooserActivity extends Activity {
 
+  private static final String TAG = "SampleChooserActivity";
+
   @Override
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
@@ -48,19 +50,25 @@ public void onCreate(Bundle savedInstanceState) {
     ListView sampleList = (ListView) findViewById(R.id.sample_list);
     final SampleAdapter sampleAdapter = new SampleAdapter(this);
 
-    sampleAdapter.add(new Header("Simple player"));
-    sampleAdapter.addAll((Object[]) Samples.SIMPLE);
     sampleAdapter.add(new Header("YouTube DASH"));
     sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_MP4);
     sampleAdapter.add(new Header("Widevine GTS DASH"));
     sampleAdapter.addAll((Object[]) Samples.WIDEVINE_GTS);
     sampleAdapter.add(new Header("SmoothStreaming"));
     sampleAdapter.addAll((Object[]) Samples.SMOOTHSTREAMING);
+    sampleAdapter.add(new Header("HLS"));
+    sampleAdapter.addAll((Object[]) Samples.HLS);
     sampleAdapter.add(new Header("Misc"));
     sampleAdapter.addAll((Object[]) Samples.MISC);
-    if (DemoUtil.EXPOSE_EXPERIMENTAL_FEATURES) {
-      sampleAdapter.add(new Header("YouTube WebM DASH (Experimental)"));
-      sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_WEBM);
+
+    // Add WebM samples if the device has a VP9 decoder.
+    try {
+      if (MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_VP9, false) != null) {
+        sampleAdapter.add(new Header("YouTube WebM DASH (Experimental)"));
+        sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_WEBM);
+      }
+    } catch (DecoderQueryException e) {
+      Log.e(TAG, "Failed to query vp9 decoder", e);
     }
 
     sampleList.setAdapter(sampleAdapter);
@@ -76,17 +84,10 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
   }
 
   private void onSampleSelected(Sample sample) {
-    if (Util.SDK_INT < 18 && sample.isEncypted) {
-      Toast.makeText(getApplicationContext(), R.string.drm_not_supported, Toast.LENGTH_SHORT)
-          .show();
-      return;
-    }
-    Class<?> playerActivityClass = sample.fullPlayer ? FullPlayerActivity.class
-        : SimplePlayerActivity.class;
-    Intent mpdIntent = new Intent(this, playerActivityClass)
+    Intent mpdIntent = new Intent(this, PlayerActivity.class)
         .setData(Uri.parse(sample.uri))
-        .putExtra(DemoUtil.CONTENT_ID_EXTRA, sample.contentId)
-        .putExtra(DemoUtil.CONTENT_TYPE_EXTRA, sample.type);
+        .putExtra(PlayerActivity.CONTENT_ID_EXTRA, sample.contentId)
+        .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, sample.type);
     startActivity(mpdIntent);
   }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index deea767d07..7817123830 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.demo;
 
+import java.util.Locale;
+
 /**
  * Holds statically defined sample definitions.
  */
@@ -26,76 +28,53 @@
     public final String contentId;
     public final String uri;
     public final int type;
-    public final boolean isEncypted;
-    public final boolean fullPlayer;
 
-    public Sample(String name, String contentId, String uri, int type, boolean isEncrypted,
-        boolean fullPlayer) {
+    public Sample(String name, String uri, int type) {
+      this(name, name.toLowerCase(Locale.US).replaceAll("\\s", ""), uri, type);
+    }
+
+    public Sample(String name, String contentId, String uri, int type) {
       this.name = name;
       this.contentId = contentId;
       this.uri = uri;
       this.type = type;
-      this.isEncypted = isEncrypted;
-      this.fullPlayer = fullPlayer;
     }
 
   }
 
-  public static final Sample[] SIMPLE = new Sample[] {
-    new Sample("Google Glass (DASH)", "bf5bb2419360daf1",
-        "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
-        + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,as&ip=0.0.0.0&"
-        + "ipbits=0&expire=19000000000&signature=255F6B3C07C753C88708C07EA31B7A1A10703C8D."
-        + "2D6A28B21F921D0B245CDCF36F7EB54A2B5ABFC2&key=ik0", DemoUtil.TYPE_DASH, false,
-        false),
-    new Sample("Google Play (DASH)", "3aa39fa2cc27967f",
-        "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
-        + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0&"
-        + "expire=19000000000&signature=7181C59D0252B285D593E1B61D985D5B7C98DE2A."
-        + "5B445837F55A40E0F28AACAA047982E372D177E2&key=ik0", DemoUtil.TYPE_DASH, false,
-        false),
-    new Sample("Super speed (SmoothStreaming)", "uid:ss:superspeed",
-        "http://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism",
-        DemoUtil.TYPE_SS, false, false),
-    new Sample("Dizzy (Misc)", "uid:misc:dizzy",
-        "http://html5demos.com/assets/dizzy.mp4", DemoUtil.TYPE_OTHER, false, false),
-  };
-
   public static final Sample[] YOUTUBE_DASH_MP4 = new Sample[] {
-    new Sample("Google Glass", "bf5bb2419360daf1",
+    new Sample("Google Glass",
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=255F6B3C07C753C88708C07EA31B7A1A10703C8D."
-        + "2D6A28B21F921D0B245CDCF36F7EB54A2B5ABFC2&key=ik0", DemoUtil.TYPE_DASH, false,
-        true),
-    new Sample("Google Play", "3aa39fa2cc27967f",
+        + "2D6A28B21F921D0B245CDCF36F7EB54A2B5ABFC2&key=ik0", DemoUtil.TYPE_DASH),
+    new Sample("Google Play",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0&"
         + "expire=19000000000&signature=7181C59D0252B285D593E1B61D985D5B7C98DE2A."
-        + "5B445837F55A40E0F28AACAA047982E372D177E2&key=ik0", DemoUtil.TYPE_DASH, false,
-        true),
+        + "5B445837F55A40E0F28AACAA047982E372D177E2&key=ik0", DemoUtil.TYPE_DASH),
   };
 
   public static final Sample[] YOUTUBE_DASH_WEBM = new Sample[] {
-    new Sample("Google Glass", "bf5bb2419360daf1",
+    new Sample("Google Glass",
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0&"
         + "expire=19000000000&signature=A3EC7EE53ABE601B357F7CAB8B54AD0702CA85A7."
-        + "446E9C38E47E3EDAF39E0163C390FF83A7944918&key=ik0", DemoUtil.TYPE_DASH, false, true),
-    new Sample("Google Play", "3aa39fa2cc27967f",
+        + "446E9C38E47E3EDAF39E0163C390FF83A7944918&key=ik0", DemoUtil.TYPE_DASH),
+    new Sample("Google Play",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0&"
         + "expire=19000000000&signature=B752B262C6D7262EC4E4EB67901E5D8F7058A81D."
-        + "C0358CE1E335417D9A8D88FF192F0D5D8F6DA1B6&key=ik0", DemoUtil.TYPE_DASH, false, true),
+        + "C0358CE1E335417D9A8D88FF192F0D5D8F6DA1B6&key=ik0", DemoUtil.TYPE_DASH),
   };
 
   public static final Sample[] SMOOTHSTREAMING = new Sample[] {
-    new Sample("Super speed", "uid:ss:superspeed",
+    new Sample("Super speed",
         "http://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism",
-        DemoUtil.TYPE_SS, false, true),
-    new Sample("Super speed (PlayReady)", "uid:ss:pr:superspeed",
+        DemoUtil.TYPE_SS),
+    new Sample("Super speed (PlayReady)",
         "http://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
-        DemoUtil.TYPE_SS, true, true),
+        DemoUtil.TYPE_SS),
   };
 
   public static final Sample[] WIDEVINE_GTS = new Sample[] {
@@ -103,42 +82,54 @@ public Sample(String name, String contentId, String uri, int type, boolean isEnc
         "http://www.youtube.com/api/manifest/dash/id/d286538032258a1c/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0"
         + "&expire=19000000000&signature=41EA40A027A125A16292E0A5E3277A3B5FA9B938."
-        + "0BB075C396FFDDC97E526E8F77DC26FF9667D0D6&key=ik0", DemoUtil.TYPE_DASH, true, true),
+        + "0BB075C396FFDDC97E526E8F77DC26FF9667D0D6&key=ik0", DemoUtil.TYPE_DASH),
     new Sample("WV: HDCP not required", "48fcc369939ac96c",
         "http://www.youtube.com/api/manifest/dash/id/48fcc369939ac96c/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0"
         + "&expire=19000000000&signature=315911BDCEED0FB0C763455BDCC97449DAAFA9E8."
-        + "5B41E2EB411F797097A359D6671D2CDE26272373&key=ik0", DemoUtil.TYPE_DASH, true, true),
+        + "5B41E2EB411F797097A359D6671D2CDE26272373&key=ik0", DemoUtil.TYPE_DASH),
     new Sample("WV: HDCP required", "e06c39f1151da3df",
         "http://www.youtube.com/api/manifest/dash/id/e06c39f1151da3df/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0"
         + "&expire=19000000000&signature=A47A1E13E7243BD567601A75F79B34644D0DC592."
-        + "B09589A34FA23527EFC1552907754BB8033870BD&key=ik0", DemoUtil.TYPE_DASH, true, true),
+        + "B09589A34FA23527EFC1552907754BB8033870BD&key=ik0", DemoUtil.TYPE_DASH),
     new Sample("WV: Secure video path required", "0894c7c8719b28a0",
         "http://www.youtube.com/api/manifest/dash/id/0894c7c8719b28a0/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0"
         + "&expire=19000000000&signature=2847EE498970F6B45176766CD2802FEB4D4CB7B2."
-        + "A1CA51EC40A1C1039BA800C41500DD448C03EEDA&key=ik0", DemoUtil.TYPE_DASH, true, true),
+        + "A1CA51EC40A1C1039BA800C41500DD448C03EEDA&key=ik0", DemoUtil.TYPE_DASH),
     new Sample("WV: HDCP + secure video path required", "efd045b1eb61888a",
         "http://www.youtube.com/api/manifest/dash/id/efd045b1eb61888a/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0"
         + "&expire=19000000000&signature=61611F115EEEC7BADE5536827343FFFE2D83D14F."
-        + "2FDF4BFA502FB5865C5C86401314BDDEA4799BD0&key=ik0", DemoUtil.TYPE_DASH, true, true),
+        + "2FDF4BFA502FB5865C5C86401314BDDEA4799BD0&key=ik0", DemoUtil.TYPE_DASH),
     new Sample("WV: 30s license duration", "f9a34cab7b05881a",
         "http://www.youtube.com/api/manifest/dash/id/f9a34cab7b05881a/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,as&ip=0.0.0.0&ipbits=0"
         + "&expire=19000000000&signature=88DC53943385CED8CF9F37ADD9E9843E3BF621E6."
-        + "22727BB612D24AA4FACE4EF62726F9461A9BF57A&key=ik0", DemoUtil.TYPE_DASH, true, true),
+        + "22727BB612D24AA4FACE4EF62726F9461A9BF57A&key=ik0", DemoUtil.TYPE_DASH),
+  };
+
+  public static final Sample[] HLS = new Sample[] {
+    new Sample("Apple master playlist",
+        "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/"
+        + "bipbop_4x3_variant.m3u8", DemoUtil.TYPE_HLS),
+    new Sample("Apple master playlist advanced",
+        "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_16x9/"
+        + "bipbop_16x9_variant.m3u8", DemoUtil.TYPE_HLS),
+    new Sample("Apple single media playlist",
+        "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/"
+        + "prog_index.m3u8", DemoUtil.TYPE_HLS),
   };
 
   public static final Sample[] MISC = new Sample[] {
-    new Sample("Dizzy", "uid:misc:dizzy", "http://html5demos.com/assets/dizzy.mp4",
-        DemoUtil.TYPE_OTHER, false, true),
-    new Sample("Dizzy (https->http redirect)", "uid:misc:dizzy2", "https://goo.gl/MtUDEj",
-        DemoUtil.TYPE_OTHER, false, true),
-    new Sample("Apple AAC 10s", "uid:misc:appleaacseg", "https://devimages.apple.com.edgekey.net/"
+    new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4",
+        DemoUtil.TYPE_OTHER),
+    new Sample("Dizzy (https->http redirect)", "https://goo.gl/MtUDEj",
+        DemoUtil.TYPE_OTHER),
+    new Sample("Apple AAC 10s", "https://devimages.apple.com.edgekey.net/"
         + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac",
-        DemoUtil.TYPE_OTHER, false, true),
+        DemoUtil.TYPE_OTHER),
   };
 
   private Samples() {}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/SmoothStreamingTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
similarity index 95%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/SmoothStreamingTestMediaDrmCallback.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
index b193860423..ace3f1ee08 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/SmoothStreamingTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full;
+package com.google.android.exoplayer.demo;
 
-import com.google.android.exoplayer.demo.DemoUtil;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/WidevineTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
similarity index 95%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/WidevineTestMediaDrmCallback.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
index f2425589db..378c74c202 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/WidevineTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full;
+package com.google.android.exoplayer.demo;
 
-import com.google.android.exoplayer.demo.DemoUtil;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 
 import android.annotation.TargetApi;
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DashRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
similarity index 66%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/player/DashRendererBuilder.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
index 8ffd60218a..3f14a58bdb 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DashRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
@@ -13,15 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full.player;
+package com.google.android.exoplayer.demo.player;
 
+import com.google.android.exoplayer.Ac3PassthroughAudioTrackRenderer;
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecUtil;
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.audio.AudioCapabilities;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.ChunkSource;
 import com.google.android.exoplayer.chunk.Format;
@@ -35,12 +38,13 @@
 import com.google.android.exoplayer.dash.mpd.Period;
 import com.google.android.exoplayer.dash.mpd.Representation;
 import com.google.android.exoplayer.demo.DemoUtil;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilderCallback;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer.text.TextTrackRenderer;
+import com.google.android.exoplayer.text.ttml.TtmlParser;
 import com.google.android.exoplayer.text.webvtt.WebvttParser;
 import com.google.android.exoplayer.upstream.BufferPool;
 import com.google.android.exoplayer.upstream.DataSource;
@@ -78,23 +82,28 @@
   private static final int SECURITY_LEVEL_1 = 1;
   private static final int SECURITY_LEVEL_3 = 3;
 
+  private static final String AC_3_CODEC = "ac-3";
+  private static final String E_AC_3_CODEC = "ec-3";
+
   private final String userAgent;
   private final String url;
   private final String contentId;
   private final MediaDrmCallback drmCallback;
   private final TextView debugTextView;
+  private final AudioCapabilities audioCapabilities;
 
   private DemoPlayer player;
   private RendererBuilderCallback callback;
   private ManifestFetcher<MediaPresentationDescription> manifestFetcher;
 
   public DashRendererBuilder(String userAgent, String url, String contentId,
-      MediaDrmCallback drmCallback, TextView debugTextView) {
+      MediaDrmCallback drmCallback, TextView debugTextView, AudioCapabilities audioCapabilities) {
     this.userAgent = userAgent;
     this.url = url;
     this.contentId = contentId;
     this.drmCallback = drmCallback;
     this.debugTextView = debugTextView;
+    this.audioCapabilities = audioCapabilities;
   }
 
   @Override
@@ -119,17 +128,33 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
     LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
 
+    boolean hasContentProtection = false;
     int videoAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_VIDEO);
-    AdaptationSet videoAdaptationSet = period.adaptationSets.get(videoAdaptationSetIndex);
+    int audioAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_AUDIO);
+    AdaptationSet videoAdaptationSet = null;
+    AdaptationSet audioAdaptationSet = null;
+    if (videoAdaptationSetIndex != -1) {
+      videoAdaptationSet = period.adaptationSets.get(videoAdaptationSetIndex);
+      hasContentProtection |= videoAdaptationSet.hasContentProtection();
+    }
+    if (audioAdaptationSetIndex != -1) {
+      audioAdaptationSet = period.adaptationSets.get(audioAdaptationSetIndex);
+      hasContentProtection |= audioAdaptationSet.hasContentProtection();
+    }
+
+    // Fail if we have neither video or audio.
+    if (videoAdaptationSet == null && audioAdaptationSet == null) {
+      callback.onRenderersError(new IllegalStateException("No video or audio adaptation sets"));
+      return;
+    }
 
     // Check drm support if necessary.
-    boolean hasContentProtection = videoAdaptationSet.hasContentProtection();
     boolean filterHdContent = false;
     DrmSessionManager drmSessionManager = null;
     if (hasContentProtection) {
       if (Util.SDK_INT < 18) {
-        callback.onRenderersError(new UnsupportedOperationException(
-            "Protected content not supported on API level " + Util.SDK_INT));
+        callback.onRenderersError(
+            new UnsupportedDrmException(UnsupportedDrmException.REASON_NO_DRM));
         return;
       }
       try {
@@ -137,28 +162,37 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
             V18Compat.getDrmSessionManagerData(player, drmCallback);
         drmSessionManager = drmSessionManagerData.first;
         // HD streams require L1 security.
-        filterHdContent = !drmSessionManagerData.second;
-      } catch (Exception e) {
+        filterHdContent = videoAdaptationSet != null && videoAdaptationSet.hasContentProtection()
+            && !drmSessionManagerData.second;
+      } catch (UnsupportedDrmException e) {
         callback.onRenderersError(e);
         return;
       }
     }
 
     // Determine which video representations we should use for playback.
-    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
-    List<Representation> videoRepresentations = videoAdaptationSet.representations;
     ArrayList<Integer> videoRepresentationIndexList = new ArrayList<Integer>();
-    for (int i = 0; i < videoRepresentations.size(); i++) {
-      Format format = videoRepresentations.get(i).format;
-      if (filterHdContent && (format.width >= 1280 || format.height >= 720)) {
-        // Filtering HD content
-      } else if (format.width * format.height > maxDecodableFrameSize) {
-        // Filtering stream that device cannot play
-      } else if (!format.mimeType.equals(MimeTypes.VIDEO_MP4)
-          && !format.mimeType.equals(MimeTypes.VIDEO_WEBM)) {
-        // Filtering unsupported mime type
-      } else {
-        videoRepresentationIndexList.add(i);
+    if (videoAdaptationSet != null) {
+      int maxDecodableFrameSize;
+      try {
+        maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
+      } catch (DecoderQueryException e) {
+        callback.onRenderersError(e);
+        return;
+      }
+      List<Representation> videoRepresentations = videoAdaptationSet.representations;
+      for (int i = 0; i < videoRepresentations.size(); i++) {
+        Format format = videoRepresentations.get(i).format;
+        if (filterHdContent && (format.width >= 1280 || format.height >= 720)) {
+          // Filtering HD content
+        } else if (format.width * format.height > maxDecodableFrameSize) {
+          // Filtering stream that device cannot play
+        } else if (!format.mimeType.equals(MimeTypes.VIDEO_MP4)
+            && !format.mimeType.equals(MimeTypes.VIDEO_WEBM)) {
+          // Filtering unsupported mime type
+        } else {
+          videoRepresentationIndexList.add(i);
+        }
       }
     }
 
@@ -184,19 +218,31 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
     }
 
     // Build the audio chunk sources.
-    int audioAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_AUDIO);
-    AdaptationSet audioAdaptationSet = period.adaptationSets.get(audioAdaptationSetIndex);
-    DataSource audioDataSource = new UriDataSource(userAgent, bandwidthMeter);
-    FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
+    boolean haveAc3Tracks = false;
     List<ChunkSource> audioChunkSourceList = new ArrayList<ChunkSource>();
     List<String> audioTrackNameList = new ArrayList<String>();
-    List<Representation> audioRepresentations = audioAdaptationSet.representations;
-    for (int i = 0; i < audioRepresentations.size(); i++) {
-      Format format = audioRepresentations.get(i).format;
-      audioTrackNameList.add(format.id + " (" + format.numChannels + "ch, " +
-          format.audioSamplingRate + "Hz)");
-      audioChunkSourceList.add(new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
-          new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS));
+    if (audioAdaptationSet != null) {
+      DataSource audioDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
+      List<Representation> audioRepresentations = audioAdaptationSet.representations;
+      for (int i = 0; i < audioRepresentations.size(); i++) {
+        Format format = audioRepresentations.get(i).format;
+        audioTrackNameList.add(format.id + " (" + format.numChannels + "ch, " +
+            format.audioSamplingRate + "Hz)");
+        audioChunkSourceList.add(new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
+            new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS));
+        haveAc3Tracks |= AC_3_CODEC.equals(format.codecs) || E_AC_3_CODEC.equals(format.codecs);
+      }
+      // Filter out non-AC-3 tracks if there is an AC-3 track, to avoid having to switch renderers.
+      if (haveAc3Tracks) {
+        for (int i = audioRepresentations.size() - 1; i >= 0; i--) {
+          Format format = audioRepresentations.get(i).format;
+          if (!AC_3_CODEC.equals(format.codecs) && !E_AC_3_CODEC.equals(format.codecs)) {
+            audioTrackNameList.remove(i);
+            audioChunkSourceList.remove(i);
+          }
+        }
+      }
     }
 
     // Build the audio renderer.
@@ -214,8 +260,16 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
       SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
           AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
           DemoPlayer.TYPE_AUDIO);
-      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,
-          mainHandler, player);
+      // TODO: There needs to be some logic to filter out non-AC3 tracks when selecting to use AC3.
+      boolean useAc3Passthrough = haveAc3Tracks && audioCapabilities != null
+          && (audioCapabilities.supportsAc3() || audioCapabilities.supportsEAc3());
+      if (useAc3Passthrough) {
+        audioRenderer =
+            new Ac3PassthroughAudioTrackRenderer(audioSampleSource, mainHandler, player);
+      } else {
+        audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,
+            mainHandler, player);
+      }
     }
 
     // Build the text chunk sources.
@@ -251,8 +305,8 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
       SampleSource textSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
           TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
           DemoPlayer.TYPE_TEXT);
-      textRenderer = new TextTrackRenderer(textSampleSource, new WebvttParser(), player,
-          mainHandler.getLooper());
+      textRenderer = new TextTrackRenderer(textSampleSource, player, mainHandler.getLooper(),
+          new TtmlParser(), new WebvttParser());
     }
 
     // Invoke the callback.
@@ -277,12 +331,18 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
   private static class V18Compat {
 
     public static Pair<DrmSessionManager, Boolean> getDrmSessionManagerData(DemoPlayer player,
-        MediaDrmCallback drmCallback) throws UnsupportedSchemeException {
-      StreamingDrmSessionManager streamingDrmSessionManager = new StreamingDrmSessionManager(
-          DemoUtil.WIDEVINE_UUID, player.getPlaybackLooper(), drmCallback, null,
-          player.getMainHandler(), player);
-      return Pair.create((DrmSessionManager) streamingDrmSessionManager,
-          getWidevineSecurityLevel(streamingDrmSessionManager) == SECURITY_LEVEL_1);
+        MediaDrmCallback drmCallback) throws UnsupportedDrmException {
+      try {
+        StreamingDrmSessionManager streamingDrmSessionManager = new StreamingDrmSessionManager(
+            DemoUtil.WIDEVINE_UUID, player.getPlaybackLooper(), drmCallback, null,
+            player.getMainHandler(), player);
+        return Pair.create((DrmSessionManager) streamingDrmSessionManager,
+            getWidevineSecurityLevel(streamingDrmSessionManager) == SECURITY_LEVEL_1);
+      } catch (UnsupportedSchemeException e) {
+        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME);
+      } catch (Exception e) {
+        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNKNOWN, e);
+      }
     }
 
     private static int getWidevineSecurityLevel(StreamingDrmSessionManager sessionManager) {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DebugTrackRenderer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
similarity index 96%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/player/DebugTrackRenderer.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
index d848dd3908..c0b9d50417 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DebugTrackRenderer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full.player;
+package com.google.android.exoplayer.demo.player;
 
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.MediaCodecTrackRenderer;
@@ -82,8 +82,8 @@ public void run() {
   }
 
   private String getRenderString() {
-    return "ms(" + (currentPositionUs / 1000) + "), " + getQualityString() +
-        ", " + renderer.codecCounters.getDebugString();
+    return "ms(" + (currentPositionUs / 1000) + "), " + getQualityString()
+        + ", " + renderer.codecCounters.getDebugString();
   }
 
   private String getQualityString() {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DefaultRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DefaultRendererBuilder.java
similarity index 83%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/player/DefaultRendererBuilder.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/player/DefaultRendererBuilder.java
index 4aea8e642e..36c2e58879 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DefaultRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DefaultRendererBuilder.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full.player;
+package com.google.android.exoplayer.demo.player;
 
-import com.google.android.exoplayer.FrameworkSampleSource;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilderCallback;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
+import com.google.android.exoplayer.source.DefaultSampleSource;
+import com.google.android.exoplayer.source.FrameworkSampleExtractor;
 
 import android.content.Context;
 import android.media.MediaCodec;
@@ -46,7 +47,8 @@ public DefaultRendererBuilder(Context context, Uri uri, TextView debugTextView)
   @Override
   public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
     // Build the video and audio renderers.
-    FrameworkSampleSource sampleSource = new FrameworkSampleSource(context, uri, null, 2);
+    DefaultSampleSource sampleSource =
+        new DefaultSampleSource(new FrameworkSampleExtractor(context, uri, null), 2);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
         null, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, player.getMainHandler(),
         player, 50);
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
similarity index 87%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/player/DemoPlayer.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index dfa900d18d..338ec5b1db 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full.player;
+package com.google.android.exoplayer.demo.player;
 
+import com.google.android.exoplayer.Ac3PassthroughAudioTrackRenderer;
 import com.google.android.exoplayer.DummyTrackRenderer;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
@@ -26,7 +27,8 @@
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
-import com.google.android.exoplayer.text.TextTrackRenderer;
+import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
+import com.google.android.exoplayer.text.TextRenderer;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer.util.PlayerControl;
 
@@ -36,6 +38,7 @@
 import android.view.Surface;
 
 import java.io.IOException;
+import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
@@ -45,8 +48,8 @@
  */
 public class DemoPlayer implements ExoPlayer.Listener, ChunkSampleSource.EventListener,
     DefaultBandwidthMeter.EventListener, MediaCodecVideoTrackRenderer.EventListener,
-    MediaCodecAudioTrackRenderer.EventListener, TextTrackRenderer.TextRenderer,
-    StreamingDrmSessionManager.EventListener {
+    MediaCodecAudioTrackRenderer.EventListener, Ac3PassthroughAudioTrackRenderer.EventListener,
+    TextRenderer, StreamingDrmSessionManager.EventListener {
 
   /**
    * Builds renderers for the player.
@@ -107,6 +110,7 @@ void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSource
   public interface InternalErrorListener {
     void onRendererInitializationError(Exception e);
     void onAudioTrackInitializationError(AudioTrack.InitializationException e);
+    void onAudioTrackWriteError(AudioTrack.WriteException e);
     void onDecoderInitializationError(DecoderInitializationException e);
     void onCryptoError(CryptoException e);
     void onUpstreamError(int sourceId, IOException e);
@@ -134,6 +138,13 @@ void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitial
     void onText(String text);
   }
 
+  /**
+   * A listener for receiving ID3 metadata parsed from the media stream.
+   */
+  public interface Id3MetadataListener {
+    void onId3Metadata(Map<String, Object> metadata);
+  }
+
   // Constants pulled into this class for convenience.
   public static final int STATE_IDLE = ExoPlayer.STATE_IDLE;
   public static final int STATE_PREPARING = ExoPlayer.STATE_PREPARING;
@@ -144,11 +155,12 @@ void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitial
   public static final int DISABLED_TRACK = -1;
   public static final int PRIMARY_TRACK = 0;
 
-  public static final int RENDERER_COUNT = 4;
+  public static final int RENDERER_COUNT = 5;
   public static final int TYPE_VIDEO = 0;
   public static final int TYPE_AUDIO = 1;
   public static final int TYPE_TEXT = 2;
-  public static final int TYPE_DEBUG = 3;
+  public static final int TYPE_TIMED_METADATA = 3;
+  public static final int TYPE_DEBUG = 4;
 
   private static final int RENDERER_BUILDING_STATE_IDLE = 1;
   private static final int RENDERER_BUILDING_STATE_BUILDING = 2;
@@ -167,12 +179,15 @@ void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitial
   private Surface surface;
   private InternalRendererBuilderCallback builderCallback;
   private TrackRenderer videoRenderer;
+  private int videoTrackToRestore;
 
   private MultiTrackChunkSource[] multiTrackSources;
   private String[][] trackNames;
   private int[] selectedTracks;
+  private boolean backgrounded;
 
   private TextListener textListener;
+  private Id3MetadataListener id3MetadataListener;
   private InternalErrorListener internalErrorListener;
   private InfoListener infoListener;
 
@@ -214,9 +229,13 @@ public void setTextListener(TextListener listener) {
     textListener = listener;
   }
 
+  public void setMetadataListener(Id3MetadataListener listener) {
+    id3MetadataListener = listener;
+  }
+
   public void setSurface(Surface surface) {
     this.surface = surface;
-    pushSurfaceAndVideoTrack(false);
+    pushSurface(false);
   }
 
   public Surface getSurface() {
@@ -225,7 +244,7 @@ public Surface getSurface() {
 
   public void blockingClearSurface() {
     surface = null;
-    pushSurfaceAndVideoTrack(true);
+    pushSurface(true);
   }
 
   public String[] getTracks(int type) {
@@ -241,10 +260,23 @@ public void selectTrack(int type, int index) {
       return;
     }
     selectedTracks[type] = index;
-    if (type == TYPE_VIDEO) {
-      pushSurfaceAndVideoTrack(false);
+    pushTrackSelection(type, true);
+    if (type == TYPE_TEXT && index == DISABLED_TRACK && textListener != null) {
+      textListener.onText(null);
+    }
+  }
+
+  public void setBackgrounded(boolean backgrounded) {
+    if (this.backgrounded == backgrounded) {
+      return;
+    }
+    this.backgrounded = backgrounded;
+    if (backgrounded) {
+      videoTrackToRestore = getSelectedTrackIndex(TYPE_VIDEO);
+      selectTrack(TYPE_VIDEO, DISABLED_TRACK);
+      blockingClearSurface();
     } else {
-      pushTrackSelection(type, true);
+      selectTrack(TYPE_VIDEO, videoTrackToRestore);
     }
   }
 
@@ -287,7 +319,8 @@ public void prepare() {
     this.trackNames = trackNames;
     this.multiTrackSources = multiTrackSources;
     rendererBuildingState = RENDERER_BUILDING_STATE_BUILT;
-    pushSurfaceAndVideoTrack(false);
+    pushSurface(false);
+    pushTrackSelection(TYPE_VIDEO, true);
     pushTrackSelection(TYPE_AUDIO, true);
     pushTrackSelection(TYPE_TEXT, true);
     player.prepare(renderers);
@@ -430,6 +463,13 @@ public void onAudioTrackInitializationError(AudioTrack.InitializationException e
     }
   }
 
+  @Override
+  public void onAudioTrackWriteError(AudioTrack.WriteException e) {
+    if (internalErrorListener != null) {
+      internalErrorListener.onAudioTrackWriteError(e);
+    }
+  }
+
   @Override
   public void onCryptoError(CryptoException e) {
     if (internalErrorListener != null) {
@@ -453,9 +493,19 @@ public void onConsumptionError(int sourceId, IOException e) {
 
   @Override
   public void onText(String text) {
-    if (textListener != null) {
-      textListener.onText(text);
-    }
+    processText(text);
+  }
+
+  /* package */ MetadataTrackRenderer.MetadataRenderer<Map<String, Object>>
+      getId3MetadataRenderer() {
+    return new MetadataTrackRenderer.MetadataRenderer<Map<String, Object>>() {
+      @Override
+      public void onMetadata(Map<String, Object> metadata) {
+        if (id3MetadataListener != null) {
+          id3MetadataListener.onId3Metadata(metadata);
+        }
+      }
+    };
   }
 
   @Override
@@ -513,7 +563,7 @@ private void maybeReportPlayerState() {
     }
   }
 
-  private void pushSurfaceAndVideoTrack(boolean blockForSurfacePush) {
+  private void pushSurface(boolean blockForSurfacePush) {
     if (rendererBuildingState != RENDERER_BUILDING_STATE_BUILT) {
       return;
     }
@@ -525,7 +575,6 @@ private void pushSurfaceAndVideoTrack(boolean blockForSurfacePush) {
       player.sendMessage(
           videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
     }
-    pushTrackSelection(TYPE_VIDEO, surface != null && surface.isValid());
   }
 
   private void pushTrackSelection(int type, boolean allowRendererEnable) {
@@ -549,6 +598,13 @@ private void pushTrackSelection(int type, boolean allowRendererEnable) {
     }
   }
 
+  /* package */ void processText(String text) {
+    if (textListener == null || selectedTracks[TYPE_TEXT] == DISABLED_TRACK) {
+      return;
+    }
+    textListener.onText(text);
+  }
+
   private class InternalRendererBuilderCallback implements RendererBuilderCallback {
 
     private boolean canceled;
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
new file mode 100644
index 0000000000..326a0689d5
--- /dev/null
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.demo.player;
+
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
+import com.google.android.exoplayer.hls.HlsChunkSource;
+import com.google.android.exoplayer.hls.HlsPlaylist;
+import com.google.android.exoplayer.hls.HlsPlaylistParser;
+import com.google.android.exoplayer.hls.HlsSampleSource;
+import com.google.android.exoplayer.metadata.Id3Parser;
+import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
+import com.google.android.exoplayer.text.eia608.Eia608TrackRenderer;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer.upstream.UriDataSource;
+import com.google.android.exoplayer.util.ManifestFetcher;
+import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
+
+import android.media.MediaCodec;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * A {@link RendererBuilder} for HLS.
+ */
+public class HlsRendererBuilder implements RendererBuilder, ManifestCallback<HlsPlaylist> {
+
+  private final String userAgent;
+  private final String url;
+  private final String contentId;
+
+  private DemoPlayer player;
+  private RendererBuilderCallback callback;
+
+  public HlsRendererBuilder(String userAgent, String url, String contentId) {
+    this.userAgent = userAgent;
+    this.url = url;
+    this.contentId = contentId;
+  }
+
+  @Override
+  public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
+    this.player = player;
+    this.callback = callback;
+    HlsPlaylistParser parser = new HlsPlaylistParser();
+    ManifestFetcher<HlsPlaylist> playlistFetcher =
+        new ManifestFetcher<HlsPlaylist>(parser, contentId, url, userAgent);
+    playlistFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+  }
+
+  @Override
+  public void onManifestError(String contentId, IOException e) {
+    callback.onRenderersError(e);
+  }
+
+  @Override
+  public void onManifest(String contentId, HlsPlaylist manifest) {
+    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+
+    DataSource dataSource = new UriDataSource(userAgent, bandwidthMeter);
+    HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter, null,
+        HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+    HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, true, 3);
+    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
+        MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, player.getMainHandler(), player, 50);
+    MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
+
+    MetadataTrackRenderer<Map<String, Object>> id3Renderer =
+        new MetadataTrackRenderer<Map<String, Object>>(sampleSource, new Id3Parser(),
+            player.getId3MetadataRenderer(), player.getMainHandler().getLooper());
+
+    Eia608TrackRenderer closedCaptionRenderer = new Eia608TrackRenderer(sampleSource, player,
+        player.getMainHandler().getLooper());
+
+    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
+    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
+    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
+    renderers[DemoPlayer.TYPE_TIMED_METADATA] = id3Renderer;
+    renderers[DemoPlayer.TYPE_TEXT] = closedCaptionRenderer;
+    callback.onRenderers(null, null, renderers);
+  }
+
+}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/SmoothStreamingRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
similarity index 81%
rename from demo/src/main/java/com/google/android/exoplayer/demo/full/player/SmoothStreamingRendererBuilder.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
index fd9c220cb2..22a342bfc7 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/full/player/SmoothStreamingRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.full.player;
+package com.google.android.exoplayer.demo.player;
 
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecUtil;
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
@@ -26,8 +27,8 @@
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.full.player.DemoPlayer.RendererBuilderCallback;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
@@ -111,21 +112,27 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
     DrmSessionManager drmSessionManager = null;
     if (manifest.protectionElement != null) {
       if (Util.SDK_INT < 18) {
-        callback.onRenderersError(new UnsupportedOperationException(
-            "Protected content not supported on API level " + Util.SDK_INT));
+        callback.onRenderersError(
+            new UnsupportedDrmException(UnsupportedDrmException.REASON_NO_DRM));
         return;
       }
       try {
         drmSessionManager = V18Compat.getDrmSessionManager(manifest.protectionElement.uuid, player,
             drmCallback);
-      } catch (Exception e) {
+      } catch (UnsupportedDrmException e) {
         callback.onRenderersError(e);
         return;
       }
     }
 
     // Obtain stream elements for playback.
-    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
+    int maxDecodableFrameSize;
+    try {
+      maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
+    } catch (DecoderQueryException e) {
+      callback.onRenderersError(e);
+      return;
+    }
     int audioStreamElementCount = 0;
     int textStreamElementCount = 0;
     int videoStreamElementIndex = -1;
@@ -149,19 +156,28 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
         }
       }
     }
-    int[] videoTrackIndices = Util.toArray(videoTrackIndexList);
 
     // Build the video renderer.
-    DataSource videoDataSource = new UriDataSource(userAgent, bandwidthMeter);
-    ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-        videoStreamElementIndex, videoTrackIndices, videoDataSource,
-        new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
-    ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-        VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-        DemoPlayer.TYPE_VIDEO);
-    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,
-        drmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null,
-        mainHandler, player, 50);
+    final MediaCodecVideoTrackRenderer videoRenderer;
+    final TrackRenderer debugRenderer;
+    if (videoTrackIndexList.isEmpty()) {
+      videoRenderer = null;
+      debugRenderer = null;
+    } else {
+      int[] videoTrackIndices = Util.toArray(videoTrackIndexList);
+      DataSource videoDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
+          videoStreamElementIndex, videoTrackIndices, videoDataSource,
+          new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
+      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
+          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
+          DemoPlayer.TYPE_VIDEO);
+      videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
+          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
+      debugRenderer = debugTextView != null
+          ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource)
+          : null;
+    }
 
     // Build the audio renderer.
     final String[] audioTrackNames;
@@ -220,15 +236,10 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
       ChunkSampleSource ttmlSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
           TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
           DemoPlayer.TYPE_TEXT);
-      textRenderer = new TextTrackRenderer(ttmlSampleSource, new TtmlParser(), player,
-          mainHandler.getLooper());
+      textRenderer = new TextTrackRenderer(ttmlSampleSource, player, mainHandler.getLooper(),
+          new TtmlParser());
     }
 
-    // Build the debug renderer.
-    TrackRenderer debugRenderer = debugTextView != null
-        ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource)
-        : null;
-
     // Invoke the callback.
     String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];
     trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;
@@ -251,9 +262,15 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
   private static class V18Compat {
 
     public static DrmSessionManager getDrmSessionManager(UUID uuid, DemoPlayer player,
-        MediaDrmCallback drmCallback) throws UnsupportedSchemeException {
-      return new StreamingDrmSessionManager(uuid, player.getPlaybackLooper(), drmCallback, null,
-          player.getMainHandler(), player);
+        MediaDrmCallback drmCallback) throws UnsupportedDrmException {
+      try {
+        return new StreamingDrmSessionManager(uuid, player.getPlaybackLooper(), drmCallback, null,
+            player.getMainHandler(), player);
+      } catch (UnsupportedSchemeException e) {
+        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME);
+      } catch (Exception e) {
+        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNKNOWN, e);
+      }
     }
 
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/UnsupportedDrmException.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/UnsupportedDrmException.java
new file mode 100644
index 0000000000..e71e1b04d3
--- /dev/null
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/UnsupportedDrmException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.demo.player;
+
+/**
+ * Exception thrown when the required level of DRM is not supported.
+ */
+public final class UnsupportedDrmException extends Exception {
+
+  public static final int REASON_NO_DRM = 0;
+  public static final int REASON_UNSUPPORTED_SCHEME = 1;
+  public static final int REASON_UNKNOWN = 2;
+
+  public final int reason;
+
+  public UnsupportedDrmException(int reason) {
+    this.reason = reason;
+  }
+
+  public UnsupportedDrmException(int reason, Exception cause) {
+    super(cause);
+    this.reason = reason;
+  }
+
+}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/simple/DashRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/simple/DashRendererBuilder.java
deleted file mode 100644
index 46923c6b74..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer/demo/simple/DashRendererBuilder.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo.simple;
-
-import com.google.android.exoplayer.DefaultLoadControl;
-import com.google.android.exoplayer.LoadControl;
-import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecUtil;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
-import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.chunk.ChunkSampleSource;
-import com.google.android.exoplayer.chunk.ChunkSource;
-import com.google.android.exoplayer.chunk.Format;
-import com.google.android.exoplayer.chunk.FormatEvaluator;
-import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
-import com.google.android.exoplayer.dash.DashChunkSource;
-import com.google.android.exoplayer.dash.mpd.AdaptationSet;
-import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
-import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
-import com.google.android.exoplayer.dash.mpd.Period;
-import com.google.android.exoplayer.dash.mpd.Representation;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity.RendererBuilder;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity.RendererBuilderCallback;
-import com.google.android.exoplayer.upstream.BufferPool;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer.upstream.UriDataSource;
-import com.google.android.exoplayer.util.ManifestFetcher;
-import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
-import com.google.android.exoplayer.util.MimeTypes;
-import com.google.android.exoplayer.util.Util;
-
-import android.media.MediaCodec;
-import android.os.Handler;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * A {@link RendererBuilder} for DASH.
- */
-/* package */ class DashRendererBuilder implements RendererBuilder,
-    ManifestCallback<MediaPresentationDescription> {
-
-  private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
-  private static final int VIDEO_BUFFER_SEGMENTS = 200;
-  private static final int AUDIO_BUFFER_SEGMENTS = 60;
-  private static final int LIVE_EDGE_LATENCY_MS = 30000;
-
-  private final SimplePlayerActivity playerActivity;
-  private final String userAgent;
-  private final String url;
-  private final String contentId;
-
-  private RendererBuilderCallback callback;
-  private ManifestFetcher<MediaPresentationDescription> manifestFetcher;
-
-  public DashRendererBuilder(SimplePlayerActivity playerActivity, String userAgent, String url,
-      String contentId) {
-    this.playerActivity = playerActivity;
-    this.userAgent = userAgent;
-    this.url = url;
-    this.contentId = contentId;
-  }
-
-  @Override
-  public void buildRenderers(RendererBuilderCallback callback) {
-    this.callback = callback;
-    MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
-    manifestFetcher = new ManifestFetcher<MediaPresentationDescription>(parser, contentId, url,
-        userAgent);
-    manifestFetcher.singleLoad(playerActivity.getMainLooper(), this);
-  }
-
-  @Override
-  public void onManifestError(String contentId, IOException e) {
-    callback.onRenderersError(e);
-  }
-
-  @Override
-  public void onManifest(String contentId, MediaPresentationDescription manifest) {
-    Period period = manifest.periods.get(0);
-    Handler mainHandler = playerActivity.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
-
-    // Determine which video representations we should use for playback.
-    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
-    int videoAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_VIDEO);
-    List<Representation> videoRepresentations =
-        period.adaptationSets.get(videoAdaptationSetIndex).representations;
-    ArrayList<Integer> videoRepresentationIndexList = new ArrayList<Integer>();
-    for (int i = 0; i < videoRepresentations.size(); i++) {
-      Format format = videoRepresentations.get(i).format;
-      if (format.width * format.height > maxDecodableFrameSize) {
-        // Filtering stream that device cannot play
-      } else if (!format.mimeType.equals(MimeTypes.VIDEO_MP4)
-          && !format.mimeType.equals(MimeTypes.VIDEO_WEBM)) {
-        // Filtering unsupported mime type
-      } else {
-        videoRepresentationIndexList.add(i);
-      }
-    }
-
-    // Build the video renderer.
-    final MediaCodecVideoTrackRenderer videoRenderer;
-    if (videoRepresentationIndexList.isEmpty()) {
-      videoRenderer = null;
-    } else {
-      int[] videoRepresentationIndices = Util.toArray(videoRepresentationIndexList);
-      DataSource videoDataSource = new UriDataSource(userAgent, bandwidthMeter);
-      ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher, videoAdaptationSetIndex,
-          videoRepresentationIndices, videoDataSource, new AdaptiveEvaluator(bandwidthMeter),
-          LIVE_EDGE_LATENCY_MS);
-      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
-      videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 0, mainHandler, playerActivity, 50);
-    }
-
-    // Build the audio renderer.
-    int audioAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_AUDIO);
-    DataSource audioDataSource = new UriDataSource(userAgent, bandwidthMeter);
-    ChunkSource audioChunkSource = new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
-        new int[] {0}, audioDataSource, new FormatEvaluator.FixedEvaluator(), LIVE_EDGE_LATENCY_MS);
-    SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
-        AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
-    MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(
-        audioSampleSource);
-    callback.onRenderers(videoRenderer, audioRenderer);
-  }
-
-}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/simple/DefaultRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/simple/DefaultRendererBuilder.java
deleted file mode 100644
index aef46d38d9..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer/demo/simple/DefaultRendererBuilder.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo.simple;
-
-import com.google.android.exoplayer.FrameworkSampleSource;
-import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity.RendererBuilder;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity.RendererBuilderCallback;
-
-import android.media.MediaCodec;
-import android.net.Uri;
-
-/**
- * A {@link RendererBuilder} for streams that can be read using
- * {@link android.media.MediaExtractor}.
- */
-/* package */ class DefaultRendererBuilder implements RendererBuilder {
-
-  private final SimplePlayerActivity playerActivity;
-  private final Uri uri;
-
-  public DefaultRendererBuilder(SimplePlayerActivity playerActivity, Uri uri) {
-    this.playerActivity = playerActivity;
-    this.uri = uri;
-  }
-
-  @Override
-  public void buildRenderers(RendererBuilderCallback callback) {
-    // Build the video and audio renderers.
-    FrameworkSampleSource sampleSource = new FrameworkSampleSource(playerActivity, uri, null, 2);
-    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
-        MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 0, playerActivity.getMainHandler(),
-        playerActivity, 50);
-    MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
-
-    // Invoke the callback.
-    callback.onRenderers(videoRenderer, audioRenderer);
-  }
-
-}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java
deleted file mode 100644
index 8c47dea3c1..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo.simple;
-
-import com.google.android.exoplayer.ExoPlaybackException;
-import com.google.android.exoplayer.ExoPlayer;
-import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
-import com.google.android.exoplayer.VideoSurfaceView;
-import com.google.android.exoplayer.demo.DemoUtil;
-import com.google.android.exoplayer.demo.R;
-import com.google.android.exoplayer.util.PlayerControl;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.media.MediaCodec.CryptoException;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.Surface;
-import android.view.SurfaceHolder;
-import android.view.View;
-import android.view.View.OnTouchListener;
-import android.widget.MediaController;
-import android.widget.Toast;
-
-/**
- * An activity that plays media using {@link ExoPlayer}.
- */
-public class SimplePlayerActivity extends Activity implements SurfaceHolder.Callback,
-    ExoPlayer.Listener, MediaCodecVideoTrackRenderer.EventListener {
-
-  /**
-   * Builds renderers for the player.
-   */
-  public interface RendererBuilder {
-
-    void buildRenderers(RendererBuilderCallback callback);
-
-  }
-
-  public static final int RENDERER_COUNT = 2;
-  public static final int TYPE_VIDEO = 0;
-  public static final int TYPE_AUDIO = 1;
-
-  private static final String TAG = "PlayerActivity";
-
-  private MediaController mediaController;
-  private Handler mainHandler;
-  private View shutterView;
-  private VideoSurfaceView surfaceView;
-
-  private ExoPlayer player;
-  private RendererBuilder builder;
-  private RendererBuilderCallback callback;
-  private MediaCodecVideoTrackRenderer videoRenderer;
-
-  private boolean autoPlay = true;
-  private long playerPosition;
-
-  private Uri contentUri;
-  private int contentType;
-  private String contentId;
-
-  // Activity lifecycle
-
-  @Override
-  public void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    Intent intent = getIntent();
-    contentUri = intent.getData();
-    contentType = intent.getIntExtra(DemoUtil.CONTENT_TYPE_EXTRA, DemoUtil.TYPE_OTHER);
-    contentId = intent.getStringExtra(DemoUtil.CONTENT_ID_EXTRA);
-
-    mainHandler = new Handler(getMainLooper());
-    builder = getRendererBuilder();
-
-    setContentView(R.layout.player_activity_simple);
-    View root = findViewById(R.id.root);
-    root.setOnTouchListener(new OnTouchListener() {
-      @Override
-      public boolean onTouch(View arg0, MotionEvent arg1) {
-        if (arg1.getAction() == MotionEvent.ACTION_DOWN) {
-          toggleControlsVisibility();
-        }
-        return true;
-      }
-    });
-
-    mediaController = new MediaController(this);
-    mediaController.setAnchorView(root);
-    shutterView = findViewById(R.id.shutter);
-    surfaceView = (VideoSurfaceView) findViewById(R.id.surface_view);
-    surfaceView.getHolder().addCallback(this);
-
-    DemoUtil.setDefaultCookieManager();
-  }
-
-  @Override
-  public void onResume() {
-    super.onResume();
-    // Setup the player
-    player = ExoPlayer.Factory.newInstance(RENDERER_COUNT, 1000, 5000);
-    player.addListener(this);
-    player.seekTo(playerPosition);
-    // Build the player controls
-    mediaController.setMediaPlayer(new PlayerControl(player));
-    mediaController.setEnabled(true);
-    // Request the renderers
-    callback = new RendererBuilderCallback();
-    builder.buildRenderers(callback);
-  }
-
-  @Override
-  public void onPause() {
-    super.onPause();
-    // Release the player
-    if (player != null) {
-      playerPosition = player.getCurrentPosition();
-      player.release();
-      player = null;
-    }
-    callback = null;
-    videoRenderer = null;
-    shutterView.setVisibility(View.VISIBLE);
-  }
-
-  // Public methods
-
-  public Handler getMainHandler() {
-    return mainHandler;
-  }
-
-  // Internal methods
-
-  private void toggleControlsVisibility()  {
-    if (mediaController.isShowing()) {
-      mediaController.hide();
-    } else {
-      mediaController.show(0);
-    }
-  }
-
-  private RendererBuilder getRendererBuilder() {
-    String userAgent = DemoUtil.getUserAgent(this);
-    switch (contentType) {
-      case DemoUtil.TYPE_SS:
-        return new SmoothStreamingRendererBuilder(this, userAgent, contentUri.toString(),
-            contentId);
-      case DemoUtil.TYPE_DASH:
-        return new DashRendererBuilder(this, userAgent, contentUri.toString(), contentId);
-      default:
-        return new DefaultRendererBuilder(this, contentUri);
-    }
-  }
-
-  private void onRenderers(RendererBuilderCallback callback,
-      MediaCodecVideoTrackRenderer videoRenderer, MediaCodecAudioTrackRenderer audioRenderer) {
-    if (this.callback != callback) {
-      return;
-    }
-    this.callback = null;
-    this.videoRenderer = videoRenderer;
-    player.prepare(videoRenderer, audioRenderer);
-    maybeStartPlayback();
-  }
-
-  private void maybeStartPlayback() {
-    Surface surface = surfaceView.getHolder().getSurface();
-    if (videoRenderer == null || surface == null || !surface.isValid()) {
-      // We're not ready yet.
-      return;
-    }
-    player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
-    if (autoPlay) {
-      player.setPlayWhenReady(true);
-      autoPlay = false;
-    }
-  }
-
-  private void onRenderersError(RendererBuilderCallback callback, Exception e) {
-    if (this.callback != callback) {
-      return;
-    }
-    this.callback = null;
-    onError(e);
-  }
-
-  private void onError(Exception e) {
-    Log.e(TAG, "Playback failed", e);
-    Toast.makeText(this, R.string.failed, Toast.LENGTH_SHORT).show();
-    finish();
-  }
-
-  // ExoPlayer.Listener implementation
-
-  @Override
-  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPlayWhenReadyCommitted() {
-    // Do nothing.
-  }
-
-  @Override
-  public void onPlayerError(ExoPlaybackException e) {
-    onError(e);
-  }
-
-  // MediaCodecVideoTrackRenderer.Listener
-
-  @Override
-  public void onVideoSizeChanged(int width, int height, float pixelWidthHeightRatio) {
-    surfaceView.setVideoWidthHeightRatio(
-        height == 0 ? 1 : (pixelWidthHeightRatio * width) / height);
-  }
-
-  @Override
-  public void onDrawnToSurface(Surface surface) {
-    shutterView.setVisibility(View.GONE);
-  }
-
-  @Override
-  public void onDroppedFrames(int count, long elapsed) {
-    Log.d(TAG, "Dropped frames: " + count);
-  }
-
-  @Override
-  public void onDecoderInitializationError(DecoderInitializationException e) {
-    // This is for informational purposes only. Do nothing.
-  }
-
-  @Override
-  public void onCryptoError(CryptoException e) {
-    // This is for informational purposes only. Do nothing.
-  }
-
-  // SurfaceHolder.Callback implementation
-
-  @Override
-  public void surfaceCreated(SurfaceHolder holder) {
-    maybeStartPlayback();
-  }
-
-  @Override
-  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
-    // Do nothing.
-  }
-
-  @Override
-  public void surfaceDestroyed(SurfaceHolder holder) {
-    if (videoRenderer != null) {
-      player.blockingSendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, null);
-    }
-  }
-
-  /* package */ final class RendererBuilderCallback {
-
-    public void onRenderers(MediaCodecVideoTrackRenderer videoRenderer,
-        MediaCodecAudioTrackRenderer audioRenderer) {
-      SimplePlayerActivity.this.onRenderers(this, videoRenderer, audioRenderer);
-    }
-
-    public void onRenderersError(Exception e) {
-      SimplePlayerActivity.this.onRenderersError(this, e);
-    }
-
-  }
-
-}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/simple/SmoothStreamingRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/simple/SmoothStreamingRendererBuilder.java
deleted file mode 100644
index 90a06a6216..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer/demo/simple/SmoothStreamingRendererBuilder.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo.simple;
-
-import com.google.android.exoplayer.DefaultLoadControl;
-import com.google.android.exoplayer.LoadControl;
-import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecUtil;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
-import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.chunk.ChunkSampleSource;
-import com.google.android.exoplayer.chunk.ChunkSource;
-import com.google.android.exoplayer.chunk.FormatEvaluator;
-import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity.RendererBuilder;
-import com.google.android.exoplayer.demo.simple.SimplePlayerActivity.RendererBuilderCallback;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingChunkSource;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifestParser;
-import com.google.android.exoplayer.upstream.BufferPool;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer.upstream.UriDataSource;
-import com.google.android.exoplayer.util.ManifestFetcher;
-import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
-import com.google.android.exoplayer.util.Util;
-
-import android.media.MediaCodec;
-import android.os.Handler;
-
-import java.io.IOException;
-import java.util.ArrayList;
-
-/**
- * A {@link RendererBuilder} for SmoothStreaming.
- */
-/* package */ class SmoothStreamingRendererBuilder implements RendererBuilder,
-    ManifestCallback<SmoothStreamingManifest> {
-
-  private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
-  private static final int VIDEO_BUFFER_SEGMENTS = 200;
-  private static final int AUDIO_BUFFER_SEGMENTS = 60;
-  private static final int LIVE_EDGE_LATENCY_MS = 30000;
-
-  private final SimplePlayerActivity playerActivity;
-  private final String userAgent;
-  private final String url;
-  private final String contentId;
-
-  private RendererBuilderCallback callback;
-  private ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
-
-  public SmoothStreamingRendererBuilder(SimplePlayerActivity playerActivity, String userAgent,
-      String url, String contentId) {
-    this.playerActivity = playerActivity;
-    this.userAgent = userAgent;
-    this.url = url;
-    this.contentId = contentId;
-  }
-
-  @Override
-  public void buildRenderers(RendererBuilderCallback callback) {
-    this.callback = callback;
-    SmoothStreamingManifestParser parser = new SmoothStreamingManifestParser();
-    manifestFetcher = new ManifestFetcher<SmoothStreamingManifest>(parser, contentId,
-        url + "/Manifest", userAgent);
-    manifestFetcher.singleLoad(playerActivity.getMainLooper(), this);
-  }
-
-  @Override
-  public void onManifestError(String contentId, IOException e) {
-    callback.onRenderersError(e);
-  }
-
-  @Override
-  public void onManifest(String contentId, SmoothStreamingManifest manifest) {
-    Handler mainHandler = playerActivity.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
-
-    // Obtain stream elements for playback.
-    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
-    int audioStreamElementIndex = -1;
-    int videoStreamElementIndex = -1;
-    ArrayList<Integer> videoTrackIndexList = new ArrayList<Integer>();
-    for (int i = 0; i < manifest.streamElements.length; i++) {
-      if (audioStreamElementIndex == -1
-          && manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
-        audioStreamElementIndex = i;
-      } else if (videoStreamElementIndex == -1
-          && manifest.streamElements[i].type == StreamElement.TYPE_VIDEO) {
-        videoStreamElementIndex = i;
-        StreamElement streamElement = manifest.streamElements[i];
-        for (int j = 0; j < streamElement.tracks.length; j++) {
-          TrackElement trackElement = streamElement.tracks[j];
-          if (trackElement.maxWidth * trackElement.maxHeight <= maxDecodableFrameSize) {
-            videoTrackIndexList.add(j);
-          } else {
-            // The device isn't capable of playing this stream.
-          }
-        }
-      }
-    }
-    int[] videoTrackIndices = Util.toArray(videoTrackIndexList);
-
-    // Build the video renderer.
-    DataSource videoDataSource = new UriDataSource(userAgent, bandwidthMeter);
-    ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-        videoStreamElementIndex, videoTrackIndices, videoDataSource,
-        new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
-    ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-        VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
-    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,
-        MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 0, mainHandler, playerActivity, 50);
-
-    // Build the audio renderer.
-    DataSource audioDataSource = new UriDataSource(userAgent, bandwidthMeter);
-    ChunkSource audioChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-        audioStreamElementIndex, new int[] {0}, audioDataSource,
-        new FormatEvaluator.FixedEvaluator(), LIVE_EDGE_LATENCY_MS);
-    SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
-        AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
-    MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(
-        audioSampleSource);
-    callback.onRenderers(videoRenderer, audioRenderer);
-  }
-
-}
diff --git a/demo/src/main/res/drawable-hdpi/ic_launcher.png b/demo/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..3e5716b8ad
Binary files /dev/null and b/demo/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/drawable-mdpi/ic_launcher.png b/demo/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..a5d2a53b13
Binary files /dev/null and b/demo/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_launcher.png b/demo/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..1d00268635
Binary files /dev/null and b/demo/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..ef2f312fd4
Binary files /dev/null and b/demo/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..0acebb43c1
Binary files /dev/null and b/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/layout/player_activity_full.xml b/demo/src/main/res/layout/player_activity.xml
similarity index 95%
rename from demo/src/main/res/layout/player_activity_full.xml
rename to demo/src/main/res/layout/player_activity.xml
index d2e069620f..21fe68e5da 100644
--- a/demo/src/main/res/layout/player_activity_full.xml
+++ b/demo/src/main/res/layout/player_activity.xml
@@ -14,6 +14,7 @@
      limitations under the License.
 -->
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     android:id="@+id/root"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
@@ -49,14 +50,16 @@
         android:layout_height="wrap_content"
         android:paddingLeft="4dp"
         android:paddingRight="4dp"
-        android:textSize="10sp"/>
+        android:textSize="10sp"
+        tools:ignore="SmallSp"/>
 
     <TextView android:id="@+id/debug_text_view"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:paddingLeft="4dp"
         android:paddingRight="4dp"
-        android:textSize="10sp"/>
+        android:textSize="10sp"
+        tools:ignore="SmallSp"/>
 
     <LinearLayout android:id="@+id/controls_root"
         android:layout_width="match_parent"
diff --git a/demo/src/main/res/layout/player_activity_simple.xml b/demo/src/main/res/layout/player_activity_simple.xml
deleted file mode 100644
index 767f20439f..0000000000
--- a/demo/src/main/res/layout/player_activity_simple.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!-- Copyright (C) 2014 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/root"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:keepScreenOn="true">
-
-  <com.google.android.exoplayer.VideoSurfaceView android:id="@+id/surface_view"
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"
-      android:layout_gravity="center"/>
-
-  <View android:id="@+id/shutter"
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"
-      android:background="@android:color/black"/>
-
-</FrameLayout>
diff --git a/demo/src/main/res/values/strings.xml b/demo/src/main/res/values/strings.xml
index f71c2fb377..3b2b190a1b 100644
--- a/demo/src/main/res/values/strings.xml
+++ b/demo/src/main/res/values/strings.xml
@@ -39,7 +39,11 @@
 
   <string name="on">[on]</string>
 
-  <string name="drm_not_supported">Protected content not supported on API levels below 18</string>
+  <string name="drm_error_not_supported">Protected content not supported on API levels below 18</string>
+
+  <string name="drm_error_unsupported_scheme">This device does not support the required DRM scheme</string>
+
+  <string name="drm_error_unknown">An unknown DRM error occurred</string>
 
   <string name="failed">Playback failed</string>
 
diff --git a/demo_misc/README.md b/demo_misc/README.md
new file mode 100644
index 0000000000..f7d7af6ac4
--- /dev/null
+++ b/demo_misc/README.md
@@ -0,0 +1,7 @@
+# Miscellaneous demos #
+
+This folder contains miscellaneous demo applications. For example applications
+that demonstrate use of optional extensions, or more advanced features.
+
+A general purpose ExoPlayer demo application can be found in the [demo](../demo)
+folder.
diff --git a/extensions/README.md b/extensions/README.md
new file mode 100644
index 0000000000..5bb863c13e
--- /dev/null
+++ b/extensions/README.md
@@ -0,0 +1,3 @@
+# Extensions #
+
+This folder contains optional ExoPlayer extensions.
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index f710b0d7a7..6bf5e08c42 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer;
 
+import android.media.MediaExtractor;
+
 /**
  * Defines constants that are generally useful throughout the library.
  */
@@ -40,6 +42,12 @@
    */
   public static final String UTF8_NAME = "UTF-8";
 
+  /**
+   * Sample flag that indicates the sample is a synchronization sample.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int SAMPLE_FLAG_SYNC = MediaExtractor.SAMPLE_FLAG_SYNC;
+
   private C() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
index 22f11c13b7..3f5dc3cb0c 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
@@ -53,6 +53,7 @@
   @SuppressLint("HandlerLeak")
   public ExoPlayerImpl(int rendererCount, int minBufferMs, int minRebufferMs) {
     Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION);
+    this.playWhenReady = false;
     this.playbackState = STATE_IDLE;
     this.listeners = new CopyOnWriteArraySet<Listener>();
     this.rendererEnabledFlags = new boolean[rendererCount];
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index e72734e80a..96019112e7 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -375,10 +375,13 @@ private void stopRenderers() throws ExoPlaybackException {
   }
 
   private void updatePositionUs() {
-    positionUs = timeSourceTrackRenderer != null &&
-        enabledRenderers.contains(timeSourceTrackRenderer) ?
-        timeSourceTrackRenderer.getCurrentPositionUs() :
-        mediaClock.getPositionUs();
+    if (timeSourceTrackRenderer != null && enabledRenderers.contains(timeSourceTrackRenderer)
+        && !timeSourceTrackRenderer.isEnded()) {
+      positionUs = timeSourceTrackRenderer.getCurrentPositionUs();
+      mediaClock.setPositionUs(positionUs);
+    } else {
+      positionUs = mediaClock.getPositionUs();
+    }
     elapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 6fb7d20be8..67b902aff9 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -26,7 +26,7 @@ private ExoPlayerLibraryInfo() {}
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.1.0";
+  public static final String VERSION = "1.2.0";
 
   /**
    * The version of the library, expressed as an integer.
@@ -34,7 +34,7 @@ private ExoPlayerLibraryInfo() {}
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001001000;
+  public static final int VERSION_INT = 001002000;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
deleted file mode 100644
index 716ef7dafb..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer;
-
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.Util;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.media.MediaExtractor;
-import android.net.Uri;
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.UUID;
-
-/**
- * Extracts samples from a stream using Android's {@link MediaExtractor}.
- */
-// TODO: This implementation needs to be fixed so that its methods are non-blocking (either
-// through use of a background thread, or through changes to the framework's MediaExtractor API).
-@TargetApi(16)
-public final class FrameworkSampleSource implements SampleSource {
-
-  private static final int TRACK_STATE_DISABLED = 0;
-  private static final int TRACK_STATE_ENABLED = 1;
-  private static final int TRACK_STATE_FORMAT_SENT = 2;
-
-  private final Context context;
-  private final Uri uri;
-  private final Map<String, String> headers;
-
-  private MediaExtractor extractor;
-  private TrackInfo[] trackInfos;
-  private boolean prepared;
-  private int remainingReleaseCount;
-  private int[] trackStates;
-  private boolean[] pendingDiscontinuities;
-
-  private long seekPositionUs;
-
-  public FrameworkSampleSource(Context context, Uri uri, Map<String, String> headers,
-      int downstreamRendererCount) {
-    Assertions.checkState(Util.SDK_INT >= 16);
-    this.context = context;
-    this.uri = uri;
-    this.headers = headers;
-    this.remainingReleaseCount = downstreamRendererCount;
-  }
-
-  @Override
-  public boolean prepare() throws IOException {
-    if (!prepared) {
-      extractor = new MediaExtractor();
-      extractor.setDataSource(context, uri, headers);
-      trackStates = new int[extractor.getTrackCount()];
-      pendingDiscontinuities = new boolean[trackStates.length];
-      trackInfos = new TrackInfo[trackStates.length];
-      for (int i = 0; i < trackStates.length; i++) {
-        android.media.MediaFormat format = extractor.getTrackFormat(i);
-        long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION) ?
-            format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
-        String mime = format.getString(android.media.MediaFormat.KEY_MIME);
-        trackInfos[i] = new TrackInfo(mime, durationUs);
-      }
-      prepared = true;
-    }
-    return true;
-  }
-
-  @Override
-  public int getTrackCount() {
-    Assertions.checkState(prepared);
-    return trackStates.length;
-  }
-
-  @Override
-  public TrackInfo getTrackInfo(int track) {
-    Assertions.checkState(prepared);
-    return trackInfos[track];
-  }
-
-  @Override
-  public void enable(int track, long positionUs) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(trackStates[track] == TRACK_STATE_DISABLED);
-    trackStates[track] = TRACK_STATE_ENABLED;
-    extractor.selectTrack(track);
-    seekToUs(positionUs);
-  }
-
-  @Override
-  public boolean continueBuffering(long positionUs) {
-    // MediaExtractor takes care of buffering and blocks until it has samples, so we can always
-    // return true here. Although note that the blocking behavior is itself as bug, as per the
-    // TODO further up this file. This method will need to return something else as part of fixing
-    // the TODO.
-    return true;
-  }
-
-  @Override
-  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
-    if (pendingDiscontinuities[track]) {
-      pendingDiscontinuities[track] = false;
-      return DISCONTINUITY_READ;
-    }
-    if (onlyReadDiscontinuity) {
-      return NOTHING_READ;
-    }
-    if (trackStates[track] != TRACK_STATE_FORMAT_SENT) {
-      formatHolder.format = MediaFormat.createFromFrameworkMediaFormatV16(
-          extractor.getTrackFormat(track));
-      formatHolder.drmInitData = Util.SDK_INT >= 18 ? getPsshInfoV18() : null;
-      trackStates[track] = TRACK_STATE_FORMAT_SENT;
-      return FORMAT_READ;
-    }
-    int extractorTrackIndex = extractor.getSampleTrackIndex();
-    if (extractorTrackIndex == track) {
-      if (sampleHolder.data != null) {
-        int offset = sampleHolder.data.position();
-        sampleHolder.size = extractor.readSampleData(sampleHolder.data, offset);
-        sampleHolder.data.position(offset + sampleHolder.size);
-      } else {
-        sampleHolder.size = 0;
-      }
-      sampleHolder.timeUs = extractor.getSampleTime();
-      sampleHolder.flags = extractor.getSampleFlags();
-      if ((sampleHolder.flags & MediaExtractor.SAMPLE_FLAG_ENCRYPTED) != 0) {
-        sampleHolder.cryptoInfo.setFromExtractorV16(extractor);
-      }
-      seekPositionUs = -1;
-      extractor.advance();
-      return SAMPLE_READ;
-    } else {
-      return extractorTrackIndex < 0 ? END_OF_STREAM : NOTHING_READ;
-    }
-  }
-
-  @TargetApi(18)
-  private Map<UUID, byte[]> getPsshInfoV18() {
-    Map<UUID, byte[]> psshInfo = extractor.getPsshInfo();
-    return (psshInfo == null || psshInfo.isEmpty()) ? null : psshInfo;
-  }
-
-  @Override
-  public void disable(int track) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
-    extractor.unselectTrack(track);
-    pendingDiscontinuities[track] = false;
-    trackStates[track] = TRACK_STATE_DISABLED;
-  }
-
-  @Override
-  public void seekToUs(long positionUs) {
-    Assertions.checkState(prepared);
-    if (seekPositionUs != positionUs) {
-      // Avoid duplicate calls to the underlying extractor's seek method in the case that there
-      // have been no interleaving calls to advance.
-      seekPositionUs = positionUs;
-      extractor.seekTo(positionUs, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-      for (int i = 0; i < trackStates.length; ++i) {
-        if (trackStates[i] != TRACK_STATE_DISABLED) {
-          pendingDiscontinuities[i] = true;
-        }
-      }
-    }
-  }
-
-  @Override
-  public long getBufferedPositionUs() {
-    Assertions.checkState(prepared);
-    long bufferedDurationUs = extractor.getCachedDuration();
-    if (bufferedDurationUs == -1) {
-      return TrackRenderer.UNKNOWN_TIME_US;
-    } else {
-      return extractor.getSampleTime() + bufferedDurationUs;
-    }
-  }
-
-  @Override
-  public void release() {
-    Assertions.checkState(remainingReleaseCount > 0);
-    if (--remainingReleaseCount == 0) {
-      extractor.release();
-      extractor = null;
-    }
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 5c8a0056d6..a6ff3b0a44 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -17,7 +17,6 @@
 
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.drm.DrmSessionManager;
-import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
 
 import android.annotation.TargetApi;
@@ -47,6 +46,13 @@
      */
     void onAudioTrackInitializationError(AudioTrack.InitializationException e);
 
+    /**
+     * Invoked when an {@link AudioTrack} write fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackWriteError(AudioTrack.WriteException e);
+
   }
 
   /**
@@ -57,10 +63,9 @@
   public static final int MSG_SET_VOLUME = 1;
 
   private final EventListener eventListener;
-
   private final AudioTrack audioTrack;
-  private int audioSessionId;
 
+  private int audioSessionId;
   private long currentPositionUs;
 
   /**
@@ -111,72 +116,10 @@ public MediaCodecAudioTrackRenderer(SampleSource source, Handler eventHandler,
    */
   public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
       boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener) {
-    this(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener,
-        new AudioTrack());
-  }
-
-  /**
-   * @param source The upstream source from which the renderer obtains samples.
-   * @param minBufferMultiplicationFactor When instantiating an underlying
-   *     {@link android.media.AudioTrack}, the size of the track is calculated as this value
-   *     multiplied by the minimum buffer size obtained from
-   *     {@link android.media.AudioTrack#getMinBufferSize(int, int, int)}. The multiplication
-   *     factor must be greater than or equal to 1.
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public MediaCodecAudioTrackRenderer(SampleSource source, float minBufferMultiplicationFactor,
-      Handler eventHandler, EventListener eventListener) {
-    this(source, null, true, minBufferMultiplicationFactor, eventHandler, eventListener);
-  }
-
-  /**
-   * @param source The upstream source from which the renderer obtains samples.
-   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
-   *     content is not required.
-   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
-   *     For example a media file may start with a short clear region so as to allow playback to
-   *     begin in parallel with key acquisision. This parameter specifies whether the renderer is
-   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
-   *     has obtained the keys necessary to decrypt encrypted regions of the media.
-   * @param minBufferMultiplicationFactor When instantiating an underlying
-   *     {@link android.media.AudioTrack}, the size of the track is calculated as this value
-   *     multiplied by the minimum buffer size obtained from
-   *     {@link android.media.AudioTrack#getMinBufferSize(int, int, int)}. The multiplication
-   *     factor must be greater than or equal to 1.
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, float minBufferMultiplicationFactor,
-      Handler eventHandler, EventListener eventListener) {
-    this(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener,
-        new AudioTrack(minBufferMultiplicationFactor));
-  }
-
-  /**
-   * @param source The upstream source from which the renderer obtains samples.
-   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
-   *     content is not required.
-   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
-   *     For example a media file may start with a short clear region so as to allow playback to
-   *     begin in parallel with key acquisision. This parameter specifies whether the renderer is
-   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
-   *     has obtained the keys necessary to decrypt encrypted regions of the media.
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param audioTrack Used for playing back decoded audio samples.
-   */
-  public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener,
-      AudioTrack audioTrack) {
     super(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener);
     this.eventListener = eventListener;
-    this.audioTrack = Assertions.checkNotNull(audioTrack);
     this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    this.audioTrack = new AudioTrack();
   }
 
   @Override
@@ -303,8 +246,14 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       }
     }
 
-    int handleBufferResult = audioTrack.handleBuffer(
-        buffer, bufferInfo.offset, bufferInfo.size, bufferInfo.presentationTimeUs);
+    int handleBufferResult;
+    try {
+      handleBufferResult = audioTrack.handleBuffer(
+          buffer, bufferInfo.offset, bufferInfo.size, bufferInfo.presentationTimeUs);
+    } catch (AudioTrack.WriteException e) {
+      notifyAudioTrackWriteError(e);
+      throw new ExoPlaybackException(e);
+    }
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
@@ -341,4 +290,15 @@ public void run() {
     }
   }
 
+  private void notifyAudioTrackWriteError(final AudioTrack.WriteException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackWriteError(e);
+        }
+      });
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 271e8ff461..61b12e33b1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
@@ -67,8 +68,12 @@
    */
   public static class DecoderInitializationException extends Exception {
 
+    private static final int CUSTOM_ERROR_CODE_BASE = -50000;
+    private static final int NO_SUITABLE_DECODER_ERROR = CUSTOM_ERROR_CODE_BASE + 1;
+    private static final int DECODER_QUERY_ERROR = CUSTOM_ERROR_CODE_BASE + 2;
+
     /**
-     * The name of the decoder that failed to initialize.
+     * The name of the decoder that failed to initialize. Null if no suitable decoder was found.
      */
     public final String decoderName;
 
@@ -77,8 +82,14 @@
      */
     public final String diagnosticInfo;
 
-    public DecoderInitializationException(String decoderName, MediaFormat mediaFormat,
-        Throwable cause) {
+    public DecoderInitializationException(MediaFormat mediaFormat, Throwable cause, int errorCode) {
+      super("Decoder init failed: [" + errorCode + "], " + mediaFormat, cause);
+      this.decoderName = null;
+      this.diagnosticInfo = buildCustomDiagnosticInfo(errorCode);
+    }
+
+    public DecoderInitializationException(MediaFormat mediaFormat, Throwable cause,
+        String decoderName) {
       super("Decoder init failed: " + decoderName + ", " + mediaFormat, cause);
       this.decoderName = decoderName;
       this.diagnosticInfo = Util.SDK_INT >= 21 ? getDiagnosticInfoV21(cause) : null;
@@ -92,6 +103,11 @@ private static String getDiagnosticInfoV21(Throwable cause) {
       return null;
     }
 
+    private static String buildCustomDiagnosticInfo(int errorCode) {
+      String sign = errorCode < 0 ? "neg_" : "";
+      return "com.google.android.exoplayer.MediaCodecTrackRenderer_" + sign + Math.abs(errorCode);
+    }
+
   }
 
   /**
@@ -281,21 +297,29 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       }
     }
 
-    DecoderInfo selectedDecoderInfo = MediaCodecUtil.getDecoderInfo(mimeType,
-        requiresSecureDecoder);
-    String selectedDecoderName = selectedDecoderInfo.name;
-    codecIsAdaptive = selectedDecoderInfo.adaptive;
+    DecoderInfo decoderInfo = null;
+    try {
+      decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
+    } catch (DecoderQueryException e) {
+      notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e,
+          DecoderInitializationException.DECODER_QUERY_ERROR));
+    }
+
+    if (decoderInfo == null) {
+      notifyAndThrowDecoderInitError(new DecoderInitializationException(format, null,
+          DecoderInitializationException.NO_SUITABLE_DECODER_ERROR));
+    }
+
+    String decoderName = decoderInfo.name;
+    codecIsAdaptive = decoderInfo.adaptive;
     try {
-      codec = MediaCodec.createByCodecName(selectedDecoderName);
+      codec = MediaCodec.createByCodecName(decoderName);
       configureCodec(codec, format.getFrameworkMediaFormatV16(), mediaCrypto);
       codec.start();
       inputBuffers = codec.getInputBuffers();
       outputBuffers = codec.getOutputBuffers();
     } catch (Exception e) {
-      DecoderInitializationException exception = new DecoderInitializationException(
-          selectedDecoderName, format, e);
-      notifyDecoderInitializationError(exception);
-      throw new ExoPlaybackException(exception);
+      notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e, decoderName));
     }
     codecHotswapTimeMs = getState() == TrackRenderer.STATE_STARTED ?
         SystemClock.elapsedRealtime() : -1;
@@ -305,6 +329,12 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     codecCounters.codecInitCount++;
   }
 
+  private void notifyAndThrowDecoderInitError(DecoderInitializationException e)
+      throws ExoPlaybackException {
+    notifyDecoderInitializationError(e);
+    throw new ExoPlaybackException(e);
+  }
+
   protected boolean shouldInitCodec() {
     return codec == null && format != null;
   }
@@ -410,17 +440,14 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
       checkForDiscontinuity();
       if (format == null) {
         readFormat();
-      } else if (codec == null && !shouldInitCodec() && getState() == TrackRenderer.STATE_STARTED) {
-        discardSamples(positionUs);
-      } else {
-        if (codec == null && shouldInitCodec()) {
-          maybeInitCodec();
-        }
-        if (codec != null) {
-          while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-          if (feedInputBuffer(true)) {
-            while (feedInputBuffer(false)) {}
-          }
+      }
+      if (codec == null && shouldInitCodec()) {
+        maybeInitCodec();
+      }
+      if (codec != null) {
+        while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
+        if (feedInputBuffer(true)) {
+          while (feedInputBuffer(false)) {}
         }
       }
       codecCounters.ensureUpdated();
@@ -436,21 +463,6 @@ private void readFormat() throws IOException, ExoPlaybackException {
     }
   }
 
-  private void discardSamples(long positionUs) throws IOException, ExoPlaybackException {
-    sampleHolder.data = null;
-    int result = SampleSource.SAMPLE_READ;
-    while (result == SampleSource.SAMPLE_READ && currentPositionUs <= positionUs) {
-      result = source.readData(trackIndex, currentPositionUs, formatHolder, sampleHolder, false);
-      if (result == SampleSource.SAMPLE_READ) {
-        if (!sampleHolder.decodeOnly) {
-          currentPositionUs = sampleHolder.timeUs;
-        }
-      } else if (result == SampleSource.FORMAT_READ) {
-        onInputFormatChanged(formatHolder);
-      }
-    }
-  }
-
   private void checkForDiscontinuity() throws IOException, ExoPlaybackException {
     if (codec == null) {
       return;
@@ -560,7 +572,7 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
     if (waitingForFirstSyncFrame) {
       // TODO: Find out if it's possible to supply samples prior to the first sync
       // frame for HE-AAC.
-      if ((sampleHolder.flags & MediaExtractor.SAMPLE_FLAG_SYNC) == 0) {
+      if ((sampleHolder.flags & C.SAMPLE_FLAG_SYNC) == 0) {
         sampleHolder.data.clear();
         if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
           // The buffer we just cleared contained reconfiguration data. We need to re-write this
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 62918b531f..f3dbc7e7d1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -35,6 +35,20 @@
 @TargetApi(16)
 public class MediaCodecUtil {
 
+  /**
+   * Thrown when an error occurs querying the device for its underlying media capabilities.
+   * <p>
+   * Such failures are not expected in normal operation and are normally temporary (e.g. if the
+   * mediaserver process has crashed and is yet to restart).
+   */
+  public static class DecoderQueryException extends Exception {
+
+    private DecoderQueryException(Throwable cause) {
+      super("Failed to query underlying media codecs", cause);
+    }
+
+  }
+
   private static final String TAG = "MediaCodecUtil";
 
   private static final HashMap<CodecKey, Pair<String, CodecCapabilities>> codecs =
@@ -48,7 +62,8 @@
    *     unless secure decryption really is required.
    * @return Information about the decoder that will be used, or null if no decoder exists.
    */
-  public static DecoderInfo getDecoderInfo(String mimeType, boolean secure) {
+  public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
+      throws DecoderQueryException {
     Pair<String, CodecCapabilities> info = getMediaCodecInfo(mimeType, secure);
     if (info == null) {
       return null;
@@ -66,14 +81,19 @@ public static DecoderInfo getDecoderInfo(String mimeType, boolean secure) {
    *     unless secure decryption really is required.
    */
   public static synchronized void warmCodec(String mimeType, boolean secure) {
-    getMediaCodecInfo(mimeType, secure);
+    try {
+      getMediaCodecInfo(mimeType, secure);
+    } catch (DecoderQueryException e) {
+      // Codec warming is best effort, so we can swallow the exception.
+      Log.e(TAG, "Codec warming failed", e);
+    }
   }
 
   /**
    * Returns the name of the best decoder and its capabilities for the given mimeType.
    */
   private static synchronized Pair<String, CodecCapabilities> getMediaCodecInfo(
-      String mimeType, boolean secure) {
+      String mimeType, boolean secure) throws DecoderQueryException {
     CodecKey key = new CodecKey(mimeType, secure);
     if (codecs.containsKey(key)) {
       return codecs.get(key);
@@ -95,6 +115,17 @@ public static synchronized void warmCodec(String mimeType, boolean secure) {
   }
 
   private static Pair<String, CodecCapabilities> getMediaCodecInfo(CodecKey key,
+      MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
+    try {
+      return getMediaCodecInfoInternal(key, mediaCodecList);
+    } catch (Exception e) {
+      // If the underlying mediaserver is in a bad state, we may catch an IllegalStateException
+      // or an IllegalArgumentException here.
+      throw new DecoderQueryException(e);
+    }
+  }
+
+  private static Pair<String, CodecCapabilities> getMediaCodecInfoInternal(CodecKey key,
       MediaCodecListCompat mediaCodecList) {
     String mimeType = key.mimeType;
     int numberOfCodecs = mediaCodecList.getCodecCount();
@@ -153,7 +184,8 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
    * @param level An AVC profile level from {@link CodecProfileLevel}.
    * @return Whether the specified profile is supported at the specified level.
    */
-  public static boolean isH264ProfileSupported(int profile, int level) {
+  public static boolean isH264ProfileSupported(int profile, int level)
+      throws DecoderQueryException {
     Pair<String, CodecCapabilities> info = getMediaCodecInfo(MimeTypes.VIDEO_H264, false);
     if (info == null) {
       return false;
@@ -173,7 +205,7 @@ public static boolean isH264ProfileSupported(int profile, int level) {
   /**
    * @return the maximum frame size for an H264 stream that can be decoded on the device.
    */
-  public static int maxH264DecodableFrameSize() {
+  public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     Pair<String, CodecCapabilities> info = getMediaCodecInfo(MimeTypes.VIDEO_H264, false);
     if (info == null) {
       return 0;
@@ -248,20 +280,23 @@ private static int avcLevelToMaxFrameSize(int avcLevel) {
   @TargetApi(21)
   private static final class MediaCodecListCompatV21 implements MediaCodecListCompat {
 
-    private final MediaCodecInfo[] mediaCodecInfos;
+    private final int codecKind;
+
+    private MediaCodecInfo[] mediaCodecInfos;
 
     public MediaCodecListCompatV21(boolean includeSecure) {
-      int codecKind = includeSecure ? MediaCodecList.ALL_CODECS : MediaCodecList.REGULAR_CODECS;
-      mediaCodecInfos = new MediaCodecList(codecKind).getCodecInfos();
+      codecKind = includeSecure ? MediaCodecList.ALL_CODECS : MediaCodecList.REGULAR_CODECS;
     }
 
     @Override
     public int getCodecCount() {
+      ensureMediaCodecInfosInitialized();
       return mediaCodecInfos.length;
     }
 
     @Override
     public MediaCodecInfo getCodecInfoAt(int index) {
+      ensureMediaCodecInfosInitialized();
       return mediaCodecInfos[index];
     }
 
@@ -275,6 +310,12 @@ public boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capa
       return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_SecurePlayback);
     }
 
+    private void ensureMediaCodecInfosInitialized() {
+      if (mediaCodecInfos == null) {
+        mediaCodecInfos = new MediaCodecList(codecKind).getCodecInfos();
+      }
+    }
+
   }
 
   @SuppressWarnings("deprecation")
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index 397f83cb88..685b32eff3 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -353,7 +353,7 @@ private void setSurface(Surface surface) throws ExoPlaybackException {
 
   @Override
   protected boolean shouldInitCodec() {
-    return super.shouldInitCodec() && surface != null;
+    return super.shouldInitCodec() && surface != null && surface.isValid();
   }
 
   // Override configureCodec to provide the surface.
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 24db47ff77..5d1bf3945b 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
@@ -86,6 +87,23 @@ public static MediaFormat createAudioFormat(String mimeType, int maxInputSize, i
         sampleRate, bitrate, initializationData);
   }
 
+  public static MediaFormat createId3Format() {
+    return createFormatForMimeType(MimeTypes.APPLICATION_ID3);
+  }
+
+  public static MediaFormat createEia608Format() {
+    return createFormatForMimeType(MimeTypes.APPLICATION_EIA608);
+  }
+
+  public static MediaFormat createTtmlFormat() {
+    return createFormatForMimeType(MimeTypes.APPLICATION_TTML);
+  }
+
+  public static MediaFormat createFormatForMimeType(String mimeType) {
+    return new MediaFormat(mimeType, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, null);
+  }
+
   @TargetApi(16)
   private MediaFormat(android.media.MediaFormat format) {
     this.frameworkMediaFormat = format;
@@ -146,7 +164,7 @@ public int getMaxVideoHeight() {
   public int hashCode() {
     if (hashCode == 0) {
       int result = 17;
-      result = 31 * result + mimeType == null ? 0 : mimeType.hashCode();
+      result = 31 * result + (mimeType == null ? 0 : mimeType.hashCode());
       result = 31 * result + maxInputSize;
       result = 31 * result + width;
       result = 31 * result + height;
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleHolder.java b/library/src/main/java/com/google/android/exoplayer/SampleHolder.java
index 43308bc40b..9a258b752c 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleHolder.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleHolder.java
@@ -96,4 +96,13 @@ public boolean replaceBuffer(int capacity) {
     return false;
   }
 
+  /**
+   * Clears {@link #data}. Does nothing if {@link #data} is null.
+   */
+  public void clearData() {
+    if (data != null) {
+      data.clear();
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
index cf4f8f13fc..8d5534e0b7 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
@@ -18,8 +18,6 @@
 import com.google.android.exoplayer.ExoPlayer.ExoPlayerComponent;
 import com.google.android.exoplayer.util.Assertions;
 
-import android.os.SystemClock;
-
 /**
  * Renders a single component of media.
  *
@@ -293,8 +291,8 @@ protected void onReleased() throws ExoPlaybackException {
    *
    * @param positionUs The current media time in microseconds, measured at the start of the
    *     current iteration of the rendering loop.
-   * @param elapsedRealtimeUs {@link SystemClock#elapsedRealtime()} in microseconds, measured at
-   *     the start of the current iteration of the rendering loop.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
    * @throws ExoPlaybackException If an error occurs.
    */
   protected abstract void doSomeWork(long positionUs, long elapsedRealtimeUs)
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index 405f3e9c6b..9c33014da8 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer.audio;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
@@ -66,6 +65,21 @@ public InitializationException(
 
   }
 
+  /**
+   * Thrown when a failure occurs writing to an {@link android.media.AudioTrack}.
+   */
+  public static class WriteException extends Exception {
+
+    /** The value returned from {@link android.media.AudioTrack#write(byte[], int, int)}. */
+    public final int errorCode;
+
+    public WriteException(int errorCode) {
+      super("AudioTrack write failed: " + errorCode);
+      this.errorCode = errorCode;
+    }
+
+  }
+
   /** Returned in the result of {@link #handleBuffer} if the buffer was discontinuous. */
   public static final int RESULT_POSITION_DISCONTINUITY = 1;
   /** Returned in the result of {@link #handleBuffer} if the buffer can be released. */
@@ -74,12 +88,19 @@ public InitializationException(
   /** Represents an unset {@link android.media.AudioTrack} session identifier. */
   public static final int SESSION_ID_NOT_SET = 0;
 
-  /** The default multiplication factor used when determining the size of the track's buffer. */
-  public static final float DEFAULT_MIN_BUFFER_MULTIPLICATION_FACTOR = 4;
-
   /** Returned by {@link #getCurrentPositionUs} when the position is not set. */
   public static final long CURRENT_POSITION_NOT_SET = Long.MIN_VALUE;
 
+  /** A minimum length for the {@link android.media.AudioTrack} buffer, in microseconds. */
+  private static final long MIN_BUFFER_DURATION_US = 250000;
+  /** A maximum length for the {@link android.media.AudioTrack} buffer, in microseconds. */
+  private static final long MAX_BUFFER_DURATION_US = 750000;
+  /**
+   * A multiplication factor to apply to the minimum buffer size requested by the underlying
+   * {@link android.media.AudioTrack}.
+   */
+  private static final int BUFFER_MULTIPLICATION_FACTOR = 4;
+
   private static final String TAG = "AudioTrack";
 
   /**
@@ -88,14 +109,14 @@ public InitializationException(
    *
    * <p>This is a fail safe that should not be required on correctly functioning devices.
    */
-  private static final long MAX_AUDIO_TIMESTAMP_OFFSET_US = 10 * C.MICROS_PER_SECOND;
+  private static final long MAX_AUDIO_TIMESTAMP_OFFSET_US = 5 * C.MICROS_PER_SECOND;
 
   /**
    * AudioTrack latencies are deemed impossibly large if they are greater than this amount.
    *
    * <p>This is a fail safe that should not be required on correctly functioning devices.
    */
-  private static final long MAX_LATENCY_US = 10 * C.MICROS_PER_SECOND;
+  private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;
 
   /** Value for ac3Bitrate before the bitrate has been calculated. */
   private static final int UNKNOWN_AC3_BITRATE = 0;
@@ -109,11 +130,10 @@ public InitializationException(
   private static final int MIN_TIMESTAMP_SAMPLE_INTERVAL_US = 500000;
 
   private final ConditionVariable releasingConditionVariable;
-  private final AudioTimestampCompat audioTimestampCompat;
   private final long[] playheadOffsets;
-  private final float minBufferMultiplicationFactor;
 
   private android.media.AudioTrack audioTrack;
+  private AudioTrackUtil audioTrackUtil;
   private int sampleRate;
   private int channelConfig;
   private int encoding;
@@ -127,8 +147,6 @@ public InitializationException(
   private long lastPlayheadSampleTimeUs;
   private boolean audioTimestampSet;
   private long lastTimestampSampleTimeUs;
-  private long lastRawPlaybackHeadPosition;
-  private long rawPlaybackHeadWrapCount;
 
   private Method getLatencyMethod;
   private long submittedBytes;
@@ -147,21 +165,8 @@ public InitializationException(
   /** Bitrate measured in kilobits per second, if {@link #isAc3} is true. */
   private int ac3Bitrate;
 
-  /** Constructs an audio track using the default minimum buffer size multiplier. */
   public AudioTrack() {
-    this(DEFAULT_MIN_BUFFER_MULTIPLICATION_FACTOR);
-  }
-
-  /** Constructs an audio track using the specified minimum buffer size multiplier. */
-  public AudioTrack(float minBufferMultiplicationFactor) {
-    Assertions.checkArgument(minBufferMultiplicationFactor >= 1);
-    this.minBufferMultiplicationFactor = minBufferMultiplicationFactor;
     releasingConditionVariable = new ConditionVariable(true);
-    if (Util.SDK_INT >= 19) {
-      audioTimestampCompat = new AudioTimestampCompatV19();
-    } else {
-      audioTimestampCompat = new NoopAudioTimestampCompat();
-    }
     if (Util.SDK_INT >= 18) {
       try {
         getLatencyMethod =
@@ -207,15 +212,15 @@ public long getCurrentPositionUs(boolean sourceEnded) {
     long currentPositionUs;
     if (audioTimestampSet) {
       // How long ago in the past the audio timestamp is (negative if it's in the future).
-      long presentationDiff = systemClockUs - (audioTimestampCompat.getNanoTime() / 1000);
+      long presentationDiff = systemClockUs - (audioTrackUtil.getTimestampNanoTime() / 1000);
       long framesDiff = durationUsToFrames(presentationDiff);
       // The position of the frame that's currently being presented.
-      long currentFramePosition = audioTimestampCompat.getFramePosition() + framesDiff;
+      long currentFramePosition = audioTrackUtil.getTimestampFramePosition() + framesDiff;
       currentPositionUs = framesToDurationUs(currentFramePosition) + startMediaTimeUs;
     } else {
       if (playheadOffsetCount == 0) {
         // The AudioTrack has started, but we don't have any samples to compute a smoothed position.
-        currentPositionUs = getPlaybackPositionUs() + startMediaTimeUs;
+        currentPositionUs = audioTrackUtil.getPlaybackHeadPositionUs() + startMediaTimeUs;
       } else {
         // getPlayheadPositionUs() only has a granularity of ~20ms, so we base the position off the
         // system clock (and a smoothed offset between it and the playhead position) so as to
@@ -262,7 +267,13 @@ public int initialize(int sessionId) throws InitializationException {
       audioTrack = new android.media.AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
           channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
     }
+
     checkAudioTrackInitialized();
+    if (Util.SDK_INT >= 19) {
+      audioTrackUtil = new AudioTrackUtilV19(audioTrack);
+    } else {
+      audioTrackUtil = new AudioTrackUtil(audioTrack);
+    }
     setVolume(volume);
     return audioTrack.getAudioSessionId();
   }
@@ -282,11 +293,11 @@ public void reconfigure(MediaFormat format) {
    *
    * @param format Specifies the channel count and sample rate to play back.
    * @param encoding The format in which audio is represented.
-   * @param bufferSize The total size of the playback buffer in bytes. Specify 0 to use a buffer
-   *     size based on the minimum for format.
+   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to use a
+   *     size inferred from the format.
    */
   @SuppressLint("InlinedApi")
-  public void reconfigure(MediaFormat format, int encoding, int bufferSize) {
+  public void reconfigure(MediaFormat format, int encoding, int specifiedBufferSize) {
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int channelConfig;
     switch (channelCount) {
@@ -310,24 +321,33 @@ public void reconfigure(MediaFormat format, int encoding, int bufferSize) {
 
     // TODO: Does channelConfig determine channelCount?
     boolean isAc3 = encoding == AudioFormat.ENCODING_AC3 || encoding == AudioFormat.ENCODING_E_AC3;
-    if (audioTrack != null && this.sampleRate == sampleRate
-        && this.channelConfig == channelConfig && !this.isAc3 && !isAc3) {
+    if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
+        && !this.isAc3 && !isAc3) {
       // We already have an existing audio track with the correct sample rate and channel config.
       return;
     }
 
     reset();
 
-    minBufferSize = android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
-
     this.encoding = encoding;
-    this.bufferSize =
-        bufferSize == 0 ? (int) (minBufferMultiplicationFactor * minBufferSize) : bufferSize;
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
     this.isAc3 = isAc3;
     ac3Bitrate = UNKNOWN_AC3_BITRATE; // Calculated on receiving the first buffer if isAc3 is true.
     frameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
+    minBufferSize = android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
+
+    if (specifiedBufferSize != 0) {
+      bufferSize = specifiedBufferSize;
+    } else {
+      int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
+      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * frameSize;
+      int maxAppBufferSize = (int) Math.max(minBufferSize,
+          durationUsToFrames(MAX_BUFFER_DURATION_US) * frameSize);
+      bufferSize = multipliedBufferSize < minAppBufferSize ? minAppBufferSize
+          : multipliedBufferSize > maxAppBufferSize ? maxAppBufferSize
+          : multipliedBufferSize;
+    }
   }
 
   /** Starts/resumes playing audio if the audio track has been initialized. */
@@ -359,11 +379,16 @@ public void handleDiscontinuity() {
    * @return A bit field with {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released, and
    *     {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was not contiguous with previously
    *     written data.
+   * @throws WriteException If an error occurs writing the audio data.
    */
-  public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentationTimeUs) {
-    int result = 0;
+  public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentationTimeUs)
+      throws WriteException {
+    if (size == 0) {
+      return RESULT_BUFFER_CONSUMED;
+    }
 
-    if (temporaryBufferSize == 0 && size != 0) {
+    int result = 0;
+    if (temporaryBufferSize == 0) {
       if (isAc3 && ac3Bitrate == UNKNOWN_AC3_BITRATE) {
         // Each AC-3 buffer contains 1536 frames of audio, so the AudioTrack playback position
         // advances by 1536 per buffer (32 ms at 48 kHz). Calculate the bitrate in kbit/s.
@@ -393,15 +418,11 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
           // number of bytes submitted.
           startMediaTimeUs += (bufferStartTime - expectedBufferStartTime);
           startMediaTimeState = START_IN_SYNC;
-          result = RESULT_POSITION_DISCONTINUITY;
+          result |= RESULT_POSITION_DISCONTINUITY;
         }
       }
     }
 
-    if (size == 0) {
-      return result;
-    }
-
     if (temporaryBufferSize == 0) {
       temporaryBufferSize = size;
       buffer.position(offset);
@@ -418,14 +439,13 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
     int bytesWritten = 0;
     if (Util.SDK_INT < 21) {
       // Work out how many bytes we can write without the risk of blocking.
-      int bytesPending = (int) (submittedBytes - framesToBytes(getPlaybackPositionFrames()));
+      int bytesPending =
+          (int) (submittedBytes - (audioTrackUtil.getPlaybackHeadPosition() * frameSize));
       int bytesToWrite = bufferSize - bytesPending;
       if (bytesToWrite > 0) {
         bytesToWrite = Math.min(temporaryBufferSize, bytesToWrite);
         bytesWritten = audioTrack.write(temporaryBuffer, temporaryBufferOffset, bytesToWrite);
-        if (bytesWritten < 0) {
-          Log.w(TAG, "AudioTrack.write returned error code: " + bytesWritten);
-        } else {
+        if (bytesWritten >= 0) {
           temporaryBufferOffset += bytesWritten;
         }
       }
@@ -433,12 +453,15 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
       bytesWritten = writeNonBlockingV21(audioTrack, buffer, temporaryBufferSize);
     }
 
+    if (bytesWritten < 0) {
+      throw new WriteException(bytesWritten);
+    }
+
     temporaryBufferSize -= bytesWritten;
     submittedBytes += bytesWritten;
     if (temporaryBufferSize == 0) {
       result |= RESULT_BUFFER_CONSUMED;
     }
-
     return result;
   }
 
@@ -450,18 +473,21 @@ private static int writeNonBlockingV21(
 
   /** Returns whether the audio track has more data pending that will be played back. */
   public boolean hasPendingData() {
-    return audioTrack != null && bytesToFrames(submittedBytes) > getPlaybackPositionFrames();
+    return isInitialized()
+        && bytesToFrames(submittedBytes) > audioTrackUtil.getPlaybackHeadPosition();
   }
 
   /** Returns whether enough data has been supplied via {@link #handleBuffer} to begin playback. */
   public boolean hasEnoughDataToBeginPlayback() {
-    return submittedBytes >= minBufferSize;
+    // The value of minBufferSize can be slightly less than what's actually required for playback
+    // to start, hence the multiplication factor.
+    return submittedBytes > (minBufferSize * 3) / 2;
   }
 
   /** Sets the playback volume. */
   public void setVolume(float volume) {
     this.volume = volume;
-    if (audioTrack != null) {
+    if (isInitialized()) {
       if (Util.SDK_INT >= 21) {
         setVolumeV21(audioTrack, volume);
       } else {
@@ -482,7 +508,7 @@ private static void setVolumeV3(android.media.AudioTrack audioTrack, float volum
 
   /** Pauses playback. */
   public void pause() {
-    if (audioTrack != null) {
+    if (isInitialized()) {
       resetSyncParams();
       audioTrack.pause();
     }
@@ -494,11 +520,9 @@ public void pause() {
    * after resetting.
    */
   public void reset() {
-    if (audioTrack != null) {
+    if (isInitialized()) {
       submittedBytes = 0;
       temporaryBufferSize = 0;
-      lastRawPlaybackHeadPosition = 0;
-      rawPlaybackHeadWrapCount = 0;
       startMediaTimeUs = START_NOT_SET;
       resetSyncParams();
       int playState = audioTrack.getPlayState();
@@ -508,6 +532,7 @@ public void reset() {
       // AudioTrack.release can take some time, so we call it on a background thread.
       final android.media.AudioTrack toRelease = audioTrack;
       audioTrack = null;
+      audioTrackUtil = null;
       releasingConditionVariable.close();
       new Thread() {
         @Override
@@ -529,7 +554,7 @@ private boolean hasCurrentPositionUs() {
 
   /** Updates the audio track latency and playback position parameters. */
   private void maybeSampleSyncParams() {
-    long playbackPositionUs = getPlaybackPositionUs();
+    long playbackPositionUs = audioTrackUtil.getPlaybackHeadPositionUs();
     if (playbackPositionUs == 0) {
       // The AudioTrack hasn't output anything yet.
       return;
@@ -550,18 +575,27 @@ private void maybeSampleSyncParams() {
     }
 
     if (systemClockUs - lastTimestampSampleTimeUs >= MIN_TIMESTAMP_SAMPLE_INTERVAL_US) {
-      audioTimestampSet = audioTimestampCompat.update(audioTrack);
+      audioTimestampSet = audioTrackUtil.updateTimestamp();
       if (audioTimestampSet) {
         // Perform sanity checks on the timestamp.
-        long audioTimestampUs = audioTimestampCompat.getNanoTime() / 1000;
+        long audioTimestampUs = audioTrackUtil.getTimestampNanoTime() / 1000;
+        long audioTimestampFramePosition = audioTrackUtil.getTimestampFramePosition();
         if (audioTimestampUs < resumeSystemTimeUs) {
           // The timestamp corresponds to a time before the track was most recently resumed.
           audioTimestampSet = false;
         } else if (Math.abs(audioTimestampUs - systemClockUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
           // The timestamp time base is probably wrong.
           audioTimestampSet = false;
-          Log.w(TAG, "Spurious audio timestamp: " + audioTimestampCompat.getFramePosition() + ", "
-              + audioTimestampUs + ", " + systemClockUs);
+          Log.w(TAG, "Spurious audio timestamp (system clock mismatch): "
+              + audioTimestampFramePosition + ", " + audioTimestampUs + ", " + systemClockUs + ", "
+              + playbackPositionUs);
+        } else if (Math.abs(framesToDurationUs(audioTimestampFramePosition) - playbackPositionUs)
+            > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
+          // The timestamp frame position is probably wrong.
+          audioTimestampSet = false;
+          Log.w(TAG, "Spurious audio timestamp (frame position mismatch): "
+              + audioTimestampFramePosition + ", " + audioTimestampUs + ", " + systemClockUs + ", "
+              + playbackPositionUs);
         }
       }
       if (getLatencyMethod != null) {
@@ -611,37 +645,10 @@ private void checkAudioTrackInitialized() throws InitializationException {
     throw new InitializationException(state, sampleRate, channelConfig, bufferSize);
   }
 
-  /**
-   * {@link android.media.AudioTrack#getPlaybackHeadPosition()} returns a value intended to be
-   * interpreted as an unsigned 32 bit integer, which also wraps around periodically. This method
-   * returns the playback head position as a long that will only wrap around if the value exceeds
-   * {@link Long#MAX_VALUE} (which in practice will never happen).
-   *
-   * @return {@link android.media.AudioTrack#getPlaybackHeadPosition()} of {@link #audioTrack}
-   *     expressed as a long.
-   */
-  private long getPlaybackPositionFrames() {
-    long rawPlaybackHeadPosition = 0xFFFFFFFFL & audioTrack.getPlaybackHeadPosition();
-    if (lastRawPlaybackHeadPosition > rawPlaybackHeadPosition) {
-      // The value must have wrapped around.
-      rawPlaybackHeadWrapCount++;
-    }
-    lastRawPlaybackHeadPosition = rawPlaybackHeadPosition;
-    return rawPlaybackHeadPosition + (rawPlaybackHeadWrapCount << 32);
-  }
-
-  private long getPlaybackPositionUs() {
-    return framesToDurationUs(getPlaybackPositionFrames());
-  }
-
-  private long framesToBytes(long frameCount) {
-    // This method is unused on SDK >= 21.
-    return frameCount * frameSize;
-  }
-
   private long bytesToFrames(long byteCount) {
     if (isAc3) {
-      return byteCount * 8 * sampleRate / (1000 * ac3Bitrate);
+      return
+          ac3Bitrate == UNKNOWN_AC3_BITRATE ? 0L : byteCount * 8 * sampleRate / (1000 * ac3Bitrate);
     } else {
       return byteCount / frameSize;
     }
@@ -665,72 +672,126 @@ private void resetSyncParams() {
   }
 
   /**
-   * Interface exposing the {@link android.media.AudioTimestamp} methods we need that were added in
-   * SDK 19.
+   * Wraps an {@link android.media.AudioTrack} to expose useful utility methods.
    */
-  private interface AudioTimestampCompat {
+  private static class AudioTrackUtil {
 
-    /**
-     * Returns true if the audioTimestamp was retrieved from the audioTrack.
-     */
-    boolean update(android.media.AudioTrack audioTrack);
+    protected final android.media.AudioTrack audioTrack;
+    private final int sampleRate;
 
-    long getNanoTime();
+    private long lastRawPlaybackHeadPosition;
+    private long rawPlaybackHeadWrapCount;
 
-    long getFramePosition();
+    public AudioTrackUtil(android.media.AudioTrack audioTrack) {
+      this.audioTrack = audioTrack;
+      this.sampleRate = audioTrack.getSampleRate();
+    }
 
-  }
+    /**
+     * {@link android.media.AudioTrack#getPlaybackHeadPosition()} returns a value intended to be
+     * interpreted as an unsigned 32 bit integer, which also wraps around periodically. This method
+     * returns the playback head position as a long that will only wrap around if the value exceeds
+     * {@link Long#MAX_VALUE} (which in practice will never happen).
+     *
+     * @return {@link android.media.AudioTrack#getPlaybackHeadPosition()} of {@link #audioTrack}
+     *     expressed as a long.
+     */
+    public long getPlaybackHeadPosition() {
+      long rawPlaybackHeadPosition = 0xFFFFFFFFL & audioTrack.getPlaybackHeadPosition();
+      if (lastRawPlaybackHeadPosition > rawPlaybackHeadPosition) {
+        // The value must have wrapped around.
+        rawPlaybackHeadWrapCount++;
+      }
+      lastRawPlaybackHeadPosition = rawPlaybackHeadPosition;
+      return rawPlaybackHeadPosition + (rawPlaybackHeadWrapCount << 32);
+    }
 
-  /**
-   * The AudioTimestampCompat implementation for SDK < 19 that does nothing or throws an exception.
-   */
-  private static final class NoopAudioTimestampCompat implements AudioTimestampCompat {
+    /**
+     * Returns {@link #getPlaybackHeadPosition()} expressed as microseconds.
+     */
+    public long getPlaybackHeadPositionUs() {
+      return (getPlaybackHeadPosition() * C.MICROS_PER_SECOND) / sampleRate;
+    }
 
-    @Override
-    public boolean update(android.media.AudioTrack audioTrack) {
+    /**
+     * Updates the values returned by {@link #getTimestampNanoTime()} and
+     * {@link #getTimestampFramePosition()}.
+     *
+     * @return True if the timestamp values were updated. False otherwise.
+     */
+    public boolean updateTimestamp() {
       return false;
     }
 
-    @Override
-    public long getNanoTime() {
-      // Should never be called if initTimestamp() returned false.
+    /**
+     * Returns the {@link android.media.AudioTimestamp#nanoTime} obtained during the most recent
+     * call to {@link #updateTimestamp()} that returned true.
+     *
+     * @return The nanoTime obtained during the most recent call to {@link #updateTimestamp()} that
+     *     returned true.
+     * @throws UnsupportedOperationException If the implementation does not support audio timestamp
+     *     queries. {@link #updateTimestamp()} will always return false in this case.
+     */
+    public long getTimestampNanoTime() {
+      // Should never be called if updateTimestamp() returned false.
       throw new UnsupportedOperationException();
     }
 
-    @Override
-    public long getFramePosition() {
-      // Should never be called if initTimestamp() returned false.
+    /**
+     * Returns the {@link android.media.AudioTimestamp#framePosition} obtained during the most
+     * recent call to {@link #updateTimestamp()} that returned true. The value is adjusted so that
+     * wrap around only occurs if the value exceeds {@link Long#MAX_VALUE} (which in practice will
+     * never happen).
+     *
+     * @return The framePosition obtained during the most recent call to {@link #updateTimestamp()}
+     *     that returned true.
+     * @throws UnsupportedOperationException If the implementation does not support audio timestamp
+     *     queries. {@link #updateTimestamp()} will always return false in this case.
+     */
+    public long getTimestampFramePosition() {
+      // Should never be called if updateTimestamp() returned false.
       throw new UnsupportedOperationException();
     }
 
   }
 
-  /**
-   * The AudioTimestampCompat implementation for SDK >= 19 that simply calls through to the actual
-   * implementations added in SDK 19.
-   */
   @TargetApi(19)
-  private static final class AudioTimestampCompatV19 implements AudioTimestampCompat {
+  private static class AudioTrackUtilV19 extends AudioTrackUtil {
 
     private final AudioTimestamp audioTimestamp;
 
-    public AudioTimestampCompatV19() {
+    private long rawTimestampFramePositionWrapCount;
+    private long lastRawTimestampFramePosition;
+    private long lastTimestampFramePosition;
+
+    public AudioTrackUtilV19(android.media.AudioTrack audioTrack) {
+      super(audioTrack);
       audioTimestamp = new AudioTimestamp();
     }
 
     @Override
-    public boolean update(android.media.AudioTrack audioTrack) {
-      return audioTrack.getTimestamp(audioTimestamp);
+    public boolean updateTimestamp() {
+      boolean updated = audioTrack.getTimestamp(audioTimestamp);
+      if (updated) {
+        long rawFramePosition = audioTimestamp.framePosition;
+        if (lastRawTimestampFramePosition > rawFramePosition) {
+          // The value must have wrapped around.
+          rawTimestampFramePositionWrapCount++;
+        }
+        lastRawTimestampFramePosition = rawFramePosition;
+        lastTimestampFramePosition = rawFramePosition + (rawTimestampFramePositionWrapCount << 32);
+      }
+      return updated;
     }
 
     @Override
-    public long getNanoTime() {
+    public long getTimestampNanoTime() {
       return audioTimestamp.nanoTime;
     }
 
     @Override
-    public long getFramePosition() {
-      return audioTimestamp.framePosition;
+    public long getTimestampFramePosition() {
+      return lastTimestampFramePosition;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
index 8a9471c113..9949037f4d 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.TraceUtil;
 
 import java.io.IOException;
 
@@ -173,7 +174,12 @@ public final boolean isLoadCanceled() {
 
   @Override
   public final void load() throws IOException, InterruptedException {
-    dataSourceStream.load();
+    TraceUtil.beginSection("chunkLoad");
+    try {
+      dataSourceStream.load();
+    } finally {
+      TraceUtil.endSection();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index f16fc4c4df..d8791f84b0 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -137,7 +137,7 @@ void onDownstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeM
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 1;
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
   private static final int STATE_UNPREPARED = 0;
   private static final int STATE_PREPARED = 1;
@@ -272,16 +272,23 @@ public boolean continueBuffering(long positionUs) throws IOException {
     downstreamPositionUs = positionUs;
     chunkSource.continueBuffering(positionUs);
     updateLoadControl();
+
+    boolean haveSamples = false;
     if (isPendingReset() || mediaChunks.isEmpty()) {
-      return false;
+      // No sample available.
     } else if (mediaChunks.getFirst().sampleAvailable()) {
       // There's a sample available to be read from the current chunk.
-      return true;
+      haveSamples = true;
     } else {
       // It may be the case that the current chunk has been fully read but not yet discarded and
       // that the next chunk has an available sample. Return true if so, otherwise false.
-      return mediaChunks.size() > 1 && mediaChunks.get(1).sampleAvailable();
+      haveSamples = mediaChunks.size() > 1 && mediaChunks.get(1).sampleAvailable();
+    }
+
+    if (!haveSamples) {
+      maybeThrowLoadableException();
     }
+    return haveSamples;
   }
 
   @Override
@@ -380,7 +387,8 @@ public void seekToUs(long positionUs) {
   }
 
   private void maybeThrowLoadableException() throws IOException {
-    if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
+    if (currentLoadableException != null && (currentLoadableExceptionFatal
+        || currentLoadableExceptionCount > minLoadableRetryCount)) {
       throw currentLoadableException;
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Mp4MediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
similarity index 94%
rename from library/src/main/java/com/google/android/exoplayer/chunk/Mp4MediaChunk.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
index e39c53ebff..a3eefa9b5c 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Mp4MediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
@@ -18,7 +18,7 @@
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.parser.Extractor;
+import com.google.android.exoplayer.chunk.parser.Extractor;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
@@ -28,9 +28,9 @@
 import java.util.UUID;
 
 /**
- * An Mp4 {@link MediaChunk}.
+ * A {@link MediaChunk} extracted from a container.
  */
-public final class Mp4MediaChunk extends MediaChunk {
+public final class ContainerMediaChunk extends MediaChunk {
 
   private final Extractor extractor;
   private final boolean maybeSelfContained;
@@ -44,7 +44,7 @@
    * @deprecated Use the other constructor, passing null as {@code psshInfo}.
    */
   @Deprecated
-  public Mp4MediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
+  public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
       int trigger, long startTimeUs, long endTimeUs, int nextChunkIndex,
       Extractor extractor, boolean maybeSelfContained, long sampleOffsetUs) {
     this(dataSource, dataSpec, format, trigger, startTimeUs, endTimeUs, nextChunkIndex,
@@ -68,7 +68,7 @@ public Mp4MediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
    *     improve startup latency.
    * @param sampleOffsetUs An offset to subtract from the sample timestamps parsed by the extractor.
    */
-  public Mp4MediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
+  public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
       int trigger, long startTimeUs, long endTimeUs, int nextChunkIndex, Extractor extractor,
       Map<UUID, byte[]> psshInfo, boolean maybeSelfContained, long sampleOffsetUs) {
     super(dataSource, dataSpec, format, trigger, startTimeUs, endTimeUs, nextChunkIndex);
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Format.java b/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
index b2948c06a9..2810dc4ff5 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
@@ -46,6 +46,11 @@ public int compare(Format a, Format b) {
    */
   public final String mimeType;
 
+  /**
+   * The codecs used to decode the format, or {@code null} if they are not specified.
+   */
+  public final String codecs;
+
   /**
    * The width of the video in pixels, or -1 for non-video formats.
    */
@@ -98,7 +103,7 @@ public int compare(Format a, Format b) {
    */
   public Format(String id, String mimeType, int width, int height, int numChannels,
       int audioSamplingRate, int bitrate) {
-    this(id, mimeType, width, height, numChannels, audioSamplingRate, bitrate, null);
+    this(id, mimeType, width, height, numChannels, audioSamplingRate, bitrate, null, null);
   }
 
   /**
@@ -113,6 +118,23 @@ public Format(String id, String mimeType, int width, int height, int numChannels
    */
   public Format(String id, String mimeType, int width, int height, int numChannels,
       int audioSamplingRate, int bitrate, String language) {
+    this(id, mimeType, width, height, numChannels, audioSamplingRate, bitrate, language, null);
+  }
+
+
+  /**
+   * @param id The format identifier.
+   * @param mimeType The format mime type.
+   * @param width The width of the video in pixels, or -1 for non-video formats.
+   * @param height The height of the video in pixels, or -1 for non-video formats.
+   * @param numChannels The number of audio channels, or -1 for non-audio formats.
+   * @param audioSamplingRate The audio sampling rate in Hz, or -1 for non-audio formats.
+   * @param bitrate The average bandwidth of the format in bits per second.
+   * @param language The language of the format.
+   * @param codecs The codecs used to decode the format.
+   */
+  public Format(String id, String mimeType, int width, int height, int numChannels,
+      int audioSamplingRate, int bitrate, String language, String codecs) {
     this.id = Assertions.checkNotNull(id);
     this.mimeType = mimeType;
     this.width = width;
@@ -121,6 +143,7 @@ public Format(String id, String mimeType, int width, int height, int numChannels
     this.audioSamplingRate = audioSamplingRate;
     this.bitrate = bitrate;
     this.language = language;
+    this.codecs = codecs;
     this.bandwidth = bitrate / 8;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/Extractor.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/Extractor.java
similarity index 94%
rename from library/src/main/java/com/google/android/exoplayer/parser/Extractor.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/Extractor.java
index 69db87ae42..d501e26bcb 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/Extractor.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser;
+package com.google.android.exoplayer.chunk.parser;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.SampleHolder;
@@ -78,6 +79,11 @@
    */
   public MediaFormat getFormat();
 
+  /**
+   * Returns the duration of the stream in microseconds, or {@link C#UNKNOWN_TIME_US} if unknown.
+   */
+  public long getDurationUs();
+
   /**
    * Returns the pssh information parsed from the stream.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/SegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/SegmentIndex.java
similarity index 97%
rename from library/src/main/java/com/google/android/exoplayer/parser/SegmentIndex.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/SegmentIndex.java
index 614453c1ef..ec68dc125d 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/SegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/SegmentIndex.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser;
+package com.google.android.exoplayer.chunk.parser;
 
 /**
  * Defines segments within a media stream.
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/DefaultSampleValues.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/DefaultSampleValues.java
similarity index 94%
rename from library/src/main/java/com/google/android/exoplayer/parser/mp4/DefaultSampleValues.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/DefaultSampleValues.java
index 5e2e073330..da20828100 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/DefaultSampleValues.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/DefaultSampleValues.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.mp4;
+package com.google.android.exoplayer.chunk.parser.mp4;
 
 /* package */ final class DefaultSampleValues {
 
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/FragmentedMp4Extractor.java
similarity index 58%
rename from library/src/main/java/com/google/android/exoplayer/parser/mp4/FragmentedMp4Extractor.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/FragmentedMp4Extractor.java
index 34f0404083..d6229cf805 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/FragmentedMp4Extractor.java
@@ -13,29 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.mp4;
+package com.google.android.exoplayer.chunk.parser.mp4;
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.parser.Extractor;
-import com.google.android.exoplayer.parser.SegmentIndex;
-import com.google.android.exoplayer.parser.mp4.Atom.ContainerAtom;
-import com.google.android.exoplayer.parser.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer.chunk.parser.Extractor;
+import com.google.android.exoplayer.chunk.parser.SegmentIndex;
+import com.google.android.exoplayer.mp4.Atom;
+import com.google.android.exoplayer.mp4.Atom.ContainerAtom;
+import com.google.android.exoplayer.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer.mp4.CommonMp4AtomParsers;
+import com.google.android.exoplayer.mp4.Mp4Util;
+import com.google.android.exoplayer.mp4.Track;
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil;
-import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
 import android.media.MediaCodec;
 import android.media.MediaExtractor;
-import android.util.Pair;
 
 import java.nio.ByteBuffer;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
@@ -64,14 +64,8 @@
 
   private static final int READ_TERMINATING_RESULTS = RESULT_NEED_MORE_DATA | RESULT_END_OF_STREAM
       | RESULT_READ_SAMPLE | RESULT_NEED_SAMPLE_HOLDER;
-  private static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
-  /** Channel counts for AC-3 audio, indexed by acmod. (See ETSI TS 102 366.) */
-  private static final int[] AC3_CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
-  /** Nominal bit-rates for AC-3 audio in kbps, indexed by bit_rate_code. (See ETSI TS 102 366.) */
-  private static final int[] AC3_BIT_RATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160,
-      192, 224, 256, 320, 384, 448, 512, 576, 640};
 
   // Parser states
   private static final int STATE_READING_ATOM_HEADER = 0;
@@ -79,10 +73,6 @@
   private static final int STATE_READING_ENCRYPTION_DATA = 2;
   private static final int STATE_READING_SAMPLE = 3;
 
-  // Atom data offsets
-  private static final int ATOM_HEADER_SIZE = 8;
-  private static final int FULL_ATOM_HEADER_SIZE = 12;
-
   // Atoms that the parser cares about
   private static final Set<Integer> PARSED_ATOMS;
   static {
@@ -96,6 +86,7 @@
     parsedAtoms.add(Atom.TYPE_moof);
     parsedAtoms.add(Atom.TYPE_moov);
     parsedAtoms.add(Atom.TYPE_mp4a);
+    parsedAtoms.add(Atom.TYPE_mvhd);
     parsedAtoms.add(Atom.TYPE_sidx);
     parsedAtoms.add(Atom.TYPE_stsd);
     parsedAtoms.add(Atom.TYPE_tfdt);
@@ -139,7 +130,6 @@
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
   private final Stack<ContainerAtom> containerAtoms;
-  private final Stack<Integer> containerAtomEndPoints;
   private final TrackFragment fragmentRun;
 
   private int parserState;
@@ -171,10 +161,9 @@ public FragmentedMp4Extractor() {
   public FragmentedMp4Extractor(int workaroundFlags) {
     this.workaroundFlags = workaroundFlags;
     parserState = STATE_READING_ATOM_HEADER;
-    atomHeader = new ParsableByteArray(ATOM_HEADER_SIZE);
+    atomHeader = new ParsableByteArray(Mp4Util.ATOM_HEADER_SIZE);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<ContainerAtom>();
-    containerAtomEndPoints = new Stack<Integer>();
     fragmentRun = new TrackFragment();
     psshData = new HashMap<UUID, byte[]>();
   }
@@ -209,6 +198,11 @@ public MediaFormat getFormat() {
     return track == null ? null : track.mediaFormat;
   }
 
+  @Override
+  public long getDurationUs() {
+    return track == null ? C.UNKNOWN_TIME_US : track.durationUs;
+  }
+
   @Override
   public int read(NonBlockingInputStream inputStream, SampleHolder out)
       throws ParserException {
@@ -226,7 +220,7 @@ public int read(NonBlockingInputStream inputStream, SampleHolder out)
             results |= readEncryptionData(inputStream);
             break;
           default:
-              results |= readOrSkipSample(inputStream, out);
+            results |= readOrSkipSample(inputStream, out);
             break;
         }
       }
@@ -258,7 +252,6 @@ public boolean seekTo(long seekTimeUs, boolean allowNoop) {
       }
     }
     containerAtoms.clear();
-    containerAtomEndPoints.clear();
     enterState(STATE_READING_ATOM_HEADER);
     return true;
   }
@@ -267,7 +260,7 @@ private void enterState(int state) {
     switch (state) {
       case STATE_READING_ATOM_HEADER:
         atomBytesRead = 0;
-        if (containerAtomEndPoints.isEmpty()) {
+        if (containerAtoms.isEmpty()) {
           rootAtomBytesRead = 0;
         }
         break;
@@ -276,14 +269,14 @@ private void enterState(int state) {
   }
 
   private int readAtomHeader(NonBlockingInputStream inputStream) {
-    int remainingBytes = ATOM_HEADER_SIZE - atomBytesRead;
+    int remainingBytes = Mp4Util.ATOM_HEADER_SIZE - atomBytesRead;
     int bytesRead = inputStream.read(atomHeader.data, atomBytesRead, remainingBytes);
     if (bytesRead == -1) {
       return RESULT_END_OF_STREAM;
     }
     rootAtomBytesRead += bytesRead;
     atomBytesRead += bytesRead;
-    if (atomBytesRead != ATOM_HEADER_SIZE) {
+    if (atomBytesRead != Mp4Util.ATOM_HEADER_SIZE) {
       return RESULT_NEED_MORE_DATA;
     }
 
@@ -300,14 +293,15 @@ private int readAtomHeader(NonBlockingInputStream inputStream) {
       return 0;
     }
 
-    if (PARSED_ATOMS.contains(atomType)) {
-      if (CONTAINER_TYPES.contains(atomType)) {
+    Integer atomTypeInteger = atomType; // Avoids boxing atomType twice.
+    if (PARSED_ATOMS.contains(atomTypeInteger)) {
+      if (CONTAINER_TYPES.contains(atomTypeInteger)) {
         enterState(STATE_READING_ATOM_HEADER);
-        containerAtoms.add(new ContainerAtom(atomType));
-        containerAtomEndPoints.add(rootAtomBytesRead + atomSize - ATOM_HEADER_SIZE);
+        containerAtoms.add(new ContainerAtom(atomType,
+            rootAtomBytesRead + atomSize - Mp4Util.ATOM_HEADER_SIZE));
       } else {
         atomData = new ParsableByteArray(atomSize);
-        System.arraycopy(atomHeader.data, 0, atomData.data, 0, ATOM_HEADER_SIZE);
+        System.arraycopy(atomHeader.data, 0, atomData.data, 0, Mp4Util.ATOM_HEADER_SIZE);
         enterState(STATE_READING_ATOM_PAYLOAD);
       }
     } else {
@@ -339,9 +333,7 @@ private int readAtomPayload(NonBlockingInputStream inputStream) {
       results |= onLeafAtomRead(new LeafAtom(atomType, atomData));
     }
 
-    while (!containerAtomEndPoints.isEmpty()
-        && containerAtomEndPoints.peek() == rootAtomBytesRead) {
-      containerAtomEndPoints.pop();
+    while (!containerAtoms.isEmpty() && containerAtoms.peek().endByteOffset == rootAtomBytesRead) {
       results |= onContainerAtomRead(containerAtoms.pop());
     }
 
@@ -372,13 +364,13 @@ private int onContainerAtomRead(ContainerAtom container) {
   }
 
   private void onMoovContainerAtomRead(ContainerAtom moov) {
-    List<Atom> moovChildren = moov.children;
+    List<Atom.LeafAtom> moovChildren = moov.leafChildren;
     int moovChildrenSize = moovChildren.size();
     for (int i = 0; i < moovChildrenSize; i++) {
-      Atom child = moovChildren.get(i);
+      LeafAtom child = moovChildren.get(i);
       if (child.type == Atom.TYPE_pssh) {
-        ParsableByteArray psshAtom = ((LeafAtom) child).data;
-        psshAtom.setPosition(FULL_ATOM_HEADER_SIZE);
+        ParsableByteArray psshAtom = child.data;
+        psshAtom.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
         UUID uuid = new UUID(psshAtom.readLong(), psshAtom.readLong());
         int dataSize = psshAtom.readInt();
         byte[] data = new byte[dataSize];
@@ -388,7 +380,8 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
     }
     ContainerAtom mvex = moov.getContainerAtomOfType(Atom.TYPE_mvex);
     extendsDefaults = parseTrex(mvex.getLeafAtomOfType(Atom.TYPE_trex).data);
-    track = parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak));
+    track = CommonMp4AtomParsers.parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak),
+        moov.getLeafAtomOfType(Atom.TYPE_mvhd));
   }
 
   private void onMoofContainerAtomRead(ContainerAtom moof) {
@@ -413,7 +406,7 @@ private void onMoofContainerAtomRead(ContainerAtom moof) {
    * Parses a trex atom (defined in 14496-12).
    */
   private static DefaultSampleValues parseTrex(ParsableByteArray trex) {
-    trex.setPosition(FULL_ATOM_HEADER_SIZE + 4);
+    trex.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE + 4);
     int defaultSampleDescriptionIndex = trex.readUnsignedIntToInt() - 1;
     int defaultSampleDuration = trex.readUnsignedIntToInt();
     int defaultSampleSize = trex.readUnsignedIntToInt();
@@ -422,385 +415,6 @@ private static DefaultSampleValues parseTrex(ParsableByteArray trex) {
         defaultSampleSize, defaultSampleFlags);
   }
 
-  /**
-   * Parses a trak atom (defined in 14496-12).
-   */
-  private static Track parseTrak(ContainerAtom trak) {
-    ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
-    int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
-    Assertions.checkState(trackType == Track.TYPE_AUDIO || trackType == Track.TYPE_VIDEO);
-
-    Pair<Integer, Long> header = parseTkhd(trak.getLeafAtomOfType(Atom.TYPE_tkhd).data);
-    int id = header.first;
-    // TODO: This value should be used to set a duration field on the Track object
-    // instantiated below, however we've found examples where the value is 0. Revisit whether we
-    // should set it anyway (and just have it be wrong for bad media streams).
-    // long duration = header.second;
-    long timescale = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
-    ContainerAtom stbl = mdia.getContainerAtomOfType(Atom.TYPE_minf)
-        .getContainerAtomOfType(Atom.TYPE_stbl);
-
-    Pair<MediaFormat, TrackEncryptionBox[]> sampleDescriptions =
-        parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data);
-    return new Track(id, trackType, timescale, sampleDescriptions.first, sampleDescriptions.second);
-  }
-
-  /**
-   * Parses a tkhd atom (defined in 14496-12).
-   *
-   * @return A {@link Pair} consisting of the track id and duration (in the timescale indicated in
-   *     the movie header box). The duration is set to -1 if the duration is unspecified.
-   */
-  private static Pair<Integer, Long> parseTkhd(ParsableByteArray tkhd) {
-    tkhd.setPosition(ATOM_HEADER_SIZE);
-    int fullAtom = tkhd.readInt();
-    int version = parseFullAtomVersion(fullAtom);
-
-    tkhd.skip(version == 0 ? 8 : 16);
-
-    int trackId = tkhd.readInt();
-    tkhd.skip(4);
-
-    boolean durationUnknown = true;
-    int durationPosition = tkhd.getPosition();
-    int durationByteCount = version == 0 ? 4 : 8;
-    for (int i = 0; i < durationByteCount; i++) {
-      if (tkhd.data[durationPosition + i] != -1) {
-        durationUnknown = false;
-        break;
-      }
-    }
-    long duration;
-    if (durationUnknown) {
-      tkhd.skip(durationByteCount);
-      duration = -1;
-    } else {
-      duration = version == 0 ? tkhd.readUnsignedInt() : tkhd.readUnsignedLongToLong();
-    }
-
-    return Pair.create(trackId, duration);
-  }
-
-  /**
-   * Parses an hdlr atom (defined in 14496-12).
-   *
-   * @param hdlr The hdlr atom to parse.
-   * @return The track type.
-   */
-  private static int parseHdlr(ParsableByteArray hdlr) {
-    hdlr.setPosition(FULL_ATOM_HEADER_SIZE + 4);
-    return hdlr.readInt();
-  }
-
-  /**
-   * Parses an mdhd atom (defined in 14496-12).
-   *
-   * @param mdhd The mdhd atom to parse.
-   * @return The media timescale, defined as the number of time units that pass in one second.
-   */
-  private static long parseMdhd(ParsableByteArray mdhd) {
-    mdhd.setPosition(ATOM_HEADER_SIZE);
-    int fullAtom = mdhd.readInt();
-    int version = parseFullAtomVersion(fullAtom);
-
-    mdhd.skip(version == 0 ? 8 : 16);
-    return mdhd.readUnsignedInt();
-  }
-
-  private static Pair<MediaFormat, TrackEncryptionBox[]> parseStsd(ParsableByteArray stsd) {
-    stsd.setPosition(FULL_ATOM_HEADER_SIZE);
-    int numberOfEntries = stsd.readInt();
-    MediaFormat mediaFormat = null;
-    TrackEncryptionBox[] trackEncryptionBoxes = new TrackEncryptionBox[numberOfEntries];
-    for (int i = 0; i < numberOfEntries; i++) {
-      int childStartPosition = stsd.getPosition();
-      int childAtomSize = stsd.readInt();
-      int childAtomType = stsd.readInt();
-      if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
-          || childAtomType == Atom.TYPE_encv) {
-        Pair<MediaFormat, TrackEncryptionBox> avc =
-            parseAvcFromParent(stsd, childStartPosition, childAtomSize);
-        mediaFormat = avc.first;
-        trackEncryptionBoxes[i] = avc.second;
-      } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
-          || childAtomType == Atom.TYPE_ac_3) {
-        Pair<MediaFormat, TrackEncryptionBox> audioSampleEntry =
-            parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize);
-        mediaFormat = audioSampleEntry.first;
-        trackEncryptionBoxes[i] = audioSampleEntry.second;
-      }
-      stsd.setPosition(childStartPosition + childAtomSize);
-    }
-    return Pair.create(mediaFormat, trackEncryptionBoxes);
-  }
-
-  private static Pair<MediaFormat, TrackEncryptionBox> parseAvcFromParent(ParsableByteArray parent,
-      int position, int size) {
-    parent.setPosition(position + ATOM_HEADER_SIZE);
-
-    parent.skip(24);
-    int width = parent.readUnsignedShort();
-    int height = parent.readUnsignedShort();
-    float pixelWidthHeightRatio = 1;
-    parent.skip(50);
-
-    List<byte[]> initializationData = null;
-    TrackEncryptionBox trackEncryptionBox = null;
-    int childPosition = parent.getPosition();
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childStartPosition = parent.getPosition();
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_avcC) {
-        initializationData = parseAvcCFromParent(parent, childStartPosition);
-      } else if (childAtomType == Atom.TYPE_sinf) {
-        trackEncryptionBox = parseSinfFromParent(parent, childStartPosition, childAtomSize);
-      } else if (childAtomType == Atom.TYPE_pasp) {
-        pixelWidthHeightRatio = parsePaspFromParent(parent, childStartPosition);
-      }
-      childPosition += childAtomSize;
-    }
-
-    MediaFormat format = MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
-        width, height, pixelWidthHeightRatio, initializationData);
-    return Pair.create(format, trackEncryptionBox);
-  }
-
-  private static Pair<MediaFormat, TrackEncryptionBox> parseAudioSampleEntry(
-      ParsableByteArray parent, int atomType, int position, int size) {
-    parent.setPosition(position + ATOM_HEADER_SIZE);
-    parent.skip(16);
-    int channelCount = parent.readUnsignedShort();
-    int sampleSize = parent.readUnsignedShort();
-    parent.skip(4);
-    int sampleRate = parent.readUnsignedFixedPoint1616();
-    int bitrate = MediaFormat.NO_VALUE;
-
-    byte[] initializationData = null;
-    TrackEncryptionBox trackEncryptionBox = null;
-    int childPosition = parent.getPosition();
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childStartPosition = parent.getPosition();
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (atomType == Atom.TYPE_mp4a || atomType == Atom.TYPE_enca) {
-        if (childAtomType == Atom.TYPE_esds) {
-          initializationData = parseEsdsFromParent(parent, childStartPosition);
-          // TODO: Do we really need to do this? See [Internal: b/10903778]
-          // Update sampleRate and channelCount from the AudioSpecificConfig initialization data.
-          Pair<Integer, Integer> audioSpecificConfig =
-              CodecSpecificDataUtil.parseAudioSpecificConfig(initializationData);
-          sampleRate = audioSpecificConfig.first;
-          channelCount = audioSpecificConfig.second;
-        } else if (childAtomType == Atom.TYPE_sinf) {
-          trackEncryptionBox = parseSinfFromParent(parent, childStartPosition, childAtomSize);
-        }
-      } else if (atomType == Atom.TYPE_ac_3 && childAtomType == Atom.TYPE_dac3) {
-        // TODO: Choose the right AC-3 track based on the contents of dac3/dec3.
-        Ac3Format ac3Format =
-            parseAc3SpecificBoxFromParent(parent, childStartPosition);
-        if (ac3Format != null) {
-          sampleRate = ac3Format.sampleRate;
-          channelCount = ac3Format.channelCount;
-          bitrate = ac3Format.bitrate;
-        }
-
-        // TODO: Add support for encrypted AC-3.
-        trackEncryptionBox = null;
-      } else if (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
-        sampleRate = parseEc3SpecificBoxFromParent(parent, childStartPosition);
-        trackEncryptionBox = null;
-      }
-      childPosition += childAtomSize;
-    }
-
-    String mimeType;
-    if (atomType == Atom.TYPE_ac_3) {
-      mimeType = MimeTypes.AUDIO_AC3;
-    } else if (atomType == Atom.TYPE_ec_3) {
-      mimeType = MimeTypes.AUDIO_EC3;
-    } else {
-      mimeType = MimeTypes.AUDIO_AAC;
-    }
-
-    MediaFormat format = MediaFormat.createAudioFormat(
-        mimeType, sampleSize, channelCount, sampleRate, bitrate,
-        initializationData == null ? null : Collections.singletonList(initializationData));
-    return Pair.create(format, trackEncryptionBox);
-  }
-
-  private static Ac3Format parseAc3SpecificBoxFromParent(ParsableByteArray parent, int position) {
-    // Start of the dac3 atom (defined in ETSI TS 102 366)
-    parent.setPosition(position + ATOM_HEADER_SIZE);
-
-    // fscod (sample rate code)
-    int fscod = (parent.readUnsignedByte() & 0xC0) >> 6;
-    int sampleRate;
-    switch (fscod) {
-      case 0:
-        sampleRate = 48000;
-        break;
-      case 1:
-        sampleRate = 44100;
-        break;
-      case 2:
-        sampleRate = 32000;
-        break;
-      default:
-        // TODO: The decoder should not use this stream.
-        return null;
-    }
-
-    int nextByte = parent.readUnsignedByte();
-
-    // Map acmod (audio coding mode) onto a channel count.
-    int channelCount = AC3_CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
-
-    // lfeon (low frequency effects on)
-    if ((nextByte & 0x04) != 0) {
-      channelCount++;
-    }
-
-    // Map bit_rate_code onto a bit-rate in kbit/s.
-    int bitrate = AC3_BIT_RATES[((nextByte & 0x03) << 3) + (parent.readUnsignedByte() >> 5)];
-
-    return new Ac3Format(channelCount, sampleRate, bitrate);
-  }
-
-  private static int parseEc3SpecificBoxFromParent(ParsableByteArray parent, int position) {
-    // Start of the dec3 atom (defined in ETSI TS 102 366)
-    parent.setPosition(position + ATOM_HEADER_SIZE);
-    // TODO: Implement parsing for enhanced AC-3 with multiple sub-streams.
-    return 0;
-  }
-
-  private static List<byte[]> parseAvcCFromParent(ParsableByteArray parent, int position) {
-    parent.setPosition(position + ATOM_HEADER_SIZE + 4);
-    // Start of the AVCDecoderConfigurationRecord (defined in 14496-15)
-    int nalUnitLength = (parent.readUnsignedByte() & 0x3) + 1;
-    if (nalUnitLength != 4) {
-      // readSample currently relies on a nalUnitLength of 4.
-      // TODO: Consider handling the case where it isn't.
-      throw new IllegalStateException();
-    }
-    List<byte[]> initializationData = new ArrayList<byte[]>();
-    // TODO: We should try and parse these using CodecSpecificDataUtil.parseSpsNalUnit, and
-    // expose the AVC profile and level somewhere useful; Most likely in MediaFormat.
-    int numSequenceParameterSets = parent.readUnsignedByte() & 0x1F;
-    for (int j = 0; j < numSequenceParameterSets; j++) {
-      initializationData.add(parseChildNalUnit(parent));
-    }
-    int numPictureParamterSets = parent.readUnsignedByte();
-    for (int j = 0; j < numPictureParamterSets; j++) {
-      initializationData.add(parseChildNalUnit(parent));
-    }
-    return initializationData;
-  }
-
-  private static byte[] parseChildNalUnit(ParsableByteArray atom) {
-    int length = atom.readUnsignedShort();
-    int offset = atom.getPosition();
-    atom.skip(length);
-    return CodecSpecificDataUtil.buildNalUnit(atom.data, offset, length);
-  }
-
-  private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
-      int size) {
-    int childPosition = position + ATOM_HEADER_SIZE;
-
-    TrackEncryptionBox trackEncryptionBox = null;
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_frma) {
-        parent.readInt(); // dataFormat.
-      } else if (childAtomType == Atom.TYPE_schm) {
-        parent.skip(4);
-        parent.readInt(); // schemeType. Expect cenc
-        parent.readInt(); // schemeVersion. Expect 0x00010000
-      } else if (childAtomType == Atom.TYPE_schi) {
-        trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
-      }
-      childPosition += childAtomSize;
-    }
-
-    return trackEncryptionBox;
-  }
-
-  private static float parsePaspFromParent(ParsableByteArray parent, int position) {
-    parent.setPosition(position + ATOM_HEADER_SIZE);
-    int hSpacing = parent.readUnsignedIntToInt();
-    int vSpacing = parent.readUnsignedIntToInt();
-    return (float) hSpacing / vSpacing;
-  }
-
-  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
-      int size) {
-    int childPosition = position + ATOM_HEADER_SIZE;
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_tenc) {
-        parent.skip(4);
-        int firstInt = parent.readInt();
-        boolean defaultIsEncrypted = (firstInt >> 8) == 1;
-        int defaultInitVectorSize = firstInt & 0xFF;
-        byte[] defaultKeyId = new byte[16];
-        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
-        return new TrackEncryptionBox(defaultIsEncrypted, defaultInitVectorSize, defaultKeyId);
-      }
-      childPosition += childAtomSize;
-    }
-    return null;
-  }
-
-  private static byte[] parseEsdsFromParent(ParsableByteArray parent, int position) {
-    parent.setPosition(position + ATOM_HEADER_SIZE + 4);
-    // Start of the ES_Descriptor (defined in 14496-1)
-    parent.skip(1); // ES_Descriptor tag
-    int varIntByte = parent.readUnsignedByte();
-    while (varIntByte > 127) {
-      varIntByte = parent.readUnsignedByte();
-    }
-    parent.skip(2); // ES_ID
-
-    int flags = parent.readUnsignedByte();
-    if ((flags & 0x80 /* streamDependenceFlag */) != 0) {
-      parent.skip(2);
-    }
-    if ((flags & 0x40 /* URL_Flag */) != 0) {
-      parent.skip(parent.readUnsignedShort());
-    }
-    if ((flags & 0x20 /* OCRstreamFlag */) != 0) {
-      parent.skip(2);
-    }
-
-    // Start of the DecoderConfigDescriptor (defined in 14496-1)
-    parent.skip(1); // DecoderConfigDescriptor tag
-    varIntByte = parent.readUnsignedByte();
-    while (varIntByte > 127) {
-      varIntByte = parent.readUnsignedByte();
-    }
-    parent.skip(13);
-
-    // Start of AudioSpecificConfig (defined in 14496-3)
-    parent.skip(1); // AudioSpecificConfig tag
-    varIntByte = parent.readUnsignedByte();
-    int varInt = varIntByte & 0x7F;
-    while (varIntByte > 127) {
-      varIntByte = parent.readUnsignedByte();
-      varInt = varInt << 8;
-      varInt |= varIntByte & 0x7F;
-    }
-    byte[] initializationData = new byte[varInt];
-    parent.readBytes(initializationData, 0, varInt);
-    return initializationData;
-  }
-
   private static void parseMoof(Track track, DefaultSampleValues extendsDefaults,
       ContainerAtom moof, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch) {
     parseTraf(track, extendsDefaults, moof.getContainerAtomOfType(Atom.TYPE_traf),
@@ -834,11 +448,11 @@ private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
       parseSenc(senc.data, out);
     }
 
-    int childrenSize = traf.children.size();
+    int childrenSize = traf.leafChildren.size();
     for (int i = 0; i < childrenSize; i++) {
-      Atom atom = traf.children.get(i);
+      LeafAtom atom = traf.leafChildren.get(i);
       if (atom.type == Atom.TYPE_uuid) {
-        parseUuid(((LeafAtom) atom).data, out, extendedTypeScratch);
+        parseUuid(atom.data, out, extendedTypeScratch);
       }
     }
   }
@@ -846,9 +460,9 @@ private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
   private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArray saiz,
       TrackFragment out) {
     int vectorSize = encryptionBox.initializationVectorSize;
-    saiz.setPosition(ATOM_HEADER_SIZE);
+    saiz.setPosition(Mp4Util.ATOM_HEADER_SIZE);
     int fullAtom = saiz.readInt();
-    int flags = parseFullAtomFlags(fullAtom);
+    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
     if ((flags & 0x01) == 1) {
       saiz.skip(8);
     }
@@ -883,9 +497,9 @@ private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArra
    */
   private static DefaultSampleValues parseTfhd(DefaultSampleValues extendsDefaults,
       ParsableByteArray tfhd) {
-    tfhd.setPosition(ATOM_HEADER_SIZE);
+    tfhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
     int fullAtom = tfhd.readInt();
-    int flags = parseFullAtomFlags(fullAtom);
+    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
 
     tfhd.skip(4); // trackId
     if ((flags & 0x01 /* base_data_offset_present */) != 0) {
@@ -908,13 +522,13 @@ private static DefaultSampleValues parseTfhd(DefaultSampleValues extendsDefaults
   /**
    * Parses a tfdt atom (defined in 14496-12).
    *
-   * @return baseMediaDecodeTime. The sum of the decode durations of all earlier samples in the
+   * @return baseMediaDecodeTime The sum of the decode durations of all earlier samples in the
    *     media, expressed in the media's timescale.
    */
   private static long parseTfdt(ParsableByteArray tfdt) {
-    tfdt.setPosition(ATOM_HEADER_SIZE);
+    tfdt.setPosition(Mp4Util.ATOM_HEADER_SIZE);
     int fullAtom = tfdt.readInt();
-    int version = parseFullAtomVersion(fullAtom);
+    int version = Mp4Util.parseFullAtomVersion(fullAtom);
     return version == 1 ? tfdt.readUnsignedLongToLong() : tfdt.readUnsignedInt();
   }
 
@@ -929,9 +543,9 @@ private static long parseTfdt(ParsableByteArray tfdt) {
    */
   private static void parseTrun(Track track, DefaultSampleValues defaultSampleValues,
       long decodeTime, int workaroundFlags, ParsableByteArray trun, TrackFragment out) {
-    trun.setPosition(ATOM_HEADER_SIZE);
+    trun.setPosition(Mp4Util.ATOM_HEADER_SIZE);
     int fullAtom = trun.readInt();
-    int flags = parseFullAtomFlags(fullAtom);
+    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
 
     int sampleCount = trun.readUnsignedIntToInt();
     if ((flags & 0x01 /* data_offset_present */) != 0) {
@@ -989,7 +603,7 @@ private static void parseTrun(Track track, DefaultSampleValues defaultSampleValu
 
   private static void parseUuid(ParsableByteArray uuid, TrackFragment out,
       byte[] extendedTypeScratch) {
-    uuid.setPosition(ATOM_HEADER_SIZE);
+    uuid.setPosition(Mp4Util.ATOM_HEADER_SIZE);
     uuid.readBytes(extendedTypeScratch, 0, 16);
 
     // Currently this parser only supports Microsoft's PIFF SampleEncryptionBox.
@@ -1008,9 +622,9 @@ private static void parseSenc(ParsableByteArray senc, TrackFragment out) {
   }
 
   private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment out) {
-    senc.setPosition(ATOM_HEADER_SIZE + offset);
+    senc.setPosition(Mp4Util.ATOM_HEADER_SIZE + offset);
     int fullAtom = senc.readInt();
-    int flags = parseFullAtomFlags(fullAtom);
+    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
 
     if ((flags & 0x01 /* override_track_encryption_box_parameters */) != 0) {
       // TODO: Implement this.
@@ -1024,7 +638,7 @@ private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment
     }
 
     Arrays.fill(out.sampleHasSubsampleEncryptionTable, 0, sampleCount, subsampleEncryption);
-    out.initEncryptionData(senc.length() - senc.getPosition());
+    out.initEncryptionData(senc.bytesLeft());
     out.fillEncryptionData(senc);
   }
 
@@ -1032,9 +646,9 @@ private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment
    * Parses a sidx atom (defined in 14496-12).
    */
   private static SegmentIndex parseSidx(ParsableByteArray atom) {
-    atom.setPosition(ATOM_HEADER_SIZE);
+    atom.setPosition(Mp4Util.ATOM_HEADER_SIZE);
     int fullAtom = atom.readInt();
-    int version = parseFullAtomVersion(fullAtom);
+    int version = Mp4Util.parseFullAtomVersion(fullAtom);
 
     atom.skip(4);
     long timescale = atom.readUnsignedInt();
@@ -1082,7 +696,7 @@ private static SegmentIndex parseSidx(ParsableByteArray atom) {
       offset += sizes[i];
     }
 
-    return new SegmentIndex(atom.length(), sizes, offsets, durationsUs, timesUs);
+    return new SegmentIndex(atom.limit(), sizes, offsets, durationsUs, timesUs);
   }
 
   private int readEncryptionData(NonBlockingInputStream inputStream) {
@@ -1148,7 +762,6 @@ private int skipSample(NonBlockingInputStream inputStream, int sampleSize) {
     return 0;
   }
 
-  @SuppressLint("InlinedApi")
   private int readSample(NonBlockingInputStream inputStream, int sampleSize, SampleHolder out) {
     if (out == null) {
       return RESULT_NEED_SAMPLE_HOLDER;
@@ -1156,7 +769,7 @@ private int readSample(NonBlockingInputStream inputStream, int sampleSize, Sampl
     out.timeUs = fragmentRun.getSamplePresentationTime(sampleIndex) * 1000L;
     out.flags = 0;
     if (fragmentRun.sampleIsSyncFrameTable[sampleIndex]) {
-      out.flags |= MediaExtractor.SAMPLE_FLAG_SYNC;
+      out.flags |= C.SAMPLE_FLAG_SYNC;
       lastSyncSampleIndex = sampleIndex;
     }
     if (out.data == null || out.data.capacity() < sampleSize) {
@@ -1174,17 +787,8 @@ private int readSample(NonBlockingInputStream inputStream, int sampleSize, Sampl
       inputStream.read(outputData, sampleSize);
       if (track.type == Track.TYPE_VIDEO) {
         // The mp4 file contains length-prefixed NAL units, but the decoder wants start code
-        // delimited content. Replace length prefixes with start codes.
-        int sampleOffset = outputData.position() - sampleSize;
-        int position = sampleOffset;
-        while (position < sampleOffset + sampleSize) {
-          outputData.position(position);
-          int length = readUnsignedIntToInt(outputData);
-          outputData.position(position);
-          outputData.put(NAL_START_CODE);
-          position += length + 4;
-        }
-        outputData.position(sampleOffset + sampleSize);
+        // delimited content.
+        Mp4Util.replaceLengthPrefixesWithAvcStartCodes(outputData, sampleSize);
       }
       out.size = sampleSize;
     }
@@ -1234,51 +838,4 @@ private void readSampleEncryptionData(ParsableByteArray sampleEncryptionData, Sa
     }
   }
 
-  /**
-   * Parses the version number out of the additional integer component of a full atom.
-   */
-  private static int parseFullAtomVersion(int fullAtomInt) {
-    return 0x000000FF & (fullAtomInt >> 24);
-  }
-
-  /**
-   * Parses the atom flags out of the additional integer component of a full atom.
-   */
-  private static int parseFullAtomFlags(int fullAtomInt) {
-    return 0x00FFFFFF & fullAtomInt;
-  }
-
-  /**
-   * Reads an unsigned integer into an integer. This method is suitable for use when it can be
-   * assumed that the top bit will always be set to zero.
-   *
-   * @throws IllegalArgumentException If the top bit of the input data is set.
-   */
-  private static int readUnsignedIntToInt(ByteBuffer data) {
-    int result = 0xFF & data.get();
-    for (int i = 1; i < 4; i++) {
-      result <<= 8;
-      result |= 0xFF & data.get();
-    }
-    if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
-    }
-    return result;
-  }
-
-  /** Represents the format for AC-3 audio. */
-  private static final class Ac3Format {
-
-    public final int channelCount;
-    public final int sampleRate;
-    public final int bitrate;
-
-    public Ac3Format(int channelCount, int sampleRate, int bitrate) {
-      this.channelCount = channelCount;
-      this.sampleRate = sampleRate;
-      this.bitrate = bitrate;
-    }
-
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/TrackEncryptionBox.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackEncryptionBox.java
similarity index 96%
rename from library/src/main/java/com/google/android/exoplayer/parser/mp4/TrackEncryptionBox.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackEncryptionBox.java
index 6a300e7230..7615cdd041 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/TrackEncryptionBox.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackEncryptionBox.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.mp4;
+package com.google.android.exoplayer.chunk.parser.mp4;
 
 /**
  * Encapsulates information parsed from a track encryption (tenc) box in an MP4 stream.
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/TrackFragment.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackFragment.java
similarity index 96%
rename from library/src/main/java/com/google/android/exoplayer/parser/mp4/TrackFragment.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackFragment.java
index 4291f5cad4..eb16a87650 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/TrackFragment.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackFragment.java
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.mp4;
+package com.google.android.exoplayer.chunk.parser.mp4;
 
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
+import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
  * A holder for information corresponding to a single fragment of an mp4 file.
@@ -112,7 +113,7 @@ public void initTables(int sampleCount) {
    * @param length The length in bytes of the encryption data.
    */
   public void initEncryptionData(int length) {
-    if (sampleEncryptionData == null || sampleEncryptionData.length() < length) {
+    if (sampleEncryptionData == null || sampleEncryptionData.limit() < length) {
       sampleEncryptionData = new ParsableByteArray(length);
     }
     sampleEncryptionDataLength = length;
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/DefaultEbmlReader.java
similarity index 99%
rename from library/src/main/java/com/google/android/exoplayer/parser/webm/DefaultEbmlReader.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/DefaultEbmlReader.java
index 76235fda47..b0e9c3f237 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/webm/DefaultEbmlReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/DefaultEbmlReader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.webm;
+package com.google.android.exoplayer.chunk.parser.webm;
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/webm/EbmlEventHandler.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlEventHandler.java
similarity index 98%
rename from library/src/main/java/com/google/android/exoplayer/parser/webm/EbmlEventHandler.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlEventHandler.java
index d27cefbc4d..53631f1a86 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/webm/EbmlEventHandler.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlEventHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.webm;
+package com.google.android.exoplayer.chunk.parser.webm;
 
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/webm/EbmlReader.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlReader.java
similarity index 98%
rename from library/src/main/java/com/google/android/exoplayer/parser/webm/EbmlReader.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlReader.java
index 955d19f19d..1c6dd0178c 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/webm/EbmlReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlReader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.webm;
+package com.google.android.exoplayer.chunk.parser.webm;
 
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/WebmExtractor.java
similarity index 87%
rename from library/src/main/java/com/google/android/exoplayer/parser/webm/WebmExtractor.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/WebmExtractor.java
index 3402fb26f5..ddf15e5610 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/WebmExtractor.java
@@ -13,20 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.webm;
+package com.google.android.exoplayer.chunk.parser.webm;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.parser.Extractor;
-import com.google.android.exoplayer.parser.SegmentIndex;
+import com.google.android.exoplayer.chunk.parser.Extractor;
+import com.google.android.exoplayer.chunk.parser.SegmentIndex;
 import com.google.android.exoplayer.upstream.NonBlockingInputStream;
 import com.google.android.exoplayer.util.LongArray;
 import com.google.android.exoplayer.util.MimeTypes;
 
-import android.annotation.TargetApi;
-import android.media.MediaExtractor;
-
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -41,13 +39,14 @@
  * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
  * More info about WebM is <a href="http://www.webmproject.org/code/specs/container/">here</a>.
  */
-@TargetApi(16)
 public final class WebmExtractor implements Extractor {
 
   private static final String DOC_TYPE_WEBM = "webm";
   private static final String CODEC_ID_VP9 = "V_VP9";
   private static final String CODEC_ID_VORBIS = "A_VORBIS";
+  private static final String CODEC_ID_OPUS = "A_OPUS";
   private static final int VORBIS_MAX_INPUT_SIZE = 8192;
+  private static final int OPUS_MAX_INPUT_SIZE = 5760;
   private static final int UNKNOWN = -1;
 
   // Element IDs
@@ -65,11 +64,15 @@
   private static final int ID_CLUSTER = 0x1F43B675;
   private static final int ID_TIME_CODE = 0xE7;
   private static final int ID_SIMPLE_BLOCK = 0xA3;
+  private static final int ID_BLOCK_GROUP = 0xA0;
+  private static final int ID_BLOCK = 0xA1;
 
   private static final int ID_TRACKS = 0x1654AE6B;
   private static final int ID_TRACK_ENTRY = 0xAE;
   private static final int ID_CODEC_ID = 0x86;
   private static final int ID_CODEC_PRIVATE = 0x63A2;
+  private static final int ID_CODEC_DELAY = 0x56AA;
+  private static final int ID_SEEK_PRE_ROLL = 0x56BB;
   private static final int ID_VIDEO = 0xE0;
   private static final int ID_PIXEL_WIDTH = 0xB0;
   private static final int ID_PIXEL_HEIGHT = 0xBA;
@@ -107,6 +110,9 @@
   private int channelCount = UNKNOWN;
   private int sampleRate = UNKNOWN;
   private byte[] codecPrivate;
+  private String codecId;
+  private long codecDelayNs;
+  private long seekPreRollNs;
   private boolean seenAudioTrack;
   private long cuesSizeBytes = UNKNOWN;
   private long clusterTimecodeUs = UNKNOWN;
@@ -175,6 +181,11 @@ public MediaFormat getFormat() {
     return format;
   }
 
+  @Override
+  public long getDurationUs() {
+    return durationUs == UNKNOWN ? C.UNKNOWN_TIME_US : durationUs;
+  }
+
   @Override
   public Map<UUID, byte[]> getPsshInfo() {
     // TODO: Parse pssh data from Webm streams.
@@ -194,6 +205,7 @@ public MediaFormat getFormat() {
       case ID_CUES:
       case ID_CUE_POINT:
       case ID_CUE_TRACK_POSITIONS:
+      case ID_BLOCK_GROUP:
         return EbmlReader.TYPE_MASTER;
       case ID_EBML_READ_VERSION:
       case ID_DOC_TYPE_READ_VERSION:
@@ -201,6 +213,8 @@ public MediaFormat getFormat() {
       case ID_TIME_CODE:
       case ID_PIXEL_WIDTH:
       case ID_PIXEL_HEIGHT:
+      case ID_CODEC_DELAY:
+      case ID_SEEK_PRE_ROLL:
       case ID_CHANNELS:
       case ID_CUE_TIME:
       case ID_CUE_CLUSTER_POSITION:
@@ -209,6 +223,7 @@ public MediaFormat getFormat() {
       case ID_CODEC_ID:
         return EbmlReader.TYPE_STRING;
       case ID_SIMPLE_BLOCK:
+      case ID_BLOCK:
       case ID_CODEC_PRIVATE:
         return EbmlReader.TYPE_BINARY;
       case ID_DURATION:
@@ -287,6 +302,12 @@ public MediaFormat getFormat() {
       case ID_PIXEL_HEIGHT:
         pixelHeight = (int) value;
         break;
+      case ID_CODEC_DELAY:
+        codecDelayNs = value;
+        break;
+      case ID_SEEK_PRE_ROLL:
+        seekPreRollNs = value;
+        break;
       case ID_CHANNELS:
         channelCount = (int) value;
         break;
@@ -329,9 +350,10 @@ public MediaFormat getFormat() {
         break;
       case ID_CODEC_ID:
         // Validate that CodecID is supported. This extractor only supports "V_VP9" and "A_VORBIS".
-        if (!CODEC_ID_VP9.equals(value) && !CODEC_ID_VORBIS.equals(value)) {
+        if (!isCodecSupported(value)) {
           throw new ParserException("CodecID " + value + " not supported");
         }
+        codecId = value;
         break;
       default:
         // pass
@@ -344,8 +366,11 @@ public MediaFormat getFormat() {
       NonBlockingInputStream inputStream) throws ParserException {
     switch (id) {
       case ID_SIMPLE_BLOCK:
+      case ID_BLOCK:
         // Please refer to http://www.matroska.org/technical/specs/index.html#simpleblock_structure
-        // for info about how data is organized in a SimpleBlock element.
+        // and http://matroska.org/technical/specs/index.html#block_structure
+        // for info about how data is organized in SimpleBlock and Block elements respectively. They
+        // differ only in the way flags are specified.
 
         // If we don't have a sample holder then don't consume the data.
         if (sampleHolder == null) {
@@ -365,7 +390,16 @@ public MediaFormat getFormat() {
         long timecodeUs = scaleTimecodeToUs(timecode);
 
         // Last byte of the three has some flags and the lacing value.
-        boolean keyframe = (simpleBlockTimecodeAndFlags[2] & 0x80) == 0x80;
+        boolean keyframe;
+        if (id == ID_BLOCK) {
+          // Matroska Block element does not self-sufficiently say whether it is a key frame or not.
+          // It depends on the existence of another element (ReferenceBlock) which may occur after
+          // the Block element. Since this extractor uses Block element only for Opus, we set the
+          // keyframe to be true always since all Opus frames are key frames.
+          keyframe = true;
+        } else {
+          keyframe = (simpleBlockTimecodeAndFlags[2] & 0x80) == 0x80;
+        }
         boolean invisible = (simpleBlockTimecodeAndFlags[2] & 0x08) == 0x08;
         int lacing = (simpleBlockTimecodeAndFlags[2] & 0x06) >> 1;
 
@@ -374,7 +408,7 @@ public MediaFormat getFormat() {
           case LACING_NONE:
             long elementEndOffsetBytes = elementOffsetBytes + headerSizeBytes + contentsSizeBytes;
             simpleBlockTimecodeUs = clusterTimecodeUs + timecodeUs;
-            sampleHolder.flags = keyframe ? MediaExtractor.SAMPLE_FLAG_SYNC : 0;
+            sampleHolder.flags = keyframe ? C.SAMPLE_FLAG_SYNC : 0;
             sampleHolder.decodeOnly = invisible;
             sampleHolder.timeUs = clusterTimecodeUs + timecodeUs;
             sampleHolder.size = (int) (elementEndOffsetBytes - reader.getBytesRead());
@@ -413,6 +447,12 @@ private long scaleTimecodeToUs(long unscaledTimecode) {
     return TimeUnit.NANOSECONDS.toMicros(unscaledTimecode * timecodeScale);
   }
 
+  private boolean isCodecSupported(String codecId) {
+    return CODEC_ID_VP9.equals(codecId)
+        || CODEC_ID_OPUS.equals(codecId)
+        || CODEC_ID_VORBIS.equals(codecId);
+  }
+
   /**
    * Build a video {@link MediaFormat} containing recently gathered Video information, if needed.
    *
@@ -444,9 +484,19 @@ private void buildAudioFormat() throws ParserException {
     if (channelCount != UNKNOWN && sampleRate != UNKNOWN
         && (format == null || format.channelCount != channelCount
             || format.sampleRate != sampleRate)) {
-      format = MediaFormat.createAudioFormat(
-          MimeTypes.AUDIO_VORBIS, VORBIS_MAX_INPUT_SIZE,
-          sampleRate, channelCount, parseVorbisCodecPrivate());
+      if (CODEC_ID_VORBIS.equals(codecId)) {
+        format = MediaFormat.createAudioFormat(
+            MimeTypes.AUDIO_VORBIS, VORBIS_MAX_INPUT_SIZE,
+            channelCount, sampleRate, parseVorbisCodecPrivate());
+      } else if (CODEC_ID_OPUS.equals(codecId)) {
+        ArrayList<byte[]> opusInitializationData = new ArrayList<byte[]>(3);
+        opusInitializationData.add(codecPrivate);
+        opusInitializationData.add(ByteBuffer.allocate(Long.SIZE).putLong(codecDelayNs).array());
+        opusInitializationData.add(ByteBuffer.allocate(Long.SIZE).putLong(seekPreRollNs).array());
+        format = MediaFormat.createAudioFormat(
+            MimeTypes.AUDIO_OPUS, OPUS_MAX_INPUT_SIZE, channelCount, sampleRate,
+            opusInitializationData);
+      }
       readResults |= RESULT_READ_INIT;
     } else if (format == null) {
       throw new ParserException("Unable to build format");
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 932a8ea598..2a1d768048 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -23,22 +23,22 @@
 import com.google.android.exoplayer.chunk.Chunk;
 import com.google.android.exoplayer.chunk.ChunkOperationHolder;
 import com.google.android.exoplayer.chunk.ChunkSource;
+import com.google.android.exoplayer.chunk.ContainerMediaChunk;
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.Format.DecreasingBandwidthComparator;
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.Evaluation;
 import com.google.android.exoplayer.chunk.MediaChunk;
-import com.google.android.exoplayer.chunk.Mp4MediaChunk;
 import com.google.android.exoplayer.chunk.SingleSampleMediaChunk;
+import com.google.android.exoplayer.chunk.parser.Extractor;
+import com.google.android.exoplayer.chunk.parser.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer.chunk.parser.webm.WebmExtractor;
 import com.google.android.exoplayer.dash.mpd.AdaptationSet;
 import com.google.android.exoplayer.dash.mpd.ContentProtection;
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
 import com.google.android.exoplayer.dash.mpd.Period;
 import com.google.android.exoplayer.dash.mpd.RangedUri;
 import com.google.android.exoplayer.dash.mpd.Representation;
-import com.google.android.exoplayer.parser.Extractor;
-import com.google.android.exoplayer.parser.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer.parser.webm.WebmExtractor;
 import com.google.android.exoplayer.text.webvtt.WebvttParser;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
@@ -326,10 +326,30 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       return;
     }
 
+    // TODO: Use UtcTimingElement where possible.
+    long nowUs = System.currentTimeMillis() * 1000;
+
+    int firstAvailableSegmentNum = segmentIndex.getFirstSegmentNum();
+    int lastAvailableSegmentNum = segmentIndex.getLastSegmentNum();
+    boolean indexUnbounded = lastAvailableSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED;
+    if (indexUnbounded) {
+      // The index is itself unbounded. We need to use the current time to calculate the range of
+      // available segments.
+      long liveEdgeTimestampUs = nowUs - currentManifest.availabilityStartTime * 1000;
+      if (currentManifest.timeShiftBufferDepth != -1) {
+        long bufferDepthUs = currentManifest.timeShiftBufferDepth * 1000;
+        firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
+            segmentIndex.getSegmentNum(liveEdgeTimestampUs - bufferDepthUs));
+      }
+      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
+      // index of the last completed segment.
+      lastAvailableSegmentNum = segmentIndex.getSegmentNum(liveEdgeTimestampUs) - 1;
+    }
+
     int segmentNum;
     if (queue.isEmpty()) {
       if (currentManifest.dynamic) {
-        seekPositionUs = getLiveSeekPosition();
+        seekPositionUs = getLiveSeekPosition(nowUs, indexUnbounded, segmentIndex.isExplicit());
       }
       segmentNum = segmentIndex.getSegmentNum(seekPositionUs);
     } else {
@@ -338,17 +358,19 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
     }
 
     if (currentManifest.dynamic) {
-      if (segmentNum < segmentIndex.getFirstSegmentNum()) {
+      if (segmentNum < firstAvailableSegmentNum) {
         // This is before the first chunk in the current manifest.
         fatalError = new BehindLiveWindowException();
         return;
-      } else if (segmentNum > segmentIndex.getLastSegmentNum()) {
-        // This is beyond the last chunk in the current manifest.
-        finishedCurrentManifest = true;
+      } else if (segmentNum > lastAvailableSegmentNum) {
+        // This chunk is beyond the last chunk in the current manifest. If the index is bounded
+        // we'll need to refresh it. If it's unbounded we just need to wait for a while before
+        // attempting to load the chunk.
+        finishedCurrentManifest = !indexUnbounded;
         return;
-      } else if (segmentNum == segmentIndex.getLastSegmentNum()) {
-        // This is the last chunk in the current manifest. Mark the manifest as being finished,
-        // but continue to return the final chunk.
+      } else if (!indexUnbounded && segmentNum == lastAvailableSegmentNum) {
+        // This is the last chunk in a dynamic bounded manifest. We'll need to refresh the manifest
+        // to obtain the next chunk.
         finishedCurrentManifest = true;
       }
     }
@@ -429,7 +451,7 @@ private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSourc
     DataSpec dataSpec = new DataSpec(segmentUri.getUri(), segmentUri.start, segmentUri.length,
         representation.getCacheKey());
 
-    long presentationTimeOffsetUs = representation.presentationTimeOffsetMs * 1000;
+    long presentationTimeOffsetUs = representation.presentationTimeOffsetUs;
     if (representation.format.mimeType.equals(MimeTypes.TEXT_VTT)) {
       if (representationHolder.vttHeaderOffsetUs != presentationTimeOffsetUs) {
         // Update the VTT header.
@@ -442,9 +464,9 @@ private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSourc
       return new SingleSampleMediaChunk(dataSource, dataSpec, representation.format, 0,
           startTimeUs, endTimeUs, nextAbsoluteSegmentNum, null, representationHolder.vttHeader);
     } else {
-      return new Mp4MediaChunk(dataSource, dataSpec, representation.format, trigger, startTimeUs,
-          endTimeUs, nextAbsoluteSegmentNum, representationHolder.extractor, psshInfo, false,
-          presentationTimeOffsetUs);
+      return new ContainerMediaChunk(dataSource, dataSpec, representation.format, trigger,
+          startTimeUs, endTimeUs, nextAbsoluteSegmentNum, representationHolder.extractor, psshInfo,
+          false, presentationTimeOffsetUs);
     }
   }
 
@@ -452,16 +474,30 @@ private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSourc
    * For live playbacks, determines the seek position that snaps playback to be
    * {@link #liveEdgeLatencyUs} behind the live edge of the current manifest
    *
+   * @param nowUs An estimate of the current server time, in microseconds.
+   * @param indexUnbounded True if the segment index for this source is unbounded. False otherwise.
+   * @param indexExplicit True if the segment index is explicit. False otherwise.
    * @return The seek position in microseconds.
    */
-  private long getLiveSeekPosition() {
-    long liveEdgeTimestampUs = Long.MIN_VALUE;
-    for (RepresentationHolder representationHolder : representationHolders.values()) {
-      DashSegmentIndex segmentIndex = representationHolder.segmentIndex;
-      int lastSegmentNum = segmentIndex.getLastSegmentNum();
-      long indexLiveEdgeTimestampUs = segmentIndex.getTimeUs(lastSegmentNum)
-          + segmentIndex.getDurationUs(lastSegmentNum);
-      liveEdgeTimestampUs = Math.max(liveEdgeTimestampUs, indexLiveEdgeTimestampUs);
+  private long getLiveSeekPosition(long nowUs, boolean indexUnbounded, boolean indexExplicit) {
+    long liveEdgeTimestampUs;
+    if (indexUnbounded) {
+      liveEdgeTimestampUs = nowUs - currentManifest.availabilityStartTime * 1000;
+    } else {
+      liveEdgeTimestampUs = Long.MIN_VALUE;
+      for (RepresentationHolder representationHolder : representationHolders.values()) {
+        DashSegmentIndex segmentIndex = representationHolder.segmentIndex;
+        int lastSegmentNum = segmentIndex.getLastSegmentNum();
+        long indexLiveEdgeTimestampUs = segmentIndex.getTimeUs(lastSegmentNum)
+            + segmentIndex.getDurationUs(lastSegmentNum);
+        liveEdgeTimestampUs = Math.max(liveEdgeTimestampUs, indexLiveEdgeTimestampUs);
+      }
+      if (!indexExplicit) {
+        // Some segments defined by the index may not be available yet. Bound the calculated live
+        // edge based on the elapsed time since the manifest became available.
+        liveEdgeTimestampUs = Math.min(liveEdgeTimestampUs,
+            nowUs - currentManifest.availabilityStartTime * 1000);
+      }
     }
     return liveEdgeTimestampUs - liveEdgeLatencyUs;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashSegmentIndex.java
index 336e4c6057..e922757e13 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashSegmentIndex.java
@@ -24,8 +24,15 @@
  */
 public interface DashSegmentIndex {
 
+  public static final int INDEX_UNBOUNDED = -1;
+
   /**
    * Returns the segment number of the segment containing a given media time.
+   * <p>
+   * If the given media time is outside the range of the index, then the returned segment number is
+   * clamped to {@link #getFirstSegmentNum()} (if the given media time is earlier the start of the
+   * first segment) or {@link #getLastSegmentNum()} (if the given media time is later then the end
+   * of the last segment).
    *
    * @param timeUs The time in microseconds.
    * @return The segment number of the corresponding segment.
@@ -64,10 +71,30 @@
   int getFirstSegmentNum();
 
   /**
-   * Returns the segment number of the last segment.
+   * Returns the segment number of the last segment, or {@link #INDEX_UNBOUNDED}.
+   * <p>
+   * An unbounded index occurs if a live stream manifest uses SegmentTemplate elements without a
+   * SegmentTimeline element. In this case the manifest can be used to derive information about
+   * segments arbitrarily far into the future. This means that the manifest does not need to be
+   * refreshed as frequently (if at all) during playback, however it is necessary for a player to
+   * manually calculate the window of currently available segments.
    *
-   * @return The segment number of the last segment.
+   * @return The segment number of the last segment, or {@link #INDEX_UNBOUNDED}.
    */
   int getLastSegmentNum();
 
+  /**
+   * Returns true if segments are defined explicitly by the index.
+   * <p>
+   * If true is returned, each segment is defined explicitly by the index data, and all of the
+   * listed segments are guaranteed to be available at the time when the index was obtained.
+   * <p>
+   * If false is returned then segment information was derived from properties such as a fixed
+   * segment duration. If the presentation is dynamic, it's possible that only a subset of the
+   * segments are available.
+   *
+   * @return True if segments are defined explicitly by the index. False otherwise.
+   */
+  boolean isExplicit();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashSingleSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashSingleSegmentIndex.java
new file mode 100644
index 0000000000..46a02a3ea2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashSingleSegmentIndex.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash;
+
+import com.google.android.exoplayer.dash.mpd.RangedUri;
+
+/**
+ * A {@link DashSegmentIndex} that defines a single segment.
+ */
+public class DashSingleSegmentIndex implements DashSegmentIndex {
+
+  private final long startTimeUs;
+  private final long durationUs;
+  private final RangedUri uri;
+
+  /**
+   * @param startTimeUs The start time of the segment, in microseconds.
+   * @param durationUs The duration of the segment, in microseconds.
+   * @param uri A {@link RangedUri} defining the location of the segment data.
+   */
+  public DashSingleSegmentIndex(long startTimeUs, long durationUs, RangedUri uri) {
+    this.startTimeUs = startTimeUs;
+    this.durationUs = durationUs;
+    this.uri = uri;
+  }
+
+  @Override
+  public int getSegmentNum(long timeUs) {
+    return 0;
+  }
+
+  @Override
+  public long getTimeUs(int segmentNum) {
+    return startTimeUs;
+  }
+
+  @Override
+  public long getDurationUs(int segmentNum) {
+    return durationUs;
+  }
+
+  @Override
+  public RangedUri getSegmentUrl(int segmentNum) {
+    return uri;
+  }
+
+  @Override
+  public int getFirstSegmentNum() {
+    return 0;
+  }
+
+  @Override
+  public int getLastSegmentNum() {
+    return 0;
+  }
+
+  @Override
+  public boolean isExplicit() {
+    return true;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
index 3d0bb0913a..44648469af 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer.dash;
 
+import com.google.android.exoplayer.chunk.parser.SegmentIndex;
 import com.google.android.exoplayer.dash.mpd.RangedUri;
-import com.google.android.exoplayer.parser.SegmentIndex;
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
@@ -74,4 +74,9 @@ public int getSegmentNum(long timeUs) {
     return Util.binarySearchFloor(segmentIndex.timesUs, timeUs, true, true);
   }
 
+  @Override
+  public boolean isExplicit() {
+    return true;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index a8ed7c03f2..67806bbb68 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -283,6 +283,7 @@ protected Representation parseRepresentation(XmlPullParser xpp, String contentId
     int width = parseInt(xpp, "width");
     int height = parseInt(xpp, "height");
     mimeType = parseString(xpp, "mimeType", mimeType);
+    String codecs = parseString(xpp, "codecs", null);
 
     int numChannels = -1;
     do {
@@ -302,15 +303,15 @@ protected Representation parseRepresentation(XmlPullParser xpp, String contentId
     } while (!isEndTag(xpp, "Representation"));
 
     Format format = buildFormat(id, mimeType, width, height, numChannels, audioSamplingRate,
-        bandwidth, language);
+        bandwidth, language, codecs);
     return buildRepresentation(periodStartMs, periodDurationMs, contentId, -1, format,
-        segmentBase);
+        segmentBase != null ? segmentBase : new SingleSegmentBase(baseUrl));
   }
 
   protected Format buildFormat(String id, String mimeType, int width, int height, int numChannels,
-      int audioSamplingRate, int bandwidth, String language) {
-    return new Format(id, mimeType, width, height, numChannels, audioSamplingRate,
-        bandwidth, language);
+      int audioSamplingRate, int bandwidth, String language, String codecs) {
+    return new Format(id, mimeType, width, height, numChannels, audioSamplingRate, bandwidth,
+        language, codecs);
   }
 
   protected Representation buildRepresentation(long periodStartMs, long periodDurationMs,
@@ -356,7 +357,7 @@ protected SingleSegmentBase buildSingleSegmentBase(RangedUri initialization, lon
   }
 
   protected SegmentList parseSegmentList(XmlPullParser xpp, Uri baseUrl, SegmentList parent,
-      long periodDuration) throws XmlPullParserException, IOException {
+      long periodDurationMs) throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
@@ -388,19 +389,19 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, Uri baseUrl, SegmentLi
       segments = segments != null ? segments : parent.mediaSegments;
     }
 
-    return buildSegmentList(initialization, timescale, presentationTimeOffset, periodDuration,
+    return buildSegmentList(initialization, timescale, presentationTimeOffset, periodDurationMs,
         startNumber, duration, timeline, segments);
   }
 
   protected SegmentList buildSegmentList(RangedUri initialization, long timescale,
-      long presentationTimeOffset, long periodDuration, int startNumber, long duration,
+      long presentationTimeOffset, long periodDurationMs, int startNumber, long duration,
       List<SegmentTimelineElement> timeline, List<RangedUri> segments) {
-    return new SegmentList(initialization, timescale, presentationTimeOffset, periodDuration,
+    return new SegmentList(initialization, timescale, presentationTimeOffset, periodDurationMs,
         startNumber, duration, timeline, segments);
   }
 
   protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, Uri baseUrl,
-      SegmentTemplate parent, long periodDuration) throws XmlPullParserException, IOException {
+      SegmentTemplate parent, long periodDurationMs) throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
@@ -429,15 +430,15 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, Uri baseUrl,
       timeline = timeline != null ? timeline : parent.segmentTimeline;
     }
 
-    return buildSegmentTemplate(initialization, timescale, presentationTimeOffset, periodDuration,
+    return buildSegmentTemplate(initialization, timescale, presentationTimeOffset, periodDurationMs,
         startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
   }
 
   protected SegmentTemplate buildSegmentTemplate(RangedUri initialization, long timescale,
-      long presentationTimeOffset, long periodDuration, int startNumber, long duration,
+      long presentationTimeOffset, long periodDurationMs, int startNumber, long duration,
       List<SegmentTimelineElement> timeline, UrlTemplate initializationTemplate,
       UrlTemplate mediaTemplate, Uri baseUrl) {
-    return new SegmentTemplate(initialization, timescale, presentationTimeOffset, periodDuration,
+    return new SegmentTemplate(initialization, timescale, presentationTimeOffset, periodDurationMs,
         startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
index d089ba7f59..afae71de23 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.dash.DashSegmentIndex;
+import com.google.android.exoplayer.dash.DashSingleSegmentIndex;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.MultiSegmentBase;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
 
@@ -63,7 +64,7 @@
   /**
    * The offset of the presentation timestamps in the media stream relative to media time.
    */
-  public final long presentationTimeOffsetMs;
+  public final long presentationTimeOffsetUs;
 
   private final RangedUri initializationUri;
 
@@ -101,7 +102,7 @@ private Representation(long periodStartMs, long periodDurationMs, String content
     this.revisionId = revisionId;
     this.format = format;
     initializationUri = segmentBase.getInitialization(this);
-    presentationTimeOffsetMs = (segmentBase.presentationTimeOffset * 1000) / segmentBase.timescale;
+    presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
 
   /**
@@ -156,6 +157,7 @@ public String getCacheKey() {
     public final long contentLength;
 
     private final RangedUri indexUri;
+    private final DashSingleSegmentIndex segmentIndex;
 
     /**
      * @param periodStartMs The start time of the enclosing period in milliseconds.
@@ -198,6 +200,10 @@ public SingleSegmentRepresentation(long periodStartMs, long periodDurationMs, St
       this.uri = segmentBase.uri;
       this.indexUri = segmentBase.getIndex();
       this.contentLength = contentLength;
+      // If we have an index uri then the index is defined externally, and we shouldn't return one
+      // directly. If we don't, then we can't do better than an index defining a single segment.
+      segmentIndex = indexUri != null ? null : new DashSingleSegmentIndex(periodStartMs * 1000,
+          periodDurationMs * 1000, new RangedUri(uri, null, 0, -1));
     }
 
     @Override
@@ -207,7 +213,7 @@ public RangedUri getIndexUri() {
 
     @Override
     public DashSegmentIndex getIndex() {
-      return null;
+      return segmentIndex;
     }
 
   }
@@ -277,6 +283,11 @@ public int getLastSegmentNum() {
       return segmentBase.getLastSegmentNum();
     }
 
+    @Override
+    public boolean isExplicit() {
+      return segmentBase.isExplicit();
+    }
+
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
index a7393865f7..f93ce33743 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.dash.mpd;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.dash.DashSegmentIndex;
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
@@ -55,6 +56,15 @@ public RangedUri getInitialization(Representation representation) {
     return initialization;
   }
 
+  /**
+   * Gets the presentation time offset, in microseconds.
+   *
+   * @return The presentation time offset, in microseconds.
+   */
+  public long getPresentationTimeOffsetUs() {
+    return Util.scaleLargeTimestamp(presentationTimeOffset, C.MICROS_PER_SECOND, timescale);
+  }
+
   /**
    * A {@link SegmentBase} that defines a single segment.
    */
@@ -86,8 +96,15 @@ public SingleSegmentBase(RangedUri initialization, long timescale, long presenta
       this.indexLength = indexLength;
     }
 
+    /**
+     * @param uri The uri of the segment.
+     */
+    public SingleSegmentBase(Uri uri) {
+      this(null, 1, 0, uri, 0, -1);
+    }
+
     public RangedUri getIndex() {
-      return new RangedUri(uri, null, indexStart, indexLength);
+      return indexLength <= 0 ? null : new RangedUri(uri, null, indexStart, indexLength);
     }
 
   }
@@ -127,19 +144,40 @@ public MultiSegmentBase(RangedUri initialization, long timescale, long presentat
       this.segmentTimeline = segmentTimeline;
     }
 
-    public final int getSegmentNum(long timeUs) {
-      // TODO: Optimize this
-      int index = startNumber;
-      while (index + 1 <= getLastSegmentNum()) {
-        if (getSegmentTimeUs(index + 1) <= timeUs) {
-          index++;
-        } else {
-          return index;
+    /**
+     * @see DashSegmentIndex#getSegmentNum(long)
+     */
+    public int getSegmentNum(long timeUs) {
+      int lowIndex = getFirstSegmentNum();
+      int highIndex = getLastSegmentNum();
+      if (segmentTimeline == null) {
+        // All segments are of equal duration (with the possible exception of the last one).
+        long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
+        int segmentNum = startNumber + (int) (timeUs / durationUs);
+        // Ensure we stay within bounds.
+        return segmentNum < lowIndex ? lowIndex
+            : highIndex != DashSegmentIndex.INDEX_UNBOUNDED && segmentNum > highIndex ? highIndex
+            : segmentNum;
+      } else {
+        // The high index cannot be unbounded. Identify the segment using binary search.
+        while (lowIndex <= highIndex) {
+          int midIndex = (lowIndex + highIndex) / 2;
+          long midTimeUs = getSegmentTimeUs(midIndex);
+          if (midTimeUs < timeUs) {
+            lowIndex = midIndex + 1;
+          } else if (midTimeUs > timeUs) {
+            highIndex = midIndex - 1;
+          } else {
+            return midIndex;
+          }
         }
+        return lowIndex - 1;
       }
-      return index;
     }
 
+    /**
+     * @see DashSegmentIndex#getDurationUs(int)
+     */
     public final long getSegmentDurationUs(int sequenceNumber) {
       if (segmentTimeline != null) {
         long duration = segmentTimeline.get(sequenceNumber - startNumber).duration;
@@ -151,6 +189,9 @@ public final long getSegmentDurationUs(int sequenceNumber) {
       }
     }
 
+    /**
+     * @see DashSegmentIndex#getTimeUs(int)
+     */
     public final long getSegmentTimeUs(int sequenceNumber) {
       long unscaledSegmentTime;
       if (segmentTimeline != null) {
@@ -162,14 +203,33 @@ public final long getSegmentTimeUs(int sequenceNumber) {
       return Util.scaleLargeTimestamp(unscaledSegmentTime, C.MICROS_PER_SECOND, timescale);
     }
 
+    /**
+     * Returns a {@link RangedUri} defining the location of a segment for the given index in the
+     * given representation.
+     *
+     * @see DashSegmentIndex#getSegmentUrl(int)
+     */
     public abstract RangedUri getSegmentUrl(Representation representation, int index);
 
+    /**
+     * @see DashSegmentIndex#getFirstSegmentNum()
+     */
     public int getFirstSegmentNum() {
       return startNumber;
     }
 
+    /**
+     * @see DashSegmentIndex#getLastSegmentNum()
+     */
     public abstract int getLastSegmentNum();
 
+    /**
+     * @see DashSegmentIndex#isExplicit()
+     */
+    public boolean isExplicit() {
+      return segmentTimeline != null;
+    }
+
   }
 
   /**
@@ -213,6 +273,11 @@ public int getLastSegmentNum() {
       return startNumber + mediaSegments.size() - 1;
     }
 
+    @Override
+    public boolean isExplicit() {
+      return true;
+    }
+
   }
 
   /**
@@ -285,9 +350,11 @@ public RangedUri getSegmentUrl(Representation representation, int sequenceNumber
     public int getLastSegmentNum() {
       if (segmentTimeline != null) {
         return segmentTimeline.size() + startNumber - 1;
+      } else if (periodDurationMs == -1) {
+        return DashSegmentIndex.INDEX_UNBOUNDED;
       } else {
         long durationMs = (duration * 1000) / timescale;
-        return startNumber + (int) (periodDurationMs / durationMs);
+        return startNumber + (int) ((periodDurationMs + durationMs - 1) / durationMs) - 1;
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/DataChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/DataChunk.java
new file mode 100644
index 0000000000..04d1bc2728
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/DataChunk.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * An abstract base class for {@link HlsChunk} implementations where the data should be loaded into
+ * a {@code byte[]} before being consumed.
+ */
+public abstract class DataChunk extends HlsChunk {
+
+  private static final int READ_GRANULARITY = 16 * 1024;
+
+  private byte[] data;
+  private int limit;
+
+  private volatile boolean loadFinished;
+  private volatile boolean loadCanceled;
+
+  /**
+   * @param dataSource The source from which the data should be loaded.
+   * @param dataSpec Defines the data to be loaded. {@code dataSpec.length} must not exceed
+   *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
+   *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
+   *     {@link Integer#MAX_VALUE}.
+   * @param data An optional recycled array that can be used as a holder for the data.
+   */
+  public DataChunk(DataSource dataSource, DataSpec dataSpec, byte[] data) {
+    super(dataSource, dataSpec);
+    this.data = data;
+  }
+
+  @Override
+  public void consume() throws IOException {
+    consume(data, limit);
+  }
+
+  /**
+   * Invoked by {@link #consume()}. Implementations should override this method to consume the
+   * loaded data.
+   *
+   * @param data An array containing the data.
+   * @param limit The limit of the data.
+   * @throws IOException If an error occurs consuming the loaded data.
+   */
+  protected abstract void consume(byte[] data, int limit) throws IOException;
+
+  /**
+   * Whether the whole of the chunk has been loaded.
+   *
+   * @return True if the whole of the chunk has been loaded. False otherwise.
+   */
+  @Override
+  public boolean isLoadFinished() {
+    return loadFinished;
+  }
+
+  // Loadable implementation
+
+  @Override
+  public final void cancelLoad() {
+    loadCanceled = true;
+  }
+
+  @Override
+  public final boolean isLoadCanceled() {
+    return loadCanceled;
+  }
+
+  @Override
+  public final void load() throws IOException, InterruptedException {
+    try {
+      dataSource.open(dataSpec);
+      limit = 0;
+      int bytesRead = 0;
+      while (bytesRead != -1 && !loadCanceled) {
+        maybeExpandData();
+        bytesRead = dataSource.read(data, limit, READ_GRANULARITY);
+        if (bytesRead != -1) {
+          limit += bytesRead;
+        }
+      }
+      loadFinished = !loadCanceled;
+    } finally {
+      dataSource.close();
+    }
+  }
+
+  private void maybeExpandData() {
+    if (data == null) {
+      data = new byte[READ_GRANULARITY];
+    } else if (data.length < limit + READ_GRANULARITY) {
+      // The new length is calculated as (data.length + READ_GRANULARITY) rather than
+      // (limit + READ_GRANULARITY) in order to avoid small increments in the length.
+      data = Arrays.copyOf(data, data.length + READ_GRANULARITY);
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunk.java
new file mode 100644
index 0000000000..4fe1a18646
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunk.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.Loader.Loadable;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.io.IOException;
+
+/**
+ * An abstract base class for {@link Loadable} implementations that load chunks of data required
+ * for the playback of HLS streams.
+ */
+public abstract class HlsChunk implements Loadable {
+
+  protected final DataSource dataSource;
+  protected final DataSpec dataSpec;
+
+  /**
+   * @param dataSource The source from which the data should be loaded.
+   * @param dataSpec Defines the data to be loaded. {@code dataSpec.length} must not exceed
+   *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
+   *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
+   *     {@link Integer#MAX_VALUE}.
+   */
+  public HlsChunk(DataSource dataSource, DataSpec dataSpec) {
+    Assertions.checkState(dataSpec.length <= Integer.MAX_VALUE);
+    this.dataSource = Assertions.checkNotNull(dataSource);
+    this.dataSpec = Assertions.checkNotNull(dataSpec);
+  }
+
+  public abstract void consume() throws IOException;
+
+  public abstract boolean isLoadFinished();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
new file mode 100644
index 0000000000..90bc497478
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -0,0 +1,584 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.hls.parser.TsExtractor;
+import com.google.android.exoplayer.upstream.Aes128DataSource;
+import com.google.android.exoplayer.upstream.BandwidthMeter;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.HttpDataSource.InvalidResponseCodeException;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import android.net.Uri;
+import android.os.SystemClock;
+import android.util.Log;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * A temporary test source of HLS chunks.
+ * <p>
+ * TODO: Figure out whether this should merge with the chunk package, or whether the hls
+ * implementation is going to naturally diverge.
+ */
+public class HlsChunkSource {
+
+  /**
+   * Adaptive switching is disabled.
+   * <p>
+   * The initially selected variant will be used throughout playback.
+   */
+  public static final int ADAPTIVE_MODE_NONE = 0;
+
+  /**
+   * Adaptive switches splice overlapping segments of the old and new variants.
+   * <p>
+   * When performing a switch from one variant to another, overlapping segments will be requested
+   * from both the old and new variants. These segments will then be spliced together, allowing
+   * a seamless switch from one variant to another even if keyframes are misaligned or if keyframes
+   * are not positioned at the start of each segment.
+   * <p>
+   * Note that where it can be guaranteed that the source content has keyframes positioned at the
+   * start of each segment, {@link #ADAPTIVE_MODE_ABRUPT} should always be used in preference to
+   * this mode.
+   */
+  public static final int ADAPTIVE_MODE_SPLICE = 1;
+
+  /**
+   * Adaptive switches are performed at segment boundaries.
+   * <p>
+   * For this mode to perform seamless switches, the source content is required to have keyframes
+   * positioned at the start of each segment. If this is not the case a visual discontinuity may
+   * be experienced when switching from one variant to another.
+   * <p>
+   * Note that where it can be guaranteed that the source content does have keyframes positioned at
+   * the start of each segment, this mode should always be used in preference to
+   * {@link #ADAPTIVE_MODE_SPLICE} because it requires fetching less data.
+   */
+  public static final int ADAPTIVE_MODE_ABRUPT = 3;
+
+  /**
+   * The default target buffer size in bytes.
+   */
+  public static final int DEFAULT_TARGET_BUFFER_SIZE = 18 * 1024 * 1024;
+
+  /**
+   * The default target buffer duration in milliseconds.
+   */
+  public static final long DEFAULT_TARGET_BUFFER_DURATION_MS = 40000;
+
+  /**
+   * The default minimum duration of media that needs to be buffered for a switch to a higher
+   * quality variant to be considered.
+   */
+  public static final long DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS = 5000;
+
+  /**
+   * The default maximum duration of media that needs to be buffered for a switch to a lower
+   * quality variant to be considered.
+   */
+  public static final long DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS = 20000;
+
+  private static final String TAG = "HlsChunkSource";
+  private static final float BANDWIDTH_FRACTION = 0.8f;
+
+  private final BufferPool bufferPool;
+  private final DataSource upstreamDataSource;
+  private final HlsPlaylistParser playlistParser;
+  private final Variant[] enabledVariants;
+  private final BandwidthMeter bandwidthMeter;
+  private final int adaptiveMode;
+  private final Uri baseUri;
+  private final int maxWidth;
+  private final int maxHeight;
+  private final int targetBufferSize;
+  private final long targetBufferDurationUs;
+  private final long minBufferDurationToSwitchUpUs;
+  private final long maxBufferDurationToSwitchDownUs;
+
+  /* package */ byte[] scratchSpace;
+  /* package */ final HlsMediaPlaylist[] mediaPlaylists;
+  /* package */ final boolean[] mediaPlaylistBlacklistFlags;
+  /* package */ final long[] lastMediaPlaylistLoadTimesMs;
+  /* package */ boolean live;
+  /* package */ long durationUs;
+
+  private int variantIndex;
+  private DataSource encryptedDataSource;
+  private Uri encryptionKeyUri;
+  private String encryptedDataSourceIv;
+  private byte[] encryptedDataSourceSecretKey;
+
+  public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist playlist,
+      BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode) {
+    this(dataSource, playlistUrl, playlist, bandwidthMeter, variantIndices, adaptiveMode,
+        DEFAULT_TARGET_BUFFER_SIZE, DEFAULT_TARGET_BUFFER_DURATION_MS,
+        DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS, DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS);
+  }
+
+  /**
+   * @param dataSource A {@link DataSource} suitable for loading the media data.
+   * @param playlistUrl The playlist URL.
+   * @param playlist The hls playlist.
+   * @param bandwidthMeter provides an estimate of the currently available bandwidth.
+   * @param variantIndices A subset of variant indices to consider, or null to consider all of the
+   *     variants in the master playlist.
+   * @param adaptiveMode The mode for switching from one variant to another. One of
+   *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
+   *     {@link #ADAPTIVE_MODE_SPLICE}.
+   * @param targetBufferSize The targeted buffer size in bytes. The buffer will not be filled more
+   *     than one chunk beyond this amount of data.
+   * @param targetBufferDurationMs The targeted duration of media to buffer ahead of the current
+   *     playback position. The buffer will not be filled more than one chunk beyond this position.
+   * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be buffered
+   *     for a switch to a higher quality variant to be considered.
+   * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
+   *     for a switch to a lower quality variant to be considered.
+   */
+  public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist playlist,
+      BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode,
+      int targetBufferSize, long targetBufferDurationMs, long minBufferDurationToSwitchUpMs,
+      long maxBufferDurationToSwitchDownMs) {
+    this.upstreamDataSource = dataSource;
+    this.bandwidthMeter = bandwidthMeter;
+    this.adaptiveMode = adaptiveMode;
+    this.targetBufferSize = targetBufferSize;
+    targetBufferDurationUs = targetBufferDurationMs * 1000;
+    minBufferDurationToSwitchUpUs = minBufferDurationToSwitchUpMs * 1000;
+    maxBufferDurationToSwitchDownUs = maxBufferDurationToSwitchDownMs * 1000;
+    baseUri = playlist.baseUri;
+    playlistParser = new HlsPlaylistParser();
+    bufferPool = new BufferPool(256 * 1024);
+
+    if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
+      enabledVariants = new Variant[] {new Variant(0, playlistUrl, 0, null, -1, -1)};
+      mediaPlaylists = new HlsMediaPlaylist[1];
+      mediaPlaylistBlacklistFlags = new boolean[1];
+      lastMediaPlaylistLoadTimesMs = new long[1];
+      setMediaPlaylist(0, (HlsMediaPlaylist) playlist);
+    } else {
+      Assertions.checkState(playlist.type == HlsPlaylist.TYPE_MASTER);
+      enabledVariants = filterVariants((HlsMasterPlaylist) playlist, variantIndices);
+      mediaPlaylists = new HlsMediaPlaylist[enabledVariants.length];
+      mediaPlaylistBlacklistFlags = new boolean[enabledVariants.length];
+      lastMediaPlaylistLoadTimesMs = new long[enabledVariants.length];
+    }
+
+    int maxWidth = -1;
+    int maxHeight = -1;
+    // Select the first variant from the master playlist that's enabled.
+    long minOriginalVariantIndex = Integer.MAX_VALUE;
+    for (int i = 0; i < enabledVariants.length; i++) {
+      if (enabledVariants[i].index < minOriginalVariantIndex) {
+        minOriginalVariantIndex = enabledVariants[i].index;
+        variantIndex = i;
+      }
+      maxWidth = Math.max(enabledVariants[i].width, maxWidth);
+      maxHeight = Math.max(enabledVariants[i].height, maxHeight);
+    }
+    // TODO: We should allow the default values to be passed through the constructor.
+    this.maxWidth = maxWidth > 0 ? maxWidth : 1920;
+    this.maxHeight = maxHeight > 0 ? maxHeight : 1080;
+  }
+
+  public long getDurationUs() {
+    return live ? C.UNKNOWN_TIME_US : durationUs;
+  }
+
+  /**
+   * Adaptive implementations must set the maximum video dimensions on the supplied
+   * {@link MediaFormat}. Other implementations do nothing.
+   * <p>
+   * Only called when the source is enabled.
+   *
+   * @param out The {@link MediaFormat} on which the maximum video dimensions should be set.
+   */
+  public void getMaxVideoDimensions(MediaFormat out) {
+    out.setMaxVideoDimensions(maxWidth, maxHeight);
+  }
+
+  /**
+   * Returns the next {@link HlsChunk} that should be loaded.
+   *
+   * @param previousTsChunk The previously loaded chunk that the next chunk should follow.
+   * @param seekPositionUs If there is no previous chunk, this parameter must specify the seek
+   *     position. If there is a previous chunk then this parameter is ignored.
+   * @param playbackPositionUs The current playback position.
+   * @return The next chunk to load.
+   */
+  public HlsChunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
+      long playbackPositionUs) {
+    if (previousTsChunk != null && (previousTsChunk.isLastChunk
+        || previousTsChunk.endTimeUs - playbackPositionUs >= targetBufferDurationUs)
+        || bufferPool.getAllocatedSize() >= targetBufferSize) {
+      // We're either finished, or we have the target amount of data or time buffered.
+      return null;
+    }
+
+    int nextVariantIndex = variantIndex;
+    boolean switchingVariant = false;
+    boolean switchingVariantSpliced = false;
+    if (adaptiveMode == ADAPTIVE_MODE_NONE) {
+      // Do nothing.
+    } else {
+      nextVariantIndex = getNextVariantIndex(previousTsChunk, playbackPositionUs);
+      switchingVariant = nextVariantIndex != variantIndex;
+      switchingVariantSpliced = switchingVariant && adaptiveMode == ADAPTIVE_MODE_SPLICE;
+    }
+
+    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[nextVariantIndex];
+    if (mediaPlaylist == null) {
+      // We don't have the media playlist for the next variant. Request it now.
+      return newMediaPlaylistChunk(nextVariantIndex);
+    }
+
+    variantIndex = nextVariantIndex;
+    int chunkMediaSequence = 0;
+    boolean liveDiscontinuity = false;
+    if (live) {
+      if (previousTsChunk == null) {
+        chunkMediaSequence = getLiveStartChunkMediaSequence(variantIndex);
+      } else {
+        chunkMediaSequence = switchingVariantSpliced
+            ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
+        if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+          // If the chunk is no longer in the playlist. Skip ahead and start again.
+          chunkMediaSequence = getLiveStartChunkMediaSequence(variantIndex);
+          liveDiscontinuity = true;
+        }
+      }
+    } else {
+      // Not live.
+      if (previousTsChunk == null) {
+        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, seekPositionUs, true,
+            true) + mediaPlaylist.mediaSequence;
+      } else {
+        chunkMediaSequence = switchingVariantSpliced
+            ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
+      }
+    }
+
+    int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
+    if (chunkIndex >= mediaPlaylist.segments.size()) {
+      if (mediaPlaylist.live && shouldRerequestMediaPlaylist(variantIndex)) {
+        return newMediaPlaylistChunk(variantIndex);
+      } else {
+        return null;
+      }
+    }
+
+    HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
+    Uri chunkUri = Util.getMergedUri(mediaPlaylist.baseUri, segment.url);
+
+    // Check if encryption is specified.
+    if (HlsMediaPlaylist.ENCRYPTION_METHOD_AES_128.equals(segment.encryptionMethod)) {
+      Uri keyUri = Util.getMergedUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
+      if (!keyUri.equals(encryptionKeyUri)) {
+        // Encryption is specified and the key has changed.
+        HlsChunk toReturn = newEncryptionKeyChunk(keyUri, segment.encryptionIV);
+        return toReturn;
+      }
+      if (!Util.areEqual(segment.encryptionIV, encryptedDataSourceIv)) {
+        initEncryptedDataSource(keyUri, segment.encryptionIV, encryptedDataSourceSecretKey);
+      }
+    } else {
+      clearEncryptedDataSource();
+    }
+
+    // Configure the data source and spec for the chunk.
+    DataSource dataSource = encryptedDataSource != null ? encryptedDataSource : upstreamDataSource;
+    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
+        null);
+
+    // Compute start and end times, and the sequence number of the next chunk.
+    long startTimeUs;
+    if (live) {
+      if (previousTsChunk == null) {
+        startTimeUs = 0;
+      } else if (switchingVariantSpliced) {
+        startTimeUs = previousTsChunk.startTimeUs;
+      } else {
+        startTimeUs = previousTsChunk.endTimeUs;
+      }
+    } else /* Not live */ {
+      startTimeUs = segment.startTimeUs;
+    }
+    long endTimeUs = startTimeUs + (long) (segment.durationSecs * C.MICROS_PER_SECOND);
+    boolean isLastChunk = !mediaPlaylist.live && chunkIndex == mediaPlaylist.segments.size() - 1;
+
+    // Configure the extractor that will read the chunk.
+    TsExtractor extractor;
+    if (previousTsChunk == null || segment.discontinuity || switchingVariant || liveDiscontinuity) {
+      extractor = new TsExtractor(startTimeUs, switchingVariantSpliced, bufferPool);
+    } else {
+      extractor = previousTsChunk.extractor;
+    }
+
+    return new TsChunk(dataSource, dataSpec, extractor, enabledVariants[variantIndex].index,
+        startTimeUs, endTimeUs, chunkMediaSequence, isLastChunk);
+  }
+
+  /**
+   * Invoked when an error occurs loading a chunk.
+   *
+   * @param chunk The chunk whose load failed.
+   * @param e The failure.
+   * @return True if the error was handled by the source. False otherwise.
+   */
+  public boolean onLoadError(HlsChunk chunk, IOException e) {
+    if ((chunk instanceof MediaPlaylistChunk) && (e instanceof InvalidResponseCodeException)) {
+      InvalidResponseCodeException responseCodeException = (InvalidResponseCodeException) e;
+      int responseCode = responseCodeException.responseCode;
+      if (responseCode == 404 || responseCode == 410) {
+        MediaPlaylistChunk playlistChunk = (MediaPlaylistChunk) chunk;
+        mediaPlaylistBlacklistFlags[playlistChunk.variantIndex] = true;
+        if (!allPlaylistsBlacklisted()) {
+          // We've handled the 404/410 by blacklisting the playlist.
+          Log.w(TAG, "Blacklisted playlist (" + responseCode + "): "
+              + playlistChunk.dataSpec.uri);
+          return true;
+        } else {
+          // This was the last non-blacklisted playlist. Don't blacklist it.
+          Log.w(TAG, "Final playlist not blacklisted (" + responseCode + "): "
+              + playlistChunk.dataSpec.uri);
+          mediaPlaylistBlacklistFlags[playlistChunk.variantIndex] = false;
+          return false;
+        }
+      }
+    }
+    return false;
+  }
+
+  private int getNextVariantIndex(TsChunk previousTsChunk, long playbackPositionUs) {
+    int idealVariantIndex = getVariantIndexForBandwdith(
+        (int) (bandwidthMeter.getBitrateEstimate() * BANDWIDTH_FRACTION));
+    if (idealVariantIndex == variantIndex) {
+      // We're already using the ideal variant.
+      return variantIndex;
+    }
+    // We're not using the ideal variant for the available bandwidth, but only switch if the
+    // conditions are appropriate.
+    long bufferedPositionUs = previousTsChunk == null ? playbackPositionUs
+        : adaptiveMode == ADAPTIVE_MODE_SPLICE ? previousTsChunk.startTimeUs
+        : previousTsChunk.endTimeUs;
+    long bufferedUs = bufferedPositionUs - playbackPositionUs;
+    if (mediaPlaylistBlacklistFlags[variantIndex]
+        || (idealVariantIndex > variantIndex && bufferedUs < maxBufferDurationToSwitchDownUs)
+        || (idealVariantIndex < variantIndex && bufferedUs > minBufferDurationToSwitchUpUs)) {
+      // Switch variant.
+      return idealVariantIndex;
+    }
+    // Stick with the current variant for now.
+    return variantIndex;
+  }
+
+  private int getVariantIndexForBandwdith(int bandwidth) {
+    int lowestQualityEnabledVariant = 0;
+    for (int i = 0; i < enabledVariants.length; i++) {
+      if (!mediaPlaylistBlacklistFlags[i]) {
+        if (enabledVariants[i].bandwidth <= bandwidth) {
+          return i;
+        }
+        lowestQualityEnabledVariant = i;
+      }
+    }
+    return lowestQualityEnabledVariant;
+  }
+
+  private boolean shouldRerequestMediaPlaylist(int variantIndex) {
+    // Don't re-request media playlist more often than one-half of the target duration.
+    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[variantIndex];
+    long timeSinceLastMediaPlaylistLoadMs =
+        SystemClock.elapsedRealtime() - lastMediaPlaylistLoadTimesMs[variantIndex];
+    return timeSinceLastMediaPlaylistLoadMs >= (mediaPlaylist.targetDurationSecs * 1000) / 2;
+  }
+
+  private int getLiveStartChunkMediaSequence(int variantIndex) {
+    // For live start playback from the third chunk from the end.
+    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[variantIndex];
+    int chunkIndex = mediaPlaylist.segments.size() > 3 ? mediaPlaylist.segments.size() - 3 : 0;
+    return chunkIndex + mediaPlaylist.mediaSequence;
+  }
+
+  private MediaPlaylistChunk newMediaPlaylistChunk(int variantIndex) {
+    Uri mediaPlaylistUri = Util.getMergedUri(baseUri, enabledVariants[variantIndex].url);
+    DataSpec dataSpec = new DataSpec(mediaPlaylistUri, 0, C.LENGTH_UNBOUNDED, null);
+    Uri baseUri = Util.parseBaseUri(mediaPlaylistUri.toString());
+    return new MediaPlaylistChunk(variantIndex, upstreamDataSource, dataSpec, baseUri);
+  }
+
+  private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv) {
+    DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNBOUNDED, null);
+    return new EncryptionKeyChunk(upstreamDataSource, dataSpec, iv);
+  }
+
+  /* package */ void initEncryptedDataSource(Uri keyUri, String iv, byte[] secretKey) {
+    String trimmedIv;
+    if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
+      trimmedIv = iv.substring(2);
+    } else {
+      trimmedIv = iv;
+    }
+
+    byte[] ivData = new BigInteger(trimmedIv, 16).toByteArray();
+    byte[] ivDataWithPadding = new byte[16];
+    int offset = ivData.length > 16 ? ivData.length - 16 : 0;
+    System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
+        + offset, ivData.length - offset);
+
+    encryptedDataSource = new Aes128DataSource(secretKey, ivDataWithPadding, upstreamDataSource);
+    encryptionKeyUri = keyUri;
+    encryptedDataSourceIv = iv;
+    encryptedDataSourceSecretKey = secretKey;
+  }
+
+  private void clearEncryptedDataSource() {
+    encryptionKeyUri = null;
+    encryptedDataSource = null;
+    encryptedDataSourceIv = null;
+    encryptedDataSourceSecretKey = null;
+  }
+
+  /* package */ void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist) {
+    lastMediaPlaylistLoadTimesMs[variantIndex] = SystemClock.elapsedRealtime();
+    mediaPlaylists[variantIndex] = mediaPlaylist;
+    live |= mediaPlaylist.live;
+    durationUs = mediaPlaylist.durationUs;
+  }
+
+  private static Variant[] filterVariants(HlsMasterPlaylist masterPlaylist, int[] variantIndices) {
+    List<Variant> masterVariants = masterPlaylist.variants;
+    ArrayList<Variant> enabledVariants = new ArrayList<Variant>();
+    if (variantIndices != null) {
+      for (int i = 0; i < variantIndices.length; i++) {
+        enabledVariants.add(masterVariants.get(variantIndices[i]));
+      }
+    } else {
+      // If variantIndices is null then all variants are initially considered.
+      enabledVariants.addAll(masterVariants);
+    }
+
+    ArrayList<Variant> definiteVideoVariants = new ArrayList<Variant>();
+    ArrayList<Variant> definiteAudioOnlyVariants = new ArrayList<Variant>();
+    for (int i = 0; i < enabledVariants.size(); i++) {
+      Variant variant = enabledVariants.get(i);
+      if (variant.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
+        definiteVideoVariants.add(variant);
+      } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
+        definiteAudioOnlyVariants.add(variant);
+      }
+    }
+
+    if (!definiteVideoVariants.isEmpty()) {
+      // We've identified some variants as definitely containing video. Assume variants within the
+      // master playlist are marked consistently, and hence that we have the full set. Filter out
+      // any other variants, which are likely to be audio only.
+      enabledVariants = definiteVideoVariants;
+    } else if (definiteAudioOnlyVariants.size() < enabledVariants.size()) {
+      // We've identified some variants, but not all, as being audio only. Filter them out to leave
+      // the remaining variants, which are likely to contain video.
+      enabledVariants.removeAll(definiteAudioOnlyVariants);
+    } else {
+      // Leave the enabled variants unchanged. They're likely either all video or all audio.
+    }
+
+    Collections.sort(enabledVariants, new Variant.DecreasingBandwidthComparator());
+
+    Variant[] enabledVariantsArray = new Variant[enabledVariants.size()];
+    enabledVariants.toArray(enabledVariantsArray);
+    return enabledVariantsArray;
+  }
+
+  private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String prefix) {
+    String[] codecs = variant.codecs;
+    if (codecs == null) {
+      return false;
+    }
+    for (int i = 0; i < codecs.length; i++) {
+      if (codecs[i].startsWith(prefix)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private boolean allPlaylistsBlacklisted() {
+    for (int i = 0; i < mediaPlaylistBlacklistFlags.length; i++) {
+      if (!mediaPlaylistBlacklistFlags[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private class MediaPlaylistChunk extends DataChunk {
+
+    @SuppressWarnings("hiding")
+    /* package */ final int variantIndex;
+
+    private final Uri playlistBaseUri;
+
+    public MediaPlaylistChunk(int variantIndex, DataSource dataSource, DataSpec dataSpec,
+        Uri playlistBaseUri) {
+      super(dataSource, dataSpec, scratchSpace);
+      this.variantIndex = variantIndex;
+      this.playlistBaseUri = playlistBaseUri;
+    }
+
+    @Override
+    protected void consume(byte[] data, int limit) throws IOException {
+      HlsPlaylist playlist = playlistParser.parse(new ByteArrayInputStream(data, 0, limit),
+          null, null, playlistBaseUri);
+      Assertions.checkState(playlist.type == HlsPlaylist.TYPE_MEDIA);
+      HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
+      setMediaPlaylist(variantIndex, mediaPlaylist);
+      // Recycle the allocation.
+      scratchSpace = data;
+    }
+
+  }
+
+  private class EncryptionKeyChunk extends DataChunk {
+
+    private final String iv;
+
+    public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, String iv) {
+      super(dataSource, dataSpec, scratchSpace);
+      this.iv = iv;
+    }
+
+    @Override
+    protected void consume(byte[] data, int limit) throws IOException {
+      initEncryptedDataSource(dataSpec.uri, iv, Arrays.copyOf(data, limit));
+      // Recycle the allocation.
+      scratchSpace = data;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
new file mode 100644
index 0000000000..7ce299df0d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import android.net.Uri;
+
+import java.util.List;
+
+/**
+ * Represents an HLS master playlist.
+ */
+public final class HlsMasterPlaylist extends HlsPlaylist {
+
+  public final List<Variant> variants;
+
+  public HlsMasterPlaylist(Uri baseUri, List<Variant> variants) {
+    super(baseUri, HlsPlaylist.TYPE_MASTER);
+    this.variants = variants;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
new file mode 100644
index 0000000000..3e9f151c08
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.C;
+
+import android.net.Uri;
+
+import java.util.List;
+
+/**
+ * Represents an HLS media playlist.
+ */
+public final class HlsMediaPlaylist extends HlsPlaylist {
+
+  /**
+   * Media segment reference.
+   */
+  public static final class Segment implements Comparable<Long> {
+    public final boolean discontinuity;
+    public final double durationSecs;
+    public final String url;
+    public final long startTimeUs;
+    public final String encryptionMethod;
+    public final String encryptionKeyUri;
+    public final String encryptionIV;
+    public final int byterangeOffset;
+    public final int byterangeLength;
+
+    public Segment(String uri, double durationSecs, boolean discontinuity, long startTimeUs,
+        String encryptionMethod, String encryptionKeyUri, String encryptionIV,
+        int byterangeOffset, int byterangeLength) {
+      this.url = uri;
+      this.durationSecs = durationSecs;
+      this.discontinuity = discontinuity;
+      this.startTimeUs = startTimeUs;
+      this.encryptionMethod = encryptionMethod;
+      this.encryptionKeyUri = encryptionKeyUri;
+      this.encryptionIV = encryptionIV;
+      this.byterangeOffset = byterangeOffset;
+      this.byterangeLength = byterangeLength;
+    }
+
+    @Override
+    public int compareTo(Long startTimeUs) {
+      return this.startTimeUs > startTimeUs ? 1 : (this.startTimeUs < startTimeUs ? -1 : 0);
+    }
+  }
+
+  public static final String ENCRYPTION_METHOD_NONE = "NONE";
+  public static final String ENCRYPTION_METHOD_AES_128 = "AES-128";
+
+  public final int mediaSequence;
+  public final int targetDurationSecs;
+  public final int version;
+  public final List<Segment> segments;
+  public final boolean live;
+  public final long durationUs;
+
+  public HlsMediaPlaylist(Uri baseUri, int mediaSequence, int targetDurationSecs, int version,
+      boolean live, List<Segment> segments) {
+    super(baseUri, HlsPlaylist.TYPE_MEDIA);
+    this.mediaSequence = mediaSequence;
+    this.targetDurationSecs = targetDurationSecs;
+    this.version = version;
+    this.live = live;
+    this.segments = segments;
+
+    if (!segments.isEmpty()) {
+      Segment last = segments.get(segments.size() - 1);
+      durationUs = last.startTimeUs + (long) (last.durationSecs * C.MICROS_PER_SECOND);
+    } else {
+      durationUs = 0;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
new file mode 100644
index 0000000000..366bab1178
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.ParserException;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods for HLS manifest parsing.
+ */
+/* package */ class HlsParserUtil {
+
+  private HlsParserUtil() {}
+
+  public static String parseStringAttr(String line, Pattern pattern, String tag)
+      throws ParserException {
+    Matcher matcher = pattern.matcher(line);
+    if (matcher.find() && matcher.groupCount() == 1) {
+      return matcher.group(1);
+    }
+    throw new ParserException(String.format("Couldn't match %s tag in %s", tag, line));
+  }
+
+  public static String parseOptionalStringAttr(String line, Pattern pattern) {
+    Matcher matcher = pattern.matcher(line);
+    if (matcher.find() && matcher.groupCount() == 1) {
+      return matcher.group(1);
+    }
+    return null;
+  }
+
+  public static int parseIntAttr(String line, Pattern pattern, String tag)
+      throws ParserException {
+    return Integer.parseInt(parseStringAttr(line, pattern, tag));
+  }
+
+  public static double parseDoubleAttr(String line, Pattern pattern, String tag)
+      throws ParserException {
+    return Double.parseDouble(parseStringAttr(line, pattern, tag));
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
new file mode 100644
index 0000000000..3c86328ba6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import android.net.Uri;
+
+/**
+ * Represents an HLS playlist.
+ */
+public abstract class HlsPlaylist {
+
+  public final static int TYPE_MASTER = 0;
+  public final static int TYPE_MEDIA = 1;
+
+  public final Uri baseUri;
+  public final int type;
+
+  protected HlsPlaylist(Uri baseUri, int type) {
+    this.baseUri = baseUri;
+    this.type = type;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
new file mode 100644
index 0000000000..a2497e3218
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.hls.HlsMediaPlaylist.Segment;
+import com.google.android.exoplayer.util.ManifestParser;
+
+import android.net.Uri;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+import java.util.regex.Pattern;
+
+/**
+ * HLS playlists parsing logic.
+ */
+public final class HlsPlaylistParser implements ManifestParser<HlsPlaylist> {
+
+  private static final String VERSION_TAG = "#EXT-X-VERSION";
+
+  private static final String STREAM_INF_TAG = "#EXT-X-STREAM-INF";
+  private static final String BANDWIDTH_ATTR = "BANDWIDTH";
+  private static final String CODECS_ATTR = "CODECS";
+  private static final String RESOLUTION_ATTR = "RESOLUTION";
+
+  private static final String DISCONTINUITY_TAG = "#EXT-X-DISCONTINUITY";
+  private static final String MEDIA_DURATION_TAG = "#EXTINF";
+  private static final String MEDIA_SEQUENCE_TAG = "#EXT-X-MEDIA-SEQUENCE";
+  private static final String TARGET_DURATION_TAG = "#EXT-X-TARGETDURATION";
+  private static final String ENDLIST_TAG = "#EXT-X-ENDLIST";
+  private static final String KEY_TAG = "#EXT-X-KEY";
+  private static final String BYTERANGE_TAG = "#EXT-X-BYTERANGE";
+
+  private static final String METHOD_ATTR = "METHOD";
+  private static final String URI_ATTR = "URI";
+  private static final String IV_ATTR = "IV";
+
+  private static final Pattern BANDWIDTH_ATTR_REGEX =
+      Pattern.compile(BANDWIDTH_ATTR + "=(\\d+)\\b");
+  private static final Pattern CODECS_ATTR_REGEX =
+      Pattern.compile(CODECS_ATTR + "=\"(.+)\"");
+  private static final Pattern RESOLUTION_ATTR_REGEX =
+      Pattern.compile(RESOLUTION_ATTR + "=(\\d+x\\d+)");
+
+  private static final Pattern MEDIA_DURATION_REGEX =
+      Pattern.compile(MEDIA_DURATION_TAG + ":([\\d.]+),");
+  private static final Pattern MEDIA_SEQUENCE_REGEX =
+      Pattern.compile(MEDIA_SEQUENCE_TAG + ":(\\d+)\\b");
+  private static final Pattern TARGET_DURATION_REGEX =
+      Pattern.compile(TARGET_DURATION_TAG + ":(\\d+)\\b");
+  private static final Pattern VERSION_REGEX =
+      Pattern.compile(VERSION_TAG + ":(\\d+)\\b");
+  private static final Pattern BYTERANGE_REGEX =
+      Pattern.compile(BYTERANGE_TAG + ":(\\d+(?:@\\d+)?)\\b");
+
+  private static final Pattern METHOD_ATTR_REGEX =
+      Pattern.compile(METHOD_ATTR + "=([^,.*]+)");
+  private static final Pattern URI_ATTR_REGEX =
+      Pattern.compile(URI_ATTR + "=\"(.+)\"");
+  private static final Pattern IV_ATTR_REGEX =
+      Pattern.compile(IV_ATTR + "=([^,.*]+)");
+
+  @Override
+  public HlsPlaylist parse(InputStream inputStream, String inputEncoding,
+      String contentId, Uri baseUri) throws IOException {
+    BufferedReader reader = new BufferedReader((inputEncoding == null)
+        ? new InputStreamReader(inputStream) : new InputStreamReader(inputStream, inputEncoding));
+    Queue<String> extraLines = new LinkedList<String>();
+    String line;
+    try {
+      while ((line = reader.readLine()) != null) {
+        line = line.trim();
+        if (line.isEmpty()) {
+          // Do nothing.
+        } else if (line.startsWith(STREAM_INF_TAG)) {
+          extraLines.add(line);
+          return parseMasterPlaylist(new LineIterator(extraLines, reader), baseUri);
+        } else if (line.startsWith(TARGET_DURATION_TAG)
+            || line.startsWith(MEDIA_SEQUENCE_TAG)
+            || line.startsWith(MEDIA_DURATION_TAG)
+            || line.startsWith(KEY_TAG)
+            || line.startsWith(BYTERANGE_TAG)
+            || line.equals(DISCONTINUITY_TAG)
+            || line.equals(ENDLIST_TAG)) {
+          extraLines.add(line);
+          return parseMediaPlaylist(new LineIterator(extraLines, reader), baseUri);
+        } else if (line.startsWith(VERSION_TAG)) {
+          extraLines.add(line);
+        } else if (!line.startsWith("#")) {
+          throw new ParserException("Missing a tag before URL.");
+        }
+      }
+    } finally {
+      reader.close();
+    }
+    throw new ParserException("Failed to parse the playlist, could not identify any tags.");
+  }
+
+  private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Uri baseUri)
+      throws IOException {
+    List<Variant> variants = new ArrayList<Variant>();
+    int bandwidth = 0;
+    String[] codecs = null;
+    int width = -1;
+    int height = -1;
+    int variantIndex = 0;
+
+    String line;
+    while (iterator.hasNext()) {
+      line = iterator.next();
+      if (line.startsWith(STREAM_INF_TAG)) {
+        bandwidth = HlsParserUtil.parseIntAttr(line, BANDWIDTH_ATTR_REGEX, BANDWIDTH_ATTR);
+        String codecsString = HlsParserUtil.parseOptionalStringAttr(line, CODECS_ATTR_REGEX);
+        if (codecsString != null) {
+          codecs = codecsString.split("(\\s*,\\s*)|(\\s*$)");
+        } else {
+          codecs = null;
+        }
+        String resolutionString = HlsParserUtil.parseOptionalStringAttr(line,
+            RESOLUTION_ATTR_REGEX);
+        if (resolutionString != null) {
+          String[] widthAndHeight = resolutionString.split("x");
+          width = Integer.parseInt(widthAndHeight[0]);
+          height = Integer.parseInt(widthAndHeight[1]);
+        } else {
+          width = -1;
+          height = -1;
+        }
+      } else if (!line.startsWith("#")) {
+        variants.add(new Variant(variantIndex++, line, bandwidth, codecs, width, height));
+        bandwidth = 0;
+        codecs = null;
+        width = -1;
+        height = -1;
+      }
+    }
+    return new HlsMasterPlaylist(baseUri, Collections.unmodifiableList(variants));
+  }
+
+  private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, Uri baseUri)
+      throws IOException {
+    int mediaSequence = 0;
+    int targetDurationSecs = 0;
+    int version = 1; // Default version == 1.
+    boolean live = true;
+    List<Segment> segments = new ArrayList<Segment>();
+
+    double segmentDurationSecs = 0.0;
+    boolean segmentDiscontinuity = false;
+    long segmentStartTimeUs = 0;
+    String segmentEncryptionMethod = null;
+    String segmentEncryptionKeyUri = null;
+    String segmentEncryptionIV = null;
+    int segmentByterangeOffset = 0;
+    int segmentByterangeLength = C.LENGTH_UNBOUNDED;
+
+    int segmentMediaSequence = 0;
+
+    String line;
+    while (iterator.hasNext()) {
+      line = iterator.next();
+      if (line.startsWith(TARGET_DURATION_TAG)) {
+        targetDurationSecs = HlsParserUtil.parseIntAttr(line, TARGET_DURATION_REGEX,
+            TARGET_DURATION_TAG);
+      } else if (line.startsWith(MEDIA_SEQUENCE_TAG)) {
+        mediaSequence = HlsParserUtil.parseIntAttr(line, MEDIA_SEQUENCE_REGEX, MEDIA_SEQUENCE_TAG);
+        segmentMediaSequence = mediaSequence;
+      } else if (line.startsWith(VERSION_TAG)) {
+        version = HlsParserUtil.parseIntAttr(line, VERSION_REGEX, VERSION_TAG);
+      } else if (line.startsWith(MEDIA_DURATION_TAG)) {
+        segmentDurationSecs = HlsParserUtil.parseDoubleAttr(line, MEDIA_DURATION_REGEX,
+            MEDIA_DURATION_TAG);
+      } else if (line.startsWith(KEY_TAG)) {
+        segmentEncryptionMethod = HlsParserUtil.parseStringAttr(line, METHOD_ATTR_REGEX,
+            METHOD_ATTR);
+        if (segmentEncryptionMethod.equals(HlsMediaPlaylist.ENCRYPTION_METHOD_NONE)) {
+          segmentEncryptionKeyUri = null;
+          segmentEncryptionIV = null;
+        } else {
+          segmentEncryptionKeyUri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX,
+              URI_ATTR);
+          segmentEncryptionIV = HlsParserUtil.parseOptionalStringAttr(line, IV_ATTR_REGEX);
+          if (segmentEncryptionIV == null) {
+            segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
+          }
+        }
+      } else if (line.startsWith(BYTERANGE_TAG)) {
+        String byteRange = HlsParserUtil.parseStringAttr(line, BYTERANGE_REGEX, BYTERANGE_TAG);
+        String[] splitByteRange = byteRange.split("@");
+        segmentByterangeLength = Integer.parseInt(splitByteRange[0]);
+        if (splitByteRange.length > 1) {
+          segmentByterangeOffset = Integer.parseInt(splitByteRange[1]);
+        }
+      } else if (line.equals(DISCONTINUITY_TAG)) {
+        segmentDiscontinuity = true;
+      } else if (!line.startsWith("#")) {
+        segmentMediaSequence++;
+        if (segmentByterangeLength == C.LENGTH_UNBOUNDED) {
+          segmentByterangeOffset = 0;
+        }
+        segments.add(new Segment(line, segmentDurationSecs, segmentDiscontinuity,
+            segmentStartTimeUs, segmentEncryptionMethod, segmentEncryptionKeyUri,
+            segmentEncryptionIV, segmentByterangeOffset, segmentByterangeLength));
+        segmentStartTimeUs += (long) (segmentDurationSecs * C.MICROS_PER_SECOND);
+        segmentDiscontinuity = false;
+        segmentDurationSecs = 0.0;
+        if (segmentByterangeLength != C.LENGTH_UNBOUNDED) {
+          segmentByterangeOffset += segmentByterangeLength;
+        }
+        segmentByterangeLength = C.LENGTH_UNBOUNDED;
+      } else if (line.equals(ENDLIST_TAG)) {
+        live = false;
+        break;
+      }
+    }
+    return new HlsMediaPlaylist(baseUri, mediaSequence, targetDurationSecs, version, live,
+        Collections.unmodifiableList(segments));
+  }
+
+  private static class LineIterator {
+
+    private final BufferedReader reader;
+    private final Queue<String> extraLines;
+
+    private String next;
+
+    public LineIterator(Queue<String> extraLines, BufferedReader reader) {
+      this.extraLines = extraLines;
+      this.reader = reader;
+    }
+
+    public boolean hasNext() throws IOException {
+      if (next != null) {
+        return true;
+      }
+      if (!extraLines.isEmpty()) {
+        next = extraLines.poll();
+        return true;
+      }
+      while ((next = reader.readLine()) != null) {
+        next = next.trim();
+        if (!next.isEmpty()) {
+          return true;
+        }
+      }
+      return false;
+    }
+
+    public String next() throws IOException {
+      String result = null;
+      if (hasNext()) {
+        result = next;
+        next = null;
+      }
+      return result;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
new file mode 100644
index 0000000000..4603577ff9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -0,0 +1,448 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackInfo;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.hls.parser.TsExtractor;
+import com.google.android.exoplayer.upstream.Loader;
+import com.google.android.exoplayer.upstream.Loader.Loadable;
+import com.google.android.exoplayer.util.Assertions;
+
+import android.os.SystemClock;
+
+import java.io.IOException;
+import java.util.LinkedList;
+
+/**
+ * A {@link SampleSource} for HLS streams.
+ */
+public class HlsSampleSource implements SampleSource, Loader.Callback {
+
+  /**
+   * The default minimum number of times to retry loading data prior to failing.
+   */
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+
+  private static final int NO_RESET_PENDING = -1;
+
+  private final HlsChunkSource chunkSource;
+  private final LinkedList<TsExtractor> extractors;
+  private final boolean frameAccurateSeeking;
+  private final int minLoadableRetryCount;
+
+  private int remainingReleaseCount;
+  private boolean prepared;
+  private int trackCount;
+  private int enabledTrackCount;
+  private boolean[] trackEnabledStates;
+  private boolean[] pendingDiscontinuities;
+  private TrackInfo[] trackInfos;
+  private MediaFormat[] downstreamMediaFormats;
+
+  private long downstreamPositionUs;
+  private long lastSeekPositionUs;
+  private long pendingResetPositionUs;
+
+  private TsChunk previousTsLoadable;
+  private HlsChunk currentLoadable;
+  private boolean loadingFinished;
+
+  private Loader loader;
+  private IOException currentLoadableException;
+  private boolean currentLoadableExceptionFatal;
+  private int currentLoadableExceptionCount;
+  private long currentLoadableExceptionTimestamp;
+
+  public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
+      int downstreamRendererCount) {
+    this(chunkSource, frameAccurateSeeking, downstreamRendererCount,
+        DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+  }
+
+  public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
+      int downstreamRendererCount, int minLoadableRetryCount) {
+    this.chunkSource = chunkSource;
+    this.frameAccurateSeeking = frameAccurateSeeking;
+    this.remainingReleaseCount = downstreamRendererCount;
+    this.minLoadableRetryCount = minLoadableRetryCount;
+    extractors = new LinkedList<TsExtractor>();
+  }
+
+  @Override
+  public boolean prepare() throws IOException {
+    if (prepared) {
+      return true;
+    }
+    if (loader == null) {
+      loader = new Loader("Loader:HLS");
+    }
+    continueBufferingInternal();
+    if (!extractors.isEmpty()) {
+      TsExtractor extractor = extractors.getFirst();
+      if (extractor.isPrepared()) {
+        trackCount = extractor.getTrackCount();
+        trackEnabledStates = new boolean[trackCount];
+        pendingDiscontinuities = new boolean[trackCount];
+        downstreamMediaFormats = new MediaFormat[trackCount];
+        trackInfos = new TrackInfo[trackCount];
+        for (int i = 0; i < trackCount; i++) {
+          MediaFormat format = extractor.getFormat(i);
+          trackInfos[i] = new TrackInfo(format.mimeType, chunkSource.getDurationUs());
+        }
+        prepared = true;
+      }
+    }
+    if (!prepared) {
+      maybeThrowLoadableException();
+    }
+    return prepared;
+  }
+
+  @Override
+  public int getTrackCount() {
+    Assertions.checkState(prepared);
+    return trackCount;
+  }
+
+  @Override
+  public TrackInfo getTrackInfo(int track) {
+    Assertions.checkState(prepared);
+    return trackInfos[track];
+  }
+
+  @Override
+  public void enable(int track, long positionUs) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(!trackEnabledStates[track]);
+    enabledTrackCount++;
+    trackEnabledStates[track] = true;
+    downstreamMediaFormats[track] = null;
+    if (enabledTrackCount == 1) {
+      seekToUs(positionUs);
+    }
+  }
+
+  @Override
+  public void disable(int track) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackEnabledStates[track]);
+    enabledTrackCount--;
+    trackEnabledStates[track] = false;
+    pendingDiscontinuities[track] = false;
+    if (enabledTrackCount == 0) {
+      if (loader.isLoading()) {
+        loader.cancelLoading();
+      } else {
+        clearState();
+      }
+    }
+  }
+
+  @Override
+  public boolean continueBuffering(long playbackPositionUs) throws IOException {
+    Assertions.checkState(prepared);
+    Assertions.checkState(enabledTrackCount > 0);
+    downstreamPositionUs = playbackPositionUs;
+    if (!extractors.isEmpty()) {
+      discardSamplesForDisabledTracks(extractors.getFirst(), downstreamPositionUs);
+    }
+    return continueBufferingInternal();
+  }
+
+  private boolean continueBufferingInternal() throws IOException {
+    maybeStartLoading();
+    if (isPendingReset() || extractors.isEmpty()) {
+      return false;
+    }
+    boolean haveSamples = prepared && haveSamplesForEnabledTracks(getCurrentExtractor());
+    if (!haveSamples) {
+      maybeThrowLoadableException();
+    }
+    return haveSamples;
+  }
+
+  @Override
+  public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
+    Assertions.checkState(prepared);
+    downstreamPositionUs = playbackPositionUs;
+
+    if (pendingDiscontinuities[track]) {
+      pendingDiscontinuities[track] = false;
+      return DISCONTINUITY_READ;
+    }
+
+    if (onlyReadDiscontinuity || isPendingReset() || extractors.isEmpty()) {
+      maybeThrowLoadableException();
+      return NOTHING_READ;
+    }
+
+    TsExtractor extractor = getCurrentExtractor();
+    if (extractors.size() > 1) {
+      // If there's more than one extractor, attempt to configure a seamless splice from the
+      // current one to the next one.
+      extractor.configureSpliceTo(extractors.get(1));
+    }
+
+    int extractorIndex = 0;
+    while (extractors.size() > extractorIndex + 1 && !extractor.hasSamples(track)) {
+      // We're finished reading from the extractor for this particular track, so advance to the
+      // next one for the current read.
+      extractor = extractors.get(++extractorIndex);
+    }
+
+    if (!extractor.isPrepared()) {
+      maybeThrowLoadableException();
+      return NOTHING_READ;
+    }
+
+    MediaFormat mediaFormat = extractor.getFormat(track);
+    if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormats[track], true)) {
+      chunkSource.getMaxVideoDimensions(mediaFormat);
+      formatHolder.format = mediaFormat;
+      downstreamMediaFormats[track] = mediaFormat;
+      return FORMAT_READ;
+    }
+
+    if (extractor.getSample(track, sampleHolder)) {
+      sampleHolder.decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      return SAMPLE_READ;
+    }
+
+    if (loadingFinished) {
+      return END_OF_STREAM;
+    }
+
+    maybeThrowLoadableException();
+    return NOTHING_READ;
+  }
+
+  @Override
+  public void seekToUs(long positionUs) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(enabledTrackCount > 0);
+    lastSeekPositionUs = positionUs;
+    if (pendingResetPositionUs == positionUs || downstreamPositionUs == positionUs) {
+      downstreamPositionUs = positionUs;
+      return;
+    }
+    downstreamPositionUs = positionUs;
+    for (int i = 0; i < pendingDiscontinuities.length; i++) {
+      pendingDiscontinuities[i] = true;
+    }
+    restartFrom(positionUs);
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    Assertions.checkState(prepared);
+    Assertions.checkState(enabledTrackCount > 0);
+    if (isPendingReset()) {
+      return pendingResetPositionUs;
+    } else if (loadingFinished) {
+      return TrackRenderer.END_OF_TRACK_US;
+    } else {
+      long largestSampleTimestamp = extractors.getLast().getLargestSampleTimestamp();
+      return largestSampleTimestamp == Long.MIN_VALUE ? downstreamPositionUs
+          : largestSampleTimestamp;
+    }
+  }
+
+  @Override
+  public void release() {
+    Assertions.checkState(remainingReleaseCount > 0);
+    if (--remainingReleaseCount == 0 && loader != null) {
+      loader.release();
+      loader = null;
+    }
+  }
+
+  @Override
+  public void onLoadCompleted(Loadable loadable) {
+    try {
+      currentLoadable.consume();
+    } catch (IOException e) {
+      currentLoadableException = e;
+      currentLoadableExceptionCount++;
+      currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+      currentLoadableExceptionFatal = true;
+    } finally {
+      if (isTsChunk(currentLoadable)) {
+        TsChunk tsChunk = (TsChunk) loadable;
+        loadingFinished = tsChunk.isLastChunk;
+      }
+      if (!currentLoadableExceptionFatal) {
+        clearCurrentLoadable();
+      }
+      maybeStartLoading();
+    }
+  }
+
+  @Override
+  public void onLoadCanceled(Loadable loadable) {
+    if (enabledTrackCount > 0) {
+      restartFrom(pendingResetPositionUs);
+    } else {
+      clearState();
+    }
+  }
+
+  @Override
+  public void onLoadError(Loadable loadable, IOException e) {
+    if (chunkSource.onLoadError(currentLoadable, e)) {
+      // Error handled by source.
+      clearCurrentLoadable();
+    } else {
+      currentLoadableException = e;
+      currentLoadableExceptionCount++;
+      currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+    }
+    maybeStartLoading();
+  }
+
+  /**
+   * Gets the current extractor from which samples should be read.
+   * <p>
+   * Calling this method discards extractors without any samples from the front of the queue. The
+   * last extractor is retained even if it doesn't have any samples.
+   * <p>
+   * This method must not be called unless {@link #extractors} is non-empty.
+   *
+   * @return The current extractor from which samples should be read. Guaranteed to be non-null.
+   */
+  private TsExtractor getCurrentExtractor() {
+    TsExtractor extractor = extractors.getFirst();
+    while (extractors.size() > 1 && !haveSamplesForEnabledTracks(extractor)) {
+      // We're finished reading from the extractor for all tracks, and so can discard it.
+      extractors.removeFirst().release();
+      extractor = extractors.getFirst();
+    }
+    return extractor;
+  }
+
+  private void discardSamplesForDisabledTracks(TsExtractor extractor, long timeUs) {
+    if (!extractor.isPrepared()) {
+      return;
+    }
+    for (int i = 0; i < trackEnabledStates.length; i++) {
+      if (!trackEnabledStates[i]) {
+        extractor.discardUntil(i, timeUs);
+      }
+    }
+  }
+
+  private boolean haveSamplesForEnabledTracks(TsExtractor extractor) {
+    if (!extractor.isPrepared()) {
+      return false;
+    }
+    for (int i = 0; i < trackEnabledStates.length; i++) {
+      if (trackEnabledStates[i] && extractor.hasSamples(i)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private void maybeThrowLoadableException() throws IOException {
+    if (currentLoadableException != null && (currentLoadableExceptionFatal
+        || currentLoadableExceptionCount > minLoadableRetryCount)) {
+      throw currentLoadableException;
+    }
+  }
+
+  private void restartFrom(long positionUs) {
+    pendingResetPositionUs = positionUs;
+    loadingFinished = false;
+    if (loader.isLoading()) {
+      loader.cancelLoading();
+    } else {
+      clearState();
+      maybeStartLoading();
+    }
+  }
+
+  private void clearState() {
+    for (int i = 0; i < extractors.size(); i++) {
+      extractors.get(i).release();
+    }
+    extractors.clear();
+    clearCurrentLoadable();
+    previousTsLoadable = null;
+  }
+
+  private void clearCurrentLoadable() {
+    currentLoadable = null;
+    currentLoadableException = null;
+    currentLoadableExceptionCount = 0;
+    currentLoadableExceptionFatal = false;
+  }
+
+  private void maybeStartLoading() {
+    if (currentLoadableExceptionFatal || loadingFinished || loader.isLoading()) {
+      return;
+    }
+
+    boolean isBackedOff = currentLoadableException != null;
+    if (isBackedOff) {
+      long elapsedMillis = SystemClock.elapsedRealtime() - currentLoadableExceptionTimestamp;
+      if (elapsedMillis >= getRetryDelayMillis(currentLoadableExceptionCount)) {
+        currentLoadableException = null;
+        loader.startLoading(currentLoadable, this);
+      }
+      return;
+    }
+
+    HlsChunk nextLoadable = chunkSource.getChunkOperation(previousTsLoadable,
+        pendingResetPositionUs, downstreamPositionUs);
+    if (nextLoadable == null) {
+      return;
+    }
+
+    currentLoadable = nextLoadable;
+    if (isTsChunk(currentLoadable)) {
+      previousTsLoadable = (TsChunk) currentLoadable;
+      if (isPendingReset()) {
+        pendingResetPositionUs = NO_RESET_PENDING;
+      }
+      if (extractors.isEmpty() || extractors.getLast() != previousTsLoadable.extractor) {
+        extractors.addLast(previousTsLoadable.extractor);
+      }
+    }
+    loader.startLoading(currentLoadable, this);
+  }
+
+  private boolean isTsChunk(HlsChunk chunk) {
+    return chunk instanceof TsChunk;
+  }
+
+  private boolean isPendingReset() {
+    return pendingResetPositionUs != NO_RESET_PENDING;
+  }
+
+  private long getRetryDelayMillis(long errorCount) {
+    return Math.min((errorCount - 1) * 1000, 5000);
+  }
+
+  protected final int usToMs(long timeUs) {
+    return (int) (timeUs / 1000);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
new file mode 100644
index 0000000000..36c1e30c8f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.hls.parser.TsExtractor;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+import java.io.IOException;
+
+/**
+ * A MPEG2TS chunk.
+ */
+public final class TsChunk extends HlsChunk {
+
+  private static final byte[] SCRATCH_SPACE = new byte[4096];
+
+  /**
+   * The index of the variant in the master playlist.
+   */
+  public final int variantIndex;
+  /**
+   * The start time of the media contained by the chunk.
+   */
+  public final long startTimeUs;
+  /**
+   * The end time of the media contained by the chunk.
+   */
+  public final long endTimeUs;
+  /**
+   * The chunk index.
+   */
+  public final int chunkIndex;
+  /**
+   * True if this is the last chunk in the media. False otherwise.
+   */
+  public final boolean isLastChunk;
+  /**
+   * The extractor into which this chunk is being consumed.
+   */
+  public final TsExtractor extractor;
+
+  private int loadPosition;
+  private volatile boolean loadFinished;
+  private volatile boolean loadCanceled;
+
+  /**
+   * @param dataSource A {@link DataSource} for loading the data.
+   * @param dataSpec Defines the data to be loaded.
+   * @param variantIndex The index of the variant in the master playlist.
+   * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
+   * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
+   * @param chunkIndex The index of the chunk.
+   * @param isLastChunk True if this is the last chunk in the media. False otherwise.
+   */
+  public TsChunk(DataSource dataSource, DataSpec dataSpec, TsExtractor tsExtractor,
+      int variantIndex, long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk) {
+    super(dataSource, dataSpec);
+    this.extractor = tsExtractor;
+    this.variantIndex = variantIndex;
+    this.startTimeUs = startTimeUs;
+    this.endTimeUs = endTimeUs;
+    this.chunkIndex = chunkIndex;
+    this.isLastChunk = isLastChunk;
+  }
+
+  @Override
+  public void consume() throws IOException {
+    // Do nothing.
+  }
+
+  @Override
+  public boolean isLoadFinished() {
+    return loadFinished;
+  }
+
+  // Loadable implementation
+
+  @Override
+  public void cancelLoad() {
+    loadCanceled = true;
+  }
+
+  @Override
+  public boolean isLoadCanceled() {
+    return loadCanceled;
+  }
+
+  @Override
+  public void load() throws IOException, InterruptedException {
+    try {
+      dataSource.open(dataSpec);
+      int bytesRead = 0;
+      int bytesSkipped = 0;
+      // If we previously fed part of this chunk to the extractor, skip it this time.
+      // TODO: Ideally we'd construct a dataSpec that only loads the remainder of the data here,
+      // rather than loading the whole chunk again and then skipping data we previously loaded. To
+      // do this is straightforward for non-encrypted content, but more complicated for content
+      // encrypted with AES, for which we'll need to modify the way that decryption is performed.
+      while (bytesRead != -1 && !loadCanceled && bytesSkipped < loadPosition) {
+        int skipLength = Math.min(loadPosition - bytesSkipped, SCRATCH_SPACE.length);
+        bytesRead = dataSource.read(SCRATCH_SPACE, 0, skipLength);
+        if (bytesRead != -1) {
+          bytesSkipped += bytesRead;
+        }
+      }
+      // Feed the remaining data into the extractor.
+      while (bytesRead != -1 && !loadCanceled) {
+        bytesRead = extractor.read(dataSource);
+        if (bytesRead != -1) {
+          loadPosition += bytesRead;
+        }
+      }
+      loadFinished = !loadCanceled;
+    } finally {
+      dataSource.close();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/Variant.java b/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
new file mode 100644
index 0000000000..47d0a450a9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import java.util.Comparator;
+
+/**
+ * Variant stream reference.
+ */
+public final class Variant {
+
+  /**
+   * Sorts {@link Variant} objects in order of decreasing bandwidth.
+   * <p>
+   * When two {@link Variant}s have the same bandwidth, the one with the lowest index comes first.
+   */
+  public static final class DecreasingBandwidthComparator implements Comparator<Variant> {
+
+    @Override
+    public int compare(Variant a, Variant b) {
+      int bandwidthDifference = b.bandwidth - a.bandwidth;
+      return bandwidthDifference != 0 ? bandwidthDifference : a.index - b.index;
+    }
+
+  }
+
+  public final int index;
+  public final int bandwidth;
+  public final String url;
+  public final String[] codecs;
+  public final int width;
+  public final int height;
+
+  public Variant(int index, String url, int bandwidth, String[] codecs, int width, int height) {
+    this.index = index;
+    this.bandwidth = bandwidth;
+    this.url = url;
+    this.codecs = codecs;
+    this.width = width;
+    this.height = height;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsReader.java
new file mode 100644
index 0000000000..35813052ad
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsReader.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.util.Pair;
+
+import java.util.Collections;
+
+/**
+ * Parses a continuous ADTS byte stream and extracts individual frames.
+ */
+/* package */ class AdtsReader extends PesPayloadReader {
+
+  private static final int STATE_FINDING_SYNC = 0;
+  private static final int STATE_READING_HEADER = 1;
+  private static final int STATE_READING_SAMPLE = 2;
+
+  private static final int HEADER_SIZE = 5;
+  private static final int CRC_SIZE = 2;
+
+  private final ParsableBitArray adtsScratch;
+
+  private int state;
+  private int bytesRead;
+
+  // Used to find the header.
+  private boolean lastByteWasFF;
+  private boolean hasCrc;
+
+  // Parsed from the header.
+  private long frameDurationUs;
+  private int sampleSize;
+
+  // Used when reading the samples.
+  private long timeUs;
+
+  public AdtsReader(BufferPool bufferPool) {
+    super(bufferPool);
+    adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
+    state = STATE_FINDING_SYNC;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    if (startOfPacket) {
+      timeUs = pesTimeUs;
+    }
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_SYNC:
+          if (skipToNextSync(data)) {
+            bytesRead = 0;
+            state = STATE_READING_HEADER;
+          }
+          break;
+        case STATE_READING_HEADER:
+          int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
+          if (continueRead(data, adtsScratch.getData(), targetLength)) {
+            parseHeader();
+            startSample(timeUs);
+            bytesRead = 0;
+            state = STATE_READING_SAMPLE;
+          }
+          break;
+        case STATE_READING_SAMPLE:
+          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+          appendData(data, bytesToRead);
+          bytesRead += bytesToRead;
+          if (bytesRead == sampleSize) {
+            commitSample(true);
+            timeUs += frameDurationUs;
+            bytesRead = 0;
+            state = STATE_FINDING_SYNC;
+          }
+          break;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+   * that the data should be written into {@code target} starting from an offset of zero.
+   *
+   * @param source The source from which to read.
+   * @param target The target into which data is to be read.
+   * @param targetLength The target length of the read.
+   * @return Whether the target length was reached.
+   */
+  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+    source.readBytes(target, bytesRead, bytesToRead);
+    bytesRead += bytesToRead;
+    return bytesRead == targetLength;
+  }
+
+  /**
+   * Locates the next sync word, advancing the position to the byte that immediately follows it.
+   * If a sync word was not located, the position is advanced to the limit.
+   *
+   * @param pesBuffer The buffer whose position should be advanced.
+   * @return True if a sync word position was found. False otherwise.
+   */
+  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
+    byte[] adtsData = pesBuffer.data;
+    int startOffset = pesBuffer.getPosition();
+    int endOffset = pesBuffer.limit();
+    for (int i = startOffset; i < endOffset; i++) {
+      boolean byteIsFF = (adtsData[i] & 0xFF) == 0xFF;
+      boolean found = lastByteWasFF && !byteIsFF && (adtsData[i] & 0xF0) == 0xF0;
+      lastByteWasFF = byteIsFF;
+      if (found) {
+        hasCrc = (adtsData[i] & 0x1) == 0;
+        pesBuffer.setPosition(i + 1);
+        return true;
+      }
+    }
+    pesBuffer.setPosition(endOffset);
+    return false;
+  }
+
+  /**
+   * Parses the sample header.
+   */
+  private void parseHeader() {
+    adtsScratch.setPosition(0);
+
+    if (!hasMediaFormat()) {
+      int audioObjectType = adtsScratch.readBits(2) + 1;
+      int sampleRateIndex = adtsScratch.readBits(4);
+      adtsScratch.skipBits(1);
+      int channelConfig = adtsScratch.readBits(3);
+
+      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
+          audioObjectType, sampleRateIndex, channelConfig);
+      Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
+          audioSpecificConfig);
+
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(MimeTypes.AUDIO_AAC,
+          MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
+          Collections.singletonList(audioSpecificConfig));
+      frameDurationUs = (C.MICROS_PER_SECOND * 1024L) / mediaFormat.sampleRate;
+      setMediaFormat(mediaFormat);
+    } else {
+      adtsScratch.skipBits(10);
+    }
+
+    adtsScratch.skipBits(4);
+    sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
+    if (hasCrc) {
+      sampleSize -= CRC_SIZE;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/H264Reader.java
new file mode 100644
index 0000000000..55faeefcf4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/H264Reader.java
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.mp4.Mp4Util;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Parses a continuous H264 byte stream and extracts individual frames.
+ */
+/* package */ class H264Reader extends PesPayloadReader {
+
+  private static final int NAL_UNIT_TYPE_IDR = 5;
+  private static final int NAL_UNIT_TYPE_SEI = 6;
+  private static final int NAL_UNIT_TYPE_SPS = 7;
+  private static final int NAL_UNIT_TYPE_PPS = 8;
+  private static final int NAL_UNIT_TYPE_AUD = 9;
+
+  private final SeiReader seiReader;
+  private final boolean[] prefixFlags;
+  private final NalUnitTargetBuffer sps;
+  private final NalUnitTargetBuffer pps;
+  private final NalUnitTargetBuffer sei;
+
+  private boolean isKeyframe;
+
+  public H264Reader(BufferPool bufferPool, SeiReader seiReader) {
+    super(bufferPool);
+    this.seiReader = seiReader;
+    prefixFlags = new boolean[3];
+    sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
+    pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
+    sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    while (data.bytesLeft() > 0) {
+      int offset = data.getPosition();
+      int limit = data.limit();
+      byte[] dataArray = data.data;
+
+      // Append the data to the buffer.
+      appendData(data, data.bytesLeft());
+
+      // Scan the appended data, processing NAL units as they are encountered
+      while (offset < limit) {
+        int nextNalUnitOffset = Mp4Util.findNalUnit(dataArray, offset, limit, prefixFlags);
+        if (nextNalUnitOffset < limit) {
+          // We've seen the start of a NAL unit.
+
+          // This is the length to the start of the unit. It may be negative if the NAL unit
+          // actually started in previously consumed data.
+          int lengthToNalUnit = nextNalUnitOffset - offset;
+          if (lengthToNalUnit > 0) {
+            feedNalUnitTargetBuffersData(dataArray, offset, nextNalUnitOffset);
+          }
+
+          int nalUnitType = Mp4Util.getNalUnitType(dataArray, nextNalUnitOffset);
+          int nalUnitOffsetInData = nextNalUnitOffset - limit;
+          if (nalUnitType == NAL_UNIT_TYPE_AUD) {
+            if (writingSample()) {
+              if (isKeyframe && !hasMediaFormat() && sps.isCompleted() && pps.isCompleted()) {
+                parseMediaFormat(sps, pps);
+              }
+              commitSample(isKeyframe, nalUnitOffsetInData);
+            }
+            startSample(pesTimeUs, nalUnitOffsetInData);
+            isKeyframe = false;
+          } else if (nalUnitType == NAL_UNIT_TYPE_IDR) {
+            isKeyframe = true;
+          }
+
+          // If the length to the start of the unit is negative then we wrote too many bytes to the
+          // NAL buffers. Discard the excess bytes when notifying that the unit has ended.
+          feedNalUnitTargetEnd(pesTimeUs, lengthToNalUnit < 0 ? -lengthToNalUnit : 0);
+          // Notify the start of the next NAL unit.
+          feedNalUnitTargetBuffersStart(nalUnitType);
+          // Continue scanning the data.
+          offset = nextNalUnitOffset + 4;
+        } else {
+          feedNalUnitTargetBuffersData(dataArray, offset, limit);
+          offset = limit;
+        }
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  private void feedNalUnitTargetBuffersStart(int nalUnitType) {
+    if (!hasMediaFormat()) {
+      sps.startNalUnit(nalUnitType);
+      pps.startNalUnit(nalUnitType);
+    }
+    sei.startNalUnit(nalUnitType);
+  }
+
+  private void feedNalUnitTargetBuffersData(byte[] dataArray, int offset, int limit) {
+    if (!hasMediaFormat()) {
+      sps.appendToNalUnit(dataArray, offset, limit);
+      pps.appendToNalUnit(dataArray, offset, limit);
+    }
+    sei.appendToNalUnit(dataArray, offset, limit);
+  }
+
+  private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
+    sps.endNalUnit(discardPadding);
+    pps.endNalUnit(discardPadding);
+    if (sei.endNalUnit(discardPadding)) {
+      seiReader.read(sei.nalData, 0, pesTimeUs);
+    }
+  }
+
+  private void parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps) {
+    byte[] spsData = new byte[sps.nalLength];
+    byte[] ppsData = new byte[pps.nalLength];
+    System.arraycopy(sps.nalData, 0, spsData, 0, sps.nalLength);
+    System.arraycopy(pps.nalData, 0, ppsData, 0, pps.nalLength);
+    List<byte[]> initializationData = new ArrayList<byte[]>();
+    initializationData.add(spsData);
+    initializationData.add(ppsData);
+
+    // Unescape and then parse the SPS unit.
+    byte[] unescapedSps = unescapeStream(spsData, 0, spsData.length);
+    ParsableBitArray bitArray = new ParsableBitArray(unescapedSps);
+    bitArray.skipBits(32); // NAL header
+    int profileIdc = bitArray.readBits(8);
+    bitArray.skipBits(16); // constraint bits (6), reserved (2) and level_idc (8)
+    bitArray.readUnsignedExpGolombCodedInt(); // seq_parameter_set_id
+
+    int chromaFormatIdc = 1; // Default is 4:2:0
+    if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244
+        || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118
+        || profileIdc == 128 || profileIdc == 138) {
+      chromaFormatIdc = bitArray.readUnsignedExpGolombCodedInt();
+      if (chromaFormatIdc == 3) {
+        bitArray.skipBits(1); // separate_colour_plane_flag
+      }
+      bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_luma_minus8
+      bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_chroma_minus8
+      bitArray.skipBits(1); // qpprime_y_zero_transform_bypass_flag
+      boolean seqScalingMatrixPresentFlag = bitArray.readBit();
+      if (seqScalingMatrixPresentFlag) {
+        int limit = (chromaFormatIdc != 3) ? 8 : 12;
+        for (int i = 0; i < limit; i++) {
+          boolean seqScalingListPresentFlag = bitArray.readBit();
+          if (seqScalingListPresentFlag) {
+            skipScalingList(bitArray, i < 6 ? 16 : 64);
+          }
+        }
+      }
+    }
+
+    bitArray.readUnsignedExpGolombCodedInt(); // log2_max_frame_num_minus4
+    long picOrderCntType = bitArray.readUnsignedExpGolombCodedInt();
+    if (picOrderCntType == 0) {
+      bitArray.readUnsignedExpGolombCodedInt(); // log2_max_pic_order_cnt_lsb_minus4
+    } else if (picOrderCntType == 1) {
+      bitArray.skipBits(1); // delta_pic_order_always_zero_flag
+      bitArray.readSignedExpGolombCodedInt(); // offset_for_non_ref_pic
+      bitArray.readSignedExpGolombCodedInt(); // offset_for_top_to_bottom_field
+      long numRefFramesInPicOrderCntCycle = bitArray.readUnsignedExpGolombCodedInt();
+      for (int i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
+        bitArray.readUnsignedExpGolombCodedInt(); // offset_for_ref_frame[i]
+      }
+    }
+    bitArray.readUnsignedExpGolombCodedInt(); // max_num_ref_frames
+    bitArray.skipBits(1); // gaps_in_frame_num_value_allowed_flag
+
+    int picWidthInMbs = bitArray.readUnsignedExpGolombCodedInt() + 1;
+    int picHeightInMapUnits = bitArray.readUnsignedExpGolombCodedInt() + 1;
+    boolean frameMbsOnlyFlag = bitArray.readBit();
+    int frameHeightInMbs = (2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
+    if (!frameMbsOnlyFlag) {
+      bitArray.skipBits(1); // mb_adaptive_frame_field_flag
+    }
+
+    bitArray.skipBits(1); // direct_8x8_inference_flag
+    int frameWidth = picWidthInMbs * 16;
+    int frameHeight = frameHeightInMbs * 16;
+    boolean frameCroppingFlag = bitArray.readBit();
+    if (frameCroppingFlag) {
+      int frameCropLeftOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int frameCropRightOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int frameCropTopOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int frameCropBottomOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int cropUnitX, cropUnitY;
+      if (chromaFormatIdc == 0) {
+        cropUnitX = 1;
+        cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);
+      } else {
+        int subWidthC = (chromaFormatIdc == 3) ? 1 : 2;
+        int subHeightC = (chromaFormatIdc == 1) ? 2 : 1;
+        cropUnitX = subWidthC;
+        cropUnitY = subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
+      }
+      frameWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
+      frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
+    }
+
+    // Set the format.
+    setMediaFormat(MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
+        frameWidth, frameHeight, initializationData));
+  }
+
+  private void skipScalingList(ParsableBitArray bitArray, int size) {
+    int lastScale = 8;
+    int nextScale = 8;
+    for (int i = 0; i < size; i++) {
+      if (nextScale != 0) {
+        int deltaScale = bitArray.readSignedExpGolombCodedInt();
+        nextScale = (lastScale + deltaScale + 256) % 256;
+      }
+      lastScale = (nextScale == 0) ? lastScale : nextScale;
+    }
+  }
+
+  /**
+   * Replaces occurrences of [0, 0, 3] with [0, 0].
+   * <p>
+   * See ISO/IEC 14496-10:2005(E) page 36 for more information.
+   */
+  private byte[] unescapeStream(byte[] data, int offset, int limit) {
+    int position = offset;
+    List<Integer> escapePositions = new ArrayList<Integer>();
+    while (position < limit) {
+      position = findNextUnescapeIndex(data, position, limit);
+      if (position < limit) {
+        escapePositions.add(position);
+        position += 3;
+      }
+    }
+
+    int escapeCount = escapePositions.size();
+    int escapedPosition = offset; // The position being read from.
+    int unescapedPosition = 0; // The position being written to.
+    byte[] unescapedData = new byte[limit - offset - escapeCount];
+    for (int i = 0; i < escapeCount; i++) {
+      int nextEscapePosition = escapePositions.get(i);
+      int copyLength = nextEscapePosition - escapedPosition;
+      System.arraycopy(data, escapedPosition, unescapedData, unescapedPosition, copyLength);
+      escapedPosition += copyLength + 3;
+      unescapedPosition += copyLength + 2;
+    }
+
+    int remainingLength = unescapedData.length - unescapedPosition;
+    System.arraycopy(data, escapedPosition, unescapedData, unescapedPosition, remainingLength);
+    return unescapedData;
+  }
+
+  private int findNextUnescapeIndex(byte[] bytes, int offset, int limit) {
+    for (int i = offset; i < limit - 2; i++) {
+      if (bytes[i] == 0x00 && bytes[i + 1] == 0x00 && bytes[i + 2] == 0x03) {
+        return i;
+      }
+    }
+    return limit;
+  }
+
+  /**
+   * A buffer that fills itself with data corresponding to a specific NAL unit, as it is
+   * encountered in the stream.
+   */
+  private static final class NalUnitTargetBuffer {
+
+    private final int targetType;
+
+    private boolean isFilling;
+    private boolean isCompleted;
+
+    public byte[] nalData;
+    public int nalLength;
+
+    public NalUnitTargetBuffer(int targetType, int initialCapacity) {
+      this.targetType = targetType;
+      // Initialize data, writing the known NAL prefix into the first four bytes.
+      nalData = new byte[4 + initialCapacity];
+      nalData[2] = 1;
+      nalData[3] = (byte) targetType;
+    }
+
+    public boolean isCompleted() {
+      return isCompleted;
+    }
+
+    /**
+     * Invoked to indicate that a NAL unit has started.
+     *
+     * @param type The type of the NAL unit.
+     */
+    public void startNalUnit(int type) {
+      Assertions.checkState(!isFilling);
+      isFilling = type == targetType;
+      if (isFilling) {
+        // Length is initially the length of the NAL prefix.
+        nalLength = 4;
+        isCompleted = false;
+      }
+    }
+
+    /**
+     * Invoked to pass stream data. The data passed should not include 4 byte NAL unit prefixes.
+     *
+     * @param data Holds the data being passed.
+     * @param offset The offset of the data in {@code data}.
+     * @param limit The limit (exclusive) of the data in {@code data}.
+     */
+    public void appendToNalUnit(byte[] data, int offset, int limit) {
+      if (!isFilling) {
+        return;
+      }
+      int readLength = limit - offset;
+      if (nalData.length < nalLength + readLength) {
+        nalData = Arrays.copyOf(nalData, (nalLength + readLength) * 2);
+      }
+      System.arraycopy(data, offset, nalData, nalLength, readLength);
+      nalLength += readLength;
+    }
+
+    /**
+     * Invoked to indicate that a NAL unit has ended.
+     *
+     * @param discardPadding The number of excess bytes that were passed to
+     *     {@link #appendToNalUnit(byte[], int, int)}, which should be discarded.
+     * @return True if the ended NAL unit is of the target type. False otherwise.
+     */
+    public boolean endNalUnit(int discardPadding) {
+      if (!isFilling) {
+        return false;
+      }
+      nalLength -= discardPadding;
+      isFilling = false;
+      isCompleted = true;
+      return true;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/Id3Reader.java
new file mode 100644
index 0000000000..609337b664
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/Id3Reader.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Parses ID3 data and extracts individual text information frames.
+ */
+/* package */ class Id3Reader extends PesPayloadReader {
+
+  public Id3Reader(BufferPool bufferPool) {
+    super(bufferPool);
+    setMediaFormat(MediaFormat.createId3Format());
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    if (startOfPacket) {
+      startSample(pesTimeUs);
+    }
+    if (writingSample()) {
+      appendData(data, data.bytesLeft());
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    commitSample(true);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/PesPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/PesPayloadReader.java
new file mode 100644
index 0000000000..2bdce8448a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/PesPayloadReader.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Extracts individual samples from continuous byte stream, preserving original order.
+ */
+/* package */ abstract class PesPayloadReader extends SampleQueue {
+
+  protected PesPayloadReader(BufferPool bufferPool) {
+    super(bufferPool);
+  }
+
+  /**
+   * Consumes (possibly partial) payload data.
+   *
+   * @param data The payload data to consume.
+   * @param pesTimeUs The timestamp associated with the payload.
+   * @param startOfPacket True if this is the first time this method is being called for the
+   *     current packet. False otherwise.
+   */
+  public abstract void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket);
+
+  /**
+   * Invoked once all of the payload data for a packet has been passed to
+   * {@link #consume(ParsableByteArray, long, boolean)}. The next call to
+   * {@link #consume(ParsableByteArray, long, boolean)} will have {@code startOfPacket == true}.
+   */
+  public abstract void packetFinished();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/RollingSampleBuffer.java
new file mode 100644
index 0000000000..48a618edde
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/RollingSampleBuffer.java
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * A rolling buffer of sample data and corresponding sample information.
+ */
+/* package */ final class RollingSampleBuffer {
+
+  private final BufferPool fragmentPool;
+  private final int fragmentLength;
+
+  private final InfoQueue infoQueue;
+  private final ConcurrentLinkedQueue<byte[]> dataQueue;
+  private final long[] dataOffsetHolder;
+
+  // Accessed only by the consuming thread.
+  private long totalBytesDropped;
+
+  // Accessed only by the loading thread.
+  private long totalBytesWritten;
+  private byte[] lastFragment;
+  private int lastFragmentOffset;
+  private long pendingSampleTimeUs;
+  private long pendingSampleOffset;
+
+  public RollingSampleBuffer(BufferPool bufferPool) {
+    this.fragmentPool = bufferPool;
+    fragmentLength = bufferPool.bufferLength;
+    infoQueue = new InfoQueue();
+    dataQueue = new ConcurrentLinkedQueue<byte[]>();
+    dataOffsetHolder = new long[1];
+  }
+
+  public void release() {
+    while (!dataQueue.isEmpty()) {
+      fragmentPool.releaseDirect(dataQueue.remove());
+    }
+  }
+
+  // Called by the consuming thread.
+
+  /**
+   * Fills {@code holder} with information about the current sample, but does not write its data.
+   * <p>
+   * The fields set are {SampleHolder#size}, {SampleHolder#timeUs} and {SampleHolder#flags}.
+   *
+   * @param holder The holder into which the current sample information should be written.
+   * @return True if the holder was filled. False if there is no current sample.
+   */
+  public boolean peekSample(SampleHolder holder) {
+    return infoQueue.peekSample(holder, dataOffsetHolder);
+  }
+
+  /**
+   * Skips the current sample.
+   */
+  public void skipSample() {
+    long nextOffset = infoQueue.moveToNextSample();
+    dropFragmentsTo(nextOffset);
+  }
+
+  /**
+   * Reads the current sample, advancing the read index to the next sample.
+   *
+   * @param holder The holder into which the current sample should be written.
+   */
+  public void readSample(SampleHolder holder) {
+    // Write the sample information into the holder.
+    infoQueue.peekSample(holder, dataOffsetHolder);
+    // Write the sample data into the holder.
+    if (holder.data == null || holder.data.capacity() < holder.size) {
+      holder.replaceBuffer(holder.size);
+    }
+    if (holder.data != null) {
+      readData(dataOffsetHolder[0], holder.data, holder.size);
+    }
+    // Advance the read head.
+    long nextOffset = infoQueue.moveToNextSample();
+    dropFragmentsTo(nextOffset);
+  }
+
+  /**
+   * Reads data from the front of the rolling buffer.
+   *
+   * @param absolutePosition The absolute position from which data should be read.
+   * @param target The buffer into which data should be written.
+   * @param length The number of bytes to read.
+   */
+  private void readData(long absolutePosition, ByteBuffer target, int length) {
+    int remaining = length;
+    while (remaining > 0) {
+      dropFragmentsTo(absolutePosition);
+      int positionInFragment = (int) (absolutePosition - totalBytesDropped);
+      int toCopy = Math.min(remaining, fragmentLength - positionInFragment);
+      target.put(dataQueue.peek(), positionInFragment, toCopy);
+      absolutePosition += toCopy;
+      remaining -= toCopy;
+    }
+  }
+
+  /**
+   * Discard any fragments that hold data prior to the specified absolute position, returning
+   * them to the pool.
+   *
+   * @param absolutePosition The absolute position up to which fragments can be discarded.
+   */
+  private void dropFragmentsTo(long absolutePosition) {
+    int relativePosition = (int) (absolutePosition - totalBytesDropped);
+    int fragmentIndex = relativePosition / fragmentLength;
+    for (int i = 0; i < fragmentIndex; i++) {
+      fragmentPool.releaseDirect(dataQueue.remove());
+      totalBytesDropped += fragmentLength;
+    }
+  }
+
+  // Called by the loading thread.
+
+  /**
+   * Indicates the start point for the next sample.
+   *
+   * @param sampleTimeUs The sample timestamp.
+   * @param offset The offset of the sample's data, relative to the total number of bytes written
+   *     to the buffer. Must be negative or zero.
+   */
+  public void startSample(long sampleTimeUs, int offset) {
+    Assertions.checkState(offset <= 0);
+    pendingSampleTimeUs = sampleTimeUs;
+    pendingSampleOffset = totalBytesWritten + offset;
+  }
+
+  /**
+   * Appends data to the rolling buffer.
+   *
+   * @param buffer A buffer containing the data to append.
+   * @param length The length of the data to append.
+   */
+  public void appendData(ParsableByteArray buffer, int length) {
+    int remainingWriteLength = length;
+    while (remainingWriteLength > 0) {
+      if (dataQueue.isEmpty() || lastFragmentOffset == fragmentLength) {
+        lastFragmentOffset = 0;
+        lastFragment = fragmentPool.allocateDirect();
+        dataQueue.add(lastFragment);
+      }
+      int thisWriteLength = Math.min(remainingWriteLength, fragmentLength - lastFragmentOffset);
+      buffer.readBytes(lastFragment, lastFragmentOffset, thisWriteLength);
+      lastFragmentOffset += thisWriteLength;
+      remainingWriteLength -= thisWriteLength;
+    }
+    totalBytesWritten += length;
+  }
+
+  /**
+   * Indicates the end point for the current sample, making it available for consumption.
+   *
+   * @param isKeyframe True if the sample being committed is a keyframe. False otherwise.
+   * @param offset The offset of the first byte after the end of the sample's data, relative to
+   *     the total number of bytes written to the buffer. Must be negative or zero.
+   */
+  public void commitSample(boolean isKeyframe, int offset) {
+    Assertions.checkState(offset <= 0);
+    int sampleSize = (int) (totalBytesWritten + offset - pendingSampleOffset);
+    infoQueue.commitSample(pendingSampleTimeUs, pendingSampleOffset, sampleSize,
+        isKeyframe ? C.SAMPLE_FLAG_SYNC : 0);
+  }
+
+  /**
+   * Holds information about the samples in the rolling buffer.
+   */
+  private static class InfoQueue {
+
+    private static final int SAMPLE_CAPACITY_INCREMENT = 1000;
+
+    private int capacity;
+
+    private long[] offsets;
+    private int[] sizes;
+    private int[] flags;
+    private long[] timesUs;
+
+    private int queueSize;
+    private int readIndex;
+    private int writeIndex;
+
+    public InfoQueue() {
+      capacity = SAMPLE_CAPACITY_INCREMENT;
+      offsets = new long[capacity];
+      timesUs = new long[capacity];
+      flags = new int[capacity];
+      sizes = new int[capacity];
+    }
+
+    // Called by the consuming thread.
+
+    /**
+     * Fills {@code holder} with information about the current sample, but does not write its data.
+     * The first entry in {@code offsetHolder} is filled with the absolute position of the sample's
+     * data in the rolling buffer.
+     * <p>
+     * The fields set are {SampleHolder#size}, {SampleHolder#timeUs}, {SampleHolder#flags} and
+     * {@code offsetHolder[0]}.
+     *
+     * @param holder The holder into which the current sample information should be written.
+     * @param offsetHolder The holder into which the absolute position of the sample's data should
+     *     be written.
+     * @return True if the holders were filled. False if there is no current sample.
+     */
+    public synchronized boolean peekSample(SampleHolder holder, long[] offsetHolder) {
+      if (queueSize == 0) {
+        return false;
+      }
+      holder.timeUs = timesUs[readIndex];
+      holder.size = sizes[readIndex];
+      holder.flags = flags[readIndex];
+      offsetHolder[0] = offsets[readIndex];
+      return true;
+    }
+
+    /**
+     * Advances the read index to the next sample.
+     *
+     * @return The absolute position of the first byte in the rolling buffer that may still be
+     *     required after advancing the index. Data prior to this position can be dropped.
+     */
+    public synchronized long moveToNextSample() {
+      queueSize--;
+      int lastReadIndex = readIndex++;
+      if (readIndex == capacity) {
+        // Wrap around.
+        readIndex = 0;
+      }
+      return queueSize > 0 ? offsets[readIndex] : (sizes[lastReadIndex] + offsets[lastReadIndex]);
+    }
+
+    // Called by the loading thread.
+
+    public synchronized void commitSample(long timeUs, long offset, int size, int sampleFlags) {
+      timesUs[writeIndex] = timeUs;
+      offsets[writeIndex] = offset;
+      sizes[writeIndex] = size;
+      flags[writeIndex] = sampleFlags;
+      // Increment the write index.
+      queueSize++;
+      if (queueSize == capacity) {
+        // Increase the capacity.
+        int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
+        long[] newOffsets = new long[newCapacity];
+        long[] newTimesUs = new long[newCapacity];
+        int[] newFlags = new int[newCapacity];
+        int[] newSizes = new int[newCapacity];
+        int beforeWrap = capacity - readIndex;
+        System.arraycopy(offsets, readIndex, newOffsets, 0, beforeWrap);
+        System.arraycopy(timesUs, readIndex, newTimesUs, 0, beforeWrap);
+        System.arraycopy(flags, readIndex, newFlags, 0, beforeWrap);
+        System.arraycopy(sizes, readIndex, newSizes, 0, beforeWrap);
+        int afterWrap = readIndex;
+        System.arraycopy(offsets, 0, newOffsets, beforeWrap, afterWrap);
+        System.arraycopy(timesUs, 0, newTimesUs, beforeWrap, afterWrap);
+        System.arraycopy(flags, 0, newFlags, beforeWrap, afterWrap);
+        System.arraycopy(sizes, 0, newSizes, beforeWrap, afterWrap);
+        offsets = newOffsets;
+        timesUs = newTimesUs;
+        flags = newFlags;
+        sizes = newSizes;
+        readIndex = 0;
+        writeIndex = capacity;
+        queueSize = capacity;
+        capacity = newCapacity;
+      } else {
+        writeIndex++;
+        if (writeIndex == capacity) {
+          // Wrap around.
+          writeIndex = 0;
+        }
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/SampleQueue.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/SampleQueue.java
new file mode 100644
index 0000000000..348a2cd843
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/SampleQueue.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Wraps a {@link RollingSampleBuffer}, adding higher level functionality such as enforcing that
+ * the first sample returned from the queue is a keyframe, allowing splicing to another queue, and
+ * so on.
+ */
+/* package */ abstract class SampleQueue {
+
+  private final RollingSampleBuffer rollingBuffer;
+  private final SampleHolder sampleInfoHolder;
+
+  // Accessed only by the consuming thread.
+  private boolean needKeyframe;
+  private long lastReadTimeUs;
+  private long spliceOutTimeUs;
+
+  // Accessed only by the loading thread.
+  private boolean writingSample;
+
+  // Accessed by both the loading and consuming threads.
+  private volatile MediaFormat mediaFormat;
+  private volatile long largestParsedTimestampUs;
+
+  protected SampleQueue(BufferPool bufferPool) {
+    rollingBuffer = new RollingSampleBuffer(bufferPool);
+    sampleInfoHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DISABLED);
+    needKeyframe = true;
+    lastReadTimeUs = Long.MIN_VALUE;
+    spliceOutTimeUs = Long.MIN_VALUE;
+    largestParsedTimestampUs = Long.MIN_VALUE;
+  }
+
+  public void release() {
+    rollingBuffer.release();
+  }
+
+  // Called by the consuming thread.
+
+  public long getLargestParsedTimestampUs() {
+    return largestParsedTimestampUs;
+  }
+
+  public boolean hasMediaFormat() {
+    return mediaFormat != null;
+  }
+
+  public MediaFormat getMediaFormat() {
+    return mediaFormat;
+  }
+
+  public boolean isEmpty() {
+    return !advanceToEligibleSample();
+  }
+
+  /**
+   * Removes the next sample from the head of the queue, writing it into the provided holder.
+   * <p>
+   * The first sample returned is guaranteed to be a keyframe, since any non-keyframe samples
+   * queued prior to the first keyframe are discarded.
+   *
+   * @param holder A {@link SampleHolder} into which the sample should be read.
+   * @return True if a sample was read. False otherwise.
+   */
+  public boolean getSample(SampleHolder holder) {
+    boolean foundEligibleSample = advanceToEligibleSample();
+    if (!foundEligibleSample) {
+      return false;
+    }
+    // Write the sample into the holder.
+    rollingBuffer.readSample(holder);
+    needKeyframe = false;
+    lastReadTimeUs = holder.timeUs;
+    return true;
+  }
+
+  /**
+   * Discards samples from the queue up to the specified time.
+   *
+   * @param timeUs The time up to which samples should be discarded, in microseconds.
+   */
+  public void discardUntil(long timeUs) {
+    while (rollingBuffer.peekSample(sampleInfoHolder) && sampleInfoHolder.timeUs < timeUs) {
+      rollingBuffer.skipSample();
+      // We're discarding one or more samples. A subsequent read will need to start at a keyframe.
+      needKeyframe = true;
+    }
+    lastReadTimeUs = Long.MIN_VALUE;
+  }
+
+  /**
+   * Attempts to configure a splice from this queue to the next.
+   *
+   * @param nextQueue The queue being spliced to.
+   * @return Whether the splice was configured successfully.
+   */
+  public boolean configureSpliceTo(SampleQueue nextQueue) {
+    if (spliceOutTimeUs != Long.MIN_VALUE) {
+      // We've already configured the splice.
+      return true;
+    }
+    long firstPossibleSpliceTime;
+    if (rollingBuffer.peekSample(sampleInfoHolder)) {
+      firstPossibleSpliceTime = sampleInfoHolder.timeUs;
+    } else {
+      firstPossibleSpliceTime = lastReadTimeUs + 1;
+    }
+    RollingSampleBuffer nextRollingBuffer = nextQueue.rollingBuffer;
+    while (nextRollingBuffer.peekSample(sampleInfoHolder)
+        && (sampleInfoHolder.timeUs < firstPossibleSpliceTime
+            || (sampleInfoHolder.flags & C.SAMPLE_FLAG_SYNC) == 0)) {
+      // Discard samples from the next queue for as long as they are before the earliest possible
+      // splice time, or not keyframes.
+      nextRollingBuffer.skipSample();
+    }
+    if (nextRollingBuffer.peekSample(sampleInfoHolder)) {
+      // We've found a keyframe in the next queue that can serve as the splice point. Set the
+      // splice point now.
+      spliceOutTimeUs = sampleInfoHolder.timeUs;
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Advances the underlying buffer to the next sample that is eligible to be returned.
+   *
+   * @boolean True if an eligible sample was found. False otherwise, in which case the underlying
+   *     buffer has been emptied.
+   */
+  private boolean advanceToEligibleSample() {
+    boolean haveNext = rollingBuffer.peekSample(sampleInfoHolder);
+    if (needKeyframe) {
+      while (haveNext && (sampleInfoHolder.flags & C.SAMPLE_FLAG_SYNC) == 0) {
+        rollingBuffer.skipSample();
+        haveNext = rollingBuffer.peekSample(sampleInfoHolder);
+      }
+    }
+    if (!haveNext) {
+      return false;
+    }
+    if (spliceOutTimeUs != Long.MIN_VALUE && sampleInfoHolder.timeUs >= spliceOutTimeUs) {
+      return false;
+    }
+    return true;
+  }
+
+  // Called by the loading thread.
+
+  protected boolean writingSample() {
+    return writingSample;
+  }
+
+  protected void setMediaFormat(MediaFormat mediaFormat) {
+    this.mediaFormat = mediaFormat;
+  }
+
+  protected void startSample(long sampleTimeUs) {
+    startSample(sampleTimeUs, 0);
+  }
+
+  protected void startSample(long sampleTimeUs, int offset) {
+    writingSample = true;
+    largestParsedTimestampUs = Math.max(largestParsedTimestampUs, sampleTimeUs);
+    rollingBuffer.startSample(sampleTimeUs, offset);
+  }
+
+  protected void appendData(ParsableByteArray buffer, int length) {
+    rollingBuffer.appendData(buffer, length);
+  }
+
+  protected void commitSample(boolean isKeyframe) {
+    commitSample(isKeyframe, 0);
+  }
+
+  protected void commitSample(boolean isKeyframe, int offset) {
+    rollingBuffer.commitSample(isKeyframe, offset);
+    writingSample = false;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/SeiReader.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/SeiReader.java
new file mode 100644
index 0000000000..6da719ae22
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/SeiReader.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.text.eia608.Eia608Parser;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Parses a SEI data from H.264 frames and extracts samples with closed captions data.
+ *
+ * TODO: Technically, we shouldn't allow a sample to be read from the queue until we're sure that
+ * a sample with an earlier timestamp won't be added to it.
+ */
+/* package */ class SeiReader extends SampleQueue {
+
+  private final ParsableByteArray seiBuffer;
+
+  public SeiReader(BufferPool bufferPool) {
+    super(bufferPool);
+    setMediaFormat(MediaFormat.createEia608Format());
+    seiBuffer = new ParsableByteArray();
+  }
+
+  public void read(byte[] data, int position, long pesTimeUs) {
+    seiBuffer.reset(data, data.length);
+    seiBuffer.setPosition(position + 4);
+    int ccDataSize = Eia608Parser.parseHeader(seiBuffer);
+    if (ccDataSize > 0) {
+      startSample(pesTimeUs);
+      appendData(seiBuffer, ccDataSize);
+      commitSample(true);
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java
new file mode 100644
index 0000000000..d7ad5e7dde
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java
@@ -0,0 +1,608 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls.parser;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.util.Log;
+import android.util.SparseArray;
+
+import java.io.IOException;
+
+/**
+ * Facilitates the extraction of data from the MPEG-2 TS container format.
+ */
+public final class TsExtractor {
+
+  private static final String TAG = "TsExtractor";
+
+  private static final int TS_PACKET_SIZE = 188;
+  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
+  private static final int TS_PAT_PID = 0;
+
+  private static final int TS_STREAM_TYPE_AAC = 0x0F;
+  private static final int TS_STREAM_TYPE_H264 = 0x1B;
+  private static final int TS_STREAM_TYPE_ID3 = 0x15;
+  private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1
+
+  private static final long MAX_PTS = 0x1FFFFFFFFL;
+
+  private final ParsableByteArray tsPacketBuffer;
+  private final SparseArray<SampleQueue> sampleQueues; // Indexed by streamType
+  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
+  private final BufferPool bufferPool;
+  private final boolean shouldSpliceIn;
+  private final long firstSampleTimestamp;
+  private final ParsableBitArray tsScratch;
+
+  // Accessed only by the consuming thread.
+  private boolean spliceConfigured;
+
+  // Accessed only by the loading thread.
+  private int tsPacketBytesRead;
+  private long timestampOffsetUs;
+  private long lastPts;
+
+  // Accessed by both the loading and consuming threads.
+  private volatile boolean prepared;
+
+  public TsExtractor(long firstSampleTimestamp, boolean shouldSpliceIn, BufferPool bufferPool) {
+    this.firstSampleTimestamp = firstSampleTimestamp;
+    this.shouldSpliceIn = shouldSpliceIn;
+    this.bufferPool = bufferPool;
+    tsScratch = new ParsableBitArray(new byte[3]);
+    tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
+    sampleQueues = new SparseArray<SampleQueue>();
+    tsPayloadReaders = new SparseArray<TsPayloadReader>();
+    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
+    lastPts = Long.MIN_VALUE;
+  }
+
+  /**
+   * Gets the number of available tracks.
+   * <p>
+   * This method should only be called after the extractor has been prepared.
+   *
+   * @return The number of available tracks.
+   */
+  public int getTrackCount() {
+    Assertions.checkState(prepared);
+    return sampleQueues.size();
+  }
+
+  /**
+   * Gets the format of the specified track.
+   * <p>
+   * This method must only be called after the extractor has been prepared.
+   *
+   * @param track The track index.
+   * @return The corresponding format.
+   */
+  public MediaFormat getFormat(int track) {
+    Assertions.checkState(prepared);
+    return sampleQueues.valueAt(track).getMediaFormat();
+  }
+
+  /**
+   * Whether the extractor is prepared.
+   *
+   * @return True if the extractor is prepared. False otherwise.
+   */
+  public boolean isPrepared() {
+    return prepared;
+  }
+
+  /**
+   * Releases the extractor, recycling any pending or incomplete samples to the sample pool.
+   * <p>
+   * This method should not be called whilst {@link #read(DataSource)} is also being invoked.
+   */
+  public void release() {
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      sampleQueues.valueAt(i).release();
+    }
+  }
+
+  /**
+   * Attempts to configure a splice from this extractor to the next.
+   * <p>
+   * The splice is performed such that for each track the samples read from the next extractor
+   * start with a keyframe, and continue from where the samples read from this extractor finish.
+   * A successful splice may discard samples from either or both extractors.
+   * <p>
+   * Splice configuration may fail if the next extractor is not yet in a state that allows the
+   * splice to be performed. Calling this method is a noop if the splice has already been
+   * configured. Hence this method should be called repeatedly during the window within which a
+   * splice can be performed.
+   *
+   * @param nextExtractor The extractor being spliced to.
+   */
+  public void configureSpliceTo(TsExtractor nextExtractor) {
+    Assertions.checkState(prepared);
+    if (spliceConfigured || !nextExtractor.shouldSpliceIn || !nextExtractor.isPrepared()) {
+      // The splice is already configured, or the next extractor doesn't want to be spliced in, or
+      // the next extractor isn't ready to be spliced in.
+      return;
+    }
+    boolean spliceConfigured = true;
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      spliceConfigured &= sampleQueues.valueAt(i).configureSpliceTo(
+          nextExtractor.sampleQueues.valueAt(i));
+    }
+    this.spliceConfigured = spliceConfigured;
+    return;
+  }
+
+  /**
+   * Gets the largest timestamp of any sample parsed by the extractor.
+   *
+   * @return The largest timestamp, or {@link Long#MIN_VALUE} if no samples have been parsed.
+   */
+  public long getLargestSampleTimestamp() {
+    long largestParsedTimestampUs = Long.MIN_VALUE;
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
+          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
+    }
+    return largestParsedTimestampUs;
+  }
+
+  /**
+   * Gets the next sample for the specified track.
+   *
+   * @param track The track from which to read.
+   * @param holder A {@link SampleHolder} into which the sample should be read.
+   * @return True if a sample was read. False otherwise.
+   */
+  public boolean getSample(int track, SampleHolder holder) {
+    Assertions.checkState(prepared);
+    return sampleQueues.valueAt(track).getSample(holder);
+  }
+
+  /**
+   * Discards samples for the specified track up to the specified time.
+   *
+   * @param track The track from which samples should be discarded.
+   * @param timeUs The time up to which samples should be discarded, in microseconds.
+   */
+  public void discardUntil(int track, long timeUs) {
+    Assertions.checkState(prepared);
+    sampleQueues.valueAt(track).discardUntil(timeUs);
+  }
+
+  /**
+   * Whether samples are available for reading from {@link #getSample(int, SampleHolder)} for the
+   * specified track.
+   *
+   * @return True if samples are available for reading from {@link #getSample(int, SampleHolder)}
+   *     for the specified track. False otherwise.
+   */
+  public boolean hasSamples(int track) {
+    Assertions.checkState(prepared);
+    return !sampleQueues.valueAt(track).isEmpty();
+  }
+
+  private boolean checkPrepared() {
+    int pesPayloadReaderCount = sampleQueues.size();
+    if (pesPayloadReaderCount == 0) {
+      return false;
+    }
+    for (int i = 0; i < pesPayloadReaderCount; i++) {
+      if (!sampleQueues.valueAt(i).hasMediaFormat()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Reads up to a single TS packet.
+   *
+   * @param dataSource The {@link DataSource} from which to read.
+   * @throws IOException If an error occurred reading from the source.
+   * @return The number of bytes read from the source.
+   */
+  public int read(DataSource dataSource) throws IOException {
+    int bytesRead = dataSource.read(tsPacketBuffer.data, tsPacketBytesRead,
+        TS_PACKET_SIZE - tsPacketBytesRead);
+    if (bytesRead == -1) {
+      return -1;
+    }
+
+    tsPacketBytesRead += bytesRead;
+    if (tsPacketBytesRead < TS_PACKET_SIZE) {
+      // We haven't read the whole packet yet.
+      return bytesRead;
+    }
+
+    // Reset before reading the packet.
+    tsPacketBytesRead = 0;
+    tsPacketBuffer.setPosition(0);
+    tsPacketBuffer.setLimit(TS_PACKET_SIZE);
+
+    int syncByte = tsPacketBuffer.readUnsignedByte();
+    if (syncByte != TS_SYNC_BYTE) {
+      return bytesRead;
+    }
+
+    tsPacketBuffer.readBytes(tsScratch, 3);
+    tsScratch.skipBits(1); // transport_error_indicator
+    boolean payloadUnitStartIndicator = tsScratch.readBit();
+    tsScratch.skipBits(1); // transport_priority
+    int pid = tsScratch.readBits(13);
+    tsScratch.skipBits(2); // transport_scrambling_control
+    boolean adaptationFieldExists = tsScratch.readBit();
+    boolean payloadExists = tsScratch.readBit();
+    // Last 4 bits of scratch are skipped: continuity_counter
+
+    // Skip the adaptation field.
+    if (adaptationFieldExists) {
+      int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
+      tsPacketBuffer.skip(adaptationFieldLength);
+    }
+
+    // Read the payload.
+    if (payloadExists) {
+      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
+      if (payloadReader != null) {
+        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+      }
+    }
+
+    if (!prepared) {
+      prepared = checkPrepared();
+    }
+
+    return bytesRead;
+  }
+
+  /**
+   * Adjusts a PTS value to the corresponding time in microseconds, accounting for PTS wraparound.
+   *
+   * @param pts The raw PTS value.
+   * @return The corresponding time in microseconds.
+   */
+  /* package */ long ptsToTimeUs(long pts) {
+    if (lastPts != Long.MIN_VALUE) {
+      // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
+      // and we need to snap to the one closest to lastPts.
+      long closestWrapCount = (lastPts + (MAX_PTS / 2)) / MAX_PTS;
+      long ptsWrapBelow = pts + (MAX_PTS * (closestWrapCount - 1));
+      long ptsWrapAbove = pts + (MAX_PTS * closestWrapCount);
+      pts = Math.abs(ptsWrapBelow - lastPts) < Math.abs(ptsWrapAbove - lastPts)
+          ? ptsWrapBelow : ptsWrapAbove;
+    }
+    // Calculate the corresponding timestamp.
+    long timeUs = (pts * C.MICROS_PER_SECOND) / 90000;
+    // If we haven't done the initial timestamp adjustment, do it now.
+    if (lastPts == Long.MIN_VALUE) {
+      timestampOffsetUs = firstSampleTimestamp - timeUs;
+    }
+    // Record the adjusted PTS to adjust for wraparound next time.
+    lastPts = pts;
+    return timeUs + timestampOffsetUs;
+  }
+
+  /**
+   * Parses TS packet payload data.
+   */
+  private abstract static class TsPayloadReader {
+
+    public abstract void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);
+
+  }
+
+  /**
+   * Parses Program Association Table data.
+   */
+  private class PatReader extends TsPayloadReader {
+
+    private final ParsableBitArray patScratch;
+
+    public PatReader() {
+      patScratch = new ParsableBitArray(new byte[4]);
+    }
+
+    @Override
+    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+      // Skip pointer.
+      if (payloadUnitStartIndicator) {
+        int pointerField = data.readUnsignedByte();
+        data.skip(pointerField);
+      }
+
+      data.readBytes(patScratch, 3);
+      patScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
+      int sectionLength = patScratch.readBits(12);
+      // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
+      // section_number (8), last_section_number (8)
+      data.skip(5);
+
+      int programCount = (sectionLength - 9) / 4;
+      for (int i = 0; i < programCount; i++) {
+        data.readBytes(patScratch, 4);
+        patScratch.skipBits(19); // program_number (16), reserved (3)
+        int pid = patScratch.readBits(13);
+        tsPayloadReaders.put(pid, new PmtReader());
+      }
+
+      // Skip CRC_32.
+    }
+
+  }
+
+  /**
+   * Parses Program Map Table.
+   */
+  private class PmtReader extends TsPayloadReader {
+
+    private final ParsableBitArray pmtScratch;
+
+    public PmtReader() {
+      pmtScratch = new ParsableBitArray(new byte[5]);
+    }
+
+    @Override
+    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+      // Skip pointer.
+      if (payloadUnitStartIndicator) {
+        int pointerField = data.readUnsignedByte();
+        data.skip(pointerField);
+      }
+
+      data.readBytes(pmtScratch, 3);
+      pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
+      int sectionLength = pmtScratch.readBits(12);
+
+      // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
+      // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
+      // Skip the rest of the PMT header.
+      data.skip(7);
+
+      data.readBytes(pmtScratch, 2);
+      pmtScratch.skipBits(4);
+      int programInfoLength = pmtScratch.readBits(12);
+
+      // Skip the descriptors.
+      data.skip(programInfoLength);
+
+      int entriesSize = sectionLength - 9 /* Size of the rest of the fields before descriptors */
+          - programInfoLength - 4 /* CRC size */;
+      while (entriesSize > 0) {
+        data.readBytes(pmtScratch, 5);
+        int streamType = pmtScratch.readBits(8);
+        pmtScratch.skipBits(3); // reserved
+        int elementaryPid = pmtScratch.readBits(13);
+        pmtScratch.skipBits(4); // reserved
+        int esInfoLength = pmtScratch.readBits(12);
+
+        // Skip the descriptors.
+        data.skip(esInfoLength);
+        entriesSize -= esInfoLength + 5;
+
+        if (sampleQueues.get(streamType) != null) {
+          continue;
+        }
+
+        PesPayloadReader pesPayloadReader = null;
+        switch (streamType) {
+          case TS_STREAM_TYPE_AAC:
+            pesPayloadReader = new AdtsReader(bufferPool);
+            break;
+          case TS_STREAM_TYPE_H264:
+            SeiReader seiReader = new SeiReader(bufferPool);
+            sampleQueues.put(TS_STREAM_TYPE_EIA608, seiReader);
+            pesPayloadReader = new H264Reader(bufferPool, seiReader);
+            break;
+          case TS_STREAM_TYPE_ID3:
+            pesPayloadReader = new Id3Reader(bufferPool);
+            break;
+        }
+
+        if (pesPayloadReader != null) {
+          sampleQueues.put(streamType, pesPayloadReader);
+          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader));
+        }
+      }
+
+      // Skip CRC_32.
+    }
+
+  }
+
+  /**
+   * Parses PES packet data and extracts samples.
+   */
+  private class PesReader extends TsPayloadReader {
+
+    private static final int STATE_FINDING_HEADER = 0;
+    private static final int STATE_READING_HEADER = 1;
+    private static final int STATE_READING_HEADER_EXTENSION = 2;
+    private static final int STATE_READING_BODY = 3;
+
+    private static final int HEADER_SIZE = 9;
+    private static final int MAX_HEADER_EXTENSION_SIZE = 5;
+
+    private final ParsableBitArray pesScratch;
+    private final PesPayloadReader pesPayloadReader;
+
+    private int state;
+    private int bytesRead;
+    private boolean bodyStarted;
+
+    private boolean ptsFlag;
+    private int extendedHeaderLength;
+
+    private int payloadSize;
+
+    private long timeUs;
+
+    public PesReader(PesPayloadReader pesPayloadReader) {
+      this.pesPayloadReader = pesPayloadReader;
+      pesScratch = new ParsableBitArray(new byte[HEADER_SIZE]);
+      state = STATE_FINDING_HEADER;
+    }
+
+    @Override
+    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+      if (payloadUnitStartIndicator) {
+        switch (state) {
+          case STATE_FINDING_HEADER:
+          case STATE_READING_HEADER:
+            // Expected.
+            break;
+          case STATE_READING_HEADER_EXTENSION:
+            Log.w(TAG, "Unexpected start indicator reading extended header");
+            break;
+          case STATE_READING_BODY:
+            // If payloadSize == -1 then the length of the previous packet was unspecified, and so
+            // we only know that it's finished now that we've seen the start of the next one. This
+            // is expected. If payloadSize != -1, then the length of the previous packet was known,
+            // but we didn't receive that amount of data. This is not expected.
+            if (payloadSize != -1) {
+              Log.w(TAG, "Unexpected start indicator: expected " + payloadSize + " more bytes");
+            }
+            // Either way, if the body was started, notify the reader that it has now finished.
+            if (bodyStarted) {
+              pesPayloadReader.packetFinished();
+            }
+            break;
+        }
+        setState(STATE_READING_HEADER);
+      }
+
+      while (data.bytesLeft() > 0) {
+        switch (state) {
+          case STATE_FINDING_HEADER:
+            data.skip(data.bytesLeft());
+            break;
+          case STATE_READING_HEADER:
+            if (continueRead(data, pesScratch.getData(), HEADER_SIZE)) {
+              setState(parseHeader() ? STATE_READING_HEADER_EXTENSION : STATE_FINDING_HEADER);
+            }
+            break;
+          case STATE_READING_HEADER_EXTENSION:
+            int readLength = Math.min(MAX_HEADER_EXTENSION_SIZE, extendedHeaderLength);
+            // Read as much of the extended header as we're interested in, and skip the rest.
+            if (continueRead(data, pesScratch.getData(), readLength)
+                && continueRead(data, null, extendedHeaderLength)) {
+              parseHeaderExtension();
+              bodyStarted = false;
+              setState(STATE_READING_BODY);
+            }
+            break;
+          case STATE_READING_BODY:
+            readLength = data.bytesLeft();
+            int padding = payloadSize == -1 ? 0 : readLength - payloadSize;
+            if (padding > 0) {
+              readLength -= padding;
+              data.setLimit(data.getPosition() + readLength);
+            }
+            pesPayloadReader.consume(data, timeUs, !bodyStarted);
+            bodyStarted = true;
+            if (payloadSize != -1) {
+              payloadSize -= readLength;
+              if (payloadSize == 0) {
+                pesPayloadReader.packetFinished();
+                setState(STATE_READING_HEADER);
+              }
+            }
+            break;
+        }
+      }
+    }
+
+    private void setState(int state) {
+      this.state = state;
+      bytesRead = 0;
+    }
+
+    /**
+     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+     * that the data should be written into {@code target} starting from an offset of zero.
+     *
+     * @param source The source from which to read.
+     * @param target The target into which data is to be read, or {@code null} to skip.
+     * @param targetLength The target length of the read.
+     * @return Whether the target length has been reached.
+     */
+    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+      int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+      if (bytesToRead <= 0) {
+        return true;
+      } else if (target == null) {
+        source.skip(bytesToRead);
+      } else {
+        source.readBytes(target, bytesRead, bytesToRead);
+      }
+      bytesRead += bytesToRead;
+      return bytesRead == targetLength;
+    }
+
+    private boolean parseHeader() {
+      pesScratch.setPosition(0);
+      int startCodePrefix = pesScratch.readBits(24);
+      if (startCodePrefix != 0x000001) {
+        Log.w(TAG, "Unexpected start code prefix: " + startCodePrefix);
+        payloadSize = -1;
+        return false;
+      }
+
+      pesScratch.skipBits(8); // stream_id.
+      int packetLength = pesScratch.readBits(16);
+      // First 8 bits are skipped: '10' (2), PES_scrambling_control (2), PES_priority (1),
+      // data_alignment_indicator (1), copyright (1), original_or_copy (1)
+      pesScratch.skipBits(8);
+      ptsFlag = pesScratch.readBit();
+      // DTS_flag (1), ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
+      // additional_copy_info_flag (1), PES_CRC_flag (1), PES_extension_flag (1)
+      pesScratch.skipBits(7);
+      extendedHeaderLength = pesScratch.readBits(8);
+
+      if (packetLength == 0) {
+        payloadSize = -1;
+      } else {
+        payloadSize = packetLength + 6 /* packetLength does not include the first 6 bytes */
+            - HEADER_SIZE - extendedHeaderLength;
+      }
+      return true;
+    }
+
+    private void parseHeaderExtension() {
+      pesScratch.setPosition(0);
+      timeUs = 0;
+      if (ptsFlag) {
+        pesScratch.skipBits(4); // '0010'
+        long pts = pesScratch.readBitsLong(3) << 30;
+        pesScratch.skipBits(1); // marker_bit
+        pts |= pesScratch.readBitsLong(15) << 15;
+        pesScratch.skipBits(1); // marker_bit
+        pts |= pesScratch.readBitsLong(15);
+        pesScratch.skipBits(1); // marker_bit
+        timeUs = ptsToTimeUs(pts);
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
new file mode 100644
index 0000000000..1ec0e363dd
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.UnsupportedEncodingException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Extracts individual TXXX text frames from raw ID3 data.
+ */
+public class Id3Parser implements MetadataParser<Map<String, Object>> {
+
+  @Override
+  public boolean canParse(String mimeType) {
+    return mimeType.equals(MimeTypes.APPLICATION_ID3);
+  }
+
+  @Override
+  public Map<String, Object> parse(byte[] data, int size)
+      throws UnsupportedEncodingException, ParserException {
+    Map<String, Object> metadata = new HashMap<String, Object>();
+    ParsableByteArray id3Data = new ParsableByteArray(data, size);
+    int id3Size = parseId3Header(id3Data);
+
+    while (id3Size > 0) {
+      int frameId0 = id3Data.readUnsignedByte();
+      int frameId1 = id3Data.readUnsignedByte();
+      int frameId2 = id3Data.readUnsignedByte();
+      int frameId3 = id3Data.readUnsignedByte();
+      int frameSize = id3Data.readSynchSafeInt();
+      if (frameSize <= 1) {
+        break;
+      }
+
+      // Skip frame flags.
+      id3Data.skip(2);
+      // Check Frame ID == TXXX.
+      if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
+        int encoding = id3Data.readUnsignedByte();
+        String charset = getCharsetName(encoding);
+        byte[] frame = new byte[frameSize - 1];
+        id3Data.readBytes(frame, 0, frameSize - 1);
+
+        int firstZeroIndex = indexOf(frame, 0, (byte) 0);
+        String description = new String(frame, 0, firstZeroIndex, charset);
+        int valueStartIndex = indexOfNot(frame, firstZeroIndex, (byte) 0);
+        int valueEndIndex = indexOf(frame, valueStartIndex, (byte) 0);
+        String value = new String(frame, valueStartIndex, valueEndIndex - valueStartIndex,
+            charset);
+        metadata.put(TxxxMetadata.TYPE, new TxxxMetadata(description, value));
+      } else {
+        String type = String.format("%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        byte[] frame = new byte[frameSize];
+        id3Data.readBytes(frame, 0, frameSize);
+        metadata.put(type, frame);
+      }
+
+      id3Size -= frameSize + 10 /* header size */;
+    }
+
+    return Collections.unmodifiableMap(metadata);
+  }
+
+  private static int indexOf(byte[] data, int fromIndex, byte key) {
+    for (int i = fromIndex; i < data.length; i++) {
+      if (data[i] == key) {
+        return i;
+      }
+    }
+    return data.length;
+  }
+
+  private static int indexOfNot(byte[] data, int fromIndex, byte key) {
+    for (int i = fromIndex; i < data.length; i++) {
+      if (data[i] != key) {
+        return i;
+      }
+    }
+    return data.length;
+  }
+
+  /**
+   * Parses an ID3 header.
+   *
+   * @param id3Buffer A {@link ParsableByteArray} from which data should be read.
+   * @return The size of ID3 frames in bytes, excluding the header and footer.
+   * @throws ParserException If ID3 file identifier != "ID3".
+   */
+  private static int parseId3Header(ParsableByteArray id3Buffer) throws ParserException {
+    int id1 = id3Buffer.readUnsignedByte();
+    int id2 = id3Buffer.readUnsignedByte();
+    int id3 = id3Buffer.readUnsignedByte();
+    if (id1 != 'I' || id2 != 'D' || id3 != '3') {
+      throw new ParserException(String.format(
+          "Unexpected ID3 file identifier, expected \"ID3\", actual \"%c%c%c\".", id1, id2, id3));
+    }
+    id3Buffer.skip(2); // Skip version.
+
+    int flags = id3Buffer.readUnsignedByte();
+    int id3Size = id3Buffer.readSynchSafeInt();
+
+    // Check if extended header presents.
+    if ((flags & 0x2) != 0) {
+      int extendedHeaderSize = id3Buffer.readSynchSafeInt();
+      if (extendedHeaderSize > 4) {
+        id3Buffer.skip(extendedHeaderSize - 4);
+      }
+      id3Size -= extendedHeaderSize;
+    }
+
+    // Check if footer presents.
+    if ((flags & 0x8) != 0) {
+      id3Size -= 10;
+    }
+
+    return id3Size;
+  }
+
+  /**
+   * Maps encoding byte from ID3v2 frame to a Charset.
+   * @param encodingByte The value of encoding byte from ID3v2 frame.
+   * @return Charset name.
+   */
+  private static String getCharsetName(int encodingByte) {
+    switch (encodingByte) {
+      case 0:
+        return "ISO-8859-1";
+      case 1:
+        return "UTF-16";
+      case 2:
+        return "UTF-16BE";
+      case 3:
+        return "UTF-8";
+      default:
+        return "ISO-8859-1";
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
new file mode 100644
index 0000000000..654f549b18
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+import java.io.IOException;
+
+/**
+ * Parses objects of type <T> from binary data.
+ *
+ * @param <T> The type of the metadata.
+ */
+public interface MetadataParser<T> {
+
+  /**
+   * Checks whether the parser supports a given mime type.
+   *
+   * @param mimeType A metadata mime type.
+   * @return Whether the mime type is supported.
+   */
+  public boolean canParse(String mimeType);
+
+  /**
+   * Parses metadata objects of type <T> from the provided binary data.
+   *
+   * @param data The raw binary data from which to parse the metadata.
+   * @param size The size of the input data.
+   * @return @return A parsed metadata object of type <T>.
+   * @throws IOException If a problem occurred parsing the data.
+   */
+  public T parse(byte[] data, int size) throws IOException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
new file mode 100644
index 0000000000..147a222c4f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.util.Assertions;
+
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+
+import java.io.IOException;
+
+/**
+ * A {@link TrackRenderer} for metadata embedded in a media stream.
+ *
+ * @param <T> The type of the metadata.
+ */
+public class MetadataTrackRenderer<T> extends TrackRenderer implements Callback {
+
+  /**
+   * An interface for components that process metadata.
+   *
+   * @param <T> The type of the metadata.
+   */
+  public interface MetadataRenderer<T> {
+
+    /**
+     * Invoked each time there is a metadata associated with current playback time.
+     *
+     * @param metadata The metadata to process.
+     */
+    void onMetadata(T metadata);
+
+  }
+
+  private static final int MSG_INVOKE_RENDERER = 0;
+
+  private final SampleSource source;
+  private final MetadataParser<T> metadataParser;
+  private final MetadataRenderer<T> metadataRenderer;
+  private final Handler metadataHandler;
+  private final MediaFormatHolder formatHolder;
+  private final SampleHolder sampleHolder;
+
+  private int trackIndex;
+  private long currentPositionUs;
+  private boolean inputStreamEnded;
+
+  private long pendingMetadataTimestamp;
+  private T pendingMetadata;
+
+  /**
+   * @param source A source from which samples containing metadata can be read.
+   * @param metadataParser A parser for parsing the metadata.
+   * @param metadataRenderer The metadata renderer to receive the parsed metadata.
+   * @param metadataRendererLooper The looper associated with the thread on which metadataRenderer
+   *     should be invoked. If the renderer makes use of standard Android UI components, then this
+   *     should normally be the looper associated with the applications' main thread, which can be
+   *     obtained using {@link android.app.Activity#getMainLooper()}. Null may be passed if the
+   *     renderer should be invoked directly on the player's internal rendering thread.
+   */
+  public MetadataTrackRenderer(SampleSource source, MetadataParser<T> metadataParser,
+      MetadataRenderer<T> metadataRenderer, Looper metadataRendererLooper) {
+    this.source = Assertions.checkNotNull(source);
+    this.metadataParser = Assertions.checkNotNull(metadataParser);
+    this.metadataRenderer = Assertions.checkNotNull(metadataRenderer);
+    this.metadataHandler = metadataRendererLooper == null ? null
+        : new Handler(metadataRendererLooper, this);
+    formatHolder = new MediaFormatHolder();
+    sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+  }
+
+  @Override
+  protected int doPrepare() throws ExoPlaybackException {
+    try {
+      boolean sourcePrepared = source.prepare();
+      if (!sourcePrepared) {
+        return TrackRenderer.STATE_UNPREPARED;
+      }
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+    for (int i = 0; i < source.getTrackCount(); i++) {
+      if (metadataParser.canParse(source.getTrackInfo(i).mimeType)) {
+        trackIndex = i;
+        return TrackRenderer.STATE_PREPARED;
+      }
+    }
+    return TrackRenderer.STATE_IGNORE;
+  }
+
+  @Override
+  protected void onEnabled(long positionUs, boolean joining) {
+    source.enable(trackIndex, positionUs);
+    seekToInternal(positionUs);
+  }
+
+  @Override
+  protected void seekTo(long positionUs) throws ExoPlaybackException {
+    source.seekToUs(positionUs);
+    seekToInternal(positionUs);
+  }
+
+  private void seekToInternal(long positionUs) {
+    currentPositionUs = positionUs;
+    pendingMetadata = null;
+    inputStreamEnded = false;
+  }
+
+  @Override
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException {
+    currentPositionUs = positionUs;
+    try {
+      source.continueBuffering(positionUs);
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+
+    if (!inputStreamEnded && pendingMetadata == null) {
+      try {
+        int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
+        if (result == SampleSource.SAMPLE_READ) {
+          pendingMetadataTimestamp = sampleHolder.timeUs;
+          pendingMetadata = metadataParser.parse(sampleHolder.data.array(), sampleHolder.size);
+          sampleHolder.data.clear();
+        } else if (result == SampleSource.END_OF_STREAM) {
+          inputStreamEnded = true;
+        }
+      } catch (IOException e) {
+        throw new ExoPlaybackException(e);
+      }
+    }
+
+    if (pendingMetadata != null && pendingMetadataTimestamp <= currentPositionUs) {
+      invokeRenderer(pendingMetadata);
+      pendingMetadata = null;
+    }
+  }
+
+  @Override
+  protected void onDisabled() {
+    pendingMetadata = null;
+    source.disable(trackIndex);
+  }
+
+  @Override
+  protected long getDurationUs() {
+    return source.getTrackInfo(trackIndex).durationUs;
+  }
+
+  @Override
+  protected long getCurrentPositionUs() {
+    return currentPositionUs;
+  }
+
+  @Override
+  protected long getBufferedPositionUs() {
+    return TrackRenderer.END_OF_TRACK_US;
+  }
+
+  @Override
+  protected boolean isEnded() {
+    return inputStreamEnded;
+  }
+
+  @Override
+  protected boolean isReady() {
+    return true;
+  }
+
+  private void invokeRenderer(T metadata) {
+    if (metadataHandler != null) {
+      metadataHandler.obtainMessage(MSG_INVOKE_RENDERER, metadata).sendToTarget();
+    } else {
+      invokeRendererInternal(metadata);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public boolean handleMessage(Message msg) {
+    switch (msg.what) {
+      case MSG_INVOKE_RENDERER:
+        invokeRendererInternal((T) msg.obj);
+        return true;
+    }
+    return false;
+  }
+
+  private void invokeRendererInternal(T metadata) {
+    metadataRenderer.onMetadata(metadata);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
new file mode 100644
index 0000000000..c455bb825d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+/**
+ * A metadata that contains parsed ID3 TXXX (User defined text information) frame data associated
+ * with time indices.
+ */
+public class TxxxMetadata {
+
+  public static final String TYPE = "TXXX";
+
+  public final String description;
+  public final String value;
+
+  public TxxxMetadata(String description, String value) {
+    this.description = description;
+    this.value = value;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/mp4/Atom.java
new file mode 100644
index 0000000000..292c231087
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/mp4/Atom.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.mp4;
+
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public abstract class Atom {
+
+  public static final int TYPE_avc1 = getAtomTypeInteger("avc1");
+  public static final int TYPE_avc3 = getAtomTypeInteger("avc3");
+  public static final int TYPE_esds = getAtomTypeInteger("esds");
+  public static final int TYPE_mdat = getAtomTypeInteger("mdat");
+  public static final int TYPE_mp4a = getAtomTypeInteger("mp4a");
+  public static final int TYPE_ac_3 = getAtomTypeInteger("ac-3");
+  public static final int TYPE_dac3 = getAtomTypeInteger("dac3");
+  public static final int TYPE_ec_3 = getAtomTypeInteger("ec-3");
+  public static final int TYPE_dec3 = getAtomTypeInteger("dec3");
+  public static final int TYPE_tfdt = getAtomTypeInteger("tfdt");
+  public static final int TYPE_tfhd = getAtomTypeInteger("tfhd");
+  public static final int TYPE_trex = getAtomTypeInteger("trex");
+  public static final int TYPE_trun = getAtomTypeInteger("trun");
+  public static final int TYPE_sidx = getAtomTypeInteger("sidx");
+  public static final int TYPE_moov = getAtomTypeInteger("moov");
+  public static final int TYPE_mvhd = getAtomTypeInteger("mvhd");
+  public static final int TYPE_trak = getAtomTypeInteger("trak");
+  public static final int TYPE_mdia = getAtomTypeInteger("mdia");
+  public static final int TYPE_minf = getAtomTypeInteger("minf");
+  public static final int TYPE_stbl = getAtomTypeInteger("stbl");
+  public static final int TYPE_avcC = getAtomTypeInteger("avcC");
+  public static final int TYPE_moof = getAtomTypeInteger("moof");
+  public static final int TYPE_traf = getAtomTypeInteger("traf");
+  public static final int TYPE_mvex = getAtomTypeInteger("mvex");
+  public static final int TYPE_tkhd = getAtomTypeInteger("tkhd");
+  public static final int TYPE_mdhd = getAtomTypeInteger("mdhd");
+  public static final int TYPE_hdlr = getAtomTypeInteger("hdlr");
+  public static final int TYPE_stsd = getAtomTypeInteger("stsd");
+  public static final int TYPE_pssh = getAtomTypeInteger("pssh");
+  public static final int TYPE_sinf = getAtomTypeInteger("sinf");
+  public static final int TYPE_schm = getAtomTypeInteger("schm");
+  public static final int TYPE_schi = getAtomTypeInteger("schi");
+  public static final int TYPE_tenc = getAtomTypeInteger("tenc");
+  public static final int TYPE_encv = getAtomTypeInteger("encv");
+  public static final int TYPE_enca = getAtomTypeInteger("enca");
+  public static final int TYPE_frma = getAtomTypeInteger("frma");
+  public static final int TYPE_saiz = getAtomTypeInteger("saiz");
+  public static final int TYPE_uuid = getAtomTypeInteger("uuid");
+  public static final int TYPE_senc = getAtomTypeInteger("senc");
+  public static final int TYPE_pasp = getAtomTypeInteger("pasp");
+  public static final int TYPE_TTML = getAtomTypeInteger("TTML");
+  public static final int TYPE_vmhd = getAtomTypeInteger("vmhd");
+  public static final int TYPE_smhd = getAtomTypeInteger("smhd");
+  public static final int TYPE_mp4v = getAtomTypeInteger("mp4v");
+  public static final int TYPE_stts = getAtomTypeInteger("stts");
+  public static final int TYPE_stss = getAtomTypeInteger("stss");
+  public static final int TYPE_ctts = getAtomTypeInteger("ctts");
+  public static final int TYPE_stsc = getAtomTypeInteger("stsc");
+  public static final int TYPE_stsz = getAtomTypeInteger("stsz");
+  public static final int TYPE_stco = getAtomTypeInteger("stco");
+  public static final int TYPE_co64 = getAtomTypeInteger("co64");
+
+  public final int type;
+
+  Atom(int type) {
+    this.type = type;
+  }
+
+  @Override
+  public String toString() {
+    return getAtomTypeString(type);
+  }
+
+  /** An MP4 atom that is a leaf. */
+  public static final class LeafAtom extends Atom {
+
+    public final ParsableByteArray data;
+
+    public LeafAtom(int type, ParsableByteArray data) {
+      super(type);
+      this.data = data;
+    }
+
+  }
+
+  /** An MP4 atom that has child atoms. */
+  public static final class ContainerAtom extends Atom {
+
+    public final long endByteOffset;
+    public final List<LeafAtom> leafChildren;
+    public final List<ContainerAtom> containerChildren;
+
+    public ContainerAtom(int type, long endByteOffset) {
+      super(type);
+
+      leafChildren = new ArrayList<LeafAtom>();
+      containerChildren = new ArrayList<ContainerAtom>();
+      this.endByteOffset = endByteOffset;
+    }
+
+    public void add(LeafAtom atom) {
+      leafChildren.add(atom);
+    }
+
+    public void add(ContainerAtom atom) {
+      containerChildren.add(atom);
+    }
+
+    public LeafAtom getLeafAtomOfType(int type) {
+      int childrenSize = leafChildren.size();
+      for (int i = 0; i < childrenSize; i++) {
+        LeafAtom atom = leafChildren.get(i);
+        if (atom.type == type) {
+          return atom;
+        }
+      }
+      return null;
+    }
+
+    public ContainerAtom getContainerAtomOfType(int type) {
+      int childrenSize = containerChildren.size();
+      for (int i = 0; i < childrenSize; i++) {
+        ContainerAtom atom = containerChildren.get(i);
+        if (atom.type == type) {
+          return atom;
+        }
+      }
+      return null;
+    }
+
+    @Override
+    public String toString() {
+      return getAtomTypeString(type)
+          + " leaves: " + Arrays.toString(leafChildren.toArray(new LeafAtom[0]))
+          + " containers: " + Arrays.toString(containerChildren.toArray(new ContainerAtom[0]));
+    }
+
+  }
+
+  private static String getAtomTypeString(int type) {
+    return "" + (char) (type >> 24)
+        + (char) ((type >> 16) & 0xFF)
+        + (char) ((type >> 8) & 0xFF)
+        + (char) (type & 0xFF);
+  }
+
+  private static int getAtomTypeInteger(String typeName) {
+    Assertions.checkArgument(typeName.length() == 4);
+    int result = 0;
+    for (int i = 0; i < 4; i++) {
+      result <<= 8;
+      result |= typeName.charAt(i);
+    }
+    return result;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/CommonMp4AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/mp4/CommonMp4AtomParsers.java
new file mode 100644
index 0000000000..4443e573c9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/mp4/CommonMp4AtomParsers.java
@@ -0,0 +1,671 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.mp4;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.chunk.parser.mp4.TrackEncryptionBox;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import android.util.Pair;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/** Utility methods for parsing MP4 format atom payloads according to ISO 14496-12. */
+public final class CommonMp4AtomParsers {
+
+  /** Channel counts for AC-3 audio, indexed by acmod. (See ETSI TS 102 366.) */
+  private static final int[] AC3_CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
+  /** Nominal bitrates for AC-3 audio in kbps, indexed by bit_rate_code. (See ETSI TS 102 366.) */
+  private static final int[] AC3_BITRATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160,
+      192, 224, 256, 320, 384, 448, 512, 576, 640};
+
+  /**
+   * Parses a trak atom (defined in 14496-12)
+   *
+   * @param trak Atom to parse.
+   * @param mvhd Movie header atom, used to get the timescale.
+   * @return A {@link Track} instance.
+   */
+  public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
+    Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
+    int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
+    Assertions.checkState(trackType == Track.TYPE_AUDIO || trackType == Track.TYPE_VIDEO
+        || trackType == Track.TYPE_TEXT || trackType == Track.TYPE_TIME_CODE);
+
+    Pair<Integer, Long> header = parseTkhd(trak.getLeafAtomOfType(Atom.TYPE_tkhd).data);
+    int id = header.first;
+    long duration = header.second;
+    long movieTimescale = parseMvhd(mvhd.data);
+    long durationUs;
+    if (duration == -1) {
+      durationUs = C.UNKNOWN_TIME_US;
+    } else {
+      durationUs = Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, movieTimescale);
+    }
+    Atom.ContainerAtom stbl = mdia.getContainerAtomOfType(Atom.TYPE_minf)
+        .getContainerAtomOfType(Atom.TYPE_stbl);
+
+    long mediaTimescale = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
+    Pair<MediaFormat, TrackEncryptionBox[]> sampleDescriptions =
+        parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data);
+    return new Track(id, trackType, mediaTimescale, durationUs, sampleDescriptions.first,
+          sampleDescriptions.second);
+  }
+
+  /**
+   * Parses an stbl atom (defined in 14496-12).
+   *
+   * @param track Track to which this sample table corresponds.
+   * @param stblAtom stbl (sample table) atom to parse.
+   * @return Sample table described by the stbl atom.
+   */
+  public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom) {
+    // Array of sample sizes.
+    ParsableByteArray stsz = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
+
+    // Entries are byte offsets of chunks.
+    ParsableByteArray chunkOffsets;
+    Atom.LeafAtom chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stco);
+    if (chunkOffsetsAtom == null) {
+      chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_co64);
+    }
+    chunkOffsets = chunkOffsetsAtom.data;
+    // Entries are (chunk number, number of samples per chunk, sample description index).
+    ParsableByteArray stsc = stblAtom.getLeafAtomOfType(Atom.TYPE_stsc).data;
+    // Entries are (number of samples, timestamp delta between those samples).
+    ParsableByteArray stts = stblAtom.getLeafAtomOfType(Atom.TYPE_stts).data;
+    // Entries are the indices of samples that are synchronization samples.
+    Atom.LeafAtom stssAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stss);
+    ParsableByteArray stss = stssAtom != null ? stssAtom.data : null;
+    // Entries are (number of samples, timestamp offset).
+    Atom.LeafAtom cttsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_ctts);
+    ParsableByteArray ctts = cttsAtom != null ? cttsAtom.data : null;
+
+    // Skip full atom.
+    stsz.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    int fixedSampleSize = stsz.readUnsignedIntToInt();
+    int sampleCount = stsz.readUnsignedIntToInt();
+
+    int[] sizes = new int[sampleCount];
+    long[] timestamps = new long[sampleCount];
+    long[] offsets = new long[sampleCount];
+    int[] flags = new int[sampleCount];
+
+    // Prepare to read chunk offsets.
+    chunkOffsets.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    int chunkCount = chunkOffsets.readUnsignedIntToInt();
+
+    stsc.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    int remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt() - 1;
+    Assertions.checkState(stsc.readInt() == 1, "stsc first chunk must be 1");
+    int samplesPerChunk = stsc.readUnsignedIntToInt();
+    stsc.skip(4); // Skip the sample description index.
+    int nextSamplesPerChunkChangeChunkIndex = -1;
+    if (remainingSamplesPerChunkChanges > 0) {
+      // Store the chunk index when the samples-per-chunk will next change.
+      nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
+    }
+
+    int chunkIndex = 0;
+    int remainingSamplesInChunk = samplesPerChunk;
+
+    // Prepare to read sample timestamps.
+    stts.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    int remainingTimestampDeltaChanges = stts.readUnsignedIntToInt() - 1;
+    int remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
+    int timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
+
+    // Prepare to read sample timestamp offsets, if ctts is present.
+    boolean cttsHasSignedOffsets = false;
+    int remainingSamplesAtTimestampOffset = 0;
+    int remainingTimestampOffsetChanges = 0;
+    int timestampOffset = 0;
+    if (ctts != null) {
+      ctts.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+      cttsHasSignedOffsets = Mp4Util.parseFullAtomVersion(ctts.readInt()) == 1;
+      remainingTimestampOffsetChanges = ctts.readUnsignedIntToInt() - 1;
+      remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
+      timestampOffset = cttsHasSignedOffsets ? ctts.readInt() : ctts.readUnsignedIntToInt();
+    }
+
+    int nextSynchronizationSampleIndex = -1;
+    int remainingSynchronizationSamples = 0;
+    if (stss != null) {
+      stss.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+      remainingSynchronizationSamples = stss.readUnsignedIntToInt();
+      nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
+    }
+
+    // Calculate the chunk offsets
+    long offsetBytes;
+    if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
+      offsetBytes = chunkOffsets.readUnsignedInt();
+    } else {
+      offsetBytes = chunkOffsets.readUnsignedLongToLong();
+    }
+
+    long timestampTimeUnits = 0;
+    for (int i = 0; i < sampleCount; i++) {
+      offsets[i] = offsetBytes;
+      sizes[i] = fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
+      timestamps[i] = timestampTimeUnits + timestampOffset;
+
+      // All samples are synchronization samples if the stss is not present.
+      flags[i] = stss == null ? C.SAMPLE_FLAG_SYNC : 0;
+      if (i == nextSynchronizationSampleIndex) {
+        flags[i] = C.SAMPLE_FLAG_SYNC;
+        remainingSynchronizationSamples--;
+        if (remainingSynchronizationSamples > 0) {
+          nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
+        }
+      }
+
+      // Add on the duration of this sample.
+      timestampTimeUnits += timestampDeltaInTimeUnits;
+      remainingSamplesAtTimestampDelta--;
+      if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
+        remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
+        timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
+        remainingTimestampDeltaChanges--;
+      }
+
+      // Add on the timestamp offset if ctts is present.
+      if (ctts != null) {
+        remainingSamplesAtTimestampOffset--;
+        if (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
+          remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
+          timestampOffset = cttsHasSignedOffsets ? ctts.readInt() : ctts.readUnsignedIntToInt();
+          remainingTimestampOffsetChanges--;
+        }
+      }
+
+      // If we're at the last sample in this chunk, move to the next chunk.
+      remainingSamplesInChunk--;
+      if (remainingSamplesInChunk == 0) {
+        chunkIndex++;
+        if (chunkIndex < chunkCount) {
+          if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
+            offsetBytes = chunkOffsets.readUnsignedInt();
+          } else {
+            offsetBytes = chunkOffsets.readUnsignedLongToLong();
+          }
+        }
+
+        // Change the samples-per-chunk if required.
+        if (chunkIndex == nextSamplesPerChunkChangeChunkIndex) {
+          samplesPerChunk = stsc.readUnsignedIntToInt();
+          stsc.skip(4); // Skip the sample description index.
+          remainingSamplesPerChunkChanges--;
+          if (remainingSamplesPerChunkChanges > 0) {
+            nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
+          }
+        }
+
+        // Expect samplesPerChunk samples in the following chunk, if it's before the end.
+        if (chunkIndex < chunkCount) {
+          remainingSamplesInChunk = samplesPerChunk;
+        }
+      } else {
+        // The next sample follows the current one.
+        offsetBytes += sizes[i];
+      }
+    }
+
+    Util.scaleLargeTimestampsInPlace(timestamps, 1000000, track.timescale);
+
+    // Check all the expected samples have been seen.
+    Assertions.checkArgument(remainingSynchronizationSamples == 0);
+    Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
+    Assertions.checkArgument(remainingSamplesInChunk == 0);
+    Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
+    Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
+    return new Mp4TrackSampleTable(offsets, sizes, timestamps, flags);
+  }
+
+  /**
+   * Parses a mvhd atom (defined in 14496-12), returning the timescale for the movie.
+   *
+   * @param mvhd Contents of the mvhd atom to be parsed.
+   * @return Timescale for the movie.
+   */
+  private static long parseMvhd(ParsableByteArray mvhd) {
+    mvhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+
+    int fullAtom = mvhd.readInt();
+    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+
+    mvhd.skip(version == 0 ? 8 : 16);
+
+    return mvhd.readUnsignedInt();
+  }
+
+  /**
+   * Parses a tkhd atom (defined in 14496-12).
+   *
+   * @return A {@link Pair} consisting of the track id and duration (in the timescale indicated in
+   *     the movie header box). The duration is set to -1 if the duration is unspecified.
+   */
+  private static Pair<Integer, Long> parseTkhd(ParsableByteArray tkhd) {
+    tkhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    int fullAtom = tkhd.readInt();
+    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+
+    tkhd.skip(version == 0 ? 8 : 16);
+
+    int trackId = tkhd.readInt();
+    tkhd.skip(4);
+
+    boolean durationUnknown = true;
+    int durationPosition = tkhd.getPosition();
+    int durationByteCount = version == 0 ? 4 : 8;
+    for (int i = 0; i < durationByteCount; i++) {
+      if (tkhd.data[durationPosition + i] != -1) {
+        durationUnknown = false;
+        break;
+      }
+    }
+    long duration;
+    if (durationUnknown) {
+      tkhd.skip(durationByteCount);
+      duration = -1;
+    } else {
+      duration = version == 0 ? tkhd.readUnsignedInt() : tkhd.readUnsignedLongToLong();
+    }
+
+    return Pair.create(trackId, duration);
+  }
+
+  /**
+   * Parses an hdlr atom.
+   *
+   * @param hdlr The hdlr atom to parse.
+   * @return The track type.
+   */
+  private static int parseHdlr(ParsableByteArray hdlr) {
+    hdlr.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE + 4);
+    return hdlr.readInt();
+  }
+
+  /**
+   * Parses an mdhd atom (defined in 14496-12).
+   *
+   * @param mdhd The mdhd atom to parse.
+   * @return The media timescale, defined as the number of time units that pass in one second.
+   */
+  private static long parseMdhd(ParsableByteArray mdhd) {
+    mdhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    int fullAtom = mdhd.readInt();
+    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+
+    mdhd.skip(version == 0 ? 8 : 16);
+    return mdhd.readUnsignedInt();
+  }
+
+  private static Pair<MediaFormat, TrackEncryptionBox[]> parseStsd(ParsableByteArray stsd) {
+    stsd.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    int numberOfEntries = stsd.readInt();
+    MediaFormat mediaFormat = null;
+    TrackEncryptionBox[] trackEncryptionBoxes = new TrackEncryptionBox[numberOfEntries];
+    for (int i = 0; i < numberOfEntries; i++) {
+      int childStartPosition = stsd.getPosition();
+      int childAtomSize = stsd.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = stsd.readInt();
+      if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
+          || childAtomType == Atom.TYPE_encv) {
+        Pair<MediaFormat, TrackEncryptionBox> avc =
+            parseAvcFromParent(stsd, childStartPosition, childAtomSize);
+        mediaFormat = avc.first;
+        trackEncryptionBoxes[i] = avc.second;
+      } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
+          || childAtomType == Atom.TYPE_ac_3) {
+        Pair<MediaFormat, TrackEncryptionBox> audioSampleEntry =
+            parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize);
+        mediaFormat = audioSampleEntry.first;
+        trackEncryptionBoxes[i] = audioSampleEntry.second;
+      } else if (childAtomType == Atom.TYPE_TTML) {
+        mediaFormat = MediaFormat.createTtmlFormat();
+      } else if (childAtomType == Atom.TYPE_mp4v) {
+        mediaFormat = parseMp4vFromParent(stsd, childStartPosition, childAtomSize);
+      }
+      stsd.setPosition(childStartPosition + childAtomSize);
+    }
+    return Pair.create(mediaFormat, trackEncryptionBoxes);
+  }
+
+  /** Returns the media format for an avc1 box. */
+  private static Pair<MediaFormat, TrackEncryptionBox> parseAvcFromParent(ParsableByteArray parent,
+      int position, int size) {
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+
+    parent.skip(24);
+    int width = parent.readUnsignedShort();
+    int height = parent.readUnsignedShort();
+    float pixelWidthHeightRatio = 1;
+    parent.skip(50);
+
+    List<byte[]> initializationData = null;
+    TrackEncryptionBox trackEncryptionBox = null;
+    int childPosition = parent.getPosition();
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childStartPosition = parent.getPosition();
+      int childAtomSize = parent.readInt();
+      if (childAtomSize == 0 && parent.getPosition() - position == size) {
+        // Handle optional terminating four zero bytes in MOV files.
+        break;
+      }
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_avcC) {
+        initializationData = parseAvcCFromParent(parent, childStartPosition);
+      } else if (childAtomType == Atom.TYPE_sinf) {
+        trackEncryptionBox = parseSinfFromParent(parent, childStartPosition, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_pasp) {
+        pixelWidthHeightRatio = parsePaspFromParent(parent, childStartPosition);
+      }
+      childPosition += childAtomSize;
+    }
+
+    MediaFormat format = MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
+        width, height, pixelWidthHeightRatio, initializationData);
+    return Pair.create(format, trackEncryptionBox);
+  }
+
+  private static List<byte[]> parseAvcCFromParent(ParsableByteArray parent, int position) {
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE + 4);
+    // Start of the AVCDecoderConfigurationRecord (defined in 14496-15)
+    int nalUnitLength = (parent.readUnsignedByte() & 0x3) + 1;
+    if (nalUnitLength != 4) {
+      // readSample currently relies on a nalUnitLength of 4.
+      // TODO: Consider handling the case where it isn't.
+      throw new IllegalStateException();
+    }
+    List<byte[]> initializationData = new ArrayList<byte[]>();
+    // TODO: We should try and parse these using CodecSpecificDataUtil.parseSpsNalUnit, and
+    // expose the AVC profile and level somewhere useful; Most likely in MediaFormat.
+    int numSequenceParameterSets = parent.readUnsignedByte() & 0x1F;
+    for (int j = 0; j < numSequenceParameterSets; j++) {
+      initializationData.add(Mp4Util.parseChildNalUnit(parent));
+    }
+    int numPictureParameterSets = parent.readUnsignedByte();
+    for (int j = 0; j < numPictureParameterSets; j++) {
+      initializationData.add(Mp4Util.parseChildNalUnit(parent));
+    }
+    return initializationData;
+  }
+
+  private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
+      int size) {
+    int childPosition = position + Mp4Util.ATOM_HEADER_SIZE;
+
+    TrackEncryptionBox trackEncryptionBox = null;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_frma) {
+        parent.readInt(); // dataFormat.
+      } else if (childAtomType == Atom.TYPE_schm) {
+        parent.skip(4);
+        parent.readInt(); // schemeType. Expect cenc
+        parent.readInt(); // schemeVersion. Expect 0x00010000
+      } else if (childAtomType == Atom.TYPE_schi) {
+        trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
+      }
+      childPosition += childAtomSize;
+    }
+
+    return trackEncryptionBox;
+  }
+
+  private static float parsePaspFromParent(ParsableByteArray parent, int position) {
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+    int hSpacing = parent.readUnsignedIntToInt();
+    int vSpacing = parent.readUnsignedIntToInt();
+    return (float) hSpacing / vSpacing;
+  }
+
+  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
+      int size) {
+    int childPosition = position + Mp4Util.ATOM_HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_tenc) {
+        parent.skip(4);
+        int firstInt = parent.readInt();
+        boolean defaultIsEncrypted = (firstInt >> 8) == 1;
+        int defaultInitVectorSize = firstInt & 0xFF;
+        byte[] defaultKeyId = new byte[16];
+        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
+        return new TrackEncryptionBox(defaultIsEncrypted, defaultInitVectorSize, defaultKeyId);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
+  /** Returns the media format for an mp4v box. */
+  private static MediaFormat parseMp4vFromParent(ParsableByteArray parent,
+      int position, int size) {
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+
+    parent.skip(24);
+    int width = parent.readUnsignedShort();
+    int height = parent.readUnsignedShort();
+    parent.skip(50);
+
+    List<byte[]> initializationData = new ArrayList<byte[]>(1);
+    int childPosition = parent.getPosition();
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childStartPosition = parent.getPosition();
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_esds) {
+        initializationData.add(parseEsdsFromParent(parent, childStartPosition));
+      }
+      childPosition += childAtomSize;
+    }
+
+    return MediaFormat.createVideoFormat(
+        MimeTypes.VIDEO_MP4V, MediaFormat.NO_VALUE, width, height, initializationData);
+  }
+
+  private static Pair<MediaFormat, TrackEncryptionBox> parseAudioSampleEntry(
+      ParsableByteArray parent, int atomType, int position, int size) {
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+    parent.skip(16);
+    int channelCount = parent.readUnsignedShort();
+    int sampleSize = parent.readUnsignedShort();
+    parent.skip(4);
+    int sampleRate = parent.readUnsignedFixedPoint1616();
+    int bitrate = MediaFormat.NO_VALUE;
+
+    byte[] initializationData = null;
+    TrackEncryptionBox trackEncryptionBox = null;
+    int childPosition = parent.getPosition();
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childStartPosition = parent.getPosition();
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (atomType == Atom.TYPE_mp4a || atomType == Atom.TYPE_enca) {
+        if (childAtomType == Atom.TYPE_esds) {
+          initializationData = parseEsdsFromParent(parent, childStartPosition);
+          // TODO: Do we really need to do this? See [Internal: b/10903778]
+          // Update sampleRate and channelCount from the AudioSpecificConfig initialization data.
+          Pair<Integer, Integer> audioSpecificConfig =
+              CodecSpecificDataUtil.parseAudioSpecificConfig(initializationData);
+          sampleRate = audioSpecificConfig.first;
+          channelCount = audioSpecificConfig.second;
+        } else if (childAtomType == Atom.TYPE_sinf) {
+          trackEncryptionBox = parseSinfFromParent(parent, childStartPosition, childAtomSize);
+        }
+      } else if (atomType == Atom.TYPE_ac_3 && childAtomType == Atom.TYPE_dac3) {
+        // TODO: Choose the right AC-3 track based on the contents of dac3/dec3.
+        Ac3Format ac3Format =
+            parseAc3SpecificBoxFromParent(parent, childStartPosition);
+        if (ac3Format != null) {
+          sampleRate = ac3Format.sampleRate;
+          channelCount = ac3Format.channelCount;
+          bitrate = ac3Format.bitrate;
+        }
+
+        // TODO: Add support for encrypted AC-3.
+        trackEncryptionBox = null;
+      } else if (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
+        sampleRate = parseEc3SpecificBoxFromParent(parent, childStartPosition);
+        trackEncryptionBox = null;
+      }
+      childPosition += childAtomSize;
+    }
+
+    String mimeType;
+    if (atomType == Atom.TYPE_ac_3) {
+      mimeType = MimeTypes.AUDIO_AC3;
+    } else if (atomType == Atom.TYPE_ec_3) {
+      mimeType = MimeTypes.AUDIO_EC3;
+    } else {
+      mimeType = MimeTypes.AUDIO_AAC;
+    }
+
+    MediaFormat format = MediaFormat.createAudioFormat(
+        mimeType, sampleSize, channelCount, sampleRate, bitrate,
+        initializationData == null ? null : Collections.singletonList(initializationData));
+    return Pair.create(format, trackEncryptionBox);
+  }
+
+  /** Returns codec-specific initialization data contained in an esds box. */
+  private static byte[] parseEsdsFromParent(ParsableByteArray parent, int position) {
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE + 4);
+    // Start of the ES_Descriptor (defined in 14496-1)
+    parent.skip(1); // ES_Descriptor tag
+    int varIntByte = parent.readUnsignedByte();
+    while (varIntByte > 127) {
+      varIntByte = parent.readUnsignedByte();
+    }
+    parent.skip(2); // ES_ID
+
+    int flags = parent.readUnsignedByte();
+    if ((flags & 0x80 /* streamDependenceFlag */) != 0) {
+      parent.skip(2);
+    }
+    if ((flags & 0x40 /* URL_Flag */) != 0) {
+      parent.skip(parent.readUnsignedShort());
+    }
+    if ((flags & 0x20 /* OCRstreamFlag */) != 0) {
+      parent.skip(2);
+    }
+
+    // Start of the DecoderConfigDescriptor (defined in 14496-1)
+    parent.skip(1); // DecoderConfigDescriptor tag
+    varIntByte = parent.readUnsignedByte();
+    while (varIntByte > 127) {
+      varIntByte = parent.readUnsignedByte();
+    }
+    parent.skip(13);
+
+    // Start of AudioSpecificConfig (defined in 14496-3)
+    parent.skip(1); // AudioSpecificConfig tag
+    varIntByte = parent.readUnsignedByte();
+    int varInt = varIntByte & 0x7F;
+    while (varIntByte > 127) {
+      varIntByte = parent.readUnsignedByte();
+      varInt = varInt << 8;
+      varInt |= varIntByte & 0x7F;
+    }
+    byte[] initializationData = new byte[varInt];
+    parent.readBytes(initializationData, 0, varInt);
+    return initializationData;
+  }
+
+  private static Ac3Format parseAc3SpecificBoxFromParent(ParsableByteArray parent, int position) {
+    // Start of the dac3 atom (defined in ETSI TS 102 366)
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+
+    // fscod (sample rate code)
+    int fscod = (parent.readUnsignedByte() & 0xC0) >> 6;
+    int sampleRate;
+    switch (fscod) {
+      case 0:
+        sampleRate = 48000;
+        break;
+      case 1:
+        sampleRate = 44100;
+        break;
+      case 2:
+        sampleRate = 32000;
+        break;
+      default:
+        // TODO: The decoder should not use this stream.
+        return null;
+    }
+
+    int nextByte = parent.readUnsignedByte();
+
+    // Map acmod (audio coding mode) onto a channel count.
+    int channelCount = AC3_CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
+
+    // lfeon (low frequency effects on)
+    if ((nextByte & 0x04) != 0) {
+      channelCount++;
+    }
+
+    // Map bit_rate_code onto a bitrate in kbit/s.
+    int bitrate = AC3_BITRATES[((nextByte & 0x03) << 3) + (parent.readUnsignedByte() >> 5)];
+
+    return new Ac3Format(channelCount, sampleRate, bitrate);
+  }
+
+  private static int parseEc3SpecificBoxFromParent(ParsableByteArray parent, int position) {
+    // Start of the dec3 atom (defined in ETSI TS 102 366)
+    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+    // TODO: Implement parsing for enhanced AC-3 with multiple sub-streams.
+    return 0;
+  }
+
+  private CommonMp4AtomParsers() {
+    // Prevent instantiation.
+  }
+
+  /** Represents the format for AC-3 audio. */
+  private static final class Ac3Format {
+
+    public final int channelCount;
+    public final int sampleRate;
+    public final int bitrate;
+
+    public Ac3Format(int channelCount, int sampleRate, int bitrate) {
+      this.channelCount = channelCount;
+      this.sampleRate = sampleRate;
+      this.bitrate = bitrate;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Mp4TrackSampleTable.java b/library/src/main/java/com/google/android/exoplayer/mp4/Mp4TrackSampleTable.java
new file mode 100644
index 0000000000..9e60146140
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/mp4/Mp4TrackSampleTable.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.mp4;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+/** Sample table for a track in an MP4 file. */
+public final class Mp4TrackSampleTable {
+
+  /** Sample offsets in bytes. */
+  public final long[] offsets;
+  /** Sample sizes in bytes. */
+  public final int[] sizes;
+  /** Sample timestamps in microseconds. */
+  public final long[] timestampsUs;
+  /** Sample flags. */
+  public final int[] flags;
+
+  Mp4TrackSampleTable(
+      long[] offsets, int[] sizes, long[] timestampsUs, int[] flags) {
+    Assertions.checkArgument(sizes.length == timestampsUs.length);
+    Assertions.checkArgument(offsets.length == timestampsUs.length);
+    Assertions.checkArgument(flags.length == timestampsUs.length);
+
+    this.offsets = offsets;
+    this.sizes = sizes;
+    this.timestampsUs = timestampsUs;
+    this.flags = flags;
+  }
+
+  /** Returns the number of samples in the table. */
+  public int getSampleCount() {
+    return sizes.length;
+  }
+
+  /**
+   * Returns the sample index of the closest synchronization sample at or before the given
+   * timestamp, if one is available.
+   *
+   * @param timeUs Timestamp adjacent to which to find a synchronization sample.
+   * @return Index of the synchronization sample, or {@link Mp4Util#NO_SAMPLE} if none.
+   */
+  public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
+    int startIndex = Util.binarySearchFloor(timestampsUs, timeUs, true, false);
+    for (int i = startIndex; i >= 0; i--) {
+      if (timestampsUs[i] <= timeUs && (flags[i] & C.SAMPLE_FLAG_SYNC) != 0) {
+        return i;
+      }
+    }
+
+    return Mp4Util.NO_SAMPLE;
+  }
+
+  /**
+   * Returns the sample index of the closest synchronization sample at or after the given timestamp,
+   * if one is available.
+   *
+   * @param timeUs Timestamp adjacent to which to find a synchronization sample.
+   * @return index Index of the synchronization sample, or {@link Mp4Util#NO_SAMPLE} if none.
+   */
+  public int getIndexOfLaterOrEqualSynchronizationSample(long timeUs) {
+    int startIndex = Util.binarySearchCeil(timestampsUs, timeUs, true, false);
+    for (int i = startIndex; i < timestampsUs.length; i++) {
+      if (timestampsUs[i] >= timeUs && (flags[i] & C.SAMPLE_FLAG_SYNC) != 0) {
+        return i;
+      }
+    }
+
+    return Mp4Util.NO_SAMPLE;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Mp4Util.java b/library/src/main/java/com/google/android/exoplayer/mp4/Mp4Util.java
new file mode 100644
index 0000000000..7b744dfea6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/mp4/Mp4Util.java
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.mp4;
+
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Utility methods and constants for parsing fragmented and unfragmented MP4 files.
+ */
+public final class Mp4Util {
+
+  /** Size of an atom header, in bytes. */
+  public static final int ATOM_HEADER_SIZE = 8;
+
+  /** Size of a long atom header, in bytes. */
+  public static final int LONG_ATOM_HEADER_SIZE = 16;
+
+  /** Size of a full atom header, in bytes. */
+  public static final int FULL_ATOM_HEADER_SIZE = 12;
+
+  /** Value for the first 32 bits of atomSize when the atom size is actually a long value. */
+  public static final int LONG_ATOM_SIZE = 1;
+
+  /** Sample index when no sample is available. */
+  public static final int NO_SAMPLE = -1;
+
+  /** Track index when no track is selected. */
+  public static final int NO_TRACK = -1;
+
+  /** Four initial bytes that must prefix H.264/AVC NAL units for decoding. */
+  private static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
+
+  /** Parses the version number out of the additional integer component of a full atom. */
+  public static int parseFullAtomVersion(int fullAtomInt) {
+    return 0x000000FF & (fullAtomInt >> 24);
+  }
+
+  /** Parses the atom flags out of the additional integer component of a full atom. */
+  public static int parseFullAtomFlags(int fullAtomInt) {
+    return 0x00FFFFFF & fullAtomInt;
+  }
+
+  /**
+   * Reads an unsigned integer into an integer. This method is suitable for use when it can be
+   * assumed that the top bit will always be set to zero.
+   *
+   * @throws IllegalArgumentException If the top bit of the input data is set.
+   */
+  public static int readUnsignedIntToInt(ByteBuffer data) {
+    int result = 0xFF & data.get();
+    for (int i = 1; i < 4; i++) {
+      result <<= 8;
+      result |= 0xFF & data.get();
+    }
+    if (result < 0) {
+      throw new IllegalArgumentException("Top bit not zero: " + result);
+    }
+    return result;
+  }
+
+  /**
+   * Replaces length prefixes of NAL units in {@code buffer} with start code prefixes, within the
+   * {@code size} bytes preceding the buffer's position.
+   */
+  public static void replaceLengthPrefixesWithAvcStartCodes(ByteBuffer buffer, int size) {
+    int sampleOffset = buffer.position() - size;
+    int position = sampleOffset;
+    while (position < sampleOffset + size) {
+      buffer.position(position);
+      int length = readUnsignedIntToInt(buffer);
+      buffer.position(position);
+      buffer.put(NAL_START_CODE);
+      position += length + 4;
+    }
+    buffer.position(sampleOffset + size);
+  }
+
+  /** Constructs and returns a NAL unit with a start code followed by the data in {@code atom}. */
+  public static byte[] parseChildNalUnit(ParsableByteArray atom) {
+    int length = atom.readUnsignedShort();
+    int offset = atom.getPosition();
+    atom.skip(length);
+    return CodecSpecificDataUtil.buildNalUnit(atom.data, offset, length);
+  }
+
+  /**
+   * Finds the first NAL unit in {@code data}.
+   * <p>
+   * For a NAL unit to be found, its first four bytes must be contained within the part of the
+   * array being searched.
+   *
+   * @param data The data to search.
+   * @param startOffset The offset (inclusive) in the data to start the search.
+   * @param endOffset The offset (exclusive) in the data to end the search.
+   * @param type The type of the NAL unit to search for, or -1 for any NAL unit.
+   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
+   */
+  public static int findNalUnit(byte[] data, int startOffset, int endOffset, int type) {
+    return findNalUnit(data, startOffset, endOffset, type, null);
+  }
+
+  /**
+   * Like {@link #findNalUnit(byte[], int, int, int)}, but supports finding of NAL units across
+   * array boundaries.
+   * <p>
+   * To use this method, pass the same {@code prefixFlags} parameter to successive calls where the
+   * data passed represents a contiguous stream. The state maintained in this parameter allows the
+   * detection of NAL units where the NAL unit prefix spans array boundaries.
+   * <p>
+   * Note that when using {@code prefixFlags} the return value may be 3, 2 or 1 less than
+   * {@code startOffset}, to indicate a NAL unit starting 3, 2 or 1 bytes before the first byte in
+   * the current array.
+   *
+   * @param data The data to search.
+   * @param startOffset The offset (inclusive) in the data to start the search.
+   * @param endOffset The offset (exclusive) in the data to end the search.
+   * @param type The type of the NAL unit to search for, or -1 for any NAL unit.
+   * @param prefixFlags A boolean array whose first three elements are used to store the state
+   *     required to detect NAL units where the NAL unit prefix spans array boundaries. The array
+   *     must be at least 3 elements long.
+   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
+   */
+  public static int findNalUnit(byte[] data, int startOffset, int endOffset, int type,
+      boolean[] prefixFlags) {
+    int length = endOffset - startOffset;
+
+    Assertions.checkState(length >= 0);
+    if (length == 0) {
+      return endOffset;
+    }
+
+    if (prefixFlags != null) {
+      if (prefixFlags[0] && matchesType(data, startOffset, type)) {
+        clearPrefixFlags(prefixFlags);
+        return startOffset - 3;
+      } else if (length > 1 && prefixFlags[1] && data[startOffset] == 1
+          && matchesType(data, startOffset + 1, type)) {
+        clearPrefixFlags(prefixFlags);
+        return startOffset - 2;
+      } else if (length > 2 && prefixFlags[2] && data[startOffset] == 0
+          && data[startOffset + 1] == 1 && matchesType(data, startOffset + 2, type)) {
+        clearPrefixFlags(prefixFlags);
+        return startOffset - 1;
+      }
+    }
+
+    int limit = endOffset - 2;
+    // We're looking for the NAL unit start code prefix 0x000001, followed by a byte that matches
+    // the specified type. The value of i tracks the index of the third byte in the four bytes
+    // being examined.
+    for (int i = startOffset + 2; i < limit; i += 3) {
+      if ((data[i] & 0xFE) != 0) {
+        // There isn't a NAL prefix here, or at the next two positions. Do nothing and let the
+        // loop advance the index by three.
+      } else if (data[i - 2] == 0 && data[i - 1] == 0 && data[i] == 1
+          && matchesType(data, i + 1, type)) {
+        return i - 2;
+      } else {
+        // There isn't a NAL prefix here, but there might be at the next position. We should
+        // only skip forward by one. The loop will skip forward by three, so subtract two here.
+        i -= 2;
+      }
+    }
+
+    if (prefixFlags != null) {
+      // True if the last three bytes in the data seen so far are {0,0,1}.
+      prefixFlags[0] = length > 2
+          ? (data[endOffset - 3] == 0 && data[endOffset - 2] == 0 && data[endOffset - 1] == 1)
+          : length == 2 ? (prefixFlags[2] && data[endOffset - 2] == 0 && data[endOffset - 1] == 1)
+          : (prefixFlags[1] && data[endOffset - 1] == 1);
+      // True if the last three bytes in the data seen so far are {0,0}.
+      prefixFlags[1] = length > 1 ? data[endOffset - 2] == 0 && data[endOffset - 1] == 0
+          : prefixFlags[2] && data[endOffset - 1] == 0;
+      // True if the last three bytes in the data seen so far are {0}.
+      prefixFlags[2] = data[endOffset - 1] == 0;
+    }
+
+    return endOffset;
+  }
+
+  /**
+   * Like {@link #findNalUnit(byte[], int, int, int)} with {@code type == -1}.
+   *
+   * @param data The data to search.
+   * @param startOffset The offset (inclusive) in the data to start the search.
+   * @param endOffset The offset (exclusive) in the data to end the search.
+   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
+   */
+  public static int findNalUnit(byte[] data, int startOffset, int endOffset) {
+    return findNalUnit(data, startOffset, endOffset, null);
+  }
+
+  /**
+   * Like {@link #findNalUnit(byte[], int, int, int, boolean[])} with {@code type == -1}.
+   *
+   * @param data The data to search.
+   * @param startOffset The offset (inclusive) in the data to start the search.
+   * @param endOffset The offset (exclusive) in the data to end the search.
+   * @param prefixFlags A boolean array of length at least 3.
+   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
+   */
+  public static int findNalUnit(byte[] data, int startOffset, int endOffset,
+      boolean[] prefixFlags) {
+    return findNalUnit(data, startOffset, endOffset, -1, prefixFlags);
+  }
+
+  /**
+   * Gets the type of the NAL unit in {@code data} that starts at {@code offset}.
+   *
+   * @param data The data to search.
+   * @param offset The start offset of a NAL unit. Must lie between {@code -3} (inclusive) and
+   *     {@code data.length - 3} (exclusive).
+   * @return The type of the unit.
+   */
+  public static int getNalUnitType(byte[] data, int offset) {
+    return data[offset + 3] & 0x1F;
+  }
+
+  /**
+   * Clears prefix flags, as used by {@link #findNalUnit(byte[], int, int, int, boolean[])}.
+   *
+   * @param prefixFlags The flags to clear.
+   */
+  private static void clearPrefixFlags(boolean[] prefixFlags) {
+    prefixFlags[0] = false;
+    prefixFlags[1] = false;
+    prefixFlags[2] = false;
+  }
+
+  /**
+   * Returns true if the type at {@code offset} is equal to {@code type}, or if {@code type == -1}.
+   */
+  private static boolean matchesType(byte[] data, int offset, int type) {
+    return type == -1 || (data[offset] & 0x1F) == type;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer/mp4/Track.java
similarity index 75%
rename from library/src/main/java/com/google/android/exoplayer/parser/mp4/Track.java
rename to library/src/main/java/com/google/android/exoplayer/mp4/Track.java
index 710626bc2e..313e3272f6 100644
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer/mp4/Track.java
@@ -13,9 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.parser.mp4;
+package com.google.android.exoplayer.mp4;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.chunk.parser.mp4.TrackEncryptionBox;
 
 /**
  * Encapsulates information describing an MP4 track.
@@ -30,6 +32,10 @@
    * Type of an audio track.
    */
   public static final int TYPE_AUDIO = 0x736F756E;
+  /**
+   * Type of a text track.
+   */
+  public static final int TYPE_TEXT = 0x74657874;
   /**
    * Type of a hint track.
    */
@@ -38,6 +44,10 @@
    * Type of a meta track.
    */
   public static final int TYPE_META = 0x6D657461;
+  /**
+   * Type of a time-code track.
+   */
+  public static final int TYPE_TIME_CODE = 0x746D6364;
 
   /**
    * The track identifier.
@@ -45,7 +55,8 @@
   public final int id;
 
   /**
-   * One of {@link #TYPE_VIDEO}, {@link #TYPE_AUDIO}, {@link #TYPE_HINT} and {@link #TYPE_META}.
+   * One of {@link #TYPE_VIDEO}, {@link #TYPE_AUDIO}, {@link #TYPE_HINT}, {@link #TYPE_META} and
+   * {@link #TYPE_TIME_CODE}.
    */
   public final int type;
 
@@ -54,6 +65,11 @@
    */
   public final long timescale;
 
+  /**
+   * The duration of the track in microseconds, or {@link C#UNKNOWN_TIME_US} if unknown.
+   */
+  public final long durationUs;
+
   /**
    * The format if {@link #type} is {@link #TYPE_VIDEO} or {@link #TYPE_AUDIO}. Null otherwise.
    */
@@ -64,11 +80,12 @@
    */
   public final TrackEncryptionBox[] sampleDescriptionEncryptionBoxes;
 
-  public Track(int id, int type, long timescale, MediaFormat mediaFormat,
+  public Track(int id, int type, long timescale, long durationUs, MediaFormat mediaFormat,
       TrackEncryptionBox[] sampleDescriptionEncryptionBoxes) {
     this.id = id;
     this.type = type;
     this.timescale = timescale;
+    this.durationUs = durationUs;
     this.mediaFormat = mediaFormat;
     this.sampleDescriptionEncryptionBoxes = sampleDescriptionEncryptionBoxes;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/parser/mp4/Atom.java
deleted file mode 100644
index 60c9ae6984..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/Atom.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.parser.mp4;
-
-import java.util.ArrayList;
-
-/* package */ abstract class Atom {
-
-  public static final int TYPE_avc1 = 0x61766331;
-  public static final int TYPE_avc3 = 0x61766333;
-  public static final int TYPE_esds = 0x65736473;
-  public static final int TYPE_mdat = 0x6D646174;
-  public static final int TYPE_mp4a = 0x6D703461;
-  public static final int TYPE_ac_3 = 0x61632D33; // ac-3
-  public static final int TYPE_dac3 = 0x64616333;
-  public static final int TYPE_ec_3 = 0x65632D33; // ec-3
-  public static final int TYPE_dec3 = 0x64656333;
-  public static final int TYPE_tfdt = 0x74666474;
-  public static final int TYPE_tfhd = 0x74666864;
-  public static final int TYPE_trex = 0x74726578;
-  public static final int TYPE_trun = 0x7472756E;
-  public static final int TYPE_sidx = 0x73696478;
-  public static final int TYPE_moov = 0x6D6F6F76;
-  public static final int TYPE_trak = 0x7472616B;
-  public static final int TYPE_mdia = 0x6D646961;
-  public static final int TYPE_minf = 0x6D696E66;
-  public static final int TYPE_stbl = 0x7374626C;
-  public static final int TYPE_avcC = 0x61766343;
-  public static final int TYPE_moof = 0x6D6F6F66;
-  public static final int TYPE_traf = 0x74726166;
-  public static final int TYPE_mvex = 0x6D766578;
-  public static final int TYPE_tkhd = 0x746B6864;
-  public static final int TYPE_mdhd = 0x6D646864;
-  public static final int TYPE_hdlr = 0x68646C72;
-  public static final int TYPE_stsd = 0x73747364;
-  public static final int TYPE_pssh = 0x70737368;
-  public static final int TYPE_sinf = 0x73696E66;
-  public static final int TYPE_schm = 0x7363686D;
-  public static final int TYPE_schi = 0x73636869;
-  public static final int TYPE_tenc = 0x74656E63;
-  public static final int TYPE_encv = 0x656E6376;
-  public static final int TYPE_enca = 0x656E6361;
-  public static final int TYPE_frma = 0x66726D61;
-  public static final int TYPE_saiz = 0x7361697A;
-  public static final int TYPE_uuid = 0x75756964;
-  public static final int TYPE_senc = 0x73656E63;
-  public static final int TYPE_pasp = 0x70617370;
-
-  public final int type;
-
-  Atom(int type) {
-    this.type = type;
-  }
-
-  public final static class LeafAtom extends Atom {
-
-    public final ParsableByteArray data;
-
-    public LeafAtom(int type, ParsableByteArray data) {
-      super(type);
-      this.data = data;
-    }
-
-  }
-
-  public final static class ContainerAtom extends Atom {
-
-    public final ArrayList<Atom> children;
-
-    public ContainerAtom(int type) {
-      super(type);
-      children = new ArrayList<Atom>();
-    }
-
-    public void add(Atom atom) {
-      children.add(atom);
-    }
-
-    public LeafAtom getLeafAtomOfType(int type) {
-      int childrenSize = children.size();
-      for (int i = 0; i < childrenSize; i++) {
-        Atom atom = children.get(i);
-        if (atom.type == type) {
-          return (LeafAtom) atom;
-        }
-      }
-      return null;
-    }
-
-    public ContainerAtom getContainerAtomOfType(int type) {
-      int childrenSize = children.size();
-      for (int i = 0; i < childrenSize; i++) {
-        Atom atom = children.get(i);
-        if (atom.type == type) {
-          return (ContainerAtom) atom;
-        }
-      }
-      return null;
-    }
-
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/parser/mp4/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/parser/mp4/ParsableByteArray.java
deleted file mode 100644
index bf4472d5a7..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/parser/mp4/ParsableByteArray.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.parser.mp4;
-
-import java.nio.ByteBuffer;
-
-/**
- * Wraps a byte array, providing a set of methods for parsing data from it. Numerical values are
- * parsed with the assumption that their constituent bytes are in big endian order.
- */
-/* package */ final class ParsableByteArray {
-
-  public byte[] data;
-
-  private int position;
-
-  public ParsableByteArray(int length) {
-    this.data = new byte[length];
-  }
-
-  public int length() {
-    return data.length;
-  }
-
-  public int getPosition() {
-    return position;
-  }
-
-  public void setPosition(int position) {
-    this.position = position;
-  }
-
-  public void skip(int bytes) {
-    position += bytes;
-  }
-
-  public void rewind(int bytes) {
-    position -= bytes;
-  }
-
-  public void readBytes(byte[] buffer, int offset, int length) {
-    System.arraycopy(data, position, buffer, offset, length);
-    position += length;
-  }
-
-  public void readBytes(ByteBuffer buffer, int length) {
-    buffer.put(data, position, length);
-    position += length;
-  }
-
-  public int readUnsignedByte() {
-    int result = shiftIntoInt(data, position, 1);
-    position += 1;
-    return result;
-  }
-
-  public int readUnsignedShort() {
-    int result = shiftIntoInt(data, position, 2);
-    position += 2;
-    return result;
-  }
-
-  public long readUnsignedInt() {
-    long result = shiftIntoLong(data, position, 4);
-    position += 4;
-    return result;
-  }
-
-  public int readInt() {
-    int result = shiftIntoInt(data, position, 4);
-    position += 4;
-    return result;
-  }
-
-  public long readLong() {
-    long result = shiftIntoLong(data, position, 8);
-    position += 8;
-    return result;
-  }
-
-  /**
-   * @return The integer portion of a fixed point 16.16.
-   */
-  public int readUnsignedFixedPoint1616() {
-    int result = shiftIntoInt(data, position, 2);
-    position += 4;
-    return result;
-  }
-
-  /**
-   * Reads an unsigned integer into an integer. This method is suitable for use when it can be
-   * assumed that the top bit will always be set to zero.
-   *
-   * @throws IllegalArgumentException If the top bit of the input data is set.
-   */
-  public int readUnsignedIntToInt() {
-    int result = shiftIntoInt(data, position, 4);
-    position += 4;
-    if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
-    }
-    return result;
-  }
-
-  /**
-   * Reads an unsigned long into a long. This method is suitable for use when it can be
-   * assumed that the top bit will always be set to zero.
-   *
-   * @throws IllegalArgumentException If the top bit of the input data is set.
-   */
-  public long readUnsignedLongToLong() {
-    long result = shiftIntoLong(data, position, 8);
-    position += 8;
-    if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
-    }
-    return result;
-  }
-
-  private static int shiftIntoInt(byte[] bytes, int offset, int length) {
-    int result = 0xFF & bytes[offset];
-    for (int i = offset + 1; i < offset + length; i++) {
-      result <<= 8;
-      result |= 0xFF & bytes[i];
-    }
-    return result;
-  }
-
-  private static long shiftIntoLong(byte[] bytes, int offset, int length) {
-    long result = 0xFF & bytes[offset];
-    for (int i = offset + 1; i < offset + length; i++) {
-      result <<= 8;
-      result |= 0xFF & bytes[i];
-    }
-    return result;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
index 936fdf824d..6e04658ef9 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
@@ -21,16 +21,16 @@
 import com.google.android.exoplayer.chunk.Chunk;
 import com.google.android.exoplayer.chunk.ChunkOperationHolder;
 import com.google.android.exoplayer.chunk.ChunkSource;
+import com.google.android.exoplayer.chunk.ContainerMediaChunk;
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.Format.DecreasingBandwidthComparator;
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.Evaluation;
 import com.google.android.exoplayer.chunk.MediaChunk;
-import com.google.android.exoplayer.chunk.Mp4MediaChunk;
-import com.google.android.exoplayer.parser.Extractor;
-import com.google.android.exoplayer.parser.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer.parser.mp4.Track;
-import com.google.android.exoplayer.parser.mp4.TrackEncryptionBox;
+import com.google.android.exoplayer.chunk.parser.Extractor;
+import com.google.android.exoplayer.chunk.parser.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer.chunk.parser.mp4.TrackEncryptionBox;
+import com.google.android.exoplayer.mp4.Track;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.ProtectionElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
@@ -167,8 +167,8 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
           : Track.TYPE_AUDIO;
       FragmentedMp4Extractor extractor = new FragmentedMp4Extractor(
           FragmentedMp4Extractor.WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME);
-      extractor.setTrack(new Track(trackIndex, trackType, streamElement.timescale, mediaFormat,
-          trackEncryptionBoxes));
+      extractor.setTrack(new Track(trackIndex, trackType, streamElement.timescale,
+          initialManifest.durationUs, mediaFormat, trackEncryptionBoxes));
       extractors.put(trackIndex, extractor);
     }
     this.maxHeight = maxHeight;
@@ -343,8 +343,8 @@ private static MediaFormat getMediaFormat(StreamElement streamElement, int track
     TrackElement trackElement = streamElement.tracks[trackIndex];
     String mimeType = trackElement.mimeType;
     if (streamElement.type == StreamElement.TYPE_VIDEO) {
-      MediaFormat format = MediaFormat.createVideoFormat(mimeType, -1, trackElement.maxWidth,
-          trackElement.maxHeight, Arrays.asList(trackElement.csd));
+      MediaFormat format = MediaFormat.createVideoFormat(mimeType, MediaFormat.NO_VALUE,
+          trackElement.maxWidth, trackElement.maxHeight, Arrays.asList(trackElement.csd));
       format.setMaxVideoDimensions(streamElement.maxWidth, streamElement.maxHeight);
       return format;
     } else if (streamElement.type == StreamElement.TYPE_AUDIO) {
@@ -355,11 +355,12 @@ private static MediaFormat getMediaFormat(StreamElement streamElement, int track
         csd = Collections.singletonList(CodecSpecificDataUtil.buildAudioSpecificConfig(
             trackElement.sampleRate, trackElement.numChannels));
       }
-      MediaFormat format = MediaFormat.createAudioFormat(mimeType, -1, trackElement.numChannels,
-          trackElement.sampleRate, csd);
+      MediaFormat format = MediaFormat.createAudioFormat(mimeType, MediaFormat.NO_VALUE,
+          trackElement.numChannels, trackElement.sampleRate, csd);
       return format;
+    } else if (streamElement.type == StreamElement.TYPE_TEXT) {
+      return MediaFormat.createFormatForMimeType(streamElement.tracks[trackIndex].mimeType);
     }
-    // TODO: Do subtitles need a format? MediaFormat supports KEY_LANGUAGE.
     return null;
   }
 
@@ -372,7 +373,7 @@ private static MediaChunk newMediaChunk(Format formatInfo, Uri uri, String cache
     DataSpec dataSpec = new DataSpec(uri, offset, -1, cacheKey);
     // In SmoothStreaming each chunk contains sample timestamps relative to the start of the chunk.
     // To convert them the absolute timestamps, we need to set sampleOffsetUs to -chunkStartTimeUs.
-    return new Mp4MediaChunk(dataSource, dataSpec, formatInfo, trigger, chunkStartTimeUs,
+    return new ContainerMediaChunk(dataSource, dataSpec, formatInfo, trigger, chunkStartTimeUs,
         nextStartTimeUs, nextChunkIndex, extractor, psshInfo, false, -chunkStartTimeUs);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
index 7a6a32e44a..d7e6ee1358 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
@@ -273,7 +273,7 @@ public Uri buildRequestUri(int track, int chunkIndex) {
       Assertions.checkState(chunkIndex < chunkStartTimes.size());
       String chunkUrl = chunkTemplate
           .replace(URL_PLACEHOLDER_BITRATE, Integer.toString(tracks[track].bitrate))
-          .replace(URL_PLACEHOLDER_START_TIME, Long.toString(chunkStartTimes.get(chunkIndex)));
+          .replace(URL_PLACEHOLDER_START_TIME, chunkStartTimes.get(chunkIndex).toString());
       return Util.getMergedUri(baseUri, chunkUrl);
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/source/DefaultSampleSource.java b/library/src/main/java/com/google/android/exoplayer/source/DefaultSampleSource.java
new file mode 100644
index 0000000000..918ff1c57a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/source/DefaultSampleSource.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.source;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackInfo;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.io.IOException;
+
+/** {@link SampleSource} that extracts sample data using a {@link SampleExtractor} */
+public final class DefaultSampleSource implements SampleSource {
+
+  private static final int TRACK_STATE_DISABLED = 0;
+  private static final int TRACK_STATE_ENABLED = 1;
+  private static final int TRACK_STATE_FORMAT_SENT = 2;
+
+  private final SampleExtractor sampleExtractor;
+
+  private TrackInfo[] trackInfos;
+  private boolean prepared;
+  private int remainingReleaseCount;
+  private int[] trackStates;
+  private boolean[] pendingDiscontinuities;
+
+  private long seekPositionUs;
+
+  /**
+   * Creates a new sample source that extracts samples using {@code sampleExtractor}. Specify the
+   * {@code downstreamRendererCount} to ensure that the sample source is released only when all
+   * downstream renderers have been released.
+   *
+   * @param sampleExtractor Sample extractor for accessing media samples.
+   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   */
+  public DefaultSampleSource(SampleExtractor sampleExtractor, int downstreamRendererCount) {
+    this.sampleExtractor = Assertions.checkNotNull(sampleExtractor);
+    this.remainingReleaseCount = downstreamRendererCount;
+  }
+
+  @Override
+  public boolean prepare() throws IOException {
+    if (prepared) {
+      return true;
+    }
+
+    if (sampleExtractor.prepare()) {
+      prepared = true;
+      trackInfos = sampleExtractor.getTrackInfos();
+      trackStates = new int[trackInfos.length];
+      pendingDiscontinuities = new boolean[trackInfos.length];
+    }
+
+    return prepared;
+  }
+
+  @Override
+  public int getTrackCount() {
+    Assertions.checkState(prepared);
+    return trackInfos.length;
+  }
+
+  @Override
+  public TrackInfo getTrackInfo(int track) {
+    Assertions.checkState(prepared);
+    return trackInfos[track];
+  }
+
+  @Override
+  public void enable(int track, long positionUs) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackStates[track] == TRACK_STATE_DISABLED);
+    trackStates[track] = TRACK_STATE_ENABLED;
+    sampleExtractor.selectTrack(track);
+    seekToUs(positionUs);
+  }
+
+  @Override
+  public void disable(int track) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
+    sampleExtractor.deselectTrack(track);
+    pendingDiscontinuities[track] = false;
+    trackStates[track] = TRACK_STATE_DISABLED;
+  }
+
+  @Override
+  public boolean continueBuffering(long positionUs) throws IOException {
+    // Do nothing.
+    return true;
+  }
+
+  @Override
+  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
+    if (pendingDiscontinuities[track]) {
+      pendingDiscontinuities[track] = false;
+      return DISCONTINUITY_READ;
+    }
+    if (onlyReadDiscontinuity) {
+      return NOTHING_READ;
+    }
+    if (trackStates[track] != TRACK_STATE_FORMAT_SENT) {
+      sampleExtractor.getTrackMediaFormat(track, formatHolder);
+      trackStates[track] = TRACK_STATE_FORMAT_SENT;
+      return FORMAT_READ;
+    }
+
+    seekPositionUs = C.UNKNOWN_TIME_US;
+    return sampleExtractor.readSample(track, sampleHolder);
+  }
+
+  @Override
+  public void seekToUs(long positionUs) {
+    Assertions.checkState(prepared);
+    if (seekPositionUs != positionUs) {
+      // Avoid duplicate calls to the underlying extractor's seek method in the case that there
+      // have been no interleaving calls to readSample.
+      seekPositionUs = positionUs;
+      sampleExtractor.seekTo(positionUs);
+      for (int i = 0; i < trackStates.length; ++i) {
+        if (trackStates[i] != TRACK_STATE_DISABLED) {
+          pendingDiscontinuities[i] = true;
+        }
+      }
+    }
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    Assertions.checkState(prepared);
+    return sampleExtractor.getBufferedPositionUs();
+  }
+
+  @Override
+  public void release() {
+    Assertions.checkState(remainingReleaseCount > 0);
+    if (--remainingReleaseCount == 0) {
+      sampleExtractor.release();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/source/FrameworkSampleExtractor.java b/library/src/main/java/com/google/android/exoplayer/source/FrameworkSampleExtractor.java
new file mode 100644
index 0000000000..e4ab4805c6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/source/FrameworkSampleExtractor.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.source;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackInfo;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.media.MediaExtractor;
+import android.net.Uri;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.util.Map;
+import java.util.UUID;
+
+/** {@link SampleExtractor} that extracts samples from a stream using {@link MediaExtractor}. */
+// TODO: This implementation needs to be fixed so that its methods are non-blocking (either
+// through use of a background thread, or through changes to the framework's MediaExtractor API).
+@TargetApi(16)
+public final class FrameworkSampleExtractor implements SampleExtractor {
+
+  // Parameters for a Uri data source.
+  private final Context context;
+  private final Uri uri;
+  private final Map<String, String> headers;
+
+  // Parameters for a FileDescriptor data source.
+  private final FileDescriptor fileDescriptor;
+  private final long fileDescriptorOffset;
+  private final long fileDescriptorLength;
+
+  private final MediaExtractor mediaExtractor;
+
+  private TrackInfo[] trackInfos;
+
+  /**
+   * Instantiates a new sample extractor reading from the specified {@code uri}.
+   *
+   * @param context Context for resolving {@code uri}.
+   * @param uri The content URI from which to extract data.
+   * @param headers Headers to send with requests for data.
+   */
+  public FrameworkSampleExtractor(Context context, Uri uri, Map<String, String> headers) {
+    Assertions.checkState(Util.SDK_INT >= 16);
+
+    this.context = Assertions.checkNotNull(context);
+    this.uri = Assertions.checkNotNull(uri);
+    this.headers = headers;
+
+    fileDescriptor = null;
+    fileDescriptorOffset = 0;
+    fileDescriptorLength = 0;
+
+    mediaExtractor = new MediaExtractor();
+  }
+
+  /**
+   * Instantiates a new sample extractor reading from the specified seekable {@code fileDescriptor}.
+   * The caller is responsible for releasing the file descriptor.
+   *
+   * @param fileDescriptor File descriptor from which to read.
+   * @param offset The offset in bytes into the file where the data to be extracted starts.
+   * @param length The length in bytes of the data to be extracted.
+   */
+  public FrameworkSampleExtractor(FileDescriptor fileDescriptor, long offset, long length) {
+    Assertions.checkState(Util.SDK_INT >= 16);
+
+    context = null;
+    uri = null;
+    headers = null;
+
+    this.fileDescriptor = Assertions.checkNotNull(fileDescriptor);
+    fileDescriptorOffset = offset;
+    fileDescriptorLength = length;
+
+    mediaExtractor = new MediaExtractor();
+  }
+
+  @Override
+  public boolean prepare() throws IOException {
+    if (context != null) {
+      mediaExtractor.setDataSource(context, uri, headers);
+    } else {
+      mediaExtractor.setDataSource(fileDescriptor, fileDescriptorOffset, fileDescriptorLength);
+    }
+
+    int trackCount = mediaExtractor.getTrackCount();
+    trackInfos = new TrackInfo[trackCount];
+    for (int i = 0; i < trackCount; i++) {
+      android.media.MediaFormat format = mediaExtractor.getTrackFormat(i);
+      long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
+          ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
+      String mime = format.getString(android.media.MediaFormat.KEY_MIME);
+      trackInfos[i] = new TrackInfo(mime, durationUs);
+    }
+
+    return true;
+  }
+
+  @Override
+  public TrackInfo[] getTrackInfos() {
+    return trackInfos;
+  }
+
+  @Override
+  public void selectTrack(int index) {
+    mediaExtractor.selectTrack(index);
+  }
+
+  @Override
+  public void deselectTrack(int index) {
+    mediaExtractor.unselectTrack(index);
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    long bufferedDurationUs = mediaExtractor.getCachedDuration();
+    if (bufferedDurationUs == -1) {
+      return TrackRenderer.UNKNOWN_TIME_US;
+    } else {
+      long sampleTime = mediaExtractor.getSampleTime();
+      return sampleTime == -1 ? TrackRenderer.END_OF_TRACK_US : sampleTime + bufferedDurationUs;
+    }
+  }
+
+  @Override
+  public void seekTo(long positionUs) {
+    mediaExtractor.seekTo(positionUs, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+  }
+
+  @Override
+  public void getTrackMediaFormat(int track, MediaFormatHolder mediaFormatHolder) {
+    mediaFormatHolder.format =
+        MediaFormat.createFromFrameworkMediaFormatV16(mediaExtractor.getTrackFormat(track));
+    mediaFormatHolder.drmInitData = Util.SDK_INT >= 18 ? getPsshInfoV18() : null;
+  }
+
+  @Override
+  public int readSample(int track, SampleHolder sampleHolder) {
+    int sampleTrack = mediaExtractor.getSampleTrackIndex();
+    if (sampleTrack != track) {
+      return sampleTrack < 0 ? SampleSource.END_OF_STREAM : SampleSource.NOTHING_READ;
+    }
+
+    if (sampleHolder.data != null) {
+      int offset = sampleHolder.data.position();
+      sampleHolder.size = mediaExtractor.readSampleData(sampleHolder.data, offset);
+      sampleHolder.data.position(offset + sampleHolder.size);
+    } else {
+      sampleHolder.size = 0;
+    }
+    sampleHolder.timeUs = mediaExtractor.getSampleTime();
+    sampleHolder.flags = mediaExtractor.getSampleFlags();
+    if ((sampleHolder.flags & MediaExtractor.SAMPLE_FLAG_ENCRYPTED) != 0) {
+      sampleHolder.cryptoInfo.setFromExtractorV16(mediaExtractor);
+    }
+
+    mediaExtractor.advance();
+
+    return SampleSource.SAMPLE_READ;
+  }
+
+  @Override
+  public void release() {
+    mediaExtractor.release();
+  }
+
+  @TargetApi(18)
+  private Map<UUID, byte[]> getPsshInfoV18() {
+    Map<UUID, byte[]> psshInfo = mediaExtractor.getPsshInfo();
+    return (psshInfo == null || psshInfo.isEmpty()) ? null : psshInfo;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/source/SampleExtractor.java b/library/src/main/java/com/google/android/exoplayer/source/SampleExtractor.java
new file mode 100644
index 0000000000..383aa80ce2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/source/SampleExtractor.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.source;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackInfo;
+import com.google.android.exoplayer.TrackRenderer;
+
+import java.io.IOException;
+
+/**
+ * Extractor for reading track metadata and samples stored in tracks.
+ *
+ * <p>Call {@link #prepare} until it returns {@code true}, then access track metadata via
+ * {@link #getTrackInfos} and {@link #getTrackMediaFormat}.
+ *
+ * <p>Pass indices of tracks to read from to {@link #selectTrack}. A track can later be deselected
+ * by calling {@link #deselectTrack}. It is safe to select/deselect tracks after reading sample
+ * data or seeking. Initially, all tracks are deselected.
+ *
+ * <p>Call {@link #release()} when the extractor is no longer needed to free resources.
+ */
+public interface SampleExtractor {
+
+  /**
+   * Prepares the extractor for reading track metadata and samples.
+   *
+   * @return Whether the source is ready; if {@code false}, {@link #prepare()} must be called again.
+   * @throws IOException Thrown if the source can't be read.
+   */
+  boolean prepare() throws IOException;
+
+  /** Returns track information about all tracks that can be selected. */
+  TrackInfo[] getTrackInfos();
+
+  /** Selects the track at {@code index} for reading sample data. */
+  void selectTrack(int index);
+
+  /** Deselects the track at {@code index}, so no more samples will be read from that track. */
+  void deselectTrack(int index);
+
+  /**
+   * Returns an estimate of the position up to which data is buffered.
+   *
+   * <p>This method should not be called until after the extractor has been successfully prepared.
+   *
+   * @return An estimate of the absolute position in microseconds up to which data is buffered,
+   *     or {@link TrackRenderer#END_OF_TRACK_US} if data is buffered to the end of the stream, or
+   *     {@link TrackRenderer#UNKNOWN_TIME_US} if no estimate is available.
+   */
+  long getBufferedPositionUs();
+
+  /**
+   * Seeks to the specified time in microseconds.
+   *
+   * <p>This method should not be called until after the extractor has been successfully prepared.
+   *
+   * @param positionUs The seek position in microseconds.
+   */
+  void seekTo(long positionUs);
+
+  /** Stores the {@link MediaFormat} of {@code track}. */
+  void getTrackMediaFormat(int track, MediaFormatHolder mediaFormatHolder);
+
+  /**
+   * Reads the next sample in the track at index {@code track} into {@code sampleHolder}, returning
+   * {@link SampleSource#SAMPLE_READ} if it is available.
+   *
+   * <p>Advances to the next sample if a sample was read.
+   *
+   * @param track The index of the track from which to read a sample.
+   * @param sampleHolder The holder for read sample data, if {@link SampleSource#SAMPLE_READ} is
+   *     returned.
+   * @return {@link SampleSource#SAMPLE_READ} if a sample was read into {@code sampleHolder}, or
+   *     {@link SampleSource#END_OF_STREAM} if the last samples in all tracks have been read, or
+   *     {@link SampleSource#NOTHING_READ} if the sample cannot be read immediately as it is not
+   *     loaded.
+   * @throws IOException Thrown if the source can't be read.
+   */
+  int readSample(int track, SampleHolder sampleHolder) throws IOException;
+
+  /** Releases resources associated with this extractor. */
+  void release();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
index 38958aa0b3..69872bf385 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
@@ -135,7 +135,6 @@ public boolean handleMessage(Message msg) {
       if (sampleHolder != holder) {
         // A flush has occurred since this holder was posted. Do nothing.
       } else {
-        holder.data.position(0);
         this.result = result;
         this.error = error;
         this.parsing = false;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java
index 7b2ecf5494..7b977aa7cc 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java
@@ -97,7 +97,7 @@ public SubtitleView(Context context, AttributeSet attrs, int defStyleAttr) {
 
     Resources resources = getContext().getResources();
     DisplayMetrics displayMetrics = resources.getDisplayMetrics();
-    int twoDpInPx = Math.round((2 * displayMetrics.densityDpi) / DisplayMetrics.DENSITY_DEFAULT);
+    int twoDpInPx = Math.round((2f * displayMetrics.densityDpi) / DisplayMetrics.DENSITY_DEFAULT);
     cornerRadius = twoDpInPx;
     outlineWidth = twoDpInPx;
     shadowRadius = twoDpInPx;
@@ -123,7 +123,7 @@ public SubtitleView(Context context) {
   @Override
   public void setBackgroundColor(int color) {
     backgroundColor = color;
-    invalidate();
+    forceUpdate(false);
   }
 
   /**
@@ -134,8 +134,7 @@ public void setBackgroundColor(int color) {
   public void setText(CharSequence text) {
     textBuilder.setLength(0);
     textBuilder.append(text);
-    hasMeasurements = false;
-    requestLayout();
+    forceUpdate(true);
   }
 
   /**
@@ -147,9 +146,7 @@ public void setTextSize(float size) {
     if (textPaint.getTextSize() != size) {
       textPaint.setTextSize(size);
       innerPaddingX = (int) (size * INNER_PADDING_RATIO + 0.5f);
-      hasMeasurements = false;
-      requestLayout();
-      invalidate();
+      forceUpdate(true);
     }
   }
 
@@ -165,17 +162,22 @@ public void setStyle(CaptionStyleCompat style) {
     edgeColor = style.edgeColor;
     setTypeface(style.typeface);
     super.setBackgroundColor(style.windowColor);
-    hasMeasurements = false;
-    requestLayout();
+    forceUpdate(true);
   }
 
   private void setTypeface(Typeface typeface) {
     if (textPaint.getTypeface() != typeface) {
       textPaint.setTypeface(typeface);
+      forceUpdate(true);
+    }
+  }
+
+  private void forceUpdate(boolean needsLayout) {
+    if (needsLayout) {
       hasMeasurements = false;
       requestLayout();
-      invalidate();
     }
+    invalidate();
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java
new file mode 100644
index 0000000000..8b0b1ae6dc
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text;
+
+/**
+ * An interface for components that render text.
+ */
+public interface TextRenderer {
+
+  /**
+   * Invoked each time there is a change in the text to be rendered.
+   *
+   * @param text The text to render, or null if no text is to be rendered.
+   */
+  void onText(String text);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
index 4fd581bf56..e2452102d1 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
@@ -38,28 +38,15 @@
 @TargetApi(16)
 public class TextTrackRenderer extends TrackRenderer implements Callback {
 
-  /**
-   * An interface for components that render text.
-   */
-  public interface TextRenderer {
-
-    /**
-     * Invoked each time there is a change in the text to be rendered.
-     *
-     * @param text The text to render, or null if no text is to be rendered.
-     */
-    void onText(String text);
-
-  }
-
   private static final int MSG_UPDATE_OVERLAY = 0;
 
   private final Handler textRendererHandler;
   private final TextRenderer textRenderer;
   private final SampleSource source;
   private final MediaFormatHolder formatHolder;
-  private final SubtitleParser subtitleParser;
+  private final SubtitleParser[] subtitleParsers;
 
+  private int parserIndex;
   private int trackIndex;
 
   private long currentPositionUs;
@@ -73,21 +60,22 @@
 
   /**
    * @param source A source from which samples containing subtitle data can be read.
-   * @param subtitleParser A subtitle parser that will parse Subtitle objects from the source.
    * @param textRenderer The text renderer.
    * @param textRendererLooper The looper associated with the thread on which textRenderer should be
    *     invoked. If the renderer makes use of standard Android UI components, then this should
    *     normally be the looper associated with the applications' main thread, which can be
    *     obtained using {@link android.app.Activity#getMainLooper()}. Null may be passed if the
    *     renderer should be invoked directly on the player's internal rendering thread.
+   * @param subtitleParsers An array of available subtitle parsers. Where multiple parsers are able
+   *     to render a subtitle, the one with the lowest index will be preferred.
    */
-  public TextTrackRenderer(SampleSource source, SubtitleParser subtitleParser,
-      TextRenderer textRenderer, Looper textRendererLooper) {
+  public TextTrackRenderer(SampleSource source, TextRenderer textRenderer,
+      Looper textRendererLooper, SubtitleParser... subtitleParsers) {
     this.source = Assertions.checkNotNull(source);
-    this.subtitleParser = Assertions.checkNotNull(subtitleParser);
     this.textRenderer = Assertions.checkNotNull(textRenderer);
-    this.textRendererHandler = textRendererLooper == null ? null : new Handler(textRendererLooper,
-        this);
+    this.textRendererHandler = textRendererLooper == null ? null
+        : new Handler(textRendererLooper, this);
+    this.subtitleParsers = Assertions.checkNotNull(subtitleParsers);
     formatHolder = new MediaFormatHolder();
   }
 
@@ -101,10 +89,13 @@ protected int doPrepare() throws ExoPlaybackException {
     } catch (IOException e) {
       throw new ExoPlaybackException(e);
     }
-    for (int i = 0; i < source.getTrackCount(); i++) {
-      if (subtitleParser.canParse(source.getTrackInfo(i).mimeType)) {
-        trackIndex = i;
-        return TrackRenderer.STATE_PREPARED;
+    for (int i = 0; i < subtitleParsers.length; i++) {
+      for (int j = 0; j < source.getTrackCount(); j++) {
+        if (subtitleParsers[i].canParse(source.getTrackInfo(j).mimeType)) {
+          parserIndex = i;
+          trackIndex = j;
+          return TrackRenderer.STATE_PREPARED;
+        }
       }
     }
     return TrackRenderer.STATE_IGNORE;
@@ -115,7 +106,7 @@ protected void onEnabled(long positionUs, boolean joining) {
     source.enable(trackIndex, positionUs);
     parserThread = new HandlerThread("textParser");
     parserThread.start();
-    parserHelper = new SubtitleParserHelper(parserThread.getLooper(), subtitleParser);
+    parserHelper = new SubtitleParserHelper(parserThread.getLooper(), subtitleParsers[parserIndex]);
     seekToInternal(positionUs);
   }
 
@@ -186,9 +177,11 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     if (!inputStreamEnded && subtitle == null) {
       try {
         SampleHolder sampleHolder = parserHelper.getSampleHolder();
+        sampleHolder.clearData();
         int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
-        if (result == SampleSource.SAMPLE_READ) {
+        if (result == SampleSource.SAMPLE_READ && !sampleHolder.decodeOnly) {
           parserHelper.startParseOperation();
+          textRendererNeedsUpdate = false;
         } else if (result == SampleSource.END_OF_STREAM) {
           inputStreamEnded = true;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaption.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaption.java
new file mode 100644
index 0000000000..1961cc7a76
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaption.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.eia608;
+
+/**
+ * A Closed Caption that contains textual data associated with time indices.
+ */
+/* package */ abstract class ClosedCaption {
+
+  /**
+   * Identifies closed captions with control characters.
+   */
+  public static final int TYPE_CTRL = 0;
+  /**
+   * Identifies closed captions with textual information.
+   */
+  public static final int TYPE_TEXT = 1;
+
+  /**
+   * The type of the closed caption data.
+   */
+  public final int type;
+
+  protected ClosedCaption(int type) {
+    this.type = type;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
new file mode 100644
index 0000000000..c784f50cd9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.eia608;
+
+/* package */ final class ClosedCaptionCtrl extends ClosedCaption {
+
+  /**
+   * The receipt of the {@link #RESUME_CAPTION_LOADING} command initiates pop-on style captioning.
+   * Subsequent data should be loaded into a non-displayed memory and held there until the
+   * {@link #END_OF_CAPTION} command is received, at which point the non-displayed memory becomes
+   * the displayed memory (and vice versa).
+   */
+  public static final byte RESUME_CAPTION_LOADING = 0x20;
+  /**
+   * The receipt of the {@link #ROLL_UP_CAPTIONS_2_ROWS} command initiates roll-up style
+   * captioning, with the maximum of 2 rows displayed simultaneously.
+   */
+  public static final byte ROLL_UP_CAPTIONS_2_ROWS = 0x25;
+  /**
+   * The receipt of the {@link #ROLL_UP_CAPTIONS_3_ROWS} command initiates roll-up style
+   * captioning, with the maximum of 3 rows displayed simultaneously.
+   */
+  public static final byte ROLL_UP_CAPTIONS_3_ROWS = 0x26;
+  /**
+   * The receipt of the {@link #ROLL_UP_CAPTIONS_4_ROWS} command initiates roll-up style
+   * captioning, with the maximum of 4 rows displayed simultaneously.
+   */
+  public static final byte ROLL_UP_CAPTIONS_4_ROWS = 0x27;
+  /**
+   * The receipt of the {@link #RESUME_DIRECT_CAPTIONING} command initiates paint-on style
+   * captioning. Subsequent data should be addressed immediately to displayed memory without need
+   * for the {@link #RESUME_CAPTION_LOADING} command.
+   */
+  public static final byte RESUME_DIRECT_CAPTIONING = 0x29;
+  /**
+   * The receipt of the {@link #END_OF_CAPTION} command indicates the end of pop-on style caption,
+   * at this point already loaded in non-displayed memory caption should become the displayed
+   * memory (and vice versa). If no {@link #RESUME_CAPTION_LOADING} command has been received,
+   * {@link #END_OF_CAPTION} command forces the receiver into pop-on style.
+   */
+  public static final byte END_OF_CAPTION = 0x2F;
+
+  public static final byte ERASE_DISPLAYED_MEMORY = 0x2C;
+  public static final byte CARRIAGE_RETURN = 0x2D;
+  public static final byte ERASE_NON_DISPLAYED_MEMORY = 0x2E;
+
+
+  public static final byte MID_ROW_CHAN_1 = 0x11;
+  public static final byte MID_ROW_CHAN_2 = 0x19;
+
+  public static final byte MISC_CHAN_1 = 0x14;
+  public static final byte MISC_CHAN_2 = 0x1C;
+
+  public static final byte TAB_OFFSET_CHAN_1 = 0x17;
+  public static final byte TAB_OFFSET_CHAN_2 = 0x1F;
+
+  public final byte cc1;
+  public final byte cc2;
+
+  protected ClosedCaptionCtrl(byte cc1, byte cc2) {
+    super(ClosedCaption.TYPE_CTRL);
+    this.cc1 = cc1;
+    this.cc2 = cc2;
+  }
+
+  public boolean isMidRowCode() {
+    return (cc1 == MID_ROW_CHAN_1 || cc1 == MID_ROW_CHAN_2) && (cc2 >= 0x20 && cc2 <= 0x2F);
+  }
+
+  public boolean isMiscCode() {
+    return (cc1 == MISC_CHAN_1 || cc1 == MISC_CHAN_2) && (cc2 >= 0x20 && cc2 <= 0x2F);
+  }
+
+  public boolean isTabOffsetCode() {
+    return (cc1 == TAB_OFFSET_CHAN_1 || cc1 == TAB_OFFSET_CHAN_2) && (cc2 >= 0x21 && cc2 <= 0x23);
+  }
+
+  public boolean isPreambleAddressCode() {
+    return (cc1 >= 0x10 && cc1 <= 0x1F) && (cc2 >= 0x40 && cc2 <= 0x7F);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionList.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionList.java
new file mode 100644
index 0000000000..f47ec1f466
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionList.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.eia608;
+
+/* package */ final class ClosedCaptionList implements Comparable<ClosedCaptionList> {
+
+  public final long timeUs;
+  public final boolean decodeOnly;
+  public final ClosedCaption[] captions;
+
+  public ClosedCaptionList(long timeUs, boolean decodeOnly, ClosedCaption[] captions) {
+    this.timeUs = timeUs;
+    this.decodeOnly = decodeOnly;
+    this.captions = captions;
+  }
+
+  @Override
+  public int compareTo(ClosedCaptionList other) {
+    long delta = timeUs - other.timeUs;
+    if (delta == 0) {
+      return 0;
+    }
+    return delta > 0 ? 1 : -1;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionText.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionText.java
new file mode 100644
index 0000000000..98e93ea493
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionText.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.eia608;
+
+/* package */ final class ClosedCaptionText extends ClosedCaption {
+
+  public final String text;
+
+  public ClosedCaptionText(String text) {
+    super(ClosedCaption.TYPE_TEXT);
+    this.text = text;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
new file mode 100644
index 0000000000..a855e34839
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.eia608;
+
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.util.ArrayList;
+
+/**
+ * Facilitates the extraction and parsing of EIA-608 (a.k.a. "line 21 captions" and "CEA-608")
+ * Closed Captions from the SEI data block from H.264.
+ */
+public class Eia608Parser {
+
+  private static final int PAYLOAD_TYPE_CC = 4;
+  private static final int COUNTRY_CODE = 0xB5;
+  private static final int PROVIDER_CODE = 0x31;
+  private static final int USER_ID = 0x47413934; // "GA94"
+  private static final int USER_DATA_TYPE_CODE = 0x3;
+
+  // Basic North American 608 CC char set, mostly ASCII. Indexed by (char-0x20).
+  private static final int[] BASIC_CHARACTER_SET = new int[] {
+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,     //   ! " # $ % & '
+    0x28, 0x29,                                         // ( )
+    0xE1,       // 2A: 225 'á' "Latin small letter A with acute"
+    0x2B, 0x2C, 0x2D, 0x2E, 0x2F,                       //       + , - . /
+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,     // 0 1 2 3 4 5 6 7
+    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,     // 8 9 : ; < = > ?
+    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,     // @ A B C D E F G
+    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,     // H I J K L M N O
+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,     // P Q R S T U V W
+    0x58, 0x59, 0x5A, 0x5B,                             // X Y Z [
+    0xE9,       // 5C: 233 'é' "Latin small letter E with acute"
+    0x5D,                                               //           ]
+    0xED,       // 5E: 237 'í' "Latin small letter I with acute"
+    0xF3,       // 5F: 243 'ó' "Latin small letter O with acute"
+    0xFA,       // 60: 250 'ú' "Latin small letter U with acute"
+    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,           //   a b c d e f g
+    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,     // h i j k l m n o
+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,     // p q r s t u v w
+    0x78, 0x79, 0x7A,                                   // x y z
+    0xE7,       // 7B: 231 'ç' "Latin small letter C with cedilla"
+    0xF7,       // 7C: 247 '÷' "Division sign"
+    0xD1,       // 7D: 209 'Ñ' "Latin capital letter N with tilde"
+    0xF1,       // 7E: 241 'ñ' "Latin small letter N with tilde"
+    0x25A0      // 7F:         "Black Square" (NB: 2588 = Full Block)
+  };
+
+  // Special North American 608 CC char set.
+  private static final int[] SPECIAL_CHARACTER_SET = new int[] {
+    0xAE,    // 30: 174 '®' "Registered Sign" - registered trademark symbol
+    0xB0,    // 31: 176 '°' "Degree Sign"
+    0xBD,    // 32: 189 '½' "Vulgar Fraction One Half" (1/2 symbol)
+    0xBF,    // 33: 191 '¿' "Inverted Question Mark"
+    0x2122,  // 34:         "Trade Mark Sign" (tm superscript)
+    0xA2,    // 35: 162 '¢' "Cent Sign"
+    0xA3,    // 36: 163 '£' "Pound Sign" - pounds sterling
+    0x266A,  // 37:         "Eighth Note" - music note
+    0xE0,    // 38: 224 'à' "Latin small letter A with grave"
+    0x20,    // 39:         TRANSPARENT SPACE - for now use ordinary space
+    0xE8,    // 3A: 232 'è' "Latin small letter E with grave"
+    0xE2,    // 3B: 226 'â' "Latin small letter A with circumflex"
+    0xEA,    // 3C: 234 'ê' "Latin small letter E with circumflex"
+    0xEE,    // 3D: 238 'î' "Latin small letter I with circumflex"
+    0xF4,    // 3E: 244 'ô' "Latin small letter O with circumflex"
+    0xFB     // 3F: 251 'û' "Latin small letter U with circumflex"
+  };
+
+  private final ParsableBitArray seiBuffer;
+  private final StringBuilder stringBuilder;
+  private final ArrayList<ClosedCaption> captions;
+
+  /* package */ Eia608Parser() {
+    seiBuffer = new ParsableBitArray();
+    stringBuilder = new StringBuilder();
+    captions = new ArrayList<ClosedCaption>();
+  }
+
+  /* package */ boolean canParse(String mimeType) {
+    return mimeType.equals(MimeTypes.APPLICATION_EIA608);
+  }
+
+  /* package */ ClosedCaptionList parse(SampleHolder sampleHolder) {
+    if (sampleHolder.size <= 0) {
+      return null;
+    }
+
+    captions.clear();
+    stringBuilder.setLength(0);
+    seiBuffer.reset(sampleHolder.data.array());
+    seiBuffer.skipBits(3); // reserved + process_cc_data_flag + zero_bit
+    int ccCount = seiBuffer.readBits(5);
+    seiBuffer.skipBits(8);
+
+    for (int i = 0; i < ccCount; i++) {
+      seiBuffer.skipBits(5); // one_bit + reserved
+      boolean ccValid = seiBuffer.readBit();
+      if (!ccValid) {
+        seiBuffer.skipBits(18);
+        continue;
+      }
+      int ccType = seiBuffer.readBits(2);
+      if (ccType != 0) {
+        seiBuffer.skipBits(16);
+        continue;
+      }
+      seiBuffer.skipBits(1);
+      byte ccData1 = (byte) seiBuffer.readBits(7);
+      seiBuffer.skipBits(1);
+      byte ccData2 = (byte) seiBuffer.readBits(7);
+
+      // Ignore empty captions.
+      if (ccData1 == 0 && ccData2 == 0) {
+        continue;
+      }
+
+      // Special North American character set.
+      if ((ccData1 == 0x11) && ((ccData2 & 0x70) == 0x30)) {
+        stringBuilder.append(getSpecialChar(ccData2));
+        continue;
+      }
+
+      // Control character.
+      if (ccData1 < 0x20) {
+        if (stringBuilder.length() > 0) {
+          captions.add(new ClosedCaptionText(stringBuilder.toString()));
+          stringBuilder.setLength(0);
+        }
+        captions.add(new ClosedCaptionCtrl(ccData1, ccData2));
+        continue;
+      }
+
+      // Basic North American character set.
+      stringBuilder.append(getChar(ccData1));
+      if (ccData2 != 0) {
+        stringBuilder.append(getChar(ccData2));
+      }
+    }
+
+    if (stringBuilder.length() > 0) {
+      captions.add(new ClosedCaptionText(stringBuilder.toString()));
+    }
+
+    if (captions.isEmpty()) {
+      return null;
+    }
+
+    ClosedCaption[] captionArray = new ClosedCaption[captions.size()];
+    captions.toArray(captionArray);
+    return new ClosedCaptionList(sampleHolder.timeUs, sampleHolder.decodeOnly, captionArray);
+  }
+
+  private static char getChar(byte ccData) {
+    int index = (ccData & 0x7F) - 0x20;
+    return (char) BASIC_CHARACTER_SET[index];
+  }
+
+  private static char getSpecialChar(byte ccData) {
+    int index = ccData & 0xF;
+    return (char) SPECIAL_CHARACTER_SET[index];
+  }
+
+  /**
+   * Parses the beginning of SEI data and returns the size of underlying contains closed captions
+   * data following the header. Returns 0 if the SEI doesn't contain any closed captions data.
+   *
+   * @param seiBuffer The buffer to read from.
+   * @return The size of closed captions data.
+   */
+  public static int parseHeader(ParsableByteArray seiBuffer) {
+    int b = 0;
+    int payloadType = 0;
+
+    do {
+      b = seiBuffer.readUnsignedByte();
+      payloadType += b;
+    } while (b == 0xFF);
+
+    if (payloadType != PAYLOAD_TYPE_CC) {
+      return 0;
+    }
+
+    int payloadSize = 0;
+    do {
+      b = seiBuffer.readUnsignedByte();
+      payloadSize += b;
+    } while (b == 0xFF);
+
+    if (payloadSize <= 0) {
+      return 0;
+    }
+
+    int countryCode = seiBuffer.readUnsignedByte();
+    if (countryCode != COUNTRY_CODE) {
+      return 0;
+    }
+    int providerCode = seiBuffer.readUnsignedShort();
+    if (providerCode != PROVIDER_CODE) {
+      return 0;
+    }
+    int userIdentifier = seiBuffer.readInt();
+    if (userIdentifier != USER_ID) {
+      return 0;
+    }
+    int userDataTypeCode = seiBuffer.readUnsignedByte();
+    if (userDataTypeCode != USER_DATA_TYPE_CODE) {
+      return 0;
+    }
+    return payloadSize;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
new file mode 100644
index 0000000000..8e855bf730
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.eia608;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.text.TextRenderer;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+
+import java.io.IOException;
+import java.util.TreeSet;
+
+/**
+ * A {@link TrackRenderer} for EIA-608 closed captions in a media stream.
+ */
+public class Eia608TrackRenderer extends TrackRenderer implements Callback {
+
+  private static final int MSG_INVOKE_RENDERER = 0;
+
+  private static final int CC_MODE_UNKNOWN = 0;
+  private static final int CC_MODE_ROLL_UP = 1;
+  private static final int CC_MODE_POP_ON = 2;
+  private static final int CC_MODE_PAINT_ON = 3;
+
+  // The default number of rows to display in roll-up captions mode.
+  private static final int DEFAULT_CAPTIONS_ROW_COUNT = 4;
+  // The maximum duration that captions are parsed ahead of the current position.
+  private static final int MAX_SAMPLE_READAHEAD_US = 5000000;
+
+  private final SampleSource source;
+  private final Eia608Parser eia608Parser;
+  private final TextRenderer textRenderer;
+  private final Handler textRendererHandler;
+  private final MediaFormatHolder formatHolder;
+  private final SampleHolder sampleHolder;
+  private final StringBuilder captionStringBuilder;
+  private final TreeSet<ClosedCaptionList> pendingCaptionLists;
+
+  private int trackIndex;
+  private long currentPositionUs;
+  private boolean inputStreamEnded;
+
+  private int captionMode;
+  private int captionRowCount;
+  private String caption;
+  private String lastRenderedCaption;
+
+  /**
+   * @param source A source from which samples containing EIA-608 closed captions can be read.
+   * @param textRenderer The text renderer.
+   * @param textRendererLooper The looper associated with the thread on which textRenderer should be
+   *     invoked. If the renderer makes use of standard Android UI components, then this should
+   *     normally be the looper associated with the applications' main thread, which can be
+   *     obtained using {@link android.app.Activity#getMainLooper()}. Null may be passed if the
+   *     renderer should be invoked directly on the player's internal rendering thread.
+   */
+  public Eia608TrackRenderer(SampleSource source, TextRenderer textRenderer,
+      Looper textRendererLooper) {
+    this.source = Assertions.checkNotNull(source);
+    this.textRenderer = Assertions.checkNotNull(textRenderer);
+    textRendererHandler = textRendererLooper == null ? null : new Handler(textRendererLooper, this);
+    eia608Parser = new Eia608Parser();
+    formatHolder = new MediaFormatHolder();
+    sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+    captionStringBuilder = new StringBuilder();
+    pendingCaptionLists = new TreeSet<ClosedCaptionList>();
+  }
+
+  @Override
+  protected int doPrepare() throws ExoPlaybackException {
+    try {
+      boolean sourcePrepared = source.prepare();
+      if (!sourcePrepared) {
+        return TrackRenderer.STATE_UNPREPARED;
+      }
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+    for (int i = 0; i < source.getTrackCount(); i++) {
+      if (eia608Parser.canParse(source.getTrackInfo(i).mimeType)) {
+        trackIndex = i;
+        return TrackRenderer.STATE_PREPARED;
+      }
+    }
+    return TrackRenderer.STATE_IGNORE;
+  }
+
+  @Override
+  protected void onEnabled(long positionUs, boolean joining) {
+    source.enable(trackIndex, positionUs);
+    seekToInternal(positionUs);
+  }
+
+  @Override
+  protected void seekTo(long positionUs) throws ExoPlaybackException {
+    source.seekToUs(positionUs);
+    seekToInternal(positionUs);
+  }
+
+  private void seekToInternal(long positionUs) {
+    currentPositionUs = positionUs;
+    inputStreamEnded = false;
+    pendingCaptionLists.clear();
+    clearPendingSample();
+    captionRowCount = DEFAULT_CAPTIONS_ROW_COUNT;
+    setCaptionMode(CC_MODE_UNKNOWN);
+    invokeRenderer(null);
+  }
+
+  @Override
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException {
+    currentPositionUs = positionUs;
+    try {
+      source.continueBuffering(positionUs);
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+
+    if (isSamplePending()) {
+      maybeParsePendingSample();
+    }
+
+    int result = inputStreamEnded ? SampleSource.END_OF_STREAM : SampleSource.SAMPLE_READ;
+    while (!isSamplePending() && result == SampleSource.SAMPLE_READ) {
+      try {
+        result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
+        if (result == SampleSource.SAMPLE_READ) {
+          maybeParsePendingSample();
+        } else if (result == SampleSource.END_OF_STREAM) {
+          inputStreamEnded = true;
+        }
+      } catch (IOException e) {
+        throw new ExoPlaybackException(e);
+      }
+    }
+
+    while (!pendingCaptionLists.isEmpty()) {
+      if (pendingCaptionLists.first().timeUs > currentPositionUs) {
+        // We're too early to render any of the pending caption lists.
+        return;
+      }
+      // Remove and consume the next caption list.
+      ClosedCaptionList nextCaptionList = pendingCaptionLists.pollFirst();
+      consumeCaptionList(nextCaptionList);
+      // Update the renderer, unless the caption list was marked for decoding only.
+      if (!nextCaptionList.decodeOnly) {
+        invokeRenderer(caption);
+      }
+    }
+  }
+
+  @Override
+  protected void onDisabled() {
+    source.disable(trackIndex);
+  }
+
+  @Override
+  protected long getDurationUs() {
+    return source.getTrackInfo(trackIndex).durationUs;
+  }
+
+  @Override
+  protected long getCurrentPositionUs() {
+    return currentPositionUs;
+  }
+
+  @Override
+  protected long getBufferedPositionUs() {
+    return TrackRenderer.END_OF_TRACK_US;
+  }
+
+  @Override
+  protected boolean isEnded() {
+    return inputStreamEnded;
+  }
+
+  @Override
+  protected boolean isReady() {
+    return true;
+  }
+
+  private void invokeRenderer(String text) {
+    if (Util.areEqual(lastRenderedCaption, text)) {
+      // No change.
+      return;
+    }
+    this.lastRenderedCaption = text;
+    if (textRendererHandler != null) {
+      textRendererHandler.obtainMessage(MSG_INVOKE_RENDERER, text).sendToTarget();
+    } else {
+      invokeRendererInternal(text);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public boolean handleMessage(Message msg) {
+    switch (msg.what) {
+      case MSG_INVOKE_RENDERER:
+        invokeRendererInternal((String) msg.obj);
+        return true;
+    }
+    return false;
+  }
+
+  private void invokeRendererInternal(String text) {
+    textRenderer.onText(text);
+  }
+
+  private void maybeParsePendingSample() {
+    if (sampleHolder.timeUs > currentPositionUs + MAX_SAMPLE_READAHEAD_US) {
+      // We're too early to parse the sample.
+      return;
+    }
+    ClosedCaptionList holder = eia608Parser.parse(sampleHolder);
+    clearPendingSample();
+    if (holder != null) {
+      pendingCaptionLists.add(holder);
+    }
+  }
+
+  private void consumeCaptionList(ClosedCaptionList captionList) {
+    int captionBufferSize = captionList.captions.length;
+    if (captionBufferSize == 0) {
+      return;
+    }
+
+    for (int i = 0; i < captionBufferSize; i++) {
+      ClosedCaption caption = captionList.captions[i];
+      if (caption.type == ClosedCaption.TYPE_CTRL) {
+        ClosedCaptionCtrl captionCtrl = (ClosedCaptionCtrl) caption;
+        if (captionCtrl.isMiscCode()) {
+          handleMiscCode(captionCtrl);
+        } else if (captionCtrl.isPreambleAddressCode()) {
+          handlePreambleAddressCode();
+        }
+      } else {
+        handleText((ClosedCaptionText) caption);
+      }
+    }
+
+    if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
+      caption = getDisplayCaption();
+    }
+  }
+
+  private void handleText(ClosedCaptionText captionText) {
+    if (captionMode != CC_MODE_UNKNOWN) {
+      captionStringBuilder.append(captionText.text);
+    }
+  }
+
+  private void handleMiscCode(ClosedCaptionCtrl captionCtrl) {
+    switch (captionCtrl.cc2) {
+      case ClosedCaptionCtrl.ROLL_UP_CAPTIONS_2_ROWS:
+        captionRowCount = 2;
+        setCaptionMode(CC_MODE_ROLL_UP);
+        return;
+      case ClosedCaptionCtrl.ROLL_UP_CAPTIONS_3_ROWS:
+        captionRowCount = 3;
+        setCaptionMode(CC_MODE_ROLL_UP);
+        return;
+      case ClosedCaptionCtrl.ROLL_UP_CAPTIONS_4_ROWS:
+        captionRowCount = 4;
+        setCaptionMode(CC_MODE_ROLL_UP);
+        return;
+      case ClosedCaptionCtrl.RESUME_CAPTION_LOADING:
+        setCaptionMode(CC_MODE_POP_ON);
+        return;
+      case ClosedCaptionCtrl.RESUME_DIRECT_CAPTIONING:
+        setCaptionMode(CC_MODE_PAINT_ON);
+        return;
+    }
+
+    if (captionMode == CC_MODE_UNKNOWN) {
+      return;
+    }
+
+    switch (captionCtrl.cc2) {
+      case ClosedCaptionCtrl.ERASE_DISPLAYED_MEMORY:
+        caption = null;
+        if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
+          captionStringBuilder.setLength(0);
+        }
+        return;
+      case ClosedCaptionCtrl.ERASE_NON_DISPLAYED_MEMORY:
+        captionStringBuilder.setLength(0);
+        return;
+      case ClosedCaptionCtrl.END_OF_CAPTION:
+        caption = getDisplayCaption();
+        captionStringBuilder.setLength(0);
+        return;
+      case ClosedCaptionCtrl.CARRIAGE_RETURN:
+        maybeAppendNewline();
+        return;
+    }
+  }
+
+  private void handlePreambleAddressCode() {
+    // TODO: Add better handling of this with specific positioning.
+    maybeAppendNewline();
+  }
+
+  private void setCaptionMode(int captionMode) {
+    if (this.captionMode == captionMode) {
+      return;
+    }
+
+    this.captionMode = captionMode;
+    // Clear the working memory.
+    captionStringBuilder.setLength(0);
+    if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_UNKNOWN) {
+      // When switching to roll-up or unknown, we also need to clear the caption.
+      caption = null;
+    }
+  }
+
+  private void maybeAppendNewline() {
+    int buildLength = captionStringBuilder.length();
+    if (buildLength > 0 && captionStringBuilder.charAt(buildLength - 1) != '\n') {
+      captionStringBuilder.append('\n');
+    }
+  }
+
+  private String getDisplayCaption() {
+    int buildLength = captionStringBuilder.length();
+    if (buildLength == 0) {
+      return null;
+    }
+
+    boolean endsWithNewline = captionStringBuilder.charAt(buildLength - 1) == '\n';
+    if (buildLength == 1 && endsWithNewline) {
+      return null;
+    }
+
+    int endIndex = endsWithNewline ? buildLength - 1 : buildLength;
+    if (captionMode != CC_MODE_ROLL_UP) {
+      return captionStringBuilder.substring(0, endIndex);
+    }
+
+    int startIndex = 0;
+    int searchBackwardFromIndex = endIndex;
+    for (int i = 0; i < captionRowCount && searchBackwardFromIndex != -1; i++) {
+      searchBackwardFromIndex = captionStringBuilder.lastIndexOf("\n", searchBackwardFromIndex - 1);
+    }
+    if (searchBackwardFromIndex != -1) {
+      startIndex = searchBackwardFromIndex + 1;
+    }
+    captionStringBuilder.delete(0, startIndex);
+    return captionStringBuilder.substring(0, endIndex - startIndex);
+  }
+
+  private void clearPendingSample() {
+    sampleHolder.timeUs = C.UNKNOWN_TIME_US;
+    sampleHolder.clearData();
+  }
+
+  private boolean isSamplePending() {
+    return sampleHolder.timeUs != C.UNKNOWN_TIME_US;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
index 036c6116a1..5d331a78b2 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
@@ -32,7 +32,6 @@
  * A simple WebVTT parser.
  * <p>
  * @see <a href="http://dev.w3.org/html5/webvtt">WebVTT specification</a>
- * <p>
  */
 public class WebvttParser implements SubtitleParser {
 
@@ -57,20 +56,28 @@
   private static final Pattern WEBVTT_METADATA_HEADER =
       Pattern.compile(WEBVTT_METADATA_HEADER_STRING);
 
+  private static final String WEBVTT_CUE_IDENTIFIER_STRING = "^(?!.*(-->)).*$";
+  private static final Pattern WEBVTT_CUE_IDENTIFIER =
+      Pattern.compile(WEBVTT_CUE_IDENTIFIER_STRING);
+
   private static final String WEBVTT_TIMESTAMP_STRING = "(\\d+:)?[0-5]\\d:[0-5]\\d\\.\\d{3}";
   private static final Pattern WEBVTT_TIMESTAMP = Pattern.compile(WEBVTT_TIMESTAMP_STRING);
 
   private static final Pattern MEDIA_TIMESTAMP_OFFSET = Pattern.compile(OFFSET + "\\d+");
   private static final Pattern MEDIA_TIMESTAMP = Pattern.compile("MPEGTS:\\d+");
 
+  private static final String WEBVTT_CUE_TAG_STRING = "\\<.*?>";
+
   private final boolean strictParsing;
+  private final boolean filterTags;
 
   public WebvttParser() {
-    this(true);
+    this(true, true);
   }
 
-  public WebvttParser(boolean strictParsing) {
+  public WebvttParser(boolean strictParsing, boolean filterTags) {
     this.strictParsing = strictParsing;
+    this.filterTags = filterTags;
   }
 
   @Override
@@ -88,6 +95,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
     if (line == null) {
       throw new ParserException("Expected WEBVTT or EXO-HEADER. Got null");
     }
+
     if (line.startsWith(EXO_HEADER)) {
       // parse the timestamp offset, if present
       Matcher matcher = MEDIA_TIMESTAMP_OFFSET.matcher(line);
@@ -101,7 +109,8 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
         throw new ParserException("Expected WEBVTT. Got null");
       }
     }
-    if (!line.equals("WEBVTT")) {
+
+    if (!line.equals("WEBVTT") && !line.equals("\uFEFFWEBVTT")) {
       throw new ParserException("Expected WEBVTT. Got " + line);
     }
 
@@ -136,8 +145,15 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
 
     // process the cues and text
     while ((line = webvttData.readLine()) != null) {
+      // parse the cue identifier (if present) {
+      Matcher matcher = WEBVTT_CUE_IDENTIFIER.matcher(line);
+      if (matcher.find()) {
+        // ignore the identifier (we currently don't use it) and read the next line
+        line = webvttData.readLine();
+      }
+
       // parse the cue timestamps
-      Matcher matcher = WEBVTT_TIMESTAMP.matcher(line);
+      matcher = WEBVTT_TIMESTAMP.matcher(line);
       long startTime;
       long endTime;
       String text = "";
@@ -158,7 +174,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
 
       // parse text
       while (((line = webvttData.readLine()) != null) && (!line.isEmpty())) {
-        text += line.trim() + "\n";
+        text += processCueText(line.trim()) + "\n";
       }
 
       WebvttCue cue = new WebvttCue(startTime, endTime, text);
@@ -192,6 +208,19 @@ protected long getAdjustedStartTime(long startTimeUs) {
     return startTimeUs;
   }
 
+  protected String processCueText(String line) {
+    if (filterTags) {
+      line = line.replaceAll(WEBVTT_CUE_TAG_STRING, "");
+      line = line.replaceAll("&lt;", "<");
+      line = line.replaceAll("&gt;", ">");
+      line = line.replaceAll("&nbsp;", " ");
+      line = line.replaceAll("&amp;", "&");
+      return line;
+    } else {
+      return line;
+    }
+  }
+
   protected void handleNoncompliantLine(String line) throws ParserException {
     if (strictParsing) {
       throw new ParserException("Unexpected line: " + line);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
new file mode 100644
index 0000000000..938dd70ef1
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.io.IOException;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.Key;
+import java.security.NoSuchAlgorithmException;
+import java.security.spec.AlgorithmParameterSpec;
+
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * A {@link DataSource} that decrypts the data read from an upstream source, encrypted with AES-128
+ * with a 128-bit key and PKCS7 padding.
+ *
+ */
+public class Aes128DataSource implements DataSource {
+
+  private final DataSource upstream;
+  private final byte[] secretKey;
+  private final byte[] iv;
+
+  private CipherInputStream cipherInputStream;
+
+  public Aes128DataSource(byte[] secretKey, byte[] iv, DataSource upstream) {
+    this.upstream = upstream;
+    this.secretKey = secretKey;
+    this.iv = iv;
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    Cipher cipher;
+    try {
+      cipher = Cipher.getInstance("AES/CBC/PKCS7Padding");
+    } catch (NoSuchAlgorithmException e) {
+      throw new RuntimeException(e);
+    } catch (NoSuchPaddingException e) {
+      throw new RuntimeException(e);
+    }
+
+    Key cipherKey = new SecretKeySpec(secretKey, "AES");
+    AlgorithmParameterSpec cipherIV = new IvParameterSpec(iv);
+
+    try {
+      cipher.init(Cipher.DECRYPT_MODE, cipherKey, cipherIV);
+    } catch (InvalidKeyException e) {
+      throw new RuntimeException(e);
+    } catch (InvalidAlgorithmParameterException e) {
+      throw new RuntimeException(e);
+    }
+
+    cipherInputStream = new CipherInputStream(
+        new DataSourceInputStream(upstream, dataSpec), cipher);
+
+    return C.LENGTH_UNBOUNDED;
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipherInputStream = null;
+    upstream.close();
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    Assertions.checkState(cipherInputStream != null);
+    int bytesRead = cipherInputStream.read(buffer, offset, readLength);
+    if (bytesRead < 0) {
+      return -1;
+    }
+    return bytesRead;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java b/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java
index a7d847d5a1..af2ce03a20 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java
@@ -96,12 +96,38 @@ public synchronized Allocation allocate(int size) {
     allocatedBufferCount += requiredBufferCount - firstNewBufferIndex;
     for (int i = firstNewBufferIndex; i < requiredBufferCount; i++) {
       // Use a recycled buffer if one is available. Else instantiate a new one.
-      buffers[i] = recycledBufferCount > 0 ? recycledBuffers[--recycledBufferCount] :
-          new byte[bufferLength];
+      buffers[i] = nextBuffer();
     }
     return buffers;
   }
 
+  /**
+   * Obtain a single buffer directly from the pool.
+   * <p>
+   * When the caller has finished with the buffer, it should be returned to the pool by calling
+   * {@link #releaseDirect(byte[])}.
+   *
+   * @return The allocated buffer.
+   */
+  public synchronized byte[] allocateDirect() {
+    allocatedBufferCount++;
+    return nextBuffer();
+  }
+
+  /**
+   * Return a single buffer to the pool.
+   *
+   * @param buffer The buffer being returned.
+   */
+  public synchronized void releaseDirect(byte[] buffer) {
+    // Weak sanity check that the buffer probably originated from this pool.
+    Assertions.checkArgument(buffer.length == bufferLength);
+    allocatedBufferCount--;
+
+    ensureRecycledBufferCapacity(recycledBufferCount + 1);
+    recycledBuffers[recycledBufferCount++] = buffer;
+  }
+
   /**
    * Returns the buffers belonging to an allocation to the pool.
    *
@@ -112,14 +138,7 @@ public synchronized Allocation allocate(int size) {
     allocatedBufferCount -= buffers.length;
 
     int newRecycledBufferCount = recycledBufferCount + buffers.length;
-    if (recycledBuffers.length < newRecycledBufferCount) {
-      // Expand the capacity of the recycled buffers array.
-      byte[][] newRecycledBuffers = new byte[newRecycledBufferCount * 2][];
-      if (recycledBufferCount > 0) {
-        System.arraycopy(recycledBuffers, 0, newRecycledBuffers, 0, recycledBufferCount);
-      }
-      recycledBuffers = newRecycledBuffers;
-    }
+    ensureRecycledBufferCapacity(newRecycledBufferCount);
     System.arraycopy(buffers, 0, recycledBuffers, recycledBufferCount, buffers.length);
     recycledBufferCount = newRecycledBufferCount;
   }
@@ -128,6 +147,22 @@ private int requiredBufferCount(long size) {
     return (int) ((size + bufferLength - 1) / bufferLength);
   }
 
+  private byte[] nextBuffer() {
+    return recycledBufferCount > 0 ? recycledBuffers[--recycledBufferCount]
+        : new byte[bufferLength];
+  }
+
+  private void ensureRecycledBufferCapacity(int requiredCapacity) {
+    if (recycledBuffers.length < requiredCapacity) {
+      // Expand the capacity of the recycled buffers array.
+      byte[][] newRecycledBuffers = new byte[requiredCapacity * 2][];
+      if (recycledBufferCount > 0) {
+        System.arraycopy(recycledBuffers, 0, newRecycledBuffers, 0, recycledBufferCount);
+      }
+      recycledBuffers = newRecycledBuffers;
+    }
+  }
+
   private class AllocationImpl implements Allocation {
 
     private byte[][] buffers;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java
index 768d7061a1..0438f87371 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java
@@ -27,24 +27,27 @@
 
   private final byte[] data;
   private int readPosition;
+  private int remainingBytes;
 
   /**
    * @param data The data to be read.
    */
   public ByteArrayDataSource(byte[] data) {
-    this.data = Assertions.checkNotNull(data);
+    Assertions.checkNotNull(data);
+    Assertions.checkArgument(data.length > 0);
+    this.data = data;
   }
 
   @Override
   public long open(DataSpec dataSpec) throws IOException {
-    if (dataSpec.length == C.LENGTH_UNBOUNDED) {
-      Assertions.checkArgument(dataSpec.position < data.length);
-    } else {
-      Assertions.checkArgument(dataSpec.position + dataSpec.length <= data.length);
-    }
     readPosition = (int) dataSpec.position;
-    return (dataSpec.length == C.LENGTH_UNBOUNDED) ? (data.length - dataSpec.position)
-        : dataSpec.length;
+    remainingBytes = (int) ((dataSpec.length == C.LENGTH_UNBOUNDED)
+        ? (data.length - dataSpec.position) : dataSpec.length);
+    if (remainingBytes <= 0 || readPosition + remainingBytes > data.length) {
+      throw new IOException("Unsatisfiable range: [" + readPosition + ", " + dataSpec.length
+          + "], length: " + data.length);
+    }
+    return remainingBytes;
   }
 
   @Override
@@ -54,8 +57,13 @@ public void close() throws IOException {
 
   @Override
   public int read(byte[] buffer, int offset, int length) throws IOException {
+    if (remainingBytes == 0) {
+      return -1;
+    }
+    length = Math.min(length, remainingBytes);
     System.arraycopy(data, readPosition, buffer, offset, length);
     readPosition += length;
+    remainingBytes -= length;
     return length;
   }
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
index 8ed35c3ea8..e0a01f3a9a 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
@@ -46,7 +46,7 @@ public DataSourceInputStream(DataSource dataSource, DataSpec dataSpec) {
   @Override
   public int read() throws IOException {
     read(singleByteArray);
-    return singleByteArray[0];
+    return singleByteArray[0] & 0xFF;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
index 164820654c..fd2f345e4c 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
@@ -226,6 +226,19 @@ public void clearAllRequestProperties() {
     }
   }
 
+  /*
+   * TODO: If the server uses gzip compression when serving the response, this may end up returning
+   * the size of the compressed response, where-as it should be returning the decompressed size or
+   * -1. See: developer.android.com/reference/java/net/HttpURLConnection.html
+   *
+   * To fix this we should:
+   *
+   * 1. Explicitly require no compression for media requests (since media should be compressed
+   *    already) by setting the Accept-Encoding header to "identity"
+   * 2. In other cases, for example when requesting manifests, we don't want to disable compression.
+   *    For these cases we should ensure that we return -1 here (and avoid performing any sanity
+   *    checks on the content length).
+   */
   @Override
   public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.dataSpec = dataSpec;
@@ -380,19 +393,22 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
         connection.setRequestProperty(property.getKey(), property.getValue());
       }
     }
-    connection.setRequestProperty("Accept-Encoding", "deflate");
+    setRangeHeader(connection, dataSpec);
     connection.setRequestProperty("User-Agent", userAgent);
-    connection.setRequestProperty("Range", buildRangeHeader(dataSpec));
     connection.connect();
     return connection;
   }
 
-  private String buildRangeHeader(DataSpec dataSpec) {
+  private void setRangeHeader(HttpURLConnection connection, DataSpec dataSpec) {
+    if (dataSpec.position == 0 && dataSpec.length == C.LENGTH_UNBOUNDED) {
+      // Not required.
+      return;
+    }
     String rangeRequest = "bytes=" + dataSpec.position + "-";
     if (dataSpec.length != C.LENGTH_UNBOUNDED) {
       rangeRequest += (dataSpec.position + dataSpec.length - 1);
     }
-    return rangeRequest;
+    connection.setRequestProperty("Range", rangeRequest);
   }
 
   private long getContentLength(HttpURLConnection connection) {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java b/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java
index 26df7db5c4..2576fff1cd 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java
@@ -53,10 +53,17 @@ public PriorityTooLowException(int priority, int highestPriority) {
    */
   public static final int DOWNLOAD_PRIORITY = 10;
 
+  private final Object lock = new Object();
+
+  /** Guarded by {@link #lock}. */
   private final PriorityQueue<Integer> queue;
 
+  /** Guarded by {@link #lock}. */
+  private int highestPriority;
+
   private NetworkLock() {
     queue = new PriorityQueue<Integer>();
+    highestPriority = Integer.MAX_VALUE;
   }
 
   /**
@@ -64,9 +71,11 @@ private NetworkLock() {
    *
    * @param priority The priority of the task that would like to proceed.
    */
-  public synchronized void proceed(int priority) throws InterruptedException {
-    while (queue.peek() < priority) {
-      wait();
+  public void proceed(int priority) throws InterruptedException {
+    synchronized (lock) {
+      while (highestPriority < priority) {
+        lock.wait();
+      }
     }
   }
 
@@ -76,8 +85,10 @@ public synchronized void proceed(int priority) throws InterruptedException {
    * @param priority The priority of the task that would like to proceed.
    * @return Whether the passed priority is allowed to proceed.
    */
-  public synchronized boolean proceedNonBlocking(int priority) {
-    return queue.peek() >= priority;
+  public boolean proceedNonBlocking(int priority) {
+    synchronized (lock) {
+      return highestPriority >= priority;
+    }
   }
 
   /**
@@ -86,10 +97,11 @@ public synchronized boolean proceedNonBlocking(int priority) {
    * @param priority The priority of the task that would like to proceed.
    * @throws PriorityTooLowException If the passed priority is not high enough to proceed.
    */
-  public synchronized void proceedOrThrow(int priority) throws PriorityTooLowException {
-    int highestPriority = queue.peek();
-    if (highestPriority < priority) {
-      throw new PriorityTooLowException(priority, highestPriority);
+  public void proceedOrThrow(int priority) throws PriorityTooLowException {
+    synchronized (lock) {
+      if (highestPriority < priority) {
+        throw new PriorityTooLowException(priority, highestPriority);
+      }
     }
   }
 
@@ -100,8 +112,11 @@ public synchronized void proceedOrThrow(int priority) throws PriorityTooLowExcep
    *
    * @param priority The priority of the task.
    */
-  public synchronized void add(int priority) {
-    queue.add(priority);
+  public void add(int priority) {
+    synchronized (lock) {
+      queue.add(priority);
+      highestPriority = Math.min(highestPriority, priority);
+    }
   }
 
   /**
@@ -109,9 +124,12 @@ public synchronized void add(int priority) {
    *
    * @param priority The priority of the task.
    */
-  public synchronized void remove(int priority) {
-    queue.remove(priority);
-    notifyAll();
+  public void remove(int priority) {
+    synchronized (lock) {
+      queue.remove(priority);
+      highestPriority = queue.isEmpty() ? Integer.MAX_VALUE : queue.peek();
+      lock.notifyAll();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
index a80df7fb86..5842d742ab 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer.util.Assertions;
 
 import android.net.Uri;
+import android.util.Log;
 
 import java.io.IOException;
 
@@ -50,6 +51,8 @@
 
   }
 
+  private static final String TAG = "CacheDataSource";
+
   private final Cache cache;
   private final DataSource cacheReadDataSource;
   private final DataSource cacheWriteDataSource;
@@ -123,9 +126,6 @@ public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDat
   @Override
   public long open(DataSpec dataSpec) throws IOException {
     Assertions.checkState(dataSpec.uriIsFullStream);
-    // TODO: Support caching for unbounded requests. This requires storing the source length
-    // into the cache (the simplest approach is to incorporate it into each cache file's name).
-    Assertions.checkState(dataSpec.length != C.LENGTH_UNBOUNDED);
     try {
       uri = dataSpec.uri;
       key = dataSpec.key;
@@ -148,10 +148,12 @@ public int read(byte[] buffer, int offset, int max) throws IOException {
           totalCachedBytesRead += bytesRead;
         }
         readPosition += bytesRead;
-        bytesRemaining -= bytesRead;
+        if (bytesRemaining != C.LENGTH_UNBOUNDED) {
+          bytesRemaining -= bytesRead;
+        }
       } else {
         closeCurrentSource();
-        if (bytesRemaining > 0) {
+        if (bytesRemaining > 0 && bytesRemaining != C.LENGTH_UNBOUNDED) {
           openNextSource();
           return read(buffer, offset, max);
         }
@@ -185,6 +187,11 @@ private void openNextSource() throws IOException {
       CacheSpan span;
       if (ignoreCache) {
         span = null;
+      } else if (bytesRemaining == C.LENGTH_UNBOUNDED) {
+        // TODO: Support caching for unbounded requests. This requires storing the source length
+        // into the cache (the simplest approach is to incorporate it into each cache file's name).
+        Log.w(TAG, "Cache bypassed due to unbounded length.");
+        span = null;
       } else if (blockOnCache) {
         span = cache.startReadWrite(key, readPosition);
       } else {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index d10b04ed27..11d49103e7 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -29,6 +29,7 @@
   public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
   public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
   public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
+  public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
 
   public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
   public static final String AUDIO_AAC = BASE_TYPE_AUDIO + "/mp4a-latm";
@@ -36,9 +37,12 @@
   public static final String AUDIO_EC3 = BASE_TYPE_AUDIO + "/eac3";
   public static final String AUDIO_WEBM = BASE_TYPE_AUDIO + "/webm";
   public static final String AUDIO_VORBIS = BASE_TYPE_AUDIO + "/vorbis";
+  public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
 
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
 
+  public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
+  public static final String APPLICATION_EIA608 = BASE_TYPE_APPLICATION + "/eia-608";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
 
   private MimeTypes() {}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
new file mode 100644
index 0000000000..a1f224a1f0
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+/**
+ * Wraps a byte array, providing methods that allow it to be read as a bitstream.
+ */
+public final class ParsableBitArray {
+
+  private byte[] data;
+
+  // The offset within the data, stored as the current byte offset, and the bit offset within that
+  // byte (from 0 to 7).
+  private int byteOffset;
+  private int bitOffset;
+
+  /** Creates a new instance that initially has no backing data. */
+  public ParsableBitArray() {}
+
+  /**
+   * Creates a new instance that wraps an existing array.
+   *
+   * @param data The data to wrap.
+   */
+  public ParsableBitArray(byte[] data) {
+    this.data = data;
+  }
+
+  /**
+   * Updates the instance to wrap {@code data}, and resets the position to zero.
+   *
+   * @param data The array to wrap.
+   */
+  public void reset(byte[] data) {
+    this.data = data;
+    byteOffset = 0;
+    bitOffset = 0;
+  }
+
+  /**
+   * Gets the backing byte array.
+   *
+   * @return The backing byte array.
+   */
+  public byte[] getData() {
+    return data;
+  }
+
+  /**
+   * Gets the current bit offset.
+   *
+   * @return The current bit offset.
+   */
+  public int getPosition() {
+    return byteOffset * 8 + bitOffset;
+  }
+
+  /**
+   * Sets the current bit offset.
+   *
+   * @param position The position to set.
+   */
+  public void setPosition(int position) {
+    byteOffset = position / 8;
+    bitOffset = position - (byteOffset * 8);
+  }
+
+  /**
+   * Skips bits and moves current reading position forward.
+   *
+   * @param n The number of bits to skip.
+   */
+  public void skipBits(int n) {
+    byteOffset += (n / 8);
+    bitOffset += (n % 8);
+    if (bitOffset > 7) {
+      byteOffset++;
+      bitOffset -= 8;
+    }
+  }
+
+  /**
+   * Reads a single bit.
+   *
+   * @return True if the bit is set. False otherwise.
+   */
+  public boolean readBit() {
+    return readBits(1) == 1;
+  }
+
+  /**
+   * Reads up to 32 bits.
+   *
+   * @param n The number of bits to read.
+   * @return An integer whose bottom n bits hold the read data.
+   */
+  public int readBits(int n) {
+    return (int) readBitsLong(n);
+  }
+
+  /**
+   * Reads up to 64 bits.
+   *
+   * @param n The number of bits to read.
+   * @return A long whose bottom n bits hold the read data.
+   */
+  public long readBitsLong(int n) {
+    if (n == 0) {
+      return 0;
+    }
+
+    long retval = 0;
+
+    // While n >= 8, read whole bytes.
+    while (n >= 8) {
+      n -= 8;
+      retval |= (readUnsignedByte() << n);
+    }
+
+    if (n > 0) {
+      int nextBit = bitOffset + n;
+      byte writeMask = (byte) (0xFF >> (8 - n));
+
+      if (nextBit > 8) {
+        // Combine bits from current byte and next byte.
+        retval |= (((getUnsignedByte(byteOffset) << (nextBit - 8)
+            | (getUnsignedByte(byteOffset + 1) >> (16 - nextBit))) & writeMask));
+        byteOffset++;
+      } else {
+        // Bits to be read only within current byte.
+        retval |= ((getUnsignedByte(byteOffset) >> (8 - nextBit)) & writeMask);
+        if (nextBit == 8) {
+          byteOffset++;
+        }
+      }
+
+      bitOffset = nextBit % 8;
+    }
+
+    return retval;
+  }
+
+  /**
+   * Reads an unsigned Exp-Golomb-coded format integer.
+   *
+   * @return The value of the parsed Exp-Golomb-coded integer.
+   */
+  public int readUnsignedExpGolombCodedInt() {
+    return readExpGolombCodeNum();
+  }
+
+  /**
+   * Reads an signed Exp-Golomb-coded format integer.
+   *
+   * @return The value of the parsed Exp-Golomb-coded integer.
+   */
+  public int readSignedExpGolombCodedInt() {
+    int codeNum = readExpGolombCodeNum();
+    return ((codeNum % 2) == 0 ? -1 : 1) * ((codeNum + 1) / 2);
+  }
+
+  private int readUnsignedByte() {
+    int value;
+    if (bitOffset != 0) {
+      value = ((data[byteOffset] & 0xFF) << bitOffset)
+          | ((data[byteOffset + 1] & 0xFF) >>> (8 - bitOffset));
+    } else {
+      value = data[byteOffset];
+    }
+    byteOffset++;
+    return value & 0xFF;
+  }
+
+  private int getUnsignedByte(int offset) {
+    return data[offset] & 0xFF;
+  }
+
+  private int readExpGolombCodeNum() {
+    int leadingZeros = 0;
+    while (!readBit()) {
+      leadingZeros++;
+    }
+    return (1 << leadingZeros) - 1 + (leadingZeros > 0 ? readBits(leadingZeros) : 0);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
new file mode 100644
index 0000000000..72b2552722
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Wraps a byte array, providing a set of methods for parsing data from it. Numerical values are
+ * parsed with the assumption that their constituent bytes are in big endian order.
+ */
+public final class ParsableByteArray {
+
+  public byte[] data;
+
+  private int position;
+  private int limit;
+
+  /** Creates a new instance that initially has no backing data. */
+  public ParsableByteArray() {}
+
+  /** Creates a new instance with {@code length} bytes. */
+  public ParsableByteArray(int length) {
+    this.data = new byte[length];
+    limit = data.length;
+  }
+
+  /**
+   * Creates a new instance that wraps an existing array.
+   *
+   * @param data The data to wrap.
+   * @param limit The limit.
+   */
+  public ParsableByteArray(byte[] data, int limit) {
+    this.data = data;
+    this.limit = limit;
+  }
+
+  /**
+   * Updates the instance to wrap {@code data}, and resets the position to zero.
+   *
+   * @param data The array to wrap.
+   * @param limit The limit.
+   */
+  public void reset(byte[] data, int limit) {
+    this.data = data;
+    this.limit = limit;
+    position = 0;
+  }
+
+  /**
+   * Sets the position and limit to zero.
+   */
+  public void reset() {
+    position = 0;
+    limit = 0;
+  }
+
+  /** Returns the number of bytes yet to be read. */
+  public int bytesLeft() {
+    return limit - position;
+  }
+
+  /** Returns the limit. */
+  public int limit() {
+    return limit;
+  }
+
+  /**
+   * Sets the limit.
+   *
+   * @param limit The limit to set.
+   */
+  public void setLimit(int limit) {
+    Assertions.checkArgument(limit >= 0 && limit <= data.length);
+    this.limit = limit;
+  }
+
+  /** Returns the current offset in the array, in bytes. */
+  public int getPosition() {
+    return position;
+  }
+
+  /** Returns the capacity of the array, which may be larger than the limit. */
+  public int capacity() {
+    return data == null ? 0 : data.length;
+  }
+
+  /**
+   * Sets the reading offset in the array.
+   *
+   * @param position Byte offset in the array from which to read.
+   * @throws IllegalArgumentException Thrown if the new position is neither in nor at the end of the
+   *     array.
+   */
+  public void setPosition(int position) {
+    // It is fine for position to be at the end of the array.
+    Assertions.checkArgument(position >= 0 && position <= limit);
+    this.position = position;
+  }
+
+  /**
+   * Moves the reading offset by {@code bytes}.
+   *
+   * @throws IllegalArgumentException Thrown if the new position is neither in nor at the end of the
+   *     array.
+   */
+  // TODO: Rename to skipBytes so that it's clearer how much data is being skipped in code where
+  // both ParsableBitArray and ParsableByteArray are in use.
+  public void skip(int bytes) {
+    setPosition(position + bytes);
+  }
+
+  /**
+   * Reads the next {@code length} bytes into {@code bitArray}, and resets the position of
+   * {@code bitArray} to zero.
+   *
+   * @param bitArray The {@link ParsableBitArray} into which the bytes should be read.
+   * @param length The number of bytes to write.
+   */
+  // TODO: It's possible to have bitArray directly index into the same array as is being wrapped
+  // by this instance. Decide whether it's worth doing this.
+  public void readBytes(ParsableBitArray bitArray, int length) {
+    readBytes(bitArray.getData(), 0, length);
+    bitArray.setPosition(0);
+  }
+
+  /**
+   * Reads the next {@code length} bytes into {@code buffer} at {@code offset}.
+   *
+   * @see System#arraycopy
+   */
+  public void readBytes(byte[] buffer, int offset, int length) {
+    System.arraycopy(data, position, buffer, offset, length);
+    position += length;
+  }
+
+  /**
+   * Reads the next {@code length} bytes into {@code buffer}.
+   *
+   * @see ByteBuffer#put(byte[], int, int)
+   */
+  public void readBytes(ByteBuffer buffer, int length) {
+    buffer.put(data, position, length);
+    position += length;
+  }
+
+  /** Reads the next byte as an unsigned value. */
+  public int readUnsignedByte() {
+    int result = shiftIntoInt(data, position, 1);
+    position += 1;
+    return result;
+  }
+
+  /** Reads the next two bytes as an unsigned value. */
+  public int readUnsignedShort() {
+    int result = shiftIntoInt(data, position, 2);
+    position += 2;
+    return result;
+  }
+
+  /** Reads the next four bytes as an unsigned value. */
+  public long readUnsignedInt() {
+    long result = shiftIntoLong(data, position, 4);
+    position += 4;
+    return result;
+  }
+
+  /** Reads the next four bytes as a signed value. */
+  public int readInt() {
+    int result = shiftIntoInt(data, position, 4);
+    position += 4;
+    return result;
+  }
+
+  /** Reads the next eight bytes as a signed value. */
+  public long readLong() {
+    long result = shiftIntoLong(data, position, 8);
+    position += 8;
+    return result;
+  }
+
+  /** Reads the next four bytes, returning the integer portion of the fixed point 16.16 integer. */
+  public int readUnsignedFixedPoint1616() {
+    int result = shiftIntoInt(data, position, 2);
+    position += 4;
+    return result;
+  }
+
+  /**
+   * Reads a Synchsafe integer.
+   * <p>
+   * Synchsafe integers keep the highest bit of every byte zeroed. A 32 bit synchsafe integer can
+   * store 28 bits of information.
+   *
+   * @return The parsed value.
+   */
+  public int readSynchSafeInt() {
+    int b1 = readUnsignedByte();
+    int b2 = readUnsignedByte();
+    int b3 = readUnsignedByte();
+    int b4 = readUnsignedByte();
+    return (b1 << 21) | (b2 << 14) | (b3 << 7) | b4;
+  }
+
+  /**
+   * Reads the next four bytes as an unsigned integer into an integer, if the top bit is a zero.
+   *
+   * @throws IllegalArgumentException Thrown if the top bit of the input data is set.
+   */
+  public int readUnsignedIntToInt() {
+    int result = shiftIntoInt(data, position, 4);
+    position += 4;
+    if (result < 0) {
+      throw new IllegalArgumentException("Top bit not zero: " + result);
+    }
+    return result;
+  }
+
+  /**
+   * Reads the next eight bytes as an unsigned long into a long, if the top bit is a zero.
+   *
+   * @throws IllegalArgumentException Thrown if the top bit of the input data is set.
+   */
+  public long readUnsignedLongToLong() {
+    long result = shiftIntoLong(data, position, 8);
+    position += 8;
+    if (result < 0) {
+      throw new IllegalArgumentException("Top bit not zero: " + result);
+    }
+    return result;
+  }
+
+  /** Reads {@code length} bytes into an int at {@code offset} in {@code bytes}. */
+  private static int shiftIntoInt(byte[] bytes, int offset, int length) {
+    int result = 0xFF & bytes[offset];
+    for (int i = offset + 1; i < offset + length; i++) {
+      result <<= 8;
+      result |= 0xFF & bytes[i];
+    }
+    return result;
+  }
+
+  /** Reads {@code length} bytes into a long at {@code offset} in {@code bytes}. */
+  private static long shiftIntoLong(byte[] bytes, int offset, int length) {
+    long result = 0xFF & bytes[offset];
+    for (int i = offset + 1; i < offset + length; i++) {
+      result <<= 8;
+      result |= 0xFF & bytes[i];
+    }
+    return result;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 4d51fda9b0..7e096cfa1b 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -317,8 +317,8 @@ public static long parseXsDateTime(String value) throws ParseException {
     } else if (matcher.group(9).equalsIgnoreCase("Z")) {
       timezoneShift = 0;
     } else {
-      timezoneShift = ((Integer.valueOf(matcher.group(12)) * 60
-          + Integer.valueOf(matcher.group(13))));
+      timezoneShift = ((Integer.parseInt(matcher.group(12)) * 60
+          + Integer.parseInt(matcher.group(13))));
       if (matcher.group(11).equals("-")) {
         timezoneShift *= -1;
       }
@@ -328,12 +328,12 @@ public static long parseXsDateTime(String value) throws ParseException {
 
     dateTime.clear();
     // Note: The month value is 0-based, hence the -1 on group(2)
-    dateTime.set(Integer.valueOf(matcher.group(1)),
-                 Integer.valueOf(matcher.group(2)) - 1,
-                 Integer.valueOf(matcher.group(3)),
-                 Integer.valueOf(matcher.group(4)),
-                 Integer.valueOf(matcher.group(5)),
-                 Integer.valueOf(matcher.group(6)));
+    dateTime.set(Integer.parseInt(matcher.group(1)),
+                 Integer.parseInt(matcher.group(2)) - 1,
+                 Integer.parseInt(matcher.group(3)),
+                 Integer.parseInt(matcher.group(4)),
+                 Integer.parseInt(matcher.group(5)),
+                 Integer.parseInt(matcher.group(6)));
     if (!TextUtils.isEmpty(matcher.group(8))) {
       final BigDecimal bd = new BigDecimal("0." + matcher.group(8));
       // we care only for milliseconds, so movePointRight(3)
@@ -401,6 +401,32 @@ public static long scaleLargeTimestamp(long timestamp, long multiplier, long div
     return scaledTimestamps;
   }
 
+  /**
+   * Applies {@link #scaleLargeTimestamp(long, long, long)} to an array of unscaled timestamps.
+   *
+   * @param timestamps The timestamps to scale.
+   * @param multiplier The multiplier.
+   * @param divisor The divisor.
+   */
+  public static void scaleLargeTimestampsInPlace(long[] timestamps, long multiplier, long divisor) {
+    if (divisor >= multiplier && (divisor % multiplier) == 0) {
+      long divisionFactor = divisor / multiplier;
+      for (int i = 0; i < timestamps.length; i++) {
+        timestamps[i] /= divisionFactor;
+      }
+    } else if (divisor < multiplier && (multiplier % divisor) == 0) {
+      long multiplicationFactor = multiplier / divisor;
+      for (int i = 0; i < timestamps.length; i++) {
+        timestamps[i] *= multiplicationFactor;
+      }
+    } else {
+      double multiplicationFactor = (double) multiplier / divisor;
+      for (int i = 0; i < timestamps.length; i++) {
+        timestamps[i] = (long) (timestamps[i] * multiplicationFactor);
+      }
+    }
+  }
+
   /**
    * Converts a list of integers to a primitive array.
    *
