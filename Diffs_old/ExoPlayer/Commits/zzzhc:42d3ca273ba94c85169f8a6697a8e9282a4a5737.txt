diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 3c1748ea9d..9dd79d8c42 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -29,6 +29,8 @@
   the `Player` set later using `AnalyticsCollector.setPlayer`.
 * Calculate correct duration for clipped WAV streams
   ([#6241](https://github.com/google/ExoPlayer/issues/6241)).
+* Fix Flac and ALAC playback on some LG devices
+  ([#5938](https://github.com/google/ExoPlayer/issues/5938)).
 
 ### 2.10.4 ###
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index b965f4ef68..6a29f316e1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -392,7 +392,7 @@ protected void configureCodec(
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
     codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);
     passthroughEnabled = codecInfo.passthrough;
-    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
+    String codecMimeType = passthroughEnabled ? MimeTypes.AUDIO_RAW : codecInfo.codecMimeType;
     MediaFormat mediaFormat =
         getMediaFormat(format, codecMimeType, codecMaxInputSize, codecOperatingRate);
     codec.configure(mediaFormat, /* surface= */ null, crypto, /* flags= */ 0);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index acaf798b41..d07def1894 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -53,6 +53,13 @@
   /** The MIME type handled by the codec, or {@code null} if this is a passthrough codec. */
   @Nullable public final String mimeType;
 
+  /**
+   * The MIME type that the codec uses for media of type {@link #mimeType}, or {@code null} if this
+   * is a passthrough codec. Equal to {@link #mimeType} unless the codec is known to use a
+   * non-standard MIME type alias.
+   */
+  @Nullable public final String codecMimeType;
+
   /**
    * The capabilities of the decoder, like the profiles/levels it supports, or {@code null} if not
    * known.
@@ -98,6 +105,7 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
     return new MediaCodecInfo(
         name,
         /* mimeType= */ null,
+        /* codecMimeType= */ null,
         /* capabilities= */ null,
         /* passthrough= */ true,
         /* forceDisableAdaptive= */ false,
@@ -109,26 +117,8 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
    *
    * @param name The name of the {@link MediaCodec}.
    * @param mimeType A mime type supported by the {@link MediaCodec}.
-   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type, or
-   *     {@code null} if not known.
-   * @return The created instance.
-   */
-  public static MediaCodecInfo newInstance(
-      String name, String mimeType, @Nullable CodecCapabilities capabilities) {
-    return new MediaCodecInfo(
-        name,
-        mimeType,
-        capabilities,
-        /* passthrough= */ false,
-        /* forceDisableAdaptive= */ false,
-        /* forceSecure= */ false);
-  }
-
-  /**
-   * Creates an instance.
-   *
-   * @param name The name of the {@link MediaCodec}.
-   * @param mimeType A mime type supported by the {@link MediaCodec}.
+   * @param codecMimeType The MIME type that the codec uses for media of type {@code #mimeType}.
+   *     Equal to {@code mimeType} unless the codec is known to use a non-standard MIME type alias.
    * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type, or
    *     {@code null} if not known.
    * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
@@ -138,22 +128,31 @@ public static MediaCodecInfo newInstance(
   public static MediaCodecInfo newInstance(
       String name,
       String mimeType,
+      String codecMimeType,
       @Nullable CodecCapabilities capabilities,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     return new MediaCodecInfo(
-        name, mimeType, capabilities, /* passthrough= */ false, forceDisableAdaptive, forceSecure);
+        name,
+        mimeType,
+        codecMimeType,
+        capabilities,
+        /* passthrough= */ false,
+        forceDisableAdaptive,
+        forceSecure);
   }
 
   private MediaCodecInfo(
       String name,
       @Nullable String mimeType,
+      @Nullable String codecMimeType,
       @Nullable CodecCapabilities capabilities,
       boolean passthrough,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     this.name = Assertions.checkNotNull(name);
     this.mimeType = mimeType;
+    this.codecMimeType = codecMimeType;
     this.capabilities = capabilities;
     this.passthrough = passthrough;
     adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 46bc448a4a..cd4c4863ff 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -171,12 +171,12 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boo
         Util.SDK_INT >= 21
             ? new MediaCodecListCompatV21(secure, tunneling)
             : new MediaCodecListCompatV16();
-    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
+    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
       mediaCodecList = new MediaCodecListCompatV16();
-      decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
+      decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
       if (!decoderInfos.isEmpty()) {
         Log.w(TAG, "MediaCodecList API didn't list secure decoder for: " + mimeType
             + ". Assuming: " + decoderInfos.get(0).name);
@@ -268,18 +268,16 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
   // Internal methods.
 
   /**
-   * Returns {@link MediaCodecInfo}s for the given codec {@code key} in the order given by
+   * Returns {@link MediaCodecInfo}s for the given codec {@link CodecKey} in the order given by
    * {@code mediaCodecList}.
    *
    * @param key The codec key.
    * @param mediaCodecList The codec list.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
    * @return The codec information for usable codecs matching the specified key.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  private static ArrayList<MediaCodecInfo> getDecoderInfosInternal(CodecKey key,
-      MediaCodecListCompat mediaCodecList, String requestedMimeType) throws DecoderQueryException {
+  private static ArrayList<MediaCodecInfo> getDecoderInfosInternal(
+      CodecKey key, MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
     try {
       ArrayList<MediaCodecInfo> decoderInfos = new ArrayList<>();
       String mimeType = key.mimeType;
@@ -289,28 +287,27 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       for (int i = 0; i < numberOfCodecs; i++) {
         android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
         String name = codecInfo.getName();
-        String supportedType =
-            getCodecSupportedType(codecInfo, name, secureDecodersExplicit, requestedMimeType);
-        if (supportedType == null) {
+        String codecMimeType = getCodecMimeType(codecInfo, name, secureDecodersExplicit, mimeType);
+        if (codecMimeType == null) {
           continue;
         }
         try {
-          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+          CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(codecMimeType);
           boolean tunnelingSupported =
               mediaCodecList.isFeatureSupported(
-                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);
           boolean tunnelingRequired =
               mediaCodecList.isFeatureRequired(
-                  CodecCapabilities.FEATURE_TunneledPlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);
           if ((!key.tunneling && tunnelingRequired) || (key.tunneling && !tunnelingSupported)) {
             continue;
           }
           boolean secureSupported =
               mediaCodecList.isFeatureSupported(
-                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);
           boolean secureRequired =
               mediaCodecList.isFeatureRequired(
-                  CodecCapabilities.FEATURE_SecurePlayback, supportedType, capabilities);
+                  CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);
           if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {
             continue;
           }
@@ -319,12 +316,18 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
               || (!secureDecodersExplicit && !key.secure)) {
             decoderInfos.add(
                 MediaCodecInfo.newInstance(
-                    name, mimeType, capabilities, forceDisableAdaptive, /* forceSecure= */ false));
+                    name,
+                    mimeType,
+                    codecMimeType,
+                    capabilities,
+                    forceDisableAdaptive,
+                    /* forceSecure= */ false));
           } else if (!secureDecodersExplicit && secureSupported) {
             decoderInfos.add(
                 MediaCodecInfo.newInstance(
                     name + ".secure",
                     mimeType,
+                    codecMimeType,
                     capabilities,
                     forceDisableAdaptive,
                     /* forceSecure= */ true));
@@ -338,7 +341,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
           } else {
             // Rethrow error querying primary codec capabilities, or secondary codec
             // capabilities if API level is greater than 23.
-            Log.e(TAG, "Failed to query codec " + name + " (" + supportedType + ")");
+            Log.e(TAG, "Failed to query codec " + name + " (" + codecMimeType + ")");
             throw e;
           }
         }
@@ -352,48 +355,49 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
   }
 
   /**
-   * Returns the codec's supported type for decoding {@code requestedMimeType} on the current
-   * device, or {@code null} if the codec can't be used.
+   * Returns the codec's supported MIME type for media of type {@code mimeType}, or {@code null} if
+   * the codec can't be used.
    *
    * @param info The codec information.
    * @param name The name of the codec
    * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
-   * @return The codec's supported type for decoding {@code requestedMimeType}, or {@code null} if
-   *     the codec can't be used.
+   * @param mimeType The MIME type.
+   * @return The codec's supported MIME type for media of type {@code mimeType}, or {@code null} if
+   *     the codec can't be used. If non-null, the returned type will be equal to {@code mimeType}
+   *     except in cases where the codec is known to use a non-standard MIME type alias.
    */
   @Nullable
-  private static String getCodecSupportedType(
+  private static String getCodecMimeType(
       android.media.MediaCodecInfo info,
       String name,
       boolean secureDecodersExplicit,
-      String requestedMimeType) {
-    if (isCodecUsableDecoder(info, name, secureDecodersExplicit, requestedMimeType)) {
-      String[] supportedTypes = info.getSupportedTypes();
-      for (String supportedType : supportedTypes) {
-        if (supportedType.equalsIgnoreCase(requestedMimeType)) {
-          return supportedType;
-        }
+      String mimeType) {
+    if (!isCodecUsableDecoder(info, name, secureDecodersExplicit, mimeType)) {
+      return null;
+    }
+
+    String[] supportedTypes = info.getSupportedTypes();
+    for (String supportedType : supportedTypes) {
+      if (supportedType.equalsIgnoreCase(mimeType)) {
+        return supportedType;
       }
+    }
 
-      if (requestedMimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
-        // Handle decoders that declare support for DV via MIME types that aren't
-        // video/dolby-vision.
-        if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
-          return "video/hevcdv";
-        } else if ("OMX.RTK.video.decoder".equals(name)
-            || "OMX.realtek.video.decoder.tunneled".equals(name)) {
-          return "video/dv_hevc";
-        }
-      } else if (requestedMimeType.equals(MimeTypes.AUDIO_ALAC)
-          && "OMX.lge.alac.decoder".equals(name)) {
-        return "audio/x-lg-alac";
-      } else if (requestedMimeType.equals(MimeTypes.AUDIO_FLAC)
-          && "OMX.lge.flac.decoder".equals(name)) {
-        return "audio/x-lg-flac";
+    if (mimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {
+      // Handle decoders that declare support for DV via MIME types that aren't
+      // video/dolby-vision.
+      if ("OMX.MS.HEVCDV.Decoder".equals(name)) {
+        return "video/hevcdv";
+      } else if ("OMX.RTK.video.decoder".equals(name)
+          || "OMX.realtek.video.decoder.tunneled".equals(name)) {
+        return "video/dv_hevc";
       }
+    } else if (mimeType.equals(MimeTypes.AUDIO_ALAC) && "OMX.lge.alac.decoder".equals(name)) {
+      return "audio/x-lg-alac";
+    } else if (mimeType.equals(MimeTypes.AUDIO_FLAC) && "OMX.lge.flac.decoder".equals(name)) {
+      return "audio/x-lg-flac";
     }
+
     return null;
   }
 
@@ -403,12 +407,14 @@ private static String getCodecSupportedType(
    * @param info The codec information.
    * @param name The name of the codec
    * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
-   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
-   *     key MIME type if the codec key is being considered as a fallback.
+   * @param mimeType The MIME type.
    * @return Whether the specified codec is usable for decoding on the current device.
    */
-  private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, String name,
-      boolean secureDecodersExplicit, String requestedMimeType) {
+  private static boolean isCodecUsableDecoder(
+      android.media.MediaCodecInfo info,
+      String name,
+      boolean secureDecodersExplicit,
+      String mimeType) {
     if (info.isEncoder() || (!secureDecodersExplicit && name.endsWith(".secure"))) {
       return false;
     }
@@ -497,8 +503,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     }
 
     // MTK E-AC3 decoder doesn't support decoding JOC streams in 2-D. See [Internal: b/69400041].
-    if (MimeTypes.AUDIO_E_AC3_JOC.equals(requestedMimeType)
-        && "OMX.MTK.AUDIO.DECODER.DSPAC3".equals(name)) {
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType) && "OMX.MTK.AUDIO.DECODER.DSPAC3".equals(name)) {
       return false;
     }
 
@@ -522,7 +527,12 @@ private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decod
         // name. See <a href="https://github.com/google/ExoPlayer/issues/5782">Issue #5782</a>.
         decoderInfos.add(
             MediaCodecInfo.newInstance(
-                "OMX.google.raw.decoder", MimeTypes.AUDIO_RAW, /* capabilities= */ null));
+                /* name= */ "OMX.google.raw.decoder",
+                /* mimeType= */ MimeTypes.AUDIO_RAW,
+                /* codecMimeType= */ MimeTypes.AUDIO_RAW,
+                /* capabilities= */ null,
+                /* forceDisableAdaptive= */ false,
+                /* forceSecure= */ false));
       }
       // Work around inconsistent raw audio decoding behavior across different devices.
       sortByScore(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 24524d057d..2ab7e61378 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -603,10 +603,12 @@ protected void configureCodec(
       Format format,
       MediaCrypto crypto,
       float codecOperatingRate) {
+    String codecMimeType = codecInfo.codecMimeType;
     codecMaxValues = getCodecMaxValues(codecInfo, format, getStreamFormats());
     MediaFormat mediaFormat =
         getMediaFormat(
             format,
+            codecMimeType,
             codecMaxValues,
             codecOperatingRate,
             deviceNeedsNoPostProcessWorkaround,
@@ -1164,6 +1166,7 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
    * Returns the framework {@link MediaFormat} that should be used to configure the decoder.
    *
    * @param format The format of media.
+   * @param codecMimeType The MIME type handled by the codec.
    * @param codecMaxValues Codec max values that should be used when configuring the decoder.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
@@ -1176,13 +1179,14 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
   @SuppressLint("InlinedApi")
   protected MediaFormat getMediaFormat(
       Format format,
+      String codecMimeType,
       CodecMaxValues codecMaxValues,
       float codecOperatingRate,
       boolean deviceNeedsNoPostProcessWorkaround,
       int tunnelingAudioSessionId) {
     MediaFormat mediaFormat = new MediaFormat();
     // Set format parameters that should always be set.
-    mediaFormat.setString(MediaFormat.KEY_MIME, format.sampleMimeType);
+    mediaFormat.setString(MediaFormat.KEY_MIME, codecMimeType);
     mediaFormat.setInteger(MediaFormat.KEY_WIDTH, format.width);
     mediaFormat.setInteger(MediaFormat.KEY_HEIGHT, format.height);
     MediaFormatUtil.setCsdBuffers(mediaFormat, format.initializationData);
