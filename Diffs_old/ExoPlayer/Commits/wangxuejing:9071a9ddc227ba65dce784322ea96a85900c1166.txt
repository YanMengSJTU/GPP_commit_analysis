diff --git a/demos/ima/src/main/AndroidManifest.xml b/demos/ima/src/main/AndroidManifest.xml
index 50ad0c1b54..2e4c3cab02 100644
--- a/demos/ima/src/main/AndroidManifest.xml
+++ b/demos/ima/src/main/AndroidManifest.xml
@@ -17,6 +17,7 @@
     package="com.google.android.exoplayer2.imademo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
   <uses-sdk/>
 
   <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
index 4fab1966fe..67d9bc7c47 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -17,6 +17,8 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.os.Environment;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.ExoPlayer;
@@ -79,22 +81,23 @@ public void init(Context context, PlayerView playerView) {
     playerView.setPlayer(player);
 
     // This is the MediaSource representing the content media (i.e. not the ad).
-    String contentUrl = context.getString(R.string.content_url);
+//    String contentUrl =Environment.getExternalStorageDirectory().getAbsolutePath() + "/Movies/Sync-One2-Test-1080p-24-H_264_V.mp4";
+    String contentUrl =Environment.getExternalStorageDirectory().getAbsolutePath() + "/Movies/Momo.mp3";
     MediaSource contentMediaSource = buildMediaSource(Uri.parse(contentUrl));
 
     // Compose the content media source into a new AdsMediaSource with both ads and content.
-    MediaSource mediaSourceWithAds =
-        new AdsMediaSource(
-            contentMediaSource,
-            /* adMediaSourceFactory= */ this,
-            adsLoader,
-            playerView.getOverlayFrameLayout(),
-            /* eventHandler= */ null,
-            /* eventListener= */ null);
+//    MediaSource mediaSourceWithAds =
+//        new AdsMediaSource(
+//            contentMediaSource,
+//            /* adMediaSourceFactory= */ this,
+//            adsLoader,
+//            playerView.getOverlayFrameLayout(),
+//            /* eventHandler= */ null,
+//            /* eventListener= */ null);
 
     // Prepare the player with the source.
     player.seekTo(contentPosition);
-    player.prepare(mediaSourceWithAds);
+    player.prepare(contentMediaSource);
     player.setPlayWhenReady(true);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index f8b7f5f5c2..c4cbde2f0c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -31,23 +31,27 @@
   /**
    * The default minimum duration of media that the player will attempt to ensure is buffered at all
    * times, in milliseconds.
+   * 默认的最小缓冲大小时长
    */
   public static final int DEFAULT_MIN_BUFFER_MS = 15000;
 
   /**
    * The default maximum duration of media that the player will attempt to buffer, in milliseconds.
+   * 默认最大缓冲时长
    */
   public static final int DEFAULT_MAX_BUFFER_MS = 50000;
 
   /**
    * The default duration of media that must be buffered for playback to start or resume following a
    * user action such as a seek, in milliseconds.
+   * 用户操作后的默认必备缓冲时长（比如用户做了一个seek操作）
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_MS = 2500;
 
   /**
    * The default duration of media that must be buffered for playback to resume after a rebuffer, in
    * milliseconds. A rebuffer is defined to be caused by buffer depletion rather than a user action.
+   * 默认必备缓冲时长（缓冲区消耗光）
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS = 5000;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
index ed57cec70c..deb05eca52 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2;
 
 import android.support.annotation.Nullable;
+import android.util.Log;
+
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.StandaloneMediaClock;
@@ -121,7 +123,7 @@ public void onRendererDisabled(Renderer renderer) {
    * Syncs internal clock if needed and returns current clock position in microseconds.
    */
   public long syncAndGetPositionUs() {
-    if (isUsingRendererClock()) {
+    if (isUsingRendererClock()) {//判断是否有渲染时钟
       ensureSynced();
       return rendererClock.getPositionUs();
     } else {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index a7d569081e..2ae790719d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -82,21 +82,21 @@
   private static final int RENDERING_INTERVAL_MS = 10;
   private static final int IDLE_INTERVAL_MS = 1000;
 
-  private final Renderer[] renderers;
-  private final RendererCapabilities[] rendererCapabilities;
-  private final TrackSelector trackSelector;
-  private final TrackSelectorResult emptyTrackSelectorResult;
-  private final LoadControl loadControl;
+  private final Renderer[] renderers;//渲染器
+  private final RendererCapabilities[] rendererCapabilities;//渲染器能力
+  private final TrackSelector trackSelector;//轨道选择器
+  private final TrackSelectorResult emptyTrackSelectorResult;//轨道选择结果
+  private final LoadControl loadControl;//加载控制器
   private final HandlerWrapper handler;
   private final HandlerThread internalPlaybackThread;
-  private final Handler eventHandler;
-  private final ExoPlayer player;
-  private final Timeline.Window window;
-  private final Timeline.Period period;
-  private final long backBufferDurationUs;
-  private final boolean retainBackBufferFromKeyframe;
-  private final DefaultMediaClock mediaClock;
-  private final PlaybackInfoUpdate playbackInfoUpdate;
+  private final Handler eventHandler;//事件处理器，looper通常是主线程
+  private final ExoPlayer player;//播放器接口
+  private final Timeline.Window window;//窗口
+  private final Timeline.Period period;//片段
+  private final long backBufferDurationUs;//相对于当前播放位置的可快退长度
+  private final boolean retainBackBufferFromKeyframe;//
+  private final DefaultMediaClock mediaClock;//默认媒体时钟
+  private final PlaybackInfoUpdate playbackInfoUpdate;//
   private final ArrayList<PendingMessageInfo> pendingMessages;
   private final Clock clock;
   private final MediaPeriodQueue queue;
@@ -113,9 +113,9 @@
   @Player.RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
 
-  private int pendingPrepareCount;
-  private SeekPosition pendingInitialSeekPosition;
-  private long rendererPositionUs;
+  private int pendingPrepareCount;//需要准备的次数，就是prepare被要求的次数
+  private SeekPosition pendingInitialSeekPosition;//初始seek位置
+  private long rendererPositionUs;//當前需要被渲染的时间点（单位us）
   private int nextPendingMessageIndex;
 
   public ExoPlayerImplInternal(
@@ -298,7 +298,7 @@ public boolean handleMessage(Message msg) {
           setShuffleModeEnabledInternal(msg.arg1 != 0);
           break;
         case MSG_DO_SOME_WORK:
-          doSomeWork();
+          doSomeWork();//循环做一些工作，这些工作包括：时间同步，通知渲染器渲染
           break;
         case MSG_SEEK_TO:
           seekToInternal((SeekPosition) msg.obj);
@@ -467,7 +467,7 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
     // Update the playback position.
     MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
     long periodPositionUs = playingPeriodHolder.mediaPeriod.readDiscontinuity();
-    if (periodPositionUs != C.TIME_UNSET) {
+    if (periodPositionUs != C.TIME_UNSET) {//如果时间没设置
       resetRendererPosition(periodPositionUs);
       // A MediaPeriod may report a discontinuity at the current playback position to ensure the
       // renderers are flushed. Only report the discontinuity externally if the position changed.
@@ -477,7 +477,7 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
     } else {
-      rendererPositionUs = mediaClock.syncAndGetPositionUs();
+      rendererPositionUs = mediaClock.syncAndGetPositionUs();//同步并且获取时间
       periodPositionUs = playingPeriodHolder.toPeriodTime(rendererPositionUs);
       maybeTriggerPendingMessages(playbackInfo.positionUs, periodPositionUs);
       playbackInfo.positionUs = periodPositionUs;
@@ -493,7 +493,7 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
   private void doSomeWork() throws ExoPlaybackException, IOException {
     long operationStartTimeMs = clock.uptimeMillis();
     updatePeriods();
-    if (!queue.hasPlayingPeriod()) {
+    if (!queue.hasPlayingPeriod()) {//若还没有准备好Period
       // We're still waiting for the first period to be prepared.
       maybeThrowPeriodPrepareError();
       scheduleNextWork(operationStartTimeMs, PREPARING_SOURCE_INTERVAL_MS);
@@ -571,7 +571,9 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
   }
 
   private void scheduleNextWork(long thisOperationStartTimeMs, long intervalMs) {
+    //移除所有MSG_DO_SOME_WORK操作
     handler.removeMessages(MSG_DO_SOME_WORK);
+    //发送一个指定时间执行的MSG_DO_SOME_WORK操作，时间指定为这个操作开始加上时间间隔
     handler.sendEmptyMessageAtTime(MSG_DO_SOME_WORK, thisOperationStartTimeMs + intervalMs);
   }
 
@@ -759,13 +761,13 @@ private int getFirstPeriodIndex() {
 
   private void resetInternal(
       boolean releaseMediaSource, boolean resetPosition, boolean resetState) {
-    handler.removeMessages(MSG_DO_SOME_WORK);
+    handler.removeMessages(MSG_DO_SOME_WORK);//如果要重置，应当先移除正在工作的事情
     rebuffering = false;
     mediaClock.stop();
     rendererPositionUs = 0;
     for (Renderer renderer : enabledRenderers) {
       try {
-        disableRenderer(renderer);
+        disableRenderer(renderer);//让每个渲染器暂时停止工作
       } catch (ExoPlaybackException | RuntimeException e) {
         // There's nothing we can do.
         Log.e(TAG, "Stop failed.", e);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java
index 80be0b9e71..fd590c4d31 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java
@@ -27,12 +27,15 @@
 
   /**
    * Called by the player when prepared with a new source.
+   * 由播放器在一个新的视频源准备好时调用
    */
   void onPrepared();
 
   /**
    * Called by the player when a track selection occurs.
    *
+   * 由播放器在完成轨道选择时候调用
+   *
    * @param renderers The renderers.
    * @param trackGroups The {@link TrackGroup}s from which the selection was made.
    * @param trackSelections The track selections that were made.
@@ -52,6 +55,7 @@ void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
 
   /**
    * Returns the {@link Allocator} that should be used to obtain media buffer allocations.
+   * 返回一个可以用来获取媒体缓存的对象
    */
   Allocator getAllocator();
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
index 47120e7375..9c3b0da1d9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
@@ -20,6 +20,8 @@
 import android.media.AudioTrack;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Retention;
@@ -41,7 +43,21 @@
  * time since it was sampled. Otherwise, it may be stationary.
  *
  * <p>Call {@link #reset()} when pausing or resuming the track.
+
+ * 获取音轨时间戳，如果平台支持（sdk>19）。
+ *
+ * 获取时间戳前，最好调用{@link #maybePollTimestamp(long)}，更新时间戳，然后在获取帧时间和系统时间
+ *
+ * 最后调用接收时间戳或者拒绝时间戳的更新。
+ *
+ *  调用{@link #hasTimestamp()}可以获取是否支持能够获取时间戳。
+ *
+ *  调用{@link #getTimestampSystemTimeUs()}可以获取最新采样的系统时间戳
+ *
+ *  调用{@link #getTimestampPositionFrames()}可以获取最新帧时间戳
+ *
  */
+
 /* package */ final class AudioTimestampPoller {
 
   /** Timestamp polling states. */
@@ -114,6 +130,7 @@ public AudioTimestampPoller(AudioTrack audioTrack) {
    * @return Whether the timestamp was updated.
    */
   public boolean maybePollTimestamp(long systemTimeUs) {
+    //没有时间戳或者在播放时十秒才更新一次，有时间戳或者刚初始化完成的话5000us就更新一次
     if (audioTimestamp == null || (systemTimeUs - lastTimestampSampleTimeUs) < sampleIntervalUs) {
       return false;
     }
@@ -203,6 +220,7 @@ public boolean hasTimestamp() {
    * current position for the track can be extrapolated based on elapsed real time since the system
    * time at which the timestamp was sampled.
    */
+  //当前时间戳是否处于增长状态
   public boolean isTimestampAdvancing() {
     return state == STATE_TIMESTAMP_ADVANCING;
   }
@@ -218,7 +236,7 @@ public void reset() {
    * If {@link #maybePollTimestamp(long)} or {@link #hasTimestamp()} returned {@code true}, returns
    * the system time at which the latest timestamp was sampled, in microseconds.
    */
-  public long getTimestampSystemTimeUs() {
+  public long getTimestampSystemTimeUs() {//最新采样的时间戳
     return audioTimestamp != null ? audioTimestamp.getTimestampSystemTimeUs() : C.TIME_UNSET;
   }
 
@@ -226,7 +244,7 @@ public long getTimestampSystemTimeUs() {
    * If {@link #maybePollTimestamp(long)} or {@link #hasTimestamp()} returned {@code true}, returns
    * the latest timestamp's position in frames.
    */
-  public long getTimestampPositionFrames() {
+  public long getTimestampPositionFrames() {//最新音频帧的时间戳
     return audioTimestamp != null ? audioTimestamp.getTimestampPositionFrames() : C.POSITION_UNSET;
   }
 
@@ -284,7 +302,7 @@ public AudioTimestampV19(AudioTrack audioTrack) {
     public boolean maybeUpdateTimestamp() {
       boolean updated = audioTrack.getTimestamp(audioTimestamp);
       if (updated) {
-        long rawPositionFrames = audioTimestamp.framePosition;
+        long rawPositionFrames = audioTimestamp.framePosition;//相对于假定音频流开始的帧中的位置
         if (lastTimestampRawPositionFrames > rawPositionFrames) {
           // The value must have wrapped around.
           rawTimestampFramePositionWrapCount++;
@@ -296,8 +314,8 @@ public boolean maybeUpdateTimestamp() {
       return updated;
     }
 
-    public long getTimestampSystemTimeUs() {
-      return audioTimestamp.nanoTime / 1000;
+    public long getTimestampSystemTimeUs() {//十秒一次才有效
+      return audioTimestamp.nanoTime / 1000;//与音频管道中的帧关联的时间
     }
 
     public long getTimestampPositionFrames() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
index 4714db8902..641ac5c10c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
@@ -19,6 +19,8 @@
 import android.media.AudioTrack;
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -206,35 +208,38 @@ public void setAudioTrack(
 
   public long getCurrentPositionUs(boolean sourceEnded) {
     if (audioTrack.getPlayState() == PLAYSTATE_PLAYING) {
-      maybeSampleSyncParams();
+      maybeSampleSyncParams();//播放的时候可能需要同步一下时间和参数
     }
 
     // If the device supports it, use the playback timestamp from AudioTrack.getTimestamp.
     // Otherwise, derive a smoothed position by sampling the track's frame position.
     long systemTimeUs = System.nanoTime() / 1000;
-    if (audioTimestampPoller.hasTimestamp()) {
+    if (audioTimestampPoller.hasTimestamp()) {//如果sdk大于19就能提供时间戳
       // Calculate the speed-adjusted position using the timestamp (which may be in the future).
       long timestampPositionFrames = audioTimestampPoller.getTimestampPositionFrames();
-      long timestampPositionUs = framesToDurationUs(timestampPositionFrames);
+      long timestampPositionUs = framesToDurationUs(timestampPositionFrames);//已写入的所有帧需要的时间
       if (!audioTimestampPoller.isTimestampAdvancing()) {
         return timestampPositionUs;
       }
+      //距离上一次时间戳刷新的时间差
       long elapsedSinceTimestampUs = systemTimeUs - audioTimestampPoller.getTimestampSystemTimeUs();
-      return timestampPositionUs + elapsedSinceTimestampUs;
-    } else {
+      return timestampPositionUs + elapsedSinceTimestampUs;//大致等于从音频开始播放到当前时间的差值
+    } else {//sdk小于19，或者还没获取到时间戳
       long positionUs;
-      if (playheadOffsetCount == 0) {
+      if (playheadOffsetCount == 0) {//若播放head还没有偏移，也就是刚开播放
         // The AudioTrack has started, but we don't have any samples to compute a smoothed position.
-        positionUs = getPlaybackHeadPositionUs();
+        positionUs = getPlaybackHeadPositionUs();//获取播放到当前音频帧的时间
       } else {
         // getPlaybackHeadPositionUs() only has a granularity of ~20 ms, so we base the position off
-        // the system clock (and a smoothed offset between it and the playhead position) so as to
+        // the system clock (and a smoothed offset between it and the play head position) so as to
         // prevent jitter in the reported positions.
-        positionUs = systemTimeUs + smoothedPlayheadOffsetUs;
+        positionUs = systemTimeUs + smoothedPlayheadOffsetUs;// 当前时间 加上平均偏移
+
       }
       if (!sourceEnded) {
-        positionUs -= latencyUs;
+        positionUs -= latencyUs;//要减去系统延时
       }
+        Log.e("getCurrentPositionUs","positionUs                 = "+positionUs);
       return positionUs;
     }
   }
@@ -294,8 +299,9 @@ public boolean mayHandleBuffer(long writtenFrames) {
    * @return An estimate of the number of bytes that can be written.
    */
   public int getAvailableBufferSize(long writtenBytes) {
+    //   還未播放的數據大小   = 已經寫入的數據大小  減去 當前已經播放的數據大小
     int bytesPending = (int) (writtenBytes - (getPlaybackHeadPosition() * outputPcmFrameSize));
-    return bufferSize - bytesPending;
+    return bufferSize - bytesPending;//緩衝區大小  減去  還未被播放的數據大小 = 緩衝區生於空間
   }
 
   /** Returns whether the track is in an invalid state and must be recreated. */
@@ -356,24 +362,29 @@ public void reset() {
     audioTimestampPoller = null;
   }
 
+  /**
+   * 1、该方法更新了lastPlayheadSampleTimeUs 最新的播放Sample的时间
+   * 2、当前播放
+   */
   private void maybeSampleSyncParams() {
-    long playbackPositionUs = getPlaybackHeadPositionUs();
+    long playbackPositionUs = getPlaybackHeadPositionUs();//获取播放到当前帧位置所需的总时间。
     if (playbackPositionUs == 0) {
       // The AudioTrack hasn't output anything yet.
       return;
     }
     long systemTimeUs = System.nanoTime() / 1000;
+    //30ms一次
     if (systemTimeUs - lastPlayheadSampleTimeUs >= MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US) {
       // Take a new sample and update the smoothed offset between the system clock and the playhead.
-      playheadOffsets[nextPlayheadOffsetIndex] = playbackPositionUs - systemTimeUs;
-      nextPlayheadOffsetIndex = (nextPlayheadOffsetIndex + 1) % MAX_PLAYHEAD_OFFSET_COUNT;
+      playheadOffsets[nextPlayheadOffsetIndex] = playbackPositionUs - systemTimeUs;//播放当前偏移帧的时间差
+      nextPlayheadOffsetIndex = (nextPlayheadOffsetIndex + 1) % MAX_PLAYHEAD_OFFSET_COUNT;//仅保存10个
       if (playheadOffsetCount < MAX_PLAYHEAD_OFFSET_COUNT) {
         playheadOffsetCount++;
       }
-      lastPlayheadSampleTimeUs = systemTimeUs;
+      lastPlayheadSampleTimeUs = systemTimeUs;//记录当前时间作为最新播放sample的时间
       smoothedPlayheadOffsetUs = 0;
-      for (int i = 0; i < playheadOffsetCount; i++) {
-        smoothedPlayheadOffsetUs += playheadOffsets[i] / playheadOffsetCount;
+      for (int i = 0; i < playheadOffsetCount; i++) {//最多取十个播放偏移，然后取记录个数的平均值
+        smoothedPlayheadOffsetUs += playheadOffsets[i] / playheadOffsetCount;//平均偏移
       }
     }
 
@@ -392,10 +403,10 @@ private void maybePollAndCheckTimestamp(long systemTimeUs, long playbackPosition
       return;
     }
 
-    // Perform sanity checks on the timestamp and accept/reject it.
+    // Perform sanity checks on the timestamp and accept/reject it. //时间戳合理性检查
     long audioTimestampSystemTimeUs = audioTimestampPoller.getTimestampSystemTimeUs();
     long audioTimestampPositionFrames = audioTimestampPoller.getTimestampPositionFrames();
-    if (Math.abs(audioTimestampSystemTimeUs - systemTimeUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
+    if (Math.abs(audioTimestampSystemTimeUs - systemTimeUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {//偏移超过五秒
       listener.onSystemTimeUsMismatch(
           audioTimestampPositionFrames,
           audioTimestampSystemTimeUs,
@@ -403,7 +414,7 @@ private void maybePollAndCheckTimestamp(long systemTimeUs, long playbackPosition
           playbackPositionUs);
       audioTimestampPoller.rejectTimestamp();
     } else if (Math.abs(framesToDurationUs(audioTimestampPositionFrames) - playbackPositionUs)
-        > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
+        > MAX_AUDIO_TIMESTAMP_OFFSET_US) {//偏移超过五秒
       listener.onPositionFramesMismatch(
           audioTimestampPositionFrames,
           audioTimestampSystemTimeUs,
@@ -415,7 +426,7 @@ private void maybePollAndCheckTimestamp(long systemTimeUs, long playbackPosition
     }
   }
 
-  private void maybeUpdateLatency(long systemTimeUs) {
+  private void maybeUpdateLatency(long systemTimeUs) {//计算播放延时
     if (isOutputPcm
         && getLatencyMethod != null
         && systemTimeUs - lastLatencySampleTimeUs >= MIN_LATENCY_SAMPLE_INTERVAL_US) {
@@ -439,7 +450,7 @@ private void maybeUpdateLatency(long systemTimeUs) {
     }
   }
 
-  private long framesToDurationUs(long frameCount) {
+  private long framesToDurationUs(long frameCount) {//计算播放对应帧数需要的时间
     return (frameCount * C.MICROS_PER_SECOND) / outputSampleRate;
   }
 
@@ -470,7 +481,7 @@ private static boolean needsPassthroughWorkarounds(@C.Encoding int outputEncodin
         && (outputEncoding == C.ENCODING_AC3 || outputEncoding == C.ENCODING_E_AC3);
   }
 
-  private long getPlaybackHeadPositionUs() {
+  private long getPlaybackHeadPositionUs() {//获取从开始播放到播当前帧需要的播放时间
     return framesToDurationUs(getPlaybackHeadPosition());
   }
 
@@ -482,11 +493,14 @@ private long getPlaybackHeadPositionUs() {
    *
    * @return The playback head position, in frames.
    */
-  private long getPlaybackHeadPosition() {
-    if (stopTimestampUs != C.TIME_UNSET) {
+  private long getPlaybackHeadPosition() {//获取当前播放帧的位置，以帧为单位
+    if (stopTimestampUs != C.TIME_UNSET) {//如果已经停止，停止时间戳只有在音频结束时设置
       // Simulate the playback head position up to the total number of frames submitted.
+      //从停止到目前的时间长度
       long elapsedTimeSinceStopUs = (SystemClock.elapsedRealtime() * 1000) - stopTimestampUs;
+      //从停止到目前时间转换成帧的数量
       long framesSinceStop = (elapsedTimeSinceStopUs * outputSampleRate) / C.MICROS_PER_SECOND;
+      //返回结束的帧 与 （停止帧加上时间流逝帧之和） 中的小的值
       return Math.min(endPlaybackHeadPosition, stopPlaybackHeadPosition + framesSinceStop);
     }
 
@@ -495,9 +509,9 @@ private long getPlaybackHeadPosition() {
       // The audio track hasn't been started.
       return 0;
     }
-
+    //获取已经播放指针位置，以帧为单位
     long rawPlaybackHeadPosition = 0xFFFFFFFFL & audioTrack.getPlaybackHeadPosition();
-    if (needsPassthroughWorkarounds) {
+    if (needsPassthroughWorkarounds) {//修复22/21的bug代码段，暂停之后获取的播放位置为0
       // Work around an issue with passthrough/direct AudioTracks on platform API versions 21/22
       // where the playback head position jumps back to zero on paused passthrough/direct audio
       // tracks. See [Internal: b/19187573].
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 1025cb953b..00c08a922f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -155,11 +155,11 @@ public long getSkippedOutputFrameCount() {
   /**
    * A minimum length for the {@link AudioTrack} buffer, in microseconds.
    */
-  private static final long MIN_BUFFER_DURATION_US = 250000;
+  private static final long MIN_BUFFER_DURATION_US = 250000;//最小緩衝長度250ms
   /**
    * A maximum length for the {@link AudioTrack} buffer, in microseconds.
    */
-  private static final long MAX_BUFFER_DURATION_US = 750000;
+  private static final long MAX_BUFFER_DURATION_US = 750000;//最大缓冲时长
   /**
    * The length for passthrough {@link AudioTrack} buffers, in microseconds.
    */
@@ -382,7 +382,7 @@ public boolean isEncodingSupported(@C.Encoding int encoding) {
   }
 
   @Override
-  public long getCurrentPositionUs(boolean sourceEnded) {
+  public long getCurrentPositionUs(boolean sourceEnded) {//获取当前音频播放位置
     if (!isInitialized() || startMediaTimeState == START_NOT_SET) {
       return CURRENT_POSITION_NOT_SET;
     }
@@ -556,11 +556,11 @@ private void initialize() throws InitializationException {
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
     // the shared memory that's available for audio track buffers. This would in turn cause the
     // initialization of the audio track to fail.
-    releasingConditionVariable.block();
+    releasingConditionVariable.block();//确保异步释放完成 再重新进入初始化流程
 
-    audioTrack = initializeAudioTrack();
-    int audioSessionId = audioTrack.getAudioSessionId();
-    if (enablePreV21AudioSessionWorkaround) {
+    audioTrack = initializeAudioTrack();//初始化AudioTrack,内部已實現不同版本的兼容初始化
+    int audioSessionId = audioTrack.getAudioSessionId();//獲取初始化的AudioTrack的session
+    if (enablePreV21AudioSessionWorkaround) {//這個值是靜態的，必須要在初始化之前設置
       if (Util.SDK_INT < 21) {
         // The workaround creates an audio track with a two byte buffer on the same session, and
         // does not release it until this object is released, which keeps the session active.
@@ -613,10 +613,10 @@ public void handleDiscontinuity() {
   public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       throws InitializationException, WriteException {
     Assertions.checkArgument(inputBuffer == null || buffer == inputBuffer);
-    if (!isInitialized()) {
-      initialize();
-      if (playing) {
-        play();
+    if (!isInitialized()) {//如果没初始化
+      initialize();//初始化
+      if (playing) {//是否在播放
+        play();//播放
       }
     }
 
@@ -624,17 +624,17 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
       return false;
     }
 
-    if (inputBuffer == null) {
+    if (inputBuffer == null) {//
       // We are seeing this buffer for the first time.
       if (!buffer.hasRemaining()) {
         // The buffer is empty.
         return true;
       }
 
-      if (!isInputPcm && framesPerEncodedSample == 0) {
+      if (!isInputPcm && framesPerEncodedSample == 0) {//非PCM同时 每个Sample的帧数还没被确定
         // If this is the first encoded sample, calculate the sample size in frames.
         framesPerEncodedSample = getFramesPerEncodedSample(outputEncoding, buffer);
-        if (framesPerEncodedSample == 0) {
+        if (framesPerEncodedSample == 0) {//如果计算结果仍为零
           // We still don't know the number of frames per sample, so drop the buffer.
           // For TrueHD this can occur after some seek operations, as not every sample starts with
           // a syncframe header. If we chunked samples together so the extracted samples always
@@ -749,32 +749,34 @@ private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throw
     if (!buffer.hasRemaining()) {
       return;
     }
-    if (outputBuffer != null) {
-      Assertions.checkArgument(outputBuffer == buffer);
+    if (outputBuffer != null) {//如果數據沒被寫完，這個outputBuffer是不會被置空的，所以如果而外面傳入了新的buffer，會抛出異常
+      Assertions.checkArgument(outputBuffer == buffer);//判斷這個buffer是否等於還沒被寫完的buffer
     } else {
-      outputBuffer = buffer;
+      outputBuffer = buffer;//記錄這個buffer，用於下一次這個方法被調用時，判斷這個buffer是否被重複調用
       if (Util.SDK_INT < 21) {
         int bytesRemaining = buffer.remaining();
         if (preV21OutputBuffer == null || preV21OutputBuffer.length < bytesRemaining) {
-          preV21OutputBuffer = new byte[bytesRemaining];
+          preV21OutputBuffer = new byte[bytesRemaining];//新建一個數組用來存儲傳過來的buffer數據
         }
-        int originalPosition = buffer.position();
-        buffer.get(preV21OutputBuffer, 0, bytesRemaining);
-        buffer.position(originalPosition);
-        preV21OutputBufferOffset = 0;
+        int originalPosition = buffer.position();//臨時保存buffer的指針位置
+        buffer.get(preV21OutputBuffer, 0, bytesRemaining);//將傳入的buffer數據拷貝出來
+        buffer.position(originalPosition);//將指針位置再設置回去
+        preV21OutputBufferOffset = 0;//僅僅用來記錄這個buffer的偏移量，拷貝之後將偏移量置爲0
       }
     }
     int bytesRemaining = buffer.remaining();
     int bytesWritten = 0;
     if (Util.SDK_INT < 21) { // isInputPcm == true
-      // Work out how many bytes we can write without the risk of blocking.
+      // Work out how many bytes we can write without the risk of blocking.//計算我們能在沒有阻塞風險的情況下寫入多少數據
       int bytesToWrite = audioTrackPositionTracker.getAvailableBufferSize(writtenPcmBytes);
       if (bytesToWrite > 0) {
-        bytesToWrite = Math.min(bytesRemaining, bytesToWrite);
-        bytesWritten = audioTrack.write(preV21OutputBuffer, preV21OutputBufferOffset, bytesToWrite);
+        bytesToWrite = Math.min(bytesRemaining, bytesToWrite);//緩衝區剩餘 和當前傳入的數據剩餘 中較小的作爲要被寫的值
+        //假如 bytesRemaining > bytesToWrite,就只有 preV21OutputBuffer中就還有（bytesRemaining - bytesToWrite）的數據量未被寫入
+        //
+        bytesWritten = audioTrack.write(preV21OutputBuffer, preV21OutputBufferOffset, bytesToWrite);//阻塞寫入（實際上前面計算得好，不會阻塞）
         if (bytesWritten > 0) {
           preV21OutputBufferOffset += bytesWritten;
-          buffer.position(buffer.position() + bytesWritten);
+          buffer.position(buffer.position() + bytesWritten);//將buffer指針前移
         }
       }
     } else if (tunneling) {
@@ -782,23 +784,23 @@ private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throw
       bytesWritten = writeNonBlockingWithAvSyncV21(audioTrack, buffer, bytesRemaining,
           avSyncPresentationTimeUs);
     } else {
-      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bytesRemaining);
+      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bytesRemaining);//SDK大於等於21直接調用阻塞式寫入數據
     }
 
-    lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
+    lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();//記錄本次投喂數據時間
 
     if (bytesWritten < 0) {
       throw new WriteException(bytesWritten);
     }
 
     if (isInputPcm) {
-      writtenPcmBytes += bytesWritten;
+      writtenPcmBytes += bytesWritten;//更新已經寫入的數據長度
     }
-    if (bytesWritten == bytesRemaining) {
+    if (bytesWritten == bytesRemaining) {//如果寫入AudioTrack的數據量等於buffer的數據大小
       if (!isInputPcm) {
         writtenEncodedFrames += framesPerEncodedSample;
       }
-      outputBuffer = null;
+      outputBuffer = null; //説明當前buffer已經被寫完了，
     }
   }
 
@@ -911,7 +913,7 @@ public void setAudioSessionId(int audioSessionId) {
 
   @Override
   public void enableTunnelingV21(int tunnelingAudioSessionId) {
-    Assertions.checkState(Util.SDK_INT >= 21);
+    Assertions.checkState(Util.SDK_INT >= 21);//必须大于等于21
     if (!tunneling || audioSessionId != tunnelingAudioSessionId) {
       tunneling = true;
       audioSessionId = tunnelingAudioSessionId;
@@ -957,11 +959,11 @@ public void pause() {
   @Override
   public void reset() {
     if (isInitialized()) {
-      submittedPcmBytes = 0;
-      submittedEncodedFrames = 0;
-      writtenPcmBytes = 0;
-      writtenEncodedFrames = 0;
-      framesPerEncodedSample = 0;
+      submittedPcmBytes = 0;//已提交的PCM數據大小，單位byte
+      submittedEncodedFrames = 0;//提交的音頻幀數量
+      writtenPcmBytes = 0;//已写到AudioTrack的PCM数据大小，单位byte
+      writtenEncodedFrames = 0;//已寫入到AudioTrack的幀數
+      framesPerEncodedSample = 0;//每個采樣裏面包含多少幀數據
       if (afterDrainPlaybackParameters != null) {
         playbackParameters = afterDrainPlaybackParameters;
         afterDrainPlaybackParameters = null;
@@ -971,8 +973,8 @@ public void reset() {
       playbackParametersCheckpoints.clear();
       playbackParametersOffsetUs = 0;
       playbackParametersPositionUs = 0;
-      inputBuffer = null;
-      outputBuffer = null;
+      inputBuffer = null;//用於緩存handleBuffer調用時傳入的buffer（寫入sink）
+      outputBuffer = null;//用於緩存writeBuffer調用時的buffer（流出Sink）
       flushAudioProcessors();
       handledEndOfStream = false;
       drainingAudioProcessorIndex = C.INDEX_UNSET;
@@ -1075,10 +1077,16 @@ private long inputFramesToDurationUs(long frameCount) {
   }
 
   private long framesToDurationUs(long frameCount) {
+    //计算指定帧数的时间长度 = 1000000*帧数/采样率
+    //等式中的1000000为单位转换需要的数字；
+    // 可以看出这个类中的音频帧指的是一个采样点，
+    // 比如1000个采样点需要的时间  ，采样率为1000000Hz， 则这个时间就为1000us 这里要注意单位的换算
     return (frameCount * C.MICROS_PER_SECOND) / outputSampleRate;
   }
 
   private long durationUsToFrames(long durationUs) {
+    //计算指定时间内有多少个帧（这个Frame需要理解为一个采样点），比如采样率为44.1KHz中的一次采样
+    //比如1s，也就是1000000us，这里算出来就为一秒的采样次数。
     return (durationUs * outputSampleRate) / C.MICROS_PER_SECOND;
   }
 
@@ -1087,6 +1095,8 @@ private long getSubmittedFrames() {
   }
 
   private long getWrittenFrames() {
+    // 如果是PCM数据，已写入帧数=已写入的Pcm数据字节数/输出的PCM帧大小
+    // 输出的PCM帧大小 = 采样深度*通道数 （可能概念有些混淆）
     return isInputPcm ? (writtenPcmBytes / outputPcmFrameSize) : writtenEncodedFrames;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 03a0b66661..f4e0f446d5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -570,8 +570,8 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     maybeInitCodec();
     if (codec != null) {
       TraceUtil.beginSection("drainAndFeed");
-      while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-      while (feedInputBuffer()) {}
+      while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}//将解码输出的数据消费掉
+      while (feedInputBuffer()) {}//再给解码器投喂数据
       TraceUtil.endSection();
     } else {
       decoderCounters.skippedInputBufferCount += skipSource(positionUs);
@@ -1005,7 +1005,7 @@ protected long getDequeueOutputBufferTimeoutUs() {
    */
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
-    if (!hasOutputBuffer()) {
+    if (!hasOutputBuffer()) {//是否有输出需要处理
       int outputIndex;
       if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {
         try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
index b1f53416fb..a5a6cf3811 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.PlaybackParameters;
 
@@ -26,9 +28,9 @@
 
   private final Clock clock;
 
-  private boolean started;
-  private long baseUs;
-  private long baseElapsedMs;
+  private boolean started; //是否启动
+  private long baseUs;     //计时基准点，每次seek之后会发生改变
+  private long baseElapsedMs;//计时基准点，启动之后才会
   private PlaybackParameters playbackParameters;
 
   /**
@@ -45,8 +47,8 @@ public StandaloneMediaClock(Clock clock) {
    * Starts the clock. Does nothing if the clock is already started.
    */
   public void start() {
-    if (!started) {
-      baseElapsedMs = clock.elapsedRealtime();
+    if (!started) {//若处于为启动状态
+      baseElapsedMs = clock.elapsedRealtime();//更新基准时间
       started = true;
     }
   }
@@ -55,7 +57,7 @@ public void start() {
    * Stops the clock. Does nothing if the clock is already stopped.
    */
   public void stop() {
-    if (started) {
+    if (started) {//
       resetPosition(getPositionUs());
       started = false;
     }
@@ -67,9 +69,9 @@ public void stop() {
    * @param positionUs The position to set in microseconds.
    */
   public void resetPosition(long positionUs) {
-    baseUs = positionUs;
-    if (started) {
-      baseElapsedMs = clock.elapsedRealtime();
+    baseUs = positionUs;//重置时间
+    if (started) {//若时钟处于启动状态
+      baseElapsedMs = clock.elapsedRealtime();//将基准时间更新为当前时间
     }
   }
 
@@ -77,10 +79,11 @@ public void resetPosition(long positionUs) {
   public long getPositionUs() {
     long positionUs = baseUs;
     if (started) {
-      long elapsedSinceBaseMs = clock.elapsedRealtime() - baseElapsedMs;
-      if (playbackParameters.speed == 1f) {
+      long elapsedSinceBaseMs = clock.elapsedRealtime() - baseElapsedMs;//当前时间减去基准时间
+      Log.e("getPositionUs","baseElapsedMs="+baseElapsedMs+",__baseUs="+baseUs);
+      if (playbackParameters.speed == 1f) {//若播放速度为一倍速度
         positionUs += C.msToUs(elapsedSinceBaseMs);
-      } else {
+      } else {//若播放速度不为一倍速度
         positionUs += playbackParameters.getMediaTimeUsForPlayoutTimeMs(elapsedSinceBaseMs);
       }
     }
@@ -91,7 +94,7 @@ public long getPositionUs() {
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
     // Store the current position as the new base, in case the playback speed has changed.
     if (started) {
-      resetPosition(getPositionUs());
+      resetPosition(getPositionUs());//播放参数变化需要重置参数，比如播放速度改变了
     }
     this.playbackParameters = playbackParameters;
     return playbackParameters;
