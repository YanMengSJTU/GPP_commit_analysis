diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 483ab37369..da5419a39a 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -28,9 +28,11 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.widget.Button;
+import android.widget.ImageView;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 import android.widget.Toast;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
@@ -77,6 +79,7 @@
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
 import com.google.android.exoplayer2.util.EventLogger;
 import com.google.android.exoplayer2.util.Util;
+
 import java.lang.reflect.Constructor;
 import java.net.CookieHandler;
 import java.net.CookieManager;
@@ -84,686 +87,723 @@
 import java.util.List;
 import java.util.UUID;
 
-/** An activity that plays media using {@link SimpleExoPlayer}. */
+/**
+ * An activity that plays media using {@link SimpleExoPlayer}.
+ */
 public class PlayerActivity extends Activity
-    implements OnClickListener, PlaybackPreparer, PlayerControlView.VisibilityListener {
-
-  public static final String DRM_SCHEME_EXTRA = "drm_scheme";
-  public static final String DRM_LICENSE_URL_EXTRA = "drm_license_url";
-  public static final String DRM_KEY_REQUEST_PROPERTIES_EXTRA = "drm_key_request_properties";
-  public static final String DRM_MULTI_SESSION_EXTRA = "drm_multi_session";
-  public static final String PREFER_EXTENSION_DECODERS_EXTRA = "prefer_extension_decoders";
-
-  public static final String ACTION_VIEW = "com.google.android.exoplayer.demo.action.VIEW";
-  public static final String EXTENSION_EXTRA = "extension";
-
-  public static final String ACTION_VIEW_LIST =
-      "com.google.android.exoplayer.demo.action.VIEW_LIST";
-  public static final String URI_LIST_EXTRA = "uri_list";
-  public static final String EXTENSION_LIST_EXTRA = "extension_list";
-
-  public static final String AD_TAG_URI_EXTRA = "ad_tag_uri";
-
-  public static final String ABR_ALGORITHM_EXTRA = "abr_algorithm";
-  public static final String ABR_ALGORITHM_DEFAULT = "default";
-  public static final String ABR_ALGORITHM_RANDOM = "random";
-
-  public static final String SPHERICAL_STEREO_MODE_EXTRA = "spherical_stereo_mode";
-  public static final String SPHERICAL_STEREO_MODE_MONO = "mono";
-  public static final String SPHERICAL_STEREO_MODE_TOP_BOTTOM = "top_bottom";
-  public static final String SPHERICAL_STEREO_MODE_LEFT_RIGHT = "left_right";
-
-  // For backwards compatibility only.
-  private static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
-
-  // Saved instance state keys.
-  private static final String KEY_TRACK_SELECTOR_PARAMETERS = "track_selector_parameters";
-  private static final String KEY_WINDOW = "window";
-  private static final String KEY_POSITION = "position";
-  private static final String KEY_AUTO_PLAY = "auto_play";
-
-  private static final CookieManager DEFAULT_COOKIE_MANAGER;
-  static {
-    DEFAULT_COOKIE_MANAGER = new CookieManager();
-    DEFAULT_COOKIE_MANAGER.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
-  }
-
-  private PlayerView playerView;
-  private LinearLayout debugRootView;
-  private TextView debugTextView;
-
-  private DataSource.Factory dataSourceFactory;
-  private SimpleExoPlayer player;
-  private FrameworkMediaDrm mediaDrm;
-  private MediaSource mediaSource;
-  private DefaultTrackSelector trackSelector;
-  private DefaultTrackSelector.Parameters trackSelectorParameters;
-  private DebugTextViewHelper debugViewHelper;
-  private TrackGroupArray lastSeenTrackGroupArray;
-
-  private boolean startAutoPlay;
-  private int startWindow;
-  private long startPosition;
-
-  // Fields used only for ad playback. The ads loader is loaded via reflection.
-
-  private AdsLoader adsLoader;
-  private Uri loadedAdTagUri;
-
-  // Activity lifecycle
-
-  @Override
-  public void onCreate(Bundle savedInstanceState) {
-    String sphericalStereoMode = getIntent().getStringExtra(SPHERICAL_STEREO_MODE_EXTRA);
-    if (sphericalStereoMode != null) {
-      setTheme(R.style.PlayerTheme_Spherical);
-    }
-    super.onCreate(savedInstanceState);
-    dataSourceFactory = buildDataSourceFactory();
-    if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
-      CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
-    }
-
-    setContentView(R.layout.player_activity);
-    View rootView = findViewById(R.id.root);
-    rootView.setOnClickListener(this);
-    debugRootView = findViewById(R.id.controls_root);
-    debugTextView = findViewById(R.id.debug_text_view);
-
-    playerView = findViewById(R.id.player_view);
-    playerView.setControllerVisibilityListener(this);
-    playerView.setErrorMessageProvider(new PlayerErrorMessageProvider());
-    playerView.requestFocus();
-    if (sphericalStereoMode != null) {
-      int stereoMode;
-      if (SPHERICAL_STEREO_MODE_MONO.equals(sphericalStereoMode)) {
-        stereoMode = C.STEREO_MODE_MONO;
-      } else if (SPHERICAL_STEREO_MODE_TOP_BOTTOM.equals(sphericalStereoMode)) {
-        stereoMode = C.STEREO_MODE_TOP_BOTTOM;
-      } else if (SPHERICAL_STEREO_MODE_LEFT_RIGHT.equals(sphericalStereoMode)) {
-        stereoMode = C.STEREO_MODE_LEFT_RIGHT;
-      } else {
-        showToast(R.string.error_unrecognized_stereo_mode);
-        finish();
-        return;
-      }
-      ((SphericalSurfaceView) playerView.getVideoSurfaceView()).setDefaultStereoMode(stereoMode);
-    }
-
-    if (savedInstanceState != null) {
-      trackSelectorParameters = savedInstanceState.getParcelable(KEY_TRACK_SELECTOR_PARAMETERS);
-      startAutoPlay = savedInstanceState.getBoolean(KEY_AUTO_PLAY);
-      startWindow = savedInstanceState.getInt(KEY_WINDOW);
-      startPosition = savedInstanceState.getLong(KEY_POSITION);
-    } else {
-      trackSelectorParameters = new DefaultTrackSelector.ParametersBuilder().build();
-      clearStartPosition();
-    }
-  }
-
-  @Override
-  public void onNewIntent(Intent intent) {
-    releasePlayer();
-    releaseAdsLoader();
-    clearStartPosition();
-    setIntent(intent);
-  }
-
-  @Override
-  public void onStart() {
-    super.onStart();
-    if (Util.SDK_INT > 23) {
-      initializePlayer();
-      if (playerView != null) {
-        playerView.onResume();
-      }
-    }
-  }
-
-  @Override
-  public void onResume() {
-    super.onResume();
-    if (Util.SDK_INT <= 23 || player == null) {
-      initializePlayer();
-      if (playerView != null) {
-        playerView.onResume();
-      }
-    }
-  }
-
-  @Override
-  public void onPause() {
-    super.onPause();
-    if (Util.SDK_INT <= 23) {
-      if (playerView != null) {
-        playerView.onPause();
-      }
-      releasePlayer();
-    }
-  }
-
-  @Override
-  public void onStop() {
-    super.onStop();
-    if (Util.SDK_INT > 23) {
-      if (playerView != null) {
-        playerView.onPause();
-      }
-      releasePlayer();
-    }
-  }
-
-  @Override
-  public void onDestroy() {
-    super.onDestroy();
-    releaseAdsLoader();
-  }
-
-  @Override
-  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
-      @NonNull int[] grantResults) {
-    if (grantResults.length == 0) {
-      // Empty results are triggered if a permission is requested while another request was already
-      // pending and can be safely ignored in this case.
-      return;
-    }
-    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-      initializePlayer();
-    } else {
-      showToast(R.string.storage_permission_denied);
-      finish();
-    }
-  }
-
-  @Override
-  public void onSaveInstanceState(Bundle outState) {
-    updateTrackSelectorParameters();
-    updateStartPosition();
-    outState.putParcelable(KEY_TRACK_SELECTOR_PARAMETERS, trackSelectorParameters);
-    outState.putBoolean(KEY_AUTO_PLAY, startAutoPlay);
-    outState.putInt(KEY_WINDOW, startWindow);
-    outState.putLong(KEY_POSITION, startPosition);
-  }
-
-  // Activity input
-
-  @Override
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    // See whether the player view wants to handle media or DPAD keys events.
-    return playerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
-  }
-
-  // OnClickListener methods
-
-  @Override
-  public void onClick(View view) {
-    if (view.getParent() == debugRootView) {
-      MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
-      if (mappedTrackInfo != null) {
-        CharSequence title = ((Button) view).getText();
-        int rendererIndex = (int) view.getTag();
-        int rendererType = mappedTrackInfo.getRendererType(rendererIndex);
-        boolean allowAdaptiveSelections =
-            rendererType == C.TRACK_TYPE_VIDEO
-                || (rendererType == C.TRACK_TYPE_AUDIO
-                    && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
-                        == MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);
-        Pair<AlertDialog, TrackSelectionView> dialogPair =
-            TrackSelectionView.getDialog(this, title, trackSelector, rendererIndex);
-        dialogPair.second.setShowDisableOption(true);
-        dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);
-        dialogPair.first.show();
-      }
-    }
-  }
-
-  // PlaybackControlView.PlaybackPreparer implementation
-
-  @Override
-  public void preparePlayback() {
-    initializePlayer();
-  }
-
-  // PlaybackControlView.VisibilityListener implementation
-
-  @Override
-  public void onVisibilityChange(int visibility) {
-    debugRootView.setVisibility(visibility);
-  }
-
-  // Internal methods
-
-  private void initializePlayer() {
-    if (player == null) {
-      Intent intent = getIntent();
-      String action = intent.getAction();
-      Uri[] uris;
-      String[] extensions;
-      if (ACTION_VIEW.equals(action)) {
-        uris = new Uri[] {intent.getData()};
-        extensions = new String[] {intent.getStringExtra(EXTENSION_EXTRA)};
-      } else if (ACTION_VIEW_LIST.equals(action)) {
-        String[] uriStrings = intent.getStringArrayExtra(URI_LIST_EXTRA);
-        uris = new Uri[uriStrings.length];
-        for (int i = 0; i < uriStrings.length; i++) {
-          uris[i] = Uri.parse(uriStrings[i]);
-        }
-        extensions = intent.getStringArrayExtra(EXTENSION_LIST_EXTRA);
-        if (extensions == null) {
-          extensions = new String[uriStrings.length];
-        }
-      } else {
-        showToast(getString(R.string.unexpected_intent_action, action));
-        finish();
-        return;
-      }
-      if (!Util.checkCleartextTrafficPermitted(uris)) {
-        showToast(R.string.error_cleartext_not_permitted);
-        return;
-      }
-      if (Util.maybeRequestReadExternalStoragePermission(/* activity= */ this, uris)) {
-        // The player will be reinitialized if the permission is granted.
-        return;
-      }
-
-      DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
-      if (intent.hasExtra(DRM_SCHEME_EXTRA) || intent.hasExtra(DRM_SCHEME_UUID_EXTRA)) {
-        String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL_EXTRA);
-        String[] keyRequestPropertiesArray =
-            intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES_EXTRA);
-        boolean multiSession = intent.getBooleanExtra(DRM_MULTI_SESSION_EXTRA, false);
-        int errorStringId = R.string.error_drm_unknown;
-        if (Util.SDK_INT < 18) {
-          errorStringId = R.string.error_drm_not_supported;
-        } else {
-          try {
-            String drmSchemeExtra = intent.hasExtra(DRM_SCHEME_EXTRA) ? DRM_SCHEME_EXTRA
-                : DRM_SCHEME_UUID_EXTRA;
-            UUID drmSchemeUuid = Util.getDrmUuid(intent.getStringExtra(drmSchemeExtra));
-            if (drmSchemeUuid == null) {
-              errorStringId = R.string.error_drm_unsupported_scheme;
+        implements OnClickListener, PlaybackPreparer, PlayerControlView.VisibilityListener,
+        PlayerControlView.OnQualityChangeClickedListener,
+        PlayerControlView.OnFullScreenButtonClickedListener {
+
+    public static final String DRM_SCHEME_EXTRA = "drm_scheme";
+    public static final String DRM_LICENSE_URL_EXTRA = "drm_license_url";
+    public static final String DRM_KEY_REQUEST_PROPERTIES_EXTRA = "drm_key_request_properties";
+    public static final String DRM_MULTI_SESSION_EXTRA = "drm_multi_session";
+    public static final String PREFER_EXTENSION_DECODERS_EXTRA = "prefer_extension_decoders";
+
+    public static final String ACTION_VIEW = "com.google.android.exoplayer.demo.action.VIEW";
+    public static final String EXTENSION_EXTRA = "extension";
+
+    public static final String ACTION_VIEW_LIST =
+            "com.google.android.exoplayer.demo.action.VIEW_LIST";
+    public static final String URI_LIST_EXTRA = "uri_list";
+    public static final String EXTENSION_LIST_EXTRA = "extension_list";
+
+    public static final String AD_TAG_URI_EXTRA = "ad_tag_uri";
+
+    public static final String ABR_ALGORITHM_EXTRA = "abr_algorithm";
+    public static final String ABR_ALGORITHM_DEFAULT = "default";
+    public static final String ABR_ALGORITHM_RANDOM = "random";
+
+    public static final String SPHERICAL_STEREO_MODE_EXTRA = "spherical_stereo_mode";
+    public static final String SPHERICAL_STEREO_MODE_MONO = "mono";
+    public static final String SPHERICAL_STEREO_MODE_TOP_BOTTOM = "top_bottom";
+    public static final String SPHERICAL_STEREO_MODE_LEFT_RIGHT = "left_right";
+
+    // For backwards compatibility only.
+    private static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
+
+    // Saved instance state keys.
+    private static final String KEY_TRACK_SELECTOR_PARAMETERS = "track_selector_parameters";
+    private static final String KEY_WINDOW = "window";
+    private static final String KEY_POSITION = "position";
+    private static final String KEY_AUTO_PLAY = "auto_play";
+
+    private static final CookieManager DEFAULT_COOKIE_MANAGER;
+
+    static {
+        DEFAULT_COOKIE_MANAGER = new CookieManager();
+        DEFAULT_COOKIE_MANAGER.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
+    }
+
+    private PlayerView playerView;
+    private LinearLayout debugRootView;
+    private TextView debugTextView;
+
+    private DataSource.Factory dataSourceFactory;
+    private SimpleExoPlayer player;
+    private FrameworkMediaDrm mediaDrm;
+    private MediaSource mediaSource;
+    private DefaultTrackSelector trackSelector;
+    private DefaultTrackSelector.Parameters trackSelectorParameters;
+    private DebugTextViewHelper debugViewHelper;
+    private TrackGroupArray lastSeenTrackGroupArray;
+
+    private boolean startAutoPlay;
+    private int startWindow;
+    private long startPosition;
+
+    // Fields used only for ad playback. The ads loader is loaded via reflection.
+
+    private AdsLoader adsLoader;
+    private Uri loadedAdTagUri;
+    private int videoRendererIndex;
+
+    // Activity lifecycle
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        String sphericalStereoMode = getIntent().getStringExtra(SPHERICAL_STEREO_MODE_EXTRA);
+        if (sphericalStereoMode != null) {
+            setTheme(R.style.PlayerTheme_Spherical);
+        }
+        super.onCreate(savedInstanceState);
+        dataSourceFactory = buildDataSourceFactory();
+        if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
+            CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
+        }
+
+        setContentView(R.layout.player_activity);
+        View rootView = findViewById(R.id.root);
+        rootView.setOnClickListener(this);
+        debugRootView = findViewById(R.id.controls_root);
+        debugTextView = findViewById(R.id.debug_text_view);
+
+        playerView = findViewById(R.id.player_view);
+        playerView.setControllerVisibilityListener(this);
+        playerView.setErrorMessageProvider(new PlayerErrorMessageProvider());
+        playerView.requestFocus();
+        playerView.setQualityChangeClickedListener(this);
+        playerView.setFullscreenClickedListener(this);
+        if (sphericalStereoMode != null) {
+            int stereoMode;
+            if (SPHERICAL_STEREO_MODE_MONO.equals(sphericalStereoMode)) {
+                stereoMode = C.STEREO_MODE_MONO;
+            } else if (SPHERICAL_STEREO_MODE_TOP_BOTTOM.equals(sphericalStereoMode)) {
+                stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+            } else if (SPHERICAL_STEREO_MODE_LEFT_RIGHT.equals(sphericalStereoMode)) {
+                stereoMode = C.STEREO_MODE_LEFT_RIGHT;
             } else {
-              drmSessionManager =
-                  buildDrmSessionManagerV18(
-                      drmSchemeUuid, drmLicenseUrl, keyRequestPropertiesArray, multiSession);
+                showToast(R.string.error_unrecognized_stereo_mode);
+                finish();
+                return;
             }
-          } catch (UnsupportedDrmException e) {
-            errorStringId = e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
-                ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown;
-          }
-        }
-        if (drmSessionManager == null) {
-          showToast(errorStringId);
-          finish();
-          return;
-        }
-      }
-
-      TrackSelection.Factory trackSelectionFactory;
-      String abrAlgorithm = intent.getStringExtra(ABR_ALGORITHM_EXTRA);
-      if (abrAlgorithm == null || ABR_ALGORITHM_DEFAULT.equals(abrAlgorithm)) {
-        trackSelectionFactory = new AdaptiveTrackSelection.Factory();
-      } else if (ABR_ALGORITHM_RANDOM.equals(abrAlgorithm)) {
-        trackSelectionFactory = new RandomTrackSelection.Factory();
-      } else {
-        showToast(R.string.error_unrecognized_abr_algorithm);
-        finish();
-        return;
-      }
-
-      boolean preferExtensionDecoders =
-          intent.getBooleanExtra(PREFER_EXTENSION_DECODERS_EXTRA, false);
-      @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode =
-          ((DemoApplication) getApplication()).useExtensionRenderers()
-              ? (preferExtensionDecoders ? DefaultRenderersFactory.EXTENSION_RENDERER_MODE_PREFER
-              : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
-              : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF;
-      DefaultRenderersFactory renderersFactory =
-          new DefaultRenderersFactory(this, extensionRendererMode);
-
-      trackSelector = new DefaultTrackSelector(trackSelectionFactory);
-      trackSelector.setParameters(trackSelectorParameters);
-      lastSeenTrackGroupArray = null;
-
-      player =
-          ExoPlayerFactory.newSimpleInstance(
-              /* context= */ this, renderersFactory, trackSelector, drmSessionManager);
-      player.addListener(new PlayerEventListener());
-      player.setPlayWhenReady(startAutoPlay);
-      player.addAnalyticsListener(new EventLogger(trackSelector));
-      playerView.setPlayer(player);
-      playerView.setPlaybackPreparer(this);
-      debugViewHelper = new DebugTextViewHelper(player, debugTextView);
-      debugViewHelper.start();
-
-      MediaSource[] mediaSources = new MediaSource[uris.length];
-      for (int i = 0; i < uris.length; i++) {
-        mediaSources[i] = buildMediaSource(uris[i], extensions[i]);
-      }
-      mediaSource =
-          mediaSources.length == 1 ? mediaSources[0] : new ConcatenatingMediaSource(mediaSources);
-      String adTagUriString = intent.getStringExtra(AD_TAG_URI_EXTRA);
-      if (adTagUriString != null) {
-        Uri adTagUri = Uri.parse(adTagUriString);
-        if (!adTagUri.equals(loadedAdTagUri)) {
-          releaseAdsLoader();
-          loadedAdTagUri = adTagUri;
-        }
-        MediaSource adsMediaSource = createAdsMediaSource(mediaSource, Uri.parse(adTagUriString));
-        if (adsMediaSource != null) {
-          mediaSource = adsMediaSource;
+            ((SphericalSurfaceView) playerView.getVideoSurfaceView()).setDefaultStereoMode(stereoMode);
+        }
+
+        if (savedInstanceState != null) {
+            trackSelectorParameters = savedInstanceState.getParcelable(KEY_TRACK_SELECTOR_PARAMETERS);
+            startAutoPlay = savedInstanceState.getBoolean(KEY_AUTO_PLAY);
+            startWindow = savedInstanceState.getInt(KEY_WINDOW);
+            startPosition = savedInstanceState.getLong(KEY_POSITION);
         } else {
-          showToast(R.string.ima_not_loaded);
+            trackSelectorParameters = new DefaultTrackSelector.ParametersBuilder().build();
+            clearStartPosition();
         }
-      } else {
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        releasePlayer();
         releaseAdsLoader();
-      }
-    }
-    boolean haveStartPosition = startWindow != C.INDEX_UNSET;
-    if (haveStartPosition) {
-      player.seekTo(startWindow, startPosition);
-    }
-    player.prepare(mediaSource, !haveStartPosition, false);
-    updateButtonVisibilities();
-  }
-
-  private MediaSource buildMediaSource(Uri uri) {
-    return buildMediaSource(uri, null);
-  }
-
-  private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
-    @ContentType int type = Util.inferContentType(uri, overrideExtension);
-    switch (type) {
-      case C.TYPE_DASH:
-        return new DashMediaSource.Factory(dataSourceFactory)
-            .setManifestParser(
-                new FilteringManifestParser<>(new DashManifestParser(), getOfflineStreamKeys(uri)))
-            .createMediaSource(uri);
-      case C.TYPE_SS:
-        return new SsMediaSource.Factory(dataSourceFactory)
-            .setManifestParser(
-                new FilteringManifestParser<>(new SsManifestParser(), getOfflineStreamKeys(uri)))
-            .createMediaSource(uri);
-      case C.TYPE_HLS:
-        return new HlsMediaSource.Factory(dataSourceFactory)
-            .setPlaylistParserFactory(
-                new DefaultHlsPlaylistParserFactory(getOfflineStreamKeys(uri)))
-            .createMediaSource(uri);
-      case C.TYPE_OTHER:
-        return new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
-      default: {
-        throw new IllegalStateException("Unsupported type: " + type);
-      }
-    }
-  }
-
-  private List<StreamKey> getOfflineStreamKeys(Uri uri) {
-    return ((DemoApplication) getApplication()).getDownloadTracker().getOfflineStreamKeys(uri);
-  }
-
-  private DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(
-      UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
-      throws UnsupportedDrmException {
-    HttpDataSource.Factory licenseDataSourceFactory =
-        ((DemoApplication) getApplication()).buildHttpDataSourceFactory();
-    HttpMediaDrmCallback drmCallback =
-        new HttpMediaDrmCallback(licenseUrl, licenseDataSourceFactory);
-    if (keyRequestPropertiesArray != null) {
-      for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
-        drmCallback.setKeyRequestProperty(keyRequestPropertiesArray[i],
-            keyRequestPropertiesArray[i + 1]);
-      }
-    }
-    releaseMediaDrm();
-    mediaDrm = FrameworkMediaDrm.newInstance(uuid);
-    return new DefaultDrmSessionManager<>(uuid, mediaDrm, drmCallback, null, multiSession);
-  }
-
-  private void releasePlayer() {
-    if (player != null) {
-      updateTrackSelectorParameters();
-      updateStartPosition();
-      debugViewHelper.stop();
-      debugViewHelper = null;
-      player.release();
-      player = null;
-      mediaSource = null;
-      trackSelector = null;
-    }
-    if (adsLoader != null) {
-      adsLoader.setPlayer(null);
-    }
-    releaseMediaDrm();
-  }
-
-  private void releaseMediaDrm() {
-    if (mediaDrm != null) {
-      mediaDrm.release();
-      mediaDrm = null;
-    }
-  }
-
-  private void releaseAdsLoader() {
-    if (adsLoader != null) {
-      adsLoader.release();
-      adsLoader = null;
-      loadedAdTagUri = null;
-      playerView.getOverlayFrameLayout().removeAllViews();
-    }
-  }
-
-  private void updateTrackSelectorParameters() {
-    if (trackSelector != null) {
-      trackSelectorParameters = trackSelector.getParameters();
-    }
-  }
-
-  private void updateStartPosition() {
-    if (player != null) {
-      startAutoPlay = player.getPlayWhenReady();
-      startWindow = player.getCurrentWindowIndex();
-      startPosition = Math.max(0, player.getContentPosition());
-    }
-  }
-
-  private void clearStartPosition() {
-    startAutoPlay = true;
-    startWindow = C.INDEX_UNSET;
-    startPosition = C.TIME_UNSET;
-  }
-
-  /** Returns a new DataSource factory. */
-  private DataSource.Factory buildDataSourceFactory() {
-    return ((DemoApplication) getApplication()).buildDataSourceFactory();
-  }
-
-  /** Returns an ads media source, reusing the ads loader if one exists. */
-  private @Nullable MediaSource createAdsMediaSource(MediaSource mediaSource, Uri adTagUri) {
-    // Load the extension source using reflection so the demo app doesn't have to depend on it.
-    // The ads loader is reused for multiple playbacks, so that ad playback can resume.
-    try {
-      Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
-      if (adsLoader == null) {
-        // Full class names used so the LINT.IfChange rule triggers should any of the classes move.
-        // LINT.IfChange
-        Constructor<? extends AdsLoader> loaderConstructor =
-            loaderClass
-                .asSubclass(AdsLoader.class)
-                .getConstructor(android.content.Context.class, android.net.Uri.class);
-        // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
-        adsLoader = loaderConstructor.newInstance(this, adTagUri);
-      }
-      adsLoader.setPlayer(player);
-      AdsMediaSource.MediaSourceFactory adMediaSourceFactory =
-          new AdsMediaSource.MediaSourceFactory() {
-            @Override
-            public MediaSource createMediaSource(Uri uri) {
-              return PlayerActivity.this.buildMediaSource(uri);
+        clearStartPosition();
+        setIntent(intent);
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        if (Util.SDK_INT > 23) {
+            initializePlayer();
+            if (playerView != null) {
+                playerView.onResume();
             }
+        }
+    }
 
-            @Override
-            public int[] getSupportedTypes() {
-              return new int[] {C.TYPE_DASH, C.TYPE_SS, C.TYPE_HLS, C.TYPE_OTHER};
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (Util.SDK_INT <= 23 || player == null) {
+            initializePlayer();
+            if (playerView != null) {
+                playerView.onResume();
             }
-          };
-      return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, playerView);
-    } catch (ClassNotFoundException e) {
-      // IMA extension not loaded.
-      return null;
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  // User controls
-
-  private void updateButtonVisibilities() {
-    debugRootView.removeAllViews();
-    if (player == null) {
-      return;
-    }
-
-    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
-    if (mappedTrackInfo == null) {
-      return;
-    }
-
-    for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
-      TrackGroupArray trackGroups = mappedTrackInfo.getTrackGroups(i);
-      if (trackGroups.length != 0) {
-        Button button = new Button(this);
-        int label;
-        switch (player.getRendererType(i)) {
-          case C.TRACK_TYPE_AUDIO:
-            label = R.string.exo_track_selection_title_audio;
-            break;
-          case C.TRACK_TYPE_VIDEO:
-            label = R.string.exo_track_selection_title_video;
-            break;
-          case C.TRACK_TYPE_TEXT:
-            label = R.string.exo_track_selection_title_text;
-            break;
-          default:
-            continue;
-        }
-        button.setText(label);
-        button.setTag(i);
-        button.setOnClickListener(this);
-        debugRootView.addView(button);
-      }
-    }
-  }
-
-  private void showControls() {
-    debugRootView.setVisibility(View.VISIBLE);
-  }
-
-  private void showToast(int messageId) {
-    showToast(getString(messageId));
-  }
-
-  private void showToast(String message) {
-    Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
-  }
-
-  private static boolean isBehindLiveWindow(ExoPlaybackException e) {
-    if (e.type != ExoPlaybackException.TYPE_SOURCE) {
-      return false;
-    }
-    Throwable cause = e.getSourceException();
-    while (cause != null) {
-      if (cause instanceof BehindLiveWindowException) {
-        return true;
-      }
-      cause = cause.getCause();
-    }
-    return false;
-  }
-
-  private class PlayerEventListener implements Player.EventListener {
+        }
+    }
 
     @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      if (playbackState == Player.STATE_ENDED) {
-        showControls();
-      }
-      updateButtonVisibilities();
+    public void onPause() {
+        super.onPause();
+        if (Util.SDK_INT <= 23) {
+            if (playerView != null) {
+                playerView.onPause();
+            }
+            releasePlayer();
+        }
     }
 
     @Override
-    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
-      if (player.getPlaybackError() != null) {
-        // The user has performed a seek whilst in the error state. Update the resume position so
-        // that if the user then retries, playback resumes from the position to which they seeked.
-        updateStartPosition();
-      }
+    public void onStop() {
+        super.onStop();
+        if (Util.SDK_INT > 23) {
+            if (playerView != null) {
+                playerView.onPause();
+            }
+            releasePlayer();
+        }
     }
 
     @Override
-    public void onPlayerError(ExoPlaybackException e) {
-      if (isBehindLiveWindow(e)) {
-        clearStartPosition();
-        initializePlayer();
-      } else {
+    public void onDestroy() {
+        super.onDestroy();
+        releaseAdsLoader();
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
+                                           @NonNull int[] grantResults) {
+        if (grantResults.length == 0) {
+            // Empty results are triggered if a permission is requested while another request was already
+            // pending and can be safely ignored in this case.
+            return;
+        }
+        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+            initializePlayer();
+        } else {
+            showToast(R.string.storage_permission_denied);
+            finish();
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        updateTrackSelectorParameters();
         updateStartPosition();
-        updateButtonVisibilities();
-        showControls();
-      }
+        outState.putParcelable(KEY_TRACK_SELECTOR_PARAMETERS, trackSelectorParameters);
+        outState.putBoolean(KEY_AUTO_PLAY, startAutoPlay);
+        outState.putInt(KEY_WINDOW, startWindow);
+        outState.putLong(KEY_POSITION, startPosition);
     }
 
+    // Activity input
+
     @Override
-    @SuppressWarnings("ReferenceEquality")
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-      updateButtonVisibilities();
-      if (trackGroups != lastSeenTrackGroupArray) {
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        // See whether the player view wants to handle media or DPAD keys events.
+        return playerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
+    }
+
+    // OnClickListener methods
+
+    @Override
+    public void onClick(View view) {
+        if (view.getParent() == debugRootView) {
+            MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+            if (mappedTrackInfo != null) {
+                CharSequence title = ((Button) view).getText();
+                int rendererIndex = (int) view.getTag();
+                int rendererType = mappedTrackInfo.getRendererType(rendererIndex);
+                boolean allowAdaptiveSelections =
+                        rendererType == C.TRACK_TYPE_VIDEO
+                                || (rendererType == C.TRACK_TYPE_AUDIO
+                                && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
+                                == MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);
+                Pair<AlertDialog, TrackSelectionView> dialogPair =
+                        TrackSelectionView.getDialog(this, title, trackSelector, rendererIndex);
+                dialogPair.second.setShowDisableOption(true);
+                dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);
+                dialogPair.first.show();
+            }
+        }
+    }
+
+    @Override
+    public void onQualityChangeClicked(@NonNull ImageView qualityChangeView) {
         MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
         if (mappedTrackInfo != null) {
-          if (mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
-              == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
-            showToast(R.string.error_unsupported_video);
-          }
-          if (mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_AUDIO)
-              == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
-            showToast(R.string.error_unsupported_audio);
-          }
+            int rendererType = mappedTrackInfo.getRendererType(videoRendererIndex);
+            boolean allowAdaptiveSelections =
+                    rendererType == C.TRACK_TYPE_VIDEO
+                            || (rendererType == C.TRACK_TYPE_AUDIO
+                            && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
+                            == MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);
+            Pair<AlertDialog, TrackSelectionView> dialogPair =
+                    TrackSelectionView.getDialog(this, "Video", trackSelector, videoRendererIndex);
+            dialogPair.second.setShowDisableOption(true);
+            dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);
+            dialogPair.first.show();
         }
-        lastSeenTrackGroupArray = trackGroups;
-      }
     }
-  }
 
-  private class PlayerErrorMessageProvider implements ErrorMessageProvider<ExoPlaybackException> {
+    @Override
+    public void onFullScreenButtonClicked(@NonNull ImageView fullScreenView) {
+        //todo onFullScreenButtonClicked
+    }
+
+    // PlaybackControlView.PlaybackPreparer implementation
 
     @Override
-    public Pair<Integer, String> getErrorMessage(ExoPlaybackException e) {
-      String errorString = getString(R.string.error_generic);
-      if (e.type == ExoPlaybackException.TYPE_RENDERER) {
-        Exception cause = e.getRendererException();
-        if (cause instanceof DecoderInitializationException) {
-          // Special case for decoder initialization failures.
-          DecoderInitializationException decoderInitializationException =
-              (DecoderInitializationException) cause;
-          if (decoderInitializationException.decoderName == null) {
-            if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
-              errorString = getString(R.string.error_querying_decoders);
-            } else if (decoderInitializationException.secureDecoderRequired) {
-              errorString =
-                  getString(
-                      R.string.error_no_secure_decoder, decoderInitializationException.mimeType);
+    public void preparePlayback() {
+        initializePlayer();
+    }
+
+    // PlaybackControlView.VisibilityListener implementation
+
+    @Override
+    public void onVisibilityChange(int visibility) {
+        debugRootView.setVisibility(visibility);
+    }
+
+    // Internal methods
+
+    private void initializePlayer() {
+        if (player == null) {
+            Intent intent = getIntent();
+            String action = intent.getAction();
+            Uri[] uris;
+            String[] extensions;
+            if (ACTION_VIEW.equals(action)) {
+                uris = new Uri[]{intent.getData()};
+                extensions = new String[]{intent.getStringExtra(EXTENSION_EXTRA)};
+            } else if (ACTION_VIEW_LIST.equals(action)) {
+                String[] uriStrings = intent.getStringArrayExtra(URI_LIST_EXTRA);
+                uris = new Uri[uriStrings.length];
+                for (int i = 0; i < uriStrings.length; i++) {
+                    uris[i] = Uri.parse(uriStrings[i]);
+                }
+                extensions = intent.getStringArrayExtra(EXTENSION_LIST_EXTRA);
+                if (extensions == null) {
+                    extensions = new String[uriStrings.length];
+                }
             } else {
-              errorString =
-                  getString(R.string.error_no_decoder, decoderInitializationException.mimeType);
+                showToast(getString(R.string.unexpected_intent_action, action));
+                finish();
+                return;
+            }
+            if (!Util.checkCleartextTrafficPermitted(uris)) {
+                showToast(R.string.error_cleartext_not_permitted);
+                return;
+            }
+            if (Util.maybeRequestReadExternalStoragePermission(/* activity= */ this, uris)) {
+                // The player will be reinitialized if the permission is granted.
+                return;
+            }
+
+            DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
+            if (intent.hasExtra(DRM_SCHEME_EXTRA) || intent.hasExtra(DRM_SCHEME_UUID_EXTRA)) {
+                String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL_EXTRA);
+                String[] keyRequestPropertiesArray =
+                        intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES_EXTRA);
+                boolean multiSession = intent.getBooleanExtra(DRM_MULTI_SESSION_EXTRA, false);
+                int errorStringId = R.string.error_drm_unknown;
+                if (Util.SDK_INT < 18) {
+                    errorStringId = R.string.error_drm_not_supported;
+                } else {
+                    try {
+                        String drmSchemeExtra = intent.hasExtra(DRM_SCHEME_EXTRA) ? DRM_SCHEME_EXTRA
+                                : DRM_SCHEME_UUID_EXTRA;
+                        UUID drmSchemeUuid = Util.getDrmUuid(intent.getStringExtra(drmSchemeExtra));
+                        if (drmSchemeUuid == null) {
+                            errorStringId = R.string.error_drm_unsupported_scheme;
+                        } else {
+                            drmSessionManager =
+                                    buildDrmSessionManagerV18(
+                                            drmSchemeUuid, drmLicenseUrl, keyRequestPropertiesArray, multiSession);
+                        }
+                    } catch (UnsupportedDrmException e) {
+                        errorStringId = e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
+                                ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown;
+                    }
+                }
+                if (drmSessionManager == null) {
+                    showToast(errorStringId);
+                    finish();
+                    return;
+                }
+            }
+
+            TrackSelection.Factory trackSelectionFactory;
+            String abrAlgorithm = intent.getStringExtra(ABR_ALGORITHM_EXTRA);
+            if (abrAlgorithm == null || ABR_ALGORITHM_DEFAULT.equals(abrAlgorithm)) {
+                trackSelectionFactory = new AdaptiveTrackSelection.Factory();
+            } else if (ABR_ALGORITHM_RANDOM.equals(abrAlgorithm)) {
+                trackSelectionFactory = new RandomTrackSelection.Factory();
+            } else {
+                showToast(R.string.error_unrecognized_abr_algorithm);
+                finish();
+                return;
+            }
+
+            boolean preferExtensionDecoders =
+                    intent.getBooleanExtra(PREFER_EXTENSION_DECODERS_EXTRA, false);
+            @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode =
+                    ((DemoApplication) getApplication()).useExtensionRenderers()
+                            ? (preferExtensionDecoders ? DefaultRenderersFactory.EXTENSION_RENDERER_MODE_PREFER
+                            : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
+                            : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF;
+            DefaultRenderersFactory renderersFactory =
+                    new DefaultRenderersFactory(this, extensionRendererMode);
+
+            trackSelector = new DefaultTrackSelector(trackSelectionFactory);
+            trackSelector.setParameters(trackSelectorParameters);
+            lastSeenTrackGroupArray = null;
+
+            player =
+                    ExoPlayerFactory.newSimpleInstance(
+                            /* context= */ this, renderersFactory, trackSelector, drmSessionManager);
+            player.addListener(new PlayerEventListener());
+            player.setPlayWhenReady(startAutoPlay);
+            player.addAnalyticsListener(new EventLogger(trackSelector));
+            playerView.setPlayer(player);
+            playerView.setPlaybackPreparer(this);
+            debugViewHelper = new DebugTextViewHelper(player, debugTextView);
+            debugViewHelper.start();
+
+            MediaSource[] mediaSources = new MediaSource[uris.length];
+            for (int i = 0; i < uris.length; i++) {
+                mediaSources[i] = buildMediaSource(uris[i], extensions[i]);
+            }
+            mediaSource =
+                    mediaSources.length == 1 ? mediaSources[0] : new ConcatenatingMediaSource(mediaSources);
+            String adTagUriString = intent.getStringExtra(AD_TAG_URI_EXTRA);
+            if (adTagUriString != null) {
+                Uri adTagUri = Uri.parse(adTagUriString);
+                if (!adTagUri.equals(loadedAdTagUri)) {
+                    releaseAdsLoader();
+                    loadedAdTagUri = adTagUri;
+                }
+                MediaSource adsMediaSource = createAdsMediaSource(mediaSource, Uri.parse(adTagUriString));
+                if (adsMediaSource != null) {
+                    mediaSource = adsMediaSource;
+                } else {
+                    showToast(R.string.ima_not_loaded);
+                }
+            } else {
+                releaseAdsLoader();
+            }
+        }
+        boolean haveStartPosition = startWindow != C.INDEX_UNSET;
+        if (haveStartPosition) {
+            player.seekTo(startWindow, startPosition);
+        }
+        player.prepare(mediaSource, !haveStartPosition, false);
+        updateButtonVisibilities();
+    }
+
+    private MediaSource buildMediaSource(Uri uri) {
+        return buildMediaSource(uri, null);
+    }
+
+    private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
+        @ContentType int type = Util.inferContentType(uri, overrideExtension);
+        switch (type) {
+            case C.TYPE_DASH:
+                return new DashMediaSource.Factory(dataSourceFactory)
+                        .setManifestParser(
+                                new FilteringManifestParser<>(new DashManifestParser(), getOfflineStreamKeys(uri)))
+                        .createMediaSource(uri);
+            case C.TYPE_SS:
+                return new SsMediaSource.Factory(dataSourceFactory)
+                        .setManifestParser(
+                                new FilteringManifestParser<>(new SsManifestParser(), getOfflineStreamKeys(uri)))
+                        .createMediaSource(uri);
+            case C.TYPE_HLS:
+                return new HlsMediaSource.Factory(dataSourceFactory)
+                        .setPlaylistParserFactory(
+                                new DefaultHlsPlaylistParserFactory(getOfflineStreamKeys(uri)))
+                        .createMediaSource(uri);
+            case C.TYPE_OTHER:
+                return new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(uri);
+            default: {
+                throw new IllegalStateException("Unsupported type: " + type);
+            }
+        }
+    }
+
+    private List<StreamKey> getOfflineStreamKeys(Uri uri) {
+        return ((DemoApplication) getApplication()).getDownloadTracker().getOfflineStreamKeys(uri);
+    }
+
+    private DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(
+            UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
+            throws UnsupportedDrmException {
+        HttpDataSource.Factory licenseDataSourceFactory =
+                ((DemoApplication) getApplication()).buildHttpDataSourceFactory();
+        HttpMediaDrmCallback drmCallback =
+                new HttpMediaDrmCallback(licenseUrl, licenseDataSourceFactory);
+        if (keyRequestPropertiesArray != null) {
+            for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
+                drmCallback.setKeyRequestProperty(keyRequestPropertiesArray[i],
+                        keyRequestPropertiesArray[i + 1]);
+            }
+        }
+        releaseMediaDrm();
+        mediaDrm = FrameworkMediaDrm.newInstance(uuid);
+        return new DefaultDrmSessionManager<>(uuid, mediaDrm, drmCallback, null, multiSession);
+    }
+
+    private void releasePlayer() {
+        if (player != null) {
+            updateTrackSelectorParameters();
+            updateStartPosition();
+            debugViewHelper.stop();
+            debugViewHelper = null;
+            player.release();
+            player = null;
+            mediaSource = null;
+            trackSelector = null;
+        }
+        if (adsLoader != null) {
+            adsLoader.setPlayer(null);
+        }
+        releaseMediaDrm();
+    }
+
+    private void releaseMediaDrm() {
+        if (mediaDrm != null) {
+            mediaDrm.release();
+            mediaDrm = null;
+        }
+    }
+
+    private void releaseAdsLoader() {
+        if (adsLoader != null) {
+            adsLoader.release();
+            adsLoader = null;
+            loadedAdTagUri = null;
+            playerView.getOverlayFrameLayout().removeAllViews();
+        }
+    }
+
+    private void updateTrackSelectorParameters() {
+        if (trackSelector != null) {
+            trackSelectorParameters = trackSelector.getParameters();
+        }
+    }
+
+    private void updateStartPosition() {
+        if (player != null) {
+            startAutoPlay = player.getPlayWhenReady();
+            startWindow = player.getCurrentWindowIndex();
+            startPosition = Math.max(0, player.getContentPosition());
+        }
+    }
+
+    private void clearStartPosition() {
+        startAutoPlay = true;
+        startWindow = C.INDEX_UNSET;
+        startPosition = C.TIME_UNSET;
+    }
+
+    /**
+     * Returns a new DataSource factory.
+     */
+    private DataSource.Factory buildDataSourceFactory() {
+        return ((DemoApplication) getApplication()).buildDataSourceFactory();
+    }
+
+    /**
+     * Returns an ads media source, reusing the ads loader if one exists.
+     */
+    private @Nullable
+    MediaSource createAdsMediaSource(MediaSource mediaSource, Uri adTagUri) {
+        // Load the extension source using reflection so the demo app doesn't have to depend on it.
+        // The ads loader is reused for multiple playbacks, so that ad playback can resume.
+        try {
+            Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
+            if (adsLoader == null) {
+                // Full class names used so the LINT.IfChange rule triggers should any of the classes move.
+                // LINT.IfChange
+                Constructor<? extends AdsLoader> loaderConstructor =
+                        loaderClass
+                                .asSubclass(AdsLoader.class)
+                                .getConstructor(android.content.Context.class, android.net.Uri.class);
+                // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+                adsLoader = loaderConstructor.newInstance(this, adTagUri);
+            }
+            adsLoader.setPlayer(player);
+            AdsMediaSource.MediaSourceFactory adMediaSourceFactory =
+                    new AdsMediaSource.MediaSourceFactory() {
+                        @Override
+                        public MediaSource createMediaSource(Uri uri) {
+                            return PlayerActivity.this.buildMediaSource(uri);
+                        }
+
+                        @Override
+                        public int[] getSupportedTypes() {
+                            return new int[]{C.TYPE_DASH, C.TYPE_SS, C.TYPE_HLS, C.TYPE_OTHER};
+                        }
+                    };
+            return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, playerView);
+        } catch (ClassNotFoundException e) {
+            // IMA extension not loaded.
+            return null;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    // User controls
+
+    private void updateButtonVisibilities() {
+        debugRootView.removeAllViews();
+        if (player == null) {
+            return;
+        }
+
+        MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+        if (mappedTrackInfo == null) {
+            return;
+        }
+
+        for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
+            TrackGroupArray trackGroups = mappedTrackInfo.getTrackGroups(i);
+            if (trackGroups.length != 0) {
+                Button button = new Button(this);
+                int label;
+                switch (player.getRendererType(i)) {
+                    case C.TRACK_TYPE_AUDIO:
+                        label = R.string.exo_track_selection_title_audio;
+                        break;
+                    case C.TRACK_TYPE_VIDEO:
+                        videoRendererIndex = i;
+                        label = R.string.exo_track_selection_title_video;
+                        break;
+                    case C.TRACK_TYPE_TEXT:
+                        label = R.string.exo_track_selection_title_text;
+                        break;
+                    default:
+                        continue;
+                }
+                button.setText(label);
+                button.setTag(i);
+                button.setOnClickListener(this);
+                debugRootView.addView(button);
+            }
+        }
+    }
+
+    private void showControls() {
+        debugRootView.setVisibility(View.VISIBLE);
+    }
+
+    private void showToast(int messageId) {
+        showToast(getString(messageId));
+    }
+
+    private void showToast(String message) {
+        Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
+    }
+
+    private static boolean isBehindLiveWindow(ExoPlaybackException e) {
+        if (e.type != ExoPlaybackException.TYPE_SOURCE) {
+            return false;
+        }
+        Throwable cause = e.getSourceException();
+        while (cause != null) {
+            if (cause instanceof BehindLiveWindowException) {
+                return true;
+            }
+            cause = cause.getCause();
+        }
+        return false;
+    }
+
+    private class PlayerEventListener implements Player.EventListener {
+
+        @Override
+        public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+            if (playbackState == Player.STATE_ENDED) {
+                showControls();
+            }
+            updateButtonVisibilities();
+        }
+
+        @Override
+        public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+            if (player.getPlaybackError() != null) {
+                // The user has performed a seek whilst in the error state. Update the resume position so
+                // that if the user then retries, playback resumes from the position to which they seeked.
+                updateStartPosition();
+            }
+        }
+
+        @Override
+        public void onPlayerError(ExoPlaybackException e) {
+            if (isBehindLiveWindow(e)) {
+                clearStartPosition();
+                initializePlayer();
+            } else {
+                updateStartPosition();
+                updateButtonVisibilities();
+                showControls();
+            }
+        }
+
+        @Override
+        @SuppressWarnings("ReferenceEquality")
+        public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+            updateButtonVisibilities();
+            if (trackGroups != lastSeenTrackGroupArray) {
+                MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+                if (mappedTrackInfo != null) {
+                    if (mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
+                            == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+                        showToast(R.string.error_unsupported_video);
+                    }
+                    if (mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_AUDIO)
+                            == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+                        showToast(R.string.error_unsupported_audio);
+                    }
+                }
+                lastSeenTrackGroupArray = trackGroups;
+            }
+        }
+    }
+
+    private class PlayerErrorMessageProvider implements ErrorMessageProvider<ExoPlaybackException> {
+
+        @Override
+        public Pair<Integer, String> getErrorMessage(ExoPlaybackException e) {
+            String errorString = getString(R.string.error_generic);
+            if (e.type == ExoPlaybackException.TYPE_RENDERER) {
+                Exception cause = e.getRendererException();
+                if (cause instanceof DecoderInitializationException) {
+                    // Special case for decoder initialization failures.
+                    DecoderInitializationException decoderInitializationException =
+                            (DecoderInitializationException) cause;
+                    if (decoderInitializationException.decoderName == null) {
+                        if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
+                            errorString = getString(R.string.error_querying_decoders);
+                        } else if (decoderInitializationException.secureDecoderRequired) {
+                            errorString =
+                                    getString(
+                                            R.string.error_no_secure_decoder, decoderInitializationException.mimeType);
+                        } else {
+                            errorString =
+                                    getString(R.string.error_no_decoder, decoderInitializationException.mimeType);
+                        }
+                    } else {
+                        errorString =
+                                getString(
+                                        R.string.error_instantiating_decoder,
+                                        decoderInitializationException.decoderName);
+                    }
+                }
             }
-          } else {
-            errorString =
-                getString(
-                    R.string.error_instantiating_decoder,
-                    decoderInitializationException.decoderName);
-          }
+            return Pair.create(0, errorString);
         }
-      }
-      return Pair.create(0, errorString);
     }
-  }
 
 }
diff --git a/demos/main/src/main/res/layout/player_activity.xml b/demos/main/src/main/res/layout/player_activity.xml
index 8546d6ece6..c0a83f96e8 100644
--- a/demos/main/src/main/res/layout/player_activity.xml
+++ b/demos/main/src/main/res/layout/player_activity.xml
@@ -1,5 +1,4 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?><!-- Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -20,31 +19,34 @@
     android:layout_height="match_parent"
     android:keepScreenOn="true">
 
-  <com.google.android.exoplayer2.ui.PlayerView android:id="@+id/player_view"
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"/>
-
-  <LinearLayout
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:background="#88000000"
-      android:orientation="vertical">
-
-    <TextView android:id="@+id/debug_text_view"
+    <com.google.android.exoplayer2.ui.PlayerView
+        android:id="@+id/player_view"
         android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:paddingLeft="4dp"
-        android:paddingRight="4dp"
-        android:textSize="10sp"
-        tools:ignore="SmallSp"/>
+        android:layout_height="match_parent" />
 
-    <LinearLayout android:id="@+id/controls_root"
+    <LinearLayout
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
-        android:orientation="horizontal"
-      tools:visibility="visible"
-        android:visibility="gone"/>
-
-  </LinearLayout>
+        android:background="#88000000"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/debug_text_view"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:paddingLeft="4dp"
+            android:paddingRight="4dp"
+            android:textSize="10sp"
+            tools:ignore="SmallSp" />
+
+        <LinearLayout
+            android:id="@+id/controls_root"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal"
+            android:visibility="gone"
+            tools:visibility="visible" />
+
+    </LinearLayout>
 
 </FrameLayout>
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultRoundedTimeBar.kt b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultRoundedTimeBar.kt
new file mode 100644
index 0000000000..61e8364e5e
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultRoundedTimeBar.kt
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui
+
+import android.content.Context
+import android.graphics.Canvas
+import android.os.Build
+import android.support.annotation.RequiresApi
+import android.util.AttributeSet
+import com.google.android.exoplayer2.util.Assertions
+import com.google.android.exoplayer2.util.Util
+
+/**
+ * A time bar that shows a current position, buffered position, duration and ad markers.
+ *
+ *
+ * A DefaultTimeBar can be customized by setting attributes, as outlined below.
+ *
+ * <h3>Attributes</h3>
+ *
+ * The following attributes can be set on a DefaultTimeBar when used in a layout XML file:
+ *
+ *
+ *
+ *
+ *
+ *  * **`bar_height`** - Dimension for the height of the time bar.
+ *
+ *  * Default: [.DEFAULT_BAR_HEIGHT_DP]
+ *
+ *  * **`touch_target_height`** - Dimension for the height of the area in which touch
+ * interactions with the time bar are handled. If no height is specified, this also determines
+ * the height of the view.
+ *
+ *  * Default: [.DEFAULT_TOUCH_TARGET_HEIGHT_DP]
+ *
+ *  * **`ad_marker_width`** - Dimension for the width of any ad markers shown on the
+ * bar. Ad markers are superimposed on the time bar to show the times at which ads will play.
+ *
+ *  * Default: [.DEFAULT_AD_MARKER_WIDTH_DP]
+ *
+ *  * **`scrubber_enabled_size`** - Dimension for the diameter of the circular scrubber
+ * handle when scrubbing is enabled but not in progress. Set to zero if no scrubber handle
+ * should be shown.
+ *
+ *  * Default: [.DEFAULT_SCRUBBER_ENABLED_SIZE_DP]
+ *
+ *  * **`scrubber_disabled_size`** - Dimension for the diameter of the circular scrubber
+ * handle when scrubbing isn't enabled. Set to zero if no scrubber handle should be shown.
+ *
+ *  * Default: [.DEFAULT_SCRUBBER_DISABLED_SIZE_DP]
+ *
+ *  * **`scrubber_dragged_size`** - Dimension for the diameter of the circular scrubber
+ * handle when scrubbing is in progress. Set to zero if no scrubber handle should be shown.
+ *
+ *  * Default: [.DEFAULT_SCRUBBER_DRAGGED_SIZE_DP]
+ *
+ *  * **`scrubber_drawable`** - Optional reference to a drawable to draw for the
+ * scrubber handle. If set, this overrides the default behavior, which is to draw a circle for
+ * the scrubber handle.
+ *  * **`played_color`** - Color for the portion of the time bar representing media
+ * before the current playback position.
+ *
+ *  * Corresponding method: [.setPlayedColor]
+ *  * Default: [.DEFAULT_PLAYED_COLOR]
+ *
+ *  * **`scrubber_color`** - Color for the scrubber handle.
+ *
+ *  * Corresponding method: [.setScrubberColor]
+ *  * Default: see [.getDefaultScrubberColor]
+ *
+ *  * **`buffered_color`** - Color for the portion of the time bar after the current
+ * played position up to the current buffered position.
+ *
+ *  * Corresponding method: [.setBufferedColor]
+ *  * Default: see [.getDefaultBufferedColor]
+ *
+ *  * **`unplayed_color`** - Color for the portion of the time bar after the current
+ * buffered position.
+ *
+ *  * Corresponding method: [.setUnplayedColor]
+ *  * Default: see [.getDefaultUnplayedColor]
+ *
+ *  * **`ad_marker_color`** - Color for unplayed ad markers.
+ *
+ *  * Corresponding method: [.setAdMarkerColor]
+ *  * Default: [.DEFAULT_AD_MARKER_COLOR]
+ *
+ *  * **`played_ad_marker_color`** - Color for played ad markers.
+ *
+ *  * Corresponding method: [.setPlayedAdMarkerColor]
+ *  * Default: see [.getDefaultPlayedAdMarkerColor]
+ *
+ *
+ */
+@RequiresApi(Build.VERSION_CODES.LOLLIPOP)
+class DefaultRoundedTimeBar
+/** Creates a new time bar.  */
+// Suppress warnings due to usage of View methods in the constructor.
+(context: Context, attrs: AttributeSet?) : DefaultTimeBar(context, attrs), TimeBar {
+
+    private val cornersRadius: Float
+
+    init {
+
+        val defaultCornersRadius = (5 * context.resources.displayMetrics.density)
+        if (attrs != null) {
+            val a = context.theme.obtainStyledAttributes(attrs, R.styleable.DefaultRoundedTimeBar, 0,
+                    0)
+            try {
+                cornersRadius = a.getDimension(R.styleable.DefaultRoundedTimeBar_corners_radius, defaultCornersRadius)
+            } finally {
+                a.recycle()
+            }
+        } else {
+            cornersRadius = defaultCornersRadius
+        }
+    }
+
+    protected override fun drawTimeBar(canvas: Canvas) {
+        val progressBarHeight = progressBar.height()
+        val barTop = progressBar.centerY() - progressBarHeight / 2
+        val barBottom = barTop + progressBarHeight
+        if (getDuration() <= 0) {
+            canvas.drawRoundRect(
+                    progressBar.left.toFloat(),
+                    barTop.toFloat(),
+                    progressBar.right.toFloat(),
+                    barBottom.toFloat(),
+                    cornersRadius,
+                    cornersRadius,
+                    unplayedPaint
+            )
+            return
+        }
+        var bufferedLeft = bufferedBar.left
+        val bufferedRight = bufferedBar.right
+        val progressLeft = Math.max(Math.max(progressBar.left, bufferedRight), scrubberBar.right)
+        if (progressLeft < progressBar.right) {
+            canvas.drawRoundRect(
+                    progressLeft.toFloat(),
+                    barTop.toFloat(),
+                    progressBar.right.toFloat(),
+                    barBottom.toFloat(),
+                    cornersRadius,
+                    cornersRadius,
+                    unplayedPaint
+            )
+        }
+        bufferedLeft = Math.max(bufferedLeft, scrubberBar.right)
+        if (bufferedRight > bufferedLeft) {
+            canvas.drawRoundRect(
+                    bufferedLeft.toFloat(),
+                    barTop.toFloat(),
+                    bufferedRight.toFloat(),
+                    barBottom.toFloat(),
+                    cornersRadius,
+                    cornersRadius,
+                    bufferedPaint
+            )
+        }
+        if (scrubberBar.width() > 0) {
+            canvas.drawRoundRect(
+                    scrubberBar.left.toFloat(),
+                    barTop.toFloat(),
+                    scrubberBar.right.toFloat(),
+                    barBottom.toFloat(),
+                    cornersRadius,
+                    cornersRadius,
+                    playedPaint
+            )
+        }
+        if (adGroupCount == 0) {
+            return
+        }
+        val adGroupTimesMs = Assertions.checkNotNull(this.adGroupTimesMs)
+        val playedAdGroups = Assertions.checkNotNull(this.playedAdGroups)
+        val adMarkerOffset = adMarkerWidth / 2
+        for (i in 0 until adGroupCount) {
+            val adGroupTimeMs = Util.constrainValue(adGroupTimesMs[i], 0, getDuration())
+            val markerPositionOffset = (progressBar.width() * adGroupTimeMs / getDuration()).toInt() - adMarkerOffset
+            val markerLeft = progressBar.left + Math.min(progressBar.width() - adMarkerWidth,
+                    Math.max(0, markerPositionOffset))
+            val paint = if (playedAdGroups[i]) playedAdMarkerPaint else adMarkerPaint
+            canvas.drawRoundRect(
+                    markerLeft.toFloat(),
+                    barTop.toFloat(),
+                    (markerLeft + adMarkerWidth).toFloat(),
+                    barBottom.toFloat(),
+                    cornersRadius,
+                    cornersRadius,
+                    paint
+            )
+        }
+    }
+
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
deleted file mode 100644
index 75c4f71b64..0000000000
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ /dev/null
@@ -1,846 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.ui;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.support.annotation.ColorInt;
-import android.support.annotation.Nullable;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewParent;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityNodeInfo;
-import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
-import java.util.Formatter;
-import java.util.Locale;
-import java.util.concurrent.CopyOnWriteArraySet;
-
-/**
- * A time bar that shows a current position, buffered position, duration and ad markers.
- *
- * <p>A DefaultTimeBar can be customized by setting attributes, as outlined below.
- *
- * <h3>Attributes</h3>
- *
- * The following attributes can be set on a DefaultTimeBar when used in a layout XML file:
- *
- * <p>
- *
- * <ul>
- *   <li><b>{@code bar_height}</b> - Dimension for the height of the time bar.
- *       <ul>
- *         <li>Default: {@link #DEFAULT_BAR_HEIGHT_DP}
- *       </ul>
- *   <li><b>{@code touch_target_height}</b> - Dimension for the height of the area in which touch
- *       interactions with the time bar are handled. If no height is specified, this also determines
- *       the height of the view.
- *       <ul>
- *         <li>Default: {@link #DEFAULT_TOUCH_TARGET_HEIGHT_DP}
- *       </ul>
- *   <li><b>{@code ad_marker_width}</b> - Dimension for the width of any ad markers shown on the
- *       bar. Ad markers are superimposed on the time bar to show the times at which ads will play.
- *       <ul>
- *         <li>Default: {@link #DEFAULT_AD_MARKER_WIDTH_DP}
- *       </ul>
- *   <li><b>{@code scrubber_enabled_size}</b> - Dimension for the diameter of the circular scrubber
- *       handle when scrubbing is enabled but not in progress. Set to zero if no scrubber handle
- *       should be shown.
- *       <ul>
- *         <li>Default: {@link #DEFAULT_SCRUBBER_ENABLED_SIZE_DP}
- *       </ul>
- *   <li><b>{@code scrubber_disabled_size}</b> - Dimension for the diameter of the circular scrubber
- *       handle when scrubbing isn't enabled. Set to zero if no scrubber handle should be shown.
- *       <ul>
- *         <li>Default: {@link #DEFAULT_SCRUBBER_DISABLED_SIZE_DP}
- *       </ul>
- *   <li><b>{@code scrubber_dragged_size}</b> - Dimension for the diameter of the circular scrubber
- *       handle when scrubbing is in progress. Set to zero if no scrubber handle should be shown.
- *       <ul>
- *         <li>Default: {@link #DEFAULT_SCRUBBER_DRAGGED_SIZE_DP}
- *       </ul>
- *   <li><b>{@code scrubber_drawable}</b> - Optional reference to a drawable to draw for the
- *       scrubber handle. If set, this overrides the default behavior, which is to draw a circle for
- *       the scrubber handle.
- *   <li><b>{@code played_color}</b> - Color for the portion of the time bar representing media
- *       before the current playback position.
- *       <ul>
- *         <li>Corresponding method: {@link #setPlayedColor(int)}
- *         <li>Default: {@link #DEFAULT_PLAYED_COLOR}
- *       </ul>
- *   <li><b>{@code scrubber_color}</b> - Color for the scrubber handle.
- *       <ul>
- *         <li>Corresponding method: {@link #setScrubberColor(int)}
- *         <li>Default: see {@link #getDefaultScrubberColor(int)}
- *       </ul>
- *   <li><b>{@code buffered_color}</b> - Color for the portion of the time bar after the current
- *       played position up to the current buffered position.
- *       <ul>
- *         <li>Corresponding method: {@link #setBufferedColor(int)}
- *         <li>Default: see {@link #getDefaultBufferedColor(int)}
- *       </ul>
- *   <li><b>{@code unplayed_color}</b> - Color for the portion of the time bar after the current
- *       buffered position.
- *       <ul>
- *         <li>Corresponding method: {@link #setUnplayedColor(int)}
- *         <li>Default: see {@link #getDefaultUnplayedColor(int)}
- *       </ul>
- *   <li><b>{@code ad_marker_color}</b> - Color for unplayed ad markers.
- *       <ul>
- *         <li>Corresponding method: {@link #setAdMarkerColor(int)}
- *         <li>Default: {@link #DEFAULT_AD_MARKER_COLOR}
- *       </ul>
- *   <li><b>{@code played_ad_marker_color}</b> - Color for played ad markers.
- *       <ul>
- *         <li>Corresponding method: {@link #setPlayedAdMarkerColor(int)}
- *         <li>Default: see {@link #getDefaultPlayedAdMarkerColor(int)}
- *       </ul>
- * </ul>
- */
-public class DefaultTimeBar extends View implements TimeBar {
-
-  /**
-   * Default height for the time bar, in dp.
-   */
-  public static final int DEFAULT_BAR_HEIGHT_DP = 4;
-  /**
-   * Default height for the touch target, in dp.
-   */
-  public static final int DEFAULT_TOUCH_TARGET_HEIGHT_DP = 26;
-  /**
-   * Default width for ad markers, in dp.
-   */
-  public static final int DEFAULT_AD_MARKER_WIDTH_DP = 4;
-  /**
-   * Default diameter for the scrubber when enabled, in dp.
-   */
-  public static final int DEFAULT_SCRUBBER_ENABLED_SIZE_DP = 12;
-  /**
-   * Default diameter for the scrubber when disabled, in dp.
-   */
-  public static final int DEFAULT_SCRUBBER_DISABLED_SIZE_DP = 0;
-  /**
-   * Default diameter for the scrubber when dragged, in dp.
-   */
-  public static final int DEFAULT_SCRUBBER_DRAGGED_SIZE_DP = 16;
-  /**
-   * Default color for the played portion of the time bar.
-   */
-  public static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
-  /**
-   * Default color for ad markers.
-   */
-  public static final int DEFAULT_AD_MARKER_COLOR = 0xB2FFFF00;
-
-  /**
-   * The threshold in dps above the bar at which touch events trigger fine scrub mode.
-   */
-  private static final int FINE_SCRUB_Y_THRESHOLD_DP = -50;
-  /**
-   * The ratio by which times are reduced in fine scrub mode.
-   */
-  private static final int FINE_SCRUB_RATIO = 3;
-  /**
-   * The time after which the scrubbing listener is notified that scrubbing has stopped after
-   * performing an incremental scrub using key input.
-   */
-  private static final long STOP_SCRUBBING_TIMEOUT_MS = 1000;
-  private static final int DEFAULT_INCREMENT_COUNT = 20;
-
-  /**
-   * The name of the Android SDK view that most closely resembles this custom view. Used as the
-   * class name for accessibility.
-   */
-  private static final String ACCESSIBILITY_CLASS_NAME = "android.widget.SeekBar";
-
-  private final Rect seekBounds;
-  private final Rect progressBar;
-  private final Rect bufferedBar;
-  private final Rect scrubberBar;
-  private final Paint playedPaint;
-  private final Paint bufferedPaint;
-  private final Paint unplayedPaint;
-  private final Paint adMarkerPaint;
-  private final Paint playedAdMarkerPaint;
-  private final Paint scrubberPaint;
-  private final @Nullable Drawable scrubberDrawable;
-  private final int barHeight;
-  private final int touchTargetHeight;
-  private final int adMarkerWidth;
-  private final int scrubberEnabledSize;
-  private final int scrubberDisabledSize;
-  private final int scrubberDraggedSize;
-  private final int scrubberPadding;
-  private final int fineScrubYThreshold;
-  private final StringBuilder formatBuilder;
-  private final Formatter formatter;
-  private final Runnable stopScrubbingRunnable;
-  private final CopyOnWriteArraySet<OnScrubListener> listeners;
-  private final int[] locationOnScreen;
-  private final Point touchPosition;
-
-  private int keyCountIncrement;
-  private long keyTimeIncrement;
-  private int lastCoarseScrubXPosition;
-
-  private boolean scrubbing;
-  private long scrubPosition;
-  private long duration;
-  private long position;
-  private long bufferedPosition;
-  private int adGroupCount;
-  private @Nullable long[] adGroupTimesMs;
-  private @Nullable boolean[] playedAdGroups;
-
-  /** Creates a new time bar. */
-  // Suppress warnings due to usage of View methods in the constructor.
-  @SuppressWarnings("nullness:method.invocation.invalid")
-  public DefaultTimeBar(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    seekBounds = new Rect();
-    progressBar = new Rect();
-    bufferedBar = new Rect();
-    scrubberBar = new Rect();
-    playedPaint = new Paint();
-    bufferedPaint = new Paint();
-    unplayedPaint = new Paint();
-    adMarkerPaint = new Paint();
-    playedAdMarkerPaint = new Paint();
-    scrubberPaint = new Paint();
-    scrubberPaint.setAntiAlias(true);
-    listeners = new CopyOnWriteArraySet<>();
-    locationOnScreen = new int[2];
-    touchPosition = new Point();
-
-    // Calculate the dimensions and paints for drawn elements.
-    Resources res = context.getResources();
-    DisplayMetrics displayMetrics = res.getDisplayMetrics();
-    fineScrubYThreshold = dpToPx(displayMetrics, FINE_SCRUB_Y_THRESHOLD_DP);
-    int defaultBarHeight = dpToPx(displayMetrics, DEFAULT_BAR_HEIGHT_DP);
-    int defaultTouchTargetHeight = dpToPx(displayMetrics, DEFAULT_TOUCH_TARGET_HEIGHT_DP);
-    int defaultAdMarkerWidth = dpToPx(displayMetrics, DEFAULT_AD_MARKER_WIDTH_DP);
-    int defaultScrubberEnabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
-    int defaultScrubberDisabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
-    int defaultScrubberDraggedSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
-    if (attrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
-          0);
-      try {
-        scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
-        if (scrubberDrawable != null) {
-          setDrawableLayoutDirection(scrubberDrawable);
-          defaultTouchTargetHeight =
-              Math.max(scrubberDrawable.getMinimumHeight(), defaultTouchTargetHeight);
-        }
-        barHeight = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height,
-            defaultBarHeight);
-        touchTargetHeight = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_touch_target_height,
-            defaultTouchTargetHeight);
-        adMarkerWidth = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_ad_marker_width,
-            defaultAdMarkerWidth);
-        scrubberEnabledSize = a.getDimensionPixelSize(
-            R.styleable.DefaultTimeBar_scrubber_enabled_size, defaultScrubberEnabledSize);
-        scrubberDisabledSize = a.getDimensionPixelSize(
-            R.styleable.DefaultTimeBar_scrubber_disabled_size, defaultScrubberDisabledSize);
-        scrubberDraggedSize = a.getDimensionPixelSize(
-            R.styleable.DefaultTimeBar_scrubber_dragged_size, defaultScrubberDraggedSize);
-        int playedColor = a.getInt(R.styleable.DefaultTimeBar_played_color, DEFAULT_PLAYED_COLOR);
-        int scrubberColor = a.getInt(R.styleable.DefaultTimeBar_scrubber_color,
-            getDefaultScrubberColor(playedColor));
-        int bufferedColor = a.getInt(R.styleable.DefaultTimeBar_buffered_color,
-            getDefaultBufferedColor(playedColor));
-        int unplayedColor = a.getInt(R.styleable.DefaultTimeBar_unplayed_color,
-            getDefaultUnplayedColor(playedColor));
-        int adMarkerColor = a.getInt(R.styleable.DefaultTimeBar_ad_marker_color,
-            DEFAULT_AD_MARKER_COLOR);
-        int playedAdMarkerColor = a.getInt(R.styleable.DefaultTimeBar_played_ad_marker_color,
-            getDefaultPlayedAdMarkerColor(adMarkerColor));
-        playedPaint.setColor(playedColor);
-        scrubberPaint.setColor(scrubberColor);
-        bufferedPaint.setColor(bufferedColor);
-        unplayedPaint.setColor(unplayedColor);
-        adMarkerPaint.setColor(adMarkerColor);
-        playedAdMarkerPaint.setColor(playedAdMarkerColor);
-      } finally {
-        a.recycle();
-      }
-    } else {
-      barHeight = defaultBarHeight;
-      touchTargetHeight = defaultTouchTargetHeight;
-      adMarkerWidth = defaultAdMarkerWidth;
-      scrubberEnabledSize = defaultScrubberEnabledSize;
-      scrubberDisabledSize = defaultScrubberDisabledSize;
-      scrubberDraggedSize = defaultScrubberDraggedSize;
-      playedPaint.setColor(DEFAULT_PLAYED_COLOR);
-      scrubberPaint.setColor(getDefaultScrubberColor(DEFAULT_PLAYED_COLOR));
-      bufferedPaint.setColor(getDefaultBufferedColor(DEFAULT_PLAYED_COLOR));
-      unplayedPaint.setColor(getDefaultUnplayedColor(DEFAULT_PLAYED_COLOR));
-      adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
-      scrubberDrawable = null;
-    }
-    formatBuilder = new StringBuilder();
-    formatter = new Formatter(formatBuilder, Locale.getDefault());
-    stopScrubbingRunnable = () -> stopScrubbing(/* canceled= */ false);
-    if (scrubberDrawable != null) {
-      scrubberPadding = (scrubberDrawable.getMinimumWidth() + 1) / 2;
-    } else {
-      scrubberPadding =
-          (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1)
-              / 2;
-    }
-    duration = C.TIME_UNSET;
-    keyTimeIncrement = C.TIME_UNSET;
-    keyCountIncrement = DEFAULT_INCREMENT_COUNT;
-    setFocusable(true);
-    if (Util.SDK_INT >= 16) {
-      maybeSetImportantForAccessibilityV16();
-    }
-  }
-
-  /**
-   * Sets the color for the portion of the time bar representing media before the playback position.
-   *
-   * @param playedColor The color for the portion of the time bar representing media before the
-   *     playback position.
-   */
-  public void setPlayedColor(@ColorInt int playedColor) {
-    playedPaint.setColor(playedColor);
-    invalidate(seekBounds);
-  }
-
-  /**
-   * Sets the color for the scrubber handle.
-   *
-   * @param scrubberColor The color for the scrubber handle.
-   */
-  public void setScrubberColor(@ColorInt int scrubberColor) {
-    scrubberPaint.setColor(scrubberColor);
-    invalidate(seekBounds);
-  }
-
-  /**
-   * Sets the color for the portion of the time bar after the current played position up to the
-   * current buffered position.
-   *
-   * @param bufferedColor The color for the portion of the time bar after the current played
-   *     position up to the current buffered position.
-   */
-  public void setBufferedColor(@ColorInt int bufferedColor) {
-    bufferedPaint.setColor(bufferedColor);
-    invalidate(seekBounds);
-  }
-
-  /**
-   * Sets the color for the portion of the time bar after the current played position.
-   *
-   * @param unplayedColor The color for the portion of the time bar after the current played
-   *     position.
-   */
-  public void setUnplayedColor(@ColorInt int unplayedColor) {
-    unplayedPaint.setColor(unplayedColor);
-    invalidate(seekBounds);
-  }
-
-  /**
-   * Sets the color for unplayed ad markers.
-   *
-   * @param adMarkerColor The color for unplayed ad markers.
-   */
-  public void setAdMarkerColor(@ColorInt int adMarkerColor) {
-    adMarkerPaint.setColor(adMarkerColor);
-    invalidate(seekBounds);
-  }
-
-  /**
-   * Sets the color for played ad markers.
-   *
-   * @param playedAdMarkerColor The color for played ad markers.
-   */
-  public void setPlayedAdMarkerColor(@ColorInt int playedAdMarkerColor) {
-    playedAdMarkerPaint.setColor(playedAdMarkerColor);
-    invalidate(seekBounds);
-  }
-
-  // TimeBar implementation.
-
-  @Override
-  public void addListener(OnScrubListener listener) {
-    listeners.add(listener);
-  }
-
-  @Override
-  public void removeListener(OnScrubListener listener) {
-    listeners.remove(listener);
-  }
-
-  @Override
-  public void setKeyTimeIncrement(long time) {
-    Assertions.checkArgument(time > 0);
-    keyCountIncrement = C.INDEX_UNSET;
-    keyTimeIncrement = time;
-  }
-
-  @Override
-  public void setKeyCountIncrement(int count) {
-    Assertions.checkArgument(count > 0);
-    keyCountIncrement = count;
-    keyTimeIncrement = C.TIME_UNSET;
-  }
-
-  @Override
-  public void setPosition(long position) {
-    this.position = position;
-    setContentDescription(getProgressText());
-    update();
-  }
-
-  @Override
-  public void setBufferedPosition(long bufferedPosition) {
-    this.bufferedPosition = bufferedPosition;
-    update();
-  }
-
-  @Override
-  public void setDuration(long duration) {
-    this.duration = duration;
-    if (scrubbing && duration == C.TIME_UNSET) {
-      stopScrubbing(true);
-    }
-    update();
-  }
-
-  @Override
-  public void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] playedAdGroups,
-      int adGroupCount) {
-    Assertions.checkArgument(adGroupCount == 0
-        || (adGroupTimesMs != null && playedAdGroups != null));
-    this.adGroupCount = adGroupCount;
-    this.adGroupTimesMs = adGroupTimesMs;
-    this.playedAdGroups = playedAdGroups;
-    update();
-  }
-
-  // View methods.
-
-  @Override
-  public void setEnabled(boolean enabled) {
-    super.setEnabled(enabled);
-    if (scrubbing && !enabled) {
-      stopScrubbing(true);
-    }
-  }
-
-  @Override
-  public void onDraw(Canvas canvas) {
-    canvas.save();
-    drawTimeBar(canvas);
-    drawPlayhead(canvas);
-    canvas.restore();
-  }
-
-  @Override
-  public boolean onTouchEvent(MotionEvent event) {
-    if (!isEnabled() || duration <= 0) {
-      return false;
-    }
-    Point touchPosition = resolveRelativeTouchPosition(event);
-    int x = touchPosition.x;
-    int y = touchPosition.y;
-    switch (event.getAction()) {
-      case MotionEvent.ACTION_DOWN:
-        if (isInSeekBar(x, y)) {
-          positionScrubber(x);
-          startScrubbing();
-          scrubPosition = getScrubberPosition();
-          update();
-          invalidate();
-          return true;
-        }
-        break;
-      case MotionEvent.ACTION_MOVE:
-        if (scrubbing) {
-          if (y < fineScrubYThreshold) {
-            int relativeX = x - lastCoarseScrubXPosition;
-            positionScrubber(lastCoarseScrubXPosition + relativeX / FINE_SCRUB_RATIO);
-          } else {
-            lastCoarseScrubXPosition = x;
-            positionScrubber(x);
-          }
-          scrubPosition = getScrubberPosition();
-          for (OnScrubListener listener : listeners) {
-            listener.onScrubMove(this, scrubPosition);
-          }
-          update();
-          invalidate();
-          return true;
-        }
-        break;
-      case MotionEvent.ACTION_UP:
-      case MotionEvent.ACTION_CANCEL:
-        if (scrubbing) {
-          stopScrubbing(event.getAction() == MotionEvent.ACTION_CANCEL);
-          return true;
-        }
-        break;
-      default:
-        // Do nothing.
-    }
-    return false;
-  }
-
-  @Override
-  public boolean onKeyDown(int keyCode, KeyEvent event) {
-    if (isEnabled()) {
-      long positionIncrement = getPositionIncrement();
-      switch (keyCode) {
-        case KeyEvent.KEYCODE_DPAD_LEFT:
-          positionIncrement = -positionIncrement;
-          // Fall through.
-        case KeyEvent.KEYCODE_DPAD_RIGHT:
-          if (scrubIncrementally(positionIncrement)) {
-            removeCallbacks(stopScrubbingRunnable);
-            postDelayed(stopScrubbingRunnable, STOP_SCRUBBING_TIMEOUT_MS);
-            return true;
-          }
-          break;
-        case KeyEvent.KEYCODE_DPAD_CENTER:
-        case KeyEvent.KEYCODE_ENTER:
-          if (scrubbing) {
-            removeCallbacks(stopScrubbingRunnable);
-            stopScrubbingRunnable.run();
-            return true;
-          }
-          break;
-        default:
-          // Do nothing.
-      }
-    }
-    return super.onKeyDown(keyCode, event);
-  }
-
-  @Override
-  protected void drawableStateChanged() {
-    super.drawableStateChanged();
-    updateDrawableState();
-  }
-
-  @Override
-  public void jumpDrawablesToCurrentState() {
-    super.jumpDrawablesToCurrentState();
-    if (scrubberDrawable != null) {
-      scrubberDrawable.jumpToCurrentState();
-    }
-  }
-
-  @Override
-  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
-    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
-    int height = heightMode == MeasureSpec.UNSPECIFIED ? touchTargetHeight
-        : heightMode == MeasureSpec.EXACTLY ? heightSize : Math.min(touchTargetHeight, heightSize);
-    setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);
-    updateDrawableState();
-  }
-
-  @Override
-  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-    int width = right - left;
-    int height = bottom - top;
-    int barY = (height - touchTargetHeight) / 2;
-    int seekLeft = getPaddingLeft();
-    int seekRight = width - getPaddingRight();
-    int progressY = barY + (touchTargetHeight - barHeight) / 2;
-    seekBounds.set(seekLeft, barY, seekRight, barY + touchTargetHeight);
-    progressBar.set(seekBounds.left + scrubberPadding, progressY,
-        seekBounds.right - scrubberPadding, progressY + barHeight);
-    update();
-  }
-
-  @Override
-  public void onRtlPropertiesChanged(int layoutDirection) {
-    if (scrubberDrawable != null && setDrawableLayoutDirection(scrubberDrawable, layoutDirection)) {
-      invalidate();
-    }
-  }
-
-  @Override
-  public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
-    super.onInitializeAccessibilityEvent(event);
-    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SELECTED) {
-      event.getText().add(getProgressText());
-    }
-    event.setClassName(ACCESSIBILITY_CLASS_NAME);
-  }
-
-  @TargetApi(21)
-  @Override
-  public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
-    super.onInitializeAccessibilityNodeInfo(info);
-    info.setClassName(ACCESSIBILITY_CLASS_NAME);
-    info.setContentDescription(getProgressText());
-    if (duration <= 0) {
-      return;
-    }
-    if (Util.SDK_INT >= 21) {
-      info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);
-      info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);
-    } else if (Util.SDK_INT >= 16) {
-      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
-      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
-    }
-  }
-
-  @TargetApi(16)
-  @Override
-  public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
-    if (super.performAccessibilityAction(action, args)) {
-      return true;
-    }
-    if (duration <= 0) {
-      return false;
-    }
-    if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
-      if (scrubIncrementally(-getPositionIncrement())) {
-        stopScrubbing(false);
-      }
-    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
-      if (scrubIncrementally(getPositionIncrement())) {
-        stopScrubbing(false);
-      }
-    } else {
-      return false;
-    }
-    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
-    return true;
-  }
-
-  // Internal methods.
-
-  @TargetApi(16)
-  private void maybeSetImportantForAccessibilityV16() {
-    if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
-      setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
-    }
-  }
-
-  private void startScrubbing() {
-    scrubbing = true;
-    setPressed(true);
-    ViewParent parent = getParent();
-    if (parent != null) {
-      parent.requestDisallowInterceptTouchEvent(true);
-    }
-    for (OnScrubListener listener : listeners) {
-      listener.onScrubStart(this, getScrubberPosition());
-    }
-  }
-
-  private void stopScrubbing(boolean canceled) {
-    scrubbing = false;
-    setPressed(false);
-    ViewParent parent = getParent();
-    if (parent != null) {
-      parent.requestDisallowInterceptTouchEvent(false);
-    }
-    invalidate();
-    for (OnScrubListener listener : listeners) {
-      listener.onScrubStop(this, getScrubberPosition(), canceled);
-    }
-  }
-
-  private void update() {
-    bufferedBar.set(progressBar);
-    scrubberBar.set(progressBar);
-    long newScrubberTime = scrubbing ? scrubPosition : position;
-    if (duration > 0) {
-      int bufferedPixelWidth = (int) ((progressBar.width() * bufferedPosition) / duration);
-      bufferedBar.right = Math.min(progressBar.left + bufferedPixelWidth, progressBar.right);
-      int scrubberPixelPosition = (int) ((progressBar.width() * newScrubberTime) / duration);
-      scrubberBar.right = Math.min(progressBar.left + scrubberPixelPosition, progressBar.right);
-    } else {
-      bufferedBar.right = progressBar.left;
-      scrubberBar.right = progressBar.left;
-    }
-    invalidate(seekBounds);
-  }
-
-  private void positionScrubber(float xPosition) {
-    scrubberBar.right = Util.constrainValue((int) xPosition, progressBar.left, progressBar.right);
-  }
-
-  private Point resolveRelativeTouchPosition(MotionEvent motionEvent) {
-    getLocationOnScreen(locationOnScreen);
-    touchPosition.set(
-        ((int) motionEvent.getRawX()) - locationOnScreen[0],
-        ((int) motionEvent.getRawY()) - locationOnScreen[1]);
-    return touchPosition;
-  }
-
-  private long getScrubberPosition() {
-    if (progressBar.width() <= 0 || duration == C.TIME_UNSET) {
-      return 0;
-    }
-    return (scrubberBar.width() * duration) / progressBar.width();
-  }
-
-  private boolean isInSeekBar(float x, float y) {
-    return seekBounds.contains((int) x, (int) y);
-  }
-
-  private void drawTimeBar(Canvas canvas) {
-    int progressBarHeight = progressBar.height();
-    int barTop = progressBar.centerY() - progressBarHeight / 2;
-    int barBottom = barTop + progressBarHeight;
-    if (duration <= 0) {
-      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, unplayedPaint);
-      return;
-    }
-    int bufferedLeft = bufferedBar.left;
-    int bufferedRight = bufferedBar.right;
-    int progressLeft = Math.max(Math.max(progressBar.left, bufferedRight), scrubberBar.right);
-    if (progressLeft < progressBar.right) {
-      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, unplayedPaint);
-    }
-    bufferedLeft = Math.max(bufferedLeft, scrubberBar.right);
-    if (bufferedRight > bufferedLeft) {
-      canvas.drawRect(bufferedLeft, barTop, bufferedRight, barBottom, bufferedPaint);
-    }
-    if (scrubberBar.width() > 0) {
-      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, playedPaint);
-    }
-    if (adGroupCount == 0) {
-      return;
-    }
-    long[] adGroupTimesMs = Assertions.checkNotNull(this.adGroupTimesMs);
-    boolean[] playedAdGroups = Assertions.checkNotNull(this.playedAdGroups);
-    int adMarkerOffset = adMarkerWidth / 2;
-    for (int i = 0; i < adGroupCount; i++) {
-      long adGroupTimeMs = Util.constrainValue(adGroupTimesMs[i], 0, duration);
-      int markerPositionOffset =
-          (int) (progressBar.width() * adGroupTimeMs / duration) - adMarkerOffset;
-      int markerLeft = progressBar.left + Math.min(progressBar.width() - adMarkerWidth,
-          Math.max(0, markerPositionOffset));
-      Paint paint = playedAdGroups[i] ? playedAdMarkerPaint : adMarkerPaint;
-      canvas.drawRect(markerLeft, barTop, markerLeft + adMarkerWidth, barBottom, paint);
-    }
-  }
-
-  private void drawPlayhead(Canvas canvas) {
-    if (duration <= 0) {
-      return;
-    }
-    int playheadX = Util.constrainValue(scrubberBar.right, scrubberBar.left, progressBar.right);
-    int playheadY = scrubberBar.centerY();
-    if (scrubberDrawable == null) {
-      int scrubberSize = (scrubbing || isFocused()) ? scrubberDraggedSize
-          : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);
-      int playheadRadius = scrubberSize / 2;
-      canvas.drawCircle(playheadX, playheadY, playheadRadius, scrubberPaint);
-    } else {
-      int scrubberDrawableWidth = scrubberDrawable.getIntrinsicWidth();
-      int scrubberDrawableHeight = scrubberDrawable.getIntrinsicHeight();
-      scrubberDrawable.setBounds(
-          playheadX - scrubberDrawableWidth / 2,
-          playheadY - scrubberDrawableHeight / 2,
-          playheadX + scrubberDrawableWidth / 2,
-          playheadY + scrubberDrawableHeight / 2);
-      scrubberDrawable.draw(canvas);
-    }
-  }
-
-  private void updateDrawableState() {
-    if (scrubberDrawable != null && scrubberDrawable.isStateful()
-        && scrubberDrawable.setState(getDrawableState())) {
-      invalidate();
-    }
-  }
-
-  private String getProgressText() {
-    return Util.getStringForTime(formatBuilder, formatter, position);
-  }
-
-  private long getPositionIncrement() {
-    return keyTimeIncrement == C.TIME_UNSET
-        ? (duration == C.TIME_UNSET ? 0 : (duration / keyCountIncrement)) : keyTimeIncrement;
-  }
-
-  /**
-   * Incrementally scrubs the position by {@code positionChange}.
-   *
-   * @param positionChange The change in the scrubber position, in milliseconds. May be negative.
-   * @return Returns whether the scrubber position changed.
-   */
-  private boolean scrubIncrementally(long positionChange) {
-    if (duration <= 0) {
-      return false;
-    }
-    long scrubberPosition = getScrubberPosition();
-    scrubPosition = Util.constrainValue(scrubberPosition + positionChange, 0, duration);
-    if (scrubPosition == scrubberPosition) {
-      return false;
-    }
-    if (!scrubbing) {
-      startScrubbing();
-    }
-    for (OnScrubListener listener : listeners) {
-      listener.onScrubMove(this, scrubPosition);
-    }
-    update();
-    return true;
-  }
-
-  private boolean setDrawableLayoutDirection(Drawable drawable) {
-    return Util.SDK_INT >= 23 && setDrawableLayoutDirection(drawable, getLayoutDirection());
-  }
-
-  private static boolean setDrawableLayoutDirection(Drawable drawable, int layoutDirection) {
-    return Util.SDK_INT >= 23 && drawable.setLayoutDirection(layoutDirection);
-  }
-
-  public static int getDefaultScrubberColor(int playedColor) {
-    return 0xFF000000 | playedColor;
-  }
-
-  public static int getDefaultUnplayedColor(int playedColor) {
-    return 0x33000000 | (playedColor & 0x00FFFFFF);
-  }
-
-  public static int getDefaultBufferedColor(int playedColor) {
-    return 0xCC000000 | (playedColor & 0x00FFFFFF);
-  }
-
-  public static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
-    return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
-  }
-
-  private static int dpToPx(DisplayMetrics displayMetrics, int dps) {
-    return (int) (dps * displayMetrics.density + 0.5f);
-  }
-}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.kt b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.kt
new file mode 100644
index 0000000000..a91c070657
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.kt
@@ -0,0 +1,809 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui
+
+import android.annotation.TargetApi
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Paint
+import android.graphics.Point
+import android.graphics.Rect
+import android.graphics.drawable.Drawable
+import android.os.Bundle
+import android.support.annotation.ColorInt
+import android.util.AttributeSet
+import android.util.DisplayMetrics
+import android.view.KeyEvent
+import android.view.MotionEvent
+import android.view.View
+import android.view.accessibility.AccessibilityEvent
+import android.view.accessibility.AccessibilityNodeInfo
+import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction
+import com.google.android.exoplayer2.C
+import com.google.android.exoplayer2.util.Assertions
+import com.google.android.exoplayer2.util.Util
+import java.util.*
+import java.util.concurrent.CopyOnWriteArraySet
+
+/**
+ * A time bar that shows a current position, buffered position, duration and ad markers.
+ *
+ *
+ * A DefaultTimeBar can be customized by setting attributes, as outlined below.
+ *
+ * <h3>Attributes</h3>
+ *
+ * The following attributes can be set on a DefaultTimeBar when used in a layout XML file:
+ *
+ *
+ *
+ *
+ *
+ *  * **`bar_height`** - Dimension for the height of the time bar.
+ *
+ *  * Default: [.DEFAULT_BAR_HEIGHT_DP]
+ *
+ *  * **`touch_target_height`** - Dimension for the height of the area in which touch
+ * interactions with the time bar are handled. If no height is specified, this also determines
+ * the height of the view.
+ *
+ *  * Default: [.DEFAULT_TOUCH_TARGET_HEIGHT_DP]
+ *
+ *  * **`ad_marker_width`** - Dimension for the width of any ad markers shown on the
+ * bar. Ad markers are superimposed on the time bar to show the times at which ads will play.
+ *
+ *  * Default: [.DEFAULT_AD_MARKER_WIDTH_DP]
+ *
+ *  * **`scrubber_enabled_size`** - Dimension for the diameter of the circular scrubber
+ * handle when scrubbing is enabled but not in progress. Set to zero if no scrubber handle
+ * should be shown.
+ *
+ *  * Default: [.DEFAULT_SCRUBBER_ENABLED_SIZE_DP]
+ *
+ *  * **`scrubber_disabled_size`** - Dimension for the diameter of the circular scrubber
+ * handle when scrubbing isn't enabled. Set to zero if no scrubber handle should be shown.
+ *
+ *  * Default: [.DEFAULT_SCRUBBER_DISABLED_SIZE_DP]
+ *
+ *  * **`scrubber_dragged_size`** - Dimension for the diameter of the circular scrubber
+ * handle when scrubbing is in progress. Set to zero if no scrubber handle should be shown.
+ *
+ *  * Default: [.DEFAULT_SCRUBBER_DRAGGED_SIZE_DP]
+ *
+ *  * **`scrubber_drawable`** - Optional reference to a drawable to draw for the
+ * scrubber handle. If set, this overrides the default behavior, which is to draw a circle for
+ * the scrubber handle.
+ *  * **`played_color`** - Color for the portion of the time bar representing media
+ * before the current playback position.
+ *
+ *  * Corresponding method: [.setPlayedColor]
+ *  * Default: [.DEFAULT_PLAYED_COLOR]
+ *
+ *  * **`scrubber_color`** - Color for the scrubber handle.
+ *
+ *  * Corresponding method: [.setScrubberColor]
+ *  * Default: see [.getDefaultScrubberColor]
+ *
+ *  * **`buffered_color`** - Color for the portion of the time bar after the current
+ * played position up to the current buffered position.
+ *
+ *  * Corresponding method: [.setBufferedColor]
+ *  * Default: see [.getDefaultBufferedColor]
+ *
+ *  * **`unplayed_color`** - Color for the portion of the time bar after the current
+ * buffered position.
+ *
+ *  * Corresponding method: [.setUnplayedColor]
+ *  * Default: see [.getDefaultUnplayedColor]
+ *
+ *  * **`ad_marker_color`** - Color for unplayed ad markers.
+ *
+ *  * Corresponding method: [.setAdMarkerColor]
+ *  * Default: [.DEFAULT_AD_MARKER_COLOR]
+ *
+ *  * **`played_ad_marker_color`** - Color for played ad markers.
+ *
+ *  * Corresponding method: [.setPlayedAdMarkerColor]
+ *  * Default: see [.getDefaultPlayedAdMarkerColor]
+ *
+ *
+ */
+open class DefaultTimeBar
+/** Creates a new time bar.  */
+// Suppress warnings due to usage of View methods in the constructor.
+(context: Context, attrs: AttributeSet?) : View(context, attrs), TimeBar {
+
+    private val seekBounds: Rect
+    protected val progressBar: Rect
+    protected val bufferedBar: Rect
+    protected val scrubberBar: Rect
+    protected val playedPaint: Paint
+    protected val bufferedPaint: Paint
+    protected val unplayedPaint: Paint
+    protected val adMarkerPaint: Paint
+    protected val playedAdMarkerPaint: Paint
+    private val scrubberPaint: Paint
+    private val scrubberDrawable: Drawable?
+    private val barHeight: Int
+    private val touchTargetHeight: Int
+    protected val adMarkerWidth: Int
+    private val scrubberEnabledSize: Int
+    private val scrubberDisabledSize: Int
+    private val scrubberDraggedSize: Int
+    private val scrubberPadding: Int
+    private val fineScrubYThreshold: Int
+    private val formatBuilder: StringBuilder
+    private val formatter: Formatter
+    private val stopScrubbingRunnable: Runnable
+    private val listeners: CopyOnWriteArraySet<TimeBar.OnScrubListener>
+    private val locationOnScreen: IntArray
+    private val touchPosition: Point
+
+    private var keyCountIncrement: Int = 0
+    private var keyTimeIncrement: Long = 0
+    private var lastCoarseScrubXPosition: Int = 0
+
+    private var scrubbing: Boolean = false
+    private var scrubPosition: Long = 0
+    private var duration: Long = 0
+    private var position: Long = 0
+    private var bufferedPosition: Long = 0
+    protected var adGroupCount: Int = 0
+    protected var adGroupTimesMs: LongArray? = null
+    protected var playedAdGroups: BooleanArray? = null
+
+    private val scrubberPosition: Long
+        get() = if (progressBar.width() <= 0 || duration == C.TIME_UNSET) {
+            0
+        } else scrubberBar.width() * duration / progressBar.width()
+
+    private val progressText: String
+        get() = Util.getStringForTime(formatBuilder, formatter, position)
+
+    private val positionIncrement: Long
+        get() = if (keyTimeIncrement == C.TIME_UNSET)
+            if (duration == C.TIME_UNSET) 0 else duration / keyCountIncrement
+        else
+            keyTimeIncrement
+
+    init {
+        seekBounds = Rect()
+        progressBar = Rect()
+        bufferedBar = Rect()
+        scrubberBar = Rect()
+        playedPaint = Paint()
+        bufferedPaint = Paint()
+        unplayedPaint = Paint()
+        adMarkerPaint = Paint()
+        playedAdMarkerPaint = Paint()
+        scrubberPaint = Paint()
+        scrubberPaint.isAntiAlias = true
+        listeners = CopyOnWriteArraySet()
+        locationOnScreen = IntArray(2)
+        touchPosition = Point()
+
+        // Calculate the dimensions and paints for drawn elements.
+        val res = context.resources
+        val displayMetrics = res.displayMetrics
+        fineScrubYThreshold = dpToPx(displayMetrics, FINE_SCRUB_Y_THRESHOLD_DP)
+        val defaultBarHeight = dpToPx(displayMetrics, DEFAULT_BAR_HEIGHT_DP)
+        var defaultTouchTargetHeight = dpToPx(displayMetrics, DEFAULT_TOUCH_TARGET_HEIGHT_DP)
+        val defaultAdMarkerWidth = dpToPx(displayMetrics, DEFAULT_AD_MARKER_WIDTH_DP)
+        val defaultScrubberEnabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_ENABLED_SIZE_DP)
+        val defaultScrubberDisabledSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DISABLED_SIZE_DP)
+        val defaultScrubberDraggedSize = dpToPx(displayMetrics, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP)
+        if (attrs != null) {
+            val a = context.theme.obtainStyledAttributes(attrs, R.styleable.DefaultTimeBar, 0,
+                    0)
+            try {
+                scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable)
+                if (scrubberDrawable != null) {
+                    setDrawableLayoutDirection(scrubberDrawable)
+                    defaultTouchTargetHeight = Math.max(scrubberDrawable.minimumHeight, defaultTouchTargetHeight)
+                }
+                barHeight = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height,
+                        defaultBarHeight)
+                touchTargetHeight = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_touch_target_height,
+                        defaultTouchTargetHeight)
+                adMarkerWidth = a.getDimensionPixelSize(R.styleable.DefaultTimeBar_ad_marker_width,
+                        defaultAdMarkerWidth)
+                scrubberEnabledSize = a.getDimensionPixelSize(
+                        R.styleable.DefaultTimeBar_scrubber_enabled_size, defaultScrubberEnabledSize)
+                scrubberDisabledSize = a.getDimensionPixelSize(
+                        R.styleable.DefaultTimeBar_scrubber_disabled_size, defaultScrubberDisabledSize)
+                scrubberDraggedSize = a.getDimensionPixelSize(
+                        R.styleable.DefaultTimeBar_scrubber_dragged_size, defaultScrubberDraggedSize)
+                val playedColor = a.getInt(R.styleable.DefaultTimeBar_played_color, DEFAULT_PLAYED_COLOR)
+                val scrubberColor = a.getInt(R.styleable.DefaultTimeBar_scrubber_color,
+                        getDefaultScrubberColor(playedColor))
+                val bufferedColor = a.getInt(R.styleable.DefaultTimeBar_buffered_color,
+                        getDefaultBufferedColor(playedColor))
+                val unplayedColor = a.getInt(R.styleable.DefaultTimeBar_unplayed_color,
+                        getDefaultUnplayedColor(playedColor))
+                val adMarkerColor = a.getInt(R.styleable.DefaultTimeBar_ad_marker_color,
+                        DEFAULT_AD_MARKER_COLOR)
+                val playedAdMarkerColor = a.getInt(R.styleable.DefaultTimeBar_played_ad_marker_color,
+                        getDefaultPlayedAdMarkerColor(adMarkerColor))
+                playedPaint.color = playedColor
+                scrubberPaint.color = scrubberColor
+                bufferedPaint.color = bufferedColor
+                unplayedPaint.color = unplayedColor
+                adMarkerPaint.color = adMarkerColor
+                playedAdMarkerPaint.color = playedAdMarkerColor
+            } finally {
+                a.recycle()
+            }
+        } else {
+            barHeight = defaultBarHeight
+            touchTargetHeight = defaultTouchTargetHeight
+            adMarkerWidth = defaultAdMarkerWidth
+            scrubberEnabledSize = defaultScrubberEnabledSize
+            scrubberDisabledSize = defaultScrubberDisabledSize
+            scrubberDraggedSize = defaultScrubberDraggedSize
+            playedPaint.color = DEFAULT_PLAYED_COLOR
+            scrubberPaint.color = getDefaultScrubberColor(DEFAULT_PLAYED_COLOR)
+            bufferedPaint.color = getDefaultBufferedColor(DEFAULT_PLAYED_COLOR)
+            unplayedPaint.color = getDefaultUnplayedColor(DEFAULT_PLAYED_COLOR)
+            adMarkerPaint.color = DEFAULT_AD_MARKER_COLOR
+            scrubberDrawable = null
+        }
+        formatBuilder = StringBuilder()
+        formatter = Formatter(formatBuilder, Locale.getDefault())
+        stopScrubbingRunnable = Runnable { stopScrubbing(/* canceled= */false) }
+        if (scrubberDrawable != null) {
+            scrubberPadding = (scrubberDrawable.minimumWidth + 1) / 2
+        } else {
+            scrubberPadding = (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1) / 2
+        }
+        duration = C.TIME_UNSET
+        keyTimeIncrement = C.TIME_UNSET
+        keyCountIncrement = DEFAULT_INCREMENT_COUNT
+        isFocusable = true
+        if (Util.SDK_INT >= 16) {
+            maybeSetImportantForAccessibilityV16()
+        }
+    }
+
+    /**
+     * Sets the color for the portion of the time bar representing media before the playback position.
+     *
+     * @param playedColor The color for the portion of the time bar representing media before the
+     * playback position.
+     */
+    fun setPlayedColor(@ColorInt playedColor: Int) {
+        playedPaint.color = playedColor
+        invalidate(seekBounds)
+    }
+
+    /**
+     * Sets the color for the scrubber handle.
+     *
+     * @param scrubberColor The color for the scrubber handle.
+     */
+    fun setScrubberColor(@ColorInt scrubberColor: Int) {
+        scrubberPaint.color = scrubberColor
+        invalidate(seekBounds)
+    }
+
+    /**
+     * Sets the color for the portion of the time bar after the current played position up to the
+     * current buffered position.
+     *
+     * @param bufferedColor The color for the portion of the time bar after the current played
+     * position up to the current buffered position.
+     */
+    fun setBufferedColor(@ColorInt bufferedColor: Int) {
+        bufferedPaint.color = bufferedColor
+        invalidate(seekBounds)
+    }
+
+    /**
+     * Sets the color for the portion of the time bar after the current played position.
+     *
+     * @param unplayedColor The color for the portion of the time bar after the current played
+     * position.
+     */
+    fun setUnplayedColor(@ColorInt unplayedColor: Int) {
+        unplayedPaint.color = unplayedColor
+        invalidate(seekBounds)
+    }
+
+    /**
+     * Sets the color for unplayed ad markers.
+     *
+     * @param adMarkerColor The color for unplayed ad markers.
+     */
+    fun setAdMarkerColor(@ColorInt adMarkerColor: Int) {
+        adMarkerPaint.color = adMarkerColor
+        invalidate(seekBounds)
+    }
+
+    /**
+     * Sets the color for played ad markers.
+     *
+     * @param playedAdMarkerColor The color for played ad markers.
+     */
+    fun setPlayedAdMarkerColor(@ColorInt playedAdMarkerColor: Int) {
+        playedAdMarkerPaint.color = playedAdMarkerColor
+        invalidate(seekBounds)
+    }
+
+    // TimeBar implementation.
+
+    override fun addListener(listener: TimeBar.OnScrubListener) {
+        listeners.add(listener)
+    }
+
+    override fun removeListener(listener: TimeBar.OnScrubListener) {
+        listeners.remove(listener)
+    }
+
+    override fun setKeyTimeIncrement(time: Long) {
+        Assertions.checkArgument(time > 0)
+        keyCountIncrement = C.INDEX_UNSET
+        keyTimeIncrement = time
+    }
+
+    override fun setKeyCountIncrement(count: Int) {
+        Assertions.checkArgument(count > 0)
+        keyCountIncrement = count
+        keyTimeIncrement = C.TIME_UNSET
+    }
+
+    override fun setPosition(position: Long) {
+        this.position = position
+        contentDescription = progressText
+        update()
+    }
+
+    override fun setBufferedPosition(bufferedPosition: Long) {
+        this.bufferedPosition = bufferedPosition
+        update()
+    }
+
+    override fun setDuration(duration: Long) {
+        this.duration = duration
+        if (scrubbing && duration == C.TIME_UNSET) {
+            stopScrubbing(true)
+        }
+        update()
+    }
+
+    fun getDuration(): Long {
+        return duration
+    }
+
+    override fun setAdGroupTimesMs(adGroupTimesMs: LongArray?, playedAdGroups: BooleanArray?,
+                                   adGroupCount: Int) {
+        Assertions.checkArgument(adGroupCount == 0 || adGroupTimesMs != null && playedAdGroups != null)
+        this.adGroupCount = adGroupCount
+        this.adGroupTimesMs = adGroupTimesMs
+        this.playedAdGroups = playedAdGroups
+        update()
+    }
+
+    // View methods.
+
+    override fun setEnabled(enabled: Boolean) {
+        super.setEnabled(enabled)
+        if (scrubbing && !enabled) {
+            stopScrubbing(true)
+        }
+    }
+
+    public override fun onDraw(canvas: Canvas) {
+        canvas.save()
+        drawTimeBar(canvas)
+        drawPlayhead(canvas)
+        canvas.restore()
+    }
+
+    override fun onTouchEvent(event: MotionEvent): Boolean {
+        if (!isEnabled || duration <= 0) {
+            return false
+        }
+        val touchPosition = resolveRelativeTouchPosition(event)
+        val x = touchPosition.x
+        val y = touchPosition.y
+        when (event.action) {
+            MotionEvent.ACTION_DOWN -> if (isInSeekBar(x.toFloat(), y.toFloat())) {
+                positionScrubber(x.toFloat())
+                startScrubbing()
+                scrubPosition = scrubberPosition
+                update()
+                invalidate()
+                return true
+            }
+            MotionEvent.ACTION_MOVE -> if (scrubbing) {
+                if (y < fineScrubYThreshold) {
+                    val relativeX = x - lastCoarseScrubXPosition
+                    positionScrubber((lastCoarseScrubXPosition + relativeX / FINE_SCRUB_RATIO).toFloat())
+                } else {
+                    lastCoarseScrubXPosition = x
+                    positionScrubber(x.toFloat())
+                }
+                scrubPosition = scrubberPosition
+                for (listener in listeners) {
+                    listener.onScrubMove(this, scrubPosition)
+                }
+                update()
+                invalidate()
+                return true
+            }
+            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> if (scrubbing) {
+                stopScrubbing(event.action == MotionEvent.ACTION_CANCEL)
+                return true
+            }
+        }// Do nothing.
+        return false
+    }
+
+    override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
+        if (isEnabled) {
+            var positionIncrement = positionIncrement
+            when (keyCode) {
+                KeyEvent.KEYCODE_DPAD_LEFT -> {
+                    positionIncrement = -positionIncrement
+                    if (scrubIncrementally(positionIncrement)) {
+                        removeCallbacks(stopScrubbingRunnable)
+                        postDelayed(stopScrubbingRunnable, STOP_SCRUBBING_TIMEOUT_MS)
+                        return true
+                    }
+                }
+                // Fall through.
+                KeyEvent.KEYCODE_DPAD_RIGHT -> if (scrubIncrementally(positionIncrement)) {
+                    removeCallbacks(stopScrubbingRunnable)
+                    postDelayed(stopScrubbingRunnable, STOP_SCRUBBING_TIMEOUT_MS)
+                    return true
+                }
+                KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_ENTER -> if (scrubbing) {
+                    removeCallbacks(stopScrubbingRunnable)
+                    stopScrubbingRunnable.run()
+                    return true
+                }
+            }// Do nothing.
+        }
+        return super.onKeyDown(keyCode, event)
+    }
+
+    override fun drawableStateChanged() {
+        super.drawableStateChanged()
+        updateDrawableState()
+    }
+
+    override fun jumpDrawablesToCurrentState() {
+        super.jumpDrawablesToCurrentState()
+        scrubberDrawable?.jumpToCurrentState()
+    }
+
+    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
+        val heightMode = View.MeasureSpec.getMode(heightMeasureSpec)
+        val heightSize = View.MeasureSpec.getSize(heightMeasureSpec)
+        val height = if (heightMode == View.MeasureSpec.UNSPECIFIED)
+            touchTargetHeight
+        else if (heightMode == View.MeasureSpec.EXACTLY) heightSize else Math.min(touchTargetHeight, heightSize)
+        setMeasuredDimension(View.MeasureSpec.getSize(widthMeasureSpec), height)
+        updateDrawableState()
+    }
+
+    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
+        val width = right - left
+        val height = bottom - top
+        val barY = (height - touchTargetHeight) / 2
+        val seekLeft = paddingLeft
+        val seekRight = width - paddingRight
+        val progressY = barY + (touchTargetHeight - barHeight) / 2
+        seekBounds.set(seekLeft, barY, seekRight, barY + touchTargetHeight)
+        progressBar.set(seekBounds.left + scrubberPadding, progressY,
+                seekBounds.right - scrubberPadding, progressY + barHeight)
+        update()
+    }
+
+    override fun onRtlPropertiesChanged(layoutDirection: Int) {
+        if (scrubberDrawable != null && setDrawableLayoutDirection(scrubberDrawable, layoutDirection)) {
+            invalidate()
+        }
+    }
+
+    override fun onInitializeAccessibilityEvent(event: AccessibilityEvent) {
+        super.onInitializeAccessibilityEvent(event)
+        if (event.eventType == AccessibilityEvent.TYPE_VIEW_SELECTED) {
+            event.text.add(progressText)
+        }
+        event.className = ACCESSIBILITY_CLASS_NAME
+    }
+
+    @TargetApi(21)
+    override fun onInitializeAccessibilityNodeInfo(info: AccessibilityNodeInfo) {
+        super.onInitializeAccessibilityNodeInfo(info)
+        info.className = ACCESSIBILITY_CLASS_NAME
+        info.contentDescription = progressText
+        if (duration <= 0) {
+            return
+        }
+        if (Util.SDK_INT >= 21) {
+            info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD)
+            info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD)
+        } else if (Util.SDK_INT >= 16) {
+            info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD)
+            info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD)
+        }
+    }
+
+    @TargetApi(16)
+    override fun performAccessibilityAction(action: Int, args: Bundle?): Boolean {
+        if (super.performAccessibilityAction(action, args)) {
+            return true
+        }
+        if (duration <= 0) {
+            return false
+        }
+        if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
+            if (scrubIncrementally(-positionIncrement)) {
+                stopScrubbing(false)
+            }
+        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
+            if (scrubIncrementally(positionIncrement)) {
+                stopScrubbing(false)
+            }
+        } else {
+            return false
+        }
+        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED)
+        return true
+    }
+
+    // Internal methods.
+
+    @TargetApi(16)
+    private fun maybeSetImportantForAccessibilityV16() {
+        if (importantForAccessibility == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+            importantForAccessibility = View.IMPORTANT_FOR_ACCESSIBILITY_YES
+        }
+    }
+
+    private fun startScrubbing() {
+        scrubbing = true
+        isPressed = true
+        val parent = parent
+        parent?.requestDisallowInterceptTouchEvent(true)
+        for (listener in listeners) {
+            listener.onScrubStart(this, scrubberPosition)
+        }
+    }
+
+    private fun stopScrubbing(canceled: Boolean) {
+        scrubbing = false
+        isPressed = false
+        val parent = parent
+        parent?.requestDisallowInterceptTouchEvent(false)
+        invalidate()
+        for (listener in listeners) {
+            listener.onScrubStop(this, scrubberPosition, canceled)
+        }
+    }
+
+    private fun update() {
+        bufferedBar.set(progressBar)
+        scrubberBar.set(progressBar)
+        val newScrubberTime = if (scrubbing) scrubPosition else position
+        if (duration > 0) {
+            val bufferedPixelWidth = (progressBar.width() * bufferedPosition / duration).toInt()
+            bufferedBar.right = Math.min(progressBar.left + bufferedPixelWidth, progressBar.right)
+            val scrubberPixelPosition = (progressBar.width() * newScrubberTime / duration).toInt()
+            scrubberBar.right = Math.min(progressBar.left + scrubberPixelPosition, progressBar.right)
+        } else {
+            bufferedBar.right = progressBar.left
+            scrubberBar.right = progressBar.left
+        }
+        invalidate(seekBounds)
+    }
+
+    private fun positionScrubber(xPosition: Float) {
+        scrubberBar.right = Util.constrainValue(xPosition.toInt(), progressBar.left, progressBar.right)
+    }
+
+    private fun resolveRelativeTouchPosition(motionEvent: MotionEvent): Point {
+        getLocationOnScreen(locationOnScreen)
+        touchPosition.set(
+                motionEvent.rawX.toInt() - locationOnScreen[0],
+                motionEvent.rawY.toInt() - locationOnScreen[1])
+        return touchPosition
+    }
+
+    private fun isInSeekBar(x: Float, y: Float): Boolean {
+        return seekBounds.contains(x.toInt(), y.toInt())
+    }
+
+    protected open fun drawTimeBar(canvas: Canvas) {
+        val progressBarHeight = progressBar.height()
+        val barTop = progressBar.centerY() - progressBarHeight / 2
+        val barBottom = barTop + progressBarHeight
+        if (duration <= 0) {
+            canvas.drawRect(progressBar.left.toFloat(), barTop.toFloat(), progressBar.right.toFloat(), barBottom.toFloat(), unplayedPaint)
+            return
+        }
+        var bufferedLeft = bufferedBar.left
+        val bufferedRight = bufferedBar.right
+        val progressLeft = Math.max(Math.max(progressBar.left, bufferedRight), scrubberBar.right)
+        if (progressLeft < progressBar.right) {
+            canvas.drawRect(progressLeft.toFloat(), barTop.toFloat(), progressBar.right.toFloat(), barBottom.toFloat(), unplayedPaint)
+        }
+        bufferedLeft = Math.max(bufferedLeft, scrubberBar.right)
+        if (bufferedRight > bufferedLeft) {
+            canvas.drawRect(bufferedLeft.toFloat(), barTop.toFloat(), bufferedRight.toFloat(), barBottom.toFloat(), bufferedPaint)
+        }
+        if (scrubberBar.width() > 0) {
+            canvas.drawRect(scrubberBar.left.toFloat(), barTop.toFloat(), scrubberBar.right.toFloat(), barBottom.toFloat(), playedPaint)
+        }
+        if (adGroupCount == 0) {
+            return
+        }
+        val adGroupTimesMs = Assertions.checkNotNull(this.adGroupTimesMs)
+        val playedAdGroups = Assertions.checkNotNull(this.playedAdGroups)
+        val adMarkerOffset = adMarkerWidth / 2
+        for (i in 0 until adGroupCount) {
+            val adGroupTimeMs = Util.constrainValue(adGroupTimesMs[i], 0, duration)
+            val markerPositionOffset = (progressBar.width() * adGroupTimeMs / duration).toInt() - adMarkerOffset
+            val markerLeft = progressBar.left + Math.min(progressBar.width() - adMarkerWidth,
+                    Math.max(0, markerPositionOffset))
+            val paint = if (playedAdGroups[i]) playedAdMarkerPaint else adMarkerPaint
+            canvas.drawRect(markerLeft.toFloat(), barTop.toFloat(), (markerLeft + adMarkerWidth).toFloat(), barBottom.toFloat(), paint)
+        }
+    }
+
+    private fun drawPlayhead(canvas: Canvas) {
+        if (duration <= 0) {
+            return
+        }
+        val playheadX = Util.constrainValue(scrubberBar.right, scrubberBar.left, progressBar.right)
+        val playheadY = scrubberBar.centerY()
+        if (scrubberDrawable == null) {
+            val scrubberSize = if (scrubbing || isFocused)
+                scrubberDraggedSize
+            else
+                if (isEnabled) scrubberEnabledSize else scrubberDisabledSize
+            val playheadRadius = scrubberSize / 2
+            canvas.drawCircle(playheadX.toFloat(), playheadY.toFloat(), playheadRadius.toFloat(), scrubberPaint)
+        } else {
+            val scrubberDrawableWidth = scrubberDrawable.intrinsicWidth
+            val scrubberDrawableHeight = scrubberDrawable.intrinsicHeight
+            scrubberDrawable.setBounds(
+                    playheadX - scrubberDrawableWidth / 2,
+                    playheadY - scrubberDrawableHeight / 2,
+                    playheadX + scrubberDrawableWidth / 2,
+                    playheadY + scrubberDrawableHeight / 2)
+            scrubberDrawable.draw(canvas)
+        }
+    }
+
+    private fun updateDrawableState() {
+        if (scrubberDrawable != null && scrubberDrawable.isStateful
+                && scrubberDrawable.setState(drawableState)) {
+            invalidate()
+        }
+    }
+
+    /**
+     * Incrementally scrubs the position by `positionChange`.
+     *
+     * @param positionChange The change in the scrubber position, in milliseconds. May be negative.
+     * @return Returns whether the scrubber position changed.
+     */
+    private fun scrubIncrementally(positionChange: Long): Boolean {
+        if (duration <= 0) {
+            return false
+        }
+        val scrubberPosition = scrubberPosition
+        scrubPosition = Util.constrainValue(scrubberPosition + positionChange, 0, duration)
+        if (scrubPosition == scrubberPosition) {
+            return false
+        }
+        if (!scrubbing) {
+            startScrubbing()
+        }
+        for (listener in listeners) {
+            listener.onScrubMove(this, scrubPosition)
+        }
+        update()
+        return true
+    }
+
+    private fun setDrawableLayoutDirection(drawable: Drawable): Boolean {
+        return Util.SDK_INT >= 23 && setDrawableLayoutDirection(drawable, layoutDirection)
+    }
+
+    companion object {
+
+        /**
+         * Default height for the time bar, in dp.
+         */
+        val DEFAULT_BAR_HEIGHT_DP = 4
+        /**
+         * Default height for the touch target, in dp.
+         */
+        val DEFAULT_TOUCH_TARGET_HEIGHT_DP = 26
+        /**
+         * Default width for ad markers, in dp.
+         */
+        val DEFAULT_AD_MARKER_WIDTH_DP = 4
+        /**
+         * Default diameter for the scrubber when enabled, in dp.
+         */
+        val DEFAULT_SCRUBBER_ENABLED_SIZE_DP = 12
+        /**
+         * Default diameter for the scrubber when disabled, in dp.
+         */
+        val DEFAULT_SCRUBBER_DISABLED_SIZE_DP = 0
+        /**
+         * Default diameter for the scrubber when dragged, in dp.
+         */
+        val DEFAULT_SCRUBBER_DRAGGED_SIZE_DP = 16
+        /**
+         * Default color for the played portion of the time bar.
+         */
+        val DEFAULT_PLAYED_COLOR = -0x1
+        /**
+         * Default color for ad markers.
+         */
+        val DEFAULT_AD_MARKER_COLOR = -0x4d000100
+
+        /**
+         * The threshold in dps above the bar at which touch events trigger fine scrub mode.
+         */
+        private val FINE_SCRUB_Y_THRESHOLD_DP = -50
+        /**
+         * The ratio by which times are reduced in fine scrub mode.
+         */
+        private val FINE_SCRUB_RATIO = 3
+        /**
+         * The time after which the scrubbing listener is notified that scrubbing has stopped after
+         * performing an incremental scrub using key input.
+         */
+        private val STOP_SCRUBBING_TIMEOUT_MS: Long = 1000
+        private val DEFAULT_INCREMENT_COUNT = 20
+
+        /**
+         * The name of the Android SDK view that most closely resembles this custom view. Used as the
+         * class name for accessibility.
+         */
+        private val ACCESSIBILITY_CLASS_NAME = "android.widget.SeekBar"
+
+        private fun setDrawableLayoutDirection(drawable: Drawable, layoutDirection: Int): Boolean {
+            return Util.SDK_INT >= 23 && drawable.setLayoutDirection(layoutDirection)
+        }
+
+        fun getDefaultScrubberColor(playedColor: Int): Int {
+            return -0x1000000 or playedColor
+        }
+
+        fun getDefaultUnplayedColor(playedColor: Int): Int {
+            return 0x33000000 or (playedColor and 0x00FFFFFF)
+        }
+
+        fun getDefaultBufferedColor(playedColor: Int): Int {
+            return -0x34000000 or (playedColor and 0x00FFFFFF)
+        }
+
+        fun getDefaultPlayedAdMarkerColor(adMarkerColor: Int): Int {
+            return 0x33000000 or (adMarkerColor and 0x00FFFFFF)
+        }
+
+        private fun dpToPx(displayMetrics: DisplayMetrics, dps: Int): Int {
+            return (dps * displayMetrics.density + 0.5f).toInt()
+        }
+    }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/OnFullScreenButtonClickedListener.kt b/library/ui/src/main/java/com/google/android/exoplayer2/ui/OnFullScreenButtonClickedListener.kt
new file mode 100644
index 0000000000..04b872129a
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/OnFullScreenButtonClickedListener.kt
@@ -0,0 +1,3 @@
+package com.google.android.exoplayer2.ui
+
+import android.widget.ImageView
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt
index a0f68c5b86..791d5348f7 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt
@@ -266,6 +266,26 @@ open class PlayerControlView(
         fun onVisibilityChange(visibility: Int)
     }
 
+    /**
+     * Listener to be notified when quality change button is clicked
+     *
+     * @author Dragos
+     * @since 06-Mar-19
+     */
+    interface OnQualityChangeClickedListener {
+        fun onQualityChangeClicked(qualityChangeView: ImageView)
+    }
+
+    /**
+     * Listener to be notified when full screen button is clicked
+     *
+     * @author Dragos
+     * @since 06-Mar-19
+     */
+    interface OnFullScreenButtonClickedListener {
+        fun onFullScreenButtonClicked(fullScreenView: ImageView)
+    }
+
     init {
         var controllerLayoutId = R.layout.exo_player_control_view
         rewindMs = DEFAULT_REWIND_MS
@@ -919,6 +939,24 @@ open class PlayerControlView(
         return true
     }
 
+    var onFullScreenButtonClickedListener: OnFullScreenButtonClickedListener? = null
+        set(value) {
+            field = value
+            fullscreenView?.let {
+                if (field == null) visibility = View.GONE
+                else visibility = View.VISIBLE
+            }
+        }
+
+    var onQualityChangeClickedListener: OnQualityChangeClickedListener? = null
+        set(value) {
+            field = value
+            qualityChangeView?.let {
+                if (field == null) visibility = View.GONE
+                else visibility = View.VISIBLE
+            }
+        }
+
     private inner class ComponentListener : Player.EventListener, TimeBar.OnScrubListener, View.OnClickListener {
 
         override fun onScrubStart(timeBar: TimeBar, position: Long) {
@@ -1002,7 +1040,8 @@ open class PlayerControlView(
                             this@PlayerControlView.player,
                             !this@PlayerControlView.player!!.shuffleModeEnabled
                     )
-                    qualityChangeView === view -> TODO("")
+                    qualityChangeView === view -> onQualityChangeClickedListener?.onQualityChangeClicked(qualityChangeView)
+                    fullscreenView === view -> onFullScreenButtonClickedListener?.onFullScreenButtonClicked(fullscreenView)
                 }
             }
         }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 9d66289e94..8b0614ef1a 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -43,6 +43,7 @@
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.TextView;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ControlDispatcher;
 import com.google.android.exoplayer2.DefaultControlDispatcher;
@@ -67,6 +68,7 @@
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoListener;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -81,97 +83,97 @@
  * overriding the view's layout file or by specifying a custom view layout file, as outlined below.
  *
  * <h3>Attributes</h3>
- *
+ * <p>
  * The following attributes can be set on a PlayerView when used in a layout XML file:
  *
  * <ul>
- *   <li><b>{@code use_artwork}</b> - Whether artwork is used if available in audio streams.
- *       <ul>
- *         <li>Corresponding method: {@link #setUseArtwork(boolean)}
- *         <li>Default: {@code true}
- *       </ul>
- *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
- *       streams.
- *       <ul>
- *         <li>Corresponding method: {@link #setDefaultArtwork(Drawable)}
- *         <li>Default: {@code null}
- *       </ul>
- *   <li><b>{@code use_controller}</b> - Whether the playback controls can be shown.
- *       <ul>
- *         <li>Corresponding method: {@link #setUseController(boolean)}
- *         <li>Default: {@code true}
- *       </ul>
- *   <li><b>{@code hide_on_touch}</b> - Whether the playback controls are hidden by touch events.
- *       <ul>
- *         <li>Corresponding method: {@link #setControllerHideOnTouch(boolean)}
- *         <li>Default: {@code true}
- *       </ul>
- *   <li><b>{@code auto_show}</b> - Whether the playback controls are automatically shown when
- *       playback starts, pauses, ends, or fails. If set to false, the playback controls can be
- *       manually operated with {@link #showController()} and {@link #hideController()}.
- *       <ul>
- *         <li>Corresponding method: {@link #setControllerAutoShow(boolean)}
- *         <li>Default: {@code true}
- *       </ul>
- *   <li><b>{@code hide_during_ads}</b> - Whether the playback controls are hidden during ads.
- *       Controls are always shown during ads if they are enabled and the player is paused.
- *       <ul>
- *         <li>Corresponding method: {@link #setControllerHideDuringAds(boolean)}
- *         <li>Default: {@code true}
- *       </ul>
- *   <li><b>{@code show_buffering}</b> - Whether the buffering spinner is displayed when the player
- *       is buffering. Valid values are {@code never}, {@code when_playing} and {@code always}.
- *       <ul>
- *         <li>Corresponding method: {@link #setShowBuffering(int)}
- *         <li>Default: {@code never}
- *       </ul>
- *   <li><b>{@code resize_mode}</b> - Controls how video and album art is resized within the view.
- *       Valid values are {@code fit}, {@code fixed_width}, {@code fixed_height} and {@code fill}.
- *       <ul>
- *         <li>Corresponding method: {@link #setResizeMode(int)}
- *         <li>Default: {@code fit}
- *       </ul>
- *   <li><b>{@code surface_type}</b> - The type of surface view used for video playbacks. Valid
- *       values are {@code surface_view}, {@code texture_view}, {@code spherical_view} and {@code
- *       none}. Using {@code none} is recommended for audio only applications, since creating the
- *       surface can be expensive. Using {@code surface_view} is recommended for video applications.
- *       Note, TextureView can only be used in a hardware accelerated window. When rendered in
- *       software, TextureView will draw nothing.
- *       <ul>
- *         <li>Corresponding method: None
- *         <li>Default: {@code surface_view}
- *       </ul>
- *   <li><b>{@code shutter_background_color}</b> - The background color of the {@code exo_shutter}
- *       view.
- *       <ul>
- *         <li>Corresponding method: {@link #setShutterBackgroundColor(int)}
- *         <li>Default: {@code unset}
- *       </ul>
- *   <li><b>{@code keep_content_on_player_reset}</b> - Whether the currently displayed video frame
- *       or media artwork is kept visible when the player is reset.
- *       <ul>
- *         <li>Corresponding method: {@link #setKeepContentOnPlayerReset(boolean)}
- *         <li>Default: {@code false}
- *       </ul>
- *   <li><b>{@code player_layout_id}</b> - Specifies the id of the layout to be inflated. See below
- *       for more details.
- *       <ul>
- *         <li>Corresponding method: None
- *         <li>Default: {@code R.layout.exo_player_view}
- *       </ul>
- *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout resource to be
- *       inflated by the child {@link PlayerControlView}. See below for more details.
- *       <ul>
- *         <li>Corresponding method: None
- *         <li>Default: {@code R.layout.exo_player_control_view}
- *       </ul>
- *   <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
- *       PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
- *       layout is overridden to specify a custom {@code exo_controller} (see below).
+ * <li><b>{@code use_artwork}</b> - Whether artwork is used if available in audio streams.
+ * <ul>
+ * <li>Corresponding method: {@link #setUseArtwork(boolean)}
+ * <li>Default: {@code true}
+ * </ul>
+ * <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
+ * streams.
+ * <ul>
+ * <li>Corresponding method: {@link #setDefaultArtwork(Drawable)}
+ * <li>Default: {@code null}
+ * </ul>
+ * <li><b>{@code use_controller}</b> - Whether the playback controls can be shown.
+ * <ul>
+ * <li>Corresponding method: {@link #setUseController(boolean)}
+ * <li>Default: {@code true}
+ * </ul>
+ * <li><b>{@code hide_on_touch}</b> - Whether the playback controls are hidden by touch events.
+ * <ul>
+ * <li>Corresponding method: {@link #setControllerHideOnTouch(boolean)}
+ * <li>Default: {@code true}
+ * </ul>
+ * <li><b>{@code auto_show}</b> - Whether the playback controls are automatically shown when
+ * playback starts, pauses, ends, or fails. If set to false, the playback controls can be
+ * manually operated with {@link #showController()} and {@link #hideController()}.
+ * <ul>
+ * <li>Corresponding method: {@link #setControllerAutoShow(boolean)}
+ * <li>Default: {@code true}
+ * </ul>
+ * <li><b>{@code hide_during_ads}</b> - Whether the playback controls are hidden during ads.
+ * Controls are always shown during ads if they are enabled and the player is paused.
+ * <ul>
+ * <li>Corresponding method: {@link #setControllerHideDuringAds(boolean)}
+ * <li>Default: {@code true}
+ * </ul>
+ * <li><b>{@code show_buffering}</b> - Whether the buffering spinner is displayed when the player
+ * is buffering. Valid values are {@code never}, {@code when_playing} and {@code always}.
+ * <ul>
+ * <li>Corresponding method: {@link #setShowBuffering(int)}
+ * <li>Default: {@code never}
+ * </ul>
+ * <li><b>{@code resize_mode}</b> - Controls how video and album art is resized within the view.
+ * Valid values are {@code fit}, {@code fixed_width}, {@code fixed_height} and {@code fill}.
+ * <ul>
+ * <li>Corresponding method: {@link #setResizeMode(int)}
+ * <li>Default: {@code fit}
+ * </ul>
+ * <li><b>{@code surface_type}</b> - The type of surface view used for video playbacks. Valid
+ * values are {@code surface_view}, {@code texture_view}, {@code spherical_view} and {@code
+ * none}. Using {@code none} is recommended for audio only applications, since creating the
+ * surface can be expensive. Using {@code surface_view} is recommended for video applications.
+ * Note, TextureView can only be used in a hardware accelerated window. When rendered in
+ * software, TextureView will draw nothing.
+ * <ul>
+ * <li>Corresponding method: None
+ * <li>Default: {@code surface_view}
+ * </ul>
+ * <li><b>{@code shutter_background_color}</b> - The background color of the {@code exo_shutter}
+ * view.
+ * <ul>
+ * <li>Corresponding method: {@link #setShutterBackgroundColor(int)}
+ * <li>Default: {@code unset}
+ * </ul>
+ * <li><b>{@code keep_content_on_player_reset}</b> - Whether the currently displayed video frame
+ * or media artwork is kept visible when the player is reset.
+ * <ul>
+ * <li>Corresponding method: {@link #setKeepContentOnPlayerReset(boolean)}
+ * <li>Default: {@code false}
+ * </ul>
+ * <li><b>{@code player_layout_id}</b> - Specifies the id of the layout to be inflated. See below
+ * for more details.
+ * <ul>
+ * <li>Corresponding method: None
+ * <li>Default: {@code R.layout.exo_player_view}
+ * </ul>
+ * <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout resource to be
+ * inflated by the child {@link PlayerControlView}. See below for more details.
+ * <ul>
+ * <li>Corresponding method: None
+ * <li>Default: {@code R.layout.exo_player_control_view}
+ * </ul>
+ * <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
+ * PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
+ * layout is overridden to specify a custom {@code exo_controller} (see below).
  * </ul>
  *
  * <h3>Overriding the layout file</h3>
- *
+ * <p>
  * To customize the layout of PlayerView throughout your app, or just for certain configurations,
  * you can define {@code exo_player_view.xml} layout files in your application {@code res/layout*}
  * directories. These layouts will override the one provided by the ExoPlayer library, and will be
@@ -181,65 +183,65 @@
  * <p>
  *
  * <ul>
- *   <li><b>{@code exo_content_frame}</b> - A frame whose aspect ratio is resized based on the video
- *       or album art of the media being played, and the configured {@code resize_mode}. The video
- *       surface view is inflated into this frame as its first child.
- *       <ul>
- *         <li>Type: {@link AspectRatioFrameLayout}
- *       </ul>
- *   <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
- *       view is typically an opaque view that covers the video surface, thereby obscuring it when
- *       visible. Obscuring the surface in this way also helps to prevent flicker at the start of
- *       playback when {@code surface_type="surface_view"}.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_buffering}</b> - A view that's made visible when the player is buffering.
- *       This view typically displays a buffering spinner or animation.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_subtitles}</b> - Displays subtitles.
- *       <ul>
- *         <li>Type: {@link SubtitleView}
- *       </ul>
- *   <li><b>{@code exo_artwork}</b> - Displays album art.
- *       <ul>
- *         <li>Type: {@link ImageView}
- *       </ul>
- *   <li><b>{@code exo_error_message}</b> - Displays an error message to the user if playback fails.
- *       <ul>
- *         <li>Type: {@link TextView}
- *       </ul>
- *   <li><b>{@code exo_controller_placeholder}</b> - A placeholder that's replaced with the inflated
- *       {@link PlayerControlView}. Ignored if an {@code exo_controller} view exists.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_controller}</b> - An already inflated {@link PlayerControlView}. Allows use
- *       of a custom extension of {@link PlayerControlView}. Note that attributes such as {@code
- *       rewind_increment} will not be automatically propagated through to this instance. If a view
- *       exists with this id, any {@code exo_controller_placeholder} view will be ignored.
- *       <ul>
- *         <li>Type: {@link PlayerControlView}
- *       </ul>
- *   <li><b>{@code exo_ad_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
- *       is used to show ad UI (if applicable).
- *       <ul>
- *         <li>Type: {@link FrameLayout}
- *       </ul>
- *   <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
- *       the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
- *       <ul>
- *         <li>Type: {@link FrameLayout}
- *       </ul>
+ * <li><b>{@code exo_content_frame}</b> - A frame whose aspect ratio is resized based on the video
+ * or album art of the media being played, and the configured {@code resize_mode}. The video
+ * surface view is inflated into this frame as its first child.
+ * <ul>
+ * <li>Type: {@link AspectRatioFrameLayout}
+ * </ul>
+ * <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
+ * view is typically an opaque view that covers the video surface, thereby obscuring it when
+ * visible. Obscuring the surface in this way also helps to prevent flicker at the start of
+ * playback when {@code surface_type="surface_view"}.
+ * <ul>
+ * <li>Type: {@link View}
+ * </ul>
+ * <li><b>{@code exo_buffering}</b> - A view that's made visible when the player is buffering.
+ * This view typically displays a buffering spinner or animation.
+ * <ul>
+ * <li>Type: {@link View}
+ * </ul>
+ * <li><b>{@code exo_subtitles}</b> - Displays subtitles.
+ * <ul>
+ * <li>Type: {@link SubtitleView}
+ * </ul>
+ * <li><b>{@code exo_artwork}</b> - Displays album art.
+ * <ul>
+ * <li>Type: {@link ImageView}
+ * </ul>
+ * <li><b>{@code exo_error_message}</b> - Displays an error message to the user if playback fails.
+ * <ul>
+ * <li>Type: {@link TextView}
+ * </ul>
+ * <li><b>{@code exo_controller_placeholder}</b> - A placeholder that's replaced with the inflated
+ * {@link PlayerControlView}. Ignored if an {@code exo_controller} view exists.
+ * <ul>
+ * <li>Type: {@link View}
+ * </ul>
+ * <li><b>{@code exo_controller}</b> - An already inflated {@link PlayerControlView}. Allows use
+ * of a custom extension of {@link PlayerControlView}. Note that attributes such as {@code
+ * rewind_increment} will not be automatically propagated through to this instance. If a view
+ * exists with this id, any {@code exo_controller_placeholder} view will be ignored.
+ * <ul>
+ * <li>Type: {@link PlayerControlView}
+ * </ul>
+ * <li><b>{@code exo_ad_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
+ * is used to show ad UI (if applicable).
+ * <ul>
+ * <li>Type: {@link FrameLayout}
+ * </ul>
+ * <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
+ * the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
+ * <ul>
+ * <li>Type: {@link FrameLayout}
+ * </ul>
  * </ul>
  *
  * <p>All child views are optional and so can be omitted if not required, however where defined they
  * must be of the expected type.
  *
  * <h3>Specifying a custom layout file</h3>
- *
+ * <p>
  * Defining your own {@code exo_player_view.xml} is useful to customize the layout of PlayerView
  * throughout your application. It's also possible to customize the layout for a single instance in
  * a layout file. This is achieved by setting the {@code player_layout_id} attribute on a
@@ -248,1225 +250,1283 @@
  */
 public class PlayerView extends FrameLayout implements AdsLoader.AdViewProvider {
 
-  // LINT.IfChange
-  /**
-   * Determines when the buffering view is shown. One of {@link #SHOW_BUFFERING_NEVER}, {@link
-   * #SHOW_BUFFERING_WHEN_PLAYING} or {@link #SHOW_BUFFERING_ALWAYS}.
-   */
-  @Documented
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({SHOW_BUFFERING_NEVER, SHOW_BUFFERING_WHEN_PLAYING, SHOW_BUFFERING_ALWAYS})
-  public @interface ShowBuffering {}
-  /** The buffering view is never shown. */
-  public static final int SHOW_BUFFERING_NEVER = 0;
-  /**
-   * The buffering view is shown when the player is in the {@link Player#STATE_BUFFERING buffering}
-   * state and {@link Player#getPlayWhenReady() playWhenReady} is {@code true}.
-   */
-  public static final int SHOW_BUFFERING_WHEN_PLAYING = 1;
-  /**
-   * The buffering view is always shown when the player is in the {@link Player#STATE_BUFFERING
-   * buffering} state.
-   */
-  public static final int SHOW_BUFFERING_ALWAYS = 2;
-  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
-
-  // LINT.IfChange
-  private static final int SURFACE_TYPE_NONE = 0;
-  private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
-  private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
-  private static final int SURFACE_TYPE_MONO360_VIEW = 3;
-  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
-
-  @Nullable private final AspectRatioFrameLayout contentFrame;
-  private final View shutterView;
-  @Nullable private final View surfaceView;
-  private final ImageView artworkView;
-  private final SubtitleView subtitleView;
-  @Nullable private final View bufferingView;
-  @Nullable private final TextView errorMessageView;
-  @Nullable private final PlayerControlView controller;
-  private final ComponentListener componentListener;
-  @Nullable private final FrameLayout adOverlayFrameLayout;
-  @Nullable private final FrameLayout overlayFrameLayout;
-
-  private Player player;
-  private boolean useController;
-  private boolean useArtwork;
-  @Nullable private Drawable defaultArtwork;
-  private @ShowBuffering int showBuffering;
-  private boolean keepContentOnPlayerReset;
-  @Nullable private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
-  @Nullable private CharSequence customErrorMessage;
-  private int controllerShowTimeoutMs;
-  private boolean controllerAutoShow;
-  private boolean controllerHideDuringAds;
-  private boolean controllerHideOnTouch;
-  private int textureViewRotation;
-
-  public PlayerView(Context context) {
-    this(context, null);
-  }
-
-  public PlayerView(Context context, AttributeSet attrs) {
-    this(context, attrs, 0);
-  }
-
-  public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
-    super(context, attrs, defStyleAttr);
-
-    if (isInEditMode()) {
-      contentFrame = null;
-      shutterView = null;
-      surfaceView = null;
-      artworkView = null;
-      subtitleView = null;
-      bufferingView = null;
-      errorMessageView = null;
-      controller = null;
-      componentListener = null;
-      adOverlayFrameLayout = null;
-      overlayFrameLayout = null;
-      ImageView logo = new ImageView(context);
-      if (Util.SDK_INT >= 23) {
-        configureEditModeLogoV23(getResources(), logo);
-      } else {
-        configureEditModeLogo(getResources(), logo);
-      }
-      addView(logo);
-      return;
-    }
-
-    boolean shutterColorSet = false;
-    int shutterColor = 0;
-    int playerLayoutId = R.layout.exo_player_view;
-    boolean useArtwork = true;
-    int defaultArtworkId = 0;
-    boolean useController = true;
-    int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
-    int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
-    int controllerShowTimeoutMs = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
-    boolean controllerHideOnTouch = true;
-    boolean controllerAutoShow = true;
-    boolean controllerHideDuringAds = true;
-    int showBuffering = SHOW_BUFFERING_NEVER;
-    if (attrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.PlayerView, 0, 0);
-      try {
-        shutterColorSet = a.hasValue(R.styleable.PlayerView_shutter_background_color);
-        shutterColor = a.getColor(R.styleable.PlayerView_shutter_background_color, shutterColor);
-        playerLayoutId = a.getResourceId(R.styleable.PlayerView_player_layout_id, playerLayoutId);
-        useArtwork = a.getBoolean(R.styleable.PlayerView_use_artwork, useArtwork);
-        defaultArtworkId =
-            a.getResourceId(R.styleable.PlayerView_default_artwork, defaultArtworkId);
-        useController = a.getBoolean(R.styleable.PlayerView_use_controller, useController);
-        surfaceType = a.getInt(R.styleable.PlayerView_surface_type, surfaceType);
-        resizeMode = a.getInt(R.styleable.PlayerView_resize_mode, resizeMode);
-        controllerShowTimeoutMs =
-            a.getInt(R.styleable.PlayerView_show_timeout, controllerShowTimeoutMs);
-        controllerHideOnTouch =
-            a.getBoolean(R.styleable.PlayerView_hide_on_touch, controllerHideOnTouch);
-        controllerAutoShow = a.getBoolean(R.styleable.PlayerView_auto_show, controllerAutoShow);
-        showBuffering = a.getInteger(R.styleable.PlayerView_show_buffering, showBuffering);
-        keepContentOnPlayerReset =
-            a.getBoolean(
-                R.styleable.PlayerView_keep_content_on_player_reset, keepContentOnPlayerReset);
-        controllerHideDuringAds =
-            a.getBoolean(R.styleable.PlayerView_hide_during_ads, controllerHideDuringAds);
-      } finally {
-        a.recycle();
-      }
-    }
-
-    LayoutInflater.from(context).inflate(playerLayoutId, this);
-    componentListener = new ComponentListener();
-    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
-
-    // Content frame.
-    contentFrame = findViewById(R.id.exo_content_frame);
-    if (contentFrame != null) {
-      setResizeModeRaw(contentFrame, resizeMode);
-    }
-
-    // Shutter view.
-    shutterView = findViewById(R.id.exo_shutter);
-    if (shutterView != null && shutterColorSet) {
-      shutterView.setBackgroundColor(shutterColor);
-    }
-
-    // Create a surface view and insert it into the content frame, if there is one.
-    if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
-      ViewGroup.LayoutParams params =
-          new ViewGroup.LayoutParams(
-              ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
-      switch (surfaceType) {
-        case SURFACE_TYPE_TEXTURE_VIEW:
-          surfaceView = new TextureView(context);
-          break;
-        case SURFACE_TYPE_MONO360_VIEW:
-          Assertions.checkState(Util.SDK_INT >= 15);
-          SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
-          sphericalSurfaceView.setSurfaceListener(componentListener);
-          sphericalSurfaceView.setSingleTapListener(componentListener);
-          surfaceView = sphericalSurfaceView;
-          break;
-        default:
-          surfaceView = new SurfaceView(context);
-          break;
-      }
-      surfaceView.setLayoutParams(params);
-      contentFrame.addView(surfaceView, 0);
-    } else {
-      surfaceView = null;
-    }
-
-    // Ad overlay frame layout.
-    adOverlayFrameLayout = findViewById(R.id.exo_ad_overlay);
-
-    // Overlay frame layout.
-    overlayFrameLayout = findViewById(R.id.exo_overlay);
-
-    // Artwork view.
-    artworkView = findViewById(R.id.exo_artwork);
-    this.useArtwork = useArtwork && artworkView != null;
-    if (defaultArtworkId != 0) {
-      defaultArtwork = ContextCompat.getDrawable(getContext(), defaultArtworkId);
-    }
-
-    // Subtitle view.
-    subtitleView = findViewById(R.id.exo_subtitles);
-    if (subtitleView != null) {
-      subtitleView.setUserDefaultStyle();
-      subtitleView.setUserDefaultTextSize();
-    }
-
-    // Buffering view.
-    bufferingView = findViewById(R.id.exo_buffering);
-    if (bufferingView != null) {
-      bufferingView.setVisibility(View.GONE);
-    }
-    this.showBuffering = showBuffering;
-
-    // Error message view.
-    errorMessageView = findViewById(R.id.exo_error_message);
-    if (errorMessageView != null) {
-      errorMessageView.setVisibility(View.GONE);
-    }
-
-    // Playback control view.
-    PlayerControlView customController = findViewById(R.id.exo_controller);
-    View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);
-    if (customController != null) {
-      this.controller = customController;
-    } else if (controllerPlaceholder != null) {
-      // Propagate attrs as playbackAttrs so that PlayerControlView's custom attributes are
-      // transferred, but standard FrameLayout attributes (e.g. background) are not.
-      this.controller = new PlayerControlView(context, null, 0, attrs);
-      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
-      ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
-      int controllerIndex = parent.indexOfChild(controllerPlaceholder);
-      parent.removeView(controllerPlaceholder);
-      parent.addView(controller, controllerIndex);
-    } else {
-      this.controller = null;
-    }
-    this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0;
-    this.controllerHideOnTouch = controllerHideOnTouch;
-    this.controllerAutoShow = controllerAutoShow;
-    this.controllerHideDuringAds = controllerHideDuringAds;
-    this.useController = useController && controller != null;
-    hideController();
-  }
-
-  /**
-   * Switches the view targeted by a given {@link Player}.
-   *
-   * @param player The player whose target view is being switched.
-   * @param oldPlayerView The old view to detach from the player.
-   * @param newPlayerView The new view to attach to the player.
-   */
-  public static void switchTargetView(
-      Player player, @Nullable PlayerView oldPlayerView, @Nullable PlayerView newPlayerView) {
-    if (oldPlayerView == newPlayerView) {
-      return;
-    }
-    // We attach the new view before detaching the old one because this ordering allows the player
-    // to swap directly from one surface to another, without transitioning through a state where no
-    // surface is attached. This is significantly more efficient and achieves a more seamless
-    // transition when using platform provided video decoders.
-    if (newPlayerView != null) {
-      newPlayerView.setPlayer(player);
-    }
-    if (oldPlayerView != null) {
-      oldPlayerView.setPlayer(null);
-    }
-  }
-
-  /** Returns the player currently set on this view, or null if no player is set. */
-  public Player getPlayer() {
-    return player;
-  }
-
-  /**
-   * Set the {@link Player} to use.
-   *
-   * <p>To transition a {@link Player} from targeting one view to another, it's recommended to use
-   * {@link #switchTargetView(Player, PlayerView, PlayerView)} rather than this method. If you do
-   * wish to use this method directly, be sure to attach the player to the new view <em>before</em>
-   * calling {@code setPlayer(null)} to detach it from the old one. This ordering is significantly
-   * more efficient and may allow for more seamless transitions.
-   *
-   * @param player The {@link Player} to use, or {@code null} to detach the current player. Only
-   *     players which are accessed on the main thread are supported ({@code
-   *     player.getApplicationLooper() == Looper.getMainLooper()}).
-   */
-  public void setPlayer(@Nullable Player player) {
-    Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());
-    Assertions.checkArgument(
-        player == null || player.getApplicationLooper() == Looper.getMainLooper());
-    if (this.player == player) {
-      return;
-    }
-    if (this.player != null) {
-      this.player.removeListener(componentListener);
-      Player.VideoComponent oldVideoComponent = this.player.getVideoComponent();
-      if (oldVideoComponent != null) {
-        oldVideoComponent.removeVideoListener(componentListener);
-        if (surfaceView instanceof TextureView) {
-          oldVideoComponent.clearVideoTextureView((TextureView) surfaceView);
-        } else if (surfaceView instanceof SphericalSurfaceView) {
-          ((SphericalSurfaceView) surfaceView).setVideoComponent(null);
-        } else if (surfaceView instanceof SurfaceView) {
-          oldVideoComponent.clearVideoSurfaceView((SurfaceView) surfaceView);
-        }
-      }
-      Player.TextComponent oldTextComponent = this.player.getTextComponent();
-      if (oldTextComponent != null) {
-        oldTextComponent.removeTextOutput(componentListener);
-      }
-    }
-    this.player = player;
-    if (useController) {
-      controller.setPlayer(player);
-    }
-    if (subtitleView != null) {
-      subtitleView.setCues(null);
-    }
-    updateBuffering();
-    updateErrorMessage();
-    updateForCurrentTrackSelections(/* isNewPlayer= */ true);
-    if (player != null) {
-      Player.VideoComponent newVideoComponent = player.getVideoComponent();
-      if (newVideoComponent != null) {
-        if (surfaceView instanceof TextureView) {
-          newVideoComponent.setVideoTextureView((TextureView) surfaceView);
-        } else if (surfaceView instanceof SphericalSurfaceView) {
-          ((SphericalSurfaceView) surfaceView).setVideoComponent(newVideoComponent);
-        } else if (surfaceView instanceof SurfaceView) {
-          newVideoComponent.setVideoSurfaceView((SurfaceView) surfaceView);
-        }
-        newVideoComponent.addVideoListener(componentListener);
-      }
-      Player.TextComponent newTextComponent = player.getTextComponent();
-      if (newTextComponent != null) {
-        newTextComponent.addTextOutput(componentListener);
-      }
-      player.addListener(componentListener);
-      maybeShowController(false);
-    } else {
-      hideController();
-    }
-  }
-
-  @Override
-  public void setVisibility(int visibility) {
-    super.setVisibility(visibility);
-    if (surfaceView instanceof SurfaceView) {
-      // Work around https://github.com/google/ExoPlayer/issues/3160.
-      surfaceView.setVisibility(visibility);
-    }
-  }
-
-  /**
-   * Sets the {@link ResizeMode}.
-   *
-   * @param resizeMode The {@link ResizeMode}.
-   */
-  public void setResizeMode(@ResizeMode int resizeMode) {
-    Assertions.checkState(contentFrame != null);
-    contentFrame.setResizeMode(resizeMode);
-  }
-
-  /** Returns the {@link ResizeMode}. */
-  public @ResizeMode int getResizeMode() {
-    Assertions.checkState(contentFrame != null);
-    return contentFrame.getResizeMode();
-  }
-
-  /** Returns whether artwork is displayed if present in the media. */
-  public boolean getUseArtwork() {
-    return useArtwork;
-  }
-
-  /**
-   * Sets whether artwork is displayed if present in the media.
-   *
-   * @param useArtwork Whether artwork is displayed.
-   */
-  public void setUseArtwork(boolean useArtwork) {
-    Assertions.checkState(!useArtwork || artworkView != null);
-    if (this.useArtwork != useArtwork) {
-      this.useArtwork = useArtwork;
-      updateForCurrentTrackSelections(/* isNewPlayer= */ false);
-    }
-  }
-
-  /** Returns the default artwork to display. */
-  public @Nullable Drawable getDefaultArtwork() {
-    return defaultArtwork;
-  }
-
-  /**
-   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
-   * present in the media.
-   *
-   * @param defaultArtwork the default artwork to display.
-   * @deprecated use (@link {@link #setDefaultArtwork(Drawable)} instead.
-   */
-  @Deprecated
-  public void setDefaultArtwork(@Nullable Bitmap defaultArtwork) {
-    setDefaultArtwork(
-        defaultArtwork == null ? null : new BitmapDrawable(getResources(), defaultArtwork));
-  }
-
-  /**
-   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
-   * present in the media.
-   *
-   * @param defaultArtwork the default artwork to display
-   */
-  public void setDefaultArtwork(@Nullable Drawable defaultArtwork) {
-    if (this.defaultArtwork != defaultArtwork) {
-      this.defaultArtwork = defaultArtwork;
-      updateForCurrentTrackSelections(/* isNewPlayer= */ false);
-    }
-  }
-
-  /** Returns whether the playback controls can be shown. */
-  public boolean getUseController() {
-    return useController;
-  }
-
-  /**
-   * Sets whether the playback controls can be shown. If set to {@code false} the playback controls
-   * are never visible and are disconnected from the player.
-   *
-   * @param useController Whether the playback controls can be shown.
-   */
-  public void setUseController(boolean useController) {
-    Assertions.checkState(!useController || controller != null);
-    if (this.useController == useController) {
-      return;
-    }
-    this.useController = useController;
-    if (useController) {
-      controller.setPlayer(player);
-    } else if (controller != null) {
-      controller.hide();
-      controller.setPlayer(null);
-    }
-  }
-
-  /**
-   * Sets the background color of the {@code exo_shutter} view.
-   *
-   * @param color The background color.
-   */
-  public void setShutterBackgroundColor(int color) {
-    if (shutterView != null) {
-      shutterView.setBackgroundColor(color);
-    }
-  }
-
-  /**
-   * Sets whether the currently displayed video frame or media artwork is kept visible when the
-   * player is reset. A player reset is defined to mean the player being re-prepared with different
-   * media, the player transitioning to unprepared media, {@link Player#stop(boolean)} being called
-   * with {@code reset=true}, or the player being replaced or cleared by calling {@link
-   * #setPlayer(Player)}.
-   *
-   * <p>If enabled, the currently displayed video frame or media artwork will be kept visible until
-   * the player set on the view has been successfully prepared with new media and loaded enough of
-   * it to have determined the available tracks. Hence enabling this option allows transitioning
-   * from playing one piece of media to another, or from using one player instance to another,
-   * without clearing the view's content.
-   *
-   * <p>If disabled, the currently displayed video frame or media artwork will be hidden as soon as
-   * the player is reset. Note that the video frame is hidden by making {@code exo_shutter} visible.
-   * Hence the video frame will not be hidden if using a custom layout that omits this view.
-   *
-   * @param keepContentOnPlayerReset Whether the currently displayed video frame or media artwork is
-   *     kept visible when the player is reset.
-   */
-  public void setKeepContentOnPlayerReset(boolean keepContentOnPlayerReset) {
-    if (this.keepContentOnPlayerReset != keepContentOnPlayerReset) {
-      this.keepContentOnPlayerReset = keepContentOnPlayerReset;
-      updateForCurrentTrackSelections(/* isNewPlayer= */ false);
-    }
-  }
-
-  /**
-   * Sets whether a buffering spinner is displayed when the player is in the buffering state. The
-   * buffering spinner is not displayed by default.
-   *
-   * @deprecated Use {@link #setShowBuffering(int)}
-   * @param showBuffering Whether the buffering icon is displayed
-   */
-  @Deprecated
-  public void setShowBuffering(boolean showBuffering) {
-    setShowBuffering(showBuffering ? SHOW_BUFFERING_WHEN_PLAYING : SHOW_BUFFERING_NEVER);
-  }
-
-  /**
-   * Sets whether a buffering spinner is displayed when the player is in the buffering state. The
-   * buffering spinner is not displayed by default.
-   *
-   * @param showBuffering The mode that defines when the buffering spinner is displayed. One of
-   *     {@link #SHOW_BUFFERING_NEVER}, {@link #SHOW_BUFFERING_WHEN_PLAYING} and
-   *     {@link #SHOW_BUFFERING_ALWAYS}.
-   */
-  public void setShowBuffering(@ShowBuffering int showBuffering) {
-    if (this.showBuffering != showBuffering) {
-      this.showBuffering = showBuffering;
-      updateBuffering();
-    }
-  }
-
-  /**
-   * Sets the optional {@link ErrorMessageProvider}.
-   *
-   * @param errorMessageProvider The error message provider.
-   */
-  public void setErrorMessageProvider(
-      @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider) {
-    if (this.errorMessageProvider != errorMessageProvider) {
-      this.errorMessageProvider = errorMessageProvider;
-      updateErrorMessage();
-    }
-  }
-
-  /**
-   * Sets a custom error message to be displayed by the view. The error message will be displayed
-   * permanently, unless it is cleared by passing {@code null} to this method.
-   *
-   * @param message The message to display, or {@code null} to clear a previously set message.
-   */
-  public void setCustomErrorMessage(@Nullable CharSequence message) {
-    Assertions.checkState(errorMessageView != null);
-    customErrorMessage = message;
-    updateErrorMessage();
-  }
-
-  @Override
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    if (player != null && player.isPlayingAd()) {
-      return super.dispatchKeyEvent(event);
-    }
-    boolean isDpadWhenControlHidden =
-        isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
-    boolean handled =
-        isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-    if (handled) {
-      maybeShowController(true);
-    }
-    return handled;
-  }
-
-  /**
-   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
-   * events will be handled. Does nothing if playback controls are disabled.
-   *
-   * @param event A key event.
-   * @return Whether the key event was handled.
-   */
-  public boolean dispatchMediaKeyEvent(KeyEvent event) {
-    return useController && controller.dispatchMediaKeyEvent(event);
-  }
-
-  /** Returns whether the controller is currently visible. */
-  public boolean isControllerVisible() {
-    return controller != null && controller.isVisible();
-  }
-
-  /**
-   * Shows the playback controls. Does nothing if playback controls are disabled.
-   *
-   * <p>The playback controls are automatically hidden during playback after {{@link
-   * #getControllerShowTimeoutMs()}}. They are shown indefinitely when playback has not started yet,
-   * is paused, has ended or failed.
-   */
-  public void showController() {
-    showController(shouldShowControllerIndefinitely());
-  }
-
-  /** Hides the playback controls. Does nothing if playback controls are disabled. */
-  public void hideController() {
-    if (controller != null) {
-      controller.hide();
-    }
-  }
-
-  /**
-   * Returns the playback controls timeout. The playback controls are automatically hidden after
-   * this duration of time has elapsed without user input and with playback or buffering in
-   * progress.
-   *
-   * @return The timeout in milliseconds. A non-positive value will cause the controller to remain
-   *     visible indefinitely.
-   */
-  public int getControllerShowTimeoutMs() {
-    return controllerShowTimeoutMs;
-  }
-
-  /**
-   * Sets the playback controls timeout. The playback controls are automatically hidden after this
-   * duration of time has elapsed without user input and with playback or buffering in progress.
-   *
-   * @param controllerShowTimeoutMs The timeout in milliseconds. A non-positive value will cause the
-   *     controller to remain visible indefinitely.
-   */
-  public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
-    Assertions.checkState(controller != null);
-    this.controllerShowTimeoutMs = controllerShowTimeoutMs;
-    if (controller.isVisible()) {
-      // Update the controller's timeout if necessary.
-      showController();
-    }
-  }
-
-  /** Returns whether the playback controls are hidden by touch events. */
-  public boolean getControllerHideOnTouch() {
-    return controllerHideOnTouch;
-  }
-
-  /**
-   * Sets whether the playback controls are hidden by touch events.
-   *
-   * @param controllerHideOnTouch Whether the playback controls are hidden by touch events.
-   */
-  public void setControllerHideOnTouch(boolean controllerHideOnTouch) {
-    Assertions.checkState(controller != null);
-    this.controllerHideOnTouch = controllerHideOnTouch;
-  }
-
-  /**
-   * Returns whether the playback controls are automatically shown when playback starts, pauses,
-   * ends, or fails. If set to false, the playback controls can be manually operated with {@link
-   * #showController()} and {@link #hideController()}.
-   */
-  public boolean getControllerAutoShow() {
-    return controllerAutoShow;
-  }
-
-  /**
-   * Sets whether the playback controls are automatically shown when playback starts, pauses, ends,
-   * or fails. If set to false, the playback controls can be manually operated with {@link
-   * #showController()} and {@link #hideController()}.
-   *
-   * @param controllerAutoShow Whether the playback controls are allowed to show automatically.
-   */
-  public void setControllerAutoShow(boolean controllerAutoShow) {
-    this.controllerAutoShow = controllerAutoShow;
-  }
-
-  /**
-   * Sets whether the playback controls are hidden when ads are playing. Controls are always shown
-   * during ads if they are enabled and the player is paused.
-   *
-   * @param controllerHideDuringAds Whether the playback controls are hidden when ads are playing.
-   */
-  public void setControllerHideDuringAds(boolean controllerHideDuringAds) {
-    this.controllerHideDuringAds = controllerHideDuringAds;
-  }
-
-  /**
-   * Set the {@link PlayerControlView.VisibilityListener}.
-   *
-   * @param listener The listener to be notified about visibility changes.
-   */
-  public void setControllerVisibilityListener(PlayerControlView.VisibilityListener listener) {
-    Assertions.checkState(controller != null);
-    controller.setVisibilityListener(listener);
-  }
-
-  /**
-   * Sets the {@link PlaybackPreparer}.
-   *
-   * @param playbackPreparer The {@link PlaybackPreparer}.
-   */
-  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
-    Assertions.checkState(controller != null);
-    controller.setPlaybackPreparer(playbackPreparer);
-  }
-
-  /**
-   * Sets the {@link ControlDispatcher}.
-   *
-   * @param controlDispatcher The {@link ControlDispatcher}, or null to use {@link
-   *     DefaultControlDispatcher}.
-   */
-  public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
-    Assertions.checkState(controller != null);
-    controller.setControlDispatcher(controlDispatcher);
-  }
-
-  /**
-   * Sets the rewind increment in milliseconds.
-   *
-   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
-   *     rewind button to be disabled.
-   */
-  public void setRewindIncrementMs(int rewindMs) {
-    Assertions.checkState(controller != null);
-    controller.setRewindIncrementMs(rewindMs);
-  }
-
-  /**
-   * Sets the fast forward increment in milliseconds.
-   *
-   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
-   *     cause the fast forward button to be disabled.
-   */
-  public void setFastForwardIncrementMs(int fastForwardMs) {
-    Assertions.checkState(controller != null);
-    controller.setFastForwardIncrementMs(fastForwardMs);
-  }
-
-  /**
-   * Sets which repeat toggle modes are enabled.
-   *
-   * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
-   */
-  public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    Assertions.checkState(controller != null);
-    controller.setRepeatToggleModes(repeatToggleModes);
-  }
-
-  /**
-   * Sets whether the shuffle button is shown.
-   *
-   * @param showShuffleButton Whether the shuffle button is shown.
-   */
-  public void setShowShuffleButton(boolean showShuffleButton) {
-    Assertions.checkState(controller != null);
-    controller.setShowShuffleButton(showShuffleButton);
-  }
-
-  /**
-   * Sets whether the time bar should show all windows, as opposed to just the current one.
-   *
-   * @param showMultiWindowTimeBar Whether to show all windows.
-   */
-  public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
-    Assertions.checkState(controller != null);
-    controller.setShowMultiWindowTimeBar(showMultiWindowTimeBar);
-  }
-
-  /**
-   * Sets the millisecond positions of extra ad markers relative to the start of the window (or
-   * timeline, if in multi-window mode) and whether each extra ad has been played or not. The
-   * markers are shown in addition to any ad markers for ads in the player's timeline.
-   *
-   * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
-   *     {@code null} to show no extra ad markers.
-   * @param extraPlayedAdGroups Whether each ad has been played, or {@code null} to show no extra ad
-   *     markers.
-   */
-  public void setExtraAdGroupMarkers(
-      @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {
-    Assertions.checkState(controller != null);
-    controller.setExtraAdGroupMarkers(extraAdGroupTimesMs, extraPlayedAdGroups);
-  }
-
-  /**
-   * Set the {@link AspectRatioFrameLayout.AspectRatioListener}.
-   *
-   * @param listener The listener to be notified about aspect ratios changes of the video content or
-   *     the content frame.
-   */
-  public void setAspectRatioListener(AspectRatioFrameLayout.AspectRatioListener listener) {
-    Assertions.checkState(contentFrame != null);
-    contentFrame.setAspectRatioListener(listener);
-  }
-
-  /**
-   * Gets the view onto which video is rendered. This is a:
-   *
-   * <ul>
-   *   <li>{@link SurfaceView} by default, or if the {@code surface_type} attribute is set to {@code
-   *       surface_view}.
-   *   <li>{@link TextureView} if {@code surface_type} is {@code texture_view}.
-   *   <li>{@link SphericalSurfaceView} if {@code surface_type} is {@code spherical_view}.
-   *   <li>{@code null} if {@code surface_type} is {@code none}.
-   * </ul>
-   *
-   * @return The {@link SurfaceView}, {@link TextureView}, {@link SphericalSurfaceView} or {@code
-   *     null}.
-   */
-  public View getVideoSurfaceView() {
-    return surfaceView;
-  }
-
-  /**
-   * Gets the overlay {@link FrameLayout}, which can be populated with UI elements to show on top of
-   * the player.
-   *
-   * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
-   *     the overlay is not present.
-   */
-  @Nullable
-  public FrameLayout getOverlayFrameLayout() {
-    return overlayFrameLayout;
-  }
-
-  /**
-   * Gets the {@link SubtitleView}.
-   *
-   * @return The {@link SubtitleView}, or {@code null} if the layout has been customized and the
-   *     subtitle view is not present.
-   */
-  public SubtitleView getSubtitleView() {
-    return subtitleView;
-  }
-
-  @Override
-  public boolean onTouchEvent(MotionEvent ev) {
-    if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
-      return false;
-    }
-    return performClick();
-  }
-
-  @Override
-  public boolean performClick() {
-    super.performClick();
-    return toggleControllerVisibility();
-  }
-
-  @Override
-  public boolean onTrackballEvent(MotionEvent ev) {
-    if (!useController || player == null) {
-      return false;
-    }
-    maybeShowController(true);
-    return true;
-  }
-
-  /**
-   * Should be called when the player is visible to the user and if {@code surface_type} is {@code
-   * spherical_view}. It is the counterpart to {@link #onPause()}.
-   *
-   * <p>This method should typically be called in {@link Activity#onStart()}, or {@link
-   * Activity#onResume()} for API versions &lt;= 23.
-   */
-  public void onResume() {
-    if (surfaceView instanceof SphericalSurfaceView) {
-      ((SphericalSurfaceView) surfaceView).onResume();
-    }
-  }
-
-  /**
-   * Should be called when the player is no longer visible to the user and if {@code surface_type}
-   * is {@code spherical_view}. It is the counterpart to {@link #onResume()}.
-   *
-   * <p>This method should typically be called in {@link Activity#onStop()}, or {@link
-   * Activity#onPause()} for API versions &lt;= 23.
-   */
-  public void onPause() {
-    if (surfaceView instanceof SphericalSurfaceView) {
-      ((SphericalSurfaceView) surfaceView).onPause();
-    }
-  }
-
-  /**
-   * Called when there's a change in the aspect ratio of the content being displayed. The default
-   * implementation sets the aspect ratio of the content frame to that of the content, unless the
-   * content view is a {@link SphericalSurfaceView} in which case the frame's aspect ratio is
-   * cleared.
-   *
-   * @param contentAspectRatio The aspect ratio of the content.
-   * @param contentFrame The content frame, or {@code null}.
-   * @param contentView The view that holds the content being displayed, or {@code null}.
-   */
-  protected void onContentAspectRatioChanged(
-      float contentAspectRatio,
-      @Nullable AspectRatioFrameLayout contentFrame,
-      @Nullable View contentView) {
-    if (contentFrame != null) {
-      contentFrame.setAspectRatio(
-          contentView instanceof SphericalSurfaceView ? 0 : contentAspectRatio);
-    }
-  }
-
-  // AdsLoader.AdViewProvider implementation.
-
-  @Override
-  public ViewGroup getAdViewGroup() {
-    return Assertions.checkNotNull(
-        adOverlayFrameLayout, "exo_ad_overlay must be present for ad playback");
-  }
-
-  @Override
-  public View[] getAdOverlayViews() {
-    ArrayList<View> overlayViews = new ArrayList<>();
-    if (overlayFrameLayout != null) {
-      overlayViews.add(overlayFrameLayout);
-    }
-    if (controller != null) {
-      overlayViews.add(controller);
-    }
-    return overlayViews.toArray(new View[0]);
-  }
-
-  // Internal methods.
-
-  private boolean toggleControllerVisibility() {
-    if (!useController || player == null) {
-      return false;
-    }
-    if (!controller.isVisible()) {
-      maybeShowController(true);
-    } else if (controllerHideOnTouch) {
-      controller.hide();
-    }
-    return true;
-  }
-
-  /** Shows the playback controls, but only if forced or shown indefinitely. */
-  private void maybeShowController(boolean isForced) {
-    if (isPlayingAd() && controllerHideDuringAds) {
-      return;
-    }
-    if (useController) {
-      boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;
-      boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();
-      if (isForced || wasShowingIndefinitely || shouldShowIndefinitely) {
-        showController(shouldShowIndefinitely);
-      }
-    }
-  }
-
-  private boolean shouldShowControllerIndefinitely() {
-    if (player == null) {
-      return true;
-    }
-    int playbackState = player.getPlaybackState();
-    return controllerAutoShow
-        && (playbackState == Player.STATE_IDLE
-            || playbackState == Player.STATE_ENDED
-            || !player.getPlayWhenReady());
-  }
-
-  private void showController(boolean showIndefinitely) {
-    if (!useController) {
-      return;
-    }
-    controller.setShowTimeoutMs(showIndefinitely ? 0 : controllerShowTimeoutMs);
-    controller.show();
-  }
-
-  private boolean isPlayingAd() {
-    return player != null && player.isPlayingAd() && player.getPlayWhenReady();
-  }
-
-  private void updateForCurrentTrackSelections(boolean isNewPlayer) {
-    if (player == null || player.getCurrentTrackGroups().isEmpty()) {
-      if (!keepContentOnPlayerReset) {
-        hideArtwork();
-        closeShutter();
-      }
-      return;
+    // LINT.IfChange
+
+    /**
+     * Determines when the buffering view is shown. One of {@link #SHOW_BUFFERING_NEVER}, {@link
+     * #SHOW_BUFFERING_WHEN_PLAYING} or {@link #SHOW_BUFFERING_ALWAYS}.
+     */
+    @Documented
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({SHOW_BUFFERING_NEVER, SHOW_BUFFERING_WHEN_PLAYING, SHOW_BUFFERING_ALWAYS})
+    public @interface ShowBuffering {
+    }
+
+    /**
+     * The buffering view is never shown.
+     */
+    public static final int SHOW_BUFFERING_NEVER = 0;
+    /**
+     * The buffering view is shown when the player is in the {@link Player#STATE_BUFFERING buffering}
+     * state and {@link Player#getPlayWhenReady() playWhenReady} is {@code true}.
+     */
+    public static final int SHOW_BUFFERING_WHEN_PLAYING = 1;
+    /**
+     * The buffering view is always shown when the player is in the {@link Player#STATE_BUFFERING
+     * buffering} state.
+     */
+    public static final int SHOW_BUFFERING_ALWAYS = 2;
+    // LINT.ThenChange(../../../../../../res/values/attrs.xml)
+
+    // LINT.IfChange
+    private static final int SURFACE_TYPE_NONE = 0;
+    private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
+    private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
+    private static final int SURFACE_TYPE_MONO360_VIEW = 3;
+    // LINT.ThenChange(../../../../../../res/values/attrs.xml)
+
+    @Nullable
+    private final AspectRatioFrameLayout contentFrame;
+    private final View shutterView;
+    @Nullable
+    private final View surfaceView;
+    private final ImageView artworkView;
+    private final SubtitleView subtitleView;
+    @Nullable
+    private final View bufferingView;
+    @Nullable
+    private final TextView errorMessageView;
+    @Nullable
+    private final PlayerControlView controller;
+    private final ComponentListener componentListener;
+    @Nullable
+    private final FrameLayout adOverlayFrameLayout;
+    @Nullable
+    private final FrameLayout overlayFrameLayout;
+
+    private Player player;
+    private boolean useController;
+    private boolean useArtwork;
+    @Nullable
+    private Drawable defaultArtwork;
+    private @ShowBuffering
+    int showBuffering;
+    private boolean keepContentOnPlayerReset;
+    @Nullable
+    private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
+    @Nullable
+    private CharSequence customErrorMessage;
+    private int controllerShowTimeoutMs;
+    private boolean controllerAutoShow;
+    private boolean controllerHideDuringAds;
+    private boolean controllerHideOnTouch;
+    private int textureViewRotation;
+
+    public PlayerView(Context context) {
+        this(context, null);
+    }
+
+    public PlayerView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+
+        if (isInEditMode()) {
+            contentFrame = null;
+            shutterView = null;
+            surfaceView = null;
+            artworkView = null;
+            subtitleView = null;
+            bufferingView = null;
+            errorMessageView = null;
+            controller = null;
+            componentListener = null;
+            adOverlayFrameLayout = null;
+            overlayFrameLayout = null;
+            ImageView logo = new ImageView(context);
+            if (Util.SDK_INT >= 23) {
+                configureEditModeLogoV23(getResources(), logo);
+            } else {
+                configureEditModeLogo(getResources(), logo);
+            }
+            addView(logo);
+            return;
+        }
+
+        boolean shutterColorSet = false;
+        int shutterColor = 0;
+        int playerLayoutId = R.layout.exo_player_view;
+        boolean useArtwork = true;
+        int defaultArtworkId = 0;
+        boolean useController = true;
+        int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
+        int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
+        int controllerShowTimeoutMs = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
+        boolean controllerHideOnTouch = true;
+        boolean controllerAutoShow = true;
+        boolean controllerHideDuringAds = true;
+        int showBuffering = SHOW_BUFFERING_NEVER;
+        if (attrs != null) {
+            TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.PlayerView, 0, 0);
+            try {
+                shutterColorSet = a.hasValue(R.styleable.PlayerView_shutter_background_color);
+                shutterColor = a.getColor(R.styleable.PlayerView_shutter_background_color, shutterColor);
+                playerLayoutId = a.getResourceId(R.styleable.PlayerView_player_layout_id, playerLayoutId);
+                useArtwork = a.getBoolean(R.styleable.PlayerView_use_artwork, useArtwork);
+                defaultArtworkId =
+                        a.getResourceId(R.styleable.PlayerView_default_artwork, defaultArtworkId);
+                useController = a.getBoolean(R.styleable.PlayerView_use_controller, useController);
+                surfaceType = a.getInt(R.styleable.PlayerView_surface_type, surfaceType);
+                resizeMode = a.getInt(R.styleable.PlayerView_resize_mode, resizeMode);
+                controllerShowTimeoutMs =
+                        a.getInt(R.styleable.PlayerView_show_timeout, controllerShowTimeoutMs);
+                controllerHideOnTouch =
+                        a.getBoolean(R.styleable.PlayerView_hide_on_touch, controllerHideOnTouch);
+                controllerAutoShow = a.getBoolean(R.styleable.PlayerView_auto_show, controllerAutoShow);
+                showBuffering = a.getInteger(R.styleable.PlayerView_show_buffering, showBuffering);
+                keepContentOnPlayerReset =
+                        a.getBoolean(
+                                R.styleable.PlayerView_keep_content_on_player_reset, keepContentOnPlayerReset);
+                controllerHideDuringAds =
+                        a.getBoolean(R.styleable.PlayerView_hide_during_ads, controllerHideDuringAds);
+            } finally {
+                a.recycle();
+            }
+        }
+
+        LayoutInflater.from(context).inflate(playerLayoutId, this);
+        componentListener = new ComponentListener();
+        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
+
+        // Content frame.
+        contentFrame = findViewById(R.id.exo_content_frame);
+        if (contentFrame != null) {
+            setResizeModeRaw(contentFrame, resizeMode);
+        }
+
+        // Shutter view.
+        shutterView = findViewById(R.id.exo_shutter);
+        if (shutterView != null && shutterColorSet) {
+            shutterView.setBackgroundColor(shutterColor);
+        }
+
+        // Create a surface view and insert it into the content frame, if there is one.
+        if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
+            ViewGroup.LayoutParams params =
+                    new ViewGroup.LayoutParams(
+                            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+            switch (surfaceType) {
+                case SURFACE_TYPE_TEXTURE_VIEW:
+                    surfaceView = new TextureView(context);
+                    break;
+                case SURFACE_TYPE_MONO360_VIEW:
+                    Assertions.checkState(Util.SDK_INT >= 15);
+                    SphericalSurfaceView sphericalSurfaceView = new SphericalSurfaceView(context);
+                    sphericalSurfaceView.setSurfaceListener(componentListener);
+                    sphericalSurfaceView.setSingleTapListener(componentListener);
+                    surfaceView = sphericalSurfaceView;
+                    break;
+                default:
+                    surfaceView = new SurfaceView(context);
+                    break;
+            }
+            surfaceView.setLayoutParams(params);
+            contentFrame.addView(surfaceView, 0);
+        } else {
+            surfaceView = null;
+        }
+
+        // Ad overlay frame layout.
+        adOverlayFrameLayout = findViewById(R.id.exo_ad_overlay);
+
+        // Overlay frame layout.
+        overlayFrameLayout = findViewById(R.id.exo_overlay);
+
+        // Artwork view.
+        artworkView = findViewById(R.id.exo_artwork);
+        this.useArtwork = useArtwork && artworkView != null;
+        if (defaultArtworkId != 0) {
+            defaultArtwork = ContextCompat.getDrawable(getContext(), defaultArtworkId);
+        }
+
+        // Subtitle view.
+        subtitleView = findViewById(R.id.exo_subtitles);
+        if (subtitleView != null) {
+            subtitleView.setUserDefaultStyle();
+            subtitleView.setUserDefaultTextSize();
+        }
+
+        // Buffering view.
+        bufferingView = findViewById(R.id.exo_buffering);
+        if (bufferingView != null) {
+            bufferingView.setVisibility(View.GONE);
+        }
+        this.showBuffering = showBuffering;
+
+        // Error message view.
+        errorMessageView = findViewById(R.id.exo_error_message);
+        if (errorMessageView != null) {
+            errorMessageView.setVisibility(View.GONE);
+        }
+
+        // Playback control view.
+        PlayerControlView customController = findViewById(R.id.exo_controller);
+        View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);
+        if (customController != null) {
+            this.controller = customController;
+        } else if (controllerPlaceholder != null) {
+            // Propagate attrs as playbackAttrs so that PlayerControlView's custom attributes are
+            // transferred, but standard FrameLayout attributes (e.g. background) are not.
+            this.controller = new PlayerControlView(context, null, 0, attrs);
+            controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
+            ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
+            int controllerIndex = parent.indexOfChild(controllerPlaceholder);
+            parent.removeView(controllerPlaceholder);
+            parent.addView(controller, controllerIndex);
+        } else {
+            this.controller = null;
+        }
+        this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0;
+        this.controllerHideOnTouch = controllerHideOnTouch;
+        this.controllerAutoShow = controllerAutoShow;
+        this.controllerHideDuringAds = controllerHideDuringAds;
+        this.useController = useController && controller != null;
+        hideController();
     }
 
-    if (isNewPlayer && !keepContentOnPlayerReset) {
-      // Hide any video from the previous player.
-      closeShutter();
+    /**
+     * Switches the view targeted by a given {@link Player}.
+     *
+     * @param player        The player whose target view is being switched.
+     * @param oldPlayerView The old view to detach from the player.
+     * @param newPlayerView The new view to attach to the player.
+     */
+    public static void switchTargetView(
+            Player player, @Nullable PlayerView oldPlayerView, @Nullable PlayerView newPlayerView) {
+        if (oldPlayerView == newPlayerView) {
+            return;
+        }
+        // We attach the new view before detaching the old one because this ordering allows the player
+        // to swap directly from one surface to another, without transitioning through a state where no
+        // surface is attached. This is significantly more efficient and achieves a more seamless
+        // transition when using platform provided video decoders.
+        if (newPlayerView != null) {
+            newPlayerView.setPlayer(player);
+        }
+        if (oldPlayerView != null) {
+            oldPlayerView.setPlayer(null);
+        }
     }
 
-    TrackSelectionArray selections = player.getCurrentTrackSelections();
-    for (int i = 0; i < selections.length; i++) {
-      if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
-        // Video enabled so artwork must be hidden. If the shutter is closed, it will be opened in
-        // onRenderedFirstFrame().
-        hideArtwork();
-        return;
-      }
-    }
-
-    // Video disabled so the shutter must be closed.
-    closeShutter();
-    // Display artwork if enabled and available, else hide it.
-    if (useArtwork) {
-      for (int i = 0; i < selections.length; i++) {
-        TrackSelection selection = selections.get(i);
-        if (selection != null) {
-          for (int j = 0; j < selection.length(); j++) {
-            Metadata metadata = selection.getFormat(j).metadata;
-            if (metadata != null && setArtworkFromMetadata(metadata)) {
-              return;
+    /**
+     * Returns the player currently set on this view, or null if no player is set.
+     */
+    public Player getPlayer() {
+        return player;
+    }
+
+    /**
+     * Set the {@link Player} to use.
+     *
+     * <p>To transition a {@link Player} from targeting one view to another, it's recommended to use
+     * {@link #switchTargetView(Player, PlayerView, PlayerView)} rather than this method. If you do
+     * wish to use this method directly, be sure to attach the player to the new view <em>before</em>
+     * calling {@code setPlayer(null)} to detach it from the old one. This ordering is significantly
+     * more efficient and may allow for more seamless transitions.
+     *
+     * @param player The {@link Player} to use, or {@code null} to detach the current player. Only
+     *               players which are accessed on the main thread are supported ({@code
+     *               player.getApplicationLooper() == Looper.getMainLooper()}).
+     */
+    public void setPlayer(@Nullable Player player) {
+        Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());
+        Assertions.checkArgument(
+                player == null || player.getApplicationLooper() == Looper.getMainLooper());
+        if (this.player == player) {
+            return;
+        }
+        if (this.player != null) {
+            this.player.removeListener(componentListener);
+            Player.VideoComponent oldVideoComponent = this.player.getVideoComponent();
+            if (oldVideoComponent != null) {
+                oldVideoComponent.removeVideoListener(componentListener);
+                if (surfaceView instanceof TextureView) {
+                    oldVideoComponent.clearVideoTextureView((TextureView) surfaceView);
+                } else if (surfaceView instanceof SphericalSurfaceView) {
+                    ((SphericalSurfaceView) surfaceView).setVideoComponent(null);
+                } else if (surfaceView instanceof SurfaceView) {
+                    oldVideoComponent.clearVideoSurfaceView((SurfaceView) surfaceView);
+                }
             }
-          }
-        }
-      }
-      if (setDrawableArtwork(defaultArtwork)) {
-        return;
-      }
-    }
-    // Artwork disabled or unavailable.
-    hideArtwork();
-  }
-
-  private boolean setArtworkFromMetadata(Metadata metadata) {
-    for (int i = 0; i < metadata.length(); i++) {
-      Metadata.Entry metadataEntry = metadata.get(i);
-      if (metadataEntry instanceof ApicFrame) {
-        byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
-        Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        return setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
-      }
-    }
-    return false;
-  }
-
-  private boolean setDrawableArtwork(@Nullable Drawable drawable) {
-    if (drawable != null) {
-      int drawableWidth = drawable.getIntrinsicWidth();
-      int drawableHeight = drawable.getIntrinsicHeight();
-      if (drawableWidth > 0 && drawableHeight > 0) {
-        float artworkAspectRatio = (float) drawableWidth / drawableHeight;
-        onContentAspectRatioChanged(artworkAspectRatio, contentFrame, artworkView);
-        artworkView.setImageDrawable(drawable);
-        artworkView.setVisibility(VISIBLE);
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private void hideArtwork() {
-    if (artworkView != null) {
-      artworkView.setImageResource(android.R.color.transparent); // Clears any bitmap reference.
-      artworkView.setVisibility(INVISIBLE);
-    }
-  }
-
-  private void closeShutter() {
-    if (shutterView != null) {
-      shutterView.setVisibility(View.VISIBLE);
-    }
-  }
-
-  private void updateBuffering() {
-    if (bufferingView != null) {
-      boolean showBufferingSpinner =
-          player != null
-              && player.getPlaybackState() == Player.STATE_BUFFERING
-              && (showBuffering == SHOW_BUFFERING_ALWAYS
-                  || (showBuffering == SHOW_BUFFERING_WHEN_PLAYING && player.getPlayWhenReady()));
-      bufferingView.setVisibility(showBufferingSpinner ? View.VISIBLE : View.GONE);
-    }
-  }
-
-  private void updateErrorMessage() {
-    if (errorMessageView != null) {
-      if (customErrorMessage != null) {
-        errorMessageView.setText(customErrorMessage);
-        errorMessageView.setVisibility(View.VISIBLE);
-        return;
-      }
-      ExoPlaybackException error = null;
-      if (player != null
-          && player.getPlaybackState() == Player.STATE_IDLE
-          && errorMessageProvider != null) {
-        error = player.getPlaybackError();
-      }
-      if (error != null) {
-        CharSequence errorMessage = errorMessageProvider.getErrorMessage(error).second;
-        errorMessageView.setText(errorMessage);
-        errorMessageView.setVisibility(View.VISIBLE);
-      } else {
-        errorMessageView.setVisibility(View.GONE);
-      }
-    }
-  }
-
-  @TargetApi(23)
-  private static void configureEditModeLogoV23(Resources resources, ImageView logo) {
-    logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo, null));
-    logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color, null));
-  }
-
-  @SuppressWarnings("deprecation")
-  private static void configureEditModeLogo(Resources resources, ImageView logo) {
-    logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo));
-    logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color));
-  }
-
-  @SuppressWarnings("ResourceType")
-  private static void setResizeModeRaw(AspectRatioFrameLayout aspectRatioFrame, int resizeMode) {
-    aspectRatioFrame.setResizeMode(resizeMode);
-  }
-
-  /** Applies a texture rotation to a {@link TextureView}. */
-  private static void applyTextureViewRotation(TextureView textureView, int textureViewRotation) {
-    float textureViewWidth = textureView.getWidth();
-    float textureViewHeight = textureView.getHeight();
-    if (textureViewWidth == 0 || textureViewHeight == 0 || textureViewRotation == 0) {
-      textureView.setTransform(null);
-    } else {
-      Matrix transformMatrix = new Matrix();
-      float pivotX = textureViewWidth / 2;
-      float pivotY = textureViewHeight / 2;
-      transformMatrix.postRotate(textureViewRotation, pivotX, pivotY);
-
-      // After rotation, scale the rotated texture to fit the TextureView size.
-      RectF originalTextureRect = new RectF(0, 0, textureViewWidth, textureViewHeight);
-      RectF rotatedTextureRect = new RectF();
-      transformMatrix.mapRect(rotatedTextureRect, originalTextureRect);
-      transformMatrix.postScale(
-          textureViewWidth / rotatedTextureRect.width(),
-          textureViewHeight / rotatedTextureRect.height(),
-          pivotX,
-          pivotY);
-      textureView.setTransform(transformMatrix);
-    }
-  }
-
-  @SuppressLint("InlinedApi")
-  private boolean isDpadKey(int keyCode) {
-    return keyCode == KeyEvent.KEYCODE_DPAD_UP
-        || keyCode == KeyEvent.KEYCODE_DPAD_UP_RIGHT
-        || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT
-        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_RIGHT
-        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN
-        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_LEFT
-        || keyCode == KeyEvent.KEYCODE_DPAD_LEFT
-        || keyCode == KeyEvent.KEYCODE_DPAD_UP_LEFT
-        || keyCode == KeyEvent.KEYCODE_DPAD_CENTER;
-  }
-
-  private final class ComponentListener
-      implements Player.EventListener,
-          TextOutput,
-          VideoListener,
-          OnLayoutChangeListener,
-          SphericalSurfaceView.SurfaceListener,
-          SingleTapListener {
-
-    // TextOutput implementation
+            Player.TextComponent oldTextComponent = this.player.getTextComponent();
+            if (oldTextComponent != null) {
+                oldTextComponent.removeTextOutput(componentListener);
+            }
+        }
+        this.player = player;
+        if (useController) {
+            controller.setPlayer(player);
+        }
+        if (subtitleView != null) {
+            subtitleView.setCues(null);
+        }
+        updateBuffering();
+        updateErrorMessage();
+        updateForCurrentTrackSelections(/* isNewPlayer= */ true);
+        if (player != null) {
+            Player.VideoComponent newVideoComponent = player.getVideoComponent();
+            if (newVideoComponent != null) {
+                if (surfaceView instanceof TextureView) {
+                    newVideoComponent.setVideoTextureView((TextureView) surfaceView);
+                } else if (surfaceView instanceof SphericalSurfaceView) {
+                    ((SphericalSurfaceView) surfaceView).setVideoComponent(newVideoComponent);
+                } else if (surfaceView instanceof SurfaceView) {
+                    newVideoComponent.setVideoSurfaceView((SurfaceView) surfaceView);
+                }
+                newVideoComponent.addVideoListener(componentListener);
+            }
+            Player.TextComponent newTextComponent = player.getTextComponent();
+            if (newTextComponent != null) {
+                newTextComponent.addTextOutput(componentListener);
+            }
+            player.addListener(componentListener);
+            maybeShowController(false);
+        } else {
+            hideController();
+        }
+    }
 
     @Override
-    public void onCues(List<Cue> cues) {
-      if (subtitleView != null) {
-        subtitleView.onCues(cues);
-      }
+    public void setVisibility(int visibility) {
+        super.setVisibility(visibility);
+        if (surfaceView instanceof SurfaceView) {
+            // Work around https://github.com/google/ExoPlayer/issues/3160.
+            surfaceView.setVisibility(visibility);
+        }
+    }
+
+    /**
+     * Sets the {@link ResizeMode}.
+     *
+     * @param resizeMode The {@link ResizeMode}.
+     */
+    public void setResizeMode(@ResizeMode int resizeMode) {
+        Assertions.checkState(contentFrame != null);
+        contentFrame.setResizeMode(resizeMode);
+    }
+
+    /**
+     * Returns the {@link ResizeMode}.
+     */
+    public @ResizeMode
+    int getResizeMode() {
+        Assertions.checkState(contentFrame != null);
+        return contentFrame.getResizeMode();
+    }
+
+    /**
+     * Returns whether artwork is displayed if present in the media.
+     */
+    public boolean getUseArtwork() {
+        return useArtwork;
+    }
+
+    /**
+     * Sets whether artwork is displayed if present in the media.
+     *
+     * @param useArtwork Whether artwork is displayed.
+     */
+    public void setUseArtwork(boolean useArtwork) {
+        Assertions.checkState(!useArtwork || artworkView != null);
+        if (this.useArtwork != useArtwork) {
+            this.useArtwork = useArtwork;
+            updateForCurrentTrackSelections(/* isNewPlayer= */ false);
+        }
     }
 
-    // VideoListener implementation
+    /**
+     * Returns the default artwork to display.
+     */
+    public @Nullable
+    Drawable getDefaultArtwork() {
+        return defaultArtwork;
+    }
+
+    /**
+     * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+     * present in the media.
+     *
+     * @param defaultArtwork the default artwork to display.
+     * @deprecated use (@link {@link #setDefaultArtwork(Drawable)} instead.
+     */
+    @Deprecated
+    public void setDefaultArtwork(@Nullable Bitmap defaultArtwork) {
+        setDefaultArtwork(
+                defaultArtwork == null ? null : new BitmapDrawable(getResources(), defaultArtwork));
+    }
+
+    /**
+     * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+     * present in the media.
+     *
+     * @param defaultArtwork the default artwork to display
+     */
+    public void setDefaultArtwork(@Nullable Drawable defaultArtwork) {
+        if (this.defaultArtwork != defaultArtwork) {
+            this.defaultArtwork = defaultArtwork;
+            updateForCurrentTrackSelections(/* isNewPlayer= */ false);
+        }
+    }
 
-    @Override
-    public void onVideoSizeChanged(
-        int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
-      float videoAspectRatio =
-          (height == 0 || width == 0) ? 1 : (width * pixelWidthHeightRatio) / height;
+    /**
+     * Returns whether the playback controls can be shown.
+     */
+    public boolean getUseController() {
+        return useController;
+    }
 
-      if (surfaceView instanceof TextureView) {
-        // Try to apply rotation transformation when our surface is a TextureView.
-        if (unappliedRotationDegrees == 90 || unappliedRotationDegrees == 270) {
-          // We will apply a rotation 90/270 degree to the output texture of the TextureView.
-          // In this case, the output video's width and height will be swapped.
-          videoAspectRatio = 1 / videoAspectRatio;
+    /**
+     * Sets whether the playback controls can be shown. If set to {@code false} the playback controls
+     * are never visible and are disconnected from the player.
+     *
+     * @param useController Whether the playback controls can be shown.
+     */
+    public void setUseController(boolean useController) {
+        Assertions.checkState(!useController || controller != null);
+        if (this.useController == useController) {
+            return;
         }
-        if (textureViewRotation != 0) {
-          surfaceView.removeOnLayoutChangeListener(this);
+        this.useController = useController;
+        if (useController) {
+            controller.setPlayer(player);
+        } else if (controller != null) {
+            controller.hide();
+            controller.setPlayer(null);
         }
-        textureViewRotation = unappliedRotationDegrees;
-        if (textureViewRotation != 0) {
-          // The texture view's dimensions might be changed after layout step.
-          // So add an OnLayoutChangeListener to apply rotation after layout step.
-          surfaceView.addOnLayoutChangeListener(this);
+    }
+
+    /**
+     * Sets the background color of the {@code exo_shutter} view.
+     *
+     * @param color The background color.
+     */
+    public void setShutterBackgroundColor(int color) {
+        if (shutterView != null) {
+            shutterView.setBackgroundColor(color);
         }
-        applyTextureViewRotation((TextureView) surfaceView, textureViewRotation);
-      }
+    }
 
-      onContentAspectRatioChanged(videoAspectRatio, contentFrame, surfaceView);
+    /**
+     * Sets whether the currently displayed video frame or media artwork is kept visible when the
+     * player is reset. A player reset is defined to mean the player being re-prepared with different
+     * media, the player transitioning to unprepared media, {@link Player#stop(boolean)} being called
+     * with {@code reset=true}, or the player being replaced or cleared by calling {@link
+     * #setPlayer(Player)}.
+     *
+     * <p>If enabled, the currently displayed video frame or media artwork will be kept visible until
+     * the player set on the view has been successfully prepared with new media and loaded enough of
+     * it to have determined the available tracks. Hence enabling this option allows transitioning
+     * from playing one piece of media to another, or from using one player instance to another,
+     * without clearing the view's content.
+     *
+     * <p>If disabled, the currently displayed video frame or media artwork will be hidden as soon as
+     * the player is reset. Note that the video frame is hidden by making {@code exo_shutter} visible.
+     * Hence the video frame will not be hidden if using a custom layout that omits this view.
+     *
+     * @param keepContentOnPlayerReset Whether the currently displayed video frame or media artwork is
+     *                                 kept visible when the player is reset.
+     */
+    public void setKeepContentOnPlayerReset(boolean keepContentOnPlayerReset) {
+        if (this.keepContentOnPlayerReset != keepContentOnPlayerReset) {
+            this.keepContentOnPlayerReset = keepContentOnPlayerReset;
+            updateForCurrentTrackSelections(/* isNewPlayer= */ false);
+        }
     }
 
-    @Override
-    public void onRenderedFirstFrame() {
-      if (shutterView != null) {
-        shutterView.setVisibility(INVISIBLE);
-      }
+    /**
+     * Sets whether a buffering spinner is displayed when the player is in the buffering state. The
+     * buffering spinner is not displayed by default.
+     *
+     * @param showBuffering Whether the buffering icon is displayed
+     * @deprecated Use {@link #setShowBuffering(int)}
+     */
+    @Deprecated
+    public void setShowBuffering(boolean showBuffering) {
+        setShowBuffering(showBuffering ? SHOW_BUFFERING_WHEN_PLAYING : SHOW_BUFFERING_NEVER);
+    }
+
+    /**
+     * Sets whether a buffering spinner is displayed when the player is in the buffering state. The
+     * buffering spinner is not displayed by default.
+     *
+     * @param showBuffering The mode that defines when the buffering spinner is displayed. One of
+     *                      {@link #SHOW_BUFFERING_NEVER}, {@link #SHOW_BUFFERING_WHEN_PLAYING} and
+     *                      {@link #SHOW_BUFFERING_ALWAYS}.
+     */
+    public void setShowBuffering(@ShowBuffering int showBuffering) {
+        if (this.showBuffering != showBuffering) {
+            this.showBuffering = showBuffering;
+            updateBuffering();
+        }
     }
 
-    @Override
-    public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
-      updateForCurrentTrackSelections(/* isNewPlayer= */ false);
+    /**
+     * Sets the optional {@link ErrorMessageProvider}.
+     *
+     * @param errorMessageProvider The error message provider.
+     */
+    public void setErrorMessageProvider(
+            @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider) {
+        if (this.errorMessageProvider != errorMessageProvider) {
+            this.errorMessageProvider = errorMessageProvider;
+            updateErrorMessage();
+        }
     }
 
-    // Player.EventListener implementation
+    /**
+     * Sets a custom error message to be displayed by the view. The error message will be displayed
+     * permanently, unless it is cleared by passing {@code null} to this method.
+     *
+     * @param message The message to display, or {@code null} to clear a previously set message.
+     */
+    public void setCustomErrorMessage(@Nullable CharSequence message) {
+        Assertions.checkState(errorMessageView != null);
+        customErrorMessage = message;
+        updateErrorMessage();
+    }
 
     @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      updateBuffering();
-      updateErrorMessage();
-      if (isPlayingAd() && controllerHideDuringAds) {
-        hideController();
-      } else {
-        maybeShowController(false);
-      }
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if (player != null && player.isPlayingAd()) {
+            return super.dispatchKeyEvent(event);
+        }
+        boolean isDpadWhenControlHidden =
+                isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
+        boolean handled =
+                isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+        if (handled) {
+            maybeShowController(true);
+        }
+        return handled;
+    }
+
+    /**
+     * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
+     * events will be handled. Does nothing if playback controls are disabled.
+     *
+     * @param event A key event.
+     * @return Whether the key event was handled.
+     */
+    public boolean dispatchMediaKeyEvent(KeyEvent event) {
+        return useController && controller.dispatchMediaKeyEvent(event);
+    }
+
+    /**
+     * Returns whether the controller is currently visible.
+     */
+    public boolean isControllerVisible() {
+        return controller != null && controller.isVisible();
+    }
+
+    /**
+     * Shows the playback controls. Does nothing if playback controls are disabled.
+     *
+     * <p>The playback controls are automatically hidden during playback after {{@link
+     * #getControllerShowTimeoutMs()}}. They are shown indefinitely when playback has not started yet,
+     * is paused, has ended or failed.
+     */
+    public void showController() {
+        showController(shouldShowControllerIndefinitely());
+    }
+
+    /**
+     * Hides the playback controls. Does nothing if playback controls are disabled.
+     */
+    public void hideController() {
+        if (controller != null) {
+            controller.hide();
+        }
     }
 
-    @Override
-    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
-      if (isPlayingAd() && controllerHideDuringAds) {
-        hideController();
-      }
+    /**
+     * Returns the playback controls timeout. The playback controls are automatically hidden after
+     * this duration of time has elapsed without user input and with playback or buffering in
+     * progress.
+     *
+     * @return The timeout in milliseconds. A non-positive value will cause the controller to remain
+     * visible indefinitely.
+     */
+    public int getControllerShowTimeoutMs() {
+        return controllerShowTimeoutMs;
+    }
+
+    /**
+     * Sets the playback controls timeout. The playback controls are automatically hidden after this
+     * duration of time has elapsed without user input and with playback or buffering in progress.
+     *
+     * @param controllerShowTimeoutMs The timeout in milliseconds. A non-positive value will cause the
+     *                                controller to remain visible indefinitely.
+     */
+    public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
+        Assertions.checkState(controller != null);
+        this.controllerShowTimeoutMs = controllerShowTimeoutMs;
+        if (controller.isVisible()) {
+            // Update the controller's timeout if necessary.
+            showController();
+        }
     }
 
-    // OnLayoutChangeListener implementation
+    /**
+     * Returns whether the playback controls are hidden by touch events.
+     */
+    public boolean getControllerHideOnTouch() {
+        return controllerHideOnTouch;
+    }
+
+    /**
+     * Sets whether the playback controls are hidden by touch events.
+     *
+     * @param controllerHideOnTouch Whether the playback controls are hidden by touch events.
+     */
+    public void setControllerHideOnTouch(boolean controllerHideOnTouch) {
+        Assertions.checkState(controller != null);
+        this.controllerHideOnTouch = controllerHideOnTouch;
+    }
+
+    /**
+     * Returns whether the playback controls are automatically shown when playback starts, pauses,
+     * ends, or fails. If set to false, the playback controls can be manually operated with {@link
+     * #showController()} and {@link #hideController()}.
+     */
+    public boolean getControllerAutoShow() {
+        return controllerAutoShow;
+    }
+
+    /**
+     * Sets whether the playback controls are automatically shown when playback starts, pauses, ends,
+     * or fails. If set to false, the playback controls can be manually operated with {@link
+     * #showController()} and {@link #hideController()}.
+     *
+     * @param controllerAutoShow Whether the playback controls are allowed to show automatically.
+     */
+    public void setControllerAutoShow(boolean controllerAutoShow) {
+        this.controllerAutoShow = controllerAutoShow;
+    }
+
+    /**
+     * Sets whether the playback controls are hidden when ads are playing. Controls are always shown
+     * during ads if they are enabled and the player is paused.
+     *
+     * @param controllerHideDuringAds Whether the playback controls are hidden when ads are playing.
+     */
+    public void setControllerHideDuringAds(boolean controllerHideDuringAds) {
+        this.controllerHideDuringAds = controllerHideDuringAds;
+    }
+
+    /**
+     * Set the {@link PlayerControlView.VisibilityListener}.
+     *
+     * @param listener The listener to be notified about visibility changes.
+     */
+    public void setControllerVisibilityListener(PlayerControlView.VisibilityListener listener) {
+        Assertions.checkState(controller != null);
+        controller.setVisibilityListener(listener);
+    }
+
+    /**
+     * Set the {@link PlayerControlView.OnQualityChangeClickedListener}.
+     *
+     * @param listener The listener to be notified about quality change button clicked.
+     */
+    public void setQualityChangeClickedListener(PlayerControlView.OnQualityChangeClickedListener listener) {
+        Assertions.checkState(controller != null);
+        controller.setOnQualityChangeClickedListener(listener);
+    }
+
+    /**
+     * Set the {@link PlayerControlView.OnFullScreenButtonClickedListener}.
+     *
+     * @param listener The listener to be notified about fullscreen button clicked.
+     */
+    public void setFullscreenClickedListener(PlayerControlView.OnFullScreenButtonClickedListener listener) {
+        Assertions.checkState(controller != null);
+        controller.setOnFullScreenButtonClickedListener(listener);
+    }
+
+    /**
+     * Sets the {@link PlaybackPreparer}.
+     *
+     * @param playbackPreparer The {@link PlaybackPreparer}.
+     */
+    public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
+        Assertions.checkState(controller != null);
+        controller.setPlaybackPreparer(playbackPreparer);
+    }
+
+    /**
+     * Sets the {@link ControlDispatcher}.
+     *
+     * @param controlDispatcher The {@link ControlDispatcher}, or null to use {@link
+     *                          DefaultControlDispatcher}.
+     */
+    public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
+        Assertions.checkState(controller != null);
+        controller.setControlDispatcher(controlDispatcher);
+    }
+
+    /**
+     * Sets the rewind increment in milliseconds.
+     *
+     * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
+     *                 rewind button to be disabled.
+     */
+    public void setRewindIncrementMs(int rewindMs) {
+        Assertions.checkState(controller != null);
+        controller.setRewindIncrementMs(rewindMs);
+    }
+
+    /**
+     * Sets the fast forward increment in milliseconds.
+     *
+     * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
+     *                      cause the fast forward button to be disabled.
+     */
+    public void setFastForwardIncrementMs(int fastForwardMs) {
+        Assertions.checkState(controller != null);
+        controller.setFastForwardIncrementMs(fastForwardMs);
+    }
+
+    /**
+     * Sets which repeat toggle modes are enabled.
+     *
+     * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
+     */
+    public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
+        Assertions.checkState(controller != null);
+        controller.setRepeatToggleModes(repeatToggleModes);
+    }
+
+    /**
+     * Sets whether the shuffle button is shown.
+     *
+     * @param showShuffleButton Whether the shuffle button is shown.
+     */
+    public void setShowShuffleButton(boolean showShuffleButton) {
+        Assertions.checkState(controller != null);
+        controller.setShowShuffleButton(showShuffleButton);
+    }
+
+    /**
+     * Sets whether the time bar should show all windows, as opposed to just the current one.
+     *
+     * @param showMultiWindowTimeBar Whether to show all windows.
+     */
+    public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
+        Assertions.checkState(controller != null);
+        controller.setShowMultiWindowTimeBar(showMultiWindowTimeBar);
+    }
+
+    /**
+     * Sets the millisecond positions of extra ad markers relative to the start of the window (or
+     * timeline, if in multi-window mode) and whether each extra ad has been played or not. The
+     * markers are shown in addition to any ad markers for ads in the player's timeline.
+     *
+     * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
+     *                            {@code null} to show no extra ad markers.
+     * @param extraPlayedAdGroups Whether each ad has been played, or {@code null} to show no extra ad
+     *                            markers.
+     */
+    public void setExtraAdGroupMarkers(
+            @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {
+        Assertions.checkState(controller != null);
+        controller.setExtraAdGroupMarkers(extraAdGroupTimesMs, extraPlayedAdGroups);
+    }
+
+    /**
+     * Set the {@link AspectRatioFrameLayout.AspectRatioListener}.
+     *
+     * @param listener The listener to be notified about aspect ratios changes of the video content or
+     *                 the content frame.
+     */
+    public void setAspectRatioListener(AspectRatioFrameLayout.AspectRatioListener listener) {
+        Assertions.checkState(contentFrame != null);
+        contentFrame.setAspectRatioListener(listener);
+    }
+
+    /**
+     * Gets the view onto which video is rendered. This is a:
+     *
+     * <ul>
+     * <li>{@link SurfaceView} by default, or if the {@code surface_type} attribute is set to {@code
+     * surface_view}.
+     * <li>{@link TextureView} if {@code surface_type} is {@code texture_view}.
+     * <li>{@link SphericalSurfaceView} if {@code surface_type} is {@code spherical_view}.
+     * <li>{@code null} if {@code surface_type} is {@code none}.
+     * </ul>
+     *
+     * @return The {@link SurfaceView}, {@link TextureView}, {@link SphericalSurfaceView} or {@code
+     * null}.
+     */
+    public View getVideoSurfaceView() {
+        return surfaceView;
+    }
+
+    /**
+     * Gets the overlay {@link FrameLayout}, which can be populated with UI elements to show on top of
+     * the player.
+     *
+     * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
+     * the overlay is not present.
+     */
+    @Nullable
+    public FrameLayout getOverlayFrameLayout() {
+        return overlayFrameLayout;
+    }
+
+    /**
+     * Gets the {@link SubtitleView}.
+     *
+     * @return The {@link SubtitleView}, or {@code null} if the layout has been customized and the
+     * subtitle view is not present.
+     */
+    public SubtitleView getSubtitleView() {
+        return subtitleView;
+    }
 
     @Override
-    public void onLayoutChange(
-        View view,
-        int left,
-        int top,
-        int right,
-        int bottom,
-        int oldLeft,
-        int oldTop,
-        int oldRight,
-        int oldBottom) {
-      applyTextureViewRotation((TextureView) view, textureViewRotation);
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+            return false;
+        }
+        return performClick();
     }
 
-    // SphericalSurfaceView.SurfaceTextureListener implementation
+    @Override
+    public boolean performClick() {
+        super.performClick();
+        return toggleControllerVisibility();
+    }
 
     @Override
-    public void surfaceChanged(@Nullable Surface surface) {
-      if (player != null) {
-        VideoComponent videoComponent = player.getVideoComponent();
-        if (videoComponent != null) {
-          videoComponent.setVideoSurface(surface);
+    public boolean onTrackballEvent(MotionEvent ev) {
+        if (!useController || player == null) {
+            return false;
         }
-      }
+        maybeShowController(true);
+        return true;
     }
 
-    // SingleTapListener implementation
+    /**
+     * Should be called when the player is visible to the user and if {@code surface_type} is {@code
+     * spherical_view}. It is the counterpart to {@link #onPause()}.
+     *
+     * <p>This method should typically be called in {@link Activity#onStart()}, or {@link
+     * Activity#onResume()} for API versions &lt;= 23.
+     */
+    public void onResume() {
+        if (surfaceView instanceof SphericalSurfaceView) {
+            ((SphericalSurfaceView) surfaceView).onResume();
+        }
+    }
+
+    /**
+     * Should be called when the player is no longer visible to the user and if {@code surface_type}
+     * is {@code spherical_view}. It is the counterpart to {@link #onResume()}.
+     *
+     * <p>This method should typically be called in {@link Activity#onStop()}, or {@link
+     * Activity#onPause()} for API versions &lt;= 23.
+     */
+    public void onPause() {
+        if (surfaceView instanceof SphericalSurfaceView) {
+            ((SphericalSurfaceView) surfaceView).onPause();
+        }
+    }
+
+    /**
+     * Called when there's a change in the aspect ratio of the content being displayed. The default
+     * implementation sets the aspect ratio of the content frame to that of the content, unless the
+     * content view is a {@link SphericalSurfaceView} in which case the frame's aspect ratio is
+     * cleared.
+     *
+     * @param contentAspectRatio The aspect ratio of the content.
+     * @param contentFrame       The content frame, or {@code null}.
+     * @param contentView        The view that holds the content being displayed, or {@code null}.
+     */
+    protected void onContentAspectRatioChanged(
+            float contentAspectRatio,
+            @Nullable AspectRatioFrameLayout contentFrame,
+            @Nullable View contentView) {
+        if (contentFrame != null) {
+            contentFrame.setAspectRatio(
+                    contentView instanceof SphericalSurfaceView ? 0 : contentAspectRatio);
+        }
+    }
+
+    // AdsLoader.AdViewProvider implementation.
+
+    @Override
+    public ViewGroup getAdViewGroup() {
+        return Assertions.checkNotNull(
+                adOverlayFrameLayout, "exo_ad_overlay must be present for ad playback");
+    }
 
     @Override
-    public boolean onSingleTapUp(MotionEvent e) {
-      return toggleControllerVisibility();
+    public View[] getAdOverlayViews() {
+        ArrayList<View> overlayViews = new ArrayList<>();
+        if (overlayFrameLayout != null) {
+            overlayViews.add(overlayFrameLayout);
+        }
+        if (controller != null) {
+            overlayViews.add(controller);
+        }
+        return overlayViews.toArray(new View[0]);
+    }
+
+    // Internal methods.
+
+    private boolean toggleControllerVisibility() {
+        if (!useController || player == null) {
+            return false;
+        }
+        if (!controller.isVisible()) {
+            maybeShowController(true);
+        } else if (controllerHideOnTouch) {
+            controller.hide();
+        }
+        return true;
+    }
+
+    /**
+     * Shows the playback controls, but only if forced or shown indefinitely.
+     */
+    private void maybeShowController(boolean isForced) {
+        if (isPlayingAd() && controllerHideDuringAds) {
+            return;
+        }
+        if (useController) {
+            boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;
+            boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();
+            if (isForced || wasShowingIndefinitely || shouldShowIndefinitely) {
+                showController(shouldShowIndefinitely);
+            }
+        }
+    }
+
+    private boolean shouldShowControllerIndefinitely() {
+        if (player == null) {
+            return true;
+        }
+        int playbackState = player.getPlaybackState();
+        return controllerAutoShow
+                && (playbackState == Player.STATE_IDLE
+                || playbackState == Player.STATE_ENDED
+                || !player.getPlayWhenReady());
+    }
+
+    private void showController(boolean showIndefinitely) {
+        if (!useController) {
+            return;
+        }
+        controller.setShowTimeoutMs(showIndefinitely ? 0 : controllerShowTimeoutMs);
+        controller.show();
+    }
+
+    private boolean isPlayingAd() {
+        return player != null && player.isPlayingAd() && player.getPlayWhenReady();
+    }
+
+    private void updateForCurrentTrackSelections(boolean isNewPlayer) {
+        if (player == null || player.getCurrentTrackGroups().isEmpty()) {
+            if (!keepContentOnPlayerReset) {
+                hideArtwork();
+                closeShutter();
+            }
+            return;
+        }
+
+        if (isNewPlayer && !keepContentOnPlayerReset) {
+            // Hide any video from the previous player.
+            closeShutter();
+        }
+
+        TrackSelectionArray selections = player.getCurrentTrackSelections();
+        for (int i = 0; i < selections.length; i++) {
+            if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
+                // Video enabled so artwork must be hidden. If the shutter is closed, it will be opened in
+                // onRenderedFirstFrame().
+                hideArtwork();
+                return;
+            }
+        }
+
+        // Video disabled so the shutter must be closed.
+        closeShutter();
+        // Display artwork if enabled and available, else hide it.
+        if (useArtwork) {
+            for (int i = 0; i < selections.length; i++) {
+                TrackSelection selection = selections.get(i);
+                if (selection != null) {
+                    for (int j = 0; j < selection.length(); j++) {
+                        Metadata metadata = selection.getFormat(j).metadata;
+                        if (metadata != null && setArtworkFromMetadata(metadata)) {
+                            return;
+                        }
+                    }
+                }
+            }
+            if (setDrawableArtwork(defaultArtwork)) {
+                return;
+            }
+        }
+        // Artwork disabled or unavailable.
+        hideArtwork();
+    }
+
+    private boolean setArtworkFromMetadata(Metadata metadata) {
+        for (int i = 0; i < metadata.length(); i++) {
+            Metadata.Entry metadataEntry = metadata.get(i);
+            if (metadataEntry instanceof ApicFrame) {
+                byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
+                Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
+                return setDrawableArtwork(new BitmapDrawable(getResources(), bitmap));
+            }
+        }
+        return false;
+    }
+
+    private boolean setDrawableArtwork(@Nullable Drawable drawable) {
+        if (drawable != null) {
+            int drawableWidth = drawable.getIntrinsicWidth();
+            int drawableHeight = drawable.getIntrinsicHeight();
+            if (drawableWidth > 0 && drawableHeight > 0) {
+                float artworkAspectRatio = (float) drawableWidth / drawableHeight;
+                onContentAspectRatioChanged(artworkAspectRatio, contentFrame, artworkView);
+                artworkView.setImageDrawable(drawable);
+                artworkView.setVisibility(VISIBLE);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void hideArtwork() {
+        if (artworkView != null) {
+            artworkView.setImageResource(android.R.color.transparent); // Clears any bitmap reference.
+            artworkView.setVisibility(INVISIBLE);
+        }
+    }
+
+    private void closeShutter() {
+        if (shutterView != null) {
+            shutterView.setVisibility(View.VISIBLE);
+        }
+    }
+
+    private void updateBuffering() {
+        if (bufferingView != null) {
+            boolean showBufferingSpinner =
+                    player != null
+                            && player.getPlaybackState() == Player.STATE_BUFFERING
+                            && (showBuffering == SHOW_BUFFERING_ALWAYS
+                            || (showBuffering == SHOW_BUFFERING_WHEN_PLAYING && player.getPlayWhenReady()));
+            bufferingView.setVisibility(showBufferingSpinner ? View.VISIBLE : View.GONE);
+        }
+    }
+
+    private void updateErrorMessage() {
+        if (errorMessageView != null) {
+            if (customErrorMessage != null) {
+                errorMessageView.setText(customErrorMessage);
+                errorMessageView.setVisibility(View.VISIBLE);
+                return;
+            }
+            ExoPlaybackException error = null;
+            if (player != null
+                    && player.getPlaybackState() == Player.STATE_IDLE
+                    && errorMessageProvider != null) {
+                error = player.getPlaybackError();
+            }
+            if (error != null) {
+                CharSequence errorMessage = errorMessageProvider.getErrorMessage(error).second;
+                errorMessageView.setText(errorMessage);
+                errorMessageView.setVisibility(View.VISIBLE);
+            } else {
+                errorMessageView.setVisibility(View.GONE);
+            }
+        }
+    }
+
+    @TargetApi(23)
+    private static void configureEditModeLogoV23(Resources resources, ImageView logo) {
+        logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo, null));
+        logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color, null));
+    }
+
+    @SuppressWarnings("deprecation")
+    private static void configureEditModeLogo(Resources resources, ImageView logo) {
+        logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo));
+        logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color));
+    }
+
+    @SuppressWarnings("ResourceType")
+    private static void setResizeModeRaw(AspectRatioFrameLayout aspectRatioFrame, int resizeMode) {
+        aspectRatioFrame.setResizeMode(resizeMode);
+    }
+
+    /**
+     * Applies a texture rotation to a {@link TextureView}.
+     */
+    private static void applyTextureViewRotation(TextureView textureView, int textureViewRotation) {
+        float textureViewWidth = textureView.getWidth();
+        float textureViewHeight = textureView.getHeight();
+        if (textureViewWidth == 0 || textureViewHeight == 0 || textureViewRotation == 0) {
+            textureView.setTransform(null);
+        } else {
+            Matrix transformMatrix = new Matrix();
+            float pivotX = textureViewWidth / 2;
+            float pivotY = textureViewHeight / 2;
+            transformMatrix.postRotate(textureViewRotation, pivotX, pivotY);
+
+            // After rotation, scale the rotated texture to fit the TextureView size.
+            RectF originalTextureRect = new RectF(0, 0, textureViewWidth, textureViewHeight);
+            RectF rotatedTextureRect = new RectF();
+            transformMatrix.mapRect(rotatedTextureRect, originalTextureRect);
+            transformMatrix.postScale(
+                    textureViewWidth / rotatedTextureRect.width(),
+                    textureViewHeight / rotatedTextureRect.height(),
+                    pivotX,
+                    pivotY);
+            textureView.setTransform(transformMatrix);
+        }
+    }
+
+    @SuppressLint("InlinedApi")
+    private boolean isDpadKey(int keyCode) {
+        return keyCode == KeyEvent.KEYCODE_DPAD_UP
+                || keyCode == KeyEvent.KEYCODE_DPAD_UP_RIGHT
+                || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT
+                || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_RIGHT
+                || keyCode == KeyEvent.KEYCODE_DPAD_DOWN
+                || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_LEFT
+                || keyCode == KeyEvent.KEYCODE_DPAD_LEFT
+                || keyCode == KeyEvent.KEYCODE_DPAD_UP_LEFT
+                || keyCode == KeyEvent.KEYCODE_DPAD_CENTER;
+    }
+
+    private final class ComponentListener
+            implements Player.EventListener,
+            TextOutput,
+            VideoListener,
+            OnLayoutChangeListener,
+            SphericalSurfaceView.SurfaceListener,
+            SingleTapListener {
+
+        // TextOutput implementation
+
+        @Override
+        public void onCues(List<Cue> cues) {
+            if (subtitleView != null) {
+                subtitleView.onCues(cues);
+            }
+        }
+
+        // VideoListener implementation
+
+        @Override
+        public void onVideoSizeChanged(
+                int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
+            float videoAspectRatio =
+                    (height == 0 || width == 0) ? 1 : (width * pixelWidthHeightRatio) / height;
+
+            if (surfaceView instanceof TextureView) {
+                // Try to apply rotation transformation when our surface is a TextureView.
+                if (unappliedRotationDegrees == 90 || unappliedRotationDegrees == 270) {
+                    // We will apply a rotation 90/270 degree to the output texture of the TextureView.
+                    // In this case, the output video's width and height will be swapped.
+                    videoAspectRatio = 1 / videoAspectRatio;
+                }
+                if (textureViewRotation != 0) {
+                    surfaceView.removeOnLayoutChangeListener(this);
+                }
+                textureViewRotation = unappliedRotationDegrees;
+                if (textureViewRotation != 0) {
+                    // The texture view's dimensions might be changed after layout step.
+                    // So add an OnLayoutChangeListener to apply rotation after layout step.
+                    surfaceView.addOnLayoutChangeListener(this);
+                }
+                applyTextureViewRotation((TextureView) surfaceView, textureViewRotation);
+            }
+
+            onContentAspectRatioChanged(videoAspectRatio, contentFrame, surfaceView);
+        }
+
+        @Override
+        public void onRenderedFirstFrame() {
+            if (shutterView != null) {
+                shutterView.setVisibility(INVISIBLE);
+            }
+        }
+
+        @Override
+        public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
+            updateForCurrentTrackSelections(/* isNewPlayer= */ false);
+        }
+
+        // Player.EventListener implementation
+
+        @Override
+        public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+            updateBuffering();
+            updateErrorMessage();
+            if (isPlayingAd() && controllerHideDuringAds) {
+                hideController();
+            } else {
+                maybeShowController(false);
+            }
+        }
+
+        @Override
+        public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+            if (isPlayingAd() && controllerHideDuringAds) {
+                hideController();
+            }
+        }
+
+        // OnLayoutChangeListener implementation
+
+        @Override
+        public void onLayoutChange(
+                View view,
+                int left,
+                int top,
+                int right,
+                int bottom,
+                int oldLeft,
+                int oldTop,
+                int oldRight,
+                int oldBottom) {
+            applyTextureViewRotation((TextureView) view, textureViewRotation);
+        }
+
+        // SphericalSurfaceView.SurfaceTextureListener implementation
+
+        @Override
+        public void surfaceChanged(@Nullable Surface surface) {
+            if (player != null) {
+                VideoComponent videoComponent = player.getVideoComponent();
+                if (videoComponent != null) {
+                    videoComponent.setVideoSurface(surface);
+                }
+            }
+        }
+
+        // SingleTapListener implementation
+
+        @Override
+        public boolean onSingleTapUp(MotionEvent e) {
+            return toggleControllerVisibility();
+        }
     }
-  }
 }
diff --git a/library/ui/src/main/res/layout-v21/exo_playback_control_view.xml b/library/ui/src/main/res/layout-v21/exo_playback_control_view.xml
new file mode 100644
index 0000000000..8369ab6191
--- /dev/null
+++ b/library/ui/src/main/res/layout-v21/exo_playback_control_view.xml
@@ -0,0 +1,153 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  android:layout_width="match_parent"
+  android:layout_height="wrap_content"
+  android:layout_gravity="bottom"
+  android:background="#CC000000"
+  android:layoutDirection="ltr"
+  android:orientation="vertical"
+  tools:targetApi="28">
+
+  <!--<LinearLayout-->
+  <!--android:layout_width="match_parent"-->
+  <!--android:layout_height="wrap_content"-->
+  <!--android:paddingTop="4dp"-->
+  <!--android:gravity="center"-->
+  <!--android:orientation="horizontal">-->
+
+
+  <com.google.android.exoplayer2.ui.DefaultRoundedTimeBar
+    android:id="@id/exo_progress"
+    android:layout_width="match_parent"
+    android:layout_height="26dp"
+    android:layout_weight="1"/>
+
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_prev"-->
+  <!--style="@style/ExoMediaButton.Previous"/>-->
+
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_rew"-->
+  <!--style="@style/ExoMediaButton.Rewind"/>-->
+
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_shuffle"-->
+  <!--style="@style/ExoMediaButton.Shuffle"/>-->
+
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_repeat_toggle"-->
+  <!--style="@style/ExoMediaButton"/>-->
+
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_ffwd"-->
+  <!--style="@style/ExoMediaButton.FastForward"/>-->
+
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_next"-->
+  <!--style="@style/ExoMediaButton.Next"/>-->
+
+  <!--</LinearLayout>-->
+
+  <RelativeLayout
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:layout_marginTop="4dp"
+    android:gravity="center_vertical"
+    android:orientation="horizontal">
+
+    <FrameLayout
+      android:id="@+id/frame_play_pause"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_alignParentLeft="true"
+      android:layout_alignParentStart="true"
+      android:layout_centerVertical="true">
+      <ImageButton
+        android:id="@id/exo_play"
+        style="@style/ExoMediaButton.Play"
+        android:layout_width="wrap_content"
+        android:layout_height="match_parent"/>
+
+      <ImageButton
+        android:id="@id/exo_pause"
+        style="@style/ExoMediaButton.Pause"
+        android:layout_width="wrap_content"
+        android:layout_height="match_parent"/>
+    </FrameLayout>
+
+    <TextView
+      android:id="@id/exo_position"
+      android:textStyle="bold"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toEndOf="@id/frame_play_pause"
+      android:layout_toRightOf="@id/frame_play_pause"
+      android:paddingLeft="4dp"
+      android:paddingRight="4dp"
+      android:includeFontPadding="false"
+      android:textColor="#FFBEBEBE"
+      android:textSize="14sp"
+      tools:text="0:30"/>
+
+    <TextView
+      android:id="@+id/separator"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toEndOf="@id/exo_position"
+      android:layout_toRightOf="@id/exo_position"
+      android:text="/"
+      android:textColor="@android:color/white"/>
+
+    <TextView
+      android:id="@id/exo_duration"
+      android:textStyle="bold"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toEndOf="@+id/separator"
+      android:layout_toRightOf="@+id/separator"
+      android:paddingLeft="4dp"
+      android:paddingRight="4dp"
+      android:includeFontPadding="false"
+      android:textColor="#FFBEBEBE"
+      android:textSize="14sp"
+      tools:text="1:00"/>
+
+    <ImageView
+      android:id="@+id/exo_quality_change"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toLeftOf="@id/exo_fullscreen_btn"
+      android:layout_toStartOf="@id/exo_fullscreen_btn"
+      android:src="@drawable/ic_exo_quality_change"/>
+
+    <ImageView
+      android:id="@+id/exo_fullscreen_btn"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_alignParentEnd="true"
+      android:layout_alignParentRight="true"
+      android:layout_centerVertical="true"
+      android:src="@drawable/ic_exo_fullscreen"/>
+
+  </RelativeLayout>
+
+</LinearLayout>
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index c5988987bb..f4b0c28226 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -23,59 +23,81 @@
   android:orientation="vertical"
   tools:targetApi="28">
 
-  <LinearLayout
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:paddingTop="4dp"
-    android:gravity="center"
-    android:orientation="horizontal">
+  <!--<LinearLayout-->
+  <!--android:layout_width="match_parent"-->
+  <!--android:layout_height="wrap_content"-->
+  <!--android:paddingTop="4dp"-->
+  <!--android:gravity="center"-->
+  <!--android:orientation="horizontal">-->
 
-    <ImageButton
-      android:id="@id/exo_prev"
-      style="@style/ExoMediaButton.Previous"/>
 
-    <ImageButton
-      android:id="@id/exo_rew"
-      style="@style/ExoMediaButton.Rewind"/>
+  <com.google.android.exoplayer2.ui.DefaultTimeBar
+    android:id="@id/exo_progress"
+    android:layout_width="match_parent"
+    android:layout_height="26dp"
+    android:layout_weight="1"/>
 
-    <ImageButton
-      android:id="@id/exo_shuffle"
-      style="@style/ExoMediaButton.Shuffle"/>
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_prev"-->
+  <!--style="@style/ExoMediaButton.Previous"/>-->
 
-    <ImageButton
-      android:id="@id/exo_repeat_toggle"
-      style="@style/ExoMediaButton"/>
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_rew"-->
+  <!--style="@style/ExoMediaButton.Rewind"/>-->
 
-    <ImageButton
-      android:id="@id/exo_play"
-      style="@style/ExoMediaButton.Play"/>
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_shuffle"-->
+  <!--style="@style/ExoMediaButton.Shuffle"/>-->
 
-    <ImageButton
-      android:id="@id/exo_pause"
-      style="@style/ExoMediaButton.Pause"/>
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_repeat_toggle"-->
+  <!--style="@style/ExoMediaButton"/>-->
 
-    <ImageButton
-      android:id="@id/exo_ffwd"
-      style="@style/ExoMediaButton.FastForward"/>
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_ffwd"-->
+  <!--style="@style/ExoMediaButton.FastForward"/>-->
 
-    <ImageButton
-      android:id="@id/exo_next"
-      style="@style/ExoMediaButton.Next"/>
+  <!--<ImageButton-->
+  <!--android:id="@id/exo_next"-->
+  <!--style="@style/ExoMediaButton.Next"/>-->
 
-  </LinearLayout>
+  <!--</LinearLayout>-->
 
-  <LinearLayout
+  <RelativeLayout
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_marginTop="4dp"
     android:gravity="center_vertical"
     android:orientation="horizontal">
 
+    <FrameLayout
+      android:id="@+id/frame_play_pause"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_alignParentLeft="true"
+      android:layout_alignParentStart="true"
+      android:layout_centerVertical="true">
+      <ImageButton
+        android:id="@id/exo_play"
+        style="@style/ExoMediaButton.Play"
+        android:layout_width="wrap_content"
+        android:layout_height="match_parent"/>
+
+      <ImageButton
+        android:id="@id/exo_pause"
+        style="@style/ExoMediaButton.Pause"
+        android:layout_width="wrap_content"
+        android:layout_height="match_parent"/>
+    </FrameLayout>
+
     <TextView
       android:id="@id/exo_position"
       android:textStyle="bold"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toEndOf="@id/frame_play_pause"
+      android:layout_toRightOf="@id/frame_play_pause"
       android:paddingLeft="4dp"
       android:paddingRight="4dp"
       android:includeFontPadding="false"
@@ -83,17 +105,24 @@
       android:textSize="14sp"
       tools:text="0:30"/>
 
-    <com.google.android.exoplayer2.ui.DefaultTimeBar
-      android:id="@id/exo_progress"
-      android:layout_width="0dp"
-      android:layout_height="26dp"
-      android:layout_weight="1"/>
+    <TextView
+      android:id="@+id/separator"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toEndOf="@id/exo_position"
+      android:layout_toRightOf="@id/exo_position"
+      android:text="/"
+      android:textColor="@android:color/white"/>
 
     <TextView
       android:id="@id/exo_duration"
       android:textStyle="bold"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toEndOf="@+id/separator"
+      android:layout_toRightOf="@+id/separator"
       android:paddingLeft="4dp"
       android:paddingRight="4dp"
       android:includeFontPadding="false"
@@ -105,14 +134,20 @@
       android:id="@+id/exo_quality_change"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:layout_centerVertical="true"
+      android:layout_toLeftOf="@id/exo_fullscreen_btn"
+      android:layout_toStartOf="@id/exo_fullscreen_btn"
       android:src="@drawable/ic_exo_quality_change"/>
 
     <ImageView
       android:id="@+id/exo_fullscreen_btn"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:layout_alignParentEnd="true"
+      android:layout_alignParentRight="true"
+      android:layout_centerVertical="true"
       android:src="@drawable/ic_exo_fullscreen"/>
 
-  </LinearLayout>
+  </RelativeLayout>
 
 </LinearLayout>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index c13622f182..9df54c7c14 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -16,7 +16,7 @@
 <resources>
 
   <!-- Must be kept in sync with AspectRatioFrameLayout -->
-  <attr name="resize_mode" format="enum">
+  <attr format="enum" name="resize_mode">
     <enum name="fit" value="0"/>
     <enum name="fixed_width" value="1"/>
     <enum name="fixed_height" value="2"/>
@@ -25,38 +25,38 @@
   </attr>
 
   <!-- Must be kept in sync with SimpleExoPlayerView -->
-  <attr name="surface_type" format="enum">
+  <attr format="enum" name="surface_type">
     <enum name="none" value="0"/>
     <enum name="surface_view" value="1"/>
     <enum name="texture_view" value="2"/>
     <enum name="spherical_view" value="3"/>
   </attr>
-  <attr name="show_timeout" format="integer"/>
-  <attr name="rewind_increment" format="integer"/>
-  <attr name="fastforward_increment" format="integer"/>
-  <attr name="player_layout_id" format="reference"/>
-  <attr name="controller_layout_id" format="reference"/>
+  <attr format="integer" name="show_timeout"/>
+  <attr format="integer" name="rewind_increment"/>
+  <attr format="integer" name="fastforward_increment"/>
+  <attr format="reference" name="player_layout_id"/>
+  <attr format="reference" name="controller_layout_id"/>
   <attr name="repeat_toggle_modes">
     <flag name="none" value="0"/>
     <flag name="one" value="1"/>
     <flag name="all" value="2"/>
   </attr>
-  <attr name="show_shuffle_button" format="boolean"/>
+  <attr format="boolean" name="show_shuffle_button"/>
 
   <declare-styleable name="PlayerView">
-    <attr name="use_artwork" format="boolean"/>
-    <attr name="shutter_background_color" format="color"/>
-    <attr name="default_artwork" format="reference"/>
-    <attr name="use_controller" format="boolean"/>
-    <attr name="hide_on_touch" format="boolean"/>
-    <attr name="hide_during_ads" format="boolean"/>
-    <attr name="auto_show" format="boolean"/>
-    <attr name="show_buffering" format="enum">
+    <attr format="boolean" name="use_artwork"/>
+    <attr format="color" name="shutter_background_color"/>
+    <attr format="reference" name="default_artwork"/>
+    <attr format="boolean" name="use_controller"/>
+    <attr format="boolean" name="hide_on_touch"/>
+    <attr format="boolean" name="hide_during_ads"/>
+    <attr format="boolean" name="auto_show"/>
+    <attr format="enum" name="show_buffering">
       <enum name="never" value="0"/>
       <enum name="when_playing" value="1"/>
       <enum name="always" value="2"/>
     </attr>
-    <attr name="keep_content_on_player_reset" format="boolean"/>
+    <attr format="boolean" name="keep_content_on_player_reset"/>
     <attr name="resize_mode"/>
     <attr name="surface_type"/>
     <attr name="player_layout_id"/>
@@ -83,19 +83,23 @@
   </declare-styleable>
 
   <declare-styleable name="DefaultTimeBar">
-    <attr name="bar_height" format="dimension"/>
-    <attr name="touch_target_height" format="dimension"/>
-    <attr name="ad_marker_width" format="dimension"/>
-    <attr name="scrubber_enabled_size" format="dimension"/>
-    <attr name="scrubber_disabled_size" format="dimension"/>
-    <attr name="scrubber_dragged_size" format="dimension"/>
-    <attr name="scrubber_drawable" format="reference"/>
-    <attr name="played_color" format="color"/>
-    <attr name="scrubber_color" format="color"/>
-    <attr name="buffered_color" format="color"/>
-    <attr name="unplayed_color" format="color"/>
-    <attr name="ad_marker_color" format="color"/>
-    <attr name="played_ad_marker_color" format="color"/>
+    <attr format="dimension" name="bar_height"/>
+    <attr format="dimension" name="touch_target_height"/>
+    <attr format="dimension" name="ad_marker_width"/>
+    <attr format="dimension" name="scrubber_enabled_size"/>
+    <attr format="dimension" name="scrubber_disabled_size"/>
+    <attr format="dimension" name="scrubber_dragged_size"/>
+    <attr format="reference" name="scrubber_drawable"/>
+    <attr format="color" name="played_color"/>
+    <attr format="color" name="scrubber_color"/>
+    <attr format="color" name="buffered_color"/>
+    <attr format="color" name="unplayed_color"/>
+    <attr format="color" name="ad_marker_color"/>
+    <attr format="color" name="played_ad_marker_color"/>
+  </declare-styleable>
+
+  <declare-styleable name="DefaultRoundedTimeBar">
+    <attr format="dimension" name="corners_radius"/>
   </declare-styleable>
 
 </resources>
