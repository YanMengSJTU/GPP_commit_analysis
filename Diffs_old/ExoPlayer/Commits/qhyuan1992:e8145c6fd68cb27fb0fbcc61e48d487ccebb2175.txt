diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 2858a987a0..88ab0f1c59 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,11 @@
 # Release notes #
 
+### r1.5.16 ###
+
+* VP9 extension: Reduced binary size.
+* FLAC extension: Enabled 64 bit targets and fixed proguard config.
+* Misc bugfixes.
+
 ### r1.5.15 ###
 
 * SmoothStreaming: Fixed handling of start_time placeholder
diff --git a/demo/build.gradle b/demo/build.gradle
index b7af1c7f4f..a28ef34084 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index edb24a2f9f..120dc6476b 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1515"
-    android:versionName="1.5.15"
+    android:versionCode="1516"
+    android:versionName="1.5.16"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo_ext/build.gradle b/demo_ext/build.gradle
index b3858ff596..60db3cd160 100644
--- a/demo_ext/build.gradle
+++ b/demo_ext/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/demo_ext/src/main/AndroidManifest.xml b/demo_ext/src/main/AndroidManifest.xml
index 5a29175120..ce0d46a855 100644
--- a/demo_ext/src/main/AndroidManifest.xml
+++ b/demo_ext/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.ext"
-    android:versionCode="1515"
-    android:versionName="1.5.15"
+    android:versionCode="1516"
+    android:versionName="1.5.16"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index 56a78787b8..a5c39f99fb 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/src/main/proguard.cfg
index d951cd9496..65aff006f1 100644
--- a/extensions/flac/src/main/proguard.cfg
+++ b/extensions/flac/src/main/proguard.cfg
@@ -9,3 +9,6 @@
 -keep class com.google.android.exoplayer.ext.flac.FlacJni {
     *;
 }
+-keep class com.google.android.exoplayer.util.FlacStreamInfo {
+    *;
+}
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 57539fa9c9..986f0fdf42 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index edd0194332..455899db4e 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 0d14be7886..97b6dc9255 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -49,7 +49,7 @@ git clone https://chromium.googlesource.com/libyuv/libyuv libyuv
 cd "${VP9_EXT_PATH}/jni/libvpx" && \
 git checkout tags/v1.6.1 -b v1.6.1 && \
 cd "${VP9_EXT_PATH}/jni/libyuv" && \
-git checkout e2611a73
+git checkout 996a2bbd
 ```
 
 * Run a script that generates necessary configuration files for libvpx:
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index edd0194332..455899db4e 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index be4359c3fe..fe3a32dd3f 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -34,7 +34,7 @@
 /**
  * Decodes and renders video using the native VP9 decoder.
  */
-public final class LibvpxVideoTrackRenderer extends SampleSourceTrackRenderer {
+public class LibvpxVideoTrackRenderer extends SampleSourceTrackRenderer {
 
   /**
    * Interface definition for a callback to be notified of {@link LibvpxVideoTrackRenderer} events.
@@ -273,9 +273,9 @@ private boolean processOutputBuffer(long positionUs)
       return false;
     }
 
-    // Drop frame only if we have the next frame and that's also late, otherwise render whatever we
-    // have.
-    if (nextOutputBuffer != null && nextOutputBuffer.timestampUs < positionUs) {
+    final long nextOutputBufferTimestampUs = nextOutputBuffer != null
+        ? nextOutputBuffer.timestampUs : UNKNOWN_TIME_US;
+    if (shouldDropOutputBuffer(outputBuffer.timestampUs, nextOutputBufferTimestampUs, positionUs)) {
       // Drop frame if we are too late.
       codecCounters.droppedOutputBufferCount++;
       droppedFrameCount++;
@@ -302,6 +302,22 @@ private boolean processOutputBuffer(long positionUs)
     return false;
   }
 
+  /**
+   * Returns whether the current frame should be dropped.
+   *
+   * @param outputBufferTimestampUs The timestamp of the current output buffer.
+   * @param nextOutputBufferTimestampUs The timestamp of the next output buffer or
+   *     {@link UNKNOWN_TIME_US} if the next output buffer is unavailable.
+   * @param positionUs The current playback position.
+   * @return Whether to drop the current output buffer.
+   */
+  protected boolean shouldDropOutputBuffer(
+      long outputBufferTimestampUs, long nextOutputBufferTimestampUs, long positionUs) {
+    // Drop frame only if we have the next frame and that's also late.
+    return nextOutputBufferTimestampUs != UNKNOWN_TIME_US
+        && nextOutputBufferTimestampUs < positionUs;
+  }
+
   private void renderBuffer() {
     codecCounters.renderedOutputBufferCount++;
     notifyIfVideoSizeChanged(outputBuffer.width, outputBuffer.height);
diff --git a/extensions/vp9/src/main/jni/Android.mk b/extensions/vp9/src/main/jni/Android.mk
index f2d8a99a90..bb1824f538 100644
--- a/extensions/vp9/src/main/jni/Android.mk
+++ b/extensions/vp9/src/main/jni/Android.mk
@@ -21,6 +21,7 @@ LIBYUV_ROOT := $(WORKING_DIR)/libyuv
 
 # build libyuv_static.a
 LOCAL_PATH := $(WORKING_DIR)
+LIBYUV_DISABLE_JPEG := "yes"
 include $(LIBYUV_ROOT)/Android.mk
 
 # build libvpx.so
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
index 6c5feaa67a..3bad609a78 100755
--- a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -68,7 +68,7 @@ limit=$((${#arch[@]} - 1))
 # everything else will be removed.
 allowed_files="libvpx_srcs.txt vpx_config.c vpx_config.h vpx_scale_rtcd.h"
 allowed_files+=" vp8_rtcd.h vp9_rtcd.h vpx_version.h vpx_config.asm"
-allowed_files+=" vpx_dsp_rtcd.h"
+allowed_files+=" vpx_dsp_rtcd.h libvpx.ver"
 
 remove_trailing_whitespace() {
   perl -pi -e 's/\s\+$//' "$@"
diff --git a/extensions/vp9/src/main/jni/libvpx.mk b/extensions/vp9/src/main/jni/libvpx.mk
index 90f76a6168..2fce4f26f3 100644
--- a/extensions/vp9/src/main/jni/libvpx.mk
+++ b/extensions/vp9/src/main/jni/libvpx.mk
@@ -37,9 +37,7 @@ LOCAL_SRC_FILES += $(addprefix libvpx/, $(filter-out vpx_config.c, \
 # include assembly files if they exist
 # "%.asm.[sS]" covers neon assembly and "%.asm" covers x86 assembly
 LOCAL_SRC_FILES += $(addprefix libvpx/, \
-                     $(filter %.asm.s %.asm, $(libvpx_codec_srcs)))
-LOCAL_SRC_FILES += $(addprefix libvpx/, \
-                     $(filter %.asm.S %.asm, $(libvpx_codec_srcs)))
+                     $(filter %.asm.s %.asm.S %.asm, $(libvpx_codec_srcs)))
 
 ifneq ($(findstring armeabi-v7a, $(TARGET_ARCH_ABI)),)
 # append .neon to *_neon.c and *.[sS]
@@ -48,10 +46,8 @@ LOCAL_SRC_FILES := $(subst .s,.s.neon,$(LOCAL_SRC_FILES))
 LOCAL_SRC_FILES := $(subst .S,.S.neon,$(LOCAL_SRC_FILES))
 endif
 
-# remove duplicates
-LOCAL_SRC_FILES := $(sort $(LOCAL_SRC_FILES))
-
 LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/libvpx \
                            $(LOCAL_PATH)/libvpx/vpx
 
+LOCAL_LDFLAGS := -Wl,--version-script=$(CONFIG_DIR)/libvpx.ver
 include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 9be351d4f4..16afefbe40 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -20,8 +20,9 @@
 #include <android/log.h>
 
 #include <algorithm>
-#include <cstdlib>
 #include <cstdio>
+#include <cstdlib>
+#include <cstring>
 #include <new>
 
 #include "libyuv.h"  // NOLINT
diff --git a/library/build.gradle b/library/build.gradle
index f02766a773..3580987c31 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -15,7 +15,7 @@ apply plugin: 'com.android.library'
 apply plugin: 'bintray-release'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
@@ -83,7 +83,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.15'
+    version = 'r1.5.16'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
index a1f80bc79b..84a7300d3a 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -43,9 +43,11 @@
   }
 
   public void testParcelable() {
+    ColorInfo colorInfo =  new ColorInfo(C.COLOR_SPACE_BT709,
+        C.COLOR_RANGE_LIMITED, C.COLOR_TRANSFER_SDR, new byte[] {1, 2, 3, 4, 5, 6, 7});
     MediaFormat formatToParcel = new MediaFormat("id", MimeTypes.VIDEO_H264, 1024, 2048,
         C.UNKNOWN_TIME_US, 1920, 1080, 90, 2, 6, 44100, "und", MediaFormat.OFFSET_SAMPLE_RELATIVE,
-        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004, null, C.STEREO_MODE_TOP_BOTTOM);
+        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004, null, C.STEREO_MODE_TOP_BOTTOM, colorInfo);
 
     Parcel parcel = Parcel.obtain();
     formatToParcel.writeToParcel(parcel, 0);
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index b2dad0e5a2..67fd26b60e 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -18,6 +18,7 @@
 import android.media.AudioFormat;
 import android.media.MediaCodec;
 import android.media.MediaExtractor;
+import android.media.MediaFormat;
 import com.google.android.exoplayer.util.Util;
 
 /**
@@ -161,6 +162,42 @@
    */
   public static final int STEREO_MODE_STEREO_MESH = 3;
 
+  /**
+   * @see MediaFormat#COLOR_STANDARD_BT709
+   */
+  public static final int COLOR_SPACE_BT709 = MediaFormat.COLOR_STANDARD_BT709;
+  /**
+   * @see MediaFormat#COLOR_STANDARD_BT601_PAL
+   */
+  public static final int COLOR_SPACE_BT601 = MediaFormat.COLOR_STANDARD_BT601_PAL;
+  /**
+   * @see MediaFormat#COLOR_STANDARD_BT2020
+   */
+  public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
+
+  /**
+   * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO
+   */
+  public static final int COLOR_TRANSFER_SDR = MediaFormat.COLOR_TRANSFER_SDR_VIDEO;
+  /**
+   * @see MediaFormat#COLOR_TRANSFER_ST2084
+   */
+  public static final int COLOR_TRANSFER_ST2084 = MediaFormat.COLOR_TRANSFER_ST2084;
+  /**
+   * @see MediaFormat#COLOR_TRANSFER_HLG
+   */
+  public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
+
+  /**
+   * @see MediaFormat#COLOR_RANGE_LIMITED
+   */
+  public static final int COLOR_RANGE_LIMITED = MediaFormat.COLOR_RANGE_LIMITED;
+  /**
+   * @see MediaFormat#COLOR_RANGE_FULL
+   */
+  public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
+
+
   private C() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ColorInfo.java b/library/src/main/java/com/google/android/exoplayer/ColorInfo.java
new file mode 100644
index 0000000000..17173e8881
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/ColorInfo.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import java.util.Arrays;
+
+/**
+ * Stores color info.
+ */
+public final class ColorInfo implements Parcelable {
+
+  /**
+   * The color space of the video. Valid values are {@link C#COLOR_SPACE_BT601}, {@link
+   * C#COLOR_SPACE_BT709}, {@link C#COLOR_SPACE_BT2020} or {@link MediaFormat#NO_VALUE} if unknown.
+   */
+  public final int colorSpace;
+
+  /**
+   * The color range of the video. Valid values are {@link C#COLOR_RANGE_LIMITED}, {@link
+   * C#COLOR_RANGE_FULL} or {@link MediaFormat#NO_VALUE} if unknown.
+   */
+  public final int colorRange;
+
+  /**
+   * The color transfer characteristicks of the video. Valid values are {@link
+   * C#COLOR_TRANSFER_HLG}, {@link C#COLOR_TRANSFER_ST2084}, {@link C#COLOR_TRANSFER_SDR} or {@link
+   * MediaFormat#NO_VALUE} if unknown.
+   */
+  public final int colorTransfer;
+
+  /**
+   * HdrStaticInfo as defined in CTA-861.3.
+   */
+  public final byte[] hdrStaticInfo;
+
+  // Lazily initialized hashcode.
+  private int hashCode;
+
+  /**
+   * Constructs the ColorInfo.
+   *
+   * @param colorSpace The color space of the video.
+   * @param colorRange The color range of the video.
+   * @param colorTransfer The color transfer characteristics of the video.
+   * @param hdrStaticInfo HdrStaticInfo as defined in CTA-861.3.
+   */
+  public ColorInfo(int colorSpace, int colorRange, int colorTransfer, byte[] hdrStaticInfo) {
+    this.colorSpace = colorSpace;
+    this.colorRange = colorRange;
+    this.colorTransfer = colorTransfer;
+    this.hdrStaticInfo = hdrStaticInfo;
+  }
+
+  /* package */ ColorInfo(Parcel in) {
+    colorSpace = in.readInt();
+    colorRange = in.readInt();
+    colorTransfer = in.readInt();
+    boolean hasHdrStaticInfo = in.readInt() != 0;
+    hdrStaticInfo = hasHdrStaticInfo ? in.createByteArray() : null;
+  }
+
+  // Parcelable implementation.
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ColorInfo other = (ColorInfo) obj;
+    if (colorSpace != other.colorSpace || colorRange != other.colorRange
+        || colorTransfer != other.colorTransfer
+        || !Arrays.equals(hdrStaticInfo, other.hdrStaticInfo)) {
+      return false;
+    }
+    return true;
+  }
+
+  @Override
+  public String toString() {
+    return "ColorInfo(" + colorSpace + ", " + colorRange + ", " + colorTransfer
+        + ", " + (hdrStaticInfo != null) + ")";
+  }
+
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      int result = 17;
+      result = 31 * result + colorSpace;
+      result = 31 * result + colorRange;
+      result = 31 * result + colorTransfer;
+      result = 31 * result + Arrays.hashCode(hdrStaticInfo);
+      hashCode = result;
+    }
+    return hashCode;
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(colorSpace);
+    dest.writeInt(colorRange);
+    dest.writeInt(colorTransfer);
+    dest.writeInt(hdrStaticInfo != null ? 1 : 0);
+    if (hdrStaticInfo != null) {
+      dest.writeByteArray(hdrStaticInfo);
+    }
+  }
+
+  public static final Parcelable.Creator<ColorInfo> CREATOR = new Parcelable.Creator<ColorInfo>() {
+    @Override
+    public ColorInfo createFromParcel(Parcel in) {
+      return new ColorInfo(in);
+    }
+
+    @Override
+    public ColorInfo[] newArray(int size) {
+      return new ColorInfo[0];
+    }
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
index 239d32f3ba..c5cfd07bf4 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
@@ -53,7 +53,7 @@
    */
   @SuppressLint("HandlerLeak")
   public ExoPlayerImpl(int rendererCount, int minBufferMs, int minRebufferMs) {
-    Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION);
+    Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION_SLASHY);
     this.playWhenReady = false;
     this.playbackState = STATE_IDLE;
     this.listeners = new CopyOnWriteArraySet<>();
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 618a3b7fed..0db0142a6e 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -21,17 +21,25 @@
 public final class ExoPlayerLibraryInfo {
 
   /**
-   * The version of the library, expressed as a string.
+   * The version of the library expressed as a string, for example "1.2.3".
    */
-  public static final String VERSION = "1.5.15";
+  // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
+  public static final String VERSION = "1.5.16";
 
   /**
-   * The version of the library, expressed as an integer.
+   * The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}.
+   */
+  // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
+  public static final String VERSION_SLASHY = "ExoPlayerLib/1.5.16";
+
+  /**
+   * The version of the library expressed as an integer, for example 1002003.
    * <p>
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
+  // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
   public static final int VERSION_INT = 1005015;
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index b114e374e0..87d6d73ab4 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -330,7 +330,7 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
         durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
         language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
         MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding,
-        null, MediaFormat.NO_VALUE);
+        null, MediaFormat.NO_VALUE, null);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 46291ae976..7178c20be1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -387,7 +387,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     }
 
     String codecName = decoderInfo.name;
-    codecIsAdaptive = decoderInfo.adaptive;
+    codecIsAdaptive = decoderInfo.adaptive && !codecNeedsDisableAdaptationWorkaround(codecName);
     codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, format);
     codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
     codecNeedsAdaptationWorkaround = codecNeedsAdaptationWorkaround(codecName);
@@ -1209,7 +1209,7 @@ private static boolean codecNeedsEosOutputExceptionWorkaround(String name) {
    *
    * @param name The decoder name.
    * @param format The input format.
-   * @return True if the device is known to set the number of audio channels in the output format
+   * @return True if the decoder is known to set the number of audio channels in the output format
    *     to 2 for the given input format, whilst only actually outputting a single channel. False
    *     otherwise.
    */
@@ -1218,6 +1218,20 @@ private static boolean codecNeedsMonoChannelCountWorkaround(String name, MediaFo
         && "OMX.MTK.AUDIO.DECODER.MP3".equals(name);
   }
 
+  /**
+   * Returns whether the decoder is known to fail when adapting, despite advertising itself as an
+   * adaptive decoder.
+   * <p>
+   * If true is returned then we explicitly disable adaptation for the decoder.
+   *
+   * @param name The decoder name.
+   * @return True if the decoder is known to fail when adapting.
+   */
+  private static boolean codecNeedsDisableAdaptationWorkaround(String name) {
+    return Util.SDK_INT <= 19 && Util.MODEL.equals("ODROID-XU3")
+        && ("OMX.Exynos.AVC.Decoder".equals(name) || "OMX.Exynos.AVC.Decoder.secure".equals(name));
+  }
+
   /**
    * Returns whether the device is known to enable frame-rate conversion logic that negatively
    * impacts ExoPlayer.
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index fbdc3be0ac..9acb48a631 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -122,6 +122,11 @@
    */
   public final byte[] projectionData;
 
+  /**
+   * The color metadata associated with the video, helps with accurate color reproduction.
+   */
+  public final ColorInfo colorInfo;
+
   // Audio specific.
 
   /**
@@ -169,7 +174,7 @@
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData) {
     return createVideoFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
-        initializationData, NO_VALUE, NO_VALUE, null, NO_VALUE);
+        initializationData, NO_VALUE, NO_VALUE, null, NO_VALUE, null);
   }
 
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
@@ -178,17 +183,17 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
         initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null,
-        NO_VALUE);
+        NO_VALUE, null);
   }
 
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData,
       int rotationDegrees, float pixelWidthHeightRatio, byte[] projectionData,
-      int stereoMode) {
+      int stereoMode, ColorInfo colorInfo) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
         initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        projectionData, stereoMode);
+        projectionData, stereoMode, colorInfo);
   }
 
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
@@ -204,7 +209,7 @@ public static MediaFormat createAudioFormat(String trackId, String mimeType, int
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
         initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE, null,
-        NO_VALUE);
+        NO_VALUE, null);
   }
 
   public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
@@ -217,7 +222,7 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null);
   }
 
   public static MediaFormat createImageFormat(String trackId, String mimeType, int bitrate,
@@ -225,14 +230,14 @@ public static MediaFormat createImageFormat(String trackId, String mimeType, int
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, OFFSET_SAMPLE_RELATIVE,
         initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null,
-        NO_VALUE);
+        NO_VALUE, null);
   }
 
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null);
   }
 
   public static MediaFormat createId3Format() {
@@ -265,6 +270,7 @@ public static MediaFormat createId3Format() {
     boolean hasProjectionData = in.readInt() != 0;
     projectionData = hasProjectionData ? in.createByteArray() : null;
     stereoMode = in.readInt();
+    colorInfo = in.readParcelable(ColorInfo.class.getClassLoader());
   }
 
   /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
@@ -272,7 +278,7 @@ public static MediaFormat createId3Format() {
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
       int pcmEncoding, int encoderDelay, int encoderPadding, byte[] projectionData,
-      int stereoMode) {
+      int stereoMode, ColorInfo colorInfo) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -296,41 +302,42 @@ public static MediaFormat createId3Format() {
     this.encoderPadding = encoderPadding;
     this.projectionData = projectionData;
     this.stereoMode = stereoMode;
+    this.colorInfo = colorInfo;
   }
 
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   public MediaFormat copyWithMaxVideoDimensions(int maxWidth, int maxHeight) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   public MediaFormat copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   public MediaFormat copyWithDurationUs(long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   public MediaFormat copyWithLanguage(String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
@@ -338,20 +345,20 @@ public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
-        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE, null, stereoMode);
+        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE, null, stereoMode, colorInfo);
   }
 
   public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding, projectionData, stereoMode);
+        encoderDelay, encoderPadding, projectionData, stereoMode, colorInfo);
   }
 
   /**
@@ -380,6 +387,7 @@ public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
       if (durationUs != C.UNKNOWN_TIME_US) {
         format.setLong(android.media.MediaFormat.KEY_DURATION, durationUs);
       }
+      maybeSetColorInfoV24(format, colorInfo);
       frameworkMediaFormat = format;
     }
     return frameworkMediaFormat;
@@ -459,6 +467,7 @@ public boolean equals(Object obj) {
         || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
         || !Util.areEqual(mimeType, other.mimeType)
         || initializationData.size() != other.initializationData.size()
+        || !Util.areEqual(colorInfo, other.colorInfo)
         || !Arrays.equals(projectionData, other.projectionData)
         || stereoMode != other.stereoMode) {
       return false;
@@ -471,6 +480,19 @@ public boolean equals(Object obj) {
     return true;
   }
 
+  @TargetApi(24)
+  private static void maybeSetColorInfoV24(android.media.MediaFormat format, ColorInfo colorInfo) {
+    if (colorInfo == null) {
+      return;
+    }
+    maybeSetIntegerV16(format,
+        android.media.MediaFormat.KEY_COLOR_TRANSFER, colorInfo.colorTransfer);
+    maybeSetIntegerV16(format, android.media.MediaFormat.KEY_COLOR_STANDARD, colorInfo.colorSpace);
+    maybeSetIntegerV16(format, android.media.MediaFormat.KEY_COLOR_RANGE, colorInfo.colorRange);
+    maybeSetByteBufferV16(format,
+        android.media.MediaFormat.KEY_HDR_STATIC_INFO, colorInfo.hdrStaticInfo);
+  }
+
   @TargetApi(16)
   private static final void maybeSetStringV16(android.media.MediaFormat format, String key,
       String value) {
@@ -487,6 +509,14 @@ private static final void maybeSetIntegerV16(android.media.MediaFormat format, S
     }
   }
 
+  @TargetApi(16)
+  private static void maybeSetByteBufferV16(android.media.MediaFormat format, String key,
+      byte[] value) {
+    if (value != null) {
+      format.setByteBuffer(key, ByteBuffer.wrap(value));
+    }
+  }
+
   // Parcelable implementation.
 
   @Override
@@ -521,6 +551,7 @@ public void writeToParcel(Parcel dest, int flags) {
       dest.writeByteArray(projectionData);
     }
     dest.writeInt(stereoMode);
+    dest.writeParcelable(colorInfo, flags);
   }
 
   public static final Creator<MediaFormat> CREATOR = new Creator<MediaFormat>() {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 1bcb44d387..c16b7b016a 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -888,7 +888,8 @@ public RepresentationHolder(long periodStartTimeUs, long periodDurationUs,
       String mimeType = representation.format.mimeType;
       mimeTypeIsRawText = mimeTypeIsRawText(mimeType);
       extractorWrapper = mimeTypeIsRawText ? null : new ChunkExtractorWrapper(
-          mimeTypeIsWebm(mimeType) ? new WebmExtractor() : new FragmentedMp4Extractor());
+          mimeTypeIsWebm(mimeType) ? new WebmExtractor(WebmExtractor.FLAG_DISABLE_SEEK_FOR_CUES)
+              : new FragmentedMp4Extractor());
       segmentIndex = representation.getIndex();
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 03a27b1dff..7efccf315f 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -707,7 +707,7 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
 
     out.mediaFormat = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
         MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, width, height, initializationData,
-        rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode);
+        rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode, null);
   }
 
   private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int position) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index 526a5a3b0b..9d085e409f 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -18,6 +18,7 @@
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ColorInfo;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.drm.DrmInitData;
@@ -55,6 +56,16 @@
  */
 public final class WebmExtractor implements Extractor {
 
+  /**
+   * Flag to disable seeking for cues.
+   * <p>
+   * Normally (i.e. when this flag is not set) the extractor will seek to the cues element if its
+   * position is specified in the seek head and if it's after the first cluster. Setting this flag
+   * disables seeking to the cues element. If the cues element is after the first cluster then the
+   * media is treated as being unseekable.
+   */
+  public static final int FLAG_DISABLE_SEEK_FOR_CUES = 1;
+
   private static final int BLOCK_STATE_START = 0;
   private static final int BLOCK_STATE_HEADER = 1;
   private static final int BLOCK_STATE_DATA = 2;
@@ -154,6 +165,23 @@
   private static final int ID_PROJECTION = 0x7670;
   private static final int ID_PROJECTION_PRIVATE = 0x7672;
   private static final int ID_STEREO_MODE = 0x53B8;
+  private static final int ID_COLOUR = 0x55B0;
+  private static final int ID_COLOUR_RANGE = 0x55B9;
+  private static final int ID_COLOUR_TRANSFER = 0x55BA;
+  private static final int ID_COLOUR_PRIMARIES = 0x55BB;
+  private static final int ID_MAX_CLL = 0x55BC;
+  private static final int ID_MAX_FALL = 0x55BD;
+  private static final int ID_MASTERING_METADATA = 0x55D0;
+  private static final int ID_PRIMARY_R_CHROMATICITY_X = 0x55D1;
+  private static final int ID_PRIMARY_R_CHROMATICITY_Y = 0x55D2;
+  private static final int ID_PRIMARY_G_CHROMATICITY_X = 0x55D3;
+  private static final int ID_PRIMARY_G_CHROMATICITY_Y = 0x55D4;
+  private static final int ID_PRIMARY_B_CHROMATICITY_X = 0x55D5;
+  private static final int ID_PRIMARY_B_CHROMATICITY_Y = 0x55D6;
+  private static final int ID_WHITE_POINT_CHROMATICITY_X = 0x55D7;
+  private static final int ID_WHITE_POINT_CHROMATICITY_Y = 0x55D8;
+  private static final int ID_LUMNINANCE_MAX = 0x55D9;
+  private static final int ID_LUMNINANCE_MIN = 0x55DA;
   private static final int LACING_NONE = 0;
   private static final int LACING_XIPH = 1;
   private static final int LACING_FIXED_SIZE = 2;
@@ -207,6 +235,7 @@
   private final EbmlReader reader;
   private final VarintReader varintReader;
   private final SparseArray<Track> tracks;
+  private final boolean seekForCuesEnabled;
 
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
@@ -274,12 +303,20 @@
   private ExtractorOutput extractorOutput;
 
   public WebmExtractor() {
-    this(new DefaultEbmlReader());
+    this(new DefaultEbmlReader(), 0);
+  }
+
+  /**
+   * @param flags Flags that control the extractor's behavior.
+   */
+  public WebmExtractor(int flags) {
+    this(new DefaultEbmlReader(), flags);
   }
 
-  /* package */ WebmExtractor(EbmlReader reader) {
+  /* package */ WebmExtractor(EbmlReader reader, int flags) {
     this.reader = reader;
     this.reader.init(new InnerEbmlReaderOutput());
+    seekForCuesEnabled = (flags & FLAG_DISABLE_SEEK_FOR_CUES) == 0;
     varintReader = new VarintReader();
     tracks = new SparseArray<>();
     scratch = new ParsableByteArray(4);
@@ -353,6 +390,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CUE_TRACK_POSITIONS:
       case ID_BLOCK_GROUP:
       case ID_PROJECTION:
+      case ID_COLOUR:
+      case ID_MASTERING_METADATA:
         return EbmlReader.TYPE_MASTER;
       case ID_EBML_READ_VERSION:
       case ID_DOC_TYPE_READ_VERSION:
@@ -381,6 +420,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CUE_CLUSTER_POSITION:
       case ID_REFERENCE_BLOCK:
       case ID_STEREO_MODE:
+      case ID_COLOUR_RANGE:
+      case ID_COLOUR_TRANSFER:
+      case ID_COLOUR_PRIMARIES:
+      case ID_MAX_CLL:
+      case ID_MAX_FALL:
         return EbmlReader.TYPE_UNSIGNED_INT;
       case ID_DOC_TYPE:
       case ID_CODEC_ID:
@@ -396,6 +440,16 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         return EbmlReader.TYPE_BINARY;
       case ID_DURATION:
       case ID_SAMPLING_FREQUENCY:
+      case ID_PRIMARY_R_CHROMATICITY_X:
+      case ID_PRIMARY_R_CHROMATICITY_Y:
+      case ID_PRIMARY_G_CHROMATICITY_X:
+      case ID_PRIMARY_G_CHROMATICITY_Y:
+      case ID_PRIMARY_B_CHROMATICITY_X:
+      case ID_PRIMARY_B_CHROMATICITY_Y:
+      case ID_WHITE_POINT_CHROMATICITY_X:
+      case ID_WHITE_POINT_CHROMATICITY_Y:
+      case ID_LUMNINANCE_MAX:
+      case ID_LUMNINANCE_MIN:
         return EbmlReader.TYPE_FLOAT;
       default:
         return EbmlReader.TYPE_UNKNOWN;
@@ -430,7 +484,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CLUSTER:
         if (!sentSeekMap) {
           // We need to build cues before parsing the cluster.
-          if (cuesContentPosition != UNKNOWN) {
+          if (seekForCuesEnabled && cuesContentPosition != UNKNOWN) {
             // We know where the Cues element is located. Seek to request it.
             seekForCues = true;
           } else {
@@ -453,6 +507,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_TRACK_ENTRY:
         currentTrack = new Track();
         return;
+      case ID_MASTERING_METADATA:
+        currentTrack.hasColorInfo = true;
+        break;
       default:
         return;
     }
@@ -660,6 +717,60 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
             break;
         }
         return;
+      case ID_COLOUR_PRIMARIES:
+        currentTrack.hasColorInfo = true;
+        switch ((int) value) {
+          case 1:
+            currentTrack.colorSpace = C.COLOR_SPACE_BT709;
+            break;
+          case 4:  // BT.470M.
+          case 5:  // BT.470BG.
+          case 6:  // SMPTE 170M.
+          case 7:  // SMPTE 240M.
+            currentTrack.colorSpace = C.COLOR_SPACE_BT601;
+            break;
+          case 9:
+            currentTrack.colorSpace = C.COLOR_SPACE_BT2020;
+            break;
+          default:
+            break;
+        }
+        break;
+      case ID_COLOUR_TRANSFER:
+        switch ((int) value) {
+          case 1:  // BT.709.
+          case 6:  // SMPTE 170M.
+          case 7:  // SMPTE 240M.
+            currentTrack.colorTransfer = C.COLOR_TRANSFER_SDR;
+            break;
+          case 16:
+            currentTrack.colorTransfer = C.COLOR_TRANSFER_ST2084;
+            break;
+          case 18:
+            currentTrack.colorTransfer = C.COLOR_TRANSFER_HLG;
+            break;
+          default:
+            break;
+        }
+        break;
+      case ID_COLOUR_RANGE:
+        switch((int) value) {
+          case 1:  // Broadcast range.
+            currentTrack.colorRange = C.COLOR_RANGE_LIMITED;
+            break;
+          case 2:
+            currentTrack.colorRange = C.COLOR_RANGE_FULL;
+            break;
+          default:
+            break;
+        }
+        break;
+      case ID_MAX_CLL:
+        currentTrack.maxContentLuminance = (int) value;
+        break;
+      case ID_MAX_FALL:
+        currentTrack.maxFrameAverageLuminance = (int) value;
+        break;
       default:
         return;
     }
@@ -673,6 +784,36 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_SAMPLING_FREQUENCY:
         currentTrack.sampleRate = (int) value;
         return;
+      case ID_PRIMARY_R_CHROMATICITY_X:
+        currentTrack.primaryRChromaticityX = (float) value;
+        break;
+      case ID_PRIMARY_R_CHROMATICITY_Y:
+        currentTrack.primaryRChromaticityY = (float) value;
+        break;
+      case ID_PRIMARY_G_CHROMATICITY_X:
+        currentTrack.primaryGChromaticityX = (float) value;
+        break;
+      case ID_PRIMARY_G_CHROMATICITY_Y:
+        currentTrack.primaryGChromaticityY = (float) value;
+        break;
+      case ID_PRIMARY_B_CHROMATICITY_X:
+        currentTrack.primaryBChromaticityX = (float) value;
+        break;
+      case ID_PRIMARY_B_CHROMATICITY_Y:
+        currentTrack.primaryBChromaticityY = (float) value;
+        break;
+      case ID_WHITE_POINT_CHROMATICITY_X:
+        currentTrack.whitePointChromaticityX = (float) value;
+        break;
+      case ID_WHITE_POINT_CHROMATICITY_Y:
+        currentTrack.whitePointChromaticityY = (float) value;
+        break;
+      case ID_LUMNINANCE_MAX:
+        currentTrack.maxMasteringLuminance = (float) value;
+        break;
+      case ID_LUMNINANCE_MIN:
+        currentTrack.minMasteringLuminance = (float) value;
+        break;
       default:
         return;
     }
@@ -1285,6 +1426,16 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
   private static final class Track {
 
     private static final int DISPLAY_UNIT_PIXELS = 0;
+    private static final int MAX_CHROMATICITY = 50000;  // Defined in CTA-861.3.
+    /**
+     * Default max content light level (CLL) that should be encoded into hdrStaticInfo.
+     */
+    private static final int DEFAULT_MAX_CLL = 1000;  // nits.
+
+    /**
+     * Default frame-average light level (FALL) that should be encoded into hdrStaticInfo.
+     */
+    private static final int DEFAULT_MAX_FALL = 200;  // nits.
 
     // Common elements.
     public String codecId;
@@ -1304,6 +1455,22 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public int displayUnit = DISPLAY_UNIT_PIXELS;
     public byte[] projectionData = null;
     public int stereoMode = MediaFormat.NO_VALUE;
+    public boolean hasColorInfo = false;
+    public int colorSpace = MediaFormat.NO_VALUE;
+    public int colorTransfer = MediaFormat.NO_VALUE;
+    public int colorRange = MediaFormat.NO_VALUE;
+    public int maxContentLuminance = DEFAULT_MAX_CLL;
+    public int maxFrameAverageLuminance = DEFAULT_MAX_FALL;
+    public float primaryRChromaticityX = MediaFormat.NO_VALUE;
+    public float primaryRChromaticityY = MediaFormat.NO_VALUE;
+    public float primaryGChromaticityX = MediaFormat.NO_VALUE;
+    public float primaryGChromaticityY = MediaFormat.NO_VALUE;
+    public float primaryBChromaticityX = MediaFormat.NO_VALUE;
+    public float primaryBChromaticityY = MediaFormat.NO_VALUE;
+    public float whitePointChromaticityX = MediaFormat.NO_VALUE;
+    public float whitePointChromaticityY = MediaFormat.NO_VALUE;
+    public float maxMasteringLuminance = MediaFormat.NO_VALUE;
+    public float minMasteringLuminance = MediaFormat.NO_VALUE;
 
     // Audio elements. Initially set to their default values.
     public int channelCount = 1;
@@ -1453,9 +1620,14 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         if (displayWidth != MediaFormat.NO_VALUE && displayHeight != MediaFormat.NO_VALUE) {
           pixelWidthHeightRatio = ((float) (height * displayWidth)) / (width * displayHeight);
         }
+        ColorInfo colorInfo = null;
+        if (hasColorInfo) {
+          byte[] hdrStaticInfo = getHdrStaticInfo();
+          colorInfo = new ColorInfo(colorSpace, colorRange, colorTransfer, hdrStaticInfo);
+        }
         format = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, maxInputSize, durationUs, width, height, initializationData,
-            MediaFormat.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode);
+            MediaFormat.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode, colorInfo);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
         format = MediaFormat.createTextFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, durationUs, language);
@@ -1471,6 +1643,42 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       this.output.format(format);
     }
 
+    /**
+     * Returns the HDR Static Info as defined in CTA-861.3.
+     */
+    private byte[] getHdrStaticInfo() {
+      // Are all fields present.
+      if (primaryRChromaticityX == MediaFormat.NO_VALUE
+          || primaryRChromaticityY == MediaFormat.NO_VALUE
+          || primaryGChromaticityX == MediaFormat.NO_VALUE
+          || primaryGChromaticityY == MediaFormat.NO_VALUE
+          || primaryBChromaticityX == MediaFormat.NO_VALUE
+          || primaryBChromaticityY == MediaFormat.NO_VALUE
+          || whitePointChromaticityX == MediaFormat.NO_VALUE
+          || whitePointChromaticityY == MediaFormat.NO_VALUE
+          || maxMasteringLuminance == MediaFormat.NO_VALUE
+          || minMasteringLuminance == MediaFormat.NO_VALUE) {
+        return null;
+      }
+
+      byte[] hdrStaticInfoData = new byte[25];
+      ByteBuffer hdrStaticInfo = ByteBuffer.wrap(hdrStaticInfoData);
+      hdrStaticInfo.put((byte) 0);  // Type.
+      hdrStaticInfo.putShort((short) ((primaryRChromaticityX * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) ((primaryRChromaticityY * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) ((primaryGChromaticityX * MAX_CHROMATICITY)  + 0.5f));
+      hdrStaticInfo.putShort((short) ((primaryGChromaticityY * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) ((primaryBChromaticityX * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) ((primaryBChromaticityY * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) ((whitePointChromaticityX * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) ((whitePointChromaticityY * MAX_CHROMATICITY) + 0.5f));
+      hdrStaticInfo.putShort((short) (maxMasteringLuminance + 0.5f));
+      hdrStaticInfo.putShort((short) (minMasteringLuminance + 0.5f));
+      hdrStaticInfo.putShort((short) maxContentLuminance);
+      hdrStaticInfo.putShort((short) maxFrameAverageLuminance);
+      return hdrStaticInfoData;
+    }
+
     /**
      * Builds initialization data for a {@link MediaFormat} from FourCC codec private data.
      * <p>
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
index dd6b54b016..545df0a249 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
@@ -104,8 +104,11 @@
 
   }
 
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+
   private final UriLoadable.Parser<T> parser;
   private final UriDataSource uriDataSource;
+  private final int minLoadableRetryCount;
   private final Handler eventHandler;
   private final EventListener eventListener;
 
@@ -144,11 +147,29 @@ public ManifestFetcher(String manifestUri, UriDataSource uriDataSource,
    */
   public ManifestFetcher(String manifestUri, UriDataSource uriDataSource,
       UriLoadable.Parser<T> parser, Handler eventHandler, EventListener eventListener) {
+    this(manifestUri, uriDataSource, parser, eventHandler, eventListener,
+        DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+  }
+
+  /**
+   * @param manifestUri The manifest location.
+   * @param uriDataSource The {@link UriDataSource} to use when loading the manifest.
+   * @param parser A parser to parse the loaded manifest data.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param minLoadableRetryCount The minimum number of times that the source should retry a load
+   *     before propagating an error.
+   */
+  public ManifestFetcher(String manifestUri, UriDataSource uriDataSource,
+      UriLoadable.Parser<T> parser, Handler eventHandler, EventListener eventListener,
+      int minLoadableRetryCount) {
     this.parser = parser;
     this.manifestUri = manifestUri;
     this.uriDataSource = uriDataSource;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
+    this.minLoadableRetryCount = minLoadableRetryCount;
   }
 
   /**
@@ -211,8 +232,8 @@ public long getManifestLoadCompleteTimestamp() {
    *     manifest.
    */
   public void maybeThrowError() throws ManifestIOException {
-    // Don't throw an exception until at least 1 retry attempt has been made.
-    if (loadException == null || loadExceptionCount <= 1) {
+    // Don't throw an exception until at least minLoadableRetryCount retry attempts has been made.
+    if (loadException == null || loadExceptionCount <= minLoadableRetryCount) {
       return;
     }
     throw loadException;
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 5cfbcce17b..287af6d6d0 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -727,7 +727,7 @@ public static String getUserAgent(Context context, String applicationName) {
       versionName = "?";
     }
     return applicationName + "/" + versionName + " (Linux;Android " + Build.VERSION.RELEASE
-        + ") " + "ExoPlayerLib/" + ExoPlayerLibraryInfo.VERSION;
+        + ") " + ExoPlayerLibraryInfo.VERSION_SLASHY;
   }
 
   /**
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index b7af1c7f4f..a28ef34084 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -14,7 +14,7 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 23
+    compileSdkVersion 24
     buildToolsVersion '25.0.0'
 
     defaultConfig {
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index f9c3b29fc1..458383eaef 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1515"
-    android:versionName="1.5.15">
+    android:versionCode="1516"
+    android:versionName="1.5.16">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
