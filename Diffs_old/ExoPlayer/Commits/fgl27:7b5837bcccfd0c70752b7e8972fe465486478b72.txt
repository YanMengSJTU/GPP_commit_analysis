diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index bfdf9e733e..06cfde8d6c 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -52,6 +52,12 @@
   ([#6192](https://github.com/google/ExoPlayer/issues/6192)).
 * Fix Flac and ALAC playback on some LG devices
   ([#5938](https://github.com/google/ExoPlayer/issues/5938)).
+* Fix issue when calling `performClick` on `PlayerView` without
+  `PlayerControlView`
+  ([#6260](https://github.com/google/ExoPlayer/issues/6260)).
+* Fix issue where playback speeds are not used in adaptive track selections
+  after manual selection changes for other renderers
+  ([#6256](https://github.com/google/ExoPlayer/issues/6256)).
 
 ### 2.10.3 ###
 
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/package-info.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/package-info.java
new file mode 100644
index 0000000000..07055905a6
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.cast;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/package-info.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/package-info.java
new file mode 100644
index 0000000000..ec0cf8df05
--- /dev/null
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.cronet;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/package-info.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/package-info.java
new file mode 100644
index 0000000000..a9fedb19cb
--- /dev/null
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.ffmpeg;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/package-info.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/package-info.java
new file mode 100644
index 0000000000..ef6da7e3c6
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.flac;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 249271dc61..e37f192c97 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -426,7 +426,7 @@ public ImaAdsLoader(Context context, Uri adTagUri) {
    * @deprecated Use {@link ImaAdsLoader.Builder}.
    */
   @Deprecated
-  public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings) {
+  public ImaAdsLoader(Context context, Uri adTagUri, @Nullable ImaSdkSettings imaSdkSettings) {
     this(
         context,
         adTagUri,
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/package-info.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/package-info.java
new file mode 100644
index 0000000000..9a382eb18f
--- /dev/null
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.ima;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/package-info.java b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/package-info.java
new file mode 100644
index 0000000000..a66904b505
--- /dev/null
+++ b/extensions/jobdispatcher/src/main/java/com/google/android/exoplayer2/ext/jobdispatcher/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.jobdispatcher;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/package-info.java b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/package-info.java
new file mode 100644
index 0000000000..79c544fc0f
--- /dev/null
+++ b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.leanback;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/package-info.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/package-info.java
new file mode 100644
index 0000000000..54eb4d5967
--- /dev/null
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.okhttp;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/package-info.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/package-info.java
new file mode 100644
index 0000000000..0848937fdc
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.opus;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/package-info.java b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/package-info.java
new file mode 100644
index 0000000000..cb16630bd3
--- /dev/null
+++ b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.rtmp;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index de411089ab..7177cde12e 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -15,39 +15,12 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.decoder.OutputBuffer;
-import com.google.android.exoplayer2.video.ColorInfo;
-import java.nio.ByteBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
 
-/** Output buffer containing video frame data, populated by {@link VpxDecoder}. */
-public final class VpxOutputBuffer extends OutputBuffer {
-
-  public static final int COLORSPACE_UNKNOWN = 0;
-  public static final int COLORSPACE_BT601 = 1;
-  public static final int COLORSPACE_BT709 = 2;
-  public static final int COLORSPACE_BT2020 = 3;
+/** Video output buffer, populated by {@link VpxDecoder}. */
+public final class VpxOutputBuffer extends VideoDecoderOutputBuffer {
 
   private final VpxDecoder owner;
-  /** Decoder private data. */
-  public int decoderPrivate;
-
-  /** Output mode. */
-  @C.VideoOutputMode public int mode;
-  /**
-   * RGB buffer for RGB mode.
-   */
-  public ByteBuffer data;
-  public int width;
-  public int height;
-  public ColorInfo colorInfo;
-
-  /**
-   * YUV planes for YUV mode.
-   */
-  public ByteBuffer[] yuvPlanes;
-  public int[] yuvStrides;
-  public int colorspace;
 
   public VpxOutputBuffer(VpxDecoder owner) {
     this.owner = owner;
@@ -58,84 +31,4 @@ public void release() {
     owner.releaseOutputBuffer(this);
   }
 
-  /**
-   * Initializes the buffer.
-   *
-   * @param timeUs The presentation timestamp for the buffer, in microseconds.
-   * @param mode The output mode. One of {@link C#VIDEO_OUTPUT_MODE_NONE}, {@link
-   *     C#VIDEO_OUTPUT_MODE_YUV} and {@link C#VIDEO_OUTPUT_MODE_SURFACE_YUV}.
-   */
-  public void init(long timeUs, @C.VideoOutputMode int mode) {
-    this.timeUs = timeUs;
-    this.mode = mode;
-  }
-
-  /**
-   * Resizes the buffer based on the given stride. Called via JNI after decoding completes.
-   *
-   * @return Whether the buffer was resized successfully.
-   */
-  public boolean initForYuvFrame(int width, int height, int yStride, int uvStride, int colorspace) {
-    this.width = width;
-    this.height = height;
-    this.colorspace = colorspace;
-    int uvHeight = (int) (((long) height + 1) / 2);
-    if (!isSafeToMultiply(yStride, height) || !isSafeToMultiply(uvStride, uvHeight)) {
-      return false;
-    }
-    int yLength = yStride * height;
-    int uvLength = uvStride * uvHeight;
-    int minimumYuvSize = yLength + (uvLength * 2);
-    if (!isSafeToMultiply(uvLength, 2) || minimumYuvSize < yLength) {
-      return false;
-    }
-    initData(minimumYuvSize);
-
-    if (yuvPlanes == null) {
-      yuvPlanes = new ByteBuffer[3];
-    }
-    // Rewrapping has to be done on every frame since the stride might have changed.
-    yuvPlanes[0] = data.slice();
-    yuvPlanes[0].limit(yLength);
-    data.position(yLength);
-    yuvPlanes[1] = data.slice();
-    yuvPlanes[1].limit(uvLength);
-    data.position(yLength + uvLength);
-    yuvPlanes[2] = data.slice();
-    yuvPlanes[2].limit(uvLength);
-    if (yuvStrides == null) {
-      yuvStrides = new int[3];
-    }
-    yuvStrides[0] = yStride;
-    yuvStrides[1] = uvStride;
-    yuvStrides[2] = uvStride;
-    return true;
-  }
-
-  /**
-   * Configures the buffer for the given frame dimensions when passing actual frame data via {@link
-   * #decoderPrivate}. Called via JNI after decoding completes.
-   */
-  public void initForPrivateFrame(int width, int height) {
-    this.width = width;
-    this.height = height;
-  }
-
-  private void initData(int size) {
-    if (data == null || data.capacity() < size) {
-      data = ByteBuffer.allocateDirect(size);
-    } else {
-      data.position(0);
-      data.limit(size);
-    }
-  }
-
-  /**
-   * Ensures that the result of multiplying individual numbers can fit into the size limit of an
-   * integer.
-   */
-  private boolean isSafeToMultiply(int a, int b) {
-    return a >= 0 && b >= 0 && !(b > 0 && a >= Integer.MAX_VALUE / b);
-  }
-
 }
diff --git a/extensions/workmanager/src/main/java/com/google/android/exoplayer2/ext/workmanager/package-info.java b/extensions/workmanager/src/main/java/com/google/android/exoplayer2/ext/workmanager/package-info.java
new file mode 100644
index 0000000000..7e0e244231
--- /dev/null
+++ b/extensions/workmanager/src/main/java/com/google/android/exoplayer2/ext/workmanager/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.workmanager;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 3eed66402d..e99429d3b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -647,7 +647,7 @@ private PlaybackInfo getResetPlaybackInfo(
     resetPosition = resetPosition || resetState;
     MediaPeriodId mediaPeriodId =
         resetPosition
-            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
+            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window, period)
             : playbackInfo.periodId;
     long startPositionUs = resetPosition ? 0 : playbackInfo.positionUs;
     long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 4fe8da92c2..6ab0838e26 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -646,7 +646,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     if (resolvedSeekPosition == null) {
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed or is not ready and a suitable seek position could not be resolved.
-      periodId = playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window);
+      periodId = playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window, period);
       periodPositionUs = C.TIME_UNSET;
       contentPositionUs = C.TIME_UNSET;
       seekPositionAdjusted = true;
@@ -884,7 +884,7 @@ private void resetInternal(
       }
     }
 
-    queue.clear(/* keepFrontPeriodUid= */ !resetPosition);
+    queue.clear(/* keepFrontPeriodUid= */ !resetState);
     setIsLoading(false);
     if (resetState) {
       queue.setTimeline(Timeline.EMPTY);
@@ -896,7 +896,7 @@ private void resetInternal(
     }
     MediaPeriodId mediaPeriodId =
         resetPosition
-            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
+            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window, period)
             : playbackInfo.periodId;
     // Set the start position to TIME_UNSET so that a subsequent seek to 0 isn't ignored.
     long startPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.positionUs;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index 669f41ca13..e9b99acd77 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -150,17 +150,26 @@ public PlaybackInfo(
    *
    * @param shuffleModeEnabled Whether shuffle mode is enabled.
    * @param window A writable {@link Timeline.Window}.
+   * @param period A writable {@link Timeline.Period}.
    * @return A dummy media period id for the first-to-be-played period of the current timeline.
    */
   public MediaPeriodId getDummyFirstMediaPeriodId(
-      boolean shuffleModeEnabled, Timeline.Window window) {
+      boolean shuffleModeEnabled, Timeline.Window window, Timeline.Period period) {
     if (timeline.isEmpty()) {
       return DUMMY_MEDIA_PERIOD_ID;
     }
-    int firstPeriodIndex =
-        timeline.getWindow(timeline.getFirstWindowIndex(shuffleModeEnabled), window)
-            .firstPeriodIndex;
-    return new MediaPeriodId(timeline.getUidOfPeriod(firstPeriodIndex));
+    int firstWindowIndex = timeline.getFirstWindowIndex(shuffleModeEnabled);
+    int firstPeriodIndex = timeline.getWindow(firstWindowIndex, window).firstPeriodIndex;
+    int currentPeriodIndex = timeline.getIndexOfPeriod(periodId.periodUid);
+    long windowSequenceNumber = C.INDEX_UNSET;
+    if (currentPeriodIndex != C.INDEX_UNSET) {
+      int currentWindowIndex = timeline.getPeriod(currentPeriodIndex, period).windowIndex;
+      if (firstWindowIndex == currentWindowIndex) {
+        // Keep window sequence number if the new position is still in the same window.
+        windowSequenceNumber = periodId.windowSequenceNumber;
+      }
+    }
+    return new MediaPeriodId(timeline.getUidOfPeriod(firstPeriodIndex), windowSequenceNumber);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index f076eae32c..847c87b077 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -106,13 +106,16 @@
    * Performs a track selection.
    *
    * <p>The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
-   * indicating whether the existing {@code SampleStream} can be retained for each selection, and
+   * indicating whether the existing {@link SampleStream} can be retained for each selection, and
    * the existing {@code stream}s themselves. The call will update {@code streams} to reflect the
    * provided selections, clearing, setting and replacing entries as required. If an existing sample
    * stream is retained but with the requirement that the consuming renderer be reset, then the
    * corresponding flag in {@code streamResetFlags} will be set to true. This flag will also be set
    * if a new sample stream is created.
    *
+   * <p>Note that previously received {@link TrackSelection TrackSelections} are no longer valid and
+   * references need to be replaced even if the corresponding {@link SampleStream} is kept.
+   *
    * <p>This method is only called after the period has been prepared.
    *
    * @param selections The renderer track selections.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
new file mode 100644
index 0000000000..af0844defb
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.decoder.OutputBuffer;
+import java.nio.ByteBuffer;
+
+/** Video decoder output buffer containing video frame data. */
+public abstract class VideoDecoderOutputBuffer extends OutputBuffer {
+
+  public static final int COLORSPACE_UNKNOWN = 0;
+  public static final int COLORSPACE_BT601 = 1;
+  public static final int COLORSPACE_BT709 = 2;
+  public static final int COLORSPACE_BT2020 = 3;
+
+  /** Decoder private data. */
+  public int decoderPrivate;
+
+  /** Output mode. */
+  @C.VideoOutputMode public int mode;
+  /** RGB buffer for RGB mode. */
+  public ByteBuffer data;
+
+  public int width;
+  public int height;
+  public ColorInfo colorInfo;
+
+  /** YUV planes for YUV mode. */
+  public ByteBuffer[] yuvPlanes;
+
+  public int[] yuvStrides;
+  public int colorspace;
+
+  /**
+   * Initializes the buffer.
+   *
+   * @param timeUs The presentation timestamp for the buffer, in microseconds.
+   * @param mode The output mode. One of {@link C#VIDEO_OUTPUT_MODE_NONE}, {@link
+   *     C#VIDEO_OUTPUT_MODE_YUV} and {@link C#VIDEO_OUTPUT_MODE_SURFACE_YUV}.
+   */
+  public void init(long timeUs, @C.VideoOutputMode int mode) {
+    this.timeUs = timeUs;
+    this.mode = mode;
+  }
+
+  /**
+   * Resizes the buffer based on the given stride. Called via JNI after decoding completes.
+   *
+   * @return Whether the buffer was resized successfully.
+   */
+  public boolean initForYuvFrame(int width, int height, int yStride, int uvStride, int colorspace) {
+    this.width = width;
+    this.height = height;
+    this.colorspace = colorspace;
+    int uvHeight = (int) (((long) height + 1) / 2);
+    if (!isSafeToMultiply(yStride, height) || !isSafeToMultiply(uvStride, uvHeight)) {
+      return false;
+    }
+    int yLength = yStride * height;
+    int uvLength = uvStride * uvHeight;
+    int minimumYuvSize = yLength + (uvLength * 2);
+    if (!isSafeToMultiply(uvLength, 2) || minimumYuvSize < yLength) {
+      return false;
+    }
+
+    // Initialize data.
+    if (data == null || data.capacity() < minimumYuvSize) {
+      data = ByteBuffer.allocateDirect(minimumYuvSize);
+    } else {
+      data.position(0);
+      data.limit(minimumYuvSize);
+    }
+
+    if (yuvPlanes == null) {
+      yuvPlanes = new ByteBuffer[3];
+    }
+    // Rewrapping has to be done on every frame since the stride might have changed.
+    yuvPlanes[0] = data.slice();
+    yuvPlanes[0].limit(yLength);
+    data.position(yLength);
+    yuvPlanes[1] = data.slice();
+    yuvPlanes[1].limit(uvLength);
+    data.position(yLength + uvLength);
+    yuvPlanes[2] = data.slice();
+    yuvPlanes[2].limit(uvLength);
+    if (yuvStrides == null) {
+      yuvStrides = new int[3];
+    }
+    yuvStrides[0] = yStride;
+    yuvStrides[1] = uvStride;
+    yuvStrides[2] = uvStride;
+    return true;
+  }
+
+  /**
+   * Configures the buffer for the given frame dimensions when passing actual frame data via {@link
+   * #decoderPrivate}. Called via JNI after decoding completes.
+   */
+  public void initForPrivateFrame(int width, int height) {
+    this.width = width;
+    this.height = height;
+  }
+
+  /**
+   * Ensures that the result of multiplying individual numbers can fit into the size limit of an
+   * integer.
+   */
+  private static boolean isSafeToMultiply(int a, int b) {
+    return a >= 0 && b >= 0 && !(b > 0 && a >= Integer.MAX_VALUE / b);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index d5b0b2c667..f924dfb34c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.Player.EventListener;
 import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -59,6 +60,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -1434,6 +1436,46 @@ public void run(SimpleExoPlayer player) {
     assertThat(windowIndexHolder[2]).isEqualTo(1);
   }
 
+  @Test
+  public void playbackErrorAndReprepareWithPositionResetKeepsWindowSequenceNumber()
+      throws Exception {
+    FakeMediaSource mediaSource = new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1));
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("playbackErrorWithResetKeepsWindowSequenceNumber")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .prepareSource(mediaSource, /* resetPosition= */ true, /* resetState= */ false)
+            .waitForPlaybackState(Player.STATE_READY)
+            .play()
+            .build();
+    HashSet<Long> reportedWindowSequenceNumbers = new HashSet<>();
+    AnalyticsListener listener =
+        new AnalyticsListener() {
+          @Override
+          public void onPlayerStateChanged(
+              EventTime eventTime, boolean playWhenReady, int playbackState) {
+            if (eventTime.mediaPeriodId != null) {
+              reportedWindowSequenceNumbers.add(eventTime.mediaPeriodId.windowSequenceNumber);
+            }
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .setAnalyticsListener(listener)
+            .build(context);
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(reportedWindowSequenceNumbers).hasSize(1);
+  }
+
   @Test
   public void testPlaybackErrorTwiceStillKeepsTimeline() throws Exception {
     final Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
index 40d4e468bd..f7edf62182 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
@@ -69,4 +69,11 @@ DashChunkSource createDashChunkSource(
    * @param newManifest The new manifest.
    */
   void updateManifest(DashManifest newManifest, int periodIndex);
+
+  /**
+   * Updates the track selection.
+   *
+   * @param trackSelection The new track selection instance. Must be equivalent to the previous one.
+   */
+  void updateTrackSelection(TrackSelection trackSelection);
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index b34b677d45..5daa1a8fd5 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -406,17 +406,27 @@ private void selectNewStreams(
       int[] streamIndexToTrackGroupIndex) {
     // Create newly selected primary and event streams.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
+      TrackSelection selection = selections[i];
+      if (selection == null) {
+        continue;
+      }
+      if (streams[i] == null) {
+        // Create new stream for selection.
         streamResetFlags[i] = true;
         int trackGroupIndex = streamIndexToTrackGroupIndex[i];
         TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
         if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_PRIMARY) {
-          streams[i] = buildSampleStream(trackGroupInfo, selections[i], positionUs);
+          streams[i] = buildSampleStream(trackGroupInfo, selection, positionUs);
         } else if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_MANIFEST_EVENTS) {
           EventStream eventStream = eventStreams.get(trackGroupInfo.eventStreamGroupIndex);
-          Format format = selections[i].getTrackGroup().getFormat(0);
+          Format format = selection.getTrackGroup().getFormat(0);
           streams[i] = new EventSampleStream(eventStream, format, manifest.dynamic);
         }
+      } else if (streams[i] instanceof ChunkSampleStream) {
+        // Update selection in existing stream.
+        @SuppressWarnings("unchecked")
+        ChunkSampleStream<DashChunkSource> stream = (ChunkSampleStream<DashChunkSource>) streams[i];
+        stream.getChunkSource().updateTrackSelection(selection);
       }
     }
     // Create newly selected embedded streams from the corresponding primary stream. Note that this
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 2de81a2535..bcf0a1766a 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -111,7 +111,6 @@ public DashChunkSource createDashChunkSource(
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int[] adaptationSetIndices;
-  private final TrackSelection trackSelection;
   private final int trackType;
   private final DataSource dataSource;
   private final long elapsedRealtimeOffsetMs;
@@ -120,6 +119,7 @@ public DashChunkSource createDashChunkSource(
 
   protected final RepresentationHolder[] representationHolders;
 
+  private TrackSelection trackSelection;
   private DashManifest manifest;
   private int periodIndex;
   private IOException fatalError;
@@ -222,6 +222,11 @@ public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
     }
   }
 
+  @Override
+  public void updateTrackSelection(TrackSelection trackSelection) {
+    this.trackSelection = trackSelection;
+  }
+
   @Override
   public void maybeThrowError() throws IOException {
     if (fatalError != null) {
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 261c9b531c..ee5a5f0809 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -183,17 +183,15 @@ public TrackGroup getTrackGroup() {
   }
 
   /**
-   * Selects tracks for use.
+   * Sets the current track selection.
    *
-   * @param trackSelection The track selection.
+   * @param trackSelection The {@link TrackSelection}.
    */
-  public void selectTracks(TrackSelection trackSelection) {
+  public void setTrackSelection(TrackSelection trackSelection) {
     this.trackSelection = trackSelection;
   }
 
-  /**
-   * Returns the current track selection.
-   */
+  /** Returns the current {@link TrackSelection}. */
   public TrackSelection getTrackSelection() {
     return trackSelection;
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index c8c1b8f566..ff725ec6f7 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -306,14 +306,17 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     TrackSelection primaryTrackSelection = oldPrimaryTrackSelection;
     // Select new tracks.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
+      TrackSelection selection = selections[i];
+      if (selection == null) {
+        continue;
+      }
+      int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
+      if (trackGroupIndex == primaryTrackGroupIndex) {
+        primaryTrackSelection = selection;
+        chunkSource.setTrackSelection(selection);
+      }
+      if (streams[i] == null) {
         enabledTrackGroupCount++;
-        TrackSelection selection = selections[i];
-        int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
-        if (trackGroupIndex == primaryTrackGroupIndex) {
-          primaryTrackSelection = selection;
-          chunkSource.selectTracks(selection);
-        }
         streams[i] = new HlsSampleStream(this, trackGroupIndex);
         streamResetFlags[i] = true;
         if (trackGroupToSampleQueueIndex != null) {
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index 59e18195e2..22dfb04f13 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -74,10 +74,10 @@ public SsChunkSource createChunkSource(
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int streamElementIndex;
-  private final TrackSelection trackSelection;
   private final ChunkExtractorWrapper[] extractorWrappers;
   private final DataSource dataSource;
 
+  private TrackSelection trackSelection;
   private SsManifest manifest;
   private int currentManifestChunkOffset;
 
@@ -155,6 +155,11 @@ public void updateManifest(SsManifest newManifest) {
     manifest = newManifest;
   }
 
+  @Override
+  public void updateTrackSelection(TrackSelection trackSelection) {
+    this.trackSelection = trackSelection;
+  }
+
   // ChunkSource implementation.
 
   @Override
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
index b763a484b8..111393140e 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
@@ -55,4 +55,11 @@ SsChunkSource createChunkSource(
    * @param newManifest The new manifest.
    */
   void updateManifest(SsManifest newManifest);
+
+  /**
+   * Updates the track selection.
+   *
+   * @param trackSelection The new track selection instance. Must be equivalent to the previous one.
+   */
+  void updateTrackSelection(TrackSelection trackSelection);
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 286ec82ed6..d103358d37 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -131,6 +131,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
           stream.release();
           streams[i] = null;
         } else {
+          stream.getChunkSource().updateTrackSelection(selections[i]);
           sampleStreamsList.add(stream);
         }
       }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index d97a53bc4d..ec6e94e042 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -1156,6 +1156,9 @@ public ViewGroup getAdViewGroup() {
   // Internal methods.
 
   private boolean toggleControllerVisibility() {
+    if (!useController || player == null) {
+      return false;
+    }
     if (!controller.isVisible()) {
       maybeShowController(true);
     } else if (controllerHideOnTouch) {
@@ -1491,9 +1494,6 @@ public void onLayoutChange(
 
     @Override
     public boolean onSingleTapUp(MotionEvent e) {
-      if (!useController || player == null) {
-        return false;
-      }
       return toggleControllerVisibility();
     }
   }
