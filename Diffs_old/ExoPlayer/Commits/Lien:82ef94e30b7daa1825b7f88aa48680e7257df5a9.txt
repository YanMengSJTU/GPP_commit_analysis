diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 75baebabb0..5e6d8deb7c 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -130,8 +130,6 @@ public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
-      // TODO: Verify that the issue cannot occur on API levels 22 and 23, and tighten this block
-      // to execute on API level 21 only if confirmed.
       mediaCodecList = new MediaCodecListCompatV16();
       decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
       if (!decoderInfos.isEmpty()) {
@@ -158,15 +156,24 @@ public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
         if (isCodecUsableDecoder(codecInfo, codecName, secureDecodersExplicit)) {
           for (String supportedType : codecInfo.getSupportedTypes()) {
             if (supportedType.equalsIgnoreCase(mimeType)) {
-              CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
-              boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
-              if ((secureDecodersExplicit && key.secure == secure)
-                  || (!secureDecodersExplicit && !key.secure)) {
-                decoderInfos.add(new DecoderInfo(codecName, capabilities));
-              } else if (!secureDecodersExplicit && secure) {
-                decoderInfos.add(new DecoderInfo(codecName + ".secure", capabilities));
-                // It only makes sense to have one synthesized secure decoder, return immediately.
-                return decoderInfos;
+              try {
+                CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+                boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
+                if ((secureDecodersExplicit && key.secure == secure)
+                    || (!secureDecodersExplicit && !key.secure)) {
+                  decoderInfos.add(new DecoderInfo(codecName, capabilities));
+                } else if (!secureDecodersExplicit && secure) {
+                  decoderInfos.add(new DecoderInfo(codecName + ".secure", capabilities));
+                  // It only makes sense to have one synthesized secure decoder, return immediately.
+                  return decoderInfos;
+                }
+              } catch (Exception e) {
+                if (Util.SDK_INT <= 23 && !decoderInfos.isEmpty()) {
+                  // Suppress error querying secondary codec capabilities up to API level 23.
+                  Log.e(TAG, "Skipping codec " + codecName + " (failed to query capabilities)");
+                } else {
+                  throw e;
+                }
               }
             }
           }
