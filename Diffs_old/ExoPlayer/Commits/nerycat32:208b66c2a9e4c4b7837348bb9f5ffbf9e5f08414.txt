diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index d11255bfd1..ec0b5f52f1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -935,6 +935,9 @@ private void processOutputFormat() throws ExoPlaybackException {
     if (codecNeedsMonoChannelCountWorkaround) {
       format.setInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT, 1);
     }
+
+    if (this.format.bitdepth > 0)
+      format.setInteger(MediaFormat.BitDepthKey, this.format.bitdepth);
     onOutputFormatChanged(codec, format);
     codecCounters.outputFormatChangedCount++;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 7efc9a82c3..0b6b621ecf 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -147,6 +147,13 @@
   private int hashCode;
   private android.media.MediaFormat frameworkMediaFormat;
 
+  /**
+   * The bit depth of the track, or {@link #NO_VALUE} if unknown or not applicable.
+   */
+  public final int bitdepth;
+
+  public final static String BitDepthKey = "bitdepth";
+
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData) {
     return createVideoFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
@@ -164,8 +171,15 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int channelCount, int sampleRate,
       List<byte[]> initializationData, String language) {
-    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
+    return createAudioFormat(trackId, mimeType, NO_VALUE, bitrate, maxInputSize, durationUs,
+        channelCount, sampleRate, initializationData, language);
+  }
+
+  public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitdepth,
+      int bitrate, int maxInputSize, long durationUs, int channelCount, int sampleRate,
+      List<byte[]> initializationData, String language) {
+    return new MediaFormat(trackId, mimeType, bitdepth, bitrate, maxInputSize, durationUs, NO_VALUE,
+        NO_VALUE, NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
         initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
@@ -206,6 +220,17 @@ public static MediaFormat createId3Format() {
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
       int encoderDelay, int encoderPadding) {
+    this(trackId, mimeType, NO_VALUE, bitrate, maxInputSize, durationUs, width, height,
+        rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
+  }
+
+  /* package */ MediaFormat(String trackId, String mimeType, int bitdepth, int bitrate,
+      int maxInputSize, long durationUs, int width, int height, int rotationDegrees,
+      float pixelWidthHeightRatio, int channelCount, int sampleRate, String language,
+      long subsampleOffsetUs, List<byte[]> initializationData, boolean adaptive,
+      int maxWidth, int maxHeight, int encoderDelay, int encoderPadding) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -226,6 +251,7 @@ public static MediaFormat createId3Format() {
     this.maxHeight = maxHeight;
     this.encoderDelay = encoderDelay;
     this.encoderPadding = encoderPadding;
+    this.bitdepth = bitdepth;
   }
 
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
@@ -310,6 +336,7 @@ public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
       if (durationUs != C.UNKNOWN_TIME_US) {
         format.setLong(android.media.MediaFormat.KEY_DURATION, durationUs);
       }
+      maybeSetIntegerV16(format, BitDepthKey, bitdepth);
       frameworkMediaFormat = format;
     }
     return frameworkMediaFormat;
@@ -329,7 +356,7 @@ public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
 
   @Override
   public String toString() {
-    return "MediaFormat(" + trackId + ", " + mimeType + ", " + bitrate + ", " + maxInputSize
+    return "MediaFormat(" + trackId + ", " + mimeType + ", " + bitdepth + ", " + bitrate + ", " + maxInputSize
         + ", " + width + ", " + height + ", " + rotationDegrees + ", " + pixelWidthHeightRatio
         + ", " + channelCount + ", " + sampleRate + ", " + language + ", " + durationUs + ", "
         + adaptive + ", " + maxWidth + ", " + maxHeight + ", " + encoderDelay + ", "
@@ -342,6 +369,7 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (trackId == null ? 0 : trackId.hashCode());
       result = 31 * result + (mimeType == null ? 0 : mimeType.hashCode());
+      result = 31 * result + bitdepth;
       result = 31 * result + bitrate;
       result = 31 * result + maxInputSize;
       result = 31 * result + width;
@@ -377,7 +405,7 @@ public boolean equals(Object obj) {
     MediaFormat other = (MediaFormat) obj;
     if (adaptive != other.adaptive || bitrate != other.bitrate || maxInputSize != other.maxInputSize
         || durationUs != other.durationUs || width != other.width || height != other.height
-        || rotationDegrees != other.rotationDegrees
+        || bitdepth != other.bitdepth || rotationDegrees != other.rotationDegrees
         || pixelWidthHeightRatio != other.pixelWidthHeightRatio
         || maxWidth != other.maxWidth || maxHeight != other.maxHeight
         || encoderDelay != other.encoderDelay || encoderPadding != other.encoderPadding
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index e991f79c72..dd1ccfa49c 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -203,6 +203,9 @@ public InvalidAudioTrackTimestampException(String message) {
   private int channelConfig;
   private int encoding;
   private boolean passthrough;
+  private int channelCount;
+  private int configuredSpecifiedBufferSize;
+  private int pcmBitdepth;
   private int pcmFrameSize;
   private int bufferSize;
   private long bufferSizeUs;
@@ -228,6 +231,9 @@ public InvalidAudioTrackTimestampException(String message) {
   private int temporaryBufferOffset;
   private int bufferBytesRemaining;
 
+  ByteBuffer pcmConvertBuffer = null;
+  boolean usePCMConvertBuffer = false;
+
   /**
    * Creates an audio track with default audio capabilities (no encoded audio passthrough support).
    */
@@ -352,7 +358,8 @@ public void configure(MediaFormat format, boolean passthrough) {
    *     size inferred from the format.
    */
   public void configure(MediaFormat format, boolean passthrough, int specifiedBufferSize) {
-    int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
+    channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
+    configuredSpecifiedBufferSize = specifiedBufferSize;
     int channelConfig;
     switch (channelCount) {
       case 1:
@@ -386,21 +393,67 @@ public void configure(MediaFormat format, boolean passthrough, int specifiedBuff
     String mimeType = format.getString(MediaFormat.KEY_MIME);
     int encoding = passthrough ? getEncodingForMimeType(mimeType) : AudioFormat.ENCODING_PCM_16BIT;
     if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
-        && this.encoding == encoding) {
+            && this.encoding == encoding) {
       // We already have an audio track with the correct sample rate, encoding and channel config.
       return;
     }
 
     reset();
 
-    this.encoding = encoding;
+    this.pcmBitdepth = mimeType.equals(MimeTypes.AUDIO_RAW) &&
+        format.containsKey(com.google.android.exoplayer.MediaFormat.BitDepthKey)
+        ? format.getInteger(com.google.android.exoplayer.MediaFormat.BitDepthKey) : -1;
+    if (encoding == AudioFormat.ENCODING_PCM_16BIT && pcmBitdepth != -1) {
+
+      switch (pcmBitdepth) {
+
+        case 8:
+          if (audioCapabilities.supportsEncoding(AudioFormat.ENCODING_PCM_8BIT))
+            encoding = AudioFormat.ENCODING_PCM_8BIT;
+          break;
+        case 24:
+          /*  TODO - write 24 - 32bit float conversion for <= two channel only
+          if (Util.SDK_INT >= 21 && channelCount > 2)
+              && audioCapabilities.supportsEncoding(AudioFormat.ENCODING_PCM_FLOAT))
+            encoding = AudioFormat.ENCODING_PCM_FLOAT;*/
+          break;
+        case 32:
+          // must be 32bit float
+          if (Util.SDK_INT >= 21 && audioCapabilities.supportsEncoding(AudioFormat.ENCODING_PCM_FLOAT))
+            encoding = AudioFormat.ENCODING_PCM_FLOAT;
+        default:
+          // don't do anything for 16bit
+          break;
+      }
+    }
+
     this.passthrough = passthrough;
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
-    pcmFrameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
 
-    if (specifiedBufferSize != 0) {
-      bufferSize = specifiedBufferSize;
+    configureFrameAndBufferSizes(encoding);
+  }
+
+  private int getPCMBytesPerChannel(int encoding) {
+
+    switch (encoding) {
+
+      case AudioFormat.ENCODING_PCM_8BIT:
+        return 1; // 1 bytes per 8 bit sample
+      case AudioFormat.ENCODING_PCM_FLOAT:
+        return 4; // 4 bytes per 32 bit sample
+      default:
+        return 2; // 2 bytes per 16 bit sample
+    }
+  }
+
+  private void configureFrameAndBufferSizes(int encoding) {
+
+    this.encoding = encoding;
+    pcmFrameSize = getPCMBytesPerChannel(encoding) * channelCount; // PCM BPC * number of channels.
+
+    if (configuredSpecifiedBufferSize != 0) {
+      bufferSize = configuredSpecifiedBufferSize;
     } else if (passthrough) {
       // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
       // account. [Internal: b/25181305]
@@ -451,14 +504,7 @@ public int initialize(int sessionId) throws InitializationException {
     // initialization of the audio track to fail.
     releasingConditionVariable.block();
 
-    if (sessionId == SESSION_ID_NOT_SET) {
-      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
-          bufferSize, android.media.AudioTrack.MODE_STREAM);
-    } else {
-      // Re-attach to the same audio session.
-      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
-          bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
-    }
+    createAudioTrack(sessionId);
     checkAudioTrackInitialized();
 
     sessionId = audioTrack.getAudioSessionId();
@@ -487,6 +533,36 @@ public int initialize(int sessionId) throws InitializationException {
     return sessionId;
   }
 
+  private void createAudioTrack(int sessionId) throws IllegalArgumentException {
+
+    try {
+      if (sessionId == SESSION_ID_NOT_SET) {
+        audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
+                bufferSize, android.media.AudioTrack.MODE_STREAM);
+      } else {
+        // Re-attach to the same audio session.
+        audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
+                bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
+      }
+    }
+    catch (IllegalArgumentException e) {
+
+      switch(encoding) {
+
+        case AudioFormat.ENCODING_PCM_8BIT:
+        case AudioFormat.ENCODING_PCM_FLOAT:
+          // if we tried to create 8 or 32 bit tracks when they aren't supported
+          // reset to 16bit and try again
+          configureFrameAndBufferSizes(AudioFormat.ENCODING_PCM_16BIT);
+          createAudioTrack(sessionId);
+          break;
+        default:
+          throw e;
+      }
+
+    }
+  }
+
   /**
    * Returns the size of this {@link AudioTrack}'s buffer in bytes.
    * <p>
@@ -572,6 +648,15 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
 
     int result = 0;
     if (bufferBytesRemaining == 0) {
+
+      usePCMConvertBuffer = false;
+      if (shouldConvertPCMInput()) {
+        usePCMConvertBuffer = convertPCMInput(buffer, offset, size);
+        if (usePCMConvertBuffer) {
+          size = pcmConvertBuffer.position();
+          pcmConvertBuffer.position(0);
+        }
+      }
       // The previous buffer (if there was one) was fully written to the audio track. We're now
       // seeing a new buffer for the first time.
       bufferBytesRemaining = size;
@@ -623,6 +708,8 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
           temporaryBufferOffset += bytesWritten;
         }
       }
+    } else if (usePCMConvertBuffer) {
+      bytesWritten = writeNonBlockingV21(audioTrack, pcmConvertBuffer, bufferBytesRemaining);
     } else {
       bytesWritten = writeNonBlockingV21(audioTrack, buffer, bufferBytesRemaining);
     }
@@ -644,6 +731,61 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
     return result;
   }
 
+  private boolean shouldConvertPCMInput() {
+
+    return (encoding == AudioFormat.ENCODING_PCM_16BIT && (pcmBitdepth == 24 || pcmBitdepth == 8));
+        //||(Util.SDK_INT >= 21 && encoding == AudioFormat.ENCODING_PCM_FLOAT && pcmBitdepth == 24);
+  }
+
+  private boolean convertPCMInput(ByteBuffer buffer, int offset, int size) {
+
+    if (pcmBitdepth == 24 && size < 3)
+      return false;
+
+    // if we are upconverting to 32 bit from 24 bit increase the buffer by 1/3
+    // if we are upconverting to 16bit from 8 bit double the buffer
+    // else we are downconverting to 16 from 24 bit make the buffer 2/3
+    int getMinBufferSize = encoding == AudioFormat.ENCODING_PCM_FLOAT ? (buffer.capacity() * 4)/3
+                           : pcmBitdepth == 8 ? buffer.capacity() * 2 : (buffer.capacity() * 2)/3;
+    if (pcmConvertBuffer == null || pcmConvertBuffer.capacity() < getMinBufferSize) {
+      pcmConvertBuffer = ByteBuffer.allocateDirect(getMinBufferSize);
+    }
+    pcmConvertBuffer.position(0);
+
+    int endPosition = offset + size;
+    buffer.position(offset);
+
+    // these conversions are little endian to little endian
+    /*if (encoding == AudioFormat.ENCODING_PCM_FLOAT) {
+      // 24->32 bit
+    }
+    else*/
+    if (pcmBitdepth == 8) {
+      // 8->16 bit, 8bit is an unsigned byte from 0-255, get back to -128,128 and then upconvert
+      final byte empty = 0;
+      int byte8;
+      while (endPosition > offset) {
+
+        byte8 = ((int)buffer.get()) - 128;
+        pcmConvertBuffer.put(empty);
+        pcmConvertBuffer.put((byte)(byte8 & 0xff));
+        ++offset;
+      }
+    }
+    else {
+      // 24->16 bit, drop the lowest byte to downconvert
+      int offsetOrig24 = offset;
+      while (endPosition > offsetOrig24) {
+        buffer.position(offsetOrig24 + 1);
+        pcmConvertBuffer.put(buffer.get());
+        pcmConvertBuffer.put(buffer.get());
+        offsetOrig24 += 3;
+      }
+    }
+
+    return true;
+  }
+
   /**
    * Ensures that the last data passed to {@link #handleBuffer(ByteBuffer, int, int, long)} is
    * played out in full.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index eacb3199a5..77c59a3288 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -1301,13 +1301,13 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
           if (!parseMsAcmCodecPrivate(new ParsableByteArray(codecPrivate))) {
             throw new ParserException("Non-PCM MS/ACM is unsupported");
           }
-          if (audioBitDepth != 16) {
+          if (audioBitDepth != 16 && audioBitDepth != 24) {
             throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
           }
           break;
         case CODEC_ID_PCM_INT_LIT:
           mimeType = MimeTypes.AUDIO_RAW;
-          if (audioBitDepth != 16) {
+          if (audioBitDepth != 16 && audioBitDepth != 24) {
             throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
           }
           break;
@@ -1329,7 +1329,7 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       // TODO: Consider reading the name elements of the tracks and, if present, incorporating them
       // into the trackId passed when creating the formats.
       if (MimeTypes.isAudio(mimeType)) {
-        format = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
+        format = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType, audioBitDepth,
             MediaFormat.NO_VALUE, maxInputSize, durationUs, channelCount, sampleRate,
             initializationData, language);
       } else if (MimeTypes.isVideo(mimeType)) {
