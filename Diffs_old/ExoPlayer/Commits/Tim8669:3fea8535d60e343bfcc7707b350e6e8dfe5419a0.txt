diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
index 1afa7bcbed..0bfe3ccc14 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -17,9 +17,8 @@
 
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.util.extensions.Buffer;
-import com.google.android.exoplayer.util.extensions.Decoder;
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
+import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
 import java.nio.ByteBuffer;
 import java.util.List;
@@ -27,8 +26,8 @@
 /**
  * JNI wrapper for the libflac Flac decoder.
  */
-/* package */ final class FlacDecoder implements Decoder<InputBuffer, FlacOutputBuffer,
-    FlacDecoderException> {
+/* package */ final class FlacDecoder extends
+    SimpleDecoder<InputBuffer, FlacOutputBuffer, FlacDecoderException> {
 
   /**
    * Whether the underlying libflac library is available.
@@ -45,15 +44,20 @@
     IS_AVAILABLE = isAvailable;
   }
 
-  public final int maxFrameSize;
-
   private final int maxOutputBufferSize;
-
   private final long nativeDecoderContext;
 
-  private FlacDecoderException exception;
-
-  public FlacDecoder(List<byte[]> initializationData) throws FlacDecoderException {
+  /**
+   * Creates a Flac decoder.
+   *
+   * @param numInputBuffers The number of input buffers.
+   * @param numOutputBuffers The number of output buffers.
+   * @param initializationData Codec-specific initialization data.
+   * @throws FlacDecoderException Thrown if an exception occurs when initializing the decoder.
+   */
+  public FlacDecoder(int numInputBuffers, int numOutputBuffers, List<byte[]> initializationData)
+      throws FlacDecoderException {
+    super(new InputBuffer[numInputBuffers], new FlacOutputBuffer[numOutputBuffers]);
     if (initializationData.size() != 1) {
       throw new FlacDecoderException("Wrong number of initialization data");
     }
@@ -69,27 +73,31 @@ public FlacDecoder(List<byte[]> initializationData) throws FlacDecoderException
       throw new FlacDecoderException("Metadata decoding failed");
     }
 
-    maxFrameSize = flacGetMaxFrameSize(nativeDecoderContext);
+    setInitialInputBufferSize(flacGetMaxFrameSize(nativeDecoderContext));
     maxOutputBufferSize = flacGetMaxOutputBufferSize(nativeDecoderContext);
   }
 
   @Override
-  public InputBuffer createInputBuffer(int initialSize) {
-    return new InputBuffer(initialSize);
+  public InputBuffer createInputBuffer() {
+    return new InputBuffer();
+  }
+
+  @Override
+  public FlacOutputBuffer createOutputBuffer() {
+    return new FlacOutputBuffer(this);
   }
 
   @Override
-  public FlacOutputBuffer createOutputBuffer(
-      DecoderWrapper<InputBuffer, FlacOutputBuffer, FlacDecoderException> owner) {
-    return new FlacOutputBuffer(owner);
+  protected void releaseOutputBuffer(FlacOutputBuffer buffer) {
+    super.releaseOutputBuffer(buffer);
   }
 
   @Override
-  public boolean decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
+  public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
     outputBuffer.reset();
     if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      return true;
+      return null;
     }
     if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
       outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
@@ -101,23 +109,16 @@ public boolean decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
     int result = flacDecode(nativeDecoderContext, sampleHolder.data, sampleHolder.size,
         outputBuffer.data, outputBuffer.data.capacity());
     if (result < 0) {
-      exception = new FlacDecoderException("Frame decoding failed");
-      return false;
+      return new FlacDecoderException("Frame decoding failed");
     }
     outputBuffer.data.position(0);
     outputBuffer.data.limit(result);
-    return true;
-  }
-
-  @Override
-  public void maybeThrowException() throws FlacDecoderException {
-    if (exception != null) {
-      throw exception;
-    }
+    return null;
   }
 
   @Override
   public void release() {
+    super.release();
     flacClose(nativeDecoderContext);
   }
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
index 3e3c2a2e5d..26356d7020 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.ext.flac;
 
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.OutputBuffer;
 
 import java.nio.ByteBuffer;
@@ -25,11 +24,11 @@
  */
 public final class FlacOutputBuffer extends OutputBuffer {
 
-  private final DecoderWrapper<?, FlacOutputBuffer, ?> owner;
+  private final FlacDecoder owner;
 
   public ByteBuffer data;
 
-  /* package */ FlacOutputBuffer(DecoderWrapper<?, FlacOutputBuffer, ?> owner) {
+  /* package */ FlacOutputBuffer(FlacDecoder owner) {
     this.owner = owner;
   }
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index 1ef63335b2..59494d3f38 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -27,7 +27,6 @@
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.extensions.Buffer;
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
 
 import android.os.Handler;
@@ -84,7 +83,7 @@
   private final MediaFormatHolder formatHolder;
 
   private MediaFormat format;
-  private DecoderWrapper<InputBuffer, FlacOutputBuffer, FlacDecoderException> decoderWrapper;
+  private FlacDecoder decoder;
   private InputBuffer inputBuffer;
   private FlacOutputBuffer outputBuffer;
 
@@ -153,23 +152,20 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
     }
 
     // If we don't have a decoder yet, we need to instantiate one.
-    if (decoderWrapper == null) {
+    if (decoder == null) {
       // For flac, the format can contain only one entry in initializationData which is the flac
       // file header.
       List<byte[]> initializationData = format.initializationData;
       if (initializationData.size() < 1) {
         throw new ExoPlaybackException("Missing initialization data");
       }
-      FlacDecoder decoder;
       try {
-        decoder = new FlacDecoder(initializationData);
+        decoder = new FlacDecoder(NUM_BUFFERS, NUM_BUFFERS, initializationData);
       } catch (FlacDecoderException e) {
         notifyDecoderError(e);
         throw new ExoPlaybackException(e);
       }
-      decoderWrapper = new DecoderWrapper<>(decoder, new InputBuffer[NUM_BUFFERS],
-          new FlacOutputBuffer[NUM_BUFFERS], decoder.maxFrameSize);
-      decoderWrapper.start();
+      decoder.start();
       codecCounters.codecInitCount++;
     }
 
@@ -197,7 +193,7 @@ private void renderBuffer() throws FlacDecoderException, AudioTrack.Initializati
     }
 
     if (outputBuffer == null) {
-      outputBuffer = decoderWrapper.dequeueOutputBuffer();
+      outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
         return;
       }
@@ -245,7 +241,7 @@ private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoderWrapper.dequeueInputBuffer();
+      inputBuffer = decoder.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -261,7 +257,7 @@ private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
     }
     if (result == SampleSource.END_OF_STREAM) {
       inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      decoderWrapper.queueInputBuffer(inputBuffer);
+      decoder.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
       return false;
@@ -271,7 +267,7 @@ private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
       inputBuffer.setFlag(Buffer.FLAG_RESET);
     }
 
-    decoderWrapper.queueInputBuffer(inputBuffer);
+    decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
   }
@@ -282,7 +278,7 @@ private void flushDecoder() {
       outputBuffer.release();
       outputBuffer = null;
     }
-    decoderWrapper.flush();
+    decoder.flush();
     notifyDiscontinuityToDecoder = true;
   }
 
@@ -316,7 +312,7 @@ protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     outputStreamEnded = false;
     sourceIsReady = false;
-    if (decoderWrapper != null) {
+    if (decoder != null) {
       flushDecoder();
     }
   }
@@ -338,9 +334,9 @@ protected void onDisabled() throws ExoPlaybackException {
     format = null;
     audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
-      if (decoderWrapper != null) {
-        decoderWrapper.release();
-        decoderWrapper = null;
+      if (decoder != null) {
+        decoder.release();
+        decoder = null;
         codecCounters.codecReleaseCount++;
       }
       audioTrack.release();
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index 09cc309335..ef607c7c78 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -27,7 +27,6 @@
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.extensions.Buffer;
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
 
 import android.os.Handler;
@@ -85,7 +84,7 @@
   private final MediaFormatHolder formatHolder;
 
   private MediaFormat format;
-  private DecoderWrapper<InputBuffer, OpusOutputBuffer, OpusDecoderException> decoderWrapper;
+  private OpusDecoder decoder;
   private InputBuffer inputBuffer;
   private OpusOutputBuffer outputBuffer;
 
@@ -161,7 +160,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
     }
 
     // If we don't have a decoder yet, we need to instantiate one.
-    if (decoderWrapper == null) {
+    if (decoder == null) {
       // For opus, the format can contain upto 3 entries in initializationData in the following
       // exact order:
       // 1) Opus Header Information (required)
@@ -171,16 +170,14 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
       if (initializationData.size() < 1) {
         throw new ExoPlaybackException("Missing initialization data");
       }
-      OpusDecoder decoder;
       try {
-        decoder = new OpusDecoder(initializationData);
+        decoder = new OpusDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
+            initializationData);
       } catch (OpusDecoderException e) {
         notifyDecoderError(e);
         throw new ExoPlaybackException(e);
       }
-      decoderWrapper = new DecoderWrapper<>(decoder, new InputBuffer[NUM_BUFFERS],
-          new OpusOutputBuffer[NUM_BUFFERS], INITIAL_INPUT_BUFFER_SIZE);
-      decoderWrapper.start();
+      decoder.start();
       codecCounters.codecInitCount++;
     }
 
@@ -208,7 +205,7 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
     }
 
     if (outputBuffer == null) {
-      outputBuffer = decoderWrapper.dequeueOutputBuffer();
+      outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
         return;
       }
@@ -256,7 +253,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoderWrapper.dequeueInputBuffer();
+      inputBuffer = decoder.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -272,7 +269,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
     }
     if (result == SampleSource.END_OF_STREAM) {
       inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      decoderWrapper.queueInputBuffer(inputBuffer);
+      decoder.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
       return false;
@@ -282,7 +279,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
       inputBuffer.setFlag(Buffer.FLAG_RESET);
     }
 
-    decoderWrapper.queueInputBuffer(inputBuffer);
+    decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
   }
@@ -293,7 +290,7 @@ private void flushDecoder() {
       outputBuffer.release();
       outputBuffer = null;
     }
-    decoderWrapper.flush();
+    decoder.flush();
     notifyDiscontinuityToDecoder = true;
   }
 
@@ -327,7 +324,7 @@ protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     outputStreamEnded = false;
     sourceIsReady = false;
-    if (decoderWrapper != null) {
+    if (decoder != null) {
       flushDecoder();
     }
   }
@@ -349,9 +346,9 @@ protected void onDisabled() throws ExoPlaybackException {
     format = null;
     audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
-      if (decoderWrapper != null) {
-        decoderWrapper.release();
-        decoderWrapper = null;
+      if (decoder != null) {
+        decoder.release();
+        decoder = null;
         codecCounters.codecReleaseCount++;
       }
       audioTrack.release();
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index 02759bff19..936444e573 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -17,9 +17,8 @@
 
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.util.extensions.Buffer;
-import com.google.android.exoplayer.util.extensions.Decoder;
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
+import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -28,8 +27,8 @@
 /**
  * JNI wrapper for the libopus Opus decoder.
  */
-/* package */ final class OpusDecoder implements Decoder<InputBuffer, OpusOutputBuffer,
-    OpusDecoderException> {
+/* package */ final class OpusDecoder extends
+    SimpleDecoder<InputBuffer, OpusOutputBuffer, OpusDecoderException> {
 
   /**
    * Whether the underlying libopus library is available.
@@ -66,17 +65,20 @@
 
   private int skipSamples;
 
-  private OpusDecoderException exception;
-
   /**
-   * Creates the Opus Decoder.
+   * Creates an Opus decoder.
    *
+   * @param numInputBuffers The number of input buffers.
+   * @param numOutputBuffers The number of output buffers.
+   * @param initialInputBufferSize The initial size of each input buffer.
    * @param initializationData Codec-specific initialization data. The first element must contain an
    *     opus header. Optionally, the list may contain two additional buffers, which must contain
    *     the encoder delay and seek pre roll values in nanoseconds, encoded as longs.
    * @throws OpusDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public OpusDecoder(List<byte[]> initializationData) throws OpusDecoderException {
+  public OpusDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
+      List<byte[]> initializationData) throws OpusDecoderException {
+    super(new InputBuffer[numInputBuffers], new OpusOutputBuffer[numOutputBuffers]);
     byte[] headerBytes = initializationData.get(0);
     if (headerBytes.length < 19) {
       throw new OpusDecoderException("Header size is too small.");
@@ -129,25 +131,30 @@ public OpusDecoder(List<byte[]> initializationData) throws OpusDecoderException
     if (nativeDecoderContext == 0) {
       throw new OpusDecoderException("Failed to initialize decoder");
     }
+    setInitialInputBufferSize(initialInputBufferSize);
+  }
+
+  @Override
+  public InputBuffer createInputBuffer() {
+    return new InputBuffer();
   }
 
   @Override
-  public InputBuffer createInputBuffer(int initialSize) {
-    return new InputBuffer(initialSize);
+  public OpusOutputBuffer createOutputBuffer() {
+    return new OpusOutputBuffer(this);
   }
 
   @Override
-  public OpusOutputBuffer createOutputBuffer(
-      DecoderWrapper<InputBuffer, OpusOutputBuffer, OpusDecoderException> owner) {
-    return new OpusOutputBuffer(owner);
+  protected void releaseOutputBuffer(OpusOutputBuffer buffer) {
+    super.releaseOutputBuffer(buffer);
   }
 
   @Override
-  public boolean decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
+  public OpusDecoderException decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
     outputBuffer.reset();
     if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      return true;
+      return null;
     }
     if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
       outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
@@ -165,15 +172,13 @@ public boolean decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
     int requiredOutputBufferSize =
         opusGetRequiredOutputBufferSize(sampleHolder.data, sampleHolder.size, SAMPLE_RATE);
     if (requiredOutputBufferSize < 0) {
-      exception = new OpusDecoderException("Error when computing required output buffer size.");
-      return false;
+      return new OpusDecoderException("Error when computing required output buffer size.");
     }
     outputBuffer.init(requiredOutputBufferSize);
     int result = opusDecode(nativeDecoderContext, sampleHolder.data, sampleHolder.size,
         outputBuffer.data, outputBuffer.data.capacity());
     if (result < 0) {
-      exception = new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
-      return false;
+      return new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
     }
     outputBuffer.data.position(0);
     outputBuffer.data.limit(result);
@@ -189,18 +194,12 @@ public boolean decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
         outputBuffer.data.position(skipBytes);
       }
     }
-    return true;
-  }
-
-  @Override
-  public void maybeThrowException() throws OpusDecoderException {
-    if (exception != null) {
-      throw exception;
-    }
+    return null;
   }
 
   @Override
   public void release() {
+    super.release();
     opusClose(nativeDecoderContext);
   }
 
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
index 8fa491bd82..3160d07710 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.ext.opus;
 
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.OutputBuffer;
 
 import java.nio.ByteBuffer;
@@ -25,11 +24,11 @@
  */
 public final class OpusOutputBuffer extends OutputBuffer {
 
-  private final DecoderWrapper<?, OpusOutputBuffer, ?> owner;
+  private final OpusDecoder owner;
 
   public ByteBuffer data;
 
-  /* package */ OpusOutputBuffer(DecoderWrapper<?, OpusOutputBuffer, ?> owner) {
+  /* package */ OpusOutputBuffer(OpusDecoder owner) {
     this.owner = owner;
   }
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index 1a037ff3c4..2dc9c6e6f0 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -25,7 +25,6 @@
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.extensions.Buffer;
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -124,7 +123,6 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
 
   private MediaFormat format;
   private VpxDecoder decoder;
-  private DecoderWrapper<VpxInputBuffer, VpxOutputBuffer, VpxDecoderException> decoderWrapper;
   private VpxInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
   private VpxOutputBuffer nextOutputBuffer;
@@ -214,11 +212,9 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
       if (decoder == null) {
         // If we don't have a decoder yet, we need to instantiate one.
         long startElapsedRealtimeMs = SystemClock.elapsedRealtime();
-        decoder = new VpxDecoder();
+        decoder = new VpxDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE);
         decoder.setOutputMode(outputMode);
-        decoderWrapper = new DecoderWrapper<>(decoder, new VpxInputBuffer[NUM_BUFFERS],
-            new VpxOutputBuffer[NUM_BUFFERS], INITIAL_INPUT_BUFFER_SIZE);
-        decoderWrapper.start();
+        decoder.start();
         notifyDecoderInitialized(startElapsedRealtimeMs, SystemClock.elapsedRealtime());
         codecCounters.codecInitCount++;
       }
@@ -243,7 +239,7 @@ private boolean processOutputBuffer(long positionUs)
         outputBuffer = nextOutputBuffer;
         nextOutputBuffer = null;
       } else {
-        outputBuffer = decoderWrapper.dequeueOutputBuffer();
+        outputBuffer = decoder.dequeueOutputBuffer();
       }
       if (outputBuffer == null) {
         return false;
@@ -251,7 +247,7 @@ private boolean processOutputBuffer(long positionUs)
     }
 
     if (nextOutputBuffer == null) {
-      nextOutputBuffer = decoderWrapper.dequeueOutputBuffer();
+      nextOutputBuffer = decoder.dequeueOutputBuffer();
     }
 
     if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
@@ -330,7 +326,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoderWrapper.dequeueInputBuffer();
+      inputBuffer = decoder.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -346,7 +342,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
     }
     if (result == SampleSource.END_OF_STREAM) {
       inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      decoderWrapper.queueInputBuffer(inputBuffer);
+      decoder.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
       return false;
@@ -354,7 +350,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
 
     inputBuffer.width = format.width;
     inputBuffer.height = format.height;
-    decoderWrapper.queueInputBuffer(inputBuffer);
+    decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
     return true;
   }
@@ -369,7 +365,7 @@ private void flushDecoder() {
       nextOutputBuffer.release();
       nextOutputBuffer = null;
     }
-    decoderWrapper.flush();
+    decoder.flush();
   }
 
   @Override
@@ -388,7 +384,7 @@ protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     outputStreamEnded = false;
     renderedFirstFrame = false;
-    if (decoderWrapper != null) {
+    if (decoder != null) {
       flushDecoder();
     }
   }
@@ -410,9 +406,9 @@ protected void onDisabled() throws ExoPlaybackException {
     outputBuffer = null;
     format = null;
     try {
-      if (decoderWrapper != null) {
-        decoderWrapper.release();
-        decoderWrapper = null;
+      if (decoder != null) {
+        decoder.release();
+        decoder = null;
         codecCounters.codecReleaseCount++;
       }
     } finally {
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index eeb02212a2..1e0e8d5be7 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -17,16 +17,15 @@
 
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.util.extensions.Buffer;
-import com.google.android.exoplayer.util.extensions.Decoder;
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
 import java.nio.ByteBuffer;
 
 /**
  * JNI wrapper for the libvpx VP9 decoder.
  */
-/* package */ final class VpxDecoder implements Decoder<VpxInputBuffer, VpxOutputBuffer,
-    VpxDecoderException> {
+/* package */ final class VpxDecoder extends
+    SimpleDecoder<VpxInputBuffer, VpxOutputBuffer, VpxDecoderException> {
 
   public static final int OUTPUT_MODE_UNKNOWN = -1;
   public static final int OUTPUT_MODE_YUV = 0;
@@ -56,18 +55,23 @@
   private final long vpxDecContext;
 
   private volatile int outputMode;
-  private VpxDecoderException exception;
 
   /**
-   * Creates the VP9 Decoder.
+   * Creates a VP9 decoder.
    *
-   * @throws VpxDecoderException Thrown if the decoder fails to initialize.
+   * @param numInputBuffers The number of input buffers.
+   * @param numOutputBuffers The number of output buffers.
+   * @param initialInputBufferSize The initial size of each input buffer.
+   * @throws VpxDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public VpxDecoder() throws VpxDecoderException {
+  public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize)
+      throws VpxDecoderException {
+    super(new VpxInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
     vpxDecContext = vpxInit();
     if (vpxDecContext == 0) {
       throw new VpxDecoderException("Failed to initialize decoder");
     }
+    setInitialInputBufferSize(initialInputBufferSize);
   }
 
   /**
@@ -81,46 +85,43 @@ public void setOutputMode(int outputMode) {
   }
 
   @Override
-  public VpxInputBuffer createInputBuffer(int initialSize) {
-    return new VpxInputBuffer(initialSize);
+  protected VpxInputBuffer createInputBuffer() {
+    return new VpxInputBuffer();
   }
 
   @Override
-  public VpxOutputBuffer createOutputBuffer(
-      DecoderWrapper<VpxInputBuffer, VpxOutputBuffer, VpxDecoderException> owner) {
-    return new VpxOutputBuffer(owner);
+  protected VpxOutputBuffer createOutputBuffer() {
+    return new VpxOutputBuffer(this);
   }
 
   @Override
-  public boolean decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer) {
+  protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
+    super.releaseOutputBuffer(buffer);
+  }
+
+  @Override
+  protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer) {
     outputBuffer.reset();
     if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      return true;
+      return null;
     }
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
     sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
     if (vpxDecode(vpxDecContext, sampleHolder.data, sampleHolder.size) != 0) {
-      exception = new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
-      return false;
+      return new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
     }
     outputBuffer.mode = outputMode;
     if (vpxGetFrame(vpxDecContext, outputBuffer) != 0) {
       outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
     }
-    return true;
-  }
-
-  @Override
-  public void maybeThrowException() throws VpxDecoderException {
-    if (exception != null) {
-      throw exception;
-    }
+    return null;
   }
 
   @Override
   public void release() {
+    super.release();
     vpxClose(vpxDecContext);
   }
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
index e8f04940ea..f237d0d8e0 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
@@ -25,8 +25,4 @@
   public int width;
   public int height;
 
-  public VpxInputBuffer(int initialSize) {
-    super(initialSize);
-  }
-
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
index 21774db701..709e504139 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
-import com.google.android.exoplayer.util.extensions.DecoderWrapper;
 import com.google.android.exoplayer.util.extensions.OutputBuffer;
 
 import java.nio.ByteBuffer;
@@ -29,7 +28,7 @@
   public static final int COLORSPACE_BT601 = 1;
   public static final int COLORSPACE_BT709 = 2;
 
-  private final DecoderWrapper<?, VpxOutputBuffer, ?> owner;
+  private final VpxDecoder owner;
 
   public int mode;
   /**
@@ -45,7 +44,7 @@
   public int[] yuvStrides;
   public int colorspace;
 
-  /* package */ VpxOutputBuffer(DecoderWrapper<?, VpxOutputBuffer, ?> owner) {
+  /* package */ VpxOutputBuffer(VpxDecoder owner) {
     this.owner = owner;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
index 29a64769b4..55f7727ab3 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
@@ -16,44 +16,47 @@
 package com.google.android.exoplayer.util.extensions;
 
 /**
- * Decoder interface for extensions that use a blocking/synchronous decoder. Implementations can be
- * wrapped by {@link DecoderWrapper}, which exposes a higher level MediaCodec-like interface.
+ * A media decoder.
+ *
+ * @param <I> The type of buffer input to the decoder.
+ * @param <O> The type of buffer output from the decoder.
+ * @param <E> The type of exception thrown from the decoder.
  */
-public interface Decoder<I extends InputBuffer, O extends OutputBuffer, E extends Exception> {
+public interface Decoder<I, O, E extends Exception> {
 
   /**
-   * Returns a new decoder input buffer for use by a {@link DecoderWrapper}.
+   * Dequeues the next input buffer to be filled and queued to the decoder.
    *
-   * @return A new decoder input buffer.
+   * @return The input buffer, or null if an input buffer isn't available.
+   * @throws E If a decoder error has occurred.
    */
-  I createInputBuffer(int size);
+  I dequeueInputBuffer() throws E;
 
   /**
-   * Returns a new decoder output buffer for use by a {@link DecoderWrapper}.
+   * Queues an input buffer to the decoder.
+   *
+   * @param inputBuffer The input buffer.
+   * @throws E If a decoder error has occurred.
    */
-  O createOutputBuffer(DecoderWrapper<I, O, E> owner);
+  void queueInputBuffer(I inputBuffer) throws E;
 
   /**
-   * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
+   * Dequeues the next output buffer from the decoder.
    *
-   * @param inputBuffer The buffer to decode.
-   * @param outputBuffer The output buffer to store decoded data. If the flag
-   *     {@link Buffer#FLAG_DECODE_ONLY} is set after this method returns, any output should not be
-   *     presented.
-   * @return True if decoding was successful. False if an exception was thrown, in which case
-   *     {@link #maybeThrowException()} will throw the error.
+   * @return The output buffer, or null if an output buffer isn't available.
+   * @throws E If a decoder error has occurred.
    */
-  boolean decode(I inputBuffer, O outputBuffer);
+  O dequeueOutputBuffer() throws E;
 
   /**
-   * Throws any exception that was previously thrown by the underlying decoder.
-   *
-   * @throws E Thrown if the underlying decoder encountered an error.
+   * Flushes input/output buffers that have not been dequeued yet and returns ownership of any
+   * dequeued input buffer to the decoder. Flushes any pending output currently in the decoder. The
+   * caller is still responsible for releasing any dequeued output buffers.
    */
-  void maybeThrowException() throws E;
+  void flush();
 
   /**
-   * Releases the decoder and any associated resources.
+   * Releases the decoder. Must be called when the decoder is no longer needed.
    */
   void release();
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
index 2df85e56e6..917e90bad7 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
@@ -24,9 +24,8 @@
 
   public final SampleHolder sampleHolder;
 
-  public InputBuffer(int initialSize) {
+  public InputBuffer() {
     sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
-    sampleHolder.ensureSpaceForWrite(initialSize);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/DecoderWrapper.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
similarity index 68%
rename from library/src/main/java/com/google/android/exoplayer/util/extensions/DecoderWrapper.java
rename to library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
index 0418339451..c6fe12eb24 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/DecoderWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
@@ -20,13 +20,13 @@
 import java.util.LinkedList;
 
 /**
- * Wraps a {@link Decoder}, exposing a higher level decoder interface.
+ * Base class for {@link Decoder}s that use their own decode thread.
  */
-public final class DecoderWrapper<I extends InputBuffer, O extends OutputBuffer,
-    E extends Exception> extends Thread {
+public abstract class SimpleDecoder<I extends InputBuffer, O extends OutputBuffer,
+    E extends Exception> extends Thread implements Decoder<I, O, E> {
 
   /**
-   * Listener for {@link DecoderWrapper} events.
+   * Listener for {@link SimpleDecoder} events.
    */
   public interface EventListener<E> {
 
@@ -39,50 +39,59 @@
 
   }
 
-  private final Decoder<I, O, E> decoder;
   private final Object lock;
-
   private final LinkedList<I> queuedInputBuffers;
   private final LinkedList<O> queuedOutputBuffers;
   private final I[] availableInputBuffers;
   private final O[] availableOutputBuffers;
+
   private int availableInputBufferCount;
   private int availableOutputBufferCount;
   private I dequeuedInputBuffer;
 
+  private E exception;
   private boolean flushDecodedOutputBuffer;
   private boolean released;
 
   /**
-   * Creates a new wrapper around {@code decoder}, using the specified {@code inputBuffers} and
-   * {@code outputBuffers}. The arrays will be populated using buffers created by the decoder.
-   *
-   * @param decoder The decoder to wrap.
    * @param inputBuffers An array of nulls that will be used to store references to input buffers.
    * @param outputBuffers An array of nulls that will be used to store references to output buffers.
-   * @param initialInputBufferSize The initial size for each input buffer, in bytes.
    */
-  public DecoderWrapper(Decoder<I, O, E> decoder, I[] inputBuffers, O[] outputBuffers,
-      int initialInputBufferSize) {
-    this.decoder = decoder;
+  protected SimpleDecoder(I[] inputBuffers, O[] outputBuffers) {
     lock = new Object();
     queuedInputBuffers = new LinkedList<>();
     queuedOutputBuffers = new LinkedList<>();
     availableInputBuffers = inputBuffers;
     availableInputBufferCount = inputBuffers.length;
     for (int i = 0; i < availableInputBufferCount; i++) {
-      availableInputBuffers[i] = decoder.createInputBuffer(initialInputBufferSize);
+      availableInputBuffers[i] = createInputBuffer();
     }
     availableOutputBuffers = outputBuffers;
     availableOutputBufferCount = outputBuffers.length;
     for (int i = 0; i < availableOutputBufferCount; i++) {
-      availableOutputBuffers[i] = decoder.createOutputBuffer(this);
+      availableOutputBuffers[i] = createOutputBuffer();
+    }
+  }
+
+  /**
+   * Sets the initial size of each input buffer.
+   * <p>
+   * This method should only be called before the decoder is used (i.e. before the first call to
+   * {@link #dequeueInputBuffer()}.
+   *
+   * @param size The required input buffer size.
+   */
+  protected final void setInitialInputBufferSize(int size) {
+    Assertions.checkState(availableInputBufferCount == availableInputBuffers.length);
+    for (int i = 0; i < availableInputBuffers.length; i++) {
+      availableInputBuffers[i].sampleHolder.ensureSpaceForWrite(size);
     }
   }
 
-  public I dequeueInputBuffer() throws E {
+  @Override
+  public final I dequeueInputBuffer() throws E {
     synchronized (lock) {
-      decoder.maybeThrowException();
+      maybeThrowException();
       Assertions.checkState(dequeuedInputBuffer == null);
       if (availableInputBufferCount == 0) {
         return null;
@@ -94,9 +103,10 @@ public I dequeueInputBuffer() throws E {
     }
   }
 
-  public void queueInputBuffer(I inputBuffer) throws E {
+  @Override
+  public final void queueInputBuffer(I inputBuffer) throws E {
     synchronized (lock) {
-      decoder.maybeThrowException();
+      maybeThrowException();
       Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
       queuedInputBuffers.addLast(inputBuffer);
       maybeNotifyDecodeLoop();
@@ -104,9 +114,10 @@ public void queueInputBuffer(I inputBuffer) throws E {
     }
   }
 
-  public O dequeueOutputBuffer() throws E {
+  @Override
+  public final O dequeueOutputBuffer() throws E {
     synchronized (lock) {
-      decoder.maybeThrowException();
+      maybeThrowException();
       if (queuedOutputBuffers.isEmpty()) {
         return null;
       }
@@ -114,19 +125,20 @@ public O dequeueOutputBuffer() throws E {
     }
   }
 
-  public void releaseOutputBuffer(O outputBuffer) {
+  /**
+   * Releases an output buffer back to the decoder.
+   *
+   * @param outputBuffer The output buffer being released.
+   */
+  protected void releaseOutputBuffer(O outputBuffer) {
     synchronized (lock) {
       availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
       maybeNotifyDecodeLoop();
     }
   }
 
-  /**
-   * Flushes input/output buffers that have not been dequeued yet and returns ownership of any
-   * dequeued input buffer to the decoder. Flushes any pending output currently in the decoder. The
-   * caller is still responsible for releasing any dequeued output buffers.
-   */
-  public void flush() {
+  @Override
+  public final void flush() {
     synchronized (lock) {
       flushDecodedOutputBuffer = true;
       if (dequeuedInputBuffer != null) {
@@ -142,6 +154,7 @@ public void flush() {
     }
   }
 
+  @Override
   public void release() {
     synchronized (lock) {
       released = true;
@@ -154,6 +167,17 @@ public void release() {
     }
   }
 
+  /**
+   * Throws a decode exception, if there is one.
+   *
+   * @throws E The decode exception.
+   */
+  private void maybeThrowException() throws E {
+    if (exception != null) {
+      throw exception;
+    }
+  }
+
   /**
    * Notifies the decode loop if there exists a queued input buffer and an available output buffer
    * to decode into.
@@ -167,22 +191,18 @@ private void maybeNotifyDecodeLoop() {
   }
 
   @Override
-  public void run() {
+  public final void run() {
     try {
-      while (decodeBuffer(decoder)) {
+      while (decode()) {
         // Do nothing.
       }
     } catch (InterruptedException e) {
       // Not expected.
       throw new IllegalStateException(e);
-    } finally {
-      if (decoder != null) {
-        decoder.release();
-      }
     }
   }
 
-  private boolean decodeBuffer(Decoder<I, O, E> decoder) throws InterruptedException {
+  private boolean decode() throws InterruptedException {
     I inputBuffer;
     O outputBuffer;
 
@@ -199,7 +219,8 @@ private boolean decodeBuffer(Decoder<I, O, E> decoder) throws InterruptedExcepti
       flushDecodedOutputBuffer = false;
     }
 
-    if (!decoder.decode(inputBuffer, outputBuffer)) {
+    exception = decode(inputBuffer, outputBuffer);
+    if (exception != null) {
       // Memory barrier to ensure that the decoder exception is visible from the playback thread.
       synchronized (lock) {}
       return false;
@@ -226,4 +247,25 @@ private boolean canDecodeBuffer() {
     return !queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0;
   }
 
+  /**
+   * Creates a new input buffer.
+   */
+  protected abstract I createInputBuffer();
+
+  /**
+   * Creates a new output buffer.
+   */
+  protected abstract O createOutputBuffer();
+
+  /**
+   * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
+   *
+   * @param inputBuffer The buffer to decode.
+   * @param outputBuffer The output buffer to store decoded data. If the flag
+   *     {@link Buffer#FLAG_DECODE_ONLY} is set after this method returns, any output should not be
+   *     presented.
+   * @return A decode exception if an error occurred, or null if the decode was successful.
+   */
+  protected abstract E decode(I inputBuffer, O outputBuffer);
+
 }
