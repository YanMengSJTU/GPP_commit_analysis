diff --git a/core_settings.gradle b/core_settings.gradle
index c4914e3040..fbbcf7e9b3 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -22,6 +22,7 @@ include modulePrefix + 'library-core'
 include modulePrefix + 'library-dash'
 include modulePrefix + 'library-hls'
 include modulePrefix + 'library-smoothstreaming'
+include modulePrefix + 'library-offline'
 include modulePrefix + 'library-ui'
 include modulePrefix + 'testutils'
 include modulePrefix + 'testutils-robolectric'
@@ -36,12 +37,16 @@ include modulePrefix + 'extension-opus'
 include modulePrefix + 'extension-vp9'
 include modulePrefix + 'extension-rtmp'
 include modulePrefix + 'extension-leanback'
+include modulePrefix + 'extension-jobdispatcher'
+
+
 
 project(modulePrefix + 'library').projectDir = new File(rootDir, 'library/all')
 project(modulePrefix + 'library-core').projectDir = new File(rootDir, 'library/core')
 project(modulePrefix + 'library-dash').projectDir = new File(rootDir, 'library/dash')
 project(modulePrefix + 'library-hls').projectDir = new File(rootDir, 'library/hls')
 project(modulePrefix + 'library-smoothstreaming').projectDir = new File(rootDir, 'library/smoothstreaming')
+project(modulePrefix + 'library-offline').projectDir = new File(rootDir, 'library/offline')
 project(modulePrefix + 'library-ui').projectDir = new File(rootDir, 'library/ui')
 project(modulePrefix + 'testutils').projectDir = new File(rootDir, 'testutils')
 project(modulePrefix + 'testutils-robolectric').projectDir = new File(rootDir, 'testutils_robolectric')
@@ -56,6 +61,8 @@ project(modulePrefix + 'extension-opus').projectDir = new File(rootDir, 'extensi
 project(modulePrefix + 'extension-vp9').projectDir = new File(rootDir, 'extensions/vp9')
 project(modulePrefix + 'extension-rtmp').projectDir = new File(rootDir, 'extensions/rtmp')
 project(modulePrefix + 'extension-leanback').projectDir = new File(rootDir, 'extensions/leanback')
+project(modulePrefix + 'extension-jobdispatcher').projectDir = new File(rootDir, 'extensions/jobdispatcher')
+
 
 if (gradle.ext.has('exoplayerIncludeCronetExtension')
         && gradle.ext.exoplayerIncludeCronetExtension) {
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index ce0992eb7a..2fcaab80fe 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -63,6 +63,8 @@ dependencies {
     implementation project(modulePrefix + 'library-hls')
     implementation project(modulePrefix + 'library-smoothstreaming')
     implementation project(modulePrefix + 'library-ui')
+    implementation project(modulePrefix + 'library-offline')
+
     withExtensionsImplementation project(path: modulePrefix + 'extension-ffmpeg')
     withExtensionsImplementation project(path: modulePrefix + 'extension-flac')
     withExtensionsImplementation project(path: modulePrefix + 'extension-ima')
diff --git a/library/offline/build.gradle b/library/offline/build.gradle
new file mode 100644
index 0000000000..4a7672d712
--- /dev/null
+++ b/library/offline/build.gradle
@@ -0,0 +1,79 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    buildTypes {
+        // Re-enable test coverage when the following issue is fixed:
+        // https://issuetracker.google.com/issues/37019591
+        // debug {
+        //    testCoverageEnabled = true
+        // }
+    }
+}
+
+ext {
+    rxJavaVersion = '2.1.0'
+    rxAndroidVersion = '2.0.1'
+    javadocTitle = 'Offline module'
+
+
+}
+
+dependencies {
+
+
+    compile project(modulePrefix + 'library-core')
+    compile project(modulePrefix + 'library-dash')
+    compile project(modulePrefix + 'library-hls')
+//    compile project(modulePrefix + 'library-smoothstreaming')
+//    compile project(modulePrefix + 'library-ui')
+//    withExtensionsCompile project(path: modulePrefix + 'extension-ffmpeg')
+//    withExtensionsCompile project(path: modulePrefix + 'extension-flac')
+//    withExtensionsCompile project(path: modulePrefix + 'extension-ima')
+//    withExtensionsCompile project(path: modulePrefix + 'extension-opus')
+//    withExtensionsCompile project(path: modulePrefix + 'extension-vp9')
+//    withExtensionsCompile project(path: modulePrefix + 'extension-rtmp')
+
+    testCompile 'junit:junit:' + junitVersion
+    testCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile 'org.robolectric:robolectric:' + robolectricVersion
+
+    // RxJava
+    compile "io.reactivex.rxjava2:rxjava:$rxJavaVersion"
+    compile "io.reactivex.rxjava2:rxandroid:$rxAndroidVersion"
+
+    testCompile 'junit:junit:4.12'
+}
+
+
+apply from: '../../javadoc_library.gradle'
+
+ext {
+    releaseArtifact = 'exoplayer-offline'
+    releaseDescription = 'The ExoPlayer library DASH module.'
+}
+apply from: '../../publish.gradle'
+
+
+
diff --git a/library/offline/src/androidTest/AndroidManifest.xml b/library/offline/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..1fdb8dfabb
--- /dev/null
+++ b/library/offline/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          xmlns:tools="http://schemas.android.com/tools"
+          package="com.google.android.exoplayer2.offline.test">
+
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
+
+    <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="27"/>
+
+    <application android:debuggable="true"
+                 android:allowBackup="false"
+                 tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
+        <uses-library android:name="android.test.runner"/>
+
+        <activity android:name="com.google.android.exoplayer2.testutil.HostActivity"
+                  android:configChanges="keyboardHidden|orientation|screenSize"
+                  android:label="ExoPlayerTest"/>
+
+    </application>
+
+    <instrumentation
+        android:targetPackage="com.google.android.exoplayer2.offline"
+        android:name="android.test.InstrumentationTestRunner"/>
+
+</manifest>
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/DashOfflineUtilTest.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/DashOfflineUtilTest.java
new file mode 100644
index 0000000000..91737f504e
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/DashOfflineUtilTest.java
@@ -0,0 +1,86 @@
+package com.google.android.exoplayer2.offline;
+
+import android.content.Context;
+import android.test.InstrumentationTestCase;
+
+import com.google.android.exoplayer2.offline.models.DownloadInfo;
+import com.google.android.exoplayer2.util.Util;
+
+import org.json.JSONObject;
+
+import java.io.File;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+
+public class DashOfflineUtilTest extends InstrumentationTestCase {
+
+    private File baseCacheDir;
+    private byte[] _16ByteEncryptionKey = {
+            0, 1, 2, 3,
+            4, 5, 6, 7,
+            8, 9, 10, 11,
+            12, 13, 14, 15
+    };
+
+    private JSONObject sampleJsonObject;
+    private String sampleJsonKey;
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        Context context = getInstrumentation().getTargetContext();
+        File externalCacheDir = context.getExternalCacheDir();
+        File testFolder = new File(externalCacheDir, "tests");
+
+        if (!testFolder.exists()) {
+            testFolder.mkdir();
+        }
+
+        baseCacheDir = testFolder; //Util.createTempDirectory(context, "DemoTest");
+
+        sampleJsonKey = "Hello";
+
+        sampleJsonObject = new JSONObject();
+        sampleJsonObject.put(sampleJsonKey, "world");
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        Util.recursiveDelete(baseCacheDir);
+        super.tearDown();
+    }
+
+    /**
+     * Downloads a sample video and checks for the following
+     * <p>
+     * 1. Download percent is 100
+     * 2. Downloaded cache folder has files
+     * 3. Cumulative file size in the download folder matches with downloaded info.
+     */
+    public void testDownloadAsync() throws InterruptedException {
+
+        String videoId = "123";
+        DownloadInfo downloadInfo = TestUtil.downloadSampleDashVideo(baseCacheDir, videoId, new String(_16ByteEncryptionKey));
+
+        // verify that 'Download percent is 100 '
+        assertEquals(100, (int) downloadInfo.downloadPercent);
+
+        File videoCacheFolder = new File(baseCacheDir, videoId);
+
+        long folderSize = TestUtil.folderSize(videoCacheFolder, "exo", "0.0");
+
+        boolean hasCache = videoCacheFolder.list().length > 0;
+
+        // verify that 'Downloaded cache folder has files'
+        assertTrue("No cache exists ", hasCache);
+
+        // verify that 'Cumulative file size in the download folder matches with downloaded info.'
+        assertEquals(folderSize, downloadInfo.downloadBytes);
+
+    }
+
+
+}
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/FileUtilTest.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/FileUtilTest.java
new file mode 100644
index 0000000000..ffb94e2cbc
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/FileUtilTest.java
@@ -0,0 +1,75 @@
+package com.google.android.exoplayer2.offline;
+
+import android.content.Context;
+import android.test.InstrumentationTestCase;
+
+import com.google.android.exoplayer2.util.Util;
+
+import org.json.JSONObject;
+
+import java.io.File;
+import java.util.Arrays;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+
+public class FileUtilTest extends InstrumentationTestCase {
+
+    private File cacheDir;
+    private byte[] _16ByteEncryptionKey = {
+            0, 1, 2, 3,
+            4, 5, 6, 7,
+            8, 9, 10, 11,
+            12, 13, 14, 15
+    };
+
+    private JSONObject sampleJsonObject;
+    private String sampleJsonKey;
+
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        Context context = getInstrumentation().getTargetContext();
+        cacheDir = Util.createTempDirectory(context, "DemoTest");
+
+        sampleJsonKey = "Hello";
+
+        sampleJsonObject = new JSONObject();
+        sampleJsonObject.put(sampleJsonKey, "world");
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        Util.recursiveDelete(cacheDir);
+        super.tearDown();
+    }
+
+    public void testJsonReadWriteEncryption() throws Exception {
+
+        FileUtil.writeEncryptedJson(cacheDir, "testJsonReadWriteEncryption", _16ByteEncryptionKey, sampleJsonObject);
+        JSONObject outputObject = FileUtil.readEncryptedJson(cacheDir, "testJsonReadWriteEncryption", _16ByteEncryptionKey);
+
+        assertEquals(sampleJsonObject.length(), outputObject.length());
+        assertEquals(sampleJsonObject.getString(sampleJsonKey), outputObject.getString(sampleJsonKey));
+    }
+
+    public void testJsonReadWrite() throws Exception {
+
+        FileUtil.writeJson(cacheDir, "testJsonReadWrite", sampleJsonObject);
+        JSONObject outputObject = FileUtil.readJson(cacheDir, "testJsonReadWrite");
+
+        assertEquals(sampleJsonObject.length(), outputObject.length());
+        assertEquals(sampleJsonObject.getString(sampleJsonKey), outputObject.getString(sampleJsonKey));
+    }
+
+    public void testByteReadWrite() throws Exception {
+
+        FileUtil.writeBytes(cacheDir, "testByteReadWrite", _16ByteEncryptionKey);
+        byte[] readBytes = FileUtil.readBytes(cacheDir, "testByteReadWrite");
+
+        assertTrue(Arrays.equals(_16ByteEncryptionKey, readBytes));
+    }
+}
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/HlsOfflineUtilTest.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/HlsOfflineUtilTest.java
new file mode 100644
index 0000000000..583d5ed426
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/HlsOfflineUtilTest.java
@@ -0,0 +1,86 @@
+package com.google.android.exoplayer2.offline;
+
+import android.content.Context;
+import android.test.InstrumentationTestCase;
+
+import com.google.android.exoplayer2.offline.models.DownloadInfo;
+import com.google.android.exoplayer2.util.Util;
+
+import org.json.JSONObject;
+
+import java.io.File;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+
+public class HlsOfflineUtilTest extends InstrumentationTestCase {
+
+    private File baseCacheDir;
+    private byte[] _16ByteEncryptionKey = {
+            0, 1, 2, 3,
+            4, 5, 6, 7,
+            8, 9, 10, 11,
+            12, 13, 14, 15
+    };
+
+    private JSONObject sampleJsonObject;
+    private String sampleJsonKey;
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        Context context = getInstrumentation().getTargetContext();
+        File externalCacheDir = context.getExternalCacheDir();
+        File testFolder = new File(externalCacheDir, "tests");
+
+        if (!testFolder.exists()) {
+            testFolder.mkdir();
+        }
+
+        baseCacheDir = testFolder; //Util.createTempDirectory(context, "DemoTest");
+
+        sampleJsonKey = "Hello";
+
+        sampleJsonObject = new JSONObject();
+        sampleJsonObject.put(sampleJsonKey, "world");
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        Util.recursiveDelete(baseCacheDir);
+        super.tearDown();
+    }
+
+    /**
+     * Downloads a sample video and checks for the following
+     * <p>
+     * 1. Download percent is 100
+     * 2. Downloaded cache folder has files
+     * 3. Cumulative file size in the download folder matches with downloaded info.
+     */
+    public void testDownloadAsync() throws InterruptedException {
+
+        String videoId = "123";
+        DownloadInfo downloadInfo = TestUtil.downloadSampleHlsVideo(baseCacheDir, videoId, new String(_16ByteEncryptionKey));
+
+        // verify that 'Download percent is 100 '
+        assertEquals(100, (int) downloadInfo.downloadPercent);
+
+        File videoCacheFolder = new File(baseCacheDir, videoId);
+
+        long folderSize = TestUtil.folderSize(videoCacheFolder, "exo", "0.0");
+
+        boolean hasCache = videoCacheFolder.list().length > 0;
+
+        // verify that 'Downloaded cache folder has files'
+        assertTrue("No cache exists ", hasCache);
+
+        // verify that 'Cumulative file size in the download folder matches with downloaded info.'
+        assertEquals(folderSize, downloadInfo.downloadBytes);
+
+    }
+
+
+}
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/OfflineUtilTest.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/OfflineUtilTest.java
new file mode 100644
index 0000000000..e62449cbed
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/OfflineUtilTest.java
@@ -0,0 +1,107 @@
+package com.google.android.exoplayer2.offline;
+
+import android.content.Context;
+import android.test.InstrumentationTestCase;
+
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+import com.google.android.exoplayer2.offline.models.DownloadInfo;
+import com.google.android.exoplayer2.util.Util;
+
+import org.json.JSONObject;
+
+import java.io.File;
+import java.util.Arrays;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+
+public class OfflineUtilTest extends InstrumentationTestCase {
+
+    private static final String SAMPLE_VIDEO_MANIFEST_URL = "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd";
+
+    private File baseCacheDir;
+    private byte[] _16ByteEncryptionKey = {
+            0, 1, 2, 3,
+            4, 5, 6, 7,
+            8, 9, 10, 11,
+            12, 13, 14, 15
+    };
+
+    private JSONObject sampleJsonObject;
+    private String sampleJsonKey;
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        Context context = getInstrumentation().getTargetContext();
+        File externalCacheDir = context.getExternalCacheDir();
+        File testFolder = new File(externalCacheDir, "tests");
+
+        if (!testFolder.exists()) {
+            testFolder.mkdir();
+        }
+
+        baseCacheDir = testFolder; //Util.createTempDirectory(context, "DemoTest");
+
+        sampleJsonKey = "Hello";
+
+        sampleJsonObject = new JSONObject();
+        sampleJsonObject.put(sampleJsonKey, "world");
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        Util.recursiveDelete(baseCacheDir);
+        super.tearDown();
+    }
+
+    /**
+     * Downloads a sample video and checks for the following.
+     * <p>
+     * 1. Downloaded video percent matches with cache info
+     * 2. Downloaded bytes matches with cache info.
+     * 3. Verifies whether cache available is true
+     */
+    public void testGetCacheInfoAndIsCacheAvailable() {
+
+        String videoId = "123";
+
+        String encKey = new String(_16ByteEncryptionKey);
+        DownloadInfo downloadInfo = TestUtil.downloadSampleDashVideo(baseCacheDir, videoId, encKey);
+
+        CacheInfo cacheInfo = OfflineUtil.getCacheInfo(baseCacheDir, videoId, encKey);
+
+        assertEquals(downloadInfo.downloadPercent, cacheInfo.getDownloadPercent());
+        assertEquals(downloadInfo.downloadBytes, cacheInfo.getDownloadBytes());
+        assertTrue(OfflineUtil.isCacheAvailable(baseCacheDir, videoId, encKey));
+
+    }
+
+    /**
+     * Insert a dummy cache info and reads back to verify the data saved are correct.
+     */
+    public void testStoreCacheInfo() {
+
+        String videoId = "123";
+        String encKey = new String(_16ByteEncryptionKey);
+
+        CacheInfo writeCacheInfo = new CacheInfo(videoId);
+        writeCacheInfo.setDownloadBytes(100);
+        writeCacheInfo.setDownloadPercent(100);
+        writeCacheInfo.setLicenseKey(_16ByteEncryptionKey);
+
+        OfflineUtil.storeCacheInfo(baseCacheDir, videoId, writeCacheInfo, encKey);
+
+
+        CacheInfo readCacheInfo = OfflineUtil.getCacheInfo(baseCacheDir, videoId, encKey);
+
+        assertEquals(writeCacheInfo.getDownloadBytes(), readCacheInfo.getDownloadBytes());
+        assertEquals(writeCacheInfo.getDownloadPercent(), readCacheInfo.getDownloadPercent());
+        assertTrue(Arrays.equals(writeCacheInfo.getLicenseKey(), readCacheInfo.getLicenseKey()));
+        assertTrue(writeCacheInfo.getId().equals(readCacheInfo.getId()));
+
+    }
+
+}
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/TestUtil.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/TestUtil.java
new file mode 100644
index 0000000000..8aeedb1d9c
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/TestUtil.java
@@ -0,0 +1,174 @@
+package com.google.android.exoplayer2.offline;
+
+import android.util.Log;
+
+import com.google.android.exoplayer2.offline.dataprovider.cache.FileCacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.offline.models.DownloadInfo;
+
+import java.io.File;
+
+import io.reactivex.Flowable;
+import io.reactivex.functions.Consumer;
+import io.reactivex.schedulers.TestScheduler;
+
+/**
+ * Created by sharish on 07/02/18.
+ */
+
+public class TestUtil {
+
+    private static final String SAMPLE_DASH_VIDEO_MANIFEST_URL = "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd";
+    private static final String SAMPLE_HLS_VIDEO_MANIFEST_URL = "https://tungsten.aaplimg.com/VOD/bipbop_adv_example_v2/master.m3u8";
+
+
+    static long folderSize(File directory, String matchExtn, String discardNamePrefix) {
+        long length = 0;
+        for (File file : directory.listFiles()) {
+            if (file.isFile()) {
+                String name = file.getName();
+                if (name.endsWith(matchExtn) && !name.startsWith(discardNamePrefix)) {
+                    length += file.length();
+                }
+            } else
+                length += folderSize(file, matchExtn, discardNamePrefix);
+        }
+        return length;
+    }
+
+    static DownloadInfo downloadSampleDashVideo(File baseCacheDir, String id, String encKey) {
+
+        ICacheInfoProvider cacheInfoProvider = new FileCacheInfoProvider(baseCacheDir, encKey);
+        HttpDataSourceFactoryBuilder httpDataSourceFactoryBuilder = new HttpDataSourceFactoryBuilder("ExoPlayer");
+
+
+        Flowable<DownloadInfo> asyncDownloader = DashOfflineUtil.downloadAsync(baseCacheDir, id, SAMPLE_DASH_VIDEO_MANIFEST_URL, encKey, 180, httpDataSourceFactoryBuilder, cacheInfoProvider);
+
+        final DownloadInfo[] result = {null};
+        final Throwable[] err = {null};
+
+        TestScheduler scheduler1 = new TestScheduler();
+        TestScheduler scheduler2 = new TestScheduler();
+
+        asyncDownloader.subscribeOn(scheduler1)
+                .observeOn(scheduler2)
+                .subscribe(new Consumer<DownloadInfo>() {
+                    @Override
+                    public void accept(DownloadInfo integer) throws Exception {
+                        result[0] = integer;
+
+                        int downloadPercent = (int) result[0].downloadPercent;
+                        Log.d("TestLog", "Download Percent:" + downloadPercent);
+
+
+                    }
+                }, new Consumer<Throwable>() {
+                    @Override
+                    public void accept(Throwable throwable) throws Exception {
+
+                        err[0] = throwable;
+                        result[0] = new DownloadInfo(-2, 0);
+                    }
+                });
+
+        scheduler1.triggerActions();
+        scheduler2.triggerActions();
+
+        float lastKnownValue = result[0].downloadPercent;
+
+        while (lastKnownValue <= result[0].downloadPercent) {
+
+            try {
+                Thread.sleep(5 * 1000);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+
+            if (lastKnownValue == result[0].downloadPercent) {
+                break;
+            }
+
+            if (result[0].downloadPercent == 100) {
+                break;
+            }
+
+        }
+
+        if (result[0].downloadPercent == -2) {
+            throw new RuntimeException(err[0]);
+        }
+
+        return result[0];
+
+    }
+
+
+    static DownloadInfo downloadSampleHlsVideo(File baseCacheDir, String id, String encKey) {
+
+        ICacheInfoProvider cacheInfoProvider = new FileCacheInfoProvider(baseCacheDir, encKey);
+        HttpDataSourceFactoryBuilder httpDataSourceFactoryBuilder = new HttpDataSourceFactoryBuilder("ExoPlayer");
+
+
+        Flowable<DownloadInfo> asyncDownloader = HlsOfflineUtil.downloadAsync(baseCacheDir, id, SAMPLE_HLS_VIDEO_MANIFEST_URL, encKey, 180, httpDataSourceFactoryBuilder, cacheInfoProvider);
+
+        final DownloadInfo[] result = {null};
+        final Throwable[] err = {null};
+
+        TestScheduler scheduler1 = new TestScheduler();
+        TestScheduler scheduler2 = new TestScheduler();
+
+        asyncDownloader.subscribeOn(scheduler1)
+                .observeOn(scheduler2)
+                .subscribe(new Consumer<DownloadInfo>() {
+                    @Override
+                    public void accept(DownloadInfo integer) throws Exception {
+                        result[0] = integer;
+
+                        int downloadPercent = (int) result[0].downloadPercent;
+                        Log.d("TestLog", "Download Percent:" + downloadPercent);
+
+
+                    }
+                }, new Consumer<Throwable>() {
+                    @Override
+                    public void accept(Throwable throwable) throws Exception {
+
+                        err[0] = throwable;
+                        result[0] = new DownloadInfo(-2, 0);
+                    }
+                });
+
+        scheduler1.triggerActions();
+        scheduler2.triggerActions();
+
+        float lastKnownValue = result[0].downloadPercent;
+
+        while (lastKnownValue <= result[0].downloadPercent) {
+
+            try {
+                Thread.sleep(5 * 1000);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+
+            if (lastKnownValue == result[0].downloadPercent) {
+                break;
+            }
+
+            if (result[0].downloadPercent == 100) {
+                break;
+            }
+
+        }
+
+        if (result[0].downloadPercent == -2) {
+            throw new RuntimeException(err[0]);
+        }
+
+        return result[0];
+
+    }
+
+
+}
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/dataprovider/license/OfflineLicenseProviderTest.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/dataprovider/license/OfflineLicenseProviderTest.java
new file mode 100644
index 0000000000..4fef212435
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/dataprovider/license/OfflineLicenseProviderTest.java
@@ -0,0 +1,158 @@
+package com.google.android.exoplayer2.offline.dataprovider.license;
+
+import android.content.Context;
+import android.test.InstrumentationTestCase;
+
+import com.google.android.exoplayer2.offline.OfflineUtil;
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.File;
+import java.util.Arrays;
+
+import io.reactivex.Flowable;
+import io.reactivex.functions.Consumer;
+import io.reactivex.schedulers.TestScheduler;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+public class OfflineLicenseProviderTest extends InstrumentationTestCase {
+
+    private File cacheDir;
+    private byte[] _16ByteEncryptionKey = {
+            0, 1, 2, 3,
+            4, 5, 6, 7,
+            8, 9, 10, 11,
+            12, 13, 14, 15
+    };
+
+    private OfflineLicenseProvider mLicenseProvider;
+    private String videoId = "123";
+
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        Context context = getInstrumentation().getTargetContext();
+        cacheDir = Util.createTempDirectory(context, "DemoTest");
+
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        Util.recursiveDelete(cacheDir);
+        super.tearDown();
+    }
+
+    /**
+     * Tests whether a proper license is generated and the same is stored in cache.
+     */
+    public void testLoadLicense() throws Throwable {
+
+        byte[] key1 = {1, 2, 3, 4};
+
+        initLicenseProvider(key1, 100);
+        byte[] keyId = downloadLicense();
+
+        assertTrue(Arrays.equals(key1, keyId)); // verify mock key is retrieved.
+
+        CacheInfo cacheInfo = OfflineUtil.getCacheInfo(cacheDir, videoId, new String(_16ByteEncryptionKey));
+        assertTrue(Arrays.equals(cacheInfo.getLicenseKey(), keyId)); // verify that cache info also holds the same key.
+    }
+
+
+    /**
+     * Create a new license and verify the following
+     *
+     * 1. Verify that base license provider is hit when no cache exists and stores such value in cache.
+     * 2. Verify that base provider is not hit when cache exists
+     * 3. Verify that cache source is hit when cache exists
+     * 4. Verify that base license provider is hit when the license expiry is too small.
+     */
+    public void testLoadLicense2() throws Throwable {
+
+
+        byte[] mockKey1 = {1, 2, 3, 4};
+        byte[] mockKey2 = {5, 6, 7, 8};
+        byte[] mockKey3 = {9, 10, 11, 12};
+
+
+        initLicenseProvider(mockKey1, 100);
+        byte[] actualKey1 = downloadLicense();
+
+        CacheInfo cacheInfo = OfflineUtil.getCacheInfo(cacheDir, videoId, new String(_16ByteEncryptionKey));
+
+        assertTrue(Arrays.equals(cacheInfo.getLicenseKey(), mockKey1)); // verify that cache info also holds the same key.
+
+
+        initLicenseProvider(mockKey2, 100);
+        byte[] actualKey2 = downloadLicense();
+
+
+        assertTrue(Arrays.equals(mockKey1, actualKey1)); //1.  Verify that base license provider is hit when no cache exists and stores such value in cache.
+        assertFalse(Arrays.equals(mockKey2, actualKey2));//2.  Verify that base provider is not hit when cache exists
+        assertTrue(Arrays.equals(mockKey1, actualKey2)); //3. Verify that cache source is hit when cache exists
+
+
+        initLicenseProvider(mockKey3, 10);
+        byte[] actualKey3 = downloadLicense();
+
+        assertTrue(Arrays.equals(mockKey3, actualKey3)); // 4. Verify that base license provider is hit when the expiry is too small.
+
+    }
+
+
+    private void initLicenseProvider(final byte[] key, final int lifetime) {
+
+
+        ILicenseProvider dummyLicenseProvider = new ILicenseProvider() {
+            @Override
+            public Flowable<byte[]> loadLicense2() {
+                return Flowable.just(key);
+            }
+
+            @Override
+            public long getLicensePeriodLeft(byte[] keyId) {
+                return lifetime;
+            }
+        };
+
+
+        mLicenseProvider = new OfflineLicenseProvider(videoId, cacheDir, dummyLicenseProvider, new String(_16ByteEncryptionKey));
+    }
+
+    private byte[] downloadLicense() throws Throwable {
+
+        final Object[] result = {null};
+
+        TestScheduler scheduler = new TestScheduler();
+        mLicenseProvider.loadLicense2()
+                .subscribeOn(scheduler)
+                .observeOn(scheduler)
+                .subscribe(new Consumer<byte[]>() {
+                    @Override
+                    public void accept(byte[] bytes) throws Exception {
+                        result[0] = bytes;
+                    }
+                }, new Consumer<Throwable>() {
+                    @Override
+                    public void accept(Throwable throwable) throws Exception {
+                        result[0] = throwable;
+                    }
+                });
+
+
+        scheduler.triggerActions();
+
+        if (result[0] instanceof Throwable) {
+            throw (Throwable) result[0];
+        }
+
+        return (byte[]) result[0];
+
+    }
+
+
+}
diff --git a/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/dataprovider/license/OnlineLicenseProviderTest.java b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/dataprovider/license/OnlineLicenseProviderTest.java
new file mode 100644
index 0000000000..d266efc6c8
--- /dev/null
+++ b/library/offline/src/androidTest/java/com/google/android/exoplayer2/offline/dataprovider/license/OnlineLicenseProviderTest.java
@@ -0,0 +1,102 @@
+package com.google.android.exoplayer2.offline.dataprovider.license;
+
+import android.content.Context;
+import android.net.Uri;
+import android.test.InstrumentationTestCase;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.File;
+
+import io.reactivex.functions.Consumer;
+import io.reactivex.schedulers.TestScheduler;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+
+public class OnlineLicenseProviderTest extends InstrumentationTestCase {
+
+    private static final String SAMPLE_VIDEO_MANIFEST_URL = "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd";
+    private static final String SAMPLE_VIDEO_LICENSE_URL = "https://proxy.uat.widevine.com/proxy?video_id=d286538032258a1c&provider=widevine_test";
+
+
+    private OnlineLicenseProvider mLicenseProvider;
+
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("Exo", null);
+        HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(SAMPLE_VIDEO_LICENSE_URL, factory);
+
+        mLicenseProvider = new OnlineLicenseProvider(factory, drmCallback, SAMPLE_VIDEO_MANIFEST_URL);
+    }
+
+
+    /**
+     * Tests whether a proper license is generated and the following are verified
+     * <p>
+     * 1. Key always starts with 'ksid'
+     * 2. Key is always 12-byte length.
+     */
+    public void testLoadLicense() throws Throwable {
+
+
+        byte[] keyId = downloadLicense();
+
+        String keyIdString = new String(keyId);
+        assertTrue("Key was " + keyIdString, keyIdString.startsWith("ksid"));
+        assertEquals(keyId.length, 12);
+    }
+
+
+    /**
+     * Tests whether a newly generated google license is generated has infinite expiry
+     */
+    public void testLicenseExpiry() throws Throwable {
+
+        byte[] keyId = downloadLicense();
+        long licensePeriodLeft1 = mLicenseProvider.getLicensePeriodLeft(keyId);
+
+        assertEquals(Math.abs(C.TIME_UNSET), licensePeriodLeft1);
+
+    }
+
+    private byte[] downloadLicense() throws Throwable {
+
+        final Object[] result = {null};
+
+        TestScheduler scheduler = new TestScheduler();
+        mLicenseProvider.loadLicense2()
+                .subscribeOn(scheduler)
+                .observeOn(scheduler)
+                .subscribe(new Consumer<byte[]>() {
+                    @Override
+                    public void accept(byte[] bytes) throws Exception {
+                        result[0] = bytes;
+                    }
+                }, new Consumer<Throwable>() {
+                    @Override
+                    public void accept(Throwable throwable) throws Exception {
+                        result[0] = throwable;
+                    }
+                });
+
+
+        scheduler.triggerActions();
+
+        if (result[0] instanceof Throwable) {
+            throw (Throwable) result[0];
+        }
+
+        return (byte[]) result[0];
+
+    }
+
+
+}
diff --git a/library/offline/src/main/AndroidManifest.xml b/library/offline/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..40a517a503
--- /dev/null
+++ b/library/offline/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest package="com.google.android.exoplayer2.offline"/>
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/DashOfflineUtil.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/DashOfflineUtil.java
new file mode 100644
index 0000000000..3f61f4770c
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/DashOfflineUtil.java
@@ -0,0 +1,166 @@
+package com.google.android.exoplayer2.offline;
+
+import android.net.Uri;
+import android.util.Log;
+
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+import com.google.android.exoplayer2.offline.models.DownloadInfo;
+import com.google.android.exoplayer2.source.dash.DashUtil;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.source.dash.offline.DashDownloader;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Locale;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+
+import static com.google.android.exoplayer2.offline.OfflineUtil.get16ByteSecretKey;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class DashOfflineUtil {
+
+
+    /**
+     * Downloads the video in asynchronous way.
+     *
+     * @param downloadFolder         - target directory where the video should be downloaded
+     * @param id                     - Unique video id, based on which sub directory will be identified.
+     * @param manifestUrl            - target video manifest url
+     * @param key                    - Encryption key if any.
+     * @param targetVideoPixelHeight - Target video height.
+     * @return - Rx Flowable reference for async downloading.
+     */
+    public static Flowable<DownloadInfo> downloadAsync(final File downloadFolder, final String id, final String manifestUrl, final String key, final int targetVideoPixelHeight, final HttpDataSourceFactoryBuilder factoryBuilder, final  ICacheInfoProvider cacheInfoProvider) {
+
+        return Flowable.create(new FlowableOnSubscribe<DownloadInfo>() {
+            @Override
+            public void subscribe(final FlowableEmitter<DownloadInfo> e) throws Exception {
+
+                try {
+                    downloadSync(downloadFolder, id, manifestUrl, key, targetVideoPixelHeight, factoryBuilder, cacheInfoProvider, new Downloader.ProgressListener() {
+                        @Override
+                        public void onDownloadProgress(Downloader downloader, float downloadPercentage, long downloadedBytes) {
+
+                            if (e.isCancelled()) return;
+
+                            DownloadInfo downloadInfo = new DownloadInfo(downloadPercentage, downloadedBytes);
+                            e.onNext(downloadInfo);
+
+                            if (downloadPercentage == 100) {
+                                e.onComplete();
+                            }
+                        }
+                    });
+                } catch (InterruptedException e1) {
+                    if (e.isCancelled()) return;
+                    throw e1;
+                }
+
+
+            }
+
+        }, BackpressureStrategy.BUFFER);
+    }
+
+
+    private static RepresentationKey[] getRepresentationKeys(DashManifest dashManifest, int pixelHeight) {
+
+        int periodCount = dashManifest.getPeriodCount();
+
+        ArrayList<RepresentationKey> keys = new ArrayList<>();
+
+        for (int i = 0; i < periodCount; i++) {
+            Period period = dashManifest.getPeriod(i);
+            int size = period.adaptationSets.size();
+
+            for (int j = 0; j < size; j++) {
+                AdaptationSet adaptationSet = period.adaptationSets.get(j);
+                int adpSize = adaptationSet.representations.size();
+
+                for (int k = 0; k < adpSize; k++) {
+                    Representation representation = adaptationSet.representations.get(k);
+
+                    int repHeight = representation.format.height;
+                    Log.d("Offline", String.format(Locale.getDefault(), "Period: %d, Adp : %d, Rep : %d, Format:%dp", i, j, k, repHeight));
+
+                    if (repHeight == pixelHeight || repHeight == -1) {
+                        keys.add(new RepresentationKey(i, j, k));
+                    }
+                }
+            }
+        }
+
+        return keys.toArray(new RepresentationKey[keys.size()]);
+
+    }
+
+    public static void downloadSync(final File baseFolder, final String id, final String manifestUrl, final String key, int targetVideoPixelHeight, HttpDataSourceFactoryBuilder factoryBuilder, final ICacheInfoProvider cacheInfoProvider, final Downloader.ProgressListener listener) throws Exception {
+
+        if (!baseFolder.exists()) {
+            baseFolder.mkdir();
+        }
+
+        byte[] secretKey = get16ByteSecretKey(key);
+
+
+        File manifestFolder = new File(baseFolder, id);
+
+        if (!manifestFolder.exists()) {
+            manifestFolder.mkdir();
+        }
+
+        Uri uri = Uri.parse(manifestUrl);
+
+        SimpleCache cache = new SimpleCache(manifestFolder, new NoOpCacheEvictor(), secretKey);
+        DefaultHttpDataSourceFactory factory = factoryBuilder.build();
+        DownloaderConstructorHelper constructorHelper =
+                new DownloaderConstructorHelper(cache, factory);
+
+        DashDownloader dashDownloader = new DashDownloader(uri, constructorHelper);
+
+        DashManifest dashManifest = DashUtil.loadManifest(factory.createDataSource(), uri);
+
+        // Select the first representation of the first adaptation set of the first period
+        dashDownloader.selectRepresentations(DashOfflineUtil.getRepresentationKeys(dashManifest, targetVideoPixelHeight));
+
+        CacheInfo cacheInfoNonfinal = cacheInfoProvider.getCacheInfo(id);
+
+        if (cacheInfoNonfinal == null) {
+            cacheInfoNonfinal = new CacheInfo(id);
+        }
+
+        final CacheInfo cacheInfo = cacheInfoNonfinal;
+
+        dashDownloader.download(new Downloader.ProgressListener() {
+            @Override
+            public void onDownloadProgress(Downloader downloader, float downloadPercentage, long downloadedBytes) {
+
+                cacheInfo.setDownloadBytes(downloadedBytes);
+                cacheInfo.setDownloadPercent(downloadPercentage);
+
+                cacheInfoProvider.storeCacheInfo(id, cacheInfo);
+
+                if (listener != null) {
+                    listener.onDownloadProgress(downloader, downloadPercentage, downloadedBytes);
+                }
+            }
+        });
+    }
+
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/FileUtil.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/FileUtil.java
new file mode 100644
index 0000000000..d09e21b8ff
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/FileUtil.java
@@ -0,0 +1,319 @@
+package com.google.android.exoplayer2.offline;
+
+
+import com.google.android.exoplayer2.util.Util;
+
+import org.json.JSONObject;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Random;
+
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+import io.reactivex.annotations.NonNull;
+
+/**
+ * Created by sharish on 29/01/18.
+ */
+
+public class FileUtil {
+
+    private static final String CHARSET = "UTF-8";
+
+    /**
+     * Initial Vector Length
+     */
+    private static final int IV_LEN = 16;
+
+    /**
+     * Writes the given JSON into a file
+     *
+     * @param targetDir     - Directory where the file has to be created.
+     * @param name          - File name
+     * @param object        - JSON data.
+     */
+    public static void writeJson(File targetDir, String name, JSONObject object) {
+
+        FileOutputStream fos = null;
+
+        if (!targetDir.exists()) {
+            targetDir.mkdir();
+        }
+        try {
+
+            byte[] bytes = object.toString().getBytes("UTF-8");
+            fos = new FileOutputStream(new File(targetDir, name));
+            fos.write(bytes, 0, bytes.length);
+            fos.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fos != null)
+                try {
+                    fos.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+        }
+
+    }
+
+    /**
+     * Writes the given JSON into a file after encrypting it with the given encryptionKey.
+     *
+     * @param targetDir     - Directory where the file has to be created.
+     * @param name          - File name
+     * @param encryptionKey - 16 byte encryption key for encryption
+     * @param object        - JSON data.
+     */
+    public static void writeEncryptedJson(File targetDir, String name, @NonNull byte[] encryptionKey, @NonNull JSONObject object) {
+
+        DataOutputStream output = null;
+
+        try {
+
+            if (!targetDir.exists()) {
+                targetDir.mkdir();
+            }
+
+            byte[] contentBytes = object.toString().getBytes(CHARSET);
+
+            BufferedOutputStream outStream = new BufferedOutputStream(new FileOutputStream(new File(targetDir, name)));
+            output = new DataOutputStream(outStream);
+
+            SecretKeySpec secretKeySpec = new SecretKeySpec(encryptionKey, "AES");
+            Cipher cipher = getCipher();
+
+            byte[] initializationVector = new byte[IV_LEN];
+            new Random().nextBytes(initializationVector);
+            output.write(initializationVector);
+
+            IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+            try {
+                cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
+            } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+                throw new IllegalStateException(e); // Should never happen.
+            }
+            output.flush();
+            output = new DataOutputStream(new CipherOutputStream(outStream, cipher));
+
+            output.writeInt(contentBytes.length);
+            output.write(contentBytes);
+            output.flush();
+
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                if (output != null) {
+                    output.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Reads the file content as JSON object after performing decryption with the given decryption key.
+     *
+     * @param targetDir     - Directory where the file has to be created.
+     * @param name          - File name
+     * @param decryptionKey - 16 byte decryption key.
+     * @return Ouput JSON when successful, null when error occurred.
+     */
+    public static JSONObject readEncryptedJson(File targetDir, String name, byte[] decryptionKey) {
+
+        DataInputStream input = null;
+        File file = new File(targetDir, name);
+
+        if (!file.exists()) return null;
+        try {
+
+            BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(file));
+            input = new DataInputStream(inputStream);
+
+            SecretKeySpec secretKeySpec = new SecretKeySpec(decryptionKey, "AES");
+            Cipher cipher = getCipher();
+
+            byte[] initializationVector = new byte[IV_LEN];
+            input.readFully(initializationVector);
+            IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+            try {
+                cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
+            } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+                throw new IllegalStateException(e);
+            }
+            input = new DataInputStream(new CipherInputStream(inputStream, cipher));
+
+
+            int totalLen = input.readInt();
+            byte[] contentBytes = new byte[totalLen];
+            input.readFully(contentBytes);
+
+            String readString = new String(contentBytes);
+
+            return new JSONObject(readString);
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            if (input != null)
+                try {
+                    input.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+        }
+
+        return null;
+
+    }
+
+    /**
+     * Reads the file content as JSON object
+     *
+     * @param targetDir     - Directory where the file has to be created.
+     * @param name          - File name
+     * @return Ouput JSON when successful, null when error occurred.
+     */
+    public static JSONObject readJson(File targetDir, String name) {
+
+        FileInputStream fis = null;
+        if (!targetDir.exists()) {
+            targetDir.mkdir();
+        }
+
+        File file = new File(targetDir, name);
+
+        if (!file.exists()) return null;
+        try {
+            fis = new FileInputStream(file);
+            int length = (int) file.length();
+            byte[] buffer = new byte[length];
+            fis.read(buffer, 0, length);
+            fis.close();
+
+            return new JSONObject(new String(buffer));
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            if (fis != null)
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+        }
+
+        return null;
+
+    }
+
+    /**
+     * Writes the given byte array into a file
+     *
+     * @param targetDir     - Directory where the file has to be created.
+     * @param name          - File name
+     */
+    public static void writeBytes(File targetDir, String name, byte[] keyId) {
+
+        FileOutputStream fos = null;
+
+        if (!targetDir.exists()) {
+            targetDir.mkdir();
+        }
+        try {
+            fos = new FileOutputStream(new File(targetDir, name));
+            fos.write(keyId, 0, keyId.length);
+            fos.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fos != null)
+                try {
+                    fos.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+        }
+
+    }
+
+    /**
+     * Reads the file content as byte array.
+     *
+     * @param targetDir     - Directory where the file has to be created.
+     * @param name          - File name
+     * @return file content in the form of byte[].
+     *
+     */
+    public static byte[] readBytes(File targetDir, String name) {
+
+        FileInputStream fis = null;
+        if (!targetDir.exists()) {
+            targetDir.mkdir();
+        }
+
+        File file = new File(targetDir, name);
+
+        if (!file.exists()) return null;
+        try {
+            fis = new FileInputStream(file);
+            int length = (int) file.length();
+            byte[] buffer = new byte[length];
+            fis.read(buffer, 0, length);
+            fis.close();
+
+            return buffer;
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fis != null)
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+        }
+
+        return null;
+    }
+
+    /**
+     * Copied from com.google.android.exoplayer2.upstream.cache.CachedContentIndex#getCipher()
+     */
+    private static Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException {
+        // Workaround for https://issuetracker.google.com/issues/36976726
+        if (Util.SDK_INT == 18) {
+            try {
+                return Cipher.getInstance("AES/CBC/PKCS5PADDING", "BC");
+            } catch (Throwable ignored) {
+                // ignored
+            }
+        }
+        return Cipher.getInstance("AES/CBC/PKCS5PADDING");
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/HlsOfflineUtil.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/HlsOfflineUtil.java
new file mode 100644
index 0000000000..0d7be7be2d
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/HlsOfflineUtil.java
@@ -0,0 +1,175 @@
+package com.google.android.exoplayer2.offline;
+
+import android.net.Uri;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+import com.google.android.exoplayer2.offline.models.DownloadInfo;
+import com.google.android.exoplayer2.source.hls.offline.HlsDownloader;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+
+import static com.google.android.exoplayer2.offline.OfflineUtil.get16ByteSecretKey;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class HlsOfflineUtil {
+
+    /**
+     * Downloads the video in asynchronous way.
+     *
+     * @param downloadFolder         - target directory where the video should be downloaded
+     * @param id                     - Unique video id, based on which sub directory will be identified.
+     * @param manifestUrl            - target video manifest url
+     * @param key                    - Encryption key if any.
+     * @param targetVideoPixelHeight - Target video height.
+     * @return - Rx Flowable reference for async downloading.
+     */
+    public static Flowable<DownloadInfo> downloadAsync(final File downloadFolder, final String id, final String manifestUrl, final String key, final int targetVideoPixelHeight, final HttpDataSourceFactoryBuilder factoryBuilder, final ICacheInfoProvider cacheInfoProvider) {
+
+        return Flowable.create(new FlowableOnSubscribe<DownloadInfo>() {
+            @Override
+            public void subscribe(final FlowableEmitter<DownloadInfo> e) throws Exception {
+
+                try {
+
+                    downloadSync(downloadFolder, id, manifestUrl, key, targetVideoPixelHeight, factoryBuilder,cacheInfoProvider, new Downloader.ProgressListener() {
+                        @Override
+                        public void onDownloadProgress(Downloader downloader, float downloadPercentage, long downloadedBytes) {
+
+                            DownloadInfo downloadInfo = new DownloadInfo(downloadPercentage, downloadedBytes);
+                            e.onNext(downloadInfo);
+
+                            if (downloadPercentage == 100) {
+                                e.onComplete();
+                            }
+                        }
+                    });
+
+                } catch (InterruptedException e1) {
+                    if (e.isCancelled()) return;
+                    throw e1;
+                }
+
+
+            }
+
+        }, BackpressureStrategy.BUFFER);
+    }
+
+
+    private static String[] getRepresentationKeys(HlsMasterPlaylist manifest, int pixelHeight) {
+
+        List<HlsMasterPlaylist.HlsUrl> variants = manifest.variants;
+
+        int periodCount = variants.size();
+
+        ArrayList<String> keys = new ArrayList<>();
+
+        for (int i = 0; i < periodCount; i++) {
+
+            HlsMasterPlaylist.HlsUrl hlsUrl = variants.get(i);
+            if (hlsUrl.format.height == pixelHeight) {
+                keys.add(hlsUrl.url);
+            }
+
+        }
+
+        List<HlsMasterPlaylist.HlsUrl> audios = manifest.audios;
+
+        for (HlsMasterPlaylist.HlsUrl audioUrl : audios) {
+            keys.add(audioUrl.url);
+
+        }
+
+
+        return keys.toArray(new String[keys.size()]);
+
+    }
+
+
+    public static void downloadSync(final File baseFolder, final String id, final String manifestUrl, final String key, int targetVideoPixelHeight, HttpDataSourceFactoryBuilder factoryBuilder, final ICacheInfoProvider cacheInfoProvider, final Downloader.ProgressListener listener) throws Exception {
+
+        if (!baseFolder.exists()) {
+            baseFolder.mkdir();
+        }
+
+        byte[] secretKey = get16ByteSecretKey(key);
+
+
+        File manifestFolder = new File(baseFolder, id);
+
+        if (!manifestFolder.exists()) {
+            manifestFolder.mkdir();
+        }
+
+        Uri uri = Uri.parse(manifestUrl);
+
+        SimpleCache cache = new SimpleCache(manifestFolder, new NoOpCacheEvictor(), secretKey);
+        DefaultHttpDataSourceFactory factory = factoryBuilder.build();
+        DownloaderConstructorHelper constructorHelper =
+                new DownloaderConstructorHelper(cache, factory);
+
+
+        HlsDownloader hlsDownloader = new HlsDownloader(uri, constructorHelper);
+
+        HlsMasterPlaylist hlsPlaylist = (HlsMasterPlaylist) loadManifest(factory.createDataSource(), uri);
+
+        // Select the first representation of the first adaptation set of the first period
+        hlsDownloader.selectRepresentations(getRepresentationKeys(hlsPlaylist, targetVideoPixelHeight));
+
+        CacheInfo cacheInfoNonfinal = cacheInfoProvider.getCacheInfo(id);
+
+        if (cacheInfoNonfinal == null) {
+            cacheInfoNonfinal = new CacheInfo(id);
+        }
+
+        final CacheInfo cacheInfo = cacheInfoNonfinal;
+
+        hlsDownloader.download(new Downloader.ProgressListener() {
+            @Override
+            public void onDownloadProgress(Downloader downloader, float downloadPercentage, long downloadedBytes) {
+
+                cacheInfo.setDownloadBytes(downloadedBytes);
+                cacheInfo.setDownloadPercent(downloadPercentage);
+
+                cacheInfoProvider.storeCacheInfo( id, cacheInfo);
+
+                if (listener != null) {
+                    listener.onDownloadProgress(downloader, downloadPercentage, downloadedBytes);
+                }
+            }
+        });
+    }
+
+    private static HlsPlaylist loadManifest(DataSource dataSource, Uri uri) throws IOException {
+        DataSpec dataSpec = new DataSpec(uri,
+                DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
+        ParsingLoadable<HlsPlaylist> loadable = new ParsingLoadable<>(dataSource, dataSpec,
+                C.DATA_TYPE_MANIFEST, new HlsPlaylistParser());
+        loadable.load();
+        return loadable.getResult();
+    }
+
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/OfflineUtil.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/OfflineUtil.java
new file mode 100644
index 0000000000..3b68f4f3e5
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/OfflineUtil.java
@@ -0,0 +1,146 @@
+package com.google.android.exoplayer2.offline;
+
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.UnsupportedEncodingException;
+
+import io.reactivex.annotations.Nullable;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class OfflineUtil {
+
+    public static final int VIDEO_HEIGHT_WILDCARD = -1;
+
+    /**
+     * Reads the Cache info.
+     *
+     * @param baseDownloadDirectory - base download directory where the info is stored.
+     * @param id                    - Unique id
+     * @param key                   - Encryption key if any.
+     * @return - Cache info of the video if found, null otherwise.
+     */
+    public static CacheInfo getCacheInfo(File baseDownloadDirectory, String id, String key) {
+
+        File contentFolder = new File(baseDownloadDirectory, "info");
+
+        if (!contentFolder.exists()) return null;
+
+        byte[] secretKey = get16ByteSecretKey(key);
+
+        JSONObject object;
+
+        if (key == null || key.length() == 0) {
+            object = FileUtil.readJson(contentFolder, id);
+        } else {
+            object = FileUtil.readEncryptedJson(contentFolder, id, secretKey);
+        }
+
+        CacheInfo cacheInfo = new CacheInfo(id);
+        cacheInfo.fromJson(object);
+
+        return cacheInfo;
+
+    }
+
+    /**
+     * Tells whether cache is available for the video or not.
+     *
+     * @param baseDownloadDirectory - base download directory where the info is stored.
+     * @param id                    - Unique id
+     * @param key                   - Encryption key if any.
+     * @return - true when cache download percent is greater than zero, false otherwise.
+     */
+    public static boolean isCacheAvailable(File baseDownloadDirectory, String id, String key) {
+        CacheInfo cacheInfo = getCacheInfo(baseDownloadDirectory, id, key);
+        return cacheInfo != null && cacheInfo.getDownloadPercent() > 0;
+    }
+
+//    /**
+//     * Loads the cache data source for the given video id.
+//     *
+//     * @param baseDirectory - Directory where all the cache resides
+//     * @param id            - unique id of the video to pick the video
+//     * @param key           - decryption key.
+//     * @return - cache data source.
+//     */
+//    public static CacheDataSource loadCache(File baseDirectory, String id, @Nullable String key) {
+//
+//        File manifestFolder = new File(baseDirectory, id);
+//
+//        byte[] secretKey = get16ByteSecretKey(key);
+//        SimpleCache cache = new SimpleCache(manifestFolder, new NoOpCacheEvictor(), secretKey);
+//        DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
+//        return new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
+//    }
+
+    /**
+     * Loads the cache data source for the given video id.
+     *
+     * @param baseDirectory - Directory where all the cache resides
+     * @param id            - unique id of the video to pick the video
+     * @param key           - decryption key.
+     * @return - cache data source.
+     */
+    public static CacheDataSource loadCache(File baseDirectory, String id, @Nullable String key, HttpDataSourceFactoryBuilder factoryBuilder) {
+
+        File manifestFolder = new File(baseDirectory, id);
+
+        byte[] secretKey = get16ByteSecretKey(key);
+        SimpleCache cache = new SimpleCache(manifestFolder, new NoOpCacheEvictor(), secretKey);
+        DefaultHttpDataSourceFactory factory = factoryBuilder.build();
+        return new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
+    }
+
+    /**
+     * Stores the cache data source for the given video id.
+     *
+     * @param baseDirectory - Directory where all the cache resides
+     * @param id            - unique id of the video to pick the video
+     * @param key           - decryption key.
+     */
+    public static void storeCacheInfo(File baseDirectory, String id, CacheInfo cacheInfo, String key) {
+
+        File contentFolder = new File(baseDirectory, "info");
+
+        if (!contentFolder.exists()) {
+            contentFolder.mkdir();
+        }
+
+        byte[] secretKey = get16ByteSecretKey(key);
+
+        if (key == null || key.length() == 0) {
+            FileUtil.writeJson(contentFolder, id, cacheInfo.toJson());
+        } else {
+            FileUtil.writeEncryptedJson(contentFolder, id, secretKey, cacheInfo.toJson());
+        }
+
+    }
+
+    static byte[] get16ByteSecretKey(String key) {
+
+        if (key == null || key.length() == 0) return null;
+
+        byte[] secretKey = new byte[16];
+
+        try {
+            byte[] actualBytes = key.getBytes("UTF-8");
+            System.arraycopy(actualBytes, 0, secretKey, 0, Math.min(16, actualBytes.length));
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+        }
+
+        return secretKey;
+    }
+
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/cache/FileCacheInfoProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/cache/FileCacheInfoProvider.java
new file mode 100644
index 0000000000..6faf00d131
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/cache/FileCacheInfoProvider.java
@@ -0,0 +1,40 @@
+package com.google.android.exoplayer2.offline.dataprovider.cache;
+
+import com.google.android.exoplayer2.offline.OfflineUtil;
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+
+import java.io.File;
+
+/**
+ * Created by Harish on 21/03/18.
+ */
+
+public class FileCacheInfoProvider implements ICacheInfoProvider {
+
+    private File mBaseDirectory;
+    private String mEncryptionKey;
+
+    public FileCacheInfoProvider(File mBaseDirectory) {
+        this.mBaseDirectory = mBaseDirectory;
+    }
+
+    public FileCacheInfoProvider(File mBaseDirectory, String mEncryptionKey) {
+        this.mBaseDirectory = mBaseDirectory;
+        this.mEncryptionKey = mEncryptionKey;
+    }
+
+    @Override
+    public CacheInfo getCacheInfo(String id) {
+        return OfflineUtil.getCacheInfo(mBaseDirectory, id, mEncryptionKey);
+    }
+
+    @Override
+    public boolean isCacheAvailable(String id) {
+        return OfflineUtil.isCacheAvailable(mBaseDirectory, id, mEncryptionKey);
+    }
+
+    @Override
+    public void storeCacheInfo(String id, CacheInfo cacheInfo) {
+        OfflineUtil.storeCacheInfo(mBaseDirectory, id, cacheInfo, mEncryptionKey);
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/cache/ICacheInfoProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/cache/ICacheInfoProvider.java
new file mode 100644
index 0000000000..479c5f9061
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/cache/ICacheInfoProvider.java
@@ -0,0 +1,16 @@
+package com.google.android.exoplayer2.offline.dataprovider.cache;
+
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+
+/**
+ * Created by Harish on 21/03/18.
+ */
+
+public interface ICacheInfoProvider {
+
+    CacheInfo getCacheInfo(String id);
+
+    boolean isCacheAvailable(String id);
+
+    void storeCacheInfo(String id, CacheInfo cacheInfo);
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/ILicenseProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/ILicenseProvider.java
new file mode 100644
index 0000000000..fd21c24076
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/ILicenseProvider.java
@@ -0,0 +1,15 @@
+package com.google.android.exoplayer2.offline.dataprovider.license;
+
+import io.reactivex.Flowable;
+import io.reactivex.Single;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public interface ILicenseProvider {
+
+    Flowable<byte[]> loadLicense2();
+
+    long getLicensePeriodLeft(byte[] keyId);
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/OfflineLicenseProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/OfflineLicenseProvider.java
new file mode 100644
index 0000000000..6280cbc156
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/OfflineLicenseProvider.java
@@ -0,0 +1,75 @@
+package com.google.android.exoplayer2.offline.dataprovider.license;
+
+import com.google.android.exoplayer2.offline.OfflineUtil;
+import com.google.android.exoplayer2.offline.models.CacheInfo;
+
+import java.io.File;
+
+import io.reactivex.Flowable;
+import io.reactivex.Single;
+import io.reactivex.functions.Function;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class OfflineLicenseProvider implements ILicenseProvider {
+
+    private String mId;
+    private File mBaseFolder;
+    private ILicenseProvider mBaseProvider;
+    private String mKey;
+
+    public OfflineLicenseProvider(String mId, File baseFolder, ILicenseProvider mBaseProvider, String key) {
+        this.mId = mId;
+        this.mBaseFolder = baseFolder;
+        this.mBaseProvider = mBaseProvider;
+        this.mKey = key;
+    }
+
+    @Override
+    public Flowable<byte[]> loadLicense2() {
+        CacheInfo cacheInfo = OfflineUtil.getCacheInfo(mBaseFolder, mId, mKey);
+
+        byte[] keyId = null;
+        if (cacheInfo != null) {
+            keyId = cacheInfo.getLicenseKey();
+        }
+
+        // if cache exists, check if good amount of time expiry left for the license and return the license key.
+        if (keyId != null && keyId.length > 0) {
+            long licensePeriodLeft = getLicensePeriodLeft(keyId);
+
+            if (licensePeriodLeft > 60) {
+                return Flowable.just(keyId);
+            }
+        }
+
+        // otherwise download from base provider and store it in cache if valid.
+        return mBaseProvider.loadLicense2().map(new Function<byte[], byte[]>() {
+            @Override
+            public byte[] apply(byte[] newKeyId) throws Exception {
+
+                if (newKeyId.length > 0) {
+
+                    CacheInfo cacheInfo = OfflineUtil.getCacheInfo(mBaseFolder, mId, mKey);
+
+                    if (cacheInfo == null) {
+                        cacheInfo = new CacheInfo(mId);
+                    }
+
+                    cacheInfo.setLicenseKey(newKeyId);
+
+                    OfflineUtil.storeCacheInfo(mBaseFolder, mId, cacheInfo, mKey);
+                }
+
+                return newKeyId;
+            }
+        });
+    }
+
+    @Override
+    public long getLicensePeriodLeft(byte[] keyId) {
+        return mBaseProvider.getLicensePeriodLeft(keyId);
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/OnlineLicenseProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/OnlineLicenseProvider.java
new file mode 100644
index 0000000000..cbf32efa7d
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/license/OnlineLicenseProvider.java
@@ -0,0 +1,105 @@
+package com.google.android.exoplayer2.offline.dataprovider.license;
+
+import android.net.Uri;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.drm.DrmSession;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
+import com.google.android.exoplayer2.drm.MediaDrmCallback;
+import com.google.android.exoplayer2.drm.OfflineLicenseHelper;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.source.dash.DashUtil;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+
+import java.io.IOException;
+import java.util.UUID;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class OnlineLicenseProvider implements ILicenseProvider {
+
+    private HttpDataSource.Factory httpDataSourceFactory;
+    private MediaDrmCallback mMediaDrmCallback;
+    private String mPlayingUri;
+
+    public OnlineLicenseProvider(HttpDataSource.Factory httpDataSourceFactory, MediaDrmCallback mMediaDrmCallback, String mPlayingUri) {
+        this.httpDataSourceFactory = httpDataSourceFactory;
+        this.mMediaDrmCallback = mMediaDrmCallback;
+        this.mPlayingUri = mPlayingUri;
+
+    }
+
+    @Override
+    public Flowable<byte[]> loadLicense2() {
+        return Flowable.create(new FlowableOnSubscribe<byte[]>() {
+            @Override
+            public void subscribe(FlowableEmitter<byte[]> e) throws Exception {
+
+                try {
+                    byte[] keyId = loadLicenseSync();
+
+                    if (keyId != null) {
+                        e.onNext(keyId);
+                    } else {
+                        e.onError(new RuntimeException("Failed to download key id"));
+                    }
+                }catch (Throwable t) {
+                    if(e.isCancelled()) {
+                        return;
+                        // do nothing.
+                    }
+                    throw t;
+                }
+
+            }
+        }, BackpressureStrategy.BUFFER);
+    }
+
+    @Override
+    public long getLicensePeriodLeft(byte[] keyId) {
+
+
+        UUID widevineUuid = C.WIDEVINE_UUID;
+        FrameworkMediaDrm frameworkMediaDrm;
+        try {
+            frameworkMediaDrm = FrameworkMediaDrm.newInstance(widevineUuid);
+
+            OfflineLicenseHelper<FrameworkMediaCrypto> offlineLicenseHelper = new OfflineLicenseHelper<>(widevineUuid, frameworkMediaDrm, mMediaDrmCallback, null);
+
+            return offlineLicenseHelper.getLicenseDurationRemainingSec(keyId).first;
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+
+        return 0;
+    }
+
+
+    private byte[] loadLicenseSync() throws IOException, InterruptedException, DrmSession.DrmSessionException, UnsupportedDrmException {
+
+        UUID widevineUuid = C.WIDEVINE_UUID;
+        FrameworkMediaDrm frameworkMediaDrm = FrameworkMediaDrm.newInstance(widevineUuid);
+
+        OfflineLicenseHelper<FrameworkMediaCrypto> offlineLicenseHelper = new OfflineLicenseHelper<>(widevineUuid, frameworkMediaDrm, mMediaDrmCallback, null);
+
+
+        DataSource dataSource = httpDataSourceFactory.createDataSource();
+        DashManifest dashManifest = DashUtil.loadManifest(dataSource, Uri.parse(mPlayingUri));
+        DrmInitData drmInitData = DashUtil.loadDrmInitData(dataSource, dashManifest.getPeriod(0));
+
+        return offlineLicenseHelper.downloadLicense(drmInitData);
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/DashDataSourceProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/DashDataSourceProvider.java
new file mode 100644
index 0000000000..f2ef3d8541
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/DashDataSourceProvider.java
@@ -0,0 +1,28 @@
+package com.google.android.exoplayer2.offline.dataprovider.source;
+
+import com.google.android.exoplayer2.offline.DashOfflineUtil;
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.upstream.DataSource;
+
+import java.io.File;
+
+import static com.google.android.exoplayer2.offline.OfflineUtil.loadCache;
+
+/**
+ * Created by sharish on 07/02/18.
+ */
+
+public class DashDataSourceProvider implements IDataSourceProvider {
+
+    @Override
+    public DataSource downloadAndLoad(File baseFolder, String id, String manifestUrl, String key, HttpDataSourceFactoryBuilder factoryBuilder, ICacheInfoProvider cacheInfoProvider, int targetVideoPixelHeight) throws Exception {
+
+        if (!cacheInfoProvider.isCacheAvailable(id)) {
+            DashOfflineUtil.downloadSync(baseFolder, id, manifestUrl, key, targetVideoPixelHeight, factoryBuilder, cacheInfoProvider, null);
+        }
+
+        return loadCache(baseFolder, id, key, factoryBuilder);
+
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/HlsDataSourceProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/HlsDataSourceProvider.java
new file mode 100644
index 0000000000..9892a4c9f6
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/HlsDataSourceProvider.java
@@ -0,0 +1,28 @@
+package com.google.android.exoplayer2.offline.dataprovider.source;
+
+import com.google.android.exoplayer2.offline.HlsOfflineUtil;
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.upstream.DataSource;
+
+import java.io.File;
+
+import static com.google.android.exoplayer2.offline.OfflineUtil.loadCache;
+
+/**
+ * Created by sharish on 07/02/18.
+ */
+
+public class HlsDataSourceProvider implements IDataSourceProvider {
+
+    @Override
+    public DataSource downloadAndLoad(File baseFolder, String id, String manifestUrl, String key, HttpDataSourceFactoryBuilder factoryBuilder, ICacheInfoProvider cacheInfoProvider, int targetVideoPixelHeight) throws Exception {
+
+        if (!cacheInfoProvider.isCacheAvailable(id)) {
+            HlsOfflineUtil.downloadSync(baseFolder, id, manifestUrl, key, targetVideoPixelHeight, factoryBuilder, cacheInfoProvider, null);
+        }
+
+        return loadCache(baseFolder, id, key, factoryBuilder);
+
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/IDataSourceProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/IDataSourceProvider.java
new file mode 100644
index 0000000000..9d325e1baa
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/source/IDataSourceProvider.java
@@ -0,0 +1,27 @@
+package com.google.android.exoplayer2.offline.dataprovider.source;
+
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.stream.HttpDataSourceFactoryBuilder;
+import com.google.android.exoplayer2.upstream.DataSource;
+
+import java.io.File;
+
+/**
+ * Created by sharish on 07/02/18.
+ */
+
+public interface IDataSourceProvider {
+
+    /**
+     * Provides Offline Video Data Source. If not offline exists, makes a synchronous cache download and provide it.
+     *
+     * @param baseFolder         - target directory where the video should be downloaded
+     * @param id                     - Unique video id, based on which sub directory will be identified.
+     * @param manifestUrl            - target video manifest url
+     * @param key                    - Encryption key if any.
+     * @param targetVideoPixelHeight - Target video height.
+     * @param factoryBuilder - Main source builder.
+     * @return - Video stream as data source.
+     */
+    DataSource downloadAndLoad(File baseFolder, String id, String manifestUrl, String key, HttpDataSourceFactoryBuilder factoryBuilder, ICacheInfoProvider cacheInfoProvider, int targetVideoPixelHeight) throws Exception;
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/DrmOnlineStreamProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/DrmOnlineStreamProvider.java
new file mode 100644
index 0000000000..9669996424
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/DrmOnlineStreamProvider.java
@@ -0,0 +1,46 @@
+package com.google.android.exoplayer2.offline.dataprovider.stream;
+
+import android.os.Handler;
+
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.MediaDrmCallback;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class DrmOnlineStreamProvider implements IVideoStreamDataSourceProvider {
+
+    private Handler mMainHandler;
+    private MediaDrmCallback mMediaDrmCallback;
+    private DefaultDrmSessionManager.EventListener mEventListener;
+    private HttpDataSourceFactoryBuilder mFactoryBuilder;
+
+
+    public DrmOnlineStreamProvider(MediaDrmCallback mMediaDrmCallback, HttpDataSourceFactoryBuilder factoryBuilder) {
+        this.mMediaDrmCallback = mMediaDrmCallback;
+        this.mFactoryBuilder = factoryBuilder;
+    }
+
+    public DrmOnlineStreamProvider(MediaDrmCallback mMediaDrmCallback, Handler mMainHandler, DefaultDrmSessionManager.EventListener mEventListener, HttpDataSourceFactoryBuilder factoryBuilder) {
+        this.mMainHandler = mMainHandler;
+        this.mMediaDrmCallback = mMediaDrmCallback;
+        this.mEventListener = mEventListener;
+        this.mFactoryBuilder = factoryBuilder;
+
+    }
+
+    @Override
+    public DataSource createDataSource() {
+        return mFactoryBuilder.build().createDataSource();
+    }
+
+    @Override
+    public DefaultDrmSessionManager<FrameworkMediaCrypto> buildSessionManager(byte[] keyId) throws UnsupportedDrmException {
+        return DefaultDrmSessionManager.newWidevineInstance(mMediaDrmCallback, null, mMainHandler, mEventListener);
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/HlsOnlineStreamProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/HlsOnlineStreamProvider.java
new file mode 100644
index 0000000000..ca89ec6d3f
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/HlsOnlineStreamProvider.java
@@ -0,0 +1,31 @@
+package com.google.android.exoplayer2.offline.dataprovider.stream;
+
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class HlsOnlineStreamProvider implements IVideoStreamDataSourceProvider {
+
+    private HttpDataSourceFactoryBuilder mFactoryBuilder;
+
+    public HlsOnlineStreamProvider(HttpDataSourceFactoryBuilder mFactoryBuilder) {
+        this.mFactoryBuilder = mFactoryBuilder;
+    }
+
+    @Override
+    public DataSource createDataSource() {
+        return mFactoryBuilder.build().createDataSource();
+    }
+
+    @Override
+    public DefaultDrmSessionManager<FrameworkMediaCrypto> buildSessionManager(byte[] keyId) throws UnsupportedDrmException {
+        return null;
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/HttpDataSourceFactoryBuilder.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/HttpDataSourceFactoryBuilder.java
new file mode 100644
index 0000000000..d7d95de429
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/HttpDataSourceFactoryBuilder.java
@@ -0,0 +1,49 @@
+package com.google.android.exoplayer2.offline.dataprovider.stream;
+
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
+
+import java.util.ArrayList;
+
+/**
+ * Created by sharish on 20/09/17.
+ */
+
+public class HttpDataSourceFactoryBuilder {
+
+    private String mUserAgent;
+    private TransferListener mTransferListener;
+    private ArrayList<String[]> mRequestProperties = new ArrayList<>();
+
+
+    public HttpDataSourceFactoryBuilder(String userAgent) {
+        this.mUserAgent = userAgent;
+    }
+
+    public HttpDataSourceFactoryBuilder addRequestProperties(String key, String value) {
+        mRequestProperties.add(new String[]{key, value});
+        return this;
+    }
+
+    public HttpDataSourceFactoryBuilder transferListener(TransferListener transferListener) {
+        mTransferListener = transferListener;
+        return this;
+    }
+
+
+    public DefaultHttpDataSourceFactory build() {
+
+
+        DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory(mUserAgent, mTransferListener);
+
+        if (mRequestProperties.size() > 0) {
+            HttpDataSource.RequestProperties defaultRequestProperties = factory.getDefaultRequestProperties();
+            for (String[] requestPropertyPair : mRequestProperties) {
+                defaultRequestProperties.set(requestPropertyPair[0], requestPropertyPair[1]);
+            }
+        }
+
+        return factory;
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/IVideoStreamDataSourceProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/IVideoStreamDataSourceProvider.java
new file mode 100644
index 0000000000..913700a8a8
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/IVideoStreamDataSourceProvider.java
@@ -0,0 +1,15 @@
+package com.google.android.exoplayer2.offline.dataprovider.stream;
+
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.upstream.DataSource;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public interface IVideoStreamDataSourceProvider extends DataSource.Factory {
+
+    DefaultDrmSessionManager<FrameworkMediaCrypto> buildSessionManager(byte[] licenseKey) throws UnsupportedDrmException;
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/OfflineStreamProvider.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/OfflineStreamProvider.java
new file mode 100644
index 0000000000..db9ae24b77
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/dataprovider/stream/OfflineStreamProvider.java
@@ -0,0 +1,79 @@
+package com.google.android.exoplayer2.offline.dataprovider.stream;
+
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.offline.OfflineUtil;
+import com.google.android.exoplayer2.offline.dataprovider.cache.ICacheInfoProvider;
+import com.google.android.exoplayer2.offline.dataprovider.source.IDataSourceProvider;
+import com.google.android.exoplayer2.upstream.DataSource;
+
+import java.io.File;
+
+/**
+ * Created by sharish on 22/01/18.
+ */
+
+public class OfflineStreamProvider implements IVideoStreamDataSourceProvider {
+
+    private IVideoStreamDataSourceProvider mBaseStreamProvider;
+
+    private String mId;
+    private File mBaseFolder;
+    private String mManifestUrl;
+    private String mEncryptionKey;
+    private int mVideoHeight = OfflineUtil.VIDEO_HEIGHT_WILDCARD;
+    private IDataSourceProvider mDataSourceProvider;
+    private ICacheInfoProvider mCacheInfoProvider;
+    private HttpDataSourceFactoryBuilder mFactoryBuilder;
+
+//    public OfflineStreamProvider(String mId, String mManifestUrl, File mBaseFolder, IVideoStreamDataSourceProvider streamProvider, IDataSourceProvider dataSourceProvider) {
+//        this(mId, mManifestUrl, mBaseFolder, null, OfflineUtil.VIDEO_HEIGHT_WILDCARD, null, streamProvider, dataSourceProvider);
+//    }
+
+    public OfflineStreamProvider(String mId, String mManifestUrl, File mBaseFolder, String encryptionKey, int videoHeight, HttpDataSourceFactoryBuilder factoryBuilder, ICacheInfoProvider cacheInfoProvider, IVideoStreamDataSourceProvider streamProvider, IDataSourceProvider dataSourceProvider) {
+        this.mId = mId;
+        this.mBaseFolder = mBaseFolder;
+        this.mManifestUrl = mManifestUrl;
+        this.mBaseStreamProvider = streamProvider;
+        mEncryptionKey = encryptionKey;
+        mVideoHeight = videoHeight;
+        mDataSourceProvider = dataSourceProvider;
+        mFactoryBuilder = factoryBuilder;
+        mCacheInfoProvider = cacheInfoProvider;
+    }
+
+    @Override
+    public DataSource createDataSource() {
+
+        if (!mBaseFolder.exists()) {
+            mBaseFolder.mkdir();
+        }
+
+
+
+        if (mCacheInfoProvider.isCacheAvailable(mId)) {
+            return OfflineUtil.loadCache(mBaseFolder, mId, mEncryptionKey, mFactoryBuilder);
+        } else {
+            try {
+                return mDataSourceProvider.downloadAndLoad(mBaseFolder, mId, mManifestUrl, mEncryptionKey, mFactoryBuilder, mCacheInfoProvider, mVideoHeight);
+            } catch (Exception e) {
+                e.printStackTrace();
+                return mBaseStreamProvider.createDataSource();
+
+            }
+        }
+    }
+
+    @Override
+    public DefaultDrmSessionManager<FrameworkMediaCrypto> buildSessionManager(byte[] licenseKey) throws UnsupportedDrmException {
+
+        DefaultDrmSessionManager<FrameworkMediaCrypto> sessionManager = mBaseStreamProvider.buildSessionManager(licenseKey);
+
+        if (licenseKey != null) {
+            sessionManager.setMode(DefaultDrmSessionManager.MODE_PLAYBACK, licenseKey);
+        }
+
+        return sessionManager;
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/models/CacheInfo.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/models/CacheInfo.java
new file mode 100644
index 0000000000..41bc2e9170
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/models/CacheInfo.java
@@ -0,0 +1,97 @@
+package com.google.android.exoplayer2.offline.models;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Created by sharish on 29/01/18.
+ */
+
+public class CacheInfo {
+
+    private static final String KEY_ID = "_id";
+    private static final String KEY_DOWNLOAD_PERCENT = "download_percent";
+    private static final String KEY_LICENSE_KEY = "license_key";
+    private static final String KEY_DOWNLOADED_BYTES = "download_bytes";
+
+
+    private String mId;
+    private float mDownloadPercent;
+    private byte[] mLicenseKey;
+    private long mDownloadBytes;
+
+
+    public CacheInfo(String id) {
+        mId = id;
+    }
+
+    public String getId() {
+        return mId;
+    }
+
+    public void setId(String mId) {
+        this.mId = mId;
+    }
+
+    public float getDownloadPercent() {
+        return mDownloadPercent;
+    }
+
+    public void setDownloadPercent(float mDownloadPercent) {
+        this.mDownloadPercent = mDownloadPercent;
+    }
+
+    public byte[] getLicenseKey() {
+        return mLicenseKey;
+    }
+
+    public void setLicenseKey(byte[] mLicenseKey) {
+        this.mLicenseKey = mLicenseKey;
+    }
+
+    public long getDownloadBytes() {
+        return mDownloadBytes;
+    }
+
+    public void setDownloadBytes(long mDownloadBytes) {
+        this.mDownloadBytes = mDownloadBytes;
+    }
+
+
+    public void fromJson(JSONObject object) {
+
+        if (object == null) return;
+        try {
+
+            mId = object.optString(KEY_ID);
+            mDownloadPercent = (float) object.optDouble(KEY_DOWNLOAD_PERCENT);
+            String licenseKeyString = object.optString(KEY_LICENSE_KEY);
+            mLicenseKey = licenseKeyString != null ? licenseKeyString.getBytes("UTF-8") : null;
+            mDownloadBytes = object.optLong(KEY_DOWNLOADED_BYTES);
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    public JSONObject toJson() {
+
+        JSONObject object = new JSONObject();
+
+        try {
+
+            object.put(KEY_ID, mId);
+            object.put(KEY_DOWNLOAD_PERCENT, mDownloadPercent);
+            if (mLicenseKey != null) {
+                object.put(KEY_LICENSE_KEY, new String(mLicenseKey));
+            }
+            object.put(KEY_DOWNLOADED_BYTES, mDownloadBytes);
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+
+        return object;
+    }
+}
diff --git a/library/offline/src/main/java/com/google/android/exoplayer2/offline/models/DownloadInfo.java b/library/offline/src/main/java/com/google/android/exoplayer2/offline/models/DownloadInfo.java
new file mode 100644
index 0000000000..7111c3d007
--- /dev/null
+++ b/library/offline/src/main/java/com/google/android/exoplayer2/offline/models/DownloadInfo.java
@@ -0,0 +1,16 @@
+package com.google.android.exoplayer2.offline.models;
+
+/**
+ * Created by sharish on 05/02/18.
+ */
+
+public class DownloadInfo {
+
+    public float downloadPercent;
+    public long downloadBytes;
+
+    public DownloadInfo(float downloadPercent, long downloadBytes) {
+        this.downloadPercent = downloadPercent;
+        this.downloadBytes = downloadBytes;
+    }
+}
diff --git a/library/offline/src/main/res/drawable-xhdpi/ic_banner.png b/library/offline/src/main/res/drawable-xhdpi/ic_banner.png
new file mode 100644
index 0000000000..09de177387
Binary files /dev/null and b/library/offline/src/main/res/drawable-xhdpi/ic_banner.png differ
diff --git a/library/offline/src/main/res/layout/inner_list_sample.xml b/library/offline/src/main/res/layout/inner_list_sample.xml
new file mode 100644
index 0000000000..c304c68884
--- /dev/null
+++ b/library/offline/src/main/res/layout/inner_list_sample.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2006 The Android Open Source Project
+
+        Licensed under the Apache License, Version 2.0 (the "License");
+        you may not use this file except in compliance with the License.
+        You may obtain a copy of the License at
+
+             http://www.apache.org/licenses/LICENSE-2.0
+
+        Unless required by applicable law or agreed to in writing, software
+        distributed under the License is distributed on an "AS IS" BASIS,
+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+        See the License for the specific language governing permissions and
+        limitations under the License.
+   -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical">
+
+
+    <TextView xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@android:id/text1"
+              android:layout_width="match_parent"
+              android:layout_height="wrap_content"
+              android:gravity="center_vertical"
+              android:minHeight="?android:attr/listPreferredItemHeightSmall"
+              android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
+              android:paddingLeft="10dp"
+              android:paddingRight="10dp"
+              android:text="123213"
+              android:paddingStart="?android:attr/listPreferredItemPaddingStart"
+              android:textAppearance="?android:attr/textAppearanceListItemSmall"
+
+        />
+
+    <ProgressBar
+        android:id="@+id/progress"
+        style="?android:attr/progressBarStyleHorizontal"
+        android:layout_width="match_parent"
+        android:layout_height="4dp"
+        android:progress="40"
+        android:max="100"
+        />
+
+
+
+</LinearLayout>
\ No newline at end of file
diff --git a/library/offline/src/main/res/layout/list_divider.xml b/library/offline/src/main/res/layout/list_divider.xml
new file mode 100644
index 0000000000..0382999160
--- /dev/null
+++ b/library/offline/src/main/res/layout/list_divider.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<View xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="1px"
+    android:background="?android:attr/listDivider"/>
diff --git a/library/offline/src/main/res/layout/player_activity.xml b/library/offline/src/main/res/layout/player_activity.xml
new file mode 100644
index 0000000000..3f8cdaa7d6
--- /dev/null
+++ b/library/offline/src/main/res/layout/player_activity.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/root"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:keepScreenOn="true">
+
+  <com.google.android.exoplayer2.ui.SimpleExoPlayerView android:id="@+id/player_view"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"/>
+
+  <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:background="#88000000"
+      android:orientation="vertical">
+
+    <TextView android:id="@+id/debug_text_view"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="4dp"
+        android:paddingRight="4dp"
+        android:textSize="10sp"
+        tools:ignore="SmallSp"/>
+
+    <LinearLayout android:id="@+id/controls_root"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:visibility="gone">
+
+      <Button android:id="@+id/retry_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:text="@string/retry"
+          android:visibility="gone"/>
+
+    </LinearLayout>
+
+  </LinearLayout>
+
+</FrameLayout>
diff --git a/library/offline/src/main/res/layout/sample_chooser_activity.xml b/library/offline/src/main/res/layout/sample_chooser_activity.xml
new file mode 100644
index 0000000000..4d968c7497
--- /dev/null
+++ b/library/offline/src/main/res/layout/sample_chooser_activity.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+  <ExpandableListView android:id="@+id/sample_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"/>
+
+</LinearLayout>
diff --git a/library/offline/src/main/res/layout/track_selection_dialog.xml b/library/offline/src/main/res/layout/track_selection_dialog.xml
new file mode 100644
index 0000000000..d7e9369e8b
--- /dev/null
+++ b/library/offline/src/main/res/layout/track_selection_dialog.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="match_parent">
+
+  <LinearLayout android:id="@+id/root"
+      android:orientation="vertical"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"/>
+
+</ScrollView>
diff --git a/library/offline/src/main/res/mipmap-hdpi/ic_launcher.png b/library/offline/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..adaa93220e
Binary files /dev/null and b/library/offline/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/library/offline/src/main/res/mipmap-mdpi/ic_launcher.png b/library/offline/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..9b6f7d5e80
Binary files /dev/null and b/library/offline/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/library/offline/src/main/res/mipmap-xhdpi/ic_launcher.png b/library/offline/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..2101026c9f
Binary files /dev/null and b/library/offline/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/library/offline/src/main/res/mipmap-xxhdpi/ic_launcher.png b/library/offline/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..223ec8bd11
Binary files /dev/null and b/library/offline/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/library/offline/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/library/offline/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..698ed68c42
Binary files /dev/null and b/library/offline/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/library/offline/src/main/res/values/strings.xml b/library/offline/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..b38ccf6e88
--- /dev/null
+++ b/library/offline/src/main/res/values/strings.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+  <string name="application_name">ExoPlayer</string>
+
+  <string name="video">Video</string>
+
+  <string name="audio">Audio</string>
+
+  <string name="text">Text</string>
+
+  <string name="retry">Retry</string>
+
+  <string name="selection_disabled">Disabled</string>
+
+  <string name="selection_default">Default</string>
+
+  <string name="unexpected_intent_action">Unexpected intent action: <xliff:g id="action">%1$s</xliff:g></string>
+
+  <string name="enable_random_adaptation">Enable random adaptation</string>
+
+  <string name="error_drm_not_supported">Protected content not supported on API levels below 18</string>
+
+  <string name="error_drm_unsupported_scheme">This device does not support the required DRM scheme</string>
+
+  <string name="error_drm_unknown">An unknown DRM error occurred</string>
+
+  <string name="error_no_decoder">This device does not provide a decoder for <xliff:g id="mime_type">%1$s</xliff:g></string>
+
+  <string name="error_no_secure_decoder">This device does not provide a secure decoder for <xliff:g id="mime_type">%1$s</xliff:g></string>
+
+  <string name="error_querying_decoders">Unable to query device decoders</string>
+
+  <string name="error_instantiating_decoder">Unable to instantiate decoder <xliff:g id="decoder_name">%1$s</xliff:g></string>
+
+  <string name="error_unsupported_video">Media includes video tracks, but none are playable by this device</string>
+
+  <string name="error_unsupported_audio">Media includes audio tracks, but none are playable by this device</string>
+
+  <string name="storage_permission_denied">Permission to access storage was denied</string>
+
+  <string name="sample_list_load_error">One or more sample lists failed to load</string>
+
+  <string name="ima_not_loaded">Playing sample without ads, as the IMA extension was not loaded</string>
+
+</resources>
diff --git a/library/offline/src/main/res/values/styles.xml b/library/offline/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..5616bb9869
--- /dev/null
+++ b/library/offline/src/main/res/values/styles.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <style name="PlayerTheme" parent="android:Theme.Holo">
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:windowBackground">@android:color/black</item>
+  </style>
+
+</resources>
diff --git a/library/offline/src/test/java/com/google/android/exoplayer2/offline/OfflineUtilTest.java b/library/offline/src/test/java/com/google/android/exoplayer2/offline/OfflineUtilTest.java
new file mode 100644
index 0000000000..7b075d16ce
--- /dev/null
+++ b/library/offline/src/test/java/com/google/android/exoplayer2/offline/OfflineUtilTest.java
@@ -0,0 +1,33 @@
+package com.google.android.exoplayer2.offline;
+
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+import static junit.framework.Assert.assertEquals;
+
+/**
+ * Created by sharish on 30/01/18.
+ */
+
+@RunWith(RobolectricTestRunner.class)
+public class OfflineUtilTest {
+
+    /**
+     * Test to verify the output of get16ByteSecretKey is always 16, when valid input is passed, null when empty input is passed.
+     */
+    @Test
+    public void test16ByteKey() {
+        byte[] positiveResult = OfflineUtil.get16ByteSecretKey("123");
+        byte[] negResult = OfflineUtil.get16ByteSecretKey(null);
+        byte[] negResult2 = OfflineUtil.get16ByteSecretKey("");
+
+
+        assertEquals(16, positiveResult.length);
+        assertEquals(null, negResult);
+        assertEquals(null, negResult2);
+
+    }
+
+}
