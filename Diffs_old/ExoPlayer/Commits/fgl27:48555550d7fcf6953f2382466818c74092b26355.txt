diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index c58841c2b3..41613f9cde 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -2,6 +2,9 @@
 
 ### dev-v2 (not yet released) ###
 
+* Surface information provided by methods `isHardwareAccelerated`,
+  `isSoftwareOnly` and `isVendor` added in Android Q in `MediaCodecInfo` class
+  ([#5839](https://github.com/google/ExoPlayer/issues/5839)).
 * Update `DefaultTrackSelector` to apply a viewport constraint for the default
   display by default.
 * Add `PlaybackStatsListener` to collect `PlaybackStats` for playbacks analysis
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index c700259b13..6dcbf896c9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -93,6 +93,33 @@
   /** Whether this instance describes a passthrough codec. */
   public final boolean passthrough;
 
+  /**
+   * Whether the codec is hardware accelerated.
+   *
+   * <p>This could be an approximation as the exact information is only provided in API levels 29+.
+   *
+   * @see android.media.MediaCodecInfo#isHardwareAccelerated()
+   */
+  public final boolean hardwareAccelerated;
+
+  /**
+   * Whether the codec is software only.
+   *
+   * <p>This could be an approximation as the exact information is only provided in API levels 29+.
+   *
+   * @see android.media.MediaCodecInfo#isSoftwareOnly()
+   */
+  public final boolean softwareOnly;
+
+  /**
+   * Whether the codec is from the vendor.
+   *
+   * <p>This could be an approximation as the exact information is only provided in API levels 29+.
+   *
+   * @see android.media.MediaCodecInfo#isVendor()
+   */
+  public final boolean vendor;
+
   private final boolean isVideo;
 
   /**
@@ -108,6 +135,9 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
         /* codecMimeType= */ null,
         /* capabilities= */ null,
         /* passthrough= */ true,
+        /* hardwareAccelerated= */ false,
+        /* softwareOnly= */ true,
+        /* vendor= */ false,
         /* forceDisableAdaptive= */ false,
         /* forceSecure= */ false);
   }
@@ -121,6 +151,9 @@ public static MediaCodecInfo newPassthroughInstance(String name) {
    *     Equal to {@code mimeType} unless the codec is known to use a non-standard MIME type alias.
    * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type, or
    *     {@code null} if not known.
+   * @param hardwareAccelerated Whether the {@link MediaCodec} is hardware accelerated.
+   * @param softwareOnly Whether the {@link MediaCodec} is software only.
+   * @param vendor Whether the {@link MediaCodec} is provided by the vendor.
    * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
    * @param forceSecure Whether {@link #secure} should be forced to {@code true}.
    * @return The created instance.
@@ -130,6 +163,9 @@ public static MediaCodecInfo newInstance(
       String mimeType,
       String codecMimeType,
       @Nullable CodecCapabilities capabilities,
+      boolean hardwareAccelerated,
+      boolean softwareOnly,
+      boolean vendor,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     return new MediaCodecInfo(
@@ -138,6 +174,9 @@ public static MediaCodecInfo newInstance(
         codecMimeType,
         capabilities,
         /* passthrough= */ false,
+        hardwareAccelerated,
+        softwareOnly,
+        vendor,
         forceDisableAdaptive,
         forceSecure);
   }
@@ -148,6 +187,9 @@ private MediaCodecInfo(
       @Nullable String codecMimeType,
       @Nullable CodecCapabilities capabilities,
       boolean passthrough,
+      boolean hardwareAccelerated,
+      boolean softwareOnly,
+      boolean vendor,
       boolean forceDisableAdaptive,
       boolean forceSecure) {
     this.name = Assertions.checkNotNull(name);
@@ -155,6 +197,9 @@ private MediaCodecInfo(
     this.codecMimeType = codecMimeType;
     this.capabilities = capabilities;
     this.passthrough = passthrough;
+    this.hardwareAccelerated = hardwareAccelerated;
+    this.softwareOnly = softwareOnly;
+    this.vendor = vendor;
     adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
     tunneling = capabilities != null && isTunneling(capabilities);
     secure = forceSecure || (capabilities != null && isSecure(capabilities));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 9c42916cad..966e9fecc2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -312,6 +312,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
           if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {
             continue;
           }
+          boolean hardwareAccelerated = isHardwareAccelerated(codecInfo);
+          boolean softwareOnly = isSoftwareOnly(codecInfo);
+          boolean vendor = isVendor(codecInfo);
           boolean forceDisableAdaptive = codecNeedsDisableAdaptationWorkaround(name);
           if ((secureDecodersExplicit && key.secure == secureSupported)
               || (!secureDecodersExplicit && !key.secure)) {
@@ -321,6 +324,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
                     mimeType,
                     codecMimeType,
                     capabilities,
+                    hardwareAccelerated,
+                    softwareOnly,
+                    vendor,
                     forceDisableAdaptive,
                     /* forceSecure= */ false));
           } else if (!secureDecodersExplicit && secureSupported) {
@@ -330,6 +336,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
                     mimeType,
                     codecMimeType,
                     capabilities,
+                    hardwareAccelerated,
+                    softwareOnly,
+                    vendor,
                     forceDisableAdaptive,
                     /* forceSecure= */ true));
             // It only makes sense to have one synthesized secure decoder, return immediately.
@@ -532,6 +541,9 @@ private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decod
                 /* mimeType= */ MimeTypes.AUDIO_RAW,
                 /* codecMimeType= */ MimeTypes.AUDIO_RAW,
                 /* capabilities= */ null,
+                /* hardwareAccelerated= */ false,
+                /* softwareOnly= */ true,
+                /* vendor= */ false,
                 /* forceDisableAdaptive= */ false,
                 /* forceSecure= */ false));
       }
@@ -565,6 +577,69 @@ private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decod
     }
   }
 
+  /**
+   * The result of {@link android.media.MediaCodecInfo#isHardwareAccelerated()} for API levels 29+,
+   * or a best-effort approximation for lower levels.
+   */
+  private static boolean isHardwareAccelerated(android.media.MediaCodecInfo codecInfo) {
+    if (Util.SDK_INT >= 29) {
+      return isHardwareAcceleratedV29(codecInfo);
+    }
+    // codecInfo.isHardwareAccelerated() != codecInfo.isSoftwareOnly() is not necessarily true.
+    // However, we assume this to be true as an approximation.
+    return !isSoftwareOnly(codecInfo);
+  }
+
+  @TargetApi(29)
+  private static boolean isHardwareAcceleratedV29(android.media.MediaCodecInfo codecInfo) {
+    return codecInfo.isHardwareAccelerated();
+  }
+
+  /**
+   * The result of {@link android.media.MediaCodecInfo#isSoftwareOnly()} for API levels 29+, or a
+   * best-effort approximation for lower levels.
+   */
+  private static boolean isSoftwareOnly(android.media.MediaCodecInfo codecInfo) {
+    if (Util.SDK_INT >= 29) {
+      return isSoftwareOnlyV29(codecInfo);
+    }
+    String codecName = codecInfo.getName().toLowerCase();
+    if (codecName.startsWith("arc.")) { // App Runtime for Chrome (ARC) codecs
+      return false;
+    }
+    return codecName.startsWith("omx.google.")
+        || codecName.startsWith("omx.ffmpeg.")
+        || (codecName.startsWith("omx.sec.") && codecName.contains(".sw."))
+        || codecName.equals("omx.qcom.video.decoder.hevcswvdec")
+        || codecName.startsWith("c2.android.")
+        || codecName.startsWith("c2.google.")
+        || (!codecName.startsWith("omx.") && !codecName.startsWith("c2."));
+  }
+
+  @TargetApi(29)
+  private static boolean isSoftwareOnlyV29(android.media.MediaCodecInfo codecInfo) {
+    return codecInfo.isSoftwareOnly();
+  }
+
+  /**
+   * The result of {@link android.media.MediaCodecInfo#isVendor()} for API levels 29+, or a
+   * best-effort approximation for lower levels.
+   */
+  private static boolean isVendor(android.media.MediaCodecInfo codecInfo) {
+    if (Util.SDK_INT >= 29) {
+      return isVendorV29(codecInfo);
+    }
+    String codecName = codecInfo.getName().toLowerCase();
+    return !codecName.startsWith("omx.google.")
+        && !codecName.startsWith("c2.android.")
+        && !codecName.startsWith("c2.google.");
+  }
+
+  @TargetApi(29)
+  private static boolean isVendorV29(android.media.MediaCodecInfo codecInfo) {
+    return codecInfo.isVendor();
+  }
+
   /**
    * Returns whether the decoder is known to fail when adapting, despite advertising itself as an
    * adaptive decoder.
