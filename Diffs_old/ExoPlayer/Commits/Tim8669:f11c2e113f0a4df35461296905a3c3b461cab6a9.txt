diff --git a/README.md b/README.md
index 15a87a915c..982ccaee34 100644
--- a/README.md
+++ b/README.md
@@ -1,14 +1,11 @@
-# ExoPlayer Readme #
-
-## Description ##
+# ExoPlayer #
 
 ExoPlayer is an application level media player for Android. It provides an
 alternative to Android’s MediaPlayer API for playing audio and video both
 locally and over the Internet. ExoPlayer supports features not currently
 supported by Android’s MediaPlayer API, including DASH and SmoothStreaming
-adaptive playbacks. Unlike the MediaPlayer API, ExoPlayer is easy to
-customize and extend, and can be updated through Play Store application
-updates.
+adaptive playbacks. Unlike the MediaPlayer API, ExoPlayer is easy to customize
+and extend, and can be updated through Play Store application updates.
 
 ## News ##
 
@@ -19,7 +16,7 @@ Read news, hints and tips on the [news][] page.
 ## Documentation ##
 
 * The [developer guide][] provides a wealth of information to help you get
-started.
+  started.
 * The [class reference][] documents the ExoPlayer library classes.
 * The [release notes][] document the major changes in each release.
 
@@ -27,37 +24,31 @@ started.
 [class reference]: https://google.github.io/ExoPlayer/doc/reference
 [release notes]: https://github.com/google/ExoPlayer/blob/dev/RELEASENOTES.md
 
-## Project branches ##
-
-  * The [master][] branch holds the most recent minor release.
-  * Most development work happens on the [dev][] branch.
-  * Additional development branches may be established for major features.
-
-[master]: https://github.com/google/ExoPlayer/tree/master
-[dev]: https://github.com/google/ExoPlayer/tree/dev
-
-## Using Eclipse ##
-
-The repository includes Eclipse projects for both the ExoPlayer library and its
-accompanying demo application. To get started:
-
-  1. Install Eclipse and setup the [Android SDK][].
+## Using ExoPlayer ##
 
-  1. Open Eclipse and navigate to File->Import->General->Existing Projects into
-     Workspace.
+#### Via jCenter ####
 
-  1. Select the root directory of the repository.
+The easiest way to get started using ExoPlayer is by including the following in
+your project's `build.gradle` file:
 
-  1. Import the ExoPlayerDemo and ExoPlayerLib projects.
+```
+gradle
+compile 'com.google.android.exoplayer:exoplayer:rX.X.X'
+```
 
-[Android SDK]: http://developer.android.com/sdk/index.html
+where `rX.X.X` is the your preferred version. For the latest version, see the
+project's [Releases][]. For more details, see the project on [Bintray][].
 
+[Releases]: https://github.com/google/ExoPlayer/releases
+[Bintray]: https://bintray.com/google/exoplayer/exoplayer/view
 
-## Using Gradle ##
+#### As source ####
 
-ExoPlayer can also be built using Gradle. You can include it as a dependent project and build from source:
+ExoPlayer can also be built from source using Gradle. You can include it as a
+dependent project like so:
 
 ```
+gradle
 // settings.gradle
 include ':app', ':..:ExoPlayer:library'
 
@@ -67,18 +58,41 @@ dependencies {
 }
 ```
 
+#### As a jar ####
+
 If you want to use ExoPlayer as a jar, run:
 
 ```
+sh
 ./gradlew jarRelease
 ```
 
-and copy library.jar to the libs-folder of your new project.
+and copy `library.jar` to the libs folder of your new project.
 
-The project is also available on [jCenter](https://bintray.com/google/exoplayer/exoplayer/view):
+## Developing ExoPlayer ##
 
-```
-compile 'com.google.android.exoplayer:exoplayer:rX.X.X'
-```
+#### Project branches ####
+
+  * The [`master`][master] branch holds the most recent minor release.
+  * Most development work happens on the [`dev`][dev] branch.
+  * Additional development branches may be established for major features.
+
+[master]: https://github.com/google/ExoPlayer/tree/master
+[dev]: https://github.com/google/ExoPlayer/tree/dev
+
+#### Using Android Studio ####
 
-Where `rX.X.X` should be replaced with the desired version.
+To develop ExoPlayer using Android Studio, simply open the ExoPlayer project in
+the root directory of the repository.
+
+#### Using Eclipse ####
+
+To develop ExoPlayer using Eclipse:
+
+  1. Install Eclipse and setup the [Android SDK][].
+  1. Open Eclipse and navigate to File->Import->General->Existing Projects into
+     Workspace.
+  1. Select the root directory of the repository.
+  1. Import the projects.
+
+[Android SDK]: http://developer.android.com/sdk/index.html
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 9bc992cbe0..e8d5d9e340 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,13 @@
 # Release notes #
 
+### r1.5.4 ###
+
+* HLS: Support for variant selection and WebVtt subtitles.
+* MP4: Support for embedded WebVtt.
+* Improved device compatibility.
+* Fix for resource leak (Issue #1066).
+* Misc bug fixes + minor features.
+
 ### r1.5.3 ###
 
 * Support for FLV (without seeking).
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 8cda23deff..29c2b1f950 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -17,7 +17,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
     android:versionCode="1503"
-    android:versionName="1.5.3"
+    android:versionName="1.5.4"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
index f93a7f8884..3619cd2e9e 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
@@ -177,7 +177,7 @@ public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
   }
 
   @Override
-  public void onAvailableRangeChanged(TimeRange availableRange) {
+  public void onAvailableRangeChanged(int sourceId, TimeRange availableRange) {
     availableRangeValuesUs = availableRange.getCurrentBoundsUs(availableRangeValuesUs);
     Log.d(TAG, "availableRange [" + availableRange.isStatic() + ", " + availableRangeValuesUs[0]
         + ", " + availableRangeValuesUs[1] + "]");
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index d515873adb..e41398b734 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -87,16 +87,9 @@
   public static final String CONTENT_ID_EXTRA = "content_id";
   public static final String CONTENT_TYPE_EXTRA = "content_type";
   public static final String PROVIDER_EXTRA = "provider";
-  public static final int TYPE_DASH = 0;
-  public static final int TYPE_SS = 1;
-  public static final int TYPE_HLS = 2;
-  public static final int TYPE_OTHER = 3;
 
   // For use when launching the demo app using adb.
   private static final String CONTENT_EXT_EXTRA = "type";
-  private static final String EXT_DASH = ".mpd";
-  private static final String EXT_SS = ".ism";
-  private static final String EXT_HLS = ".m3u8";
 
   private static final String TAG = "PlayerActivity";
   private static final int MENU_GROUP_TRACKS = 1;
@@ -306,15 +299,15 @@ private boolean requiresPermission(Uri uri) {
   private RendererBuilder getRendererBuilder() {
     String userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
     switch (contentType) {
-      case TYPE_SS:
+      case Util.TYPE_SS:
         return new SmoothStreamingRendererBuilder(this, userAgent, contentUri.toString(),
             new SmoothStreamingTestMediaDrmCallback());
-      case TYPE_DASH:
+      case Util.TYPE_DASH:
         return new DashRendererBuilder(this, userAgent, contentUri.toString(),
             new WidevineTestMediaDrmCallback(contentId, provider));
-      case TYPE_HLS:
+      case Util.TYPE_HLS:
         return new HlsRendererBuilder(this, userAgent, contentUri.toString());
-      case TYPE_OTHER:
+      case Util.TYPE_OTHER:
         return new ExtractorRendererBuilder(this, userAgent, contentUri);
       default:
         throw new IllegalStateException("Unsupported type: " + contentType);
@@ -693,17 +686,7 @@ private CaptionStyleCompat getUserCaptionStyleV19() {
   private static int inferContentType(Uri uri, String fileExtension) {
     String lastPathSegment = !TextUtils.isEmpty(fileExtension) ? "." + fileExtension
         : uri.getLastPathSegment();
-    if (lastPathSegment == null) {
-      return TYPE_OTHER;
-    } else if (lastPathSegment.endsWith(EXT_DASH)) {
-      return TYPE_DASH;
-    } else if (lastPathSegment.endsWith(EXT_SS)) {
-      return TYPE_SS;
-    } else if (lastPathSegment.endsWith(EXT_HLS)) {
-      return TYPE_HLS;
-    } else {
-      return TYPE_OTHER;
-    }
+    return Util.inferContentType(lastPathSegment);
   }
 
   private static final class KeyCompatibleMediaController extends MediaController {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
index a403c83018..fa8315190b 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
@@ -25,12 +25,15 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
+import android.widget.BaseExpandableListAdapter;
+import android.widget.ExpandableListView;
+import android.widget.ExpandableListView.OnChildClickListener;
 import android.widget.TextView;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * An activity for selecting from a number of samples.
  */
@@ -40,41 +43,46 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.sample_chooser_activity);
-
-    ListView sampleList = (ListView) findViewById(R.id.sample_list);
-    final SampleAdapter sampleAdapter = new SampleAdapter(this);
-
-    sampleAdapter.add(new Header("YouTube DASH"));
-    sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_MP4);
-    sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_WEBM);
-    sampleAdapter.add(new Header("Widevine DASH Policy Tests (GTS)"));
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_GTS);
-    sampleAdapter.add(new Header("Widevine HDCP Capabilities Tests"));
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_HDCP);
-    sampleAdapter.add(new Header("Widevine DASH: MP4,H264"));
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H264_MP4_CLEAR);
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H264_MP4_SECURE);
-    sampleAdapter.add(new Header("Widevine DASH: WebM,VP9"));
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_VP9_WEBM_CLEAR);
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_VP9_WEBM_SECURE);
-    sampleAdapter.add(new Header("Widevine DASH: MP4,H265"));
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H265_MP4_CLEAR);
-    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H265_MP4_SECURE);
-    sampleAdapter.add(new Header("SmoothStreaming"));
-    sampleAdapter.addAll((Object[]) Samples.SMOOTHSTREAMING);
-    sampleAdapter.add(new Header("HLS"));
-    sampleAdapter.addAll((Object[]) Samples.HLS);
-    sampleAdapter.add(new Header("Misc"));
-    sampleAdapter.addAll((Object[]) Samples.MISC);
-
-    sampleList.setAdapter(sampleAdapter);
-    sampleList.setOnItemClickListener(new OnItemClickListener() {
+    final List<SampleGroup> sampleGroups = new ArrayList<>();
+    SampleGroup group = new SampleGroup("YouTube DASH");
+    group.addAll(Samples.YOUTUBE_DASH_MP4);
+    group.addAll(Samples.YOUTUBE_DASH_WEBM);
+    sampleGroups.add(group);
+    group = new SampleGroup("Widevine DASH Policy Tests (GTS)");
+    group.addAll(Samples.WIDEVINE_GTS);
+    sampleGroups.add(group);
+    group = new SampleGroup("Widevine HDCP Capabilities Tests");
+    group.addAll(Samples.WIDEVINE_HDCP);
+    sampleGroups.add(group);
+    group = new SampleGroup("Widevine DASH: MP4,H264");
+    group.addAll(Samples.WIDEVINE_H264_MP4_CLEAR);
+    group.addAll(Samples.WIDEVINE_H264_MP4_SECURE);
+    sampleGroups.add(group);
+    group = new SampleGroup("Widevine DASH: WebM,VP9");
+    group.addAll(Samples.WIDEVINE_VP9_WEBM_CLEAR);
+    group.addAll(Samples.WIDEVINE_VP9_WEBM_SECURE);
+    sampleGroups.add(group);
+    group = new SampleGroup("Widevine DASH: MP4,H265");
+    group.addAll(Samples.WIDEVINE_H265_MP4_CLEAR);
+    group.addAll(Samples.WIDEVINE_H265_MP4_SECURE);
+    sampleGroups.add(group);
+    group = new SampleGroup("SmoothStreaming");
+    group.addAll(Samples.SMOOTHSTREAMING);
+    sampleGroups.add(group);
+    group = new SampleGroup("HLS");
+    group.addAll(Samples.HLS);
+    sampleGroups.add(group);
+    group = new SampleGroup("Misc");
+    group.addAll(Samples.MISC);
+    sampleGroups.add(group);
+    ExpandableListView sampleList = (ExpandableListView) findViewById(R.id.sample_list);
+    sampleList.setAdapter(new SampleAdapter(this, sampleGroups));
+    sampleList.setOnChildClickListener(new OnChildClickListener() {
       @Override
-      public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-        Object item = sampleAdapter.getItem(position);
-        if (item instanceof Sample) {
-          onSampleSelected((Sample) item);
-        }
+      public boolean onChildClick(ExpandableListView parent, View view, int groupPosition,
+          int childPosition, long id) {
+        onSampleSelected(sampleGroups.get(groupPosition).samples.get(childPosition));
+        return true;
       }
     });
   }
@@ -88,49 +96,94 @@ private void onSampleSelected(Sample sample) {
     startActivity(mpdIntent);
   }
 
-  private static class SampleAdapter extends ArrayAdapter<Object> {
+  private static final class SampleAdapter extends BaseExpandableListAdapter {
+
+    private final Context context;
+    private final List<SampleGroup> sampleGroups;
+
+    public SampleAdapter(Context context, List<SampleGroup> sampleGroups) {
+      this.context = context;
+      this.sampleGroups = sampleGroups;
+    }
 
-    public SampleAdapter(Context context) {
-      super(context, 0);
+    @Override
+    public Sample getChild(int groupPosition, int childPosition) {
+      return getGroup(groupPosition).samples.get(childPosition);
     }
 
     @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
+    public long getChildId(int groupPosition, int childPosition) {
+      return childPosition;
+    }
+
+    @Override
+    public View getChildView(int groupPosition, int childPosition, boolean isLastChild,
+        View convertView, ViewGroup parent) {
       View view = convertView;
       if (view == null) {
-        int layoutId = getItemViewType(position) == 1 ? android.R.layout.simple_list_item_1
-            : R.layout.sample_chooser_inline_header;
-        view = LayoutInflater.from(getContext()).inflate(layoutId, null, false);
+        view = LayoutInflater.from(context).inflate(android.R.layout.simple_list_item_1, parent,
+            false);
       }
-      Object item = getItem(position);
-      String name = null;
-      if (item instanceof Sample) {
-        name = ((Sample) item).name;
-      } else if (item instanceof Header) {
-        name = ((Header) item).name;
+      ((TextView) view).setText(getChild(groupPosition, childPosition).name);
+      return view;
+    }
+
+    @Override
+    public int getChildrenCount(int groupPosition) {
+      return getGroup(groupPosition).samples.size();
+    }
+
+    @Override
+    public SampleGroup getGroup(int groupPosition) {
+      return sampleGroups.get(groupPosition);
+    }
+
+    @Override
+    public long getGroupId(int groupPosition) {
+      return groupPosition;
+    }
+
+    @Override
+    public View getGroupView(int groupPosition, boolean isExpanded, View convertView,
+        ViewGroup parent) {
+      View view = convertView;
+      if (view == null) {
+        view = LayoutInflater.from(context).inflate(R.layout.sample_chooser_inline_header, parent,
+            false);
       }
-      ((TextView) view).setText(name);
+      ((TextView) view).setText(getGroup(groupPosition).title);
       return view;
     }
 
     @Override
-    public int getItemViewType(int position) {
-      return (getItem(position) instanceof Sample) ? 1 : 0;
+    public int getGroupCount() {
+      return sampleGroups.size();
     }
 
     @Override
-    public int getViewTypeCount() {
-      return 2;
+    public boolean hasStableIds() {
+      return false;
+    }
+
+    @Override
+    public boolean isChildSelectable(int groupPosition, int childPosition) {
+      return true;
     }
 
   }
 
-  private static class Header {
+  private static final class SampleGroup {
+
+    public final String title;
+    public final List<Sample> samples;
 
-    public final String name;
+    public SampleGroup(String title) {
+      this.title = title;
+      this.samples = new ArrayList<>();
+    }
 
-    public Header(String name) {
-      this.name = name;
+    public void addAll(Sample[] samples) {
+      Collections.addAll(this.samples, samples);
     }
 
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index a78a77ffa1..9f58528895 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.demo;
 
+import com.google.android.exoplayer.util.Util;
+
 import java.util.Locale;
 
 /**
@@ -49,12 +51,12 @@ public Sample(String name, String contentId, String provider, String uri, int ty
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7."
-        + "8506521BFC350652163895D4C26DEE124209AA9E&key=ik0", PlayerActivity.TYPE_DASH),
+        + "8506521BFC350652163895D4C26DEE124209AA9E&key=ik0", Util.TYPE_DASH),
     new Sample("Google Play (MP4,H264)",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=A2716F75795F5D2AF0E88962FFCD10DB79384F29."
-        + "84308FF04844498CE6FBCE4731507882B8307798&key=ik0", PlayerActivity.TYPE_DASH),
+        + "84308FF04844498CE6FBCE4731507882B8307798&key=ik0", Util.TYPE_DASH),
   };
 
   public static final Sample[] YOUTUBE_DASH_WEBM = new Sample[] {
@@ -62,188 +64,188 @@ public Sample(String name, String contentId, String provider, String uri, int ty
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=249B04F79E984D7F86B4D8DB48AE6FAF41C17AB3."
-        + "7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0", PlayerActivity.TYPE_DASH),
+        + "7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0", Util.TYPE_DASH),
     new Sample("Google Play (WebM,VP9)",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=B1C2A74783AC1CC4865EB312D7DD2D48230CC9FD."
-        + "BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0", PlayerActivity.TYPE_DASH),
+        + "BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0", Util.TYPE_DASH),
   };
 
   public static final Sample[] SMOOTHSTREAMING = new Sample[] {
     new Sample("Super speed",
         "http://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism",
-        PlayerActivity.TYPE_SS),
+        Util.TYPE_SS),
     new Sample("Super speed (PlayReady)",
         "http://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
-        PlayerActivity.TYPE_SS),
+        Util.TYPE_SS),
   };
 
   private static final String WIDEVINE_GTS_MPD =
       "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd";
   public static final Sample[] WIDEVINE_GTS = new Sample[] {
     new Sample("WV: HDCP not specified", "d286538032258a1c", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP not required", "48fcc369939ac96c", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP required", "e06c39f1151da3df", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: Secure video path required (MP4,H264)", "0894c7c8719b28a0", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: Secure video path required (WebM,VP9)", "0894c7c8719b28a0", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure video path required (MP4,H265)", "0894c7c8719b28a0", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: HDCP + secure video path required", "efd045b1eb61888a", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: 30s license duration (fails at ~30s)", "f9a34cab7b05881a", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_HDCP = new Sample[] {
     new Sample("WV: HDCP: None (not required)", "HDCP_None", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP: 1.0 required", "HDCP_V1", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP: 2.0 required", "HDCP_V2", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP: 2.1 required", "HDCP_V2_1", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP: 2.2 required", "HDCP_V2_2", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
     new Sample("WV: HDCP: No digital output", "HDCP_NO_DIGTAL_OUTPUT", "widevine_test",
-        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+        WIDEVINE_GTS_MPD, Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_H264_MP4_CLEAR = new Sample[] {
     new Sample("WV: Clear SD & HD (MP4,H264)",
         "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear SD (MP4,H264)",
         "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_sd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear HD (MP4,H264)",
         "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_hd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear UHD (MP4,H264)",
         "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_uhd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_H264_MP4_SECURE = new Sample[] {
     new Sample("WV: Secure SD & HD (MP4,H264)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure SD (MP4,H264)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_sd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure HD (MP4,H264)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_hd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure UHD (MP4,H264)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_uhd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_VP9_WEBM_CLEAR = new Sample[] {
     new Sample("WV: Clear SD & HD (WebM,VP9)",
         "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear SD (WebM,VP9)",
         "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_sd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear HD (WebM,VP9)",
         "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_hd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear UHD (WebM,VP9)",
         "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_uhd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_VP9_WEBM_SECURE = new Sample[] {
     new Sample("WV: Secure SD & HD (WebM,VP9)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure SD (WebM,VP9)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_sd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure HD (WebM,VP9)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_hd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure UHD (WebM,VP9)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_uhd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_H265_MP4_CLEAR = new Sample[] {
     new Sample("WV: Clear SD & HD (MP4,H265)",
         "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear SD (MP4,H265)",
         "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_sd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear HD (MP4,H265)",
         "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_hd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Clear UHD (MP4,H265)",
         "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_uhd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
   };
 
   public static final Sample[] WIDEVINE_H265_MP4_SECURE = new Sample[] {
     new Sample("WV: Secure SD & HD (MP4,H265)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure SD (MP4,H265)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_sd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure HD (MP4,H265)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_hd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
     new Sample("WV: Secure UHD (MP4,H265)", "", "widevine_test",
         "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_uhd.mpd",
-        PlayerActivity.TYPE_DASH),
+        Util.TYPE_DASH),
   };
 
   public static final Sample[] HLS = new Sample[] {
     new Sample("Apple master playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/"
-        + "bipbop_4x3_variant.m3u8", PlayerActivity.TYPE_HLS),
+        + "bipbop_4x3_variant.m3u8", Util.TYPE_HLS),
     new Sample("Apple master playlist advanced",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_16x9/"
-        + "bipbop_16x9_variant.m3u8", PlayerActivity.TYPE_HLS),
+        + "bipbop_16x9_variant.m3u8", Util.TYPE_HLS),
     new Sample("Apple TS media playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/"
-        + "prog_index.m3u8", PlayerActivity.TYPE_HLS),
+        + "prog_index.m3u8", Util.TYPE_HLS),
     new Sample("Apple AAC media playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear0/"
-        + "prog_index.m3u8", PlayerActivity.TYPE_HLS),
+        + "prog_index.m3u8", Util.TYPE_HLS),
     new Sample("Apple ID3 metadata", "http://devimages.apple.com/samplecode/adDemo/ad.m3u8",
-        PlayerActivity.TYPE_HLS),
+        Util.TYPE_HLS),
   };
 
   public static final Sample[] MISC = new Sample[] {
-    new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4", PlayerActivity.TYPE_OTHER),
+    new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4", Util.TYPE_OTHER),
     new Sample("Apple AAC 10s", "https://devimages.apple.com.edgekey.net/"
-        + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac", PlayerActivity.TYPE_OTHER),
+        + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac", Util.TYPE_OTHER),
     new Sample("Apple TS 10s", "https://devimages.apple.com.edgekey.net/streaming/examples/"
-        + "bipbop_4x3/gear1/fileSequence0.ts", PlayerActivity.TYPE_OTHER),
+        + "bipbop_4x3/gear1/fileSequence0.ts", Util.TYPE_OTHER),
     new Sample("Android screens (Matroska)", "http://storage.googleapis.com/exoplayer-test-media-1/"
         + "mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
-        PlayerActivity.TYPE_OTHER),
+        Util.TYPE_OTHER),
     new Sample("Big Buck Bunny (MP4 Video)",
         "http://redirector.c.youtube.com/videoplayback?id=604ed5ce52eda7ee&itag=22&source=youtube&"
         + "sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature="
         + "513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300"
-        + "&key=ik0", PlayerActivity.TYPE_OTHER),
+        + "&key=ik0", Util.TYPE_OTHER),
     new Sample("Google Play (MP3 Audio)",
-        "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3", PlayerActivity.TYPE_OTHER),
+        "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3", Util.TYPE_OTHER),
     new Sample("Google Glass (WebM Video with Vorbis Audio)",
-        "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm", PlayerActivity.TYPE_OTHER),
+        "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm", Util.TYPE_OTHER),
     new Sample("Big Buck Bunny (FLV Video)",
-        "http://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0", PlayerActivity.TYPE_OTHER),
+        "http://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0", Util.TYPE_OTHER),
   };
 
   private Samples() {}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
index 3d2f24dd02..458f1d4d70 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioCapabilities;
@@ -47,6 +48,7 @@
 import com.google.android.exoplayer.util.Util;
 
 import android.content.Context;
+import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.os.Handler;
 import android.util.Log;
@@ -215,30 +217,31 @@ private void buildRenderers() {
       ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher,
           DefaultDashTrackSelector.newVideoInstance(context, true, filterHdContent),
           videoDataSource, new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS,
-          elapsedRealtimeOffset, mainHandler, player);
+          elapsedRealtimeOffset, mainHandler, player, DemoPlayer.TYPE_VIDEO);
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
           DemoPlayer.TYPE_VIDEO);
       TrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context, videoSampleSource,
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, drmSessionManager, true,
-          mainHandler, player, 50);
+          MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,
+          drmSessionManager, true, mainHandler, player, 50);
 
       // Build the audio renderer.
       DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource audioChunkSource = new DashChunkSource(manifestFetcher,
           DefaultDashTrackSelector.newAudioInstance(), audioDataSource, null, LIVE_EDGE_LATENCY_MS,
-          elapsedRealtimeOffset, mainHandler, player);
+          elapsedRealtimeOffset, mainHandler, player, DemoPlayer.TYPE_AUDIO);
       ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
           AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
           DemoPlayer.TYPE_AUDIO);
       TrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource,
-          drmSessionManager, true, mainHandler, player, AudioCapabilities.getCapabilities(context));
+          MediaCodecSelector.DEFAULT, drmSessionManager, true, mainHandler, player,
+          AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
 
       // Build the text renderer.
       DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource textChunkSource = new DashChunkSource(manifestFetcher,
           DefaultDashTrackSelector.newTextInstance(), textDataSource, null, LIVE_EDGE_LATENCY_MS,
-          elapsedRealtimeOffset, mainHandler, player);
+          elapsedRealtimeOffset, mainHandler, player, DemoPlayer.TYPE_TEXT);
       ChunkSampleSource textSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
           TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
           DemoPlayer.TYPE_TEXT);
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index 6f1e8b0e83..b22e204f3f 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -126,7 +126,7 @@ void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Form
         long mediaStartTimeMs, long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs);
     void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
         long initializationDurationMs);
-    void onAvailableRangeChanged(TimeRange availableRange);
+    void onAvailableRangeChanged(int sourceId, TimeRange availableRange);
   }
 
   /**
@@ -526,9 +526,9 @@ public void onMetadata(Map<String, Object> metadata) {
   }
 
   @Override
-  public void onAvailableRangeChanged(TimeRange availableRange) {
+  public void onAvailableRangeChanged(int sourceId, TimeRange availableRange) {
     if (infoListener != null) {
-      infoListener.onAvailableRangeChanged(availableRange);
+      infoListener.onAvailableRangeChanged(sourceId, availableRange);
     }
   }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
index faf39ab907..70cdf54717 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.demo.player;
 
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioCapabilities;
@@ -30,6 +31,7 @@
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 
 import android.content.Context;
+import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.net.Uri;
 
@@ -62,10 +64,11 @@ public void buildRenderers(DemoPlayer player) {
     ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, allocator,
         BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context,
-        sampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, player.getMainHandler(),
-        player, 50);
+        sampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,
+        player.getMainHandler(), player, 50);
     MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
-        null, true, player.getMainHandler(), player, AudioCapabilities.getCapabilities(context));
+        MediaCodecSelector.DEFAULT, null, true, player.getMainHandler(), player,
+        AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
     TrackRenderer textRenderer = new TextTrackRenderer(sampleSource, player,
         player.getMainHandler().getLooper());
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index 51475c9341..242faeace4 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -18,19 +18,21 @@
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioCapabilities;
-import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.hls.DefaultHlsTrackSelector;
 import com.google.android.exoplayer.hls.HlsChunkSource;
 import com.google.android.exoplayer.hls.HlsMasterPlaylist;
 import com.google.android.exoplayer.hls.HlsPlaylist;
 import com.google.android.exoplayer.hls.HlsPlaylistParser;
 import com.google.android.exoplayer.hls.HlsSampleSource;
+import com.google.android.exoplayer.hls.PtsTimestampAdjusterProvider;
 import com.google.android.exoplayer.metadata.Id3Parser;
 import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
+import com.google.android.exoplayer.text.TextTrackRenderer;
 import com.google.android.exoplayer.text.eia608.Eia608TrackRenderer;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DefaultAllocator;
@@ -40,6 +42,7 @@
 import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
 
 import android.content.Context;
+import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.os.Handler;
 
@@ -52,7 +55,8 @@
 public class HlsRendererBuilder implements RendererBuilder {
 
   private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
-  private static final int BUFFER_SEGMENTS = 256;
+  private static final int MAIN_BUFFER_SEGMENTS = 256;
+  private static final int TEXT_BUFFER_SEGMENTS = 2;
 
   private final Context context;
   private final String userAgent;
@@ -126,42 +130,47 @@ public void onSingleManifest(HlsPlaylist manifest) {
       Handler mainHandler = player.getMainHandler();
       LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
       DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+      PtsTimestampAdjusterProvider timestampAdjusterProvider = new PtsTimestampAdjusterProvider();
 
-      int[] variantIndices = null;
-      if (manifest instanceof HlsMasterPlaylist) {
-        HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) manifest;
-        try {
-          variantIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
-              context, masterPlaylist.variants, null, false);
-        } catch (DecoderQueryException e) {
-          player.onRenderersError(e);
-          return;
-        }
-        if (variantIndices.length == 0) {
-          player.onRenderersError(new IllegalStateException("No variants selected."));
-          return;
-        }
-      }
-
+      // Build the video/audio/metadata renderers.
       DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter,
-          variantIndices, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+      HlsChunkSource chunkSource = new HlsChunkSource(true /* isMaster */, dataSource, url,
+          manifest, DefaultHlsTrackSelector.newDefaultInstance(context), bandwidthMeter,
+          timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
       HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl,
-          BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_VIDEO);
+          MAIN_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_VIDEO);
       MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context,
-          sampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, mainHandler, player, 50);
+          sampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
+          5000, mainHandler, player, 50);
       MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
-          null, true, player.getMainHandler(), player, AudioCapabilities.getCapabilities(context));
+          MediaCodecSelector.DEFAULT, null, true, player.getMainHandler(), player,
+          AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
       MetadataTrackRenderer<Map<String, Object>> id3Renderer = new MetadataTrackRenderer<>(
           sampleSource, new Id3Parser(), player, mainHandler.getLooper());
-      Eia608TrackRenderer closedCaptionRenderer = new Eia608TrackRenderer(sampleSource, player,
-          mainHandler.getLooper());
+
+      // Build the text renderer, preferring Webvtt where available.
+      boolean preferWebvtt = false;
+      if (manifest instanceof HlsMasterPlaylist) {
+        preferWebvtt = !((HlsMasterPlaylist) manifest).subtitles.isEmpty();
+      }
+      TrackRenderer textRenderer;
+      if (preferWebvtt) {
+        DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        HlsChunkSource textChunkSource = new HlsChunkSource(false /* isMaster */, textDataSource,
+            url, manifest, DefaultHlsTrackSelector.newVttInstance(), bandwidthMeter,
+            timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+        HlsSampleSource textSampleSource = new HlsSampleSource(textChunkSource, loadControl,
+            TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_TEXT);
+        textRenderer = new TextTrackRenderer(textSampleSource, player, mainHandler.getLooper());
+      } else {
+        textRenderer = new Eia608TrackRenderer(sampleSource, player, mainHandler.getLooper());
+      }
 
       TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
       renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
       renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
       renderers[DemoPlayer.TYPE_METADATA] = id3Renderer;
-      renderers[DemoPlayer.TYPE_TEXT] = closedCaptionRenderer;
+      renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
       player.onRenderers(renderers, bandwidthMeter);
     }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
index 7e4211807d..bb769a833d 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioCapabilities;
@@ -32,7 +33,6 @@
 import com.google.android.exoplayer.smoothstreaming.DefaultSmoothStreamingTrackSelector;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingChunkSource;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifestParser;
 import com.google.android.exoplayer.text.TextTrackRenderer;
 import com.google.android.exoplayer.upstream.DataSource;
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer.util.Util;
 
 import android.content.Context;
+import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.os.Handler;
 
@@ -158,30 +159,31 @@ public void onSingleManifest(SmoothStreamingManifest manifest) {
       // Build the video renderer.
       DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-          new DefaultSmoothStreamingTrackSelector(context, StreamElement.TYPE_VIDEO),
+          DefaultSmoothStreamingTrackSelector.newVideoInstance(context, true, false),
           videoDataSource, new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
           DemoPlayer.TYPE_VIDEO);
       TrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context, videoSampleSource,
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, drmSessionManager, true, mainHandler,
-          player, 50);
+          MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,
+          drmSessionManager, true, mainHandler, player, 50);
 
       // Build the audio renderer.
       DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource audioChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-          new DefaultSmoothStreamingTrackSelector(context, StreamElement.TYPE_AUDIO),
+          DefaultSmoothStreamingTrackSelector.newAudioInstance(),
           audioDataSource, null, LIVE_EDGE_LATENCY_MS);
       ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
           AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
           DemoPlayer.TYPE_AUDIO);
       TrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource,
-          drmSessionManager, true, mainHandler, player, AudioCapabilities.getCapabilities(context));
+          MediaCodecSelector.DEFAULT, drmSessionManager, true, mainHandler, player,
+          AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
 
       // Build the text renderer.
       DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource textChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-          new DefaultSmoothStreamingTrackSelector(context, StreamElement.TYPE_TEXT),
+          DefaultSmoothStreamingTrackSelector.newTextInstance(),
           textDataSource, null, LIVE_EDGE_LATENCY_MS);
       ChunkSampleSource textSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
           TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
diff --git a/demo/src/main/res/layout/sample_chooser_activity.xml b/demo/src/main/res/layout/sample_chooser_activity.xml
index ae9be53796..4e78e6c700 100644
--- a/demo/src/main/res/layout/sample_chooser_activity.xml
+++ b/demo/src/main/res/layout/sample_chooser_activity.xml
@@ -18,7 +18,7 @@
     android:layout_height="match_parent"
     android:orientation="vertical">
 
-  <ListView android:id="@+id/sample_list"
+  <ExpandableListView android:id="@+id/sample_list"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
 
diff --git a/demo/src/main/res/layout/sample_chooser_inline_header.xml b/demo/src/main/res/layout/sample_chooser_inline_header.xml
index 8df32d76a1..e77803c771 100644
--- a/demo/src/main/res/layout/sample_chooser_inline_header.xml
+++ b/demo/src/main/res/layout/sample_chooser_inline_header.xml
@@ -20,6 +20,10 @@
     android:textAllCaps="true"
     android:textColor="@android:color/white"
     android:textSize="14sp"
-    android:padding="8dp"
-    android:focusable="true"
+    android:paddingStart="?android:attr/expandableListPreferredItemPaddingLeft"
+    android:paddingLeft="?android:attr/expandableListPreferredItemPaddingLeft"
+    android:paddingRight="8dp"
+    android:paddingEnd="8dp"
+    android:paddingTop="8dp"
+    android:paddingBottom="8dp"
     android:background="#339999FF"/>
diff --git a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
index 9824d7c1c5..d71f92db6c 100644
--- a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
+++ b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.vp9opus"
     android:versionCode="1503"
-    android:versionName="1.5.3"
+    android:versionName="1.5.4"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -44,14 +44,11 @@
       </intent-filter>
     </activity>
 
-    <activity android:name="com.google.android.exoplayer.demo.vp9opus.VideoPlayer"
+    <activity android:name=".PlayerActivity"
         android:configChanges="keyboardHidden|orientation|screenSize"
         android:label="@string/app_name"
         android:theme="@style/PlayerTheme"/>
 
-    <activity android:name="com.google.android.exoplayer.demo.vp9opus.FilePickerActivity"
-        android:theme="@android:style/Theme.Dialog"/>
-
   </application>
 
 </manifest>
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
index fc32d837a6..06d05070f9 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
@@ -56,9 +57,9 @@
 
   private final String manifestUrl;
   private final String userAgent;
-  private final VideoPlayer player;
+  private final PlayerActivity player;
 
-  public DashRendererBuilder(String manifestUrl, String userAgent, VideoPlayer player) {
+  public DashRendererBuilder(String manifestUrl, String userAgent, PlayerActivity player) {
     this.manifestUrl = manifestUrl;
     this.userAgent = userAgent;
     this.player = player;
@@ -133,7 +134,8 @@ public void onSingleManifest(MediaPresentationDescription manifest) {
       if (audioRepresentationIsOpus) {
         audioRenderer = new LibopusAudioTrackRenderer(audioSampleSource);
       } else {
-        audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource);
+        audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource,
+            MediaCodecSelector.DEFAULT);
       }
     }
 
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/FilePickerActivity.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/FilePickerActivity.java
deleted file mode 100644
index 61125b9eeb..0000000000
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/FilePickerActivity.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo.vp9opus;
-
-import android.app.Activity;
-import android.app.ListActivity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Environment;
-import android.view.View;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * A simple file picker.
- */
-public class FilePickerActivity extends ListActivity {
-
-  public static final String FILENAME_EXTRA_ID = "filename";
-
-  private List<String> listItems;
-  private List<File> itemPaths;
-  private TextView currentPathView;
-  private File root;
-
-  @Override
-  public void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.file_picker_activity);
-    setResult(Activity.RESULT_CANCELED);
-    currentPathView = (TextView) findViewById(R.id.path);
-    root = new File(Environment.getExternalStorageDirectory().getPath());
-    setDirectory(root);
-  }
-
-  private void setDirectory(File directory) {
-    currentPathView.setText(getString(R.string.current_path, directory.getAbsolutePath()));
-    listItems = new ArrayList<>();
-    itemPaths = new ArrayList<>();
-    File[] files = directory.listFiles();
-
-    if (!directory.getAbsolutePath().equals(root.getAbsolutePath())) {
-      listItems.add(root.getAbsolutePath());
-      itemPaths.add(root);
-      listItems.add("../");
-      itemPaths.add(new File(directory.getParent()));
-    }
-
-    if (files != null) {
-      for (File file : files) {
-        if (!file.isHidden() && file.canRead()) {
-          itemPaths.add(file);
-          if (file.isDirectory()) {
-            listItems.add(file.getName() + File.separator);
-          } else {
-            listItems.add(file.getName());
-          }
-        }
-      }
-    }
-
-    setListAdapter(new ArrayAdapter<>(this, R.layout.rows, listItems));
-  }
-
-  @Override
-  protected void onListItemClick(ListView l, View v, int position, long id) {
-    File file = itemPaths.get(position);
-    if (file.isDirectory() && file.canRead()) {
-      setDirectory(itemPaths.get(position));
-    } else {
-      Intent intent = new Intent();
-      intent.putExtra(FILENAME_EXTRA_ID, file.getAbsolutePath());
-      setResult(Activity.RESULT_OK, intent);
-      finish();
-    }
-  }
-}
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
similarity index 79%
rename from demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java
rename to demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
index 4733fc0f90..51e070e401 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
@@ -30,8 +30,11 @@
 import com.google.android.exoplayer.util.PlayerControl;
 import com.google.android.exoplayer.util.Util;
 
+import android.Manifest.permission;
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
@@ -39,32 +42,26 @@
 import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.View;
-import android.view.View.OnClickListener;
 import android.view.View.OnTouchListener;
-import android.widget.Button;
 import android.widget.MediaController;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import java.io.File;
-
 /**
  * Sample player that shows how to use ExoPlayer Extensions to playback VP9 Video and Opus Audio.
  */
-public class VideoPlayer extends Activity implements OnClickListener,
-       LibvpxVideoTrackRenderer.EventListener, ExoPlayer.Listener {
+public class PlayerActivity extends Activity implements
+    LibvpxVideoTrackRenderer.EventListener, ExoPlayer.Listener {
 
-  public static final String DASH_MANIFEST_URL_ID_EXTRA = "manifest_url";
-  public static final String USE_OPENGL_ID_EXTRA = "use_opengl";
+  /*package*/ static final String CONTENT_TYPE_EXTRA = "content_type";
+  /*package*/ static final String USE_OPENGL_ID_EXTRA = "use_opengl";
 
-  private static final int FILE_PICKER_REQUEST = 1;
   private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
   private static final int BUFFER_SEGMENT_COUNT = 160;
 
-  private boolean isDash;
-  private String manifestUrl;
+  private Uri contentUri;
+  private int contentType;
   private boolean useOpenGL;
-  private String filename;
 
   private ExoPlayer player;
   private Handler handler;
@@ -81,8 +78,9 @@ public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
 
     Intent intent = getIntent();
-    manifestUrl = intent.getStringExtra(DASH_MANIFEST_URL_ID_EXTRA);
-    isDash = manifestUrl != null;
+    contentUri = intent.getData();
+    contentType = intent.getIntExtra(CONTENT_TYPE_EXTRA,
+        Util.inferContentType(contentUri.toString()));
     useOpenGL = intent.getBooleanExtra(USE_OPENGL_ID_EXTRA, true);
 
     handler = new Handler();
@@ -109,16 +107,17 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
     debugInfoView = (TextView) findViewById(R.id.debug_info);
     debugInfo = "";
     playerState = "";
-    filename = "";
     updateDebugInfoTextView();
 
-    // Set the buttons' onclick listeners.
-    ((Button) findViewById(R.id.choose_file)).setOnClickListener(this);
-    ((Button) findViewById(R.id.play)).setOnClickListener(this);
+    if (!maybeRequestPermission()) {
+      startPlayback();
+    }
+  }
 
-    // In case of DASH, start playback right away.
-    if (isDash) {
-      findViewById(R.id.buttons).setVisibility(View.GONE);
+  private void startPlayback() {
+    if (contentType != Util.TYPE_DASH) {
+      startBasicPlayback();
+    } else {
       startDashPlayback();
     }
   }
@@ -129,51 +128,20 @@ public void onPause() {
     stopPlayback();
   }
 
-  @Override
-  public void onClick(View v) {
-    switch (v.getId()) {
-      case R.id.choose_file:
-        Intent intent = new Intent();
-        intent.setClass(this, FilePickerActivity.class);
-        startActivityForResult(intent, FILE_PICKER_REQUEST);
-        break;
-      case R.id.play:
-        startBasicPlayback();
-        break;
-    }
-  }
-
-  @Override
-  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-    switch (requestCode) {
-      case FILE_PICKER_REQUEST:
-        if (resultCode == Activity.RESULT_OK) {
-          filename = data.getStringExtra(FilePickerActivity.FILENAME_EXTRA_ID);
-          updateDebugInfoTextView();
-        }
-        break;
-    }
-  }
-
   private void startBasicPlayback() {
-    if (filename == null) {
-      Toast.makeText(this, "Choose a file!", Toast.LENGTH_SHORT).show();
-      return;
-    }
-    findViewById(R.id.buttons).setVisibility(View.GONE);
     player = ExoPlayer.Factory.newInstance(2);
     player.addListener(this);
     mediaController.setMediaPlayer(new PlayerControl(player));
     mediaController.setEnabled(true);
     ExtractorSampleSource sampleSource = new ExtractorSampleSource(
-        Uri.fromFile(new File(filename)),
+        contentUri,
         new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
         new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
         new WebmExtractor());
     TrackRenderer videoRenderer =
         new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
     if (useOpenGL) {
-      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
+      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
           vpxVideoSurfaceView);
       surfaceView.setVisibility(View.GONE);
     } else {
@@ -192,7 +160,8 @@ private void startDashPlayback() {
     updateDebugInfoTextView();
     final String userAgent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like"
         + " Gecko) Chrome/38.0.2125.104 Safari/537.36";
-    DashRendererBuilder rendererBuilder = new DashRendererBuilder(manifestUrl, userAgent, this);
+    DashRendererBuilder rendererBuilder = new DashRendererBuilder(contentUri.toString(),
+        userAgent, this);
     rendererBuilder.build();
   }
 
@@ -202,7 +171,7 @@ public void onRenderersBuilt(TrackRenderer[] renderers) {
     player.addListener(this);
     mediaController.setMediaPlayer(new PlayerControl(player));
     mediaController.setEnabled(true);
-    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
+    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
         vpxVideoSurfaceView);
     player.prepare(renderers);
     player.setPlayWhenReady(true);
@@ -269,6 +238,45 @@ public Handler getMainHandler() {
     return handler;
   }
 
+  // Permission management methods
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, String[] permissions,
+      int[] grantResults) {
+    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+      startPlayback();
+    } else {
+      Toast.makeText(getApplicationContext(), R.string.storage_permission_denied,
+          Toast.LENGTH_LONG).show();
+      finish();
+    }
+  }
+
+  /**
+   * Checks whether it is necessary to ask for permission to read storage. If necessary, it also
+   * requests permission.
+   *
+   * @return true if a permission request is made. False if it is not necessary.
+   */
+  @TargetApi(23)
+  private boolean maybeRequestPermission() {
+    if (requiresPermission(contentUri)) {
+      requestPermissions(new String[] {permission.READ_EXTERNAL_STORAGE}, 0);
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  @TargetApi(23)
+  private boolean requiresPermission(Uri uri) {
+    return Util.SDK_INT >= 23 && Util.isLocalFileUri(uri)
+        && checkSelfPermission(permission.READ_EXTERNAL_STORAGE)
+        != PackageManager.PERMISSION_GRANTED;
+  }
+
+  // Internal methods
+
   private void stopPlayback() {
     if (player != null) {
       player.stop();
@@ -277,7 +285,7 @@ private void stopPlayback() {
     }
   }
 
-  private void toggleControlsVisibility()  {
+  private void toggleControlsVisibility() {
     if (mediaController != null && player != null) {
       if (mediaController.isShowing()) {
         mediaController.hide();
@@ -295,7 +303,7 @@ private void updateDebugInfoTextView() {
     debugInfoText.append(
         getString(R.string.libopus_version, LibopusAudioTrackRenderer.getLibopusVersion()));
     debugInfoText.append("\n");
-    debugInfoText.append(getString(R.string.current_path, filename));
+    debugInfoText.append(getString(R.string.current_path, contentUri.toString()));
     debugInfoText.append(" ");
     debugInfoText.append(debugInfo);
     debugInfoText.append(" ");
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
index c03c815277..adf0ba1e31 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
@@ -15,9 +15,12 @@
  */
 package com.google.android.exoplayer.demo.vp9opus;
 
+import com.google.android.exoplayer.util.Util;
+
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.net.Uri;
 import android.os.Bundle;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -41,18 +44,18 @@ public void onCreate(Bundle savedInstanceState) {
     ListView sampleList = (ListView) findViewById(R.id.sample_list);
     final SampleAdapter sampleAdapter = new SampleAdapter(this);
 
-    sampleAdapter.add(new Header("Local VP9 Video only"));
-    sampleAdapter.add(new Sample("S/W Color Conversion - upto 720p", false));
-    sampleAdapter.add(new Sample("OpenGL", true));
     sampleAdapter.add(new Header("DASH - VP9 Only"));
     sampleAdapter.add(new Sample("Google Glass",
-          "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9.mpd"));
+        "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9.mpd",
+        Util.TYPE_DASH));
     sampleAdapter.add(new Header("DASH - VP9 and Opus"));
     sampleAdapter.add(new Sample("Google Glass",
-          "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_opus.mpd"));
+        "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_opus.mpd",
+        Util.TYPE_DASH));
     sampleAdapter.add(new Header("DASH - VP9 and Vorbis"));
     sampleAdapter.add(new Sample("Google Glass",
-          "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_vorbis.mpd"));
+        "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_vorbis.mpd",
+        Util.TYPE_DASH));
 
     sampleList.setAdapter(sampleAdapter);
     sampleList.setOnItemClickListener(new OnItemClickListener() {
@@ -67,9 +70,9 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
   }
 
   private void onSampleSelected(Sample sample) {
-    Intent playerIntent = new Intent(this, VideoPlayer.class)
-        .putExtra(VideoPlayer.DASH_MANIFEST_URL_ID_EXTRA, sample.uri)
-        .putExtra(VideoPlayer.USE_OPENGL_ID_EXTRA, sample.useOpenGL);
+    Intent playerIntent = new Intent(this, PlayerActivity.class)
+        .setData(Uri.parse(sample.uri))
+        .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, sample.type);
     startActivity(playerIntent);
   }
 
@@ -114,20 +117,12 @@ public int getViewTypeCount() {
 
     public final String description;
     public final String uri;
-    public final boolean useOpenGL;
-
-    public Sample(String description, boolean useOpenGL) {
-      this(description, null, useOpenGL);
-    }
-
-    public Sample(String description, String uri) {
-      this(description, uri, true); // always use OpenGL for DASH playbacks.
-    }
+    public final int type;
 
-    public Sample(String description, String uri, boolean useOpenGL) {
+    public Sample(String description, String uri, int type) {
       this.description = description;
       this.uri = uri;
-      this.useOpenGL = useOpenGL;
+      this.type = type;
     }
 
   }
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml b/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
index c6b2aea44d..176f28e6e6 100644
--- a/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
+++ b/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
@@ -40,33 +40,14 @@
   </com.google.android.exoplayer.AspectRatioFrameLayout>
 
   <LinearLayout
-      android:layout_width="wrap_content"
+      android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:orientation="vertical"
       android:background="#88000000">
 
-    <LinearLayout
-        android:id="@+id/buttons"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content">
-
-      <Button
-          android:id="@+id/choose_file"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:text="@string/choose_file"/>
-
-      <Button
-          android:id="@+id/play"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:text="@string/play"/>
-
-    </LinearLayout>
-
     <TextView
         android:id="@+id/debug_info"
-        android:layout_width="wrap_content"
+        android:layout_width="match_parent"
         android:layout_height="wrap_content"/>
 
   </LinearLayout>
diff --git a/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml b/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
index 6be85034cf..b12c865ebc 100644
--- a/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
+++ b/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
@@ -28,5 +28,6 @@
   <string name="libopus_version">
     Libopus: <xliff:g id="path">%1$s</xliff:g>
   </string>
+  <string name="storage_permission_denied">Permission to access storage was denied</string>
 
 </resources>
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 4d257c42e3..f7c3ce6256 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -36,7 +36,7 @@ android {
 
 dependencies {
     compile project(':library')
-    compile('com.squareup.okhttp:okhttp:2.5.0') {
+    compile('com.squareup.okhttp3:okhttp:+') {
         exclude group: 'org.json'
     }
 }
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
index 19e802e34e..6163655a63 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
@@ -22,13 +22,12 @@
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Predicate;
 
-import com.squareup.okhttp.CacheControl;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Util;
+import okhttp3.CacheControl;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -116,7 +115,7 @@ public OkHttpDataSource(OkHttpClient client, String userAgent,
 
   @Override
   public String getUri() {
-    return response == null ? null : response.request().urlString();
+    return response == null ? null : response.request().url().toString();
   }
 
   @Override
@@ -184,15 +183,10 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
-    try {
-      long contentLength = response.body().contentLength();
-      bytesToRead = dataSpec.length != C.LENGTH_UNBOUNDED ? dataSpec.length
-          : contentLength != -1 ? contentLength - bytesToSkip
-          : C.LENGTH_UNBOUNDED;
-    } catch (IOException e) {
-      closeConnectionQuietly();
-      throw new HttpDataSourceException(e, dataSpec);
-    }
+    long contentLength = response.body().contentLength();
+    bytesToRead = dataSpec.length != C.LENGTH_UNBOUNDED ? dataSpec.length
+        : contentLength != -1 ? contentLength - bytesToSkip
+        : C.LENGTH_UNBOUNDED;
 
     opened = true;
     if (listener != null) {
@@ -370,7 +364,7 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
    * Closes the current connection quietly, if there is one.
    */
   private void closeConnectionQuietly() {
-    Util.closeQuietly(response.body());
+    response.body().close();
     response = null;
     responseByteStream = null;
   }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index b5c3bd6295..acffce3f97 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.ext.opus;
 
+import com.google.android.exoplayer.CodecCounters;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.MediaClock;
@@ -75,6 +76,8 @@
    */
   public static final int MSG_SET_VOLUME = 1;
 
+  public final CodecCounters codecCounters = new CodecCounters();
+
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final MediaFormatHolder formatHolder;
@@ -142,19 +145,11 @@ protected boolean handlesTrack(MediaFormat mediaFormat) {
   }
 
   @Override
-  protected void onEnabled(int track, long positionUs, boolean joining)
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
       throws ExoPlaybackException {
-    super.onEnabled(track, positionUs, joining);
-    seekToInternal(positionUs);
-  }
-
-  @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
       return;
     }
-    sourceIsReady = continueBufferingSource(positionUs);
-    checkForDiscontinuity(positionUs);
 
     // Try and read a format if we don't have one already.
     if (format == null && !readFormat(positionUs)) {
@@ -191,6 +186,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
         throw new ExoPlaybackException(e);
       }
       decoder.start();
+      codecCounters.codecInitCount++;
     }
 
     // Rendering loop.
@@ -207,6 +203,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
       notifyDecoderError(e);
       throw new ExoPlaybackException(e);
     }
+    codecCounters.ensureUpdated();
   }
 
   private void renderBuffer() throws OpusDecoderException, AudioTrack.InitializationException,
@@ -253,6 +250,7 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
     // Release the buffer if it was consumed.
     if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
       decoder.releaseOutputBuffer(outputBuffer);
+      codecCounters.renderedOutputBufferCount++;
       outputBuffer = null;
     }
   }
@@ -269,14 +267,10 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
       }
     }
 
-    int result = readSource(positionUs, formatHolder, inputBuffer.sampleHolder, false);
+    int result = readSource(positionUs, formatHolder, inputBuffer.sampleHolder);
     if (result == SampleSource.NOTHING_READ) {
       return false;
     }
-    if (result == SampleSource.DISCONTINUITY_READ) {
-      flushDecoder();
-      return true;
-    }
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
       return true;
@@ -298,16 +292,6 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
     return true;
   }
 
-  private void checkForDiscontinuity(long positionUs) {
-    if (decoder == null) {
-      return;
-    }
-    int result = readSource(positionUs, formatHolder, null, true);
-    if (result == SampleSource.DISCONTINUITY_READ) {
-      flushDecoder();
-    }
-  }
-
   private void flushDecoder() {
     inputBuffer = null;
     outputBuffer = null;
@@ -338,18 +322,16 @@ public long getPositionUs() {
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal(positionUs);
-  }
-
-  private void seekToInternal(long positionUs) {
+  protected void onDiscontinuity(long positionUs) {
     audioTrack.reset();
     currentPositionUs = positionUs;
     allowPositionDiscontinuity = true;
     inputStreamEnded = false;
     outputStreamEnded = false;
     sourceIsReady = false;
+    if (decoder != null) {
+      flushDecoder();
+    }
   }
 
   @Override
@@ -372,6 +354,7 @@ protected void onDisabled() throws ExoPlaybackException {
       if (decoder != null) {
         decoder.release();
         decoder = null;
+        codecCounters.codecReleaseCount++;
       }
       audioTrack.release();
     } finally {
@@ -380,7 +363,7 @@ protected void onDisabled() throws ExoPlaybackException {
   }
 
   private boolean readFormat(long positionUs) {
-    int result = readSource(positionUs, formatHolder, null, false);
+    int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
       audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index 8fb2b21199..d63da51700 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -50,7 +50,7 @@ public OpusDecoder(OpusHeader opusHeader) throws OpusDecoderException {
         opusHeader.sampleRate, opusHeader.channelCount, opusHeader.numStreams,
         opusHeader.numCoupled, opusHeader.gain, opusHeader.streamMap);
     if (nativeDecoderContext == 0) {
-      throw new OpusDecoderException("failed to initialize opus decoder");
+      throw new OpusDecoderException("Failed to initialize decoder");
     }
   }
 
@@ -68,7 +68,7 @@ public int decode(ByteBuffer inputBuffer, int inputSize, ByteBuffer outputBuffer
       int outputSize) throws OpusDecoderException {
     int result = opusDecode(nativeDecoderContext, inputBuffer, inputSize, outputBuffer, outputSize);
     if (result < 0) {
-      throw new OpusDecoderException(opusGetErrorMessage(result));
+      throw new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
     }
     return result;
   }
diff --git a/extensions/opus/src/main/proguard.cfg b/extensions/opus/src/main/proguard.cfg
new file mode 100644
index 0000000000..15e910b1e9
--- /dev/null
+++ b/extensions/opus/src/main/proguard.cfg
@@ -0,0 +1,6 @@
+# Proguard rules specific to the Opus extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
diff --git a/extensions/vp9/src/androidTest/.classpath b/extensions/vp9/src/androidTest/.classpath
new file mode 100644
index 0000000000..5b30f3b49b
--- /dev/null
+++ b/extensions/vp9/src/androidTest/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/ExoPlayerExt-VP9"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/vp9/src/androidTest/.project b/extensions/vp9/src/androidTest/.project
new file mode 100644
index 0000000000..8e0bfa4eb9
--- /dev/null
+++ b/extensions/vp9/src/androidTest/.project
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-VP9Tests</name>
+	<comment></comment>
+	<projects>
+		<project>ExoPlayerLib</project>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>0</id>
+			<name></name>
+			<type>14</type>
+			<matcher>
+				<id>org.eclipse.ui.ide.multiFilter</id>
+				<arguments>1.0-name-matches-true-false-BUILD</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/file_picker_activity.xml b/extensions/vp9/src/androidTest/AndroidManifest.xml
similarity index 53%
rename from demo_misc/vp9_opus_sw/src/main/res/layout/file_picker_activity.xml
rename to extensions/vp9/src/androidTest/AndroidManifest.xml
index a478458d9a..a2859b3c3c 100644
--- a/demo_misc/vp9_opus_sw/src/main/res/layout/file_picker_activity.xml
+++ b/extensions/vp9/src/androidTest/AndroidManifest.xml
@@ -13,20 +13,22 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical">
+    package="com.google.android.exoplayer.ext.vp9.test">
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
-    <TextView
-        android:id="@+id/path"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"/>
+  <application android:debuggable="true"
+      android:allowBackup="false"
+      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
+    <uses-library android:name="android.test.runner"/>
+  </application>
 
-    <ListView
-        android:id="@android:id/list"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"/>
+  <instrumentation
+      android:targetPackage="com.google.android.exoplayer.ext.vp9.test"
+      android:name="android.test.InstrumentationTestRunner"
+      tools:replace="android:targetPackage"/>
 
-</LinearLayout>
+</manifest>
diff --git a/extensions/vp9/src/androidTest/assets/bear-vp9-odd-dimensions.webm b/extensions/vp9/src/androidTest/assets/bear-vp9-odd-dimensions.webm
new file mode 100644
index 0000000000..4d65a906fa
Binary files /dev/null and b/extensions/vp9/src/androidTest/assets/bear-vp9-odd-dimensions.webm differ
diff --git a/extensions/vp9/src/androidTest/assets/bear-vp9.webm b/extensions/vp9/src/androidTest/assets/bear-vp9.webm
new file mode 100644
index 0000000000..4f497aeb34
Binary files /dev/null and b/extensions/vp9/src/androidTest/assets/bear-vp9.webm differ
diff --git a/extensions/vp9/src/androidTest/assets/invalid-bitstream.webm b/extensions/vp9/src/androidTest/assets/invalid-bitstream.webm
new file mode 100644
index 0000000000..7763cb452f
Binary files /dev/null and b/extensions/vp9/src/androidTest/assets/invalid-bitstream.webm differ
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer/ext/vp9/VpxPlaybackTest.java
new file mode 100644
index 0000000000..a13580a3f7
--- /dev/null
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer/ext/vp9/VpxPlaybackTest.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.webm.WebmExtractor;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
+import com.google.android.exoplayer.util.Util;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.Looper;
+import android.test.InstrumentationTestCase;
+
+/**
+ * Playback tests using {@link LibvpxVideoTrackRenderer}.
+ */
+public class VpxPlaybackTest extends InstrumentationTestCase {
+
+  private static final String BEAR_URI = "asset:///bear-vp9.webm";
+  private static final String BEAR_ODD_DIMENSIONS_URI = "asset:///bear-vp9-odd-dimensions.webm";
+  private static final String INVALID_BITSTREAM_URI = "asset:///invalid-bitstream.webm";
+
+  public void testBasicPlayback() throws ExoPlaybackException {
+    playUri(BEAR_URI);
+  }
+
+  public void testOddDimensionsPlayback() throws ExoPlaybackException {
+    playUri(BEAR_ODD_DIMENSIONS_URI);
+  }
+
+  public void testInvalidBitstream() {
+    try {
+      playUri(INVALID_BITSTREAM_URI);
+      fail();
+    } catch (Exception e) {
+      assertNotNull(e.getCause());
+      assertTrue(e.getCause() instanceof VpxDecoderException);
+    }
+  }
+
+  private void playUri(String uri) throws ExoPlaybackException {
+    TestPlaybackThread thread = new TestPlaybackThread(Uri.parse(uri),
+        getInstrumentation().getContext());
+    thread.start();
+    try {
+      thread.join();
+    } catch (InterruptedException e) {
+      fail(); // Should never happen.
+    }
+    if (thread.playbackException != null) {
+      throw thread.playbackException;
+    }
+  }
+
+  private static class TestPlaybackThread extends Thread implements ExoPlayer.Listener {
+
+    private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+    private static final int BUFFER_SEGMENT_COUNT = 16;
+
+    private final Context context;
+    private final Uri uri;
+
+    private ExoPlayer player;
+    private ExoPlaybackException playbackException;
+
+    public TestPlaybackThread(Uri uri, Context context) {
+      this.uri = uri;
+      this.context = context;
+    }
+
+    @Override
+    public void run() {
+      Looper.prepare();
+      player = ExoPlayer.Factory.newInstance(1);
+      player.addListener(this);
+      ExtractorSampleSource  sampleSource = new ExtractorSampleSource(
+          uri, new DefaultUriDataSource(context, Util.getUserAgent(context, "ExoPlayerExtVP9Test")),
+          new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
+          new WebmExtractor());
+      LibvpxVideoTrackRenderer videoRenderer = new LibvpxVideoTrackRenderer(sampleSource, true);
+      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
+          new VpxVideoSurfaceView(context));
+      player.prepare(videoRenderer);
+      player.setPlayWhenReady(true);
+      Looper.loop();
+    }
+
+    @Override
+    public void onPlayWhenReadyCommitted () {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException error) {
+      playbackException = error;
+    }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (playbackState == ExoPlayer.STATE_ENDED
+          || (playbackState == ExoPlayer.STATE_IDLE && playbackException != null)) {
+        releasePlayerAndQuitLooper();
+      }
+    }
+
+    private void releasePlayerAndQuitLooper() {
+      player.release();
+      Looper.myLooper().quit();
+    }
+
+  }
+
+}
diff --git a/extensions/vp9/src/androidTest/project.properties b/extensions/vp9/src/androidTest/project.properties
new file mode 100644
index 0000000000..916037e334
--- /dev/null
+++ b/extensions/vp9/src/androidTest/project.properties
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-23
diff --git a/extensions/vp9/src/androidTest/res/.README.txt b/extensions/vp9/src/androidTest/res/.README.txt
new file mode 100644
index 0000000000..c27147ce56
--- /dev/null
+++ b/extensions/vp9/src/androidTest/res/.README.txt
@@ -0,0 +1,2 @@
+This file is needed to make sure the res directory is present.
+The file is ignored by the Android toolchain because its name starts with a dot.
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index fd2d0579e4..f20f877c5a 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -23,8 +23,7 @@
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.SampleSourceTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.InputBuffer;
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
+import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.VpxInputBuffer;
 import com.google.android.exoplayer.util.MimeTypes;
 
 import android.graphics.Bitmap;
@@ -88,7 +87,12 @@
    * should be the target {@link Surface}, or null.
    */
   public static final int MSG_SET_SURFACE = 1;
-  public static final int MSG_SET_VPX_SURFACE_VIEW = 2;
+  /**
+   * The type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be the target {@link VpxOutputBufferRenderer}, or null.
+   */
+  public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = 2;
 
   public final CodecCounters codecCounters = new CodecCounters();
 
@@ -100,14 +104,14 @@
 
   private MediaFormat format;
   private VpxDecoderWrapper decoder;
-  private InputBuffer inputBuffer;
-  private OutputBuffer outputBuffer;
+  private VpxInputBuffer inputBuffer;
+  private VpxOutputBuffer outputBuffer;
 
   private Bitmap bitmap;
   private boolean drawnToSurface;
   private boolean renderedFirstFrame;
   private Surface surface;
-  private VpxVideoSurfaceView vpxVideoSurfaceView;
+  private VpxOutputBufferRenderer outputBufferRenderer;
   private int outputMode;
 
   private boolean inputStreamEnded;
@@ -171,12 +175,11 @@ protected boolean handlesTrack(MediaFormat mediaFormat) {
   }
 
   @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
     if (outputStreamEnded) {
       return;
     }
-    sourceIsReady = continueBufferingSource(positionUs);
-    checkForDiscontinuity(positionUs);
 
     // Try and read a format if we don't have one already.
     if (format == null && !readFormat(positionUs)) {
@@ -188,6 +191,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     if (decoder == null) {
       decoder = new VpxDecoderWrapper(outputMode);
       decoder.start();
+      codecCounters.codecInitCount++;
     }
 
     // Rendering loop.
@@ -198,6 +202,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
       notifyDecoderError(e);
       throw new ExoPlaybackException(e);
     }
+    codecCounters.ensureUpdated();
   }
 
   private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
@@ -215,7 +220,8 @@ private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
 
     if (outputBuffer.flags == VpxDecoderWrapper.FLAG_END_OF_STREAM) {
       outputStreamEnded = true;
-      releaseOutputBuffer();
+      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer = null;
       return;
     }
 
@@ -229,7 +235,8 @@ private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
       if (droppedFrameCount == maxDroppedFrameCountToNotify) {
         notifyAndResetDroppedFrameCount();
       }
-      releaseOutputBuffer();
+      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer = null;
       return;
     }
 
@@ -257,7 +264,7 @@ private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
     renderBuffer();
   }
 
-  private void renderBuffer() throws VpxDecoderException {
+  private void renderBuffer() {
     codecCounters.renderedOutputBufferCount++;
     notifyIfVideoSizeChanged(outputBuffer);
     if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_RGB && surface != null) {
@@ -266,18 +273,17 @@ private void renderBuffer() throws VpxDecoderException {
         drawnToSurface = true;
         notifyDrawnToSurface(surface);
       }
-    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && vpxVideoSurfaceView != null) {
-      vpxVideoSurfaceView.renderFrame(outputBuffer);
+      outputBuffer.release();
+    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null) {
+      // The renderer will release the buffer.
+      outputBufferRenderer.setOutputBuffer(outputBuffer);
+    } else {
+      outputBuffer.release();
     }
-    releaseOutputBuffer();
-  }
-
-  private void releaseOutputBuffer() throws VpxDecoderException {
-    decoder.releaseOutputBuffer(outputBuffer);
     outputBuffer = null;
   }
 
-  private void renderRgbFrame(OutputBuffer outputBuffer, boolean scale) {
+  private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
     if (bitmap == null || bitmap.getWidth() != outputBuffer.width
         || bitmap.getHeight() != outputBuffer.height) {
       bitmap = Bitmap.createBitmap(outputBuffer.width, outputBuffer.height, Bitmap.Config.RGB_565);
@@ -304,15 +310,10 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
       }
     }
 
-    int result = readSource(positionUs, formatHolder, inputBuffer.sampleHolder,
-        false);
+    int result = readSource(positionUs, formatHolder, inputBuffer.sampleHolder);
     if (result == SampleSource.NOTHING_READ) {
       return false;
     }
-    if (result == SampleSource.DISCONTINUITY_READ) {
-      flushDecoder();
-      return true;
-    }
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
       return true;
@@ -332,19 +333,12 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
     return true;
   }
 
-  private void checkForDiscontinuity(long positionUs) {
-    if (decoder == null) {
-      return;
-    }
-    int result = readSource(positionUs, formatHolder, null, true);
-    if (result == SampleSource.DISCONTINUITY_READ) {
-      flushDecoder();
-    }
-  }
-
   private void flushDecoder() {
     inputBuffer = null;
-    outputBuffer = null;
+    if (outputBuffer != null) {
+      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer = null;
+    }
     decoder.flush();
   }
 
@@ -355,27 +349,18 @@ protected boolean isEnded() {
 
   @Override
   protected boolean isReady() {
-    return format != null && (sourceIsReady || outputBuffer != null);
-  }
-
-  @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal();
+    return format != null && (sourceIsReady || outputBuffer != null) && renderedFirstFrame;
   }
 
   @Override
-  protected void onEnabled(int track, long positionUs, boolean joining)
-      throws ExoPlaybackException {
-    super.onEnabled(track, positionUs, joining);
-    seekToInternal();
-  }
-
-  private void seekToInternal() {
+  protected void onDiscontinuity(long positionUs) {
     sourceIsReady = false;
     inputStreamEnded = false;
     outputStreamEnded = false;
     renderedFirstFrame = false;
+    if (decoder != null) {
+      flushDecoder();
+    }
   }
 
   @Override
@@ -398,6 +383,7 @@ protected void onDisabled() throws ExoPlaybackException {
       if (decoder != null) {
         decoder.release();
         decoder = null;
+        codecCounters.codecReleaseCount++;
       }
     } finally {
       super.onDisabled();
@@ -405,7 +391,7 @@ protected void onDisabled() throws ExoPlaybackException {
   }
 
   private boolean readFormat(long positionUs) {
-    int result = readSource(positionUs, formatHolder, null, false);
+    int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
       return true;
@@ -417,8 +403,8 @@ private boolean readFormat(long positionUs) {
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     if (messageType == MSG_SET_SURFACE) {
       setSurface((Surface) message);
-    } else if (messageType == MSG_SET_VPX_SURFACE_VIEW) {
-      setVpxVideoSurfaceView((VpxVideoSurfaceView) message);
+    } else if (messageType == MSG_SET_OUTPUT_BUFFER_RENDERER) {
+      setOutputBufferRenderer((VpxOutputBufferRenderer) message);
     } else {
       super.handleMessage(messageType, message);
     }
@@ -429,7 +415,7 @@ private void setSurface(Surface surface) {
       return;
     }
     this.surface = surface;
-    vpxVideoSurfaceView = null;
+    outputBufferRenderer = null;
     outputMode = (surface != null) ? VpxDecoder.OUTPUT_MODE_RGB : VpxDecoder.OUTPUT_MODE_UNKNOWN;
     if (decoder != null) {
       decoder.setOutputMode(outputMode);
@@ -437,20 +423,20 @@ private void setSurface(Surface surface) {
     drawnToSurface = false;
   }
 
-  private void setVpxVideoSurfaceView(VpxVideoSurfaceView vpxVideoSurfaceView) {
-    if (this.vpxVideoSurfaceView == vpxVideoSurfaceView) {
+  private void setOutputBufferRenderer(VpxOutputBufferRenderer outputBufferRenderer) {
+    if (this.outputBufferRenderer == outputBufferRenderer) {
       return;
     }
-    this.vpxVideoSurfaceView = vpxVideoSurfaceView;
+    this.outputBufferRenderer = outputBufferRenderer;
     surface = null;
-    outputMode =
-        (vpxVideoSurfaceView != null) ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
+    outputMode = (outputBufferRenderer != null)
+        ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
     if (decoder != null) {
       decoder.setOutputMode(outputMode);
     }
   }
 
-  private void notifyIfVideoSizeChanged(final OutputBuffer outputBuffer) {
+  private void notifyIfVideoSizeChanged(final VpxOutputBuffer outputBuffer) {
     if (previousWidth == -1 || previousHeight == -1
         || previousWidth != outputBuffer.width || previousHeight != outputBuffer.height) {
       previousWidth = outputBuffer.width;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 954304d0cd..3e54003633 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
-
 import java.nio.ByteBuffer;
 
 /**
@@ -51,7 +49,7 @@
   public VpxDecoder() throws VpxDecoderException {
     vpxDecContext = vpxInit();
     if (vpxDecContext == 0) {
-      throw new VpxDecoderException("libvpx initialization error: failed to initialize decoder");
+      throw new VpxDecoderException("Failed to initialize decoder");
     }
   }
 
@@ -64,10 +62,10 @@ public VpxDecoder() throws VpxDecoderException {
    * @return 0 on success with a frame to render. 1 on success without a frame to render.
    * @throws VpxDecoderException on decode failure.
    */
-  public int decode(ByteBuffer encoded, int size, OutputBuffer outputBuffer)
+  public int decode(ByteBuffer encoded, int size, VpxOutputBuffer outputBuffer)
       throws VpxDecoderException {
     if (vpxDecode(vpxDecContext, encoded, size) != 0) {
-      throw new VpxDecoderException("libvpx decode error: " + vpxGetErrorMessage(vpxDecContext));
+      throw new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
     }
     return vpxGetFrame(vpxDecContext, outputBuffer);
   }
@@ -94,7 +92,7 @@ public static boolean isLibvpxAvailable() {
   private native long vpxInit();
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
-  private native int vpxGetFrame(long context, OutputBuffer outputBuffer);
+  private native int vpxGetFrame(long context, VpxOutputBuffer outputBuffer);
   private native String vpxGetErrorMessage(long context);
 
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
index 5999244da7..5dff64a846 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.ext.vp9;
 
 import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.Assertions;
 
 import java.nio.ByteBuffer;
 import java.util.LinkedList;
@@ -23,23 +24,27 @@
 /**
  * Wraps {@link VpxDecoder}, exposing a higher level decoder interface.
  */
-/* package */ class VpxDecoderWrapper extends Thread {
+/* package */ final class VpxDecoderWrapper extends Thread {
 
   public static final int FLAG_END_OF_STREAM = 1;
 
   private static final int INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
+  /**
+   * The number of input buffers and the number of output buffers. The track renderer may limit the
+   * minimum possible value due to requiring multiple output buffers to be dequeued at a time for it
+   * to make progress.
+   */
   private static final int NUM_BUFFERS = 16;
 
   private final Object lock;
 
-  private final LinkedList<InputBuffer> dequeuedInputBuffers;
-  private final LinkedList<InputBuffer> queuedInputBuffers;
-  private final LinkedList<OutputBuffer> queuedOutputBuffers;
-  private final LinkedList<OutputBuffer> dequeuedOutputBuffers;
-  private final InputBuffer[] availableInputBuffers;
-  private final OutputBuffer[] availableOutputBuffers;
+  private final LinkedList<VpxInputBuffer> queuedInputBuffers;
+  private final LinkedList<VpxOutputBuffer> queuedOutputBuffers;
+  private final VpxInputBuffer[] availableInputBuffers;
+  private final VpxOutputBuffer[] availableOutputBuffers;
   private int availableInputBufferCount;
   private int availableOutputBufferCount;
+  private VpxInputBuffer dequeuedInputBuffer;
 
   private boolean flushDecodedOutputBuffer;
   private boolean released;
@@ -54,17 +59,15 @@
   public VpxDecoderWrapper(int outputMode) {
     lock = new Object();
     this.outputMode = outputMode;
-    dequeuedInputBuffers = new LinkedList<>();
     queuedInputBuffers = new LinkedList<>();
     queuedOutputBuffers = new LinkedList<>();
-    dequeuedOutputBuffers = new LinkedList<>();
-    availableInputBuffers = new InputBuffer[NUM_BUFFERS];
-    availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
+    availableInputBuffers = new VpxInputBuffer[NUM_BUFFERS];
+    availableOutputBuffers = new VpxOutputBuffer[NUM_BUFFERS];
     availableInputBufferCount = NUM_BUFFERS;
     availableOutputBufferCount = NUM_BUFFERS;
     for (int i = 0; i < NUM_BUFFERS; i++) {
-      availableInputBuffers[i] = new InputBuffer();
-      availableOutputBuffers[i] = new OutputBuffer();
+      availableInputBuffers[i] = new VpxInputBuffer();
+      availableOutputBuffers[i] = new VpxOutputBuffer(this);
     }
   }
 
@@ -72,55 +75,59 @@ public void setOutputMode(int outputMode) {
     this.outputMode = outputMode;
   }
 
-  public InputBuffer dequeueInputBuffer() throws VpxDecoderException {
+  public VpxInputBuffer dequeueInputBuffer() throws VpxDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
+      Assertions.checkState(dequeuedInputBuffer == null);
       if (availableInputBufferCount == 0) {
         return null;
       }
-      InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
+      VpxInputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
       inputBuffer.flags = 0;
       inputBuffer.sampleHolder.clearData();
-      dequeuedInputBuffers.addLast(inputBuffer);
+      dequeuedInputBuffer = inputBuffer;
       return inputBuffer;
     }
   }
 
-  public void queueInputBuffer(InputBuffer inputBuffer) throws VpxDecoderException {
+  public void queueInputBuffer(VpxInputBuffer inputBuffer) throws VpxDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
-      dequeuedInputBuffers.remove(inputBuffer);
+      Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
       queuedInputBuffers.addLast(inputBuffer);
       maybeNotifyDecodeLoop();
+      dequeuedInputBuffer = null;
     }
   }
 
-  public OutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
+  public VpxOutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
       if (queuedOutputBuffers.isEmpty()) {
         return null;
       }
-      OutputBuffer outputBuffer = queuedOutputBuffers.removeFirst();
-      dequeuedOutputBuffers.add(outputBuffer);
-      return outputBuffer;
+      return queuedOutputBuffers.removeFirst();
     }
   }
 
-  public void releaseOutputBuffer(OutputBuffer outputBuffer) throws VpxDecoderException {
+  public void releaseOutputBuffer(VpxOutputBuffer outputBuffer) {
     synchronized (lock) {
-      maybeThrowDecoderError();
-      dequeuedOutputBuffers.remove(outputBuffer);
       availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
       maybeNotifyDecodeLoop();
     }
   }
 
+  /**
+   * Flushes input/output buffers that have not been dequeued yet and returns ownership of any
+   * dequeued input buffer to the decoder. Flushes any pending output currently in the decoder. The
+   * caller is still responsible for releasing any dequeued output buffers.
+   */
   public void flush() {
     synchronized (lock) {
       flushDecodedOutputBuffer = true;
-      while (!dequeuedInputBuffers.isEmpty()) {
-        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffers.removeFirst();
+      if (dequeuedInputBuffer != null) {
+        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffer;
+        dequeuedInputBuffer = null;
       }
       while (!queuedInputBuffers.isEmpty()) {
         availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
@@ -128,9 +135,6 @@ public void flush() {
       while (!queuedOutputBuffers.isEmpty()) {
         availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
       }
-      while (!dequeuedOutputBuffers.isEmpty()) {
-        availableOutputBuffers[availableOutputBufferCount++] = dequeuedOutputBuffers.removeFirst();
-      }
     }
   }
 
@@ -159,7 +163,7 @@ private void maybeThrowDecoderError() throws VpxDecoderException {
    * Should only be called whilst synchronized on the lock object.
    */
   private void maybeNotifyDecodeLoop() {
-    if (!queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0) {
+    if (canDecodeBuffer()) {
       lock.notify();
     }
   }
@@ -187,12 +191,12 @@ public void run() {
 
   private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
       VpxDecoderException {
-    InputBuffer inputBuffer;
-    OutputBuffer outputBuffer;
+    VpxInputBuffer inputBuffer;
+    VpxOutputBuffer outputBuffer;
 
     // Wait until we have an input buffer to decode, and an output buffer to decode into.
     synchronized (lock) {
-      while (!released && (queuedInputBuffers.isEmpty() || availableOutputBufferCount == 0)) {
+      while (!released && !canDecodeBuffer()) {
         lock.wait();
       }
       if (released) {
@@ -238,7 +242,11 @@ private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
     return true;
   }
 
-  /* package */ static final class InputBuffer {
+  private boolean canDecodeBuffer() {
+    return !queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0;
+  }
+
+  /* package */ static final class VpxInputBuffer {
 
     public final SampleHolder sampleHolder;
 
@@ -246,75 +254,11 @@ private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
     public int height;
     public int flags;
 
-    public InputBuffer() {
+    public VpxInputBuffer() {
       sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
       sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
     }
 
   }
 
-  /* package */ static final class OutputBuffer {
-
-    public ByteBuffer data;
-    public long timestampUs;
-    public int width;
-    public int height;
-    public int flags;
-    public ByteBuffer[] yuvPlanes;
-    public int[] yuvStrides;
-    public int mode;
-
-    /**
-     * This method is called from C++ through JNI after decoding is done. It will resize the
-     * buffer based on the given dimensions.
-     */
-    public void initForRgbFrame(int width, int height) {
-      this.width = width;
-      this.height = height;
-      int minimumRgbSize = width * height * 2;
-      if (data == null || data.capacity() < minimumRgbSize) {
-        data = ByteBuffer.allocateDirect(minimumRgbSize);
-        yuvPlanes = null;
-      }
-      data.position(0);
-      data.limit(minimumRgbSize);
-    }
-
-    /**
-     * This method is called from C++ through JNI after decoding is done. It will resize the
-     * buffer based on the given stride.
-     */
-    public void initForYuvFrame(int width, int height, int yStride, int uvStride) {
-      this.width = width;
-      this.height = height;
-      int yLength = yStride * height;
-      int uvLength = uvStride * ((height + 1) / 2);
-      int minimumYuvSize = yLength + (uvLength * 2);
-      if (data == null || data.capacity() < minimumYuvSize) {
-        data = ByteBuffer.allocateDirect(minimumYuvSize);
-      }
-      data.limit(minimumYuvSize);
-      if (yuvPlanes == null) {
-        yuvPlanes = new ByteBuffer[3];
-      }
-      // Rewrapping has to be done on every frame since the stride might have changed.
-      data.position(0);
-      yuvPlanes[0] = data.slice();
-      yuvPlanes[0].limit(yLength);
-      data.position(yLength);
-      yuvPlanes[1] = data.slice();
-      yuvPlanes[1].limit(uvLength);
-      data.position(yLength + uvLength);
-      yuvPlanes[2] = data.slice();
-      yuvPlanes[2].limit(uvLength);
-      if (yuvStrides == null) {
-        yuvStrides = new int[3];
-      }
-      yuvStrides[0] = yStride;
-      yuvStrides[1] = uvStride;
-      yuvStrides[2] = uvStride;
-    }
-
-  }
-
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
new file mode 100644
index 0000000000..1a2b40a069
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import java.nio.ByteBuffer;
+
+/**
+ * OutputBuffer for storing the video frame.
+ */
+public final class VpxOutputBuffer {
+
+  public static final int COLORSPACE_UNKNOWN = 0;
+  public static final int COLORSPACE_BT601 = 1;
+  public static final int COLORSPACE_BT709 = 2;
+
+  private final VpxDecoderWrapper decoder;
+
+  /* package */ VpxOutputBuffer(VpxDecoderWrapper decoder) {
+    this.decoder = decoder;
+  }
+
+  /**
+   * RGB buffer for RGB mode.
+   */
+  public ByteBuffer data;
+  public long timestampUs;
+  public int width;
+  public int height;
+  public int flags;
+  /**
+   * YUV planes for YUV mode.
+   */
+  public ByteBuffer[] yuvPlanes;
+  public int[] yuvStrides;
+  public int mode;
+  public int colorspace;
+
+  /**
+   * Releases the buffer back to the decoder, allowing it to be reused.
+   */
+  public void release() {
+    decoder.releaseOutputBuffer(this);
+  }
+
+  /**
+   * Resizes the buffer based on the given dimensions. Called via JNI after decoding completes.
+   */
+  /* package */ void initForRgbFrame(int width, int height) {
+    this.width = width;
+    this.height = height;
+    int minimumRgbSize = width * height * 2;
+    if (data == null || data.capacity() < minimumRgbSize) {
+      data = ByteBuffer.allocateDirect(minimumRgbSize);
+      yuvPlanes = null;
+    }
+    data.position(0);
+    data.limit(minimumRgbSize);
+  }
+
+  /**
+   * Resizes the buffer based on the given stride. Called via JNI after decoding completes.
+   */
+  /* package */ void initForYuvFrame(int width, int height, int yStride, int uvStride,
+      int colorspace) {
+    this.width = width;
+    this.height = height;
+    this.colorspace = colorspace;
+    int yLength = yStride * height;
+    int uvLength = uvStride * ((height + 1) / 2);
+    int minimumYuvSize = yLength + (uvLength * 2);
+    if (data == null || data.capacity() < minimumYuvSize) {
+      data = ByteBuffer.allocateDirect(minimumYuvSize);
+    }
+    data.limit(minimumYuvSize);
+    if (yuvPlanes == null) {
+      yuvPlanes = new ByteBuffer[3];
+    }
+    // Rewrapping has to be done on every frame since the stride might have changed.
+    data.position(0);
+    yuvPlanes[0] = data.slice();
+    yuvPlanes[0].limit(yLength);
+    data.position(yLength);
+    yuvPlanes[1] = data.slice();
+    yuvPlanes[1].limit(uvLength);
+    data.position(yLength + uvLength);
+    yuvPlanes[2] = data.slice();
+    yuvPlanes[2].limit(uvLength);
+    if (yuvStrides == null) {
+      yuvStrides = new int[3];
+    }
+    yuvStrides[0] = yStride;
+    yuvStrides[1] = uvStride;
+    yuvStrides[2] = uvStride;
+  }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBufferRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBufferRenderer.java
new file mode 100644
index 0000000000..0ab1fc475e
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBufferRenderer.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+/**
+ * Renders the {@link VpxOutputBuffer}.
+ */
+public interface VpxOutputBufferRenderer {
+
+  /**
+   * Sets the output buffer to be rendered. The renderer is responsible for releasing the buffer.
+   */
+  void setOutputBuffer(VpxOutputBuffer outputBuffer);
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java
index c78619594f..508e77deac 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java
@@ -15,14 +15,13 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
-
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
+import java.util.concurrent.atomic.AtomicReference;
 
 import javax.microedition.khronos.egl.EGLConfig;
 import javax.microedition.khronos.opengles.GL10;
@@ -33,6 +32,18 @@
  */
 /* package */ class VpxRenderer implements GLSurfaceView.Renderer {
 
+  private static final float[] kColorConversion601 = {
+    1.164f, 1.164f, 1.164f,
+    0.0f, -0.392f, 2.017f,
+    1.596f, -0.813f, 0.0f,
+  };
+
+  private static final float[] kColorConversion709 = {
+    1.164f, 1.164f, 1.164f,
+    0.0f, -0.213f, 2.112f,
+    1.793f, -0.533f, 0.0f,
+  };
+
   private static final String VERTEX_SHADER =
       "varying vec2 interp_tc;\n"
       + "attribute vec4 in_pos;\n"
@@ -48,14 +59,13 @@
       + "uniform sampler2D y_tex;\n"
       + "uniform sampler2D u_tex;\n"
       + "uniform sampler2D v_tex;\n"
+      + "uniform mat3 mColorConversion;\n"
       + "void main() {\n"
-      + "  float y = 1.164 * (texture2D(y_tex, interp_tc).r - 0.0625);\n"
-      + "  float u = texture2D(u_tex, interp_tc).r - 0.5;\n"
-      + "  float v = texture2D(v_tex, interp_tc).r - 0.5;\n"
-      + "  gl_FragColor = vec4(y + 1.596 * v, "
-      + "                      y - 0.391 * u - 0.813 * v, "
-      + "                      y + 2.018 * u, "
-      + "                      1.0);\n"
+      + "  vec3 yuv;"
+      + "  yuv.x = texture2D(y_tex, interp_tc).r - 0.0625;\n"
+      + "  yuv.y = texture2D(u_tex, interp_tc).r - 0.5;\n"
+      + "  yuv.z = texture2D(v_tex, interp_tc).r - 0.5;\n"
+      + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);"
       + "}\n";
   private static final FloatBuffer TEXTURE_VERTICES = nativeFloatBuffer(
       -1.0f, 1.0f,
@@ -63,17 +73,21 @@
       1.0f, 1.0f,
       1.0f, -1.0f);
   private final int[] yuvTextures = new int[3];
+  private final AtomicReference<VpxOutputBuffer> pendingOutputBufferReference;
 
   private int program;
   private int texLocation;
+  private int colorMatrixLocation;
   private FloatBuffer textureCoords;
-  private volatile OutputBuffer outputBuffer;
   private int previousWidth;
   private int previousStride;
 
+  private VpxOutputBuffer renderedOutputBuffer; // Accessed only from the GL thread.
+
   public VpxRenderer() {
     previousWidth = -1;
     previousStride = -1;
+    pendingOutputBufferReference = new AtomicReference<>();
   }
 
   /**
@@ -82,8 +96,12 @@ public VpxRenderer() {
    *
    * @param outputBuffer OutputBuffer containing the YUV Frame to be rendered
    */
-  public void setFrame(OutputBuffer outputBuffer) {
-    this.outputBuffer = outputBuffer;
+  public void setFrame(VpxOutputBuffer outputBuffer) {
+    VpxOutputBuffer oldPendingOutputBuffer = pendingOutputBufferReference.getAndSet(outputBuffer);
+    if (oldPendingOutputBuffer != null) {
+      // The old pending output buffer will never be used for rendering, so release it now.
+      oldPendingOutputBuffer.release();
+    }
   }
 
   @Override
@@ -110,6 +128,9 @@ public void onSurfaceCreated(GL10 unused, EGLConfig config) {
         posLocation, 2, GLES20.GL_FLOAT, false, 0, TEXTURE_VERTICES);
     texLocation = GLES20.glGetAttribLocation(program, "in_tc");
     GLES20.glEnableVertexAttribArray(texLocation);
+    checkNoGLES2Error();
+    colorMatrixLocation = GLES20.glGetUniformLocation(program, "mColorConversion");
+    checkNoGLES2Error();
     setupTextures();
     checkNoGLES2Error();
   }
@@ -121,19 +142,31 @@ public void onSurfaceChanged(GL10 unused, int width, int height) {
 
   @Override
   public void onDrawFrame(GL10 unused) {
-    OutputBuffer outputBuffer = this.outputBuffer;
-    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
-    if (outputBuffer == null) {
-      // Nothing to render yet.
+    VpxOutputBuffer pendingOutputBuffer = pendingOutputBufferReference.getAndSet(null);
+    if (pendingOutputBuffer == null && renderedOutputBuffer == null) {
+      // There is no output buffer to render at the moment.
       return;
     }
+    if (pendingOutputBuffer != null) {
+      if (renderedOutputBuffer != null) {
+        renderedOutputBuffer.release();
+      }
+      renderedOutputBuffer = pendingOutputBuffer;
+    }
+    VpxOutputBuffer outputBuffer = renderedOutputBuffer;
+    // Set color matrix. Assume BT709 if the color space is unknown.
+    float[] colorConversion = outputBuffer.colorspace == VpxOutputBuffer.COLORSPACE_BT601
+        ? kColorConversion601 : kColorConversion709;
+    GLES20.glUniformMatrix3fv(colorMatrixLocation, 1, false, colorConversion, 0);
+
     for (int i = 0; i < 3; i++) {
       int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
       GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
       GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
       GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
-      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE, outputBuffer.yuvStrides[i],
-          h, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, outputBuffer.yuvPlanes[i]);
+      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE,
+          outputBuffer.yuvStrides[i], h, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE,
+          outputBuffer.yuvPlanes[i]);
     }
     // Set cropping of stride if either width or stride has changed.
     if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
@@ -148,6 +181,7 @@ public void onDrawFrame(GL10 unused) {
       previousWidth = outputBuffer.width;
       previousStride = outputBuffer.yuvStrides[0];
     }
+    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
     GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
     checkNoGLES2Error();
   }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java
index 1b8046a6d2..47d0770abe 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.opengl.GLSurfaceView;
@@ -26,7 +24,7 @@
  * A GLSurfaceView extension that scales itself to the given aspect ratio.
  */
 @TargetApi(11)
-public class VpxVideoSurfaceView extends GLSurfaceView {
+public class VpxVideoSurfaceView extends GLSurfaceView implements VpxOutputBufferRenderer {
 
   private final VpxRenderer renderer;
 
@@ -43,7 +41,8 @@ public VpxVideoSurfaceView(Context context, AttributeSet attrs) {
     setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
   }
 
-  public void renderFrame(OutputBuffer outputBuffer) {
+  @Override
+  public void setOutputBuffer(VpxOutputBuffer outputBuffer) {
     renderer.setFrame(outputBuffer);
     requestRender();
   }
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 6d8fbd5298..a3abe24399 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -44,7 +44,7 @@
     Java_com_google_android_exoplayer_ext_vp9_VpxDecoder_ ## NAME \
       (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
 
-// JNI references for OutputBuffer class.
+// JNI references for VpxOutputBuffer class.
 static jmethodID initForRgbFrame;
 static jmethodID initForYuvFrame;
 static jfieldID dataField;
@@ -69,9 +69,9 @@ FUNC(jlong, vpxInit) {
 
   // Populate JNI References.
   const jclass outputBufferClass = env->FindClass(
-      "com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper$OutputBuffer");
+      "com/google/android/exoplayer/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
-                                     "(IIII)V");
+                                     "(IIIII)V");
   initForRgbFrame = env->GetMethodID(outputBufferClass, "initForRgbFrame",
                                      "(II)V");
   dataField = env->GetFieldID(outputBufferClass, "data",
@@ -128,9 +128,26 @@ FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
                          img->planes[VPX_PLANE_V], img->stride[VPX_PLANE_V],
                          dst, img->d_w * 2, img->d_w, img->d_h);
   } else if (outputMode == kOutputModeYuv) {
+    const int kColorspaceUnknown = 0;
+    const int kColorspaceBT601 = 1;
+    const int kColorspaceBT709 = 2;
+
+    int colorspace = kColorspaceUnknown;
+    switch (img->cs) {
+      case VPX_CS_BT_601:
+        colorspace = kColorspaceBT601;
+        break;
+      case VPX_CS_BT_709:
+        colorspace = kColorspaceBT709;
+        break;
+      default:
+        break;
+    }
+
     // resize buffer if required.
     env->CallVoidMethod(jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
-                        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U]);
+                        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U],
+                        colorspace);
 
     // get pointer to the data buffer.
     const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
diff --git a/library/build.gradle b/library/build.gradle
index 98551f2159..10cb65a13e 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.3'
+    version = 'r1.5.4'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/assets/subrip/typical_with_byte_order_mark b/library/src/androidTest/assets/subrip/typical_with_byte_order_mark
new file mode 100644
index 0000000000..9601c99bfb
--- /dev/null
+++ b/library/src/androidTest/assets/subrip/typical_with_byte_order_mark
@@ -0,0 +1,12 @@
+﻿1
+00:00:00,000 --> 00:00:01,234
+This is the first subtitle.
+
+2
+00:00:02,345 --> 00:00:03,456
+This is the second subtitle.
+Second subtitle with second line.
+
+3
+00:00:04,567 --> 00:00:08,901
+This is the third subtitle.
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
index d1e75b8838..b9b778226e 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
@@ -324,7 +324,8 @@ private static DashChunkSource buildDashChunkSource(MediaPresentationDescription
     DashChunkSource chunkSource = new DashChunkSource(manifestFetcher, mpd,
         DefaultDashTrackSelector.newVideoInstance(null, false, false), mock(DataSource.class), null,
         new FakeClock(mpd.availabilityStartTime + mpd.duration - ELAPSED_REALTIME_OFFSET_MS),
-        liveEdgeLatencyMs * 1000, ELAPSED_REALTIME_OFFSET_MS * 1000, startAtLiveEdge, null, null);
+        liveEdgeLatencyMs * 1000, ELAPSED_REALTIME_OFFSET_MS * 1000, startAtLiveEdge, null, null,
+        0);
     chunkSource.prepare();
     chunkSource.enable(0);
     return chunkSource;
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
index 4e901a5210..19c6586bf5 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
@@ -43,8 +43,7 @@ public void testInitialPosition() throws IOException {
   }
 
   public void testRead() throws IOException, InterruptedException {
-    FakeDataSource testDataSource = buildDataSource();
-    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     // We expect to perform three reads of three bytes, as setup in buildTestDataSource.
     int bytesRead = 0;
@@ -61,9 +60,34 @@ public void testRead() throws IOException, InterruptedException {
     assertEquals(-1, expectedEndOfInput);
   }
 
+  public void testReadPeeked() throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    input.advancePeekPosition(TEST_DATA.length);
+
+    int bytesRead = input.read(target, 0, TEST_DATA.length);
+    assertEquals(TEST_DATA.length, bytesRead);
+
+    // Check the read data is correct.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+  }
+
+  public void testReadMoreDataPeeked() throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    input.advancePeekPosition(TEST_DATA.length);
+
+    int bytesRead = input.read(target, 0, TEST_DATA.length + 1);
+    assertEquals(TEST_DATA.length, bytesRead);
+
+    // Check the read data is correct.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+  }
+
   public void testReadFullyOnce() throws IOException, InterruptedException {
-    FakeDataSource testDataSource = buildDataSource();
-    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.readFully(target, 0, TEST_DATA.length);
     // Check that we read the whole of TEST_DATA.
@@ -83,8 +107,7 @@ public void testReadFullyOnce() throws IOException, InterruptedException {
 
   public void testReadFullyTwice() throws IOException, InterruptedException {
     // Read TEST_DATA in two parts.
-    FakeDataSource testDataSource = buildDataSource();
-    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[5];
     input.readFully(target, 0, 5);
     assertTrue(Arrays.equals(Arrays.copyOf(TEST_DATA, 5), target));
@@ -97,8 +120,7 @@ public void testReadFullyTwice() throws IOException, InterruptedException {
 
   public void testReadFullyTooMuch() throws IOException, InterruptedException {
     // Read more than TEST_DATA. Should fail with an EOFException. Position should not update.
-    FakeDataSource testDataSource = buildDataSource();
-    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    DefaultExtractorInput input = createDefaultExtractorInput();
     try {
       byte[] target = new byte[TEST_DATA.length + 1];
       input.readFully(target, 0, TEST_DATA.length + 1);
@@ -110,8 +132,7 @@ public void testReadFullyTooMuch() throws IOException, InterruptedException {
 
     // Read more than TEST_DATA with allowEndOfInput set. Should fail with an EOFException because
     // the end of input isn't encountered immediately. Position should not update.
-    testDataSource = buildDataSource();
-    input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    input = createDefaultExtractorInput();
     try {
       byte[] target = new byte[TEST_DATA.length + 1];
       input.readFully(target, 0, TEST_DATA.length + 1, true);
@@ -136,12 +157,39 @@ public void testReadFullyWithFailingDataSource() throws IOException, Interrupted
     assertEquals(0, input.getPosition());
   }
 
-  public void testSkipFullyOnce() throws IOException, InterruptedException {
-    // Skip TEST_DATA.
+  public void testReadFullyHalfPeeked() throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    input.advancePeekPosition(4);
+
+    input.readFully(target, 0, TEST_DATA.length);
+
+    // Check the read data is correct.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertEquals(TEST_DATA.length, input.getPosition());
+  }
+
+  public void testSkip() throws IOException, InterruptedException {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    // We expect to perform three skips of three bytes, as setup in buildTestDataSource.
+    for (int i = 0; i < 3; i++) {
+      assertEquals(3, input.skip(TEST_DATA.length));
+    }
+    // Check we're now indicated that the end of input is reached.
+    int expectedEndOfInput = input.skip(TEST_DATA.length);
+    assertEquals(-1, expectedEndOfInput);
+  }
+
+  public void testSkipFullyOnce() throws IOException, InterruptedException {
+    // Skip TEST_DATA.
+    DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(TEST_DATA.length);
     assertEquals(TEST_DATA.length, input.getPosition());
+    // Check that we see end of input if we skip again with allowEndOfInput set.
+    boolean result = input.skipFully(1, true);
+    assertFalse(result);
     // Check that we fail with EOFException we skip again.
     try {
       input.skipFully(1);
@@ -153,18 +201,30 @@ public void testSkipFullyOnce() throws IOException, InterruptedException {
 
   public void testSkipFullyTwice() throws IOException, InterruptedException {
     // Skip TEST_DATA in two parts.
-    FakeDataSource testDataSource = buildDataSource();
-    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(5);
     assertEquals(5, input.getPosition());
     input.skipFully(4);
     assertEquals(5 + 4, input.getPosition());
   }
 
+  public void testSkipFullyTwicePeeked() throws IOException, InterruptedException {
+    // Skip TEST_DATA.
+    DefaultExtractorInput input = createDefaultExtractorInput();
+
+    input.advancePeekPosition(TEST_DATA.length);
+
+    int halfLength = TEST_DATA.length / 2;
+    input.skipFully(halfLength);
+    assertEquals(halfLength, input.getPosition());
+
+    input.skipFully(TEST_DATA.length - halfLength);
+    assertEquals(TEST_DATA.length, input.getPosition());
+  }
+
   public void testSkipFullyTooMuch() throws IOException, InterruptedException {
     // Skip more than TEST_DATA. Should fail with an EOFException. Position should not update.
-    FakeDataSource testDataSource = buildDataSource();
-    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    DefaultExtractorInput input = createDefaultExtractorInput();
     try {
       input.skipFully(TEST_DATA.length + 1);
       fail();
@@ -172,6 +232,17 @@ public void testSkipFullyTooMuch() throws IOException, InterruptedException {
       // Expected.
     }
     assertEquals(0, input.getPosition());
+
+    // Skip more than TEST_DATA with allowEndOfInput set. Should fail with an EOFException because
+    // the end of input isn't encountered immediately. Position should not update.
+    input = createDefaultExtractorInput();
+    try {
+      input.skipFully(TEST_DATA.length + 1, true);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+    assertEquals(0, input.getPosition());
   }
 
   public void testSkipFullyWithFailingDataSource() throws IOException, InterruptedException {
@@ -207,6 +278,99 @@ public void testSkipFullyLarge() throws IOException, InterruptedException {
     }
   }
 
+  public void testPeekFully() throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+    input.peekFully(target, 0, TEST_DATA.length);
+
+    // Check that we read the whole of TEST_DATA.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertEquals(0, input.getPosition());
+
+    // Check that we can read again from the buffer
+    byte[] target2 = new byte[TEST_DATA.length];
+    input.readFully(target2, 0, TEST_DATA.length);
+    assertTrue(Arrays.equals(TEST_DATA, target2));
+
+    // Check that we fail with EOFException if we peek again
+    try {
+      input.peekFully(target, 0, 1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  public void testResetPeekPosition() throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+    input.peekFully(target, 0, TEST_DATA.length);
+
+    // Check that we read the whole of TEST_DATA.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertEquals(0, input.getPosition());
+
+    // Check that we can peek again after resetting.
+    input.resetPeekPosition();
+    byte[] target2 = new byte[TEST_DATA.length];
+    input.peekFully(target2, 0, TEST_DATA.length);
+    assertTrue(Arrays.equals(TEST_DATA, target2));
+
+    // Check that we fail with EOFException if we peek past the end of the input.
+    try {
+      input.peekFully(target, 0, 1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds()
+      throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    // Check peeking up to the end of input succeeds.
+    assertTrue(input.peekFully(target, 0, TEST_DATA.length, true));
+
+    // Check peeking at the end of input with allowEndOfInput signals the end of input.
+    assertFalse(input.peekFully(target, 0, 1, true));
+  }
+
+  public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails()
+      throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    // Check peeking before the end of input with allowEndOfInput succeeds.
+    assertTrue(input.peekFully(target, 0, TEST_DATA.length - 1, true));
+
+    // Check peeking across the end of input with allowEndOfInput throws.
+    try {
+      input.peekFully(target, 0, 2, true);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails()
+      throws IOException, InterruptedException {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    // Check peeking up to the end of input succeeds.
+    assertTrue(input.peekFully(target, 0, TEST_DATA.length, true));
+    input.resetPeekPosition();
+    try {
+      // Check peeking one more byte throws.
+      input.peekFully(target, 0, TEST_DATA.length + 1, true);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
   private static FakeDataSource buildDataSource() throws IOException {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 3));
@@ -227,4 +391,8 @@ private static FakeDataSource buildFailingDataSource() throws IOException {
     return testDataSource;
   }
 
+  private static DefaultExtractorInput createDefaultExtractorInput() throws IOException {
+    FakeDataSource testDataSource = buildDataSource();
+    return new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+  }
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
deleted file mode 100644
index 6b140c9ab2..0000000000
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.extractor.mp3;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
-import com.google.android.exoplayer.extractor.DefaultExtractorInput;
-import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.testutil.FakeDataSource;
-import com.google.android.exoplayer.testutil.TestUtil;
-import com.google.android.exoplayer.upstream.DataSpec;
-import com.google.android.exoplayer.util.ParsableByteArray;
-
-import android.net.Uri;
-import android.test.InstrumentationTestCase;
-
-import org.mockito.Mock;
-
-import java.nio.BufferOverflowException;
-import java.util.Arrays;
-
-/**
- * Tests for {@link BufferingInput}.
- */
-public class BufferingInputTest extends InstrumentationTestCase {
-
-  private static final String TEST_URI = "http://www.google.com";
-  private static final byte[] STREAM_DATA = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-  private ExtractorInput fakeExtractorInput;
-
-  /** Used for verifying interactions. */
-  @Mock private ExtractorInput mockExtractorInput;
-  @Mock private TrackOutput mockTrackOutput;
-
-  @Override
-  public void setUp() throws Exception {
-    TestUtil.setUpMockito(this);
-
-    FakeDataSource.Builder builder = new FakeDataSource.Builder();
-    builder.appendReadData(STREAM_DATA);
-    FakeDataSource fakeDataSource = builder.build();
-    fakeDataSource.open(new DataSpec(Uri.parse(TEST_URI)));
-    fakeExtractorInput = new DefaultExtractorInput(fakeDataSource, 0, STREAM_DATA.length);
-  }
-
-  public void testReadFromExtractor() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[4];
-    input.read(fakeExtractorInput, target, 0, 4);
-    assertMatchesStreamData(target, 0, 4);
-  }
-
-  public void testReadCapacityFromExtractor() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[5];
-    input.read(fakeExtractorInput, target, 0, 5);
-    assertMatchesStreamData(target, 0, 5);
-  }
-
-  public void testReadOverCapacityFromExtractorFails() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[6];
-    try {
-      input.read(fakeExtractorInput, target, 0, 6);
-      fail();
-    } catch (BufferOverflowException e) {
-      // Expected.
-    }
-  }
-
-  public void testReadFromBuffer() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[5];
-    input.read(fakeExtractorInput, target, 0, 5);
-
-    // When reading already-buffered data
-    input.returnToMark();
-    input.read(mockExtractorInput, target, 0, 5);
-    assertMatchesStreamData(target, 0, 5);
-
-    // There is no interaction with the extractor input.
-    verifyZeroInteractions(mockExtractorInput);
-  }
-
-  public void testReadFromBufferPartially() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[5];
-    input.read(fakeExtractorInput, target, 0, 5);
-
-    // When reading already-buffered data
-    input.returnToMark();
-    input.read(mockExtractorInput, target, 0, 4);
-    assertMatchesStreamData(target, 0, 4);
-
-    // There is no interaction with the extractor input.
-    verifyZeroInteractions(mockExtractorInput);
-  }
-
-  public void testResetDiscardsData() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[5];
-    input.read(fakeExtractorInput, target, 0, 5);
-
-    // When the buffer is reset
-    input.reset();
-
-    // Then it is possible to read up to the capacity again.
-    input.read(fakeExtractorInput, target, 0, 5);
-    assertMatchesStreamData(target, 5, 5);
-  }
-
-  public void testGetAvailableByteCountAtWritePosition() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[5];
-    input.read(fakeExtractorInput, target, 0, 5);
-    assertEquals(0, input.getAvailableByteCount());
-  }
-
-  public void testGetAvailableByteCountBeforeWritePosition() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    byte[] target = new byte[5];
-    input.read(fakeExtractorInput, target, 0, 3);
-    input.mark();
-    input.read(fakeExtractorInput, target, 0, 3);
-    input.mark();
-    input.read(fakeExtractorInput, target, 0, 2);
-    input.returnToMark();
-
-    // The reading position is calculated correctly.
-    assertEquals(2, input.getAvailableByteCount());
-    assertEquals(8, fakeExtractorInput.getPosition());
-  }
-
-  public void testGetParsableByteArray() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    input.skip(fakeExtractorInput, 4);
-    input.mark();
-    input.skip(fakeExtractorInput, 3);
-    input.returnToMark();
-    ParsableByteArray parsableByteArray = input.getParsableByteArray(fakeExtractorInput, 4);
-
-    // The returned array matches the input's internal buffer.
-    assertMatchesStreamData(parsableByteArray.data, 0, 7);
-  }
-
-  public void testGetParsableByteArrayPastCapacity() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    input.skip(fakeExtractorInput, 4);
-    input.mark();
-    input.skip(fakeExtractorInput, 3);
-    input.mark();
-    input.skip(fakeExtractorInput, 1);
-    input.returnToMark();
-    ParsableByteArray parsableByteArray = input.getParsableByteArray(fakeExtractorInput, 2);
-
-    // The second call to mark() copied the buffer data to the start.
-    assertMatchesStreamData(parsableByteArray.data, 7, 2);
-  }
-
-  public void testDrainEntireBuffer() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    input.skip(fakeExtractorInput, 3);
-    input.returnToMark();
-
-    // When draining the first three bytes
-    input.drainToOutput(mockTrackOutput, 3);
-
-    // They are appended as sample data.
-    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(3));
-  }
-
-  public void testDrainTwice() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    input.skip(fakeExtractorInput, 3);
-    input.returnToMark();
-
-    // When draining one then two bytes
-    input.drainToOutput(mockTrackOutput, 1);
-    assertEquals(2, input.drainToOutput(mockTrackOutput, 3));
-
-    // They are appended as sample data.
-    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(1));
-    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(2));
-  }
-
-  public void testDrainPastCapacity() throws Exception {
-    BufferingInput input = new BufferingInput(5);
-    input.skip(fakeExtractorInput, 4);
-    input.mark();
-    input.skip(fakeExtractorInput, 5);
-    input.returnToMark();
-
-    // When draining the entire buffer
-    input.drainToOutput(mockTrackOutput, 5);
-
-    // The sample data is appended as one whole buffer.
-    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(5));
-  }
-
-  private static void assertMatchesStreamData(byte[] read, int offset, int length) {
-    assertTrue(Arrays.equals(Arrays.copyOfRange(STREAM_DATA, offset, offset + length),
-        Arrays.copyOfRange(read, 0, length)));
-  }
-
-}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java
new file mode 100644
index 0000000000..e981e65f49
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.testutil.TestUtil;
+import com.google.android.exoplayer.util.MpegAudioHeader;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.test.InstrumentationTestCase;
+
+/**
+ * Tests for {@link XingSeeker}.
+ */
+public final class XingSeekerTest extends InstrumentationTestCase {
+
+  // Xing header/payload from http://storage.googleapis.com/exoplayer-test-media-0/play.mp3.
+  private static final int XING_FRAME_HEADER_DATA = 0xFFFB3000;
+  private static final byte[] XING_FRAME_PAYLOAD = TestUtil.createByteArray(
+      "00000007000008dd000e7919000205080a0d0f1214171a1c1e212426292c2e303336383b3d404245484a4c4f5254"
+      + "575a5c5e616466696b6e707376787a7d808285878a8c8f929496999c9ea1a4a6a8abaeb0b3b5b8babdc0c2c4c7"
+      + "cacccfd2d4d6d9dcdee1e3e6e8ebeef0f2f5f8fafd");
+  private static final int XING_FRAME_POSITION = 157;
+
+  /**
+   * Size of the audio stream, encoded in {@link #XING_FRAME_PAYLOAD}.
+   */
+  private static final int STREAM_SIZE_BYTES = 948505;
+  /**
+   * Duration of the audio stream in microseconds, encoded in {@link #XING_FRAME_PAYLOAD}.
+   */
+  private static final int STREAM_DURATION_US = 59271836;
+  /**
+   * The length of the file in bytes.
+   */
+  private static final int INPUT_LENGTH = 948662;
+
+  private XingSeeker seeker;
+  private XingSeeker seekerWithInputLength;
+  private int xingFrameSize;
+
+  @Override
+  public void setUp() throws Exception {
+    MpegAudioHeader xingFrameHeader = new MpegAudioHeader();
+    MpegAudioHeader.populateHeader(XING_FRAME_HEADER_DATA, xingFrameHeader);
+    seeker = XingSeeker.create(xingFrameHeader, new ParsableByteArray(XING_FRAME_PAYLOAD),
+        XING_FRAME_POSITION, C.UNKNOWN_TIME_US);
+    seekerWithInputLength = XingSeeker.create(xingFrameHeader,
+        new ParsableByteArray(XING_FRAME_PAYLOAD), XING_FRAME_POSITION, INPUT_LENGTH);
+    xingFrameSize = xingFrameHeader.frameSize;
+  }
+
+  public void testGetTimeUsBeforeFirstAudioFrame() {
+    assertEquals(0, seeker.getTimeUs(-1));
+    assertEquals(0, seekerWithInputLength.getTimeUs(-1));
+  }
+
+  public void testGetTimeUsAtFirstAudioFrame() {
+    assertEquals(0, seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize));
+    assertEquals(0, seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize));
+  }
+
+  public void testGetTimeUsAtEndOfStream() {
+    assertEquals(STREAM_DURATION_US,
+        seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES));
+    assertEquals(STREAM_DURATION_US,
+        seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES));
+  }
+
+  public void testGetPositionAtStartOfStream() {
+    assertEquals(XING_FRAME_POSITION + xingFrameSize, seeker.getPosition(0));
+    assertEquals(XING_FRAME_POSITION + xingFrameSize, seekerWithInputLength.getPosition(0));
+  }
+
+  public void testGetPositionAtEndOfStream() {
+    assertEquals(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1,
+        seeker.getPosition(STREAM_DURATION_US));
+    assertEquals(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1,
+        seekerWithInputLength.getPosition(STREAM_DURATION_US));
+  }
+
+  public void testGetTimeForAllPositions() {
+    for (int offset = xingFrameSize; offset < STREAM_SIZE_BYTES; offset++) {
+      int position = XING_FRAME_POSITION + offset;
+      long timeUs = seeker.getTimeUs(position);
+      assertEquals(position, seeker.getPosition(timeUs));
+      timeUs = seekerWithInputLength.getTimeUs(position);
+      assertEquals(position, seekerWithInputLength.getPosition(timeUs));
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
index a7a572d3cd..d4f796c3bc 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
@@ -39,50 +39,51 @@
 public final class Mp4ExtractorTest extends TestCase {
 
   /** String of hexadecimal bytes containing the video stsd payload from an AVC video. */
-  private static final byte[] VIDEO_STSD_PAYLOAD = getByteArray(
-      "00000000000000010000009961766331000000000000000100000000000000000000000000000000050002"
-      + "d00048000000480000000000000001000000000000000000000000000000000000000000000000000000"
-      + "00000000000018ffff0000002f617663430164001fffe100186764001facb402802dd808800000030080"
-      + "00001e078c195001000468ee3cb000000014627472740000e35c0042a61000216cb8");
-  private static final byte[] VIDEO_HDLR_PAYLOAD = getByteArray("000000000000000076696465");
-  private static final byte[] VIDEO_MDHD_PAYLOAD =
-      getByteArray("0000000000000000cf6c48890000001e00001c8a55c40000");
+  private static final byte[] VIDEO_STSD_PAYLOAD = TestUtil.createByteArray(
+      "00000000000000010000009961766331000000000000000100000000000000000000000000000000050002d00048"
+      + "000000480000000000000001000000000000000000000000000000000000000000000000000000000000000000"
+      + "18ffff0000002f617663430164001fffe100186764001facb402802dd80880000003008000001e078c19500100"
+      + "0468ee3cb000000014627472740000e35c0042a61000216cb8");
+  private static final byte[] VIDEO_HDLR_PAYLOAD = TestUtil.createByteArray(
+      "000000000000000076696465");
+  private static final byte[] VIDEO_MDHD_PAYLOAD = TestUtil.createByteArray(
+      "0000000000000000cf6c48890000001e00001c8a55c40000");
   private static final int TIMESCALE = 30;
   private static final int VIDEO_WIDTH = 1280;
   private static final int VIDEO_HEIGHT = 720;
 
   /** String of hexadecimal bytes containing the video stsd payload for an mp4v track. */
-  private static final byte[] VIDEO_STSD_MP4V_PAYLOAD = getByteArray(
-      "0000000000000001000000A36D703476000000000000000100000000000000000000000000000000014000"
-      + "B40048000000480000000000000001000000000000000000000000000000000000000000000000000000"
-      + "00000000000018FFFF0000004D6573647300000000033F00000004372011001A400004CF280002F11805"
-      + "28000001B001000001B58913000001000000012000C48D8800F50A04169463000001B2476F6F676C6506"
-      + "0102");
+  private static final byte[] VIDEO_STSD_MP4V_PAYLOAD = TestUtil.createByteArray(
+      "0000000000000001000000A36D703476000000000000000100000000000000000000000000000000014000B40048"
+      + "000000480000000000000001000000000000000000000000000000000000000000000000000000000000000000"
+      + "18FFFF0000004D6573647300000000033F00000004372011001A400004CF280002F1180528000001B001000001"
+      + "B58913000001000000012000C48D8800F50A04169463000001B2476F6F676C65060102");
   private static final int VIDEO_MP4V_WIDTH = 320;
   private static final int VIDEO_MP4V_HEIGHT = 180;
 
   /** String of hexadecimal bytes containing the audio stsd payload from an AAC track. */
-  private static final byte[] AUDIO_STSD_PAYLOAD = getByteArray(
-      "0000000000000001000000596d703461000000000000000100000000000000000001001000000000ac4400"
-      + "000000003565736473000000000327000000041f401500023e00024bc000023280051012080000000000"
-      + "000000000000000000060102");
-  private static final byte[] AUDIO_HDLR_PAYLOAD = getByteArray("0000000000000000736f756e");
-  private static final byte[] AUDIO_MDHD_PAYLOAD =
-      getByteArray("00000000cf6c4889cf6c488a0000ac4400a3e40055c40000");
+  private static final byte[] AUDIO_STSD_PAYLOAD = TestUtil.createByteArray(
+      "0000000000000001000000596d703461000000000000000100000000000000000001001000000000ac4400000000"
+      + "003565736473000000000327000000041f401500023e00024bc000023280051012080000000000000000000000"
+      + "000000060102");
+  private static final byte[] AUDIO_HDLR_PAYLOAD = TestUtil.createByteArray(
+      "0000000000000000736f756e");
+  private static final byte[] AUDIO_MDHD_PAYLOAD = TestUtil.createByteArray(
+      "00000000cf6c4889cf6c488a0000ac4400a3e40055c40000");
 
   /** String of hexadecimal bytes for an ftyp payload with major_brand mp41 and minor_version 0. **/
-  private static final byte[] FTYP_PAYLOAD = getByteArray("6d70343100000000");
+  private static final byte[] FTYP_PAYLOAD = TestUtil.createByteArray("6d70343100000000");
 
   /** String of hexadecimal bytes containing an mvhd payload from an AVC/AAC video. */
-  private static final byte[] MVHD_PAYLOAD = getByteArray(
-      "00000000cf6c4888cf6c48880000025800023ad40001000001000000000000000000000000010000000000"
-      + "000000000000000000000100000000000000000000000000004000000000000000000000000000000000"
-      + "000000000000000000000000000003");
+  private static final byte[] MVHD_PAYLOAD = TestUtil.createByteArray(
+      "00000000cf6c4888cf6c48880000025800023ad40001000001000000000000000000000000010000000000000000"
+      + "000000000000000100000000000000000000000000004000000000000000000000000000000000000000000000"
+      + "000000000000000003");
 
   /** String of hexadecimal bytes containing a tkhd payload with an unknown duration. */
-  private static final byte[] TKHD_PAYLOAD = getByteArray(
-      "00000007D1F0C7BFD1F0C7BF0000000000000000FFFFFFFF00000000000000000000000000000000000100"
-      + "0000000000000000000000000000010000000000000000000000000000400000000780000004380000");
+  private static final byte[] TKHD_PAYLOAD = TestUtil.createByteArray(
+      "00000007D1F0C7BFD1F0C7BF0000000000000000FFFFFFFF00000000000000000000000000000000000100000000"
+      + "0000000000000000000000010000000000000000000000000000400000000780000004380000");
 
   /** Video frame timestamps in time units. */
   private static final int[] SAMPLE_TIMESTAMPS = {0, 2, 3, 5, 6, 7};
@@ -450,15 +451,6 @@ private static Mp4Atom atom(int type, byte[] payload) {
     return new Mp4Atom(type, payload);
   }
 
-  private static byte[] getByteArray(String hexBytes) {
-    byte[] result = new byte[hexBytes.length() / 2];
-    for (int i = 0; i < result.length; i++) {
-      result[i] = (byte) ((Character.digit(hexBytes.charAt(i * 2), 16) << 4)
-          + Character.digit(hexBytes.charAt(i * 2 + 1), 16));
-    }
-    return result;
-  }
-
   /**
    * MP4 atom that can be serialized as a byte array.
    */
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java
new file mode 100644
index 0000000000..78f0dd5ce9
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.testutil.FakeTrackOutput;
+import com.google.android.exoplayer.testutil.TestUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import junit.framework.TestCase;
+
+import java.util.Arrays;
+
+/**
+ * Test for {@link AdtsReader}.
+ */
+public class AdtsReaderTest extends TestCase {
+
+  public static final byte[] ID3_DATA_1 = TestUtil.createByteArray(
+      0x49, 0x44, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x54, 0x58,
+      0x58, 0x58, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x03, 0x00, 0x20, 0x2a,
+      0x2a, 0x2a, 0x20, 0x54, 0x48, 0x49, 0x53, 0x20, 0x49, 0x53, 0x20, 0x54,
+      0x69, 0x6d, 0x65, 0x64, 0x20, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74,
+      0x61, 0x20, 0x40, 0x20, 0x2d, 0x2d, 0x20, 0x30, 0x30, 0x3a, 0x30, 0x30,
+      0x3a, 0x30, 0x30, 0x2e, 0x30, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x00);
+
+  public static final byte[] ID3_DATA_2 = TestUtil.createByteArray(
+      0x49,
+      0x44, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x50, 0x52, 0x49,
+      0x56, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
+      0x70, 0x70, 0x6c, 0x65, 0x2e, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69,
+      0x6e, 0x67, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74,
+      0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
+      0x61, 0x6d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xbb, 0xa0);
+
+  public static final byte[] ADTS_HEADER = TestUtil.createByteArray(
+      0xff, 0xf1, 0x50, 0x80, 0x01, 0xdf, 0xfc);
+
+  public static final byte[] ADTS_CONTENT = TestUtil.createByteArray(
+      0x20, 0x00, 0x20, 0x00, 0x00, 0x80, 0x0e);
+
+  private static final byte TEST_DATA[] = TestUtil.joinByteArrays(
+      ID3_DATA_1,
+      ID3_DATA_2,
+      ADTS_HEADER,
+      ADTS_CONTENT);
+
+  private static final long ADTS_SAMPLE_DURATION = 23219L;
+
+  private ParsableByteArray data;
+
+  private AdtsReader adtsReader;
+  private FakeTrackOutput adtsOutput;
+  private FakeTrackOutput id3Output;
+
+  @Override
+  protected void setUp() throws Exception {
+    adtsOutput = new FakeTrackOutput();
+    id3Output = new FakeTrackOutput();
+    adtsReader = new AdtsReader(adtsOutput, id3Output);
+    data = new ParsableByteArray(TEST_DATA);
+  }
+
+  public void testSkipToNextSample() throws Exception {
+    for (int i = 1; i <= ID3_DATA_1.length + ID3_DATA_2.length; i++) {
+      data.setPosition(i);
+      feed();
+      // Once the data position set to ID3_DATA_1.length, no more id3 samples are read
+      int id3SampleCount = Math.min(i, ID3_DATA_1.length);
+      assertSampleCounts(id3SampleCount, i);
+    }
+  }
+
+  public void testSkipToNextSampleResetsState() throws Exception {
+    data = new ParsableByteArray(TestUtil.joinByteArrays(
+        ADTS_HEADER,
+        ADTS_CONTENT,
+        // Adts sample missing the first sync byte
+        Arrays.copyOfRange(ADTS_HEADER, 1, ADTS_HEADER.length),
+        ADTS_CONTENT));
+    feed();
+    assertSampleCounts(0, 1);
+    adtsOutput.assertSample(0, ADTS_CONTENT, 0, C.SAMPLE_FLAG_SYNC, null);
+  }
+
+  public void testNoData() throws Exception {
+    feedLimited(0);
+    assertSampleCounts(0, 0);
+  }
+
+  public void testNotEnoughDataForIdentifier() throws Exception {
+    feedLimited(3 - 1);
+    assertSampleCounts(0, 0);
+  }
+
+  public void testNotEnoughDataForHeader() throws Exception {
+    feedLimited(10 - 1);
+    assertSampleCounts(0, 0);
+  }
+
+  public void testNotEnoughDataForWholeId3Packet() throws Exception {
+    feedLimited(ID3_DATA_1.length - 1);
+    assertSampleCounts(0, 0);
+  }
+
+  public void testConsumeWholeId3Packet() throws Exception {
+    feedLimited(ID3_DATA_1.length);
+    assertSampleCounts(1, 0);
+    id3Output.assertSample(0, ID3_DATA_1, 0, C.SAMPLE_FLAG_SYNC, null);
+  }
+
+  public void testMultiId3Packet() throws Exception {
+    feedLimited(ID3_DATA_1.length + ID3_DATA_2.length - 1);
+    assertSampleCounts(1, 0);
+    id3Output.assertSample(0, ID3_DATA_1, 0, C.SAMPLE_FLAG_SYNC, null);
+  }
+
+  public void testMultiId3PacketConsumed() throws Exception {
+    feedLimited(ID3_DATA_1.length + ID3_DATA_2.length);
+    assertSampleCounts(2, 0);
+    id3Output.assertSample(0, ID3_DATA_1, 0, C.SAMPLE_FLAG_SYNC, null);
+    id3Output.assertSample(1, ID3_DATA_2, 0, C.SAMPLE_FLAG_SYNC, null);
+  }
+
+  public void testMultiPacketConsumed() throws Exception {
+    for (int i = 0; i < 10; i++) {
+      data.setPosition(0);
+      adtsReader.consume(data, 0, i == 0);
+
+      long timeUs = ADTS_SAMPLE_DURATION * i;
+      int j = i * 2;
+      assertSampleCounts(j + 2, i + 1);
+
+      id3Output.assertSample(j, ID3_DATA_1, timeUs, C.SAMPLE_FLAG_SYNC, null);
+      id3Output.assertSample(j + 1, ID3_DATA_2, timeUs, C.SAMPLE_FLAG_SYNC, null);
+      adtsOutput.assertSample(i, ADTS_CONTENT, timeUs, C.SAMPLE_FLAG_SYNC, null);
+    }
+  }
+
+  public void testAdtsDataOnly() throws Exception {
+    data.setPosition(ID3_DATA_1.length + ID3_DATA_2.length);
+    feed();
+    assertSampleCounts(0, 1);
+    adtsOutput.assertSample(0, ADTS_CONTENT, 0, C.SAMPLE_FLAG_SYNC, null);
+  }
+
+  private void feedLimited(int limit) {
+    data.setLimit(limit);
+    feed();
+  }
+
+  private void feed() {
+    adtsReader.consume(data, 0, true);
+  }
+
+  private void assertSampleCounts(int id3SampleCount, int adtsSampleCount) {
+    id3Output.assertSampleCount(id3SampleCount);
+    adtsOutput.assertSampleCount(adtsSampleCount);
+  }
+
+}
+
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
index 77fc5fa12a..0195028a76 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
@@ -21,13 +21,16 @@
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.Util;
 
+import android.app.Instrumentation;
 import android.net.Uri;
 import android.test.InstrumentationTestCase;
 
 import org.mockito.MockitoAnnotations;
 
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Random;
 
@@ -77,6 +80,15 @@ public static ExtractorInput createTestExtractorInput(byte[] data, int offset)
     return source;
   }
 
+  public static byte[] createByteArray(String hexBytes) {
+    byte[] result = new byte[hexBytes.length() / 2];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = (byte) ((Character.digit(hexBytes.charAt(i * 2), 16) << 4)
+          + Character.digit(hexBytes.charAt(i * 2 + 1), 16));
+    }
+    return result;
+  }
+
   public static byte[] createByteArray(int... intArray) {
     byte[] byteArray = new byte[intArray.length];
     for (int i = 0; i < byteArray.length; i++) {
@@ -106,4 +118,10 @@ public static void setUpMockito(InstrumentationTestCase instrumentationTestCase)
     MockitoAnnotations.initMocks(instrumentationTestCase);
   }
 
+  public static byte[] getByteArray(Instrumentation instrumentation, String fileName)
+      throws IOException {
+    InputStream is = instrumentation.getContext().getResources().getAssets().open(fileName);
+    return Util.toByteArray(is);
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
index 8b7f74ad1e..eabdb5be17 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer.text.subrip;
 
+import com.google.android.exoplayer.testutil.TestUtil;
+
 import android.test.InstrumentationTestCase;
 
 import java.io.IOException;
-import java.io.InputStream;
 
 /**
  * Unit test for {@link SubripParser}.
@@ -27,6 +28,7 @@
 
   private static final String EMPTY_FILE = "subrip/empty";
   private static final String TYPICAL_FILE = "subrip/typical";
+  private static final String TYPICAL_WITH_BYTE_ORDER_MARK = "subrip/typical_with_byte_order_mark";
   private static final String TYPICAL_EXTRA_BLANK_LINE = "subrip/typical_extra_blank_line";
   private static final String TYPICAL_MISSING_TIMECODE = "subrip/typical_missing_timecode";
   private static final String TYPICAL_MISSING_SEQUENCE = "subrip/typical_missing_sequence";
@@ -34,8 +36,8 @@
 
   public void testParseEmpty() throws IOException {
     SubripParser parser = new SubripParser();
-    InputStream inputStream = getInputStream(EMPTY_FILE);
-    SubripSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY_FILE);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
     // Assert that the subtitle is empty.
     assertEquals(0, subtitle.getEventTimeCount());
     assertTrue(subtitle.getCues(0).isEmpty());
@@ -43,8 +45,18 @@ public void testParseEmpty() throws IOException {
 
   public void testParseTypical() throws IOException {
     SubripParser parser = new SubripParser();
-    InputStream inputStream = getInputStream(TYPICAL_FILE);
-    SubripSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_FILE);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
+    assertEquals(6, subtitle.getEventTimeCount());
+    assertTypicalCue1(subtitle, 0);
+    assertTypicalCue2(subtitle, 2);
+    assertTypicalCue3(subtitle, 4);
+  }
+
+  public void testParseTypicalWithByteOrderMark() throws IOException {
+    SubripParser parser = new SubripParser();
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_WITH_BYTE_ORDER_MARK);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
     assertEquals(6, subtitle.getEventTimeCount());
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
@@ -53,8 +65,8 @@ public void testParseTypical() throws IOException {
 
   public void testParseTypicalExtraBlankLine() throws IOException {
     SubripParser parser = new SubripParser();
-    InputStream inputStream = getInputStream(TYPICAL_EXTRA_BLANK_LINE);
-    SubripSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_EXTRA_BLANK_LINE);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
     assertEquals(6, subtitle.getEventTimeCount());
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
@@ -64,8 +76,8 @@ public void testParseTypicalExtraBlankLine() throws IOException {
   public void testParseTypicalMissingTimecode() throws IOException {
     // Parsing should succeed, parsing the first and third cues only.
     SubripParser parser = new SubripParser();
-    InputStream inputStream = getInputStream(TYPICAL_MISSING_TIMECODE);
-    SubripSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_MISSING_TIMECODE);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
     assertEquals(4, subtitle.getEventTimeCount());
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue3(subtitle, 2);
@@ -74,8 +86,8 @@ public void testParseTypicalMissingTimecode() throws IOException {
   public void testParseTypicalMissingSequence() throws IOException {
     // Parsing should succeed, parsing the first and third cues only.
     SubripParser parser = new SubripParser();
-    InputStream inputStream = getInputStream(TYPICAL_MISSING_SEQUENCE);
-    SubripSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_MISSING_SEQUENCE);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
     assertEquals(4, subtitle.getEventTimeCount());
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue3(subtitle, 2);
@@ -83,8 +95,8 @@ public void testParseTypicalMissingSequence() throws IOException {
 
   public void testParseNoEndTimecodes() throws IOException {
     SubripParser parser = new SubripParser();
-    InputStream inputStream = getInputStream(NO_END_TIMECODES_FILE);
-    SubripSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), NO_END_TIMECODES_FILE);
+    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // Test event count.
     assertEquals(3, subtitle.getEventTimeCount());
@@ -105,10 +117,6 @@ public void testParseNoEndTimecodes() throws IOException {
         subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
   }
 
-  private InputStream getInputStream(String fileName) throws IOException {
-    return getInstrumentation().getContext().getResources().getAssets().open(fileName);
-  }
-
   private static void assertTypicalCue1(SubripSubtitle subtitle, int eventIndex) {
     assertEquals(0, subtitle.getEventTime(eventIndex));
     assertEquals("This is the first subtitle.",
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlColorParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlColorParserTest.java
index 922b054011..dec5c9c93f 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlColorParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlColorParserTest.java
@@ -24,10 +24,12 @@
 public class TtmlColorParserTest extends InstrumentationTestCase {
 
   public void testHexCodeParsing() {
-    assertEquals(Color.WHITE, TtmlColorParser.parseColor("#ffffff"));
-    assertEquals(Color.WHITE, TtmlColorParser.parseColor("#ffffffff"));
-    assertEquals(Color.parseColor("#00ffffff"), TtmlColorParser.parseColor("#00ffffff"));
-    assertEquals(Color.parseColor("#12341234"), TtmlColorParser.parseColor("#12341234"));
+    assertEquals(Color.WHITE, TtmlColorParser.parseColor("#FFFFFF"));
+    assertEquals(Color.WHITE, TtmlColorParser.parseColor("#FFFFFFFF"));
+    assertEquals(Color.parseColor("#FF123456"), TtmlColorParser.parseColor("#123456"));
+    // Hex colors in TTML are RGBA, where-as {@link Color#parseColor} takes ARGB.
+    assertEquals(Color.parseColor("#00FFFFFF"), TtmlColorParser.parseColor("#FFFFFF00"));
+    assertEquals(Color.parseColor("#78123456"), TtmlColorParser.parseColor("#12345678"));
   }
 
   public void testColorNameParsing() {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
index eef062bce1..64423c33f8 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.text.ttml;
 
+import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.text.Cue;
 
 import android.test.InstrumentationTestCase;
@@ -32,7 +33,6 @@
 import android.text.style.UnderlineSpan;
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.List;
 import java.util.Map;
 
@@ -471,8 +471,7 @@ private TtmlNode queryChildrenForTag(TtmlNode node, String tag, int pos) {
 
   private TtmlSubtitle getSubtitle(String file) throws IOException {
     TtmlParser ttmlParser = new TtmlParser();
-    InputStream inputStream = getInstrumentation().getContext()
-        .getResources().getAssets().open(file);
-    return (TtmlSubtitle) ttmlParser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), file);
+    return ttmlParser.parse(bytes, 0, bytes.length);
   }
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java
new file mode 100644
index 0000000000..2444dcca6f
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.Subtitle;
+import com.google.android.exoplayer.util.Util;
+
+import android.util.ArraySet;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Unit test for {@link Mp4WebvttParser}.
+ * As a side effect, it also involves the {@link Mp4WebvttSubtitle}.
+ */
+public final class Mp4WebvttParserTest extends TestCase {
+
+  private static final byte[] SINGLE_CUE_SAMPLE = {
+      0x00, 0x00, 0x00, 0x1C,  // Size
+      0x76, 0x74, 0x74, 0x63,  // "vttc" Box type. VTT Cue box begins:
+
+      0x00, 0x00, 0x00, 0x14,  // Contained payload box's size
+      0x70, 0x61, 0x79, 0x6c,  // Contained payload box's type (payl), Cue Payload Box begins:
+
+      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x0a // Hello World\n
+  };
+
+  private static final byte[] DOUBLE_CUE_SAMPLE = {
+      0x00, 0x00, 0x00, 0x1B,  // Size
+      0x76, 0x74, 0x74, 0x63,  // "vttc" Box type. First VTT Cue box begins:
+
+      0x00, 0x00, 0x00, 0x13,  // First contained payload box's size
+      0x70, 0x61, 0x79, 0x6c,  // First contained payload box's type (payl), Cue Payload Box begins:
+
+      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, // Hello World
+
+      0x00, 0x00, 0x00, 0x17,  // Size
+      0x76, 0x74, 0x74, 0x63,  // "vttc" Box type. Second VTT Cue box begins:
+
+      0x00, 0x00, 0x00, 0x0F,  // Contained payload box's size
+      0x70, 0x61, 0x79, 0x6c,  // Contained payload box's type (payl), Payload begins:
+
+      0x42, 0x79, 0x65, 0x20, 0x42, 0x79, 0x65  // Bye Bye
+  };
+
+  private static final byte[] NO_CUE_SAMPLE = {
+      0x00, 0x00, 0x00, 0x1B,  // Size
+      0x74, 0x74, 0x74, 0x63,  // "tttc" Box type, which is not a Cue. Should be skipped:
+
+      0x00, 0x00, 0x00, 0x13,  // Contained payload box's size
+      0x70, 0x61, 0x79, 0x6c,  // Contained payload box's type (payl), Cue Payload Box begins:
+
+      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64 // Hello World
+  };
+
+  private static final byte[] INCOMPLETE_HEADER_SAMPLE = {
+      0x00, 0x00, 0x00, 0x23,  // Size
+      0x76, 0x74, 0x74, 0x63,  // "vttc" Box type. VTT Cue box begins:
+
+      0x00, 0x00, 0x00, 0x14,  // Contained payload box's size
+      0x70, 0x61, 0x79, 0x6c,  // Contained payload box's type (payl), Cue Payload Box begins:
+
+      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x0a, // Hello World\n
+
+      0x00, 0x00, 0x00, 0x07, // Size of an incomplete header, which belongs to the first vttc box.
+      0x76, 0x74, 0x74
+  };
+
+  private Mp4WebvttParser parser;
+
+  @Override
+  public void setUp() {
+    parser = new Mp4WebvttParser();
+  }
+
+  // Positive tests.
+
+  public void testSingleCueSample() throws ParserException {
+    Subtitle result = parser.parse(SINGLE_CUE_SAMPLE, 0, SINGLE_CUE_SAMPLE.length);
+    Cue expectedCue = new Cue("Hello World"); // Line feed must be trimmed by the parser
+    assertMp4WebvttSubtitleEquals(result, expectedCue);
+  }
+
+  public void testTwoCuesSample() throws ParserException {
+    Subtitle result = parser.parse(DOUBLE_CUE_SAMPLE, 0, DOUBLE_CUE_SAMPLE.length);
+    Cue firstExpectedCue = new Cue("Hello World");
+    Cue secondExpectedCue = new Cue("Bye Bye");
+    assertMp4WebvttSubtitleEquals(result, firstExpectedCue, secondExpectedCue);
+  }
+
+  public void testNoCueSample() throws IOException {
+    Subtitle result = parser.parse(NO_CUE_SAMPLE, 0, NO_CUE_SAMPLE.length);
+    assertMp4WebvttSubtitleEquals(result, new Cue[] {});
+  }
+
+  // Negative tests.
+
+  public void testSampleWithIncompleteHeader() {
+    try {
+      parser.parse(INCOMPLETE_HEADER_SAMPLE, 0, INCOMPLETE_HEADER_SAMPLE.length);
+    } catch (ParserException e) {
+      return;
+    }
+    fail("The parser should have failed, no payload was included in the VTTCue.");
+  }
+
+  // Util methods
+
+  /**
+   * Asserts that the Subtitle's cues (which are all part of the event at t=0) are equal to the
+   * expected Cues.
+   *
+   * @param sub The parsed {@link Subtitle} to check.
+   * @param expectedCues Expected {@link Cue}s in order of appearance.
+   */
+  private static void assertMp4WebvttSubtitleEquals(Subtitle sub, Cue... expectedCues) {
+    assertEquals(1, sub.getEventTimeCount());
+    assertEquals(0, sub.getEventTime(0));
+    List<Cue> subtitleCues = sub.getCues(0);
+    assertEquals(expectedCues.length, subtitleCues.size());
+    for (int i = 0; i < subtitleCues.size(); i++) {
+      Set<String> differences = getCueDifferences(subtitleCues.get(i), expectedCues[i]);
+      assertTrue("Cues at position " + i + " are not equal. Different fields are "
+          + Arrays.toString(differences.toArray()), differences.isEmpty());
+    }
+  }
+
+  /**
+   * Checks whether two non null cues are equal. Check fails if any of the Cues are null.
+   *
+   * @return a set that contains the names of the different fields.
+   */
+  private static Set<String> getCueDifferences(Cue aCue, Cue anotherCue) {
+    assertNotNull(aCue);
+    assertNotNull(anotherCue);
+    Set<String> differences = new ArraySet<>();
+    if (aCue.line != anotherCue.line) {
+      differences.add("line: " + aCue.line + " | " + anotherCue.line);
+    }
+    if (aCue.lineAnchor != anotherCue.lineAnchor) {
+      differences.add("lineAnchor: " + aCue.lineAnchor + " | " + anotherCue.lineAnchor);
+    }
+    if (aCue.lineType != anotherCue.lineType) {
+      differences.add("lineType: " + aCue.lineType + " | " + anotherCue.lineType);
+    }
+    if (aCue.position != anotherCue.position) {
+      differences.add("position: " + aCue.position + " | " + anotherCue.position);
+    }
+    if (aCue.positionAnchor != anotherCue.positionAnchor) {
+      differences.add("positionAnchor: " + aCue.positionAnchor + " | " + anotherCue.positionAnchor);
+    }
+    if (aCue.size != anotherCue.size) {
+      differences.add("size: " + aCue.size + " | " + anotherCue.size);
+    }
+    if (!Util.areEqual(aCue.text.toString(), anotherCue.text.toString())) {
+      differences.add("text: '" + aCue.text + "' | '" + anotherCue.text + '\'');
+    }
+    if (!Util.areEqual(aCue.textAlignment, anotherCue.textAlignment)) {
+      differences.add("textAlignment: " + aCue.textAlignment + " | " + anotherCue.textAlignment);
+    }
+    return differences;
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java
index c5d1465b21..0737476ad9 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java
@@ -27,8 +27,7 @@
 public final class WebvttCueParserTest extends InstrumentationTestCase {
 
   public void testParseStrictValidClassesAndTrailingTokens() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("<v.first.loud Esme>"
+    Spanned text = parseCueText("<v.first.loud Esme>"
         + "This <u.style1.style2 some stuff>is</u> text with <b.foo><i.bar>html</i></b> tags");
 
     assertEquals("This is text with html tags", text.toString());
@@ -49,20 +48,16 @@ public void testParseStrictValidClassesAndTrailingTokens() throws Exception {
   }
 
   public void testParseStrictValidUnsupportedTagsStrippedOut() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse(
-        "<v.first.loud Esme>This <unsupported>is</unsupported> text with "
+    Spanned text = parseCueText("<v.first.loud Esme>This <unsupported>is</unsupported> text with "
         + "<notsupp><invalid>html</invalid></notsupp> tags");
-
     assertEquals("This is text with html tags", text.toString());
     assertEquals(0, getSpans(text, UnderlineSpan.class).length);
     assertEquals(0, getSpans(text, StyleSpan.class).length);
   }
 
   public void testParseWellFormedUnclosedEndAtCueEnd() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse(
-        "An <u some trailing stuff>unclosed u tag with <i>italic</i> inside");
+    Spanned text = parseCueText("An <u some trailing stuff>unclosed u tag with "
+        + "<i>italic</i> inside");
 
     assertEquals("An unclosed u tag with italic inside", text.toString());
 
@@ -79,9 +74,7 @@ public void testParseWellFormedUnclosedEndAtCueEnd() throws Exception {
   }
 
   public void testParseWellFormedUnclosedEndAtParent() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse(
-        "An unclosed u tag with <i><u>underline and italic</i> inside");
+    Spanned text = parseCueText("An unclosed u tag with <i><u>underline and italic</i> inside");
 
     assertEquals("An unclosed u tag with underline and italic inside", text.toString());
 
@@ -99,9 +92,7 @@ public void testParseWellFormedUnclosedEndAtParent() throws Exception {
   }
 
   public void testParseMalformedNestedElements() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse(
-        "<b><u>An unclosed u tag with <i>italic</u> inside</i></b>");
+    Spanned text = parseCueText("<b><u>An unclosed u tag with <i>italic</u> inside</i></b>");
     assertEquals("An unclosed u tag with italic inside", text.toString());
 
     UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
@@ -126,8 +117,7 @@ public void testParseMalformedNestedElements() throws Exception {
   }
 
   public void testParseCloseNonExistingTag() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("blah<b>blah</i>blah</b>blah");
+    Spanned text = parseCueText("blah<b>blah</i>blah</b>blah");
     assertEquals("blahblahblahblah", text.toString());
 
     StyleSpan[] spans = getSpans(text, StyleSpan.class);
@@ -138,50 +128,42 @@ public void testParseCloseNonExistingTag() throws Exception {
   }
 
   public void testParseEmptyTagName() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("An unclosed u tag with <>italic inside");
+    Spanned text = parseCueText("An unclosed u tag with <>italic inside");
     assertEquals("An unclosed u tag with italic inside", text.toString());
   }
 
   public void testParseEntities() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("&amp; &gt; &lt; &nbsp;");
+    Spanned text = parseCueText("&amp; &gt; &lt; &nbsp;");
     assertEquals("& > <  ", text.toString());
   }
 
   public void testParseEntitiesUnsupported() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("&noway; &sure;");
+    Spanned text = parseCueText("&noway; &sure;");
     assertEquals(" ", text.toString());
   }
 
   public void testParseEntitiesNotTerminated() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("&amp here comes text");
+    Spanned text = parseCueText("&amp here comes text");
     assertEquals("& here comes text", text.toString());
   }
 
   public void testParseEntitiesNotTerminatedUnsupported() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("&surenot here comes text");
+    Spanned text = parseCueText("&surenot here comes text");
     assertEquals(" here comes text", text.toString());
   }
 
   public void testParseEntitiesNotTerminatedNoSpace() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("&surenot");
+    Spanned text = parseCueText("&surenot");
     assertEquals("&surenot", text.toString());
   }
 
   public void testParseVoidTag() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("here comes<br/> text<br/>");
+    Spanned text = parseCueText("here comes<br/> text<br/>");
     assertEquals("here comes text", text.toString());
   }
 
   public void testParseMultipleTagsOfSameKind() {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("blah <b>blah</b> blah <b>foo</b>");
+    Spanned text = parseCueText("blah <b>blah</b> blah <b>foo</b>");
 
     assertEquals("blah blah blah foo", text.toString());
     StyleSpan[] spans = getSpans(text, StyleSpan.class);
@@ -195,8 +177,7 @@ public void testParseMultipleTagsOfSameKind() {
   }
 
   public void testParseInvalidVoidSlash() {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse("blah <b/.st1.st2 trailing stuff> blah");
+    Spanned text = parseCueText("blah <b/.st1.st2 trailing stuff> blah");
 
     assertEquals("blah  blah", text.toString());
     StyleSpan[] spans = getSpans(text, StyleSpan.class);
@@ -204,42 +185,46 @@ public void testParseInvalidVoidSlash() {
   }
 
   public void testParseMonkey() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse(
-        "< u>An unclosed u tag with <<<<< i>italic</u></u></u></u    ></i><u><u> inside");
-    assertEquals("An unclosed u tag with italic inside", text.toString());
-    text = parser.parse(">>>>>>>>>An unclosed u tag with <<<<< italic</u></u></u></u  >"
+    Spanned text = parseCueText("< u>An unclosed u tag with <<<<< i>italic</u></u></u></u    >"
         + "</i><u><u> inside");
+    assertEquals("An unclosed u tag with italic inside", text.toString());
+    text = parseCueText(">>>>>>>>>An unclosed u tag with <<<<< italic</u></u></u>"
+        + "</u  ></i><u><u> inside");
     assertEquals(">>>>>>>>>An unclosed u tag with  inside", text.toString());
   }
 
   public void testParseCornerCases() throws Exception {
-    WebvttCueParser parser = new WebvttCueParser();
-    Spanned text = parser.parse(">");
+    Spanned text = parseCueText(">");
     assertEquals(">", text.toString());
 
-    text = parser.parse("<");
+    text = parseCueText("<");
     assertEquals("", text.toString());
 
-    text = parser.parse("<b.st1.st2 annotation");
+    text = parseCueText("<b.st1.st2 annotation");
     assertEquals("", text.toString());
 
-    text = parser.parse("<<<<<<<<<<<<<<<<");
+    text = parseCueText("<<<<<<<<<<<<<<<<");
     assertEquals("", text.toString());
 
-    text = parser.parse("<<<<<<>><<<<<<<<<<");
+    text = parseCueText("<<<<<<>><<<<<<<<<<");
     assertEquals(">", text.toString());
 
-    text = parser.parse("<>");
+    text = parseCueText("<>");
     assertEquals("", text.toString());
 
-    text = parser.parse("&");
+    text = parseCueText("&");
     assertEquals("&", text.toString());
 
-    text = parser.parse("&&&&&&&");
+    text = parseCueText("&&&&&&&");
     assertEquals("&&&&&&&", text.toString());
   }
 
+  private static Spanned parseCueText(String string) {
+    WebvttCue.Builder builder = new WebvttCue.Builder();
+    WebvttCueParser.parseCueText(string, builder);
+    return (Spanned) builder.build().text;
+  }
+
   private static <T> T[] getSpans(Spanned text, Class<T> spanType) {
     return text.getSpans(0, text.length(), spanType);
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
index 07967e7df7..0c45bae33a 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer.text.webvtt;
 
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.text.Cue;
 
 import android.test.InstrumentationTestCase;
 import android.text.Layout.Alignment;
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.List;
 
 /**
@@ -39,21 +40,19 @@
 
   public void testParseEmpty() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
-        .open(EMPTY_FILE);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY_FILE);
     try {
-      parser.parse(inputStream);
-      fail("Expected IOException");
-    } catch (IOException expected) {
+      parser.parse(bytes, 0, bytes.length);
+      fail("Expected ParserException");
+    } catch (ParserException expected) {
       // Do nothing.
     }
   }
 
   public void testParseTypical() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream =
-        getInstrumentation().getContext().getResources().getAssets().open(TYPICAL_FILE);
-    WebvttSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_FILE);
+    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
     assertEquals(4, subtitle.getEventTimeCount());
@@ -65,9 +64,8 @@ public void testParseTypical() throws IOException {
 
   public void testParseTypicalWithIds() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
-        .open(TYPICAL_WITH_IDS_FILE);
-    WebvttSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_WITH_IDS_FILE);
+    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
     assertEquals(4, subtitle.getEventTimeCount());
@@ -79,9 +77,8 @@ public void testParseTypicalWithIds() throws IOException {
 
   public void testParseTypicalWithComments() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
-        .open(TYPICAL_WITH_COMMENTS_FILE);
-    WebvttSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_WITH_COMMENTS_FILE);
+    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
     assertEquals(4, subtitle.getEventTimeCount());
@@ -93,9 +90,8 @@ public void testParseTypicalWithComments() throws IOException {
 
   public void testParseWithTags() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
-        .open(WITH_TAGS_FILE);
-    WebvttSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), WITH_TAGS_FILE);
+    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
     assertEquals(8, subtitle.getEventTimeCount());
@@ -109,9 +105,8 @@ public void testParseWithTags() throws IOException {
 
   public void testParseWithPositioning() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
-        .open(WITH_POSITIONING_FILE);
-    WebvttSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), WITH_POSITIONING_FILE);
+    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
     assertEquals(10, subtitle.getEventTimeCount());
@@ -135,9 +130,8 @@ public void testParseWithPositioning() throws IOException {
 
   public void testParseWithBadCueHeader() throws IOException {
     WebvttParser parser = new WebvttParser();
-    InputStream inputStream =
-        getInstrumentation().getContext().getResources().getAssets().open(WITH_BAD_CUE_HEADER_FILE);
-    WebvttSubtitle subtitle = parser.parse(inputStream);
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), WITH_BAD_CUE_HEADER_FILE);
+    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
     assertEquals(4, subtitle.getEventTimeCount());
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
index 235a1a53a3..a7b5b89f46 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
@@ -18,6 +18,7 @@
 import junit.framework.TestCase;
 
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.Arrays;
 
 /**
@@ -278,4 +279,148 @@ public void testReadingBytesReturnsCopy() {
     assertTrue(Arrays.equals(parsableByteArray.data, copy));
   }
 
+  public void testReadLittleEndianLong() {
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+        0x01, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, (byte) 0xFF
+    });
+    assertEquals(0xFF00000000000001L, byteArray.readLittleEndianLong());
+    assertEquals(8, byteArray.getPosition());
+  }
+
+  public void testReadLittleEndianUnsignedInt() {
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[] {
+        0x10, 0x00, 0x00, (byte) 0xFF
+    });
+    assertEquals(0xFF000010L, byteArray.readLittleEndianUnsignedInt());
+    assertEquals(4, byteArray.getPosition());
+  }
+
+  public void testReadLittleEndianInt() {
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+        0x01, 0x00, 0x00, (byte) 0xFF
+    });
+    assertEquals(0xFF000001, byteArray.readLittleEndianInt());
+    assertEquals(4, byteArray.getPosition());
+  }
+
+  public void testReadLittleEndianUnsignedInt24() {
+    byte[] data = { 0x01, 0x02, (byte) 0xFF };
+    ParsableByteArray byteArray = new ParsableByteArray(data);
+    assertEquals(0xFF0201, byteArray.readLittleEndianUnsignedInt24());
+    assertEquals(3, byteArray.getPosition());
+  }
+
+  public void testReadLittleEndianUnsignedShort() {
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+        0x01, (byte) 0xFF, 0x02, (byte) 0xFF
+    });
+    assertEquals(0xFF01, byteArray.readLittleEndianUnsignedShort());
+    assertEquals(2, byteArray.getPosition());
+    assertEquals(0xFF02, byteArray.readLittleEndianUnsignedShort());
+    assertEquals(4, byteArray.getPosition());
+  }
+
+  public void testReadLittleEndianShort() {
+    ParsableByteArray byteArray = new ParsableByteArray(new byte[]{
+        0x01, (byte) 0xFF, 0x02, (byte) 0xFF
+    });
+    assertEquals((short) 0xFF01, byteArray.readLittleEndianShort());
+    assertEquals(2, byteArray.getPosition());
+    assertEquals((short) 0xFF02, byteArray.readLittleEndianShort());
+    assertEquals(4, byteArray.getPosition());
+  }
+
+  public void testReadString() {
+    byte[] data = {
+        (byte) 0xC3, (byte) 0xA4, (byte) 0x20,
+        (byte) 0xC3, (byte) 0xB6, (byte) 0x20,
+        (byte) 0xC2, (byte) 0xAE, (byte) 0x20,
+        (byte) 0xCF, (byte) 0x80, (byte) 0x20,
+        (byte) 0xE2, (byte) 0x88, (byte) 0x9A, (byte) 0x20,
+        (byte) 0xC2, (byte) 0xB1, (byte) 0x20,
+        (byte) 0xE8, (byte) 0xB0, (byte) 0xA2, (byte) 0x20,
+    };
+    ParsableByteArray byteArray = new ParsableByteArray(data);
+    assertEquals("ä ö ® π √ ± 谢 ", byteArray.readString(data.length));
+    assertEquals(data.length, byteArray.getPosition());
+  }
+
+  public void testReadAsciiString() {
+    byte[] data = new byte[] {'t', 'e', 's', 't'};
+    ParsableByteArray testArray = new ParsableByteArray(data);
+    assertEquals("test", testArray.readString(data.length, Charset.forName("US-ASCII")));
+    assertEquals(data.length, testArray.getPosition());
+  }
+
+  public void testReadStringOutOfBoundsDoesNotMovePosition() {
+    byte[] data = {
+        (byte) 0xC3, (byte) 0xA4, (byte) 0x20
+    };
+    ParsableByteArray byteArray = new ParsableByteArray(data);
+    try {
+      byteArray.readString(data.length + 1);
+      fail();
+    } catch (StringIndexOutOfBoundsException e) {
+      assertEquals(0, byteArray.getPosition());
+    }
+  }
+
+  public void testReadEmptyString() {
+    byte[] bytes = new byte[0];
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertNull(parser.readLine());
+  }
+
+  public void testReadSingleLineWithoutEndingTrail() {
+    byte[] bytes = new byte[] {
+      'f', 'o', 'o'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readLine());
+    assertNull(parser.readLine());
+  }
+
+  public void testReadSingleLineWithEndingLf() {
+    byte[] bytes = new byte[] {
+      'f', 'o', 'o', '\n'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readLine());
+    assertNull(parser.readLine());
+  }
+
+  public void testReadTwoLinesWithCrFollowedByLf() {
+    byte[] bytes = new byte[] {
+      'f', 'o', 'o', '\r', '\n', 'b', 'a', 'r'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readLine());
+    assertEquals("bar", parser.readLine());
+    assertNull(parser.readLine());
+  }
+
+  public void testReadThreeLinesWithEmptyLine() {
+    byte[] bytes = new byte[] {
+      'f', 'o', 'o', '\r', '\n', '\r', 'b', 'a', 'r'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readLine());
+    assertEquals("", parser.readLine());
+    assertEquals("bar", parser.readLine());
+    assertNull(parser.readLine());
+  }
+
+  public void testReadFourLinesWithLfFollowedByCr() {
+    byte[] bytes = new byte[] {
+      'f', 'o', 'o', '\n', '\r', '\r', 'b', 'a', 'r', '\r', '\n'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readLine());
+    assertEquals("", parser.readLine());
+    assertEquals("", parser.readLine());
+    assertEquals("bar", parser.readLine());
+    assertNull(parser.readLine());
+  }
+
 }
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 332b9178d7..7dd9bb7ccd 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -17,13 +17,6 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer">
 
-  <!-- For streaming media over the network. -->
-  <uses-permission android:name="android.permission.INTERNET"/>
-  <!-- For reading media from external storage. -->
-  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
-  <!-- For writing media to external storage. -->
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
-
   <!--
     Important: ExoPlayerLib specifies a minSdkVersion of 9 because various components provided by
     the library may be of use on older devices. However, please note that the core video playback
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
index de0c73bdb1..5d265a64ff 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
@@ -273,42 +273,6 @@ public static ExoPlayer newInstance(int rendererCount) {
    */
   public void prepare(TrackRenderer... renderers);
 
-  /**
-   * Returns whether the renderer at the given index has media to play.
-   * <p>
-   * Always returns false whilst the player is in the {@link #STATE_PREPARING} state.
-   *
-   * @deprecated Use {@code getTrackCount(rendererIndex) > 0}.
-   * @param rendererIndex The index of the renderer.
-   * @return True if the renderer has media to play, false otherwise.
-   */
-  @Deprecated
-  public boolean getRendererHasMedia(int rendererIndex);
-
-  /**
-   * Sets whether the renderer at the given index is enabled.
-   *
-   * @deprecated Use {@code setSelectedTrack(rendererIndex, trackIndex)}. Passing
-   *     {@link #TRACK_DEFAULT} as {@code trackIndex} is equivalent to enabling the renderer with
-   *     this method. Passing {@link #TRACK_DISABLED} is equivalent to disabling the renderer.
-   * @param rendererIndex The index of the renderer.
-   * @param enabled Whether the renderer at the given index should be enabled.
-   */
-  @Deprecated
-  public void setRendererEnabled(int rendererIndex, boolean enabled);
-
-  /**
-   * Whether the renderer at the given index is enabled.
-   *
-   * @deprecated Use {@code getSelectedTrack(rendererIndex)}. A non-negative return value from that
-   *     method is equivalent to this method returning true. A negative return value is equivalent
-   *     to this method returning false.
-   * @param rendererIndex The index of the renderer.
-   * @return Whether the renderer is enabled.
-   */
-  @Deprecated
-  public boolean getRendererEnabled(int rendererIndex);
-
   /**
    * Returns the number of tracks exposed by the specified renderer.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
index 2924a3ba6c..5450a2b94c 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
@@ -96,24 +96,6 @@ public void prepare(TrackRenderer... renderers) {
     internalPlayer.prepare(renderers);
   }
 
-  @Deprecated
-  @Override
-  public boolean getRendererHasMedia(int rendererIndex) {
-    return getTrackCount(rendererIndex) > 0;
-  }
-
-  @Deprecated
-  @Override
-  public void setRendererEnabled(int rendererIndex, boolean enabled) {
-    setSelectedTrack(rendererIndex, enabled ? ExoPlayer.TRACK_DEFAULT : ExoPlayer.TRACK_DISABLED);
-  }
-
-  @Deprecated
-  @Override
-  public boolean getRendererEnabled(int rendererIndex) {
-    return getSelectedTrack(rendererIndex) >= 0;
-  }
-
   @Override
   public int getTrackCount(int rendererIndex) {
     return trackFormats[rendererIndex] != null ? trackFormats[rendererIndex].length : 0;
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index f6658548a4..e8a79efa04 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -640,7 +640,9 @@ private void setRendererSelectedTrackInternal(int rendererIndex, int trackIndex)
     if (shouldEnable) {
       // Re-enable the renderer with the newly selected track.
       boolean playing = playWhenReady && state == ExoPlayer.STATE_READY;
-      renderer.enable(trackIndex, positionUs, playing);
+      // Consider as joining if the renderer was previously disabled, but not when switching tracks.
+      boolean joining = !isEnabled && playing;
+      renderer.enable(trackIndex, positionUs, joining);
       enabledRenderers.add(renderer);
       if (playing) {
         renderer.start();
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index e64ec76b8d..96f8124789 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.3";
+  public static final String VERSION = "1.5.4";
 
   /**
    * The version of the library, expressed as an integer.
@@ -31,7 +31,7 @@
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001005003;
+  public static final int VERSION_INT = 001005004;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index e5ea8f7863..eb54971a39 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -80,7 +80,8 @@
   private int[] trackStates;
   private boolean[] pendingDiscontinuities;
 
-  private long seekPositionUs;
+  private long lastSeekPositionUs;
+  private long pendingSeekPositionUs;
 
   /**
    * Instantiates a new sample extractor reading from the specified {@code uri}.
@@ -184,16 +185,21 @@ public boolean continueBuffering(int track, long positionUs) {
     return true;
   }
 
+  @Override
+  public long readDiscontinuity(int track) {
+    if (pendingDiscontinuities[track]) {
+      pendingDiscontinuities[track] = false;
+      return lastSeekPositionUs;
+    }
+    return NO_DISCONTINUITY;
+  }
+
   @Override
   public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
+      SampleHolder sampleHolder) {
     Assertions.checkState(prepared);
     Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
     if (pendingDiscontinuities[track]) {
-      pendingDiscontinuities[track] = false;
-      return DISCONTINUITY_READ;
-    }
-    if (onlyReadDiscontinuity) {
       return NOTHING_READ;
     }
     if (trackStates[track] != TRACK_STATE_FORMAT_SENT) {
@@ -216,7 +222,7 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
       if (sampleHolder.isEncrypted()) {
         sampleHolder.cryptoInfo.setFromExtractorV16(extractor);
       }
-      seekPositionUs = C.UNKNOWN_TIME_US;
+      pendingSeekPositionUs = C.UNKNOWN_TIME_US;
       extractor.advance();
       return SAMPLE_READ;
     } else {
@@ -285,8 +291,9 @@ private DrmInitData getDrmInitDataV18() {
   private void seekToUsInternal(long positionUs, boolean force) {
     // Unless forced, avoid duplicate calls to the underlying extractor's seek method in the case
     // that there have been no interleaving calls to readSample.
-    if (force || seekPositionUs != positionUs) {
-      seekPositionUs = positionUs;
+    if (force || pendingSeekPositionUs != positionUs) {
+      lastSeekPositionUs = positionUs;
+      pendingSeekPositionUs = positionUs;
       extractor.seekTo(positionUs, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
       for (int i = 0; i < trackStates.length; ++i) {
         if (trackStates[i] != TRACK_STATE_DISABLED) {
diff --git a/library/src/main/java/com/google/android/exoplayer/LoadControl.java b/library/src/main/java/com/google/android/exoplayer/LoadControl.java
index d7b2091ccd..12d8578efa 100644
--- a/library/src/main/java/com/google/android/exoplayer/LoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer/LoadControl.java
@@ -26,7 +26,7 @@
    * Registers a loader.
    *
    * @param loader The loader being registered.
-   * @param bufferSizeContribution For controls whose {@link Allocator}s maintain a pool of memory
+   * @param bufferSizeContribution For instances whose {@link Allocator} maintains a pool of memory
    *     for the purpose of satisfying allocation requests, this is a hint indicating the loader's
    *     desired contribution to the size of the pool, in bytes.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 6f641b19e1..afe93e6a7a 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -86,14 +86,10 @@
    */
   public static final int MSG_SET_PLAYBACK_PARAMS = 2;
 
-  /**
-   * The name for the raw (passthrough) decoder OMX component.
-   */
-  private static final String RAW_DECODER_NAME = "OMX.google.raw.decoder";
-
   private final EventListener eventListener;
   private final AudioTrack audioTrack;
 
+  private boolean passthroughEnabled;
   private android.media.MediaFormat passthroughMediaFormat;
   private int audioSessionId;
   private long currentPositionUs;
@@ -104,13 +100,15 @@
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    */
-  public MediaCodecAudioTrackRenderer(SampleSource source) {
-    this(source, null, true);
+  public MediaCodecAudioTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector) {
+    this(source, mediaCodecSelector, null, true);
   }
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
    *     content is not required.
    * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
@@ -119,24 +117,26 @@ public MediaCodecAudioTrackRenderer(SampleSource source) {
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    */
-  public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys) {
-    this(source, drmSessionManager, playClearSamplesWithoutKeys, null, null);
+  public MediaCodecAudioTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys) {
+    this(source, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, null, null);
   }
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public MediaCodecAudioTrackRenderer(SampleSource source, Handler eventHandler,
-      EventListener eventListener) {
-    this(source, null, true, eventHandler, eventListener);
+  public MediaCodecAudioTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector,
+      Handler eventHandler, EventListener eventListener) {
+    this(source, mediaCodecSelector, null, true, eventHandler, eventListener);
   }
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
    *     content is not required.
    * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
@@ -148,36 +148,16 @@ public MediaCodecAudioTrackRenderer(SampleSource source, Handler eventHandler,
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener) {
-    this(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener,
-        null);
-  }
-
-  /**
-   * @param source The upstream source from which the renderer obtains samples.
-   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
-   *     content is not required.
-   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
-   *     For example a media file may start with a short clear region so as to allow playback to
-   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
-   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
-   *     has obtained the keys necessary to decrypt encrypted regions of the media.
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
-   *     default capabilities (no encoded audio passthrough support) should be assumed.
-   */
-  public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener,
-      AudioCapabilities audioCapabilities) {
-    this(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener,
-        audioCapabilities, AudioManager.STREAM_MUSIC);
+  public MediaCodecAudioTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
+      Handler eventHandler, EventListener eventListener) {
+    this(source, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
+        eventListener, null, AudioManager.STREAM_MUSIC);
   }
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
    *     content is not required.
    * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
@@ -192,20 +172,38 @@ public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSe
    *     default capabilities (no encoded audio passthrough support) should be assumed.
    * @param streamType The type of audio stream for the {@link AudioTrack}.
    */
-  public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener,
-      AudioCapabilities audioCapabilities, int streamType) {
-    super(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener);
+  public MediaCodecAudioTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
+      Handler eventHandler, EventListener eventListener, AudioCapabilities audioCapabilities,
+      int streamType) {
+    super(source, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
+        eventListener);
     this.eventListener = eventListener;
     this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     this.audioTrack = new AudioTrack(audioCapabilities, streamType);
   }
 
   @Override
-  protected DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+  protected boolean handlesTrack(MediaCodecSelector mediaCodecSelector, MediaFormat mediaFormat)
       throws DecoderQueryException {
-    return allowPassthrough(mimeType) ? new DecoderInfo(RAW_DECODER_NAME, true)
-        : super.getDecoderInfo(mimeType, requiresSecureDecoder);
+    String mimeType = mediaFormat.mimeType;
+    return MimeTypes.isAudio(mimeType) && (MimeTypes.AUDIO_UNKNOWN.equals(mimeType)
+        || (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderName() != null)
+        || mediaCodecSelector.getDecoderInfo(mediaFormat, false) != null);
+  }
+
+  @Override
+  protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, MediaFormat format,
+      boolean requiresSecureDecoder) throws DecoderQueryException {
+    if (allowPassthrough(format.mimeType)) {
+      String passthroughDecoderName = mediaCodecSelector.getPassthroughDecoderName();
+      if (passthroughDecoderName != null) {
+        passthroughEnabled = true;
+        return new DecoderInfo(passthroughDecoderName, false);
+      }
+    }
+    passthroughEnabled = false;
+    return super.getDecoderInfo(mediaCodecSelector, format, requiresSecureDecoder);
   }
 
   /**
@@ -221,10 +219,10 @@ protected boolean allowPassthrough(String mimeType) {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, String codecName, boolean codecIsAdaptive,
+  protected void configureCodec(MediaCodec codec, boolean codecIsAdaptive,
       android.media.MediaFormat format, android.media.MediaCrypto crypto) {
     String mimeType = format.getString(android.media.MediaFormat.KEY_MIME);
-    if (RAW_DECODER_NAME.equals(codecName) && !MimeTypes.AUDIO_RAW.equals(mimeType)) {
+    if (passthroughEnabled) {
       // Override the MIME type used to configure the codec if we are using a passthrough decoder.
       format.setString(android.media.MediaFormat.KEY_MIME, MimeTypes.AUDIO_RAW);
       codec.configure(format, null, crypto, 0);
@@ -241,21 +239,6 @@ protected MediaClock getMediaClock() {
     return this;
   }
 
-  @Override
-  protected boolean handlesTrack(MediaFormat mediaFormat) throws DecoderQueryException {
-    // TODO: Use MediaCodecList.findDecoderForFormat on API 23.
-    String mimeType = mediaFormat.mimeType;
-    return MimeTypes.isAudio(mimeType) && (MimeTypes.AUDIO_UNKNOWN.equals(mimeType)
-        || allowPassthrough(mimeType) || MediaCodecUtil.getDecoderInfo(mimeType, false) != null);
-  }
-
-  @Override
-  protected void onEnabled(int track, long positionUs, boolean joining)
-      throws ExoPlaybackException {
-    super.onEnabled(track, positionUs, joining);
-    seekToInternal(positionUs);
-  }
-
   @Override
   protected void onOutputFormatChanged(android.media.MediaFormat outputFormat) {
     boolean passthrough = passthroughMediaFormat != null;
@@ -322,13 +305,8 @@ protected void onDisabled() throws ExoPlaybackException {
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal(positionUs);
-  }
-
-  private void seekToInternal(long positionUs) {
-    // TODO: Try and re-use the same AudioTrack instance once [Internal: b/7941810] is fixed.
+  protected void onDiscontinuity(long positionUs) throws ExoPlaybackException {
+    super.onDiscontinuity(positionUs);
     audioTrack.reset();
     currentPositionUs = positionUs;
     allowPositionDiscontinuity = true;
@@ -386,7 +364,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      handleDiscontinuity();
+      handleAudioTrackDiscontinuity();
       allowPositionDiscontinuity = true;
     }
 
@@ -405,7 +383,7 @@ protected void onOutputStreamEnded() {
     audioTrack.handleEndOfStream();
   }
 
-  protected void handleDiscontinuity() {
+  protected void handleAudioTrackDiscontinuity() {
     // Do nothing
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
new file mode 100644
index 0000000000..40378b40fd
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
+
+import android.media.MediaCodec;
+
+/**
+ * Selector of {@link MediaCodec} instances.
+ */
+public interface MediaCodecSelector {
+
+  /**
+   * Default implementation of {@link MediaCodecSelector}.
+   */
+  public static final MediaCodecSelector DEFAULT = new MediaCodecSelector() {
+
+    /**
+     * The name for the raw (passthrough) decoder OMX component.
+     */
+    private static final String RAW_DECODER_NAME = "OMX.google.raw.decoder";
+
+    @Override
+    public DecoderInfo getDecoderInfo(MediaFormat format, boolean requiresSecureDecoder)
+        throws DecoderQueryException {
+      return MediaCodecUtil.getDecoderInfo(format.mimeType, requiresSecureDecoder);
+    }
+
+    @Override
+    public String getPassthroughDecoderName() throws DecoderQueryException {
+      // TODO: Return null if the raw decoder doesn't exist.
+      return RAW_DECODER_NAME;
+    }
+
+  };
+
+  /**
+   * Selects a decoder to instantiate for a given format.
+   *
+   * @param format The format for which a decoder is required.
+   * @param requiresSecureDecoder Whether a secure decoder is required.
+   * @return A {@link DecoderInfo} describing the decoder to instantiate, or null if no suitable
+   *     decoder exists.
+   * @throws DecoderQueryException Thrown if there was an error querying decoders.
+   */
+  DecoderInfo getDecoderInfo(MediaFormat format, boolean requiresSecureDecoder)
+      throws DecoderQueryException;
+
+  /**
+   * Gets the name of a decoder suitable for audio passthrough.
+   *
+   * @return The name of a decoder suitable for audio passthrough, or null if no suitable decoder
+   *     exists.
+   * @throws DecoderQueryException Thrown if there was an error querying decoders.
+   */
+  String getPassthroughDecoderName() throws DecoderQueryException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index ff7f9027c6..0f1d42e5e1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -194,6 +194,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
 
   public final CodecCounters codecCounters;
 
+  private final MediaCodecSelector mediaCodecSelector;
   private final DrmSessionManager drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
   private final SampleHolder sampleHolder;
@@ -207,6 +208,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private DrmInitData drmInitData;
   private MediaCodec codec;
   private boolean codecIsAdaptive;
+  private boolean codecNeedsFlushWorkaround;
   private boolean codecNeedsEosPropagationWorkaround;
   private boolean codecNeedsEosFlushWorkaround;
   private boolean codecReceivedEos;
@@ -229,21 +231,24 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
    *     media is not required.
    * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
    *     For example a media file may start with a short clear region so as to allow playback to
-   *     begin in parallel with key acquisision. This parameter specifies whether the renderer is
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public MediaCodecTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener) {
+  public MediaCodecTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
+      Handler eventHandler, EventListener eventListener) {
     super(source);
     Assertions.checkState(Util.SDK_INT >= 16);
+    this.mediaCodecSelector = Assertions.checkNotNull(mediaCodecSelector);
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     this.eventHandler = eventHandler;
@@ -258,24 +263,34 @@ public MediaCodecTrackRenderer(SampleSource source, DrmSessionManager drmSession
   }
 
   @Override
-  protected void onEnabled(int track, long positionUs, boolean joining)
-      throws ExoPlaybackException {
-    super.onEnabled(track, positionUs, joining);
-    seekToInternal();
+  protected final boolean handlesTrack(MediaFormat mediaFormat) throws DecoderQueryException {
+    return handlesTrack(mediaCodecSelector, mediaFormat);
   }
 
   /**
-   * Returns a {@link DecoderInfo} for decoding media in the specified MIME type.
+   * Returns whether this renderer is capable of handling the provided track.
+   *
+   * @param mediaCodecSelector The decoder selector.
+   * @param mediaFormat The format of the track.
+   * @return True if the renderer can handle the track, false otherwise.
+   * @throws DecoderQueryException Thrown if there was an error querying decoders.
+   */
+  protected abstract boolean handlesTrack(MediaCodecSelector mediaCodecSelector,
+      MediaFormat mediaFormat) throws DecoderQueryException;
+
+  /**
+   * Returns a {@link DecoderInfo} for a given format.
    *
-   * @param mimeType The type of media to decode.
-   * @param requiresSecureDecoder Whether a secure decoder is needed for decoding {@code mimeType}.
-   * @return {@link DecoderInfo} for decoding media in the specified MIME type, or {@code null} if
-   *     no suitable decoder is available.
+   * @param mediaCodecSelector The decoder selector.
+   * @param mediaFormat The format for which a decoder is required.
+   * @param requiresSecureDecoder Whether a secure decoder is required.
+   * @return A {@link DecoderInfo} describing the decoder to instantiate, or null if no suitable
+   *     decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  protected DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
-      throws DecoderQueryException {
-    return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
+  protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
+      MediaFormat mediaFormat, boolean requiresSecureDecoder) throws DecoderQueryException {
+    return mediaCodecSelector.getDecoderInfo(format, requiresSecureDecoder);
   }
 
   /**
@@ -283,12 +298,11 @@ protected DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDeco
    * wish to configure the codec with a non-null surface.
    *
    * @param codec The {@link MediaCodec} to configure.
-   * @param codecName The name of the codec.
    * @param codecIsAdaptive Whether the codec is adaptive.
    * @param format The format for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
    */
-  protected void configureCodec(MediaCodec codec, String codecName, boolean codecIsAdaptive,
+  protected void configureCodec(MediaCodec codec, boolean codecIsAdaptive,
       android.media.MediaFormat format, MediaCrypto crypto) {
     codec.configure(format, null, crypto, 0);
   }
@@ -325,7 +339,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
 
     DecoderInfo decoderInfo = null;
     try {
-      decoderInfo = getDecoderInfo(mimeType, requiresSecureDecoder);
+      decoderInfo = getDecoderInfo(mediaCodecSelector, format, requiresSecureDecoder);
     } catch (DecoderQueryException e) {
       notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e,
           requiresSecureDecoder, DecoderInitializationException.DECODER_QUERY_ERROR));
@@ -338,6 +352,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
 
     String codecName = decoderInfo.name;
     codecIsAdaptive = decoderInfo.adaptive;
+    codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
     codecNeedsEosPropagationWorkaround = codecNeedsEosPropagationWorkaround(codecName);
     codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
     try {
@@ -346,8 +361,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
-      configureCodec(codec, codecName, codecIsAdaptive, format.getFrameworkMediaFormatV16(),
-          mediaCrypto);
+      configureCodec(codec, decoderInfo.adaptive, format.getFrameworkMediaFormatV16(), mediaCrypto);
       TraceUtil.endSection();
       TraceUtil.beginSection("codec.start()");
       codec.start();
@@ -417,6 +431,7 @@ protected void releaseCodec() {
       codecReconfigured = false;
       codecHasQueuedBuffers = false;
       codecIsAdaptive = false;
+      codecNeedsFlushWorkaround = false;
       codecNeedsEosPropagationWorkaround = false;
       codecNeedsEosFlushWorkaround = false;
       codecReceivedEos = false;
@@ -436,15 +451,13 @@ protected void releaseCodec() {
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal();
-  }
-
-  private void seekToInternal() {
+  protected void onDiscontinuity(long positionUs) throws ExoPlaybackException {
     sourceState = SOURCE_STATE_NOT_READY;
     inputStreamEnded = false;
     outputStreamEnded = false;
+    if (codec != null) {
+      flushCodec();
+    }
   }
 
   @Override
@@ -458,11 +471,11 @@ protected void onStopped() {
   }
 
   @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    sourceState = continueBufferingSource(positionUs)
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
+    sourceState = sourceIsReady
         ? (sourceState == SOURCE_STATE_NOT_READY ? SOURCE_STATE_READY : sourceState)
         : SOURCE_STATE_NOT_READY;
-    checkForDiscontinuity(positionUs);
     if (format == null) {
       readFormat(positionUs);
     }
@@ -479,22 +492,12 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
   }
 
   private void readFormat(long positionUs) throws ExoPlaybackException {
-    int result = readSource(positionUs, formatHolder, sampleHolder, false);
+    int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       onInputFormatChanged(formatHolder);
     }
   }
 
-  private void checkForDiscontinuity(long positionUs) throws ExoPlaybackException {
-    if (codec == null) {
-      return;
-    }
-    int result = readSource(positionUs, formatHolder, sampleHolder, true);
-    if (result == SampleSource.DISCONTINUITY_READ) {
-      flushCodec();
-    }
-  }
-
   private void flushCodec() throws ExoPlaybackException {
     codecHotswapTimeMs = -1;
     inputIndex = -1;
@@ -502,7 +505,7 @@ private void flushCodec() throws ExoPlaybackException {
     waitingForFirstSyncFrame = true;
     waitingForKeys = false;
     decodeOnlyPresentationTimestamps.clear();
-    if (Util.SDK_INT < 18 || (codecNeedsEosFlushWorkaround && codecReceivedEos)) {
+    if (codecNeedsFlushWorkaround || (codecNeedsEosFlushWorkaround && codecReceivedEos)) {
       // Workaround framework bugs. See [Internal: b/8347958, b/8578467, b/8543366, b/23361053].
       releaseCodec();
       maybeInitCodec();
@@ -576,7 +579,7 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
         }
         codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;
       }
-      result = readSource(positionUs, formatHolder, sampleHolder, false);
+      result = readSource(positionUs, formatHolder, sampleHolder);
       if (firstFeed && sourceState == SOURCE_STATE_READY && result == SampleSource.NOTHING_READ) {
         sourceState = SOURCE_STATE_READY_READ_MAY_FAIL;
       }
@@ -585,10 +588,6 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
     if (result == SampleSource.NOTHING_READ) {
       return false;
     }
-    if (result == SampleSource.DISCONTINUITY_READ) {
-      flushCodec();
-      return true;
-    }
     if (result == SampleSource.FORMAT_READ) {
       if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
         // We received two formats in a row. Clear the current buffer of any reconfiguration data
@@ -731,8 +730,10 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
    * The default implementation is a no-op.
    *
    * @param outputFormat The new output format.
+   * @throws ExoPlaybackException If an error occurs on output format change.
    */
-  protected void onOutputFormatChanged(android.media.MediaFormat outputFormat) {
+  protected void onOutputFormatChanged(android.media.MediaFormat outputFormat)
+      throws ExoPlaybackException {
     // Do nothing.
   }
 
@@ -923,6 +924,23 @@ private int getDecodeOnlyIndex(long presentationTimeUs) {
     return -1;
   }
 
+  /**
+   * Returns whether the decoder is known to fail when flushed.
+   * <p>
+   * If true is returned, the renderer will work around the issue by releasing the decoder and
+   * instantiating a new one rather than flushing the current instance.
+   *
+   * @param name The name of the decoder.
+   * @return True if the decoder is known to fail when flushed.
+   */
+  private static boolean codecNeedsFlushWorkaround(String name) {
+    return Util.SDK_INT < 18
+        || (Util.SDK_INT == 18
+            && ("OMX.SEC.avc.dec".equals(name) || "OMX.SEC.avc.dec.secure".equals(name)))
+        || (Util.SDK_INT == 19 && Util.MODEL.startsWith("SM-G800")
+            && ("OMX.Exynos.avc.dec".equals(name) || "OMX.Exynos.avc.dec.secure".equals(name)));
+  }
+
   /**
    * Returns whether the decoder is known to handle the propagation of the
    * {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} flag incorrectly on the host device.
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 8380108f29..9ff406de56 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -110,9 +110,11 @@ public static synchronized void warmCodec(String mimeType, boolean secure) {
     MediaCodecListCompat mediaCodecList = Util.SDK_INT >= 21
         ? new MediaCodecListCompatV21(secure) : new MediaCodecListCompatV16();
     Pair<String, CodecCapabilities> codecInfo = getMediaCodecInfo(key, mediaCodecList);
-    // TODO: Verify this cannot occur on v22, and change >= to == [Internal: b/18678462].
-    if (secure && codecInfo == null && Util.SDK_INT >= 21) {
-      // Some devices don't list secure decoders on API level 21. Try the legacy path.
+    if (secure && codecInfo == null && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
+      // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
+      // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
+      // TODO: Verify that the issue cannot occur on API levels 22 and 23, and tighten this block
+      // to execute on API level 21 only if confirmed.
       mediaCodecList = new MediaCodecListCompatV16();
       codecInfo = getMediaCodecInfo(key, mediaCodecList);
       if (codecInfo != null) {
@@ -184,9 +186,15 @@ private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
     }
 
     // Work around broken audio decoders.
-    if ((Util.SDK_INT < 18 && "CIPAACDecoder".equals(name))
-        || (Util.SDK_INT < 18 && "CIPMP3Decoder".equals(name))
-        || (Util.SDK_INT < 20 && "AACDecoder".equals(name))) {
+    if (Util.SDK_INT < 21
+        && ("CIPAACDecoder".equals(name))
+            || "CIPMP3Decoder".equals(name)
+            || "CIPVorbisDecoder".equals(name)
+            || "AACDecoder".equals(name)
+            || "MP3Decoder".equals(name)) {
+      return false;
+    }
+    if (Util.SDK_INT == 16 && "OMX.SEC.MP3.Decoder".equals(name)) {
       return false;
     }
 
@@ -239,6 +247,27 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
     return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
   }
 
+  /**
+   * Tests whether the device advertises it can decode video of a given type at a specified width
+   * and height.
+   * <p>
+   * Must not be called if the device SDK version is less than 21.
+   *
+   * @param mimeType The mime type.
+   * @param secure Whether the decoder is required to support secure decryption. Always pass false
+   *     unless secure decryption really is required.
+   * @param width Width in pixels.
+   * @param height Height in pixels.
+   * @return Whether the decoder advertises support of the given size.
+   */
+  @TargetApi(21)
+  public static boolean isSizeSupportedV21(String mimeType, boolean secure, int width,
+      int height) throws DecoderQueryException {
+    Assertions.checkState(Util.SDK_INT >= 21);
+    MediaCodecInfo.VideoCapabilities videoCapabilities = getVideoCapabilitiesV21(mimeType, secure);
+    return videoCapabilities != null && videoCapabilities.isSizeSupported(width, height);
+  }
+
   /**
    * Tests whether the device advertises it can decode video of a given type at a specified
    * width, height, and frame rate.
@@ -257,11 +286,7 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
   public static boolean isSizeAndRateSupportedV21(String mimeType, boolean secure,
       int width, int height, double frameRate) throws DecoderQueryException {
     Assertions.checkState(Util.SDK_INT >= 21);
-    Pair<String, CodecCapabilities> info = getMediaCodecInfo(mimeType, secure);
-    if (info == null) {
-      return false;
-    }
-    MediaCodecInfo.VideoCapabilities videoCapabilities = info.second.getVideoCapabilities();
+    MediaCodecInfo.VideoCapabilities videoCapabilities = getVideoCapabilitiesV21(mimeType, secure);
     return videoCapabilities != null
         && videoCapabilities.areSizeAndRateSupported(width, height, frameRate);
   }
@@ -309,6 +334,16 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     return maxH264DecodableFrameSize;
   }
 
+  @TargetApi(21)
+  private static MediaCodecInfo.VideoCapabilities getVideoCapabilitiesV21(String mimeType,
+      boolean secure) throws DecoderQueryException {
+    Pair<String, CodecCapabilities> info = getMediaCodecInfo(mimeType, secure);
+    if (info == null) {
+      return null;
+    }
+    return info.second.getVideoCapabilities();
+  }
+
   /**
    * Conversion values taken from: https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index ba10897b56..cc3f114b7d 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -128,29 +128,34 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   /**
    * @param context A context.
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param videoScalingMode The scaling mode to pass to
    *     {@link MediaCodec#setVideoScalingMode(int)}.
    */
-  public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int videoScalingMode) {
-    this(context, source, videoScalingMode, 0);
+  public MediaCodecVideoTrackRenderer(Context context, SampleSource source,
+      MediaCodecSelector mediaCodecSelector, int videoScalingMode) {
+    this(context, source, mediaCodecSelector, videoScalingMode, 0);
   }
 
   /**
    * @param context A context.
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param videoScalingMode The scaling mode to pass to
    *     {@link MediaCodec#setVideoScalingMode(int)}.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    */
-  public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int videoScalingMode,
-      long allowedJoiningTimeMs) {
-    this(context, source, videoScalingMode, allowedJoiningTimeMs, null, null, -1);
+  public MediaCodecVideoTrackRenderer(Context context, SampleSource source,
+      MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs) {
+    this(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, null,
+        -1);
   }
 
   /**
    * @param context A context.
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param videoScalingMode The scaling mode to pass to
    *     {@link MediaCodec#setVideoScalingMode(int)}.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
@@ -161,16 +166,17 @@ public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int vi
    * @param maxDroppedFrameCountToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link EventListener#onDroppedFrames(int, long)}.
    */
-  public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int videoScalingMode,
-      long allowedJoiningTimeMs, Handler eventHandler, EventListener eventListener,
-      int maxDroppedFrameCountToNotify) {
-    this(context, source, videoScalingMode, allowedJoiningTimeMs, null, false, eventHandler,
-        eventListener, maxDroppedFrameCountToNotify);
+  public MediaCodecVideoTrackRenderer(Context context, SampleSource source,
+      MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs,
+      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify) {
+    this(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
+        eventHandler, eventListener, maxDroppedFrameCountToNotify);
   }
 
   /**
    * @param context A context.
    * @param source The upstream source from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
    * @param videoScalingMode The scaling mode to pass to
    *     {@link MediaCodec#setVideoScalingMode(int)}.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
@@ -188,11 +194,12 @@ public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int vi
    * @param maxDroppedFrameCountToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link EventListener#onDroppedFrames(int, long)}.
    */
-  public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int videoScalingMode,
-      long allowedJoiningTimeMs, DrmSessionManager drmSessionManager,
-      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener,
-      int maxDroppedFrameCountToNotify) {
-    super(source, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener);
+  public MediaCodecVideoTrackRenderer(Context context, SampleSource source,
+      MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
+      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify) {
+    super(source, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
+        eventListener);
     this.frameReleaseTimeHelper = new VideoFrameReleaseTimeHelper(context);
     this.videoScalingMode = videoScalingMode;
     this.allowedJoiningTimeUs = allowedJoiningTimeMs * 1000;
@@ -209,19 +216,17 @@ public MediaCodecVideoTrackRenderer(Context context, SampleSource source, int vi
   }
 
   @Override
-  protected boolean handlesTrack(MediaFormat mediaFormat) throws DecoderQueryException {
-    // TODO: Use MediaCodecList.findDecoderForFormat on API 23.
+  protected boolean handlesTrack(MediaCodecSelector mediaCodecSelector, MediaFormat mediaFormat)
+      throws DecoderQueryException {
     String mimeType = mediaFormat.mimeType;
     return MimeTypes.isVideo(mimeType) && (MimeTypes.VIDEO_UNKNOWN.equals(mimeType)
-        || MediaCodecUtil.getDecoderInfo(mimeType, false) != null);
+        || mediaCodecSelector.getDecoderInfo(mediaFormat, false) != null);
   }
 
   @Override
   protected void onEnabled(int track, long positionUs, boolean joining)
       throws ExoPlaybackException {
     super.onEnabled(track, positionUs, joining);
-    renderedFirstFrame = false;
-    consecutiveDroppedFrameCount = 0;
     if (joining && allowedJoiningTimeUs > 0) {
       joiningDeadlineUs = SystemClock.elapsedRealtime() * 1000L + allowedJoiningTimeUs;
     }
@@ -229,8 +234,8 @@ protected void onEnabled(int track, long positionUs, boolean joining)
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
+  protected void onDiscontinuity(long positionUs) throws ExoPlaybackException {
+    super.onDiscontinuity(positionUs);
     renderedFirstFrame = false;
     consecutiveDroppedFrameCount = 0;
     joiningDeadlineUs = -1;
@@ -316,7 +321,7 @@ protected boolean shouldInitCodec() {
 
   // Override configureCodec to provide the surface.
   @Override
-  protected void configureCodec(MediaCodec codec, String codecName, boolean codecIsAdaptive,
+  protected void configureCodec(MediaCodec codec, boolean codecIsAdaptive,
       android.media.MediaFormat format, MediaCrypto crypto) {
     maybeSetMaxInputSize(format, codecIsAdaptive);
     codec.configure(format, surface, crypto, 0);
@@ -491,19 +496,10 @@ protected void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long rel
 
   @SuppressLint("InlinedApi")
   private void maybeSetMaxInputSize(android.media.MediaFormat format, boolean codecIsAdaptive) {
-    if (!MimeTypes.VIDEO_H264.equals(format.getString(android.media.MediaFormat.KEY_MIME))) {
-      // Only set a max input size for H264 for now.
-      return;
-    }
     if (format.containsKey(android.media.MediaFormat.KEY_MAX_INPUT_SIZE)) {
       // Already set. The source of the format may know better, so do nothing.
       return;
     }
-    if ("BRAVIA 4K 2015".equals(Util.MODEL)) {
-      // The Sony BRAVIA 4k TV has input buffers that are too small for the calculated 4k video
-      // maximum input size, so use the default value.
-      return;
-    }
     int maxHeight = format.getInteger(android.media.MediaFormat.KEY_HEIGHT);
     if (codecIsAdaptive && format.containsKey(android.media.MediaFormat.KEY_MAX_HEIGHT)) {
       maxHeight = Math.max(maxHeight, format.getInteger(android.media.MediaFormat.KEY_MAX_HEIGHT));
@@ -512,8 +508,34 @@ private void maybeSetMaxInputSize(android.media.MediaFormat format, boolean code
     if (codecIsAdaptive && format.containsKey(android.media.MediaFormat.KEY_MAX_WIDTH)) {
       maxWidth = Math.max(maxHeight, format.getInteger(android.media.MediaFormat.KEY_MAX_WIDTH));
     }
-    // H264 requires compression ratio of at least 2, and uses macroblocks.
-    int maxInputSize = ((maxWidth + 15) / 16) * ((maxHeight + 15) / 16) * 192;
+    int maxPixels;
+    int minCompressionRatio;
+    switch (format.getString(android.media.MediaFormat.KEY_MIME)) {
+      case MimeTypes.VIDEO_H264:
+        if ("BRAVIA 4K 2015".equals(Util.MODEL)) {
+          // The Sony BRAVIA 4k TV has input buffers that are too small for the calculated 4k video
+          // maximum input size, so use the default value.
+          return;
+        }
+        // Round up width/height to an integer number of macroblocks.
+        maxPixels = ((maxWidth + 15) / 16) * ((maxHeight + 15) / 16) * 16 * 16;
+        minCompressionRatio = 2;
+        break;
+      case MimeTypes.VIDEO_VP8:
+        // VPX does not specify a ratio so use the values from the platform's SoftVPX.cpp.
+        maxPixels = maxWidth * maxHeight;
+        minCompressionRatio = 2;
+        break;
+      case MimeTypes.VIDEO_VP9:
+        maxPixels = maxWidth * maxHeight;
+        minCompressionRatio = 4;
+        break;
+      default:
+        // Leave the default max input size.
+        return;
+    }
+    // Estimate the maximum input size assuming three channel 4:2:0 subsampled input frames.
+    int maxInputSize = (maxPixels * 3) / (2 * minCompressionRatio);
     format.setInteger(android.media.MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 23d7985236..9978221a74 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer;
 
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
@@ -180,6 +181,11 @@ public static MediaFormat createFormatForMimeType(String trackId, String mimeTyp
         NO_VALUE);
   }
 
+  public static MediaFormat createId3Format() {
+    return createFormatForMimeType(null, MimeTypes.APPLICATION_ID3, MediaFormat.NO_VALUE,
+        C.UNKNOWN_TIME_US);
+  }
+
   /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
@@ -228,6 +234,13 @@ public MediaFormat copyWithDurationUs(long durationUs) {
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight);
   }
 
+  public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
+      String language) {
+    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
+        rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
+        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE);
+  }
+
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleSource.java b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
index 0243387c78..c122532d56 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
@@ -46,9 +46,9 @@
    */
   public static final int FORMAT_READ = -4;
   /**
-   * A discontinuity in the sample stream.
+   * Returned from {@link SampleSourceReader#readDiscontinuity(int)} to indicate no discontinuity.
    */
-  public static final int DISCONTINUITY_READ = -5;
+  public static final long NO_DISCONTINUITY = Long.MIN_VALUE;
 
   /**
    * A consumer of samples should call this method to register themselves and gain access to the
@@ -104,7 +104,7 @@
      * (i.e. @link {@link MediaFormat#adaptive} is true). Hence the track formats returned through
      * this method should not be used to configure decoders. Decoder configuration should be
      * performed using the formats obtained when reading the media stream through calls to
-     * {@link #readData(int, long, MediaFormatHolder, SampleHolder, boolean)}.
+     * {@link #readData(int, long, MediaFormatHolder, SampleHolder)}.
      * <p>
      * This method should only be called after the source has been prepared.
      *
@@ -115,7 +115,7 @@
 
     /**
      * Enable the specified track. This allows the track's format and samples to be read from
-     * {@link #readData(int, long, MediaFormatHolder, SampleHolder, boolean)}.
+     * {@link #readData(int, long, MediaFormatHolder, SampleHolder)}.
      * <p>
      * This method should only be called after the source has been prepared, and when the specified
      * track is disabled.
@@ -138,13 +138,27 @@
     public boolean continueBuffering(int track, long positionUs);
 
     /**
-     * Attempts to read either a sample, a new format or or a discontinuity from the source.
+     * Attempts to read a pending discontinuity from the source.
+     * <p>
+     * This method should only be called when the specified track is enabled.
+     *
+     * @param track The track from which to read.
+     * @return If a discontinuity was read then the playback position after the discontinuity. Else
+     *     {@link #NO_DISCONTINUITY}.
+     */
+    public long readDiscontinuity(int track);
+
+    /**
+     * Attempts to read a sample or a new format from the source.
      * <p>
      * This method should only be called when the specified track is enabled.
      * <p>
      * Note that where multiple tracks are enabled, {@link #NOTHING_READ} may be returned if the
      * next piece of data to be read from the {@link SampleSource} corresponds to a different track
      * than the one for which data was requested.
+     * <p>
+     * This method will always return {@link #NOTHING_READ} in the case that there's a pending
+     * discontinuity to be read from {@link #readDiscontinuity(int)} for the specified track.
      *
      * @param track The track from which to read.
      * @param positionUs The current playback position.
@@ -153,13 +167,11 @@
      * @param sampleHolder A {@link SampleHolder} object to populate in the case of a new sample.
      *     If the caller requires the sample data then it must ensure that {@link SampleHolder#data}
      *     references a valid output buffer.
-     * @param onlyReadDiscontinuity Whether to only read a discontinuity. If true, only
-     *     {@link #DISCONTINUITY_READ} or {@link #NOTHING_READ} can be returned.
      * @return The result, which can be {@link #SAMPLE_READ}, {@link #FORMAT_READ},
-     *     {@link #DISCONTINUITY_READ}, {@link #NOTHING_READ} or {@link #END_OF_STREAM}.
+     *     {@link #NOTHING_READ} or {@link #END_OF_STREAM}.
      */
     public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-        SampleHolder sampleHolder, boolean onlyReadDiscontinuity);
+        SampleHolder sampleHolder);
 
     /**
      * Seeks to the specified time in microseconds.
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java
index 8673d774cd..08edae3bc3 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java
@@ -48,7 +48,7 @@ public SampleSourceTrackRenderer(SampleSource... sources) {
   }
 
   @Override
-  protected boolean doPrepare(long positionUs) throws ExoPlaybackException {
+  protected final boolean doPrepare(long positionUs) throws ExoPlaybackException {
     boolean allSourcesPrepared = true;
     for (int i = 0; i < sources.length; i++) {
       allSourcesPrepared &= sources[i].prepare(positionUs);
@@ -103,26 +103,30 @@ protected boolean doPrepare(long positionUs) throws ExoPlaybackException {
     return true;
   }
 
-  /**
-   * Returns whether this renderer is capable of handling the provided track.
-   *
-   * @param mediaFormat The format of the track.
-   * @return True if the renderer can handle the track, false otherwise.
-   * @throws DecoderQueryException Thrown if there was an error querying decoders.
-   */
-  protected abstract boolean handlesTrack(MediaFormat mediaFormat) throws DecoderQueryException;
-
   @Override
   protected void onEnabled(int track, long positionUs, boolean joining)
       throws ExoPlaybackException {
+    positionUs = shiftInputPosition(positionUs);
     enabledSource = sources[handledSourceIndices[track]];
     enabledSourceTrackIndex = handledSourceTrackIndices[track];
     enabledSource.enable(enabledSourceTrackIndex, positionUs);
+    onDiscontinuity(positionUs);
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
+  protected final void seekTo(long positionUs) throws ExoPlaybackException {
+    positionUs = shiftInputPosition(positionUs);
     enabledSource.seekToUs(positionUs);
+    checkForDiscontinuity(positionUs);
+  }
+
+  @Override
+  protected final void doSomeWork(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException {
+    positionUs = shiftInputPosition(positionUs);
+    boolean sourceIsReady = enabledSource.continueBuffering(enabledSourceTrackIndex, positionUs);
+    positionUs = checkForDiscontinuity(positionUs);
+    doSomeWork(positionUs, elapsedRealtimeUs, sourceIsReady);
   }
 
   @Override
@@ -147,14 +151,6 @@ protected void maybeThrowError() throws ExoPlaybackException {
     }
   }
 
-  private void maybeThrowError(SampleSourceReader source) throws ExoPlaybackException {
-    try {
-      source.maybeThrowError();
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
-    }
-  }
-
   @Override
   protected void onDisabled() throws ExoPlaybackException {
     enabledSource.disable(enabledSourceTrackIndex);
@@ -169,16 +165,6 @@ protected void onReleased() throws ExoPlaybackException {
     }
   }
 
-  protected final boolean continueBufferingSource(long positionUs) {
-    return enabledSource.continueBuffering(enabledSourceTrackIndex, positionUs);
-  }
-
-  protected final int readSource(long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
-    return enabledSource.readData(enabledSourceTrackIndex, positionUs, formatHolder, sampleHolder,
-        onlyReadDiscontinuity);
-  }
-
   @Override
   protected final int getTrackCount() {
     return handledSourceTrackIndices.length;
@@ -190,4 +176,92 @@ protected final MediaFormat getFormat(int track) {
     return source.getFormat(handledSourceTrackIndices[track]);
   }
 
+  /**
+   * Shifts positions passed to {@link #onEnabled(int, long, boolean)}, {@link #seekTo(long)} and
+   * {@link #doSomeWork(long, long)}.
+   * <p>
+   * The default implementation does not modify the position. Except in very specific cases,
+   * subclasses should not override this method.
+   *
+   * @param positionUs The position in microseconds.
+   * @return The adjusted position in microseconds.
+   */
+  protected long shiftInputPosition(long positionUs) {
+    return positionUs;
+  }
+
+  // Methods to be called by subclasses.
+
+  /**
+   * Reads from the enabled upstream source.
+   *
+   * @param positionUs The current playback position.
+   * @param formatHolder A {@link MediaFormatHolder} object to populate in the case of a new format.
+   * @param sampleHolder A {@link SampleHolder} object to populate in the case of a new sample.
+   *     If the caller requires the sample data then it must ensure that {@link SampleHolder#data}
+   *     references a valid output buffer.
+   * @return The result, which can be {@link SampleSource#SAMPLE_READ},
+   *     {@link SampleSource#FORMAT_READ}, {@link SampleSource#NOTHING_READ} or
+   *     {@link SampleSource#END_OF_STREAM}.
+   */
+  protected final int readSource(long positionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder) {
+    return enabledSource.readData(enabledSourceTrackIndex, positionUs, formatHolder, sampleHolder);
+  }
+
+  // Abstract methods.
+
+  /**
+   * Returns whether this renderer is capable of handling the provided track.
+   *
+   * @param mediaFormat The format of the track.
+   * @return True if the renderer can handle the track, false otherwise.
+   * @throws DecoderQueryException Thrown if there was an error querying decoders.
+   */
+  protected abstract boolean handlesTrack(MediaFormat mediaFormat) throws DecoderQueryException;
+
+  /**
+   * Invoked when a discontinuity is encountered. Also invoked when the renderer is enabled, for
+   * convenience.
+   *
+   * @param positionUs The playback position after the discontinuity, or the position at which
+   *     the renderer is being enabled.
+   * @throws ExoPlaybackException If an error occurs handling the discontinuity.
+   */
+  protected abstract void onDiscontinuity(long positionUs) throws ExoPlaybackException;
+
+  /**
+   * Called by {@link #doSomeWork(long, long)}.
+   *
+   * @param positionUs The current media time in microseconds, measured at the start of the
+   *     current iteration of the rendering loop.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   * @param sourceIsReady The result of the most recent call to
+   *     {@link SampleSourceReader#continueBuffering(int, long)}.
+   * @throws ExoPlaybackException If an error occurs.
+   * @throws ExoPlaybackException
+   */
+  protected abstract void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException;
+
+  // Private methods.
+
+  private long checkForDiscontinuity(long positionUs) throws ExoPlaybackException {
+    long discontinuityPositionUs = enabledSource.readDiscontinuity(enabledSourceTrackIndex);
+    if (discontinuityPositionUs != SampleSource.NO_DISCONTINUITY) {
+      onDiscontinuity(discontinuityPositionUs);
+      return discontinuityPositionUs;
+    }
+    return positionUs;
+  }
+
+  private void maybeThrowError(SampleSourceReader source) throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
index 55fde5057b..ec7a8dcbb7 100644
--- a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
@@ -119,12 +119,15 @@ public void maybeThrowError() throws IOException {
     }
   }
 
+  @Override
+  public long readDiscontinuity(int track) {
+    return NO_DISCONTINUITY;
+  }
+
   @Override
   public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
-    if (onlyReadDiscontinuity) {
-      return NOTHING_READ;
-    } else if (state == STATE_END_OF_STREAM) {
+      SampleHolder sampleHolder) {
+    if (state == STATE_END_OF_STREAM) {
       return END_OF_STREAM;
     } else if (state == STATE_SEND_FORMAT) {
       formatHolder.format = format;
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
index e32aa16008..e2fd0301b4 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
@@ -150,9 +150,7 @@ protected final int getState() {
    *
    * @param track The track for which the renderer is being enabled.
    * @param positionUs The player's current position.
-   * @param joining Whether this renderer is being enabled to join an ongoing playback. If true
-   *     then {@link #start} must be called immediately after this method returns (unless a
-   *     {@link ExoPlaybackException} is thrown).
+   * @param joining Whether this renderer is being enabled to join an ongoing playback.
    * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final void enable(int track, long positionUs, boolean joining)
@@ -169,9 +167,7 @@ protected final int getState() {
    *
    * @param track The track for which the renderer is being enabled.
    * @param positionUs The player's current position.
-   * @param joining Whether this renderer is being enabled to join an ongoing playback. If true
-   *     then {@link #onStarted} is guaranteed to be called immediately after this method returns
-   *     (unless a {@link ExoPlaybackException} is thrown).
+   * @param joining Whether this renderer is being enabled to join an ongoing playback.
    * @throws ExoPlaybackException If an error occurs.
    */
   protected void onEnabled(int track, long positionUs, boolean joining)
diff --git a/library/src/main/java/com/google/android/exoplayer/VideoFrameReleaseTimeHelper.java b/library/src/main/java/com/google/android/exoplayer/VideoFrameReleaseTimeHelper.java
index 7aeff788c9..31f84cf07f 100644
--- a/library/src/main/java/com/google/android/exoplayer/VideoFrameReleaseTimeHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer/VideoFrameReleaseTimeHelper.java
@@ -17,6 +17,9 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
 import android.view.Choreographer;
 import android.view.Choreographer.FrameCallback;
 import android.view.WindowManager;
@@ -25,7 +28,7 @@
  * Makes a best effort to adjust frame release timestamps for a smoother visual result.
  */
 @TargetApi(16)
-public final class VideoFrameReleaseTimeHelper implements FrameCallback {
+public final class VideoFrameReleaseTimeHelper {
 
   private static final long CHOREOGRAPHER_SAMPLE_DELAY_MILLIS = 500;
   private static final long MAX_ALLOWED_DRIFT_NS = 20000000;
@@ -33,13 +36,11 @@
   private static final long VSYNC_OFFSET_PERCENTAGE = 80;
   private static final int MIN_FRAMES_FOR_ADJUSTMENT = 6;
 
+  private final VSyncSampler vsyncSampler;
   private final boolean useDefaultDisplayVsync;
   private final long vsyncDurationNs;
   private final long vsyncOffsetNs;
 
-  private Choreographer choreographer;
-  private long sampledVsyncTimeNs;
-
   private long lastFramePresentationTimeUs;
   private long adjustedLastFrameTimeNs;
   private long pendingAdjustedFrameTimeNs;
@@ -71,9 +72,11 @@ private VideoFrameReleaseTimeHelper(float defaultDisplayRefreshRate,
       boolean useDefaultDisplayVsync) {
     this.useDefaultDisplayVsync = useDefaultDisplayVsync;
     if (useDefaultDisplayVsync) {
+      vsyncSampler = VSyncSampler.getInstance();
       vsyncDurationNs = (long) (1000000000d / defaultDisplayRefreshRate);
       vsyncOffsetNs = (vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) / 100;
     } else {
+      vsyncSampler = null;
       vsyncDurationNs = -1;
       vsyncOffsetNs = -1;
     }
@@ -85,9 +88,7 @@ private VideoFrameReleaseTimeHelper(float defaultDisplayRefreshRate,
   public void enable() {
     haveSync = false;
     if (useDefaultDisplayVsync) {
-      sampledVsyncTimeNs = 0;
-      choreographer = Choreographer.getInstance();
-      choreographer.postFrameCallback(this);
+      vsyncSampler.addObserver();
     }
   }
 
@@ -96,17 +97,10 @@ public void enable() {
    */
   public void disable() {
     if (useDefaultDisplayVsync) {
-      choreographer.removeFrameCallback(this);
-      choreographer = null;
+      vsyncSampler.removeObserver();
     }
   }
 
-  @Override
-  public void doFrame(long vsyncTimeNs) {
-    sampledVsyncTimeNs = vsyncTimeNs;
-    choreographer.postFrameCallbackDelayed(this, CHOREOGRAPHER_SAMPLE_DELAY_MILLIS);
-  }
-
   /**
    * Called to make a fine-grained adjustment to a frame release time.
    *
@@ -167,12 +161,13 @@ public long adjustReleaseTime(long framePresentationTimeUs, long unadjustedRelea
     lastFramePresentationTimeUs = framePresentationTimeUs;
     pendingAdjustedFrameTimeNs = adjustedFrameTimeNs;
 
-    if (sampledVsyncTimeNs == 0) {
+    if (vsyncSampler == null || vsyncSampler.sampledVsyncTimeNs == 0) {
       return adjustedReleaseTimeNs;
     }
 
     // Find the timestamp of the closest vsync. This is the vsync that we're targeting.
-    long snappedTimeNs = closestVsync(adjustedReleaseTimeNs, sampledVsyncTimeNs, vsyncDurationNs);
+    long snappedTimeNs = closestVsync(adjustedReleaseTimeNs,
+        vsyncSampler.sampledVsyncTimeNs, vsyncDurationNs);
     // Apply an offset so that we release before the target vsync, but after the previous one.
     return snappedTimeNs - vsyncOffsetNs;
   }
@@ -209,4 +204,102 @@ private static float getDefaultDisplayRefreshRate(Context context) {
     return manager.getDefaultDisplay().getRefreshRate();
   }
 
+  /**
+   * Manages the lifecycle of a single {@link Choreographer} to be shared among all
+   * {@link VideoFrameReleaseTimeHelper} instances. This is done to avoid a bug fixed in platform
+   * API version 23 that causes resource leakage. See [Internal: b/12455729].
+   */
+  private static final class VSyncSampler implements FrameCallback, Handler.Callback {
+
+    public volatile long sampledVsyncTimeNs;
+
+    private static final int CREATE_CHOREOGRAPHER = 0;
+    private static final int MSG_ADD_OBSERVER = 1;
+    private static final int MSG_REMOVE_OBSERVER = 2;
+
+    private static final VSyncSampler INSTANCE = new VSyncSampler();
+
+    private final Handler handler;
+    private final HandlerThread choreographerOwnerThread;
+    private Choreographer choreographer;
+    private int observerCount;
+
+    public static VSyncSampler getInstance() {
+      return INSTANCE;
+    }
+
+    private VSyncSampler() {
+      choreographerOwnerThread = new HandlerThread("ChoreographerOwner:Handler");
+      choreographerOwnerThread.start();
+      handler = new Handler(choreographerOwnerThread.getLooper(), this);
+      handler.sendEmptyMessage(CREATE_CHOREOGRAPHER);
+    }
+
+    /**
+     * Tells the {@link VSyncSampler} that there is a new {@link VideoFrameReleaseTimeHelper}
+     * instance observing the currentSampledVsyncTimeNs value. As a consequence, if necessary, it
+     * will register itself as a {@code doFrame} callback listener.
+     */
+    public void addObserver() {
+      handler.sendEmptyMessage(MSG_ADD_OBSERVER);
+    }
+
+    /**
+     * Counterpart of {@code addNewObservingHelper}. This method should be called once the observer
+     * no longer needs to read {@link #sampledVsyncTimeNs}
+     */
+    public void removeObserver() {
+      handler.sendEmptyMessage(MSG_REMOVE_OBSERVER);
+    }
+
+    @Override
+    public void doFrame(long vsyncTimeNs) {
+      sampledVsyncTimeNs = vsyncTimeNs;
+      choreographer.postFrameCallbackDelayed(this, CHOREOGRAPHER_SAMPLE_DELAY_MILLIS);
+    }
+
+    @Override
+    public boolean handleMessage(Message message) {
+      switch (message.what) {
+        case CREATE_CHOREOGRAPHER: {
+          createChoreographerInstanceInternal();
+          return true;
+        }
+        case MSG_ADD_OBSERVER: {
+          addObserverInternal();
+          return true;
+        }
+        case MSG_REMOVE_OBSERVER: {
+          removeObserverInternal();
+          return true;
+        }
+        default: {
+          return false;
+        }
+      }
+    }
+
+
+    private void createChoreographerInstanceInternal() {
+      choreographer = Choreographer.getInstance();
+    }
+
+    private void addObserverInternal() {
+      observerCount++;
+      if (observerCount == 1) {
+        choreographer.postFrameCallback(this);
+      }
+    }
+
+    private void removeObserverInternal() {
+      observerCount--;
+      if (observerCount == 0) {
+        choreographer.removeFrameCallback(this);
+        sampledVsyncTimeNs = 0;
+      }
+    }
+
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index c82ea25f22..34b5db935a 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.util.Ac3Util;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.DtsUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
@@ -134,6 +135,10 @@ public InvalidAudioTrackTimestampException(String message) {
    * A maximum length for the {@link android.media.AudioTrack} buffer, in microseconds.
    */
   private static final long MAX_BUFFER_DURATION_US = 750000;
+  /**
+   * The length for passthrough {@link android.media.AudioTrack} buffers, in microseconds.
+   */
+  private static final long PASSTHROUGH_BUFFER_DURATION_US = 250000;
   /**
    * A multiplication factor to apply to the minimum buffer size requested by the underlying
    * {@link android.media.AudioTrack}.
@@ -199,7 +204,6 @@ public InvalidAudioTrackTimestampException(String message) {
   private int encoding;
   private boolean passthrough;
   private int pcmFrameSize;
-  private int minBufferSize;
   private int bufferSize;
   private long bufferSizeUs;
 
@@ -394,15 +398,23 @@ public void configure(MediaFormat format, boolean passthrough, int specifiedBuff
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
     pcmFrameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
-    minBufferSize = android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
-    Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
+
     if (specifiedBufferSize != 0) {
       bufferSize = specifiedBufferSize;
     } else if (passthrough) {
-      // TODO: Set the minimum buffer size correctly for encoded output when getMinBufferSize takes
-      // the encoding into account. [Internal: b/25181305]
-      bufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR * 2;
+      // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
+      // account. [Internal: b/25181305]
+      if (encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3) {
+        // AC-3 allows bitrates up to 640 kbit/s.
+        bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 80 * 1024 / C.MICROS_PER_SECOND);
+      } else { // encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD
+        // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
+        bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
+      }
     } else {
+      int minBufferSize =
+          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
+      Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
       int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * pcmFrameSize;
       int maxAppBufferSize = (int) Math.max(minBufferSize,
@@ -954,10 +966,7 @@ private static int getEncodingForMimeType(String mimeType) {
 
   private static int getFramesPerEncodedSample(int encoding, ByteBuffer buffer) {
     if (encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD) {
-      // Calculate the sample size in frames as per ETSI TS 102 114 F.3.2.1.
-      int nblks = ((buffer.get(buffer.position() + 4) & 0x01) << 6)
-          | ((buffer.get(buffer.position() + 5) & 0xFC) >> 2);
-      return (nblks + 1) * 32;
+      return DtsUtil.parseDtsAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC3) {
       return Ac3Util.getAc3SyncframeAudioSampleCount();
     } else if (encoding == C.ENCODING_E_AC3) {
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index d9c9aa6cec..f7d4e12dfc 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -223,21 +223,21 @@ public boolean continueBuffering(int track, long positionUs) {
   }
 
   @Override
-  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
-    Assertions.checkState(state == STATE_ENABLED);
-    downstreamPositionUs = positionUs;
-
+  public long readDiscontinuity(int track) {
     if (pendingDiscontinuity) {
       pendingDiscontinuity = false;
-      return DISCONTINUITY_READ;
+      return lastSeekPositionUs;
     }
+    return NO_DISCONTINUITY;
+  }
 
-    if (onlyReadDiscontinuity) {
-      return NOTHING_READ;
-    }
+  @Override
+  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder) {
+    Assertions.checkState(state == STATE_ENABLED);
+    downstreamPositionUs = positionUs;
 
-    if (isPendingReset()) {
+    if (pendingDiscontinuity || isPendingReset()) {
       return NOTHING_READ;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
index 02167d3838..7eaaa107a6 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
@@ -43,6 +43,10 @@ public MediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format
         Chunk.NO_PARENT_ID);
   }
 
+  public int getNextChunkIndex() {
+    return chunkIndex + 1;
+  }
+
   /**
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index 37b2aa42a7..84717b9c79 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -154,9 +154,13 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
     if (format.width > 0 && format.height > 0) {
       String videoMediaMimeType = MimeTypes.getVideoMediaMimeType(format.codecs);
       if (Util.SDK_INT >= 21 && !MimeTypes.VIDEO_UNKNOWN.equals(videoMediaMimeType)) {
-        float frameRate = (format.frameRate > 0) ? format.frameRate : 30.0f;
-        return MediaCodecUtil.isSizeAndRateSupportedV21(videoMediaMimeType, false,
-            format.width, format.height, frameRate);
+        if (format.frameRate > 0) {
+          return MediaCodecUtil.isSizeAndRateSupportedV21(videoMediaMimeType, false, format.width,
+              format.height, format.frameRate);
+        } else {
+          return MediaCodecUtil.isSizeSupportedV21(videoMediaMimeType, false, format.width,
+              format.height);
+        }
       }
       //Assuming that the media is H.264
       if (format.width * format.height > maxDecodableFrameSize) {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 8c7350e1d5..eec4ea5e98 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -85,9 +85,10 @@
     /**
      * Invoked when the available seek range of the stream has changed.
      *
+     * @param sourceId The id of the reporting {@link DashChunkSource}.
      * @param availableRange The range which specifies available content that can be seeked to.
      */
-    public void onAvailableRangeChanged(TimeRange availableRange);
+    public void onAvailableRangeChanged(int sourceId, TimeRange availableRange);
 
   }
 
@@ -119,6 +120,7 @@ public NoAdaptationSetException(String message) {
   private final long elapsedRealtimeOffsetUs;
   private final long[] availableRangeValues;
   private final boolean live;
+  private final int eventSourceId;
 
   private MediaPresentationDescription currentManifest;
   private MediaPresentationDescription processedManifest;
@@ -179,7 +181,7 @@ public DashChunkSource(DashTrackSelector trackSelector, DataSource dataSource,
   public DashChunkSource(MediaPresentationDescription manifest, DashTrackSelector trackSelector,
       DataSource dataSource, FormatEvaluator adaptiveFormatEvaluator) {
     this(null, manifest, trackSelector, dataSource, adaptiveFormatEvaluator, new SystemClock(), 0,
-        0, false, null, null);
+        0, false, null, null, 0);
   }
 
   /**
@@ -204,14 +206,15 @@ public DashChunkSource(MediaPresentationDescription manifest, DashTrackSelector
    * @param eventHandler A handler to use when delivering events to {@code EventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
    */
   public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       DashTrackSelector trackSelector, DataSource dataSource,
       FormatEvaluator adaptiveFormatEvaluator, long liveEdgeLatencyMs, long elapsedRealtimeOffsetMs,
-      Handler eventHandler, EventListener eventListener) {
+      Handler eventHandler, EventListener eventListener, int eventSourceId) {
     this(manifestFetcher, manifestFetcher.getManifest(), trackSelector,
         dataSource, adaptiveFormatEvaluator, new SystemClock(), liveEdgeLatencyMs * 1000,
-        elapsedRealtimeOffsetMs * 1000, true, eventHandler, eventListener);
+        elapsedRealtimeOffsetMs * 1000, true, eventHandler, eventListener, eventSourceId);
   }
 
   /**
@@ -235,21 +238,25 @@ public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFet
    * @param eventHandler A handler to use when delivering events to {@code EventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
    */
   public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       DashTrackSelector trackSelector, DataSource dataSource,
       FormatEvaluator adaptiveFormatEvaluator, long liveEdgeLatencyMs, long elapsedRealtimeOffsetMs,
-      boolean startAtLiveEdge, Handler eventHandler, EventListener eventListener) {
+      boolean startAtLiveEdge, Handler eventHandler, EventListener eventListener,
+      int eventSourceId) {
     this(manifestFetcher, manifestFetcher.getManifest(), trackSelector,
         dataSource, adaptiveFormatEvaluator, new SystemClock(), liveEdgeLatencyMs * 1000,
-        elapsedRealtimeOffsetMs * 1000, startAtLiveEdge, eventHandler, eventListener);
+        elapsedRealtimeOffsetMs * 1000, startAtLiveEdge, eventHandler, eventListener,
+        eventSourceId);
   }
 
   /* package */ DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       MediaPresentationDescription initialManifest, DashTrackSelector trackSelector,
       DataSource dataSource, FormatEvaluator adaptiveFormatEvaluator,
       Clock systemClock, long liveEdgeLatencyUs, long elapsedRealtimeOffsetUs,
-      boolean startAtLiveEdge, Handler eventHandler, EventListener eventListener) {
+      boolean startAtLiveEdge, Handler eventHandler, EventListener eventListener,
+      int eventSourceId) {
     this.manifestFetcher = manifestFetcher;
     this.currentManifest = initialManifest;
     this.trackSelector = trackSelector;
@@ -261,6 +268,7 @@ public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFet
     this.startAtLiveEdge = startAtLiveEdge;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
+    this.eventSourceId = eventSourceId;
     this.evaluation = new Evaluation();
     this.availableRangeValues = new long[2];
     periodHolders = new SparseArray<>();
@@ -424,7 +432,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
         if (previous.parentId == lastPeriodHolder.localIndex) {
           RepresentationHolder representationHolder =
               lastPeriodHolder.representationHolders.get(previous.format.id);
-          if (representationHolder.isLastSegment(previous.chunkIndex)) {
+          if (representationHolder.isBeyondLastSegment(previous.getNextChunkIndex())) {
             out.endOfStream = true;
             return;
           }
@@ -443,7 +451,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
       } else if (!periodHolder.isIndexUnbounded()) {
         RepresentationHolder representationHolder =
             periodHolder.representationHolders.get(previous.format.id);
-        if (representationHolder.isLastSegment(previous.chunkIndex)) {
+        if (representationHolder.isBeyondLastSegment(previous.getNextChunkIndex())) {
           // We reached the end of a period. Start the next one.
           periodHolder = periodHolders.get(previous.parentId + 1);
           startingNewPeriod = true;
@@ -478,9 +486,9 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
 
     int segmentNum = queue.isEmpty() ? representationHolder.getSegmentNum(playbackPositionUs)
           : startingNewPeriod ? representationHolder.getFirstAvailableSegmentNum()
-          : queue.get(out.queueSize - 1).chunkIndex + 1;
+          : queue.get(out.queueSize - 1).getNextChunkIndex();
     Chunk nextMediaChunk = newMediaChunk(periodHolder, representationHolder, dataSource,
-        mediaFormat, segmentNum, evaluation.trigger);
+        mediaFormat, enabledTrack, segmentNum, evaluation.trigger);
     lastChunkWasInitialization = false;
     out.chunk = nextMediaChunk;
   }
@@ -672,8 +680,9 @@ private Chunk newInitializationChunk(RangedUri initializationUri, RangedUri inde
         extractor, manifestIndex);
   }
 
-  private Chunk newMediaChunk(PeriodHolder periodHolder, RepresentationHolder representationHolder,
-      DataSource dataSource, MediaFormat mediaFormat, int segmentNum, int trigger) {
+  protected Chunk newMediaChunk(
+      PeriodHolder periodHolder, RepresentationHolder representationHolder, DataSource dataSource,
+      MediaFormat mediaFormat, ExposedTrack enabledTrack, int segmentNum, int trigger) {
     Representation representation = representationHolder.representation;
     Format format = representation.format;
     long startTimeUs = representationHolder.getSegmentStartTimeUs(segmentNum);
@@ -796,17 +805,19 @@ private void notifyAvailableRangeChanged(final TimeRange seekRange) {
       eventHandler.post(new Runnable() {
         @Override
         public void run() {
-          eventListener.onAvailableRangeChanged(seekRange);
+          eventListener.onAvailableRangeChanged(eventSourceId, seekRange);
         }
       });
     }
   }
 
-  // Private classes.
+  // Protected classes.
 
-  private static final class ExposedTrack {
+  protected static final class ExposedTrack {
 
     public final MediaFormat trackFormat;
+    public final int adaptiveMaxWidth;
+    public final int adaptiveMaxHeight;
 
     private final int adaptationSetIndex;
 
@@ -815,8 +826,6 @@ public void run() {
 
     // Adaptive track variables.
     private final Format[] adaptiveFormats;
-    private final int adaptiveMaxWidth;
-    private final int adaptiveMaxHeight;
 
     public ExposedTrack(MediaFormat trackFormat, int adaptationSetIndex, Format fixedFormat) {
       this.trackFormat = trackFormat;
@@ -843,8 +852,9 @@ public boolean isAdaptive() {
 
   }
 
-  private static final class RepresentationHolder {
+  protected static final class RepresentationHolder {
 
+    public final boolean mimeTypeIsRawText;
     public final ChunkExtractorWrapper extractorWrapper;
 
     public Representation representation;
@@ -862,7 +872,8 @@ public RepresentationHolder(long periodStartTimeUs, long periodDurationUs,
       this.periodDurationUs = periodDurationUs;
       this.representation = representation;
       String mimeType = representation.format.mimeType;
-      extractorWrapper = mimeTypeIsRawText(mimeType) ? null : new ChunkExtractorWrapper(
+      mimeTypeIsRawText = mimeTypeIsRawText(mimeType);
+      extractorWrapper = mimeTypeIsRawText ? null : new ChunkExtractorWrapper(
           mimeTypeIsWebm(mimeType) ? new WebmExtractor() : new FragmentedMp4Extractor());
       segmentIndex = representation.getIndex();
     }
@@ -919,10 +930,14 @@ public long getSegmentEndTimeUs(int segmentNum) {
           + segmentIndex.getDurationUs(segmentNum - segmentNumShift, periodDurationUs);
     }
 
-    public boolean isLastSegment(int segmentNum) {
-      int lastSegmentNum = segmentIndex.getLastSegmentNum(periodDurationUs);
+    public int getLastSegmentNum() {
+      return segmentIndex.getLastSegmentNum(periodDurationUs);
+    }
+
+    public boolean isBeyondLastSegment(int segmentNum) {
+      int lastSegmentNum = getLastSegmentNum();
       return lastSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED ? false
-          : segmentNum == (lastSegmentNum + segmentNumShift);
+          : segmentNum > (lastSegmentNum + segmentNumShift);
     }
 
     public int getFirstAvailableSegmentNum() {
@@ -935,7 +950,7 @@ public RangedUri getSegmentUrl(int segmentNum) {
 
   }
 
-  private static final class PeriodHolder {
+  protected static final class PeriodHolder {
 
     public final int localIndex;
     public final long startTimeUs;
@@ -1019,6 +1034,10 @@ public boolean isIndexExplicit() {
       return indexIsExplicit;
     }
 
+    public DrmInitData getDrmInitData() {
+      return drmInitData;
+    }
+
     // Private methods.
 
     private void updateRepresentationIndependentProperties(long periodDurationUs,
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index a205599e45..f14fa0816a 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -111,8 +111,7 @@ protected MediaPresentationDescription parseMediaPresentationDescription(XmlPull
     String typeString = xpp.getAttributeValue(null, "type");
     boolean dynamic = (typeString != null) ? typeString.equals("dynamic") : false;
     long minUpdateTimeMs = (dynamic) ? parseDuration(xpp, "minimumUpdatePeriod", -1) : -1;
-    long timeShiftBufferDepthMs = (dynamic) ? parseDuration(xpp, "timeShiftBufferDepth", -1)
-        : -1;
+    long timeShiftBufferDepthMs = (dynamic) ? parseDuration(xpp, "timeShiftBufferDepth", -1) : -1;
     UtcTimingElement utcTiming = null;
     String location = null;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
index a7a4ae2d9b..ca60e546b8 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
@@ -51,47 +51,23 @@ public DefaultExtractorInput(DataSource dataSource, long position, long length)
 
   @Override
   public int read(byte[] target, int offset, int length) throws IOException, InterruptedException {
-    if (Thread.interrupted()) {
-      throw new InterruptedException();
-    }
-    int peekBytes = Math.min(peekBufferLength, length);
-    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
-    offset += peekBytes;
-    length -= peekBytes;
-    int bytesRead = length != 0 ? dataSource.read(target, offset, length) : 0;
-    if (bytesRead == C.RESULT_END_OF_INPUT) {
-      return C.RESULT_END_OF_INPUT;
+    int bytesRead = readFromPeekBuffer(target, offset, length);
+    if (bytesRead == 0) {
+      bytesRead = readFromDataSource(target, offset, length, 0, true);
     }
-    updatePeekBuffer(peekBytes);
-    bytesRead += peekBytes;
-    position += bytesRead;
+    commitBytesRead(bytesRead);
     return bytesRead;
   }
 
   @Override
   public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
-    int peekBytes = Math.min(peekBufferLength, length);
-    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
-    offset += peekBytes;
-    int remaining = length - peekBytes;
-    while (remaining > 0) {
-      if (Thread.interrupted()) {
-        throw new InterruptedException();
-      }
-      int bytesRead = dataSource.read(target, offset, remaining);
-      if (bytesRead == C.RESULT_END_OF_INPUT) {
-        if (allowEndOfInput && remaining == length) {
-          return false;
-        }
-        throw new EOFException();
-      }
-      offset += bytesRead;
-      remaining -= bytesRead;
+    int bytesRead = readFromPeekBuffer(target, offset, length);
+    while (bytesRead < length && bytesRead != C.RESULT_END_OF_INPUT) {
+      bytesRead = readFromDataSource(target, offset, length, bytesRead, allowEndOfInput);
     }
-    updatePeekBuffer(peekBytes);
-    position += length;
-    return true;
+    commitBytesRead(bytesRead);
+    return bytesRead != C.RESULT_END_OF_INPUT;
   }
 
   @Override
@@ -100,71 +76,69 @@ public void readFully(byte[] target, int offset, int length)
     readFully(target, offset, length, false);
   }
 
+  @Override
+  public int skip(int length) throws IOException, InterruptedException {
+    int bytesSkipped = skipFromPeekBuffer(length);
+    if (bytesSkipped == 0) {
+      bytesSkipped = readFromDataSource(SCRATCH_SPACE, 0, length, 0, true);
+    }
+    commitBytesRead(bytesSkipped);
+    return bytesSkipped;
+  }
+
+  @Override
+  public boolean skipFully(int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    int bytesSkipped = skipFromPeekBuffer(length);
+    while (bytesSkipped < length && bytesSkipped != C.RESULT_END_OF_INPUT) {
+      bytesSkipped = readFromDataSource(SCRATCH_SPACE, -bytesSkipped,
+          Math.min(length, bytesSkipped + SCRATCH_SPACE.length), bytesSkipped, allowEndOfInput);
+    }
+    commitBytesRead(bytesSkipped);
+    return bytesSkipped != C.RESULT_END_OF_INPUT;
+  }
+
   @Override
   public void skipFully(int length) throws IOException, InterruptedException {
-    int peekBytes = Math.min(peekBufferLength, length);
-    int remaining = length - peekBytes;
-    while (remaining > 0) {
-      if (Thread.interrupted()) {
-        throw new InterruptedException();
-      }
-      int bytesRead = dataSource.read(SCRATCH_SPACE, 0, Math.min(SCRATCH_SPACE.length, remaining));
-      if (bytesRead == C.RESULT_END_OF_INPUT) {
-        throw new EOFException();
-      }
-      remaining -= bytesRead;
+    skipFully(length, false);
+  }
+
+  @Override
+  public boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    if (!advancePeekPosition(length, allowEndOfInput)) {
+      return false;
     }
-    updatePeekBuffer(peekBytes);
-    position += length;
+    System.arraycopy(peekBuffer, peekBufferPosition - length, target, offset, length);
+    return true;
   }
 
   @Override
   public void peekFully(byte[] target, int offset, int length)
       throws IOException, InterruptedException {
+    peekFully(target, offset, length, false);
+  }
+
+  @Override
+  public boolean advancePeekPosition(int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
     ensureSpaceForPeek(length);
-    int peekBytes = Math.min(peekBufferLength - peekBufferPosition, length);
-    System.arraycopy(peekBuffer, peekBufferPosition, target, offset, peekBytes);
-    offset += peekBytes;
-    int fillBytes = length - peekBytes;
-    int remaining = fillBytes;
-    int writePosition = peekBufferLength;
-    while (remaining > 0) {
-      if (Thread.interrupted()) {
-        throw new InterruptedException();
+    int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
+    peekBufferLength += length - bytesPeeked;
+    while (bytesPeeked < length) {
+      bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
+          allowEndOfInput);
+      if (bytesPeeked == C.RESULT_END_OF_INPUT) {
+        return false;
       }
-      int bytesRead = dataSource.read(peekBuffer, writePosition, remaining);
-      if (bytesRead == C.RESULT_END_OF_INPUT) {
-        throw new EOFException();
-      }
-      System.arraycopy(peekBuffer, writePosition, target, offset, bytesRead);
-      remaining -= bytesRead;
-      writePosition += bytesRead;
-      offset += bytesRead;
     }
     peekBufferPosition += length;
-    peekBufferLength += fillBytes;
+    return true;
   }
 
   @Override
   public void advancePeekPosition(int length) throws IOException, InterruptedException {
-    ensureSpaceForPeek(length);
-    int peekBytes = Math.min(peekBufferLength - peekBufferPosition, length);
-    int fillBytes = length - peekBytes;
-    int remaining = fillBytes;
-    int writePosition = peekBufferLength;
-    while (remaining > 0) {
-      if (Thread.interrupted()) {
-        throw new InterruptedException();
-      }
-      int bytesRead = dataSource.read(peekBuffer, writePosition, remaining);
-      if (bytesRead == C.RESULT_END_OF_INPUT) {
-        throw new EOFException();
-      }
-      remaining -= bytesRead;
-      writePosition += bytesRead;
-    }
-    peekBufferPosition += length;
-    peekBufferLength += fillBytes;
+    advancePeekPosition(length, false);
   }
 
   @Override
@@ -193,6 +167,36 @@ private void ensureSpaceForPeek(int length) {
     }
   }
 
+  /**
+   * Skips from the peek buffer.
+   *
+   * @param length The maximum number of bytes to skip from the peek buffer.
+   * @return The number of bytes skipped.
+   */
+  private int skipFromPeekBuffer(int length) {
+    int bytesSkipped = Math.min(peekBufferLength, length);
+    updatePeekBuffer(bytesSkipped);
+    return bytesSkipped;
+  }
+
+  /**
+   * Reads from the peek buffer
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The maximum number of bytes to read from the peek buffer.
+   * @return The number of bytes read.
+   */
+  private int readFromPeekBuffer(byte[] target, int offset, int length) {
+    if (peekBufferLength == 0) {
+      return 0;
+    }
+    int peekBytes = Math.min(peekBufferLength, length);
+    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
+    updatePeekBuffer(peekBytes);
+    return peekBytes;
+  }
+
   /**
    * Updates the peek buffer's length, position and contents after consuming data.
    *
@@ -204,4 +208,48 @@ private void updatePeekBuffer(int bytesConsumed) {
     System.arraycopy(peekBuffer, bytesConsumed, peekBuffer, 0, peekBufferLength);
   }
 
+  /**
+   * Starts or continues a read from the data source.
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The maximum number of bytes to read from the input.
+   * @param bytesAlreadyRead The number of bytes already read from the input.
+   * @param allowEndOfInput True if encountering the end of the input having read no data is
+   *     allowed, and should result in {@link C#RESULT_END_OF_INPUT} being returned. False if it
+   *     should be considered an error, causing an {@link EOFException} to be thrown.
+   * @return The total number of bytes read so far, or {@link C#RESULT_END_OF_INPUT} if
+   *     {@code allowEndOfInput} is true and the input has ended having read no bytes.
+   * @throws EOFException If the end of input was encountered having partially satisfied the read
+   *     (i.e. having read at least one byte, but fewer than {@code length}), or if no bytes were
+   *     read and {@code allowEndOfInput} is false.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private int readFromDataSource(byte[] target, int offset, int length, int bytesAlreadyRead,
+      boolean allowEndOfInput) throws InterruptedException, IOException {
+    if (Thread.interrupted()) {
+      throw new InterruptedException();
+    }
+    int bytesRead = dataSource.read(target, offset + bytesAlreadyRead, length - bytesAlreadyRead);
+    if (bytesRead == C.RESULT_END_OF_INPUT) {
+      if (bytesAlreadyRead == 0 && allowEndOfInput) {
+        return C.RESULT_END_OF_INPUT;
+      }
+      throw new EOFException();
+    }
+    return bytesAlreadyRead + bytesRead;
+  }
+
+  /**
+   * Advances the position by the specified number of bytes read.
+   *
+   * @param bytesRead The number of bytes read.
+   */
+  private void commitBytesRead(int bytesRead) {
+    if (bytesRead != C.RESULT_END_OF_INPUT) {
+      position += bytesRead;
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DummyTrackOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DummyTrackOutput.java
new file mode 100644
index 0000000000..330630c89e
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DummyTrackOutput.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * A dummy {@link TrackOutput} implementation.
+ */
+public class DummyTrackOutput implements TrackOutput {
+  @Override
+  public void format(MediaFormat format) {
+    // Do nothing.
+  }
+
+  @Override
+  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    return input.skip(length);
+  }
+
+  @Override
+  public void sampleData(ParsableByteArray data, int length) {
+    data.skipBytes(length);
+  }
+
+  @Override
+  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+    // Do nothing.
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
index e44e67b3f4..46b70232f6 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
@@ -52,7 +52,12 @@
   /**
    * Returns whether this extractor can extract samples from the {@link ExtractorInput}, which must
    * provide data from the start of the stream.
+   * <p>
+   * If {@code true} is returned, the {@code input}'s reading position may have been modified.
+   * Otherwise, only its peek position may have been modified.
    *
+   * @param input The {@link ExtractorInput} from which data should be peeked/read.
+   * @return Whether this extractor can read the provided input.
    * @throws IOException If an error occurred reading from the input.
    * @throws InterruptedException If the thread was interrupted.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
index bf5788fc8c..87c141c0b2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
@@ -79,6 +79,33 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput
    */
   void readFully(byte[] target, int offset, int length) throws IOException, InterruptedException;
 
+  /**
+   * Like {@link #read(byte[], int, int)}, except the data is skipped instead of read.
+   *
+   * @param length The maximum number of bytes to skip from the input.
+   * @return The number of bytes skipped, or {@link C#RESULT_END_OF_INPUT} if the input has ended.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  int skip(int length) throws IOException, InterruptedException;
+
+  /**
+   * Like {@link #readFully(byte[], int, int, boolean)}, except the data is skipped instead of read.
+   *
+   * @param length The number of bytes to skip from the input.
+   * @param allowEndOfInput True if encountering the end of the input having skipped no data is
+   *     allowed, and should result in {@code false} being returned. False if it should be
+   *     considered an error, causing an {@link EOFException} to be thrown.
+   * @return True if the skip was successful. False if the end of the input was encountered having
+   *     skipped no data.
+   * @throws EOFException If the end of input was encountered having partially satisfied the skip
+   *     (i.e. having skipped at least one byte, but fewer than {@code length}), or if no bytes were
+   *     skipped and {@code allowEndOfInput} is false.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  boolean skipFully(int length, boolean allowEndOfInput) throws IOException, InterruptedException;
+
   /**
    * Like {@link #readFully(byte[], int, int)}, except the data is skipped instead of read.
    * <p>
@@ -92,12 +119,42 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput
    */
   void skipFully(int length) throws IOException, InterruptedException;
 
+  /**
+   * Peeks {@code length} bytes from the peek position, writing them into {@code target} at index
+   * {@code offset}. The current read position is left unchanged.
+   * <p>
+   * If the end of the input is found having peeked no data, then behavior is dependent on
+   * {@code allowEndOfInput}. If {@code allowEndOfInput == true} then {@code false} is returned.
+   * Otherwise an {@link EOFException} is thrown.
+   * <p>
+   * Calling {@link #resetPeekPosition()} resets the peek position to equal the current read
+   * position, so the caller can peek the same data again. Reading and skipping also reset the peek
+   * position.
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The number of bytes to peek from the input.
+   * @param allowEndOfInput True if encountering the end of the input having peeked no data is
+   *     allowed, and should result in {@code false} being returned. False if it should be
+   *     considered an error, causing an {@link EOFException} to be thrown.
+   * @return True if the peek was successful. False if the end of the input was encountered having
+   *     peeked no data.
+   * @throws EOFException If the end of input was encountered having partially satisfied the peek
+   *     (i.e. having peeked at least one byte, but fewer than {@code length}), or if no bytes were
+   *     peeked and {@code allowEndOfInput} is false.
+   * @throws IOException If an error occurs peeking from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException;
+
   /**
    * Peeks {@code length} bytes from the peek position, writing them into {@code target} at index
    * {@code offset}. The current read position is left unchanged.
    * <p>
    * Calling {@link #resetPeekPosition()} resets the peek position to equal the current read
-   * position, so the caller can peek the same data again. Reading also resets the peek position.
+   * position, so the caller can peek the same data again. Reading and skipping also reset the peek
+   * position.
    *
    * @param target A target array into which data should be written.
    * @param offset The offset into the target array at which to write.
@@ -108,6 +165,28 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput
    */
   void peekFully(byte[] target, int offset, int length) throws IOException, InterruptedException;
 
+  /**
+   * Advances the peek position by {@code length} bytes.
+   * <p>
+   * If the end of the input is encountered before advancing the peek position, then behavior is
+   * dependent on {@code allowEndOfInput}. If {@code allowEndOfInput == true} then {@code false} is
+   * returned. Otherwise an {@link EOFException} is thrown.
+   *
+   * @param length The number of bytes by which to advance the peek position.
+   * @param allowEndOfInput True if encountering the end of the input before advancing is allowed,
+   *     and should result in {@code false} being returned. False if it should be considered an
+   *     error, causing an {@link EOFException} to be thrown.
+   * @return True if advancing the peek position was successful. False if the end of the input was
+   *     encountered before the peek position could be advanced.
+   * @throws EOFException If the end of input was encountered having partially advanced (i.e. having
+   *     advanced by at least one byte, but fewer than {@code length}), or if the end of input was
+   *     encountered before advancing and {@code allowEndOfInput} is false.
+   * @throws IOException If an error occurs advancing the peek position.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  boolean advancePeekPosition(int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException;
+
   /**
    * Advances the peek position by {@code length} bytes.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index e13bb16422..a9b517a4d2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -27,7 +27,6 @@
 import com.google.android.exoplayer.upstream.Allocator;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
-import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.util.Assertions;
@@ -196,20 +195,6 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   private int extractedSampleCount;
   private int extractedSampleCountAtStartOfLoad;
 
-  /**
-   * @param uri The {@link Uri} of the media stream.
-   * @param dataSource A data source to read the media stream.
-   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
-   *     The actual allocated size may exceed the value passed in if the implementation requires it.
-   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
-   *     priority. If omitted, the default extractors will be used.
-   */
-  @Deprecated
-  public ExtractorSampleSource(Uri uri, DataSource dataSource, int requestedBufferSize,
-      Extractor... extractors) {
-    this(uri, dataSource, new DefaultAllocator(64 * 1024), requestedBufferSize, extractors);
-  }
-
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
@@ -225,23 +210,6 @@ public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator
         extractors);
   }
 
-  /**
-   * @param uri The {@link Uri} of the media stream.
-   * @param dataSource A data source to read the media stream.
-   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
-   *     The actual allocated size may exceed the value passed in if the implementation requires it.
-   * @param minLoadableRetryCount The minimum number of times that the sample source will retry
-   *     if a loading error occurs.
-   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
-   *     priority. If omitted, the default extractors will be used.
-   */
-  @Deprecated
-  public ExtractorSampleSource(Uri uri, DataSource dataSource, int requestedBufferSize,
-      int minLoadableRetryCount, Extractor... extractors) {
-    this(uri, dataSource, new DefaultAllocator(64 * 1024), requestedBufferSize,
-        minLoadableRetryCount, extractors);
-  }
-
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
@@ -377,16 +345,20 @@ public boolean continueBuffering(int track, long playbackPositionUs) {
   }
 
   @Override
-  public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
-    downstreamPositionUs = playbackPositionUs;
-
+  public long readDiscontinuity(int track) {
     if (pendingDiscontinuities[track]) {
       pendingDiscontinuities[track] = false;
-      return DISCONTINUITY_READ;
+      return lastSeekPositionUs;
     }
+    return NO_DISCONTINUITY;
+  }
+
+  @Override
+  public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder) {
+    downstreamPositionUs = playbackPositionUs;
 
-    if (onlyReadDiscontinuity || isPendingReset()) {
+    if (pendingDiscontinuities[track] || isPendingReset()) {
       return NOTHING_READ;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java
index 239fe69b7d..957755cb58 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
-import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 import android.util.Pair;
@@ -83,21 +82,13 @@ protected void parsePayload(ParsableByteArray data, long timeUs) {
     int packetType = data.readUnsignedByte();
     // Parse sequence header just in case it was not done before.
     if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
-      ParsableBitArray adtsScratch = new ParsableBitArray(new byte[data.bytesLeft()]);
-      data.readBytes(adtsScratch.data, 0, data.bytesLeft());
-
-      int audioObjectType = adtsScratch.readBits(5);
-      int sampleRateIndex = adtsScratch.readBits(4);
-      int channelConfig = adtsScratch.readBits(4);
-
-      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
-          audioObjectType, sampleRateIndex, channelConfig);
+      byte[] audioSpecifiConfig = new byte[data.bytesLeft()];
+      data.readBytes(audioSpecifiConfig, 0, audioSpecifiConfig.length);
       Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
-          audioSpecificConfig);
-
+          audioSpecifiConfig);
       MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_AAC,
           MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, getDurationUs(), audioParams.second,
-          audioParams.first, Collections.singletonList(audioSpecificConfig), null);
+          audioParams.first, Collections.singletonList(audioSpecifiConfig), null);
       output.format(mediaFormat);
       hasOutputFormat = true;
     } else if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java
index b28f422d67..0f71be791c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java
@@ -81,7 +81,9 @@ protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserEx
     Map<String, Object> metadata = readAmfEcmaArray(data);
     if (metadata.containsKey(KEY_DURATION)) {
       double durationSeconds = (double) metadata.get(KEY_DURATION);
-      setDurationUs((long) (durationSeconds * C.MICROS_PER_SECOND));
+      if (durationSeconds > 0.0) {
+        setDurationUs((long) (durationSeconds * C.MICROS_PER_SECOND));
+      }
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/BufferingInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/BufferingInput.java
deleted file mode 100644
index f628b70de3..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/BufferingInput.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.extractor.mp3;
-
-import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.ParsableByteArray;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.BufferOverflowException;
-
-/**
- * Buffers bytes read from an {@link ExtractorInput} to allow re-reading buffered bytes within a
- * window starting at a marked position.
- */
-/* package */ final class BufferingInput {
-
-  private final ParsableByteArray buffer;
-  private final int capacity;
-
-  private int readPosition;
-  private int writePosition;
-  private int markPosition;
-
-  /**
-   * Constructs a new buffer for reading from extractor inputs that can store up to {@code capacity}
-   * bytes.
-   *
-   * @param capacity Number of bytes that can be stored in the buffer.
-   */
-  public BufferingInput(int capacity) {
-    this.capacity = capacity;
-    buffer = new ParsableByteArray(capacity * 2);
-  }
-
-  /** Discards any pending data in the buffer and returns the writing position to zero. */
-  public void reset() {
-    readPosition = 0;
-    writePosition = 0;
-    markPosition = 0;
-  }
-
-  /**
-   * Moves the mark to be at the reading position. Any data before the reading position is
-   * discarded. After calling this method, calling {@link #returnToMark} will move the reading
-   * position back to the mark position.
-   */
-  public void mark() {
-    if (readPosition > capacity) {
-      System.arraycopy(buffer.data, readPosition, buffer.data, 0, writePosition - readPosition);
-      writePosition -= readPosition;
-      readPosition = 0;
-    }
-    markPosition = readPosition;
-  }
-
-  /** Moves the reading position back to the mark position. */
-  public void returnToMark() {
-    readPosition = markPosition;
-  }
-
-  /** Returns the number of bytes available for reading from the current position. */
-  public int getAvailableByteCount() {
-    return writePosition - readPosition;
-  }
-
-  /**
-   * Buffers any more data required to read {@code length} bytes from the reading position, and
-   * returns a {@link ParsableByteArray} that wraps the buffer's byte array, with its position set
-   * to the current reading position. The read position is then updated for having read
-   * {@code length} bytes.
-   *
-   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
-   * @param length Number of bytes that will be readable in the returned array.
-   * @return {@link ParsableByteArray} from which {@code length} bytes can be read.
-   * @throws IOException Thrown if there was an error reading from the stream.
-   * @throws InterruptedException Thrown if reading from the stream was interrupted.
-   */
-  public ParsableByteArray getParsableByteArray(ExtractorInput extractorInput, int length)
-      throws IOException, InterruptedException {
-    if (!ensureLoaded(extractorInput, length)) {
-      throw new EOFException();
-    }
-    ParsableByteArray parsableByteArray = new ParsableByteArray(buffer.data, writePosition);
-    parsableByteArray.setPosition(readPosition);
-    readPosition += length;
-    return parsableByteArray;
-  }
-
-  /**
-   * Drains as much buffered data as possible up to {@code length} bytes to {@code trackOutput}.
-   *
-   * @param trackOutput Track output to populate with up to {@code length} bytes of sample data.
-   * @param length Number of bytes to try to read from the buffer.
-   * @return The number of buffered bytes written.
-   */
-  public int drainToOutput(TrackOutput trackOutput, int length) {
-    if (length == 0) {
-      return 0;
-    }
-    buffer.setPosition(readPosition);
-    int bytesToDrain = Math.min(writePosition - readPosition, length);
-    trackOutput.sampleData(buffer, bytesToDrain);
-    readPosition += bytesToDrain;
-    return bytesToDrain;
-  }
-
-  /**
-   * Skips {@code length} bytes from the reading position, reading from {@code extractorInput} to
-   * populate the buffer if required.
-   *
-   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
-   * @param length Number of bytes to skip.
-   * @throws IOException Thrown if there was an error reading from the stream.
-   * @throws InterruptedException Thrown if reading from the stream was interrupted.
-   */
-  public void skip(ExtractorInput extractorInput, int length)
-      throws IOException, InterruptedException {
-    if (!readInternal(extractorInput, null, 0, length)) {
-      throw new EOFException();
-    }
-  }
-
-  /**
-   * Reads {@code length} bytes from the reading position, reading from {@code extractorInput} to
-   * populate the buffer if required.
-   *
-   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
-   * @param length Number of bytes to read.
-   * @throws IOException Thrown if there was an error reading from the stream.
-   * @throws InterruptedException Thrown if reading from the stream was interrupted.
-   * @throws EOFException Thrown if the end of the file was reached.
-   */
-  public void read(ExtractorInput extractorInput, byte[] target, int offset, int length)
-      throws IOException, InterruptedException {
-    if (!readInternal(extractorInput, target, offset, length)) {
-      throw new EOFException();
-    }
-  }
-
-  /**
-   * Reads {@code length} bytes from the reading position, reading from {@code extractorInput} to
-   * populate the buffer if required.
-   *
-   * <p>Returns {@code false} if the end of the stream has been reached. Throws {@link EOFException}
-   * if the read request could only be partially satisfied. Returns {@code true} otherwise.
-   *
-   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
-   * @param length Number of bytes to read.
-   * @return Whether the extractor input is at the end of the stream.
-   * @throws IOException Thrown if there was an error reading from the stream.
-   * @throws InterruptedException Thrown if reading from the stream was interrupted.
-   * @throws EOFException Thrown if the end of the file was reached.
-   */
-  public boolean readAllowingEndOfInput(ExtractorInput extractorInput, byte[] target, int offset,
-      int length) throws IOException, InterruptedException {
-    return readInternal(extractorInput, target, offset, length);
-  }
-
-  private boolean readInternal(ExtractorInput extractorInput, byte[] target, int offset, int length)
-      throws InterruptedException, IOException {
-    if (!ensureLoaded(extractorInput, length)) {
-      return false;
-    }
-    if (target != null) {
-      System.arraycopy(buffer.data, readPosition, target, offset, length);
-    }
-    readPosition += length;
-    return true;
-  }
-
-  /** Ensures the buffer contains enough data to read {@code length} bytes. */
-  private boolean ensureLoaded(ExtractorInput extractorInput, int length)
-      throws InterruptedException, IOException {
-    if (length + readPosition - markPosition > capacity) {
-      throw new BufferOverflowException();
-    }
-
-    int bytesToLoad = length - (writePosition - readPosition);
-    if (bytesToLoad > 0) {
-      if (!extractorInput.readFully(buffer.data, writePosition, bytesToLoad, true)) {
-        return false;
-      }
-      writePosition += bytesToLoad;
-    }
-    return true;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
index db134089b9..bf83902410 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
@@ -47,7 +47,8 @@ public long getPosition(long timeUs) {
 
   @Override
   public long getTimeUs(long position) {
-    return ((position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE) / bitrate;
+    return (Math.max(0, position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE)
+        / bitrate;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java
new file mode 100644
index 0000000000..06aa5add34
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import android.util.Pair;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility for parsing ID3 version 2 metadata in MP3 files.
+ */
+/* package */ final class Id3Util {
+
+  /**
+   * The maximum valid length for metadata in bytes.
+   */
+  private static final int MAXIMUM_METADATA_SIZE = 3 * 1024 * 1024;
+
+  private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
+  private static final String GAPLESS_COMMENT_NAME = "iTunSMPB";
+  private static final Pattern GAPLESS_COMMENT_VALUE_PATTERN =
+      Pattern.compile("^ [0-9a-fA-F]{8} ([0-9a-fA-F]{8}) ([0-9a-fA-F]{8})");
+  private static final Charset[] CHARSET_BY_ENCODING = new Charset[] {Charset.forName("ISO-8859-1"),
+      Charset.forName("UTF-16LE"), Charset.forName("UTF-16BE"), Charset.forName("UTF-8")};
+
+  /**
+   * Peeks data from the input and parses ID3 metadata.
+   *
+   * @param input The {@link ExtractorInput} from which data should be peeked.
+   * @param out {@link Mp3Extractor.Metadata} to populate based on the input.
+   * @return The number of bytes peeked from the input.
+   * @throws IOException If an error occurred peeking from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public static int parseId3(ExtractorInput input, Mp3Extractor.Metadata out)
+      throws IOException, InterruptedException {
+    out.encoderDelay = 0;
+    out.encoderPadding = 0;
+    ParsableByteArray scratch = new ParsableByteArray(10);
+    int peekedId3Bytes = 0;
+    while (true) {
+      input.peekFully(scratch.data, 0, 10);
+      scratch.setPosition(0);
+      if (scratch.readUnsignedInt24() != ID3_TAG) {
+        break;
+      }
+
+      int majorVersion = scratch.readUnsignedByte();
+      int minorVersion = scratch.readUnsignedByte();
+      int flags = scratch.readUnsignedByte();
+      int length = scratch.readSynchSafeInt();
+      if (canParseMetadata(majorVersion, minorVersion, flags, length)) {
+        byte[] frame = new byte[length];
+        input.peekFully(frame, 0, length);
+        parseMetadata(new ParsableByteArray(frame), majorVersion, flags, out);
+      } else {
+        input.advancePeekPosition(length);
+      }
+
+      peekedId3Bytes += 10 + length;
+    }
+    input.resetPeekPosition();
+    input.advancePeekPosition(peekedId3Bytes);
+    return peekedId3Bytes;
+  }
+
+  private static boolean canParseMetadata(int majorVersion, int minorVersion, int flags,
+      int length) {
+    return minorVersion != 0xFF && majorVersion >= 2 && majorVersion <= 4
+        && length <= MAXIMUM_METADATA_SIZE
+        && !(majorVersion == 2 && ((flags & 0x3F) != 0 || (flags & 0x40) != 0))
+        && !(majorVersion == 3 && (flags & 0x1F) != 0)
+        && !(majorVersion == 4 && (flags & 0x0F) != 0);
+  }
+
+  private static void parseMetadata(ParsableByteArray frame, int version, int flags,
+      Mp3Extractor.Metadata out) {
+    unescape(frame, version, flags);
+
+    // Skip any extended header.
+    frame.setPosition(0);
+    if (version == 3 && (flags & 0x40) != 0) {
+      if (frame.bytesLeft() < 4) {
+        return;
+      }
+      int extendedHeaderSize = frame.readUnsignedIntToInt();
+      if (extendedHeaderSize > frame.bytesLeft()) {
+        return;
+      }
+      int paddingSize = 0;
+      if (extendedHeaderSize >= 6) {
+        frame.skipBytes(2); // extended flags
+        paddingSize = frame.readUnsignedIntToInt();
+        frame.setPosition(4);
+        frame.setLimit(frame.limit() - paddingSize);
+        if (frame.bytesLeft() < extendedHeaderSize) {
+          return;
+        }
+      }
+      frame.skipBytes(extendedHeaderSize);
+    } else if (version == 4 && (flags & 0x40) != 0) {
+      if (frame.bytesLeft() < 4) {
+        return;
+      }
+      int extendedHeaderSize = frame.readSynchSafeInt();
+      if (extendedHeaderSize < 6 || extendedHeaderSize > frame.bytesLeft() + 4) {
+        return;
+      }
+      frame.setPosition(extendedHeaderSize);
+    }
+
+    // Extract gapless playback metadata stored in comments.
+    Pair<String, String> comment;
+    while ((comment = findNextComment(version, frame)) != null) {
+      if (comment.first.length() > 3 && comment.first.substring(3).equals(GAPLESS_COMMENT_NAME)) {
+        Matcher matcher = GAPLESS_COMMENT_VALUE_PATTERN.matcher(comment.second);
+        if (matcher.find()) {
+          try {
+            out.encoderDelay = Integer.parseInt(matcher.group(1), 16);
+            out.encoderPadding = Integer.parseInt(matcher.group(2), 16);
+            break;
+          } catch (NumberFormatException e) {
+            out.encoderDelay = 0;
+            return;
+          }
+        }
+      }
+    }
+  }
+
+  private static Pair<String, String> findNextComment(int majorVersion, ParsableByteArray data) {
+    int frameSize;
+    while (true) {
+      if (majorVersion == 2) {
+        if (data.bytesLeft() < 6) {
+          return null;
+        }
+        String id = data.readString(3, Charset.forName("US-ASCII"));
+        if (id.equals("\0\0\0")) {
+          return null;
+        }
+        frameSize = data.readUnsignedInt24();
+        if (frameSize == 0 || frameSize > data.bytesLeft()) {
+          return null;
+        }
+        if (id.equals("COM")) {
+          break;
+        }
+      } else /* major == 3 || major == 4 */ {
+        if (data.bytesLeft() < 10) {
+          return null;
+        }
+        String id = data.readString(4, Charset.forName("US-ASCII"));
+        if (id.equals("\0\0\0\0")) {
+          return null;
+        }
+        frameSize = majorVersion == 4 ? data.readSynchSafeInt() : data.readUnsignedIntToInt();
+        if (frameSize == 0 || frameSize > data.bytesLeft() - 2) {
+          return null;
+        }
+        int flags = data.readUnsignedShort();
+        boolean compressedOrEncrypted = (majorVersion == 4 && (flags & 0x0C) != 0)
+            || (majorVersion == 3 && (flags & 0xC0) != 0);
+        if (!compressedOrEncrypted && id.equals("COMM")) {
+          break;
+        }
+      }
+      data.skipBytes(frameSize);
+    }
+
+    // The comment tag is at the reading position in data.
+    int encoding = data.readUnsignedByte();
+    if (encoding < 0 || encoding >= CHARSET_BY_ENCODING.length) {
+      return null;
+    }
+    Charset charset = CHARSET_BY_ENCODING[encoding];
+    String[] commentFields = data.readString(frameSize - 1, charset).split("\0");
+    return commentFields.length == 2 ? Pair.create(commentFields[0], commentFields[1]) : null;
+  }
+
+  private static boolean unescape(ParsableByteArray frame, int version, int flags) {
+    if (version != 4) {
+      if ((flags & 0x80) != 0) {
+        // Remove unsynchronization on ID3 version < 2.4.0.
+        byte[] bytes = frame.data;
+        int newLength = bytes.length;
+        for (int i = 0; i + 1 < newLength; i++) {
+          if ((bytes[i] & 0xFF) == 0xFF && bytes[i + 1] == 0x00) {
+            System.arraycopy(bytes, i + 2, bytes, i + 1, newLength - i - 2);
+            newLength--;
+          }
+        }
+        frame.setLimit(newLength);
+      }
+    } else {
+      // Remove unsynchronization on ID3 version 2.4.0.
+      if (canUnescapeVersion4(frame, false)) {
+        unescapeVersion4(frame, false);
+      } else if (canUnescapeVersion4(frame, true)) {
+        unescapeVersion4(frame, true);
+      } else {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private static boolean canUnescapeVersion4(ParsableByteArray frame,
+      boolean unsignedIntDataSizeHack) {
+    frame.setPosition(0);
+    while (frame.bytesLeft() >= 10) {
+      if (frame.readInt() == 0) {
+        return true;
+      }
+      long dataSize = frame.readUnsignedInt();
+      if (!unsignedIntDataSizeHack) {
+        // Parse the data size as a syncsafe integer.
+        if ((dataSize & 0x808080L) != 0) {
+          return false;
+        }
+        dataSize = (dataSize & 0x7F) | (((dataSize >> 8) & 0x7F) << 7)
+            | (((dataSize >> 16) & 0x7F) << 14) | (((dataSize >> 24) & 0x7F) << 21);
+      }
+      if (dataSize > frame.bytesLeft() - 2) {
+        return false;
+      }
+      int flags = frame.readUnsignedShort();
+      if ((flags & 1) != 0) {
+        if (frame.bytesLeft() < 4) {
+          return false;
+        }
+      }
+      frame.skipBytes((int) dataSize);
+    }
+    return true;
+  }
+
+  private static void unescapeVersion4(ParsableByteArray frame, boolean unsignedIntDataSizeHack) {
+    frame.setPosition(0);
+    byte[] bytes = frame.data;
+    while (frame.bytesLeft() >= 10) {
+      if (frame.readInt() == 0) {
+        return;
+      }
+      int dataSize =
+          unsignedIntDataSizeHack ? frame.readUnsignedIntToInt() : frame.readSynchSafeInt();
+      int flags = frame.readUnsignedShort();
+      int previousFlags = flags;
+      if ((flags & 1) != 0) {
+        // Strip data length indicator.
+        int offset = frame.getPosition();
+        System.arraycopy(bytes, offset + 4, bytes, offset, frame.bytesLeft() - 4);
+        dataSize -= 4;
+        flags &= ~1;
+        frame.setLimit(frame.limit() - 4);
+      }
+      if ((flags & 2) != 0) {
+        // Unescape 0xFF00 to 0xFF in the next dataSize bytes.
+        int readOffset = frame.getPosition() + 1;
+        int writeOffset = readOffset;
+        for (int i = 0; i + 1 < dataSize; i++) {
+          if ((bytes[readOffset - 1] & 0xFF) == 0xFF && bytes[readOffset] == 0) {
+            readOffset++;
+            dataSize--;
+          }
+          bytes[writeOffset++] = bytes[readOffset++];
+        }
+        frame.setLimit(frame.limit() - (readOffset - writeOffset));
+        System.arraycopy(bytes, readOffset, bytes, writeOffset, frame.bytesLeft() - readOffset);
+        flags &= ~2;
+      }
+      if (flags != previousFlags || unsignedIntDataSizeHack) {
+        int dataSizeOffset = frame.getPosition() - 6;
+        writeSyncSafeInteger(bytes, dataSizeOffset, dataSize);
+        bytes[dataSizeOffset + 4] = (byte) (flags >> 8);
+        bytes[dataSizeOffset + 5] = (byte) (flags & 0xFF);
+      }
+      frame.skipBytes(dataSize);
+    }
+  }
+
+  private static void writeSyncSafeInteger(byte[] bytes, int offset, int value) {
+    bytes[offset] = (byte) ((value >> 21) & 0x7F);
+    bytes[offset + 1] = (byte) ((value >> 14) & 0x7F);
+    bytes[offset + 2] = (byte) ((value >> 7) & 0x7F);
+    bytes[offset + 3] = (byte) (value & 0x7F);
+  }
+
+  private Id3Util() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index 7a07c76bb1..e16d294845 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -36,22 +36,27 @@
  */
 public final class Mp3Extractor implements Extractor {
 
-  /** The maximum number of bytes to search when synchronizing, before giving up. */
+  /**
+   * The maximum number of bytes to search when synchronizing, before giving up.
+   */
   private static final int MAX_SYNC_BYTES = 128 * 1024;
-  /** The maximum number of bytes to read when sniffing, excluding the header, before giving up. */
-  private static final int MAX_SNIFF_BYTES = 4 * 1024;
+  /**
+   * The maximum number of bytes to peek when sniffing, excluding the ID3 header, before giving up.
+   */
+  private static final int MAX_SNIFF_BYTES = MpegAudioHeader.MAX_FRAME_SIZE_BYTES;
 
-  /** Mask that includes the audio header values that must match between frames. */
+  /**
+   * Mask that includes the audio header values that must match between frames.
+   */
   private static final int HEADER_MASK = 0xFFFE0C00;
-  private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
   private static final int XING_HEADER = Util.getIntegerCodeForString("Xing");
   private static final int INFO_HEADER = Util.getIntegerCodeForString("Info");
   private static final int VBRI_HEADER = Util.getIntegerCodeForString("VBRI");
 
   private final long forcedFirstSampleTimestampUs;
-  private final BufferingInput inputBuffer;
   private final ParsableByteArray scratch;
   private final MpegAudioHeader synchronizedHeader;
+  private final Metadata metadata;
 
   // Extractor outputs.
   private ExtractorOutput extractorOutput;
@@ -79,69 +84,15 @@ public Mp3Extractor() {
    */
   public Mp3Extractor(long forcedFirstSampleTimestampUs) {
     this.forcedFirstSampleTimestampUs = forcedFirstSampleTimestampUs;
-    inputBuffer = new BufferingInput(MpegAudioHeader.MAX_FRAME_SIZE_BYTES * 3);
     scratch = new ParsableByteArray(4);
     synchronizedHeader = new MpegAudioHeader();
+    metadata = new Metadata();
     basisTimeUs = -1;
   }
 
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-    ParsableByteArray scratch = new ParsableByteArray(4);
-    int startPosition = 0;
-    while (true) {
-      input.peekFully(scratch.data, 0, 3);
-      scratch.setPosition(0);
-      if (scratch.readUnsignedInt24() != ID3_TAG) {
-        break;
-      }
-      input.advancePeekPosition(3);
-      input.peekFully(scratch.data, 0, 4);
-      int headerLength = ((scratch.data[0] & 0x7F) << 21) | ((scratch.data[1] & 0x7F) << 14)
-          | ((scratch.data[2] & 0x7F) << 7) | (scratch.data[3] & 0x7F);
-      input.advancePeekPosition(headerLength);
-      startPosition += 3 + 3 + 4 + headerLength;
-    }
-    input.resetPeekPosition();
-    input.advancePeekPosition(startPosition);
-
-    // Try to find four consecutive valid MPEG audio frames.
-    int headerPosition = startPosition;
-    int validFrameCount = 0;
-    int candidateSynchronizedHeaderData = 0;
-    while (true) {
-      if (headerPosition - startPosition >= MAX_SNIFF_BYTES) {
-        return false;
-      }
-
-      input.peekFully(scratch.data, 0, 4);
-      scratch.setPosition(0);
-      int headerData = scratch.readInt();
-      int frameSize;
-      if ((candidateSynchronizedHeaderData != 0
-          && (headerData & HEADER_MASK) != (candidateSynchronizedHeaderData & HEADER_MASK))
-          || (frameSize = MpegAudioHeader.getFrameSize(headerData)) == -1) {
-        validFrameCount = 0;
-        candidateSynchronizedHeaderData = 0;
-
-        // Try reading a header starting at the next byte.
-        input.resetPeekPosition();
-        input.advancePeekPosition(++headerPosition);
-        continue;
-      }
-
-      if (validFrameCount == 0) {
-        candidateSynchronizedHeaderData = headerData;
-      }
-
-      // The header was valid and matching (if appropriate). Check another or end synchronization.
-      if (++validFrameCount == 4) {
-        return true;
-      }
-
-      // Look for more headers.
-      input.advancePeekPosition(frameSize - 4);
-    }
+    return synchronize(input, true);
   }
 
   @Override
@@ -157,28 +108,31 @@ public void seek() {
     samplesRead = 0;
     basisTimeUs = -1;
     sampleBytesRemaining = 0;
-    inputBuffer.reset();
   }
 
   @Override
-  public int read(ExtractorInput extractorInput, PositionHolder seekPosition)
+  public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    if (synchronizedHeaderData == 0
-        && synchronizeCatchingEndOfInput(extractorInput) == RESULT_END_OF_INPUT) {
+    if (synchronizedHeaderData == 0 && !synchronizeCatchingEndOfInput(input)) {
       return RESULT_END_OF_INPUT;
     }
-
-    return readSample(extractorInput);
+    if (seeker == null) {
+      setupSeeker(input);
+      extractorOutput.seekMap(seeker);
+      trackOutput.format(MediaFormat.createAudioFormat(null, synchronizedHeader.mimeType,
+          MediaFormat.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, seeker.getDurationUs(),
+          synchronizedHeader.channels, synchronizedHeader.sampleRate, null, null));
+    }
+    return readSample(input);
   }
 
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
     if (sampleBytesRemaining == 0) {
-      long headerPosition = maybeResynchronize(extractorInput);
-      if (headerPosition == RESULT_END_OF_INPUT) {
+      if (!maybeResynchronize(extractorInput)) {
         return RESULT_END_OF_INPUT;
       }
       if (basisTimeUs == -1) {
-        basisTimeUs = seeker.getTimeUs(getPosition(extractorInput, inputBuffer));
+        basisTimeUs = seeker.getTimeUs(extractorInput.getPosition());
         if (forcedFirstSampleTimestampUs != -1) {
           long embeddedFirstSampleTimestampUs = seeker.getTimeUs(0);
           basisTimeUs += forcedFirstSampleTimestampUs - embeddedFirstSampleTimestampUs;
@@ -186,24 +140,15 @@ private int readSample(ExtractorInput extractorInput) throws IOException, Interr
       }
       sampleBytesRemaining = synchronizedHeader.frameSize;
     }
-
-    long timeUs = basisTimeUs + (samplesRead * C.MICROS_PER_SECOND / synchronizedHeader.sampleRate);
-
-    // Start by draining any buffered bytes, then read directly from the extractor input.
-    sampleBytesRemaining -= inputBuffer.drainToOutput(trackOutput, sampleBytesRemaining);
+    int bytesAppended = trackOutput.sampleData(extractorInput, sampleBytesRemaining, true);
+    if (bytesAppended == C.RESULT_END_OF_INPUT) {
+      return RESULT_END_OF_INPUT;
+    }
+    sampleBytesRemaining -= bytesAppended;
     if (sampleBytesRemaining > 0) {
-      inputBuffer.mark();
-      int bytesAppended = trackOutput.sampleData(extractorInput, sampleBytesRemaining, true);
-      if (bytesAppended == C.RESULT_END_OF_INPUT) {
-        return RESULT_END_OF_INPUT;
-      }
-      sampleBytesRemaining -= bytesAppended;
-      // Return if we still need more data.
-      if (sampleBytesRemaining > 0) {
-        return RESULT_CONTINUE;
-      }
+      return RESULT_CONTINUE;
     }
-
+    long timeUs = basisTimeUs + (samplesRead * C.MICROS_PER_SECOND / synchronizedHeader.sampleRate);
     trackOutput.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, synchronizedHeader.frameSize, 0, null);
     samplesRead += synchronizedHeader.samplesPerFrame;
     sampleBytesRemaining = 0;
@@ -213,13 +158,12 @@ private int readSample(ExtractorInput extractorInput) throws IOException, Interr
   /**
    * Attempts to read an MPEG audio header at the current offset, resynchronizing if necessary.
    */
-  private long maybeResynchronize(ExtractorInput extractorInput)
+  private boolean maybeResynchronize(ExtractorInput extractorInput)
       throws IOException, InterruptedException {
-    inputBuffer.mark();
-    if (!inputBuffer.readAllowingEndOfInput(extractorInput, scratch.data, 0, 4)) {
-      return RESULT_END_OF_INPUT;
+    extractorInput.resetPeekPosition();
+    if (!extractorInput.peekFully(scratch.data, 0, 4, true)) {
+      return false;
     }
-    inputBuffer.returnToMark();
 
     scratch.setPosition(0);
     int sampleHeaderData = scratch.readInt();
@@ -227,209 +171,139 @@ private long maybeResynchronize(ExtractorInput extractorInput)
       int frameSize = MpegAudioHeader.getFrameSize(sampleHeaderData);
       if (frameSize != -1) {
         MpegAudioHeader.populateHeader(sampleHeaderData, synchronizedHeader);
-        return RESULT_CONTINUE;
+        return true;
       }
     }
 
     synchronizedHeaderData = 0;
-    inputBuffer.skip(extractorInput, 1);
+    extractorInput.skipFully(1);
     return synchronizeCatchingEndOfInput(extractorInput);
   }
 
-  private long synchronizeCatchingEndOfInput(ExtractorInput extractorInput)
+  private boolean synchronizeCatchingEndOfInput(ExtractorInput input)
       throws IOException, InterruptedException {
-    // An EOFException will be raised if any read operation was partially satisfied. If a seek
-    // operation resulted in reading from within the last frame, we may try to read past the end of
+    // An EOFException will be raised if any peek operation was partially satisfied. If a seek
+    // operation resulted in reading from within the last frame, we may try to peek past the end of
     // the file in a partially-satisfied read operation, so we need to catch the exception.
     try {
-      return synchronize(extractorInput);
+      return synchronize(input, false);
     } catch (EOFException e) {
-      return RESULT_END_OF_INPUT;
+      return false;
     }
   }
 
-  private long synchronize(ExtractorInput extractorInput) throws IOException, InterruptedException {
-    // TODO: Use peekFully instead of a buffering input, and deduplicate with sniff().
-    if (extractorInput.getPosition() == 0) {
-      // Before preparation completes, retrying loads from the start, so clear any buffered data.
-      inputBuffer.reset();
-    } else {
-      // After preparation completes, retrying resumes loading from the old position, so return to
-      // the start of buffered data to parse it again.
-      inputBuffer.returnToMark();
-    }
-
-    long startPosition = getPosition(extractorInput, inputBuffer);
-
-    // Skip any ID3 header at the start of the file.
-    if (startPosition == 0) {
-      while (true) {
-        inputBuffer.read(extractorInput, scratch.data, 0, 3);
-        scratch.setPosition(0);
-        if (scratch.readUnsignedInt24() != ID3_TAG) {
-          break;
-        }
-        extractorInput.skipFully(3);
-        extractorInput.readFully(scratch.data, 0, 4);
-        int headerLength = ((scratch.data[0] & 0x7F) << 21) | ((scratch.data[1] & 0x7F) << 14)
-            | ((scratch.data[2] & 0x7F) << 7) | (scratch.data[3] & 0x7F);
-        extractorInput.skipFully(headerLength);
-        inputBuffer.reset();
-        startPosition = getPosition(extractorInput, inputBuffer);
-      }
-      inputBuffer.returnToMark();
-    }
-
-    // Try to find four consecutive valid MPEG audio frames.
-    inputBuffer.mark();
-    long headerPosition = startPosition;
+  private boolean synchronize(ExtractorInput input, boolean sniffing)
+      throws IOException, InterruptedException {
+    input.resetPeekPosition();
+    int searched = 0;
     int validFrameCount = 0;
     int candidateSynchronizedHeaderData = 0;
+    int peekedId3Bytes = input.getPosition() == 0 ? Id3Util.parseId3(input, metadata) : 0;
     while (true) {
-      if (headerPosition - startPosition >= MAX_SYNC_BYTES) {
-        throw new ParserException("Searched too many bytes while resynchronizing.");
+      if (sniffing && searched == MAX_SNIFF_BYTES) {
+        return false;
       }
-
-      if (!inputBuffer.readAllowingEndOfInput(extractorInput, scratch.data, 0, 4)) {
-        return RESULT_END_OF_INPUT;
+      if (!sniffing && searched == MAX_SYNC_BYTES) {
+        throw new ParserException("Searched too many bytes.");
+      }
+      if (!input.peekFully(scratch.data, 0, 4, true)) {
+        return false;
       }
-
       scratch.setPosition(0);
       int headerData = scratch.readInt();
       int frameSize;
       if ((candidateSynchronizedHeaderData != 0
           && (headerData & HEADER_MASK) != (candidateSynchronizedHeaderData & HEADER_MASK))
           || (frameSize = MpegAudioHeader.getFrameSize(headerData)) == -1) {
+        // The header is invalid or doesn't match the candidate header. Try the next byte offset.
         validFrameCount = 0;
         candidateSynchronizedHeaderData = 0;
-
-        // Try reading a header starting at the next byte.
-        inputBuffer.returnToMark();
-        inputBuffer.skip(extractorInput, 1);
-        inputBuffer.mark();
-        headerPosition++;
-        continue;
-      }
-
-      if (validFrameCount == 0) {
-        MpegAudioHeader.populateHeader(headerData, synchronizedHeader);
-        candidateSynchronizedHeaderData = headerData;
-      }
-
-      // The header was valid and matching (if appropriate). Check another or end synchronization.
-      validFrameCount++;
-      if (validFrameCount == 4) {
-        break;
+        searched++;
+        if (sniffing) {
+          input.resetPeekPosition();
+          input.advancePeekPosition(peekedId3Bytes + searched);
+        } else {
+          input.skipFully(1);
+        }
+      } else {
+        // The header is valid and matches the candidate header.
+        validFrameCount++;
+        if (validFrameCount == 1) {
+          MpegAudioHeader.populateHeader(headerData, synchronizedHeader);
+          candidateSynchronizedHeaderData = headerData;
+        } else if (validFrameCount == 4) {
+          break;
+        }
+        input.advancePeekPosition(frameSize - 4);
       }
-
-      // Look for more headers.
-      inputBuffer.skip(extractorInput, frameSize - 4);
     }
-
-    // The input buffer read position is now synchronized.
-    inputBuffer.returnToMark();
-    synchronizedHeaderData = candidateSynchronizedHeaderData;
-    if (seeker == null) {
-      setupSeeker(extractorInput, headerPosition);
-      extractorOutput.seekMap(seeker);
-      trackOutput.format(MediaFormat.createAudioFormat(null, synchronizedHeader.mimeType,
-          MediaFormat.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, seeker.getDurationUs(),
-          synchronizedHeader.channels, synchronizedHeader.sampleRate, null, null));
+    // Prepare to read the synchronized frame.
+    if (sniffing) {
+      input.skipFully(peekedId3Bytes + searched);
+    } else {
+      input.resetPeekPosition();
     }
-
-    return headerPosition;
+    synchronizedHeaderData = candidateSynchronizedHeaderData;
+    return true;
   }
 
   /**
-   * Sets {@link #seeker} to seek using metadata from {@link #inputBuffer}, which should have its
-   * position set to the start of the first frame in the stream. On returning,
-   * {@link #inputBuffer}'s position and mark will be set to the start of the first frame of audio.
+   * Sets {@link #seeker} to seek using metadata read from {@code input}, which should provide data
+   * from the start of the first frame in the stream. On returning, the input's position will be set
+   * to the start of the first frame of audio.
    *
-   * @param extractorInput Source of data for {@link #inputBuffer}.
-   * @param headerPosition Position (byte offset) of the synchronized header in the stream.
+   * @param input The {@link ExtractorInput} from which to read.
    * @throws IOException Thrown if there was an error reading from the stream. Not expected if the
-   *     next two frames were already read during synchronization.
+   *     next two frames were already peeked during synchronization.
    * @throws InterruptedException Thrown if reading from the stream was interrupted. Not expected if
-   *     the next two frames were already read during synchronization.
+   *     the next two frames were already peeked during synchronization.
    */
-  private void setupSeeker(ExtractorInput extractorInput, long headerPosition)
-      throws IOException, InterruptedException {
-    // Try to set up seeking based on a XING or VBRI header.
-    if (parseSeekerFrame(extractorInput, headerPosition, extractorInput.getLength())) {
-      // Discard the parsed header so we start reading from the first audio frame.
-      inputBuffer.mark();
-      if (seeker != null) {
-        return;
-      }
-
-      // If there was a header but it was not usable, synchronize to the next frame so we don't
-      // use an invalid bitrate for CBR seeking. This read is guaranteed to succeed if the frame was
-      // already read during synchronization.
-      inputBuffer.read(extractorInput, scratch.data, 0, 4);
-      scratch.setPosition(0);
-      headerPosition += synchronizedHeader.frameSize;
-      MpegAudioHeader.populateHeader(scratch.readInt(), synchronizedHeader);
-    }
-
-    inputBuffer.returnToMark();
-    seeker = new ConstantBitrateSeeker(headerPosition, synchronizedHeader.bitrate * 1000,
-        extractorInput.getLength());
-  }
-
-  /**
-   * Consumes the frame at {@link #inputBuffer}'s current position, advancing it to the next frame.
-   * The mark is not modified. {@link #seeker} will be assigned based on seeking metadata in the
-   * frame. If there is no seeking metadata, returns {@code false} and sets {@link #seeker} to null.
-   * If seeking metadata is present and unusable, returns {@code true} and sets {@link #seeker} to
-   * null. Otherwise, returns {@code true} and assigns {@link #seeker}.
-   */
-  private boolean parseSeekerFrame(ExtractorInput extractorInput, long headerPosition,
-      long inputLength) throws IOException, InterruptedException {
-    // Read the first frame so it can be parsed for seeking metadata.
-    inputBuffer.mark();
-    seeker = null;
-    ParsableByteArray frame =
-        inputBuffer.getParsableByteArray(extractorInput, synchronizedHeader.frameSize);
-
-    // Check if there is a XING header.
-    int xingBase;
-    if ((synchronizedHeader.version & 1) == 1) {
-      // MPEG 1.
-      if (synchronizedHeader.channels != 1) {
-        xingBase = 32;
-      } else {
-        xingBase = 17;
+  private void setupSeeker(ExtractorInput input) throws IOException, InterruptedException {
+    // Read the first frame which may contain a Xing or VBRI header with seeking metadata.
+    ParsableByteArray frame = new ParsableByteArray(synchronizedHeader.frameSize);
+    input.peekFully(frame.data, 0, synchronizedHeader.frameSize);
+
+    long position = input.getPosition();
+    long length = input.getLength();
+
+    // Check if there is a Xing header.
+    int xingBase = (synchronizedHeader.version & 1) != 0
+        ? (synchronizedHeader.channels != 1 ? 36 : 21) // MPEG 1
+        : (synchronizedHeader.channels != 1 ? 21 : 13); // MPEG 2 or 2.5
+    frame.setPosition(xingBase);
+    int headerData = frame.readInt();
+    if (headerData == XING_HEADER || headerData == INFO_HEADER) {
+      seeker = XingSeeker.create(synchronizedHeader, frame, position, length);
+      if (seeker != null && metadata.encoderDelay == 0 && metadata.encoderPadding == 0) {
+        // If there is a Xing header, read gapless playback metadata at a fixed offset.
+        input.resetPeekPosition();
+        input.advancePeekPosition(xingBase + 141);
+        input.peekFully(scratch.data, 0, 3);
+        scratch.setPosition(0);
+        int gaplessMetadata = scratch.readUnsignedInt24();
+        metadata.encoderDelay = gaplessMetadata >> 12;
+        metadata.encoderPadding = gaplessMetadata & 0x0FFF;
       }
+      input.skipFully(synchronizedHeader.frameSize);
     } else {
-      // MPEG 2 or 2.5.
-      if (synchronizedHeader.channels != 1) {
-        xingBase = 17;
-      } else {
-        xingBase = 9;
+      // Check if there is a VBRI header.
+      frame.setPosition(36); // MPEG audio header (4 bytes) + 32 bytes.
+      headerData = frame.readInt();
+      if (headerData == VBRI_HEADER) {
+        seeker = VbriSeeker.create(synchronizedHeader, frame, position);
+        input.skipFully(synchronizedHeader.frameSize);
       }
     }
-    frame.setPosition(4 + xingBase);
-    int headerData = frame.readInt();
-    if (headerData == XING_HEADER || headerData == INFO_HEADER) {
-      seeker = XingSeeker.create(synchronizedHeader, frame, headerPosition, inputLength);
-      return true;
-    }
 
-    // Check if there is a VBRI header.
-    frame.setPosition(36); // MPEG audio header (4 bytes) + 32 bytes.
-    headerData = frame.readInt();
-    if (headerData == VBRI_HEADER) {
-      seeker = VbriSeeker.create(synchronizedHeader, frame, headerPosition);
-      return true;
+    if (seeker == null) {
+      // Repopulate the synchronized header in case we had to skip an invalid seeking header, which
+      // would give an invalid CBR bitrate.
+      input.resetPeekPosition();
+      input.peekFully(scratch.data, 0, 4);
+      scratch.setPosition(0);
+      MpegAudioHeader.populateHeader(scratch.readInt(), synchronizedHeader);
+      seeker = new ConstantBitrateSeeker(input.getPosition(), synchronizedHeader.bitrate, length);
     }
-
-    // Neither header is present.
-    return false;
-  }
-
-  /** Returns the reading position of {@code bufferingInput} relative to the extractor's stream. */
-  private static long getPosition(ExtractorInput extractorInput, BufferingInput bufferingInput) {
-    return extractorInput.getPosition() - bufferingInput.getAvailableByteCount();
   }
 
   /**
@@ -451,4 +325,11 @@ private static long getPosition(ExtractorInput extractorInput, BufferingInput bu
 
   }
 
+  /* package */ static final class Metadata {
+
+    public int encoderDelay;
+    public int encoderPadding;
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
index bc548f676c..9477b7cd31 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
@@ -21,7 +21,7 @@
 import com.google.android.exoplayer.util.Util;
 
 /**
- * MP3 seeker that uses metadata from a XING header.
+ * MP3 seeker that uses metadata from a Xing header.
  */
 /* package */ final class XingSeeker implements Mp3Extractor.Seeker {
 
@@ -32,7 +32,7 @@
    *
    * @param mpegAudioHeader The MPEG audio header associated with the frame.
    * @param frame The data in this audio frame, with its position set to immediately after the
-   *    'XING' or 'INFO' tag.
+   *    'Xing' or 'Info' tag.
    * @param position The position (byte offset) of the start of this frame in the stream.
    * @param inputLength The length of the stream in bytes.
    * @return A {@link XingSeeker} for seeking in the stream, or {@code null} if the required
@@ -54,7 +54,7 @@ public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
         sampleRate);
     if ((flags & 0x06) != 0x06) {
       // If the size in bytes or table of contents is missing, the stream is not seekable.
-      return new XingSeeker(inputLength, firstFramePosition, durationUs);
+      return new XingSeeker(firstFramePosition, durationUs, inputLength);
     }
 
     long sizeBytes = frame.readUnsignedIntToInt();
@@ -67,29 +67,32 @@ public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
     // TODO: Handle encoder delay and padding in 3 bytes offset by xingBase + 213 bytes:
     // delay = (frame.readUnsignedByte() << 4) + (frame.readUnsignedByte() >> 4);
     // padding = ((frame.readUnsignedByte() & 0x0F) << 8) + frame.readUnsignedByte();
-    return new XingSeeker(inputLength, firstFramePosition, durationUs, tableOfContents, sizeBytes);
+    return new XingSeeker(firstFramePosition, durationUs, inputLength, tableOfContents,
+        sizeBytes, mpegAudioHeader.frameSize);
   }
 
+  private final long firstFramePosition;
+  private final long durationUs;
+  private final long inputLength;
   /**
    * Entries are in the range [0, 255], but are stored as long integers for convenience.
    */
   private final long[] tableOfContents;
-  private final long firstFramePosition;
   private final long sizeBytes;
-  private final long durationUs;
-  private final long inputLength;
+  private final int headerSize;
 
-  private XingSeeker(long inputLength, long firstFramePosition, long durationUs) {
-    this(inputLength, firstFramePosition, durationUs, null, 0);
+  private XingSeeker(long firstFramePosition, long durationUs, long inputLength) {
+    this(firstFramePosition, durationUs, inputLength, null, 0, 0);
   }
 
-  private XingSeeker(long inputLength, long firstFramePosition, long durationUs,
-      long[] tableOfContents, long sizeBytes) {
-    this.tableOfContents = tableOfContents;
+  private XingSeeker(long firstFramePosition, long durationUs, long inputLength,
+      long[] tableOfContents, long sizeBytes, int headerSize) {
     this.firstFramePosition = firstFramePosition;
-    this.sizeBytes = sizeBytes;
     this.durationUs = durationUs;
     this.inputLength = inputLength;
+    this.tableOfContents = tableOfContents;
+    this.sizeBytes = sizeBytes;
+    this.headerSize = headerSize;
   }
 
   @Override
@@ -124,26 +127,26 @@ public long getPosition(long timeUs) {
       fx = fa + (fb - fa) * (percent - a);
     }
 
-    long position = (long) ((1.0 / 256) * fx * sizeBytes) + firstFramePosition;
-    return inputLength != C.LENGTH_UNBOUNDED ? Math.min(position, inputLength - 1) : position;
+    long position = Math.round((1.0 / 256) * fx * sizeBytes) + firstFramePosition;
+    long maximumPosition = inputLength != C.LENGTH_UNBOUNDED ? inputLength - 1
+        : firstFramePosition - headerSize + sizeBytes - 1;
+    return Math.min(position, maximumPosition);
   }
 
   @Override
   public long getTimeUs(long position) {
-    if (!isSeekable()) {
+    if (!isSeekable() || position < firstFramePosition) {
       return 0L;
     }
     double offsetByte = 256.0 * (position - firstFramePosition) / sizeBytes;
-    int previousIndex = Util.binarySearchFloor(tableOfContents, (long) offsetByte, true, false);
-    long previousTime = getTimeUsForTocIndex(previousIndex);
-    if (previousIndex == 98) {
-      return previousTime;
-    }
+    int previousTocPosition =
+        Util.binarySearchFloor(tableOfContents, (long) offsetByte, true, false) + 1;
+    long previousTime = getTimeUsForTocPosition(previousTocPosition);
 
     // Linearly interpolate the time taking into account the next entry.
-    long previousByte = previousIndex == -1 ? 0 : tableOfContents[previousIndex];
-    long nextByte = tableOfContents[previousIndex + 1];
-    long nextTime = getTimeUsForTocIndex(previousIndex + 1);
+    long previousByte = previousTocPosition == 0 ? 0 : tableOfContents[previousTocPosition - 1];
+    long nextByte = previousTocPosition == 99 ? 256 : tableOfContents[previousTocPosition];
+    long nextTime = getTimeUsForTocPosition(previousTocPosition + 1);
     long timeOffset = nextByte == previousByte ? 0 : (long) ((nextTime - previousTime)
         * (offsetByte - previousByte) / (nextByte - previousByte));
     return previousTime + timeOffset;
@@ -155,10 +158,11 @@ public long getDurationUs() {
   }
 
   /**
-   * Returns the time in microseconds corresponding to an index in the table of contents.
+   * Returns the time in microseconds corresponding to a table of contents position, which is
+   * interpreted as a percentage of the stream's duration between 0 and 100.
    */
-  private long getTimeUsForTocIndex(int tocIndex) {
-    return durationUs * (tocIndex + 1) / 100;
+  private long getTimeUsForTocPosition(int tocPosition) {
+    return durationUs * tocPosition / 100;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 23186e0d2a..ba281c5c24 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -110,6 +110,7 @@
   public static final int TYPE_stco = Util.getIntegerCodeForString("stco");
   public static final int TYPE_co64 = Util.getIntegerCodeForString("co64");
   public static final int TYPE_tx3g = Util.getIntegerCodeForString("tx3g");
+  public static final int TYPE_wvtt = Util.getIntegerCodeForString("wvtt");
   public static final int TYPE_stpp = Util.getIntegerCodeForString("stpp");
   public static final int TYPE_samr = Util.getIntegerCodeForString("samr");
   public static final int TYPE_sawb = Util.getIntegerCodeForString("sawb");
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 345afeebc9..5691d927d5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -262,6 +262,17 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     // implementation handles simple discarding/delaying of samples. The extractor may place
     // further restrictions on what edited streams are playable.
 
+    if (track.editListDurations.length == 1 && track.editListDurations[0] == 0) {
+      // The current version of the spec leaves handling of an edit with zero segment_duration in
+      // unfragmented files open to interpretation. We handle this as a special case and include all
+      // samples in the edit.
+      for (int i = 0; i < timestamps.length; i++) {
+        timestamps[i] = Util.scaleLargeTimestamp(timestamps[i] - track.editListMediaTimes[0],
+            C.MICROS_PER_SECOND, track.timescale);
+      }
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+    }
+
     // Count the number of samples after applying edits.
     int editedSampleCount = 0;
     int nextSampleIndex = 0;
@@ -462,6 +473,9 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
       } else if (childAtomType == Atom.TYPE_tx3g) {
         out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
             MimeTypes.APPLICATION_TX3G, MediaFormat.NO_VALUE, durationUs, language);
+      } else if (childAtomType == Atom.TYPE_wvtt) {
+        out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
+            MimeTypes.APPLICATION_MP4VTT, MediaFormat.NO_VALUE, durationUs, language);
       } else if (childAtomType == Atom.TYPE_stpp) {
         out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
             MimeTypes.APPLICATION_TTML, MediaFormat.NO_VALUE, durationUs, language,
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 56b20274e0..0e2cea9adb 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -232,16 +232,19 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       containerAtoms.add(new ContainerAtom(atomType, endPosition));
       enterReadingAtomHeaderState();
     } else if (shouldParseLeafAtom(atomType)) {
-      // We don't support parsing of leaf atoms that define extended atom sizes, or that have
-      // lengths greater than Integer.MAX_VALUE.
-      checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
-      checkState(atomSize <= Integer.MAX_VALUE);
+      if (atomHeaderBytesRead != Atom.HEADER_SIZE) {
+        throw new ParserException("Leaf atom defines extended atom size (unsupported).");
+      }
+      if (atomSize > Integer.MAX_VALUE) {
+        throw new ParserException("Leaf atom with length > 2147483647 (unsupported).");
+      }
       atomData = new ParsableByteArray((int) atomSize);
       System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
       parserState = STATE_READING_ATOM_PAYLOAD;
     } else {
-      // We don't support skipping of atoms that have lengths greater than Integer.MAX_VALUE.
-      checkState(atomSize <= Integer.MAX_VALUE);
+      if (atomSize > Integer.MAX_VALUE) {
+        throw new ParserException("Skipping atom with length > 2147483647 (unsupported).");
+      }
       atomData = null;
       parserState = STATE_READING_ATOM_PAYLOAD;
     }
@@ -308,7 +311,9 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
     extendsDefaults = parseTrex(mvex.getLeafAtomOfType(Atom.TYPE_trex).data);
     track = AtomParsers.parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak),
         moov.getLeafAtomOfType(Atom.TYPE_mvhd), false);
-    checkState(track != null);
+    if (track == null) {
+      throw new ParserException("Track type not supported.");
+    }
     trackOutput.format(track.mediaFormat);
   }
 
@@ -318,18 +323,6 @@ private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException
     sampleIndex = 0;
   }
 
-  private static void checkState(boolean expression) throws ParserException {
-    if (!expression) {
-      throw new ParserException();
-    }
-  }
-
-  private static void checkState(boolean expression, String errorMessage) throws ParserException {
-    if (!expression) {
-      throw new ParserException(errorMessage);
-    }
-  }
-
   /**
    * Parses a trex atom (defined in 14496-12).
    */
@@ -346,8 +339,9 @@ private static DefaultSampleValues parseTrex(ParsableByteArray trex) {
   private static void parseMoof(Track track, DefaultSampleValues extendsDefaults,
       ContainerAtom moof, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch)
       throws ParserException {
-    // This extractor only supports one traf per moof.
-    checkState(1 == moof.getChildAtomOfTypeCount(Atom.TYPE_traf));
+    if (moof.getChildAtomOfTypeCount(Atom.TYPE_traf) != 1) {
+      throw new ParserException("Traf count in moof != 1 (unsupported).");
+    }
     parseTraf(track, extendsDefaults, moof.getContainerAtomOfType(Atom.TYPE_traf),
         out, workaroundFlags, extendedTypeScratch);
   }
@@ -358,8 +352,9 @@ private static void parseMoof(Track track, DefaultSampleValues extendsDefaults,
   private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
       ContainerAtom traf, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch)
       throws ParserException {
-    // This extractor only supports one trun per traf.
-    checkState(1 == traf.getChildAtomOfTypeCount(Atom.TYPE_trun));
+    if (traf.getChildAtomOfTypeCount(Atom.TYPE_trun) != 1) {
+      throw new ParserException("Trun count in traf != 1 (unsupported).");
+    }
     LeafAtom tfdtAtom = traf.getLeafAtomOfType(Atom.TYPE_tfdt);
     long decodeTime;
     if (tfdtAtom == null || (workaroundFlags & WORKAROUND_IGNORE_TFDT_BOX) != 0) {
@@ -535,6 +530,17 @@ private static void parseTrun(Track track, DefaultSampleValues defaultSampleValu
     boolean sampleCompositionTimeOffsetsPresent =
         (flags & 0x800 /* sample_composition_time_offsets_present */) != 0;
 
+    // Offset to the entire video timeline. In the presence of B-frames this is usually used to
+    // ensure that the first frame's presentation timestamp is zero.
+    long edtsOffset = 0;
+
+    // Currently we only support a single edit that moves the entire media timeline (indicated by
+    // duration == 0). Other uses of edit lists are uncommon and unsupported.
+    if (track.editListDurations != null && track.editListDurations.length == 1
+        && track.editListDurations[0] == 0) {
+      edtsOffset = Util.scaleLargeTimestamp(track.editListMediaTimes[0], 1000, track.timescale);
+    }
+
     out.initTables(sampleCount);
     int[] sampleSizeTable = out.sampleSizeTable;
     int[] sampleCompositionTimeOffsetTable = out.sampleCompositionTimeOffsetTable;
@@ -563,7 +569,8 @@ private static void parseTrun(Track track, DefaultSampleValues defaultSampleValu
       } else {
         sampleCompositionTimeOffsetTable[i] = 0;
       }
-      sampleDecodingTimeTable[i] = Util.scaleLargeTimestamp(cumulativeTime, 1000, timescale);
+      sampleDecodingTimeTable[i] =
+          Util.scaleLargeTimestamp(cumulativeTime, 1000, timescale) - edtsOffset;
       sampleSizeTable[i] = sampleSize;
       sampleIsSyncFrameTable[i] = ((sampleFlags >> 16) & 0x1) == 0
           && (!workaroundEveryVideoFrameIsSyncFrame || i == 0);
@@ -653,7 +660,7 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       }
       long referenceDuration = atom.readUnsignedInt();
 
-      sizes[i] = 0x7fffffff & firstInt;
+      sizes[i] = 0x7FFFFFFF & firstInt;
       offsets[i] = offset;
 
       // Calculate time and duration values such that any rounding errors are consistent. i.e. That
@@ -672,7 +679,9 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
 
   private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
     int bytesToSkip = (int) (fragmentRun.auxiliaryDataPosition - input.getPosition());
-    checkState(bytesToSkip >= 0, "Offset to encryption data was negative.");
+    if (bytesToSkip < 0) {
+      throw new ParserException("Offset to encryption data was negative.");
+    }
     input.skipFully(bytesToSkip);
     fragmentRun.fillEncryptionData(input);
     parserState = STATE_READING_SAMPLE_START;
@@ -693,22 +702,26 @@ private void readEncryptionData(ExtractorInput input) throws IOException, Interr
    * @throws InterruptedException If the thread is interrupted.
    */
   private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
-    if (sampleIndex == 0) {
-      int bytesToSkip = (int) (fragmentRun.dataPosition - input.getPosition());
-      checkState(bytesToSkip >= 0, "Offset to sample data was negative.");
-      input.skipFully(bytesToSkip);
-    }
-
-    if (sampleIndex >= fragmentRun.length) {
-      int bytesToSkip = (int) (endOfMdatPosition - input.getPosition());
-      checkState(bytesToSkip >= 0, "Offset to end of mdat was negative.");
-      input.skipFully(bytesToSkip);
-      // We've run out of samples in the current mdat atom.
-      enterReadingAtomHeaderState();
-      return false;
-    }
-
     if (parserState == STATE_READING_SAMPLE_START) {
+      if (sampleIndex == fragmentRun.length) {
+        // We've run out of samples in the current mdat. Discard any trailing data and prepare to
+        // read the header of the next atom.
+        int bytesToSkip = (int) (endOfMdatPosition - input.getPosition());
+        if (bytesToSkip < 0) {
+          throw new ParserException("Offset to end of mdat was negative.");
+        }
+        input.skipFully(bytesToSkip);
+        enterReadingAtomHeaderState();
+        return false;
+      }
+      if (sampleIndex == 0) {
+        // We're reading the first sample in the current mdat. Discard any preceding data.
+        int bytesToSkip = (int) (fragmentRun.dataPosition - input.getPosition());
+        if (bytesToSkip < 0) {
+          throw new ParserException("Offset to sample data was negative.");
+        }
+        input.skipFully(bytesToSkip);
+      }
       sampleSize = fragmentRun.sampleSizeTable[sampleIndex];
       if (fragmentRun.definesEncryptionData) {
         sampleBytesWritten = appendSampleEncryptionData(fragmentRun.sampleEncryptionData);
@@ -801,14 +814,15 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_sidx || atom == Atom.TYPE_stsd || atom == Atom.TYPE_tfdt
         || atom == Atom.TYPE_tfhd || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_trex
         || atom == Atom.TYPE_trun || atom == Atom.TYPE_pssh || atom == Atom.TYPE_saiz
-        || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid;
+        || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid
+        || atom == Atom.TYPE_elst;
   }
 
   /** Returns whether the extractor should parse a container atom with type {@code atom}. */
   private static boolean shouldParseContainerAtom(int atom) {
     return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
         || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_moof
-        || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex;
+        || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex || atom == Atom.TYPE_edts;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
index 24b578b028..d83e9a1561 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
@@ -110,7 +110,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
 
   @Override
   public void init(ExtractorOutput output) {
-    adtsReader = new AdtsReader(output.track(0));
+    adtsReader = new AdtsReader(output.track(0), output.track(1));
     output.endTracks();
     output.seekMap(SeekMap.UNSEEKABLE);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index f4976e8ce0..c4578f363a 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -25,6 +25,7 @@
 
 import android.util.Pair;
 
+import java.util.Arrays;
 import java.util.Collections;
 
 /**
@@ -32,20 +33,34 @@
  */
 /* package */ final class AdtsReader extends ElementaryStreamReader {
 
-  private static final int STATE_FINDING_SYNC = 0;
-  private static final int STATE_READING_HEADER = 1;
-  private static final int STATE_READING_SAMPLE = 2;
+  private static final int STATE_FINDING_SAMPLE = 0;
+  private static final int STATE_READING_ID3_HEADER = 1;
+  private static final int STATE_READING_ADTS_HEADER = 2;
+  private static final int STATE_READING_SAMPLE = 3;
 
   private static final int HEADER_SIZE = 5;
   private static final int CRC_SIZE = 2;
 
+  // Match states used while looking for the next sample
+  private static final int MATCH_STATE_VALUE_SHIFT = 8;
+  private static final int MATCH_STATE_START = 1 << MATCH_STATE_VALUE_SHIFT;
+  private static final int MATCH_STATE_FF = 2 << MATCH_STATE_VALUE_SHIFT;
+  private static final int MATCH_STATE_I = 3 << MATCH_STATE_VALUE_SHIFT;
+  private static final int MATCH_STATE_ID = 4 << MATCH_STATE_VALUE_SHIFT;
+
+  private static final int ID3_HEADER_SIZE = 10;
+  private static final int ID3_SIZE_OFFSET = 6;
+  private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
+
   private final ParsableBitArray adtsScratch;
+  private final ParsableByteArray id3HeaderBuffer;
+  private final TrackOutput id3Output;
 
   private int state;
   private int bytesRead;
 
-  // Used to find the header.
-  private boolean lastByteWasFF;
+  private int matchState;
+
   private boolean hasCrc;
 
   // Used when parsing the header.
@@ -56,17 +71,25 @@
   // Used when reading the samples.
   private long timeUs;
 
-  public AdtsReader(TrackOutput output) {
+  private TrackOutput currentOutput;
+  private long currentSampleDuration;
+
+  /**
+   * @param output A {@link TrackOutput} to which AAC samples should be written.
+   * @param id3Output A {@link TrackOutput} to which ID3 samples should be written.
+   */
+  public AdtsReader(TrackOutput output, TrackOutput id3Output) {
     super(output);
+    this.id3Output = id3Output;
+    id3Output.format(MediaFormat.createId3Format());
     adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
-    state = STATE_FINDING_SYNC;
+    id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
+    setFindingSampleState();
   }
 
   @Override
   public void seek() {
-    state = STATE_FINDING_SYNC;
-    bytesRead = 0;
-    lastByteWasFF = false;
+    setFindingSampleState();
   }
 
   @Override
@@ -76,30 +99,22 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
     }
     while (data.bytesLeft() > 0) {
       switch (state) {
-        case STATE_FINDING_SYNC:
-          if (skipToNextSync(data)) {
-            bytesRead = 0;
-            state = STATE_READING_HEADER;
+        case STATE_FINDING_SAMPLE:
+          findNextSample(data);
+          break;
+        case STATE_READING_ID3_HEADER:
+          if (continueRead(data, id3HeaderBuffer.data, ID3_HEADER_SIZE)) {
+            parseId3Header();
           }
           break;
-        case STATE_READING_HEADER:
+        case STATE_READING_ADTS_HEADER:
           int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
           if (continueRead(data, adtsScratch.data, targetLength)) {
-            parseHeader();
-            bytesRead = 0;
-            state = STATE_READING_SAMPLE;
+            parseAdtsHeader();
           }
           break;
         case STATE_READING_SAMPLE:
-          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
-          output.sampleData(data, bytesToRead);
-          bytesRead += bytesToRead;
-          if (bytesRead == sampleSize) {
-            output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
-            timeUs += sampleDurationUs;
-            bytesRead = 0;
-            state = STATE_FINDING_SYNC;
-          }
+          readSample(data);
           break;
       }
     }
@@ -127,36 +142,109 @@ private boolean continueRead(ParsableByteArray source, byte[] target, int target
   }
 
   /**
-   * Locates the next sync word, advancing the position to the byte that immediately follows it.
-   * If a sync word was not located, the position is advanced to the limit.
+   * Sets the state to STATE_FINDING_SAMPLE.
+   */
+  private void setFindingSampleState() {
+    state = STATE_FINDING_SAMPLE;
+    bytesRead = 0;
+    matchState = MATCH_STATE_START;
+  }
+
+  /**
+   * Sets the state to STATE_READING_ID3_HEADER and resets the fields required for
+   * {@link #parseId3Header()}.
+   */
+  private void setReadingId3HeaderState() {
+    state = STATE_READING_ID3_HEADER;
+    bytesRead = ID3_IDENTIFIER.length;
+    sampleSize = 0;
+    id3HeaderBuffer.setPosition(0);
+  }
+
+  /**
+   * Sets the state to STATE_READING_SAMPLE.
+   *
+   * @param outputToUse TrackOutput object to write the sample to
+   * @param currentSampleDuration Duration of the sample to be read
+   * @param priorReadBytes Size of prior read bytes
+   * @param sampleSize Size of the sample
+   */
+  private void setReadingSampleState(TrackOutput outputToUse, long currentSampleDuration,
+      int priorReadBytes, int sampleSize) {
+    state = STATE_READING_SAMPLE;
+    bytesRead = priorReadBytes;
+    this.currentOutput = outputToUse;
+    this.currentSampleDuration = currentSampleDuration;
+    this.sampleSize = sampleSize;
+  }
+
+  /**
+   * Sets the state to STATE_READING_ADTS_HEADER.
+   */
+  private void setReadingAdtsHeaderState() {
+    state = STATE_READING_ADTS_HEADER;
+    bytesRead = 0;
+  }
+
+  /**
+   * Locates the next sample start, advancing the position to the byte that immediately follows
+   * identifier. If a sample was not located, the position is advanced to the limit.
    *
    * @param pesBuffer The buffer whose position should be advanced.
-   * @return True if a sync word position was found. False otherwise.
    */
-  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
+  private void findNextSample(ParsableByteArray pesBuffer) {
     byte[] adtsData = pesBuffer.data;
-    int startOffset = pesBuffer.getPosition();
+    int position = pesBuffer.getPosition();
     int endOffset = pesBuffer.limit();
-    for (int i = startOffset; i < endOffset; i++) {
-      boolean byteIsFF = (adtsData[i] & 0xFF) == 0xFF;
-      boolean found = lastByteWasFF && !byteIsFF && (adtsData[i] & 0xF0) == 0xF0;
-      lastByteWasFF = byteIsFF;
-      if (found) {
-        hasCrc = (adtsData[i] & 0x1) == 0;
-        pesBuffer.setPosition(i + 1);
-        // Reset lastByteWasFF for next time.
-        lastByteWasFF = false;
-        return true;
+    while (position < endOffset) {
+      int data = adtsData[position++] & 0xFF;
+      if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
+        hasCrc = (data & 0x1) == 0;
+        setReadingAdtsHeaderState();
+        pesBuffer.setPosition(position);
+        return;
+      }
+      switch (matchState | data) {
+        case MATCH_STATE_START | 0xFF:
+          matchState = MATCH_STATE_FF;
+          break;
+        case MATCH_STATE_START | 'I':
+          matchState = MATCH_STATE_I;
+          break;
+        case MATCH_STATE_I | 'D':
+          matchState = MATCH_STATE_ID;
+          break;
+        case MATCH_STATE_ID | '3':
+          setReadingId3HeaderState();
+          pesBuffer.setPosition(position);
+          return;
+        default:
+          if (matchState != MATCH_STATE_START) {
+            // If matching fails in a later state, revert to MATCH_STATE_START and
+            // check this byte again
+            matchState = MATCH_STATE_START;
+            position--;
+          }
+          break;
       }
     }
-    pesBuffer.setPosition(endOffset);
-    return false;
+    pesBuffer.setPosition(position);
+  }
+
+  /**
+   * Parses the Id3 header.
+   */
+  private void parseId3Header() {
+    id3Output.sampleData(id3HeaderBuffer, ID3_HEADER_SIZE);
+    id3HeaderBuffer.setPosition(ID3_SIZE_OFFSET);
+    setReadingSampleState(id3Output, 0, ID3_HEADER_SIZE,
+        id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);
   }
 
   /**
    * Parses the sample header.
    */
-  private void parseHeader() {
+  private void parseAdtsHeader() {
     adtsScratch.setPosition(0);
 
     if (!hasOutputFormat) {
@@ -183,10 +271,26 @@ private void parseHeader() {
     }
 
     adtsScratch.skipBits(4);
-    sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
+    int sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
     if (hasCrc) {
       sampleSize -= CRC_SIZE;
     }
+
+    setReadingSampleState(output, sampleDurationUs, 0, sampleSize);
+  }
+
+  /**
+   * Reads the rest of the sample
+   */
+  private void readSample(ParsableByteArray data) {
+    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+    currentOutput.sampleData(data, bytesToRead);
+    bytesRead += bytesToRead;
+    if (bytesRead == sampleSize) {
+      currentOutput.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
+      timeUs += currentSampleDuration;
+      setFindingSampleState();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java
new file mode 100644
index 0000000000..d363c0de8b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.DtsUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Parses a continuous DTS byte stream and extracts individual samples.
+ */
+/* package */ final class DtsReader extends ElementaryStreamReader {
+
+  private static final int STATE_FINDING_SYNC = 0;
+  private static final int STATE_READING_HEADER = 1;
+  private static final int STATE_READING_SAMPLE = 2;
+
+  private static final int HEADER_SIZE = 15;
+  private static final int SYNC_VALUE = 0x7FFE8001;
+  private static final int SYNC_VALUE_SIZE = 4;
+
+  private final ParsableByteArray headerScratchBytes;
+
+  private int state;
+  private int bytesRead;
+
+  // Used to find the header.
+  private int syncBytes;
+
+  // Used when parsing the header.
+  private long sampleDurationUs;
+  private MediaFormat mediaFormat;
+  private int sampleSize;
+
+  // Used when reading the samples.
+  private long timeUs;
+
+  /**
+   * Constructs a new reader for DTS elementary streams.
+   *
+   * @param output Track output for extracted samples.
+   */
+  public DtsReader(TrackOutput output) {
+    super(output);
+    headerScratchBytes = new ParsableByteArray(new byte[HEADER_SIZE]);
+    headerScratchBytes.data[0] = (byte) ((SYNC_VALUE >> 24) & 0xFF);
+    headerScratchBytes.data[1] = (byte) ((SYNC_VALUE >> 16) & 0xFF);
+    headerScratchBytes.data[2] = (byte) ((SYNC_VALUE >> 8) & 0xFF);
+    headerScratchBytes.data[3] = (byte) (SYNC_VALUE & 0xFF);
+    state = STATE_FINDING_SYNC;
+  }
+
+  @Override
+  public void seek() {
+    state = STATE_FINDING_SYNC;
+    bytesRead = 0;
+    syncBytes = 0;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    if (startOfPacket) {
+      timeUs = pesTimeUs;
+    }
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_SYNC:
+          if (skipToNextSync(data)) {
+            bytesRead = SYNC_VALUE_SIZE;
+            state = STATE_READING_HEADER;
+          }
+          break;
+        case STATE_READING_HEADER:
+          if (continueRead(data, headerScratchBytes.data, HEADER_SIZE)) {
+            parseHeader();
+            headerScratchBytes.setPosition(0);
+            output.sampleData(headerScratchBytes, HEADER_SIZE);
+            state = STATE_READING_SAMPLE;
+          }
+          break;
+        case STATE_READING_SAMPLE:
+          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+          output.sampleData(data, bytesToRead);
+          bytesRead += bytesToRead;
+          if (bytesRead == sampleSize) {
+            output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
+            timeUs += sampleDurationUs;
+            state = STATE_FINDING_SYNC;
+          }
+          break;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+   * that the data should be written into {@code target} starting from an offset of zero.
+   *
+   * @param source The source from which to read.
+   * @param target The target into which data is to be read.
+   * @param targetLength The target length of the read.
+   * @return Whether the target length was reached.
+   */
+  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+    source.readBytes(target, bytesRead, bytesToRead);
+    bytesRead += bytesToRead;
+    return bytesRead == targetLength;
+  }
+
+  /**
+   * Locates the next SYNC value in the buffer, advancing the position to the byte that immediately
+   * follows it. If SYNC was not located, the position is advanced to the limit.
+   *
+   * @param pesBuffer The buffer whose position should be advanced.
+   * @return True if SYNC was found. False otherwise.
+   */
+  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
+    while (pesBuffer.bytesLeft() > 0) {
+      syncBytes <<= 8;
+      syncBytes |= pesBuffer.readUnsignedByte();
+      if (syncBytes == SYNC_VALUE) {
+        syncBytes = 0;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Parses the sample header.
+   */
+  private void parseHeader() {
+    byte[] frameData = headerScratchBytes.data;
+    if (mediaFormat == null) {
+      mediaFormat = DtsUtil.parseDtsFormat(frameData, null, C.UNKNOWN_TIME_US, null);
+      output.format(mediaFormat);
+    }
+    sampleSize = DtsUtil.getDtsFrameSize(frameData);
+    // In this class a sample is an access unit (frame in DTS), but the MediaFormat sample rate
+    // specifies the number of PCM audio samples per second.
+    sampleDurationUs = (int) (C.MICROS_PER_SECOND
+        * DtsUtil.parseDtsAudioSampleCount(frameData) / mediaFormat.sampleRate);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
index 8e94411814..6b5935f042 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
@@ -22,6 +22,8 @@
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.Pair;
+
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -35,12 +37,18 @@
   private static final int START_EXTENSION = 0xB5;
   private static final int START_GROUP = 0xB8;
 
+  // Maps (frame_rate_code - 1) indices to values, as defined in ITU-T H.262 Table 6-4.
+  private static final double[] FRAME_RATE_VALUES = new double[] {
+      24000d / 1001, 24, 25, 30000d / 1001, 30, 50, 60000d / 1001, 60};
+
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
+  private long frameDurationUs;
 
   // State that should be reset on seek.
   private final boolean[] prefixFlags;
   private final CsdBuffer csdBuffer;
+  private boolean foundFirstFrameInPacket;
   private boolean foundFirstFrameInGroup;
   private long totalBytesWritten;
 
@@ -59,12 +67,16 @@ public H262Reader(TrackOutput output) {
   public void seek() {
     NalUnitUtil.clearPrefixFlags(prefixFlags);
     csdBuffer.reset();
+    foundFirstFrameInPacket = false;
     foundFirstFrameInGroup = false;
     totalBytesWritten = 0;
   }
 
   @Override
   public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    if (startOfPacket) {
+      foundFirstFrameInPacket = false;
+    }
     while (data.bytesLeft() > 0) {
       int offset = data.getPosition();
       int limit = data.limit();
@@ -101,7 +113,9 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
           int bytesAlreadyPassed = lengthToStartCode < 0 ? -lengthToStartCode : 0;
           if (csdBuffer.onStartCode(startCodeValue, bytesAlreadyPassed)) {
             // The csd data is complete, so we can parse and output the media format.
-            output.format(parseMediaFormat(csdBuffer));
+            Pair<MediaFormat, Long> result = parseCsdBuffer(csdBuffer);
+            output.format(result.first);
+            frameDurationUs = result.second;
             hasOutputFormat = true;
           }
         }
@@ -118,9 +132,10 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
             foundFirstFrameInGroup = false;
             isKeyframe = true;
           } else /* startCode == START_PICTURE */ {
-            foundFirstFrameInGroup = true;
-            frameTimeUs = pesTimeUs;
+            frameTimeUs = !foundFirstFrameInPacket ? pesTimeUs : (frameTimeUs + frameDurationUs);
             framePosition = totalBytesWritten - bytesWrittenPastStartCode;
+            foundFirstFrameInPacket = true;
+            foundFirstFrameInGroup = true;
           }
         }
 
@@ -135,7 +150,14 @@ public void packetFinished() {
     // Do nothing.
   }
 
-  private static MediaFormat parseMediaFormat(CsdBuffer csdBuffer) {
+  /**
+   * Parses the {@link MediaFormat} and frame duration from a csd buffer.
+   *
+   * @param csdBuffer The csd buffer.
+   * @return A pair consisting of the {@link MediaFormat} and the frame duration in microseconds, or
+   *     0 if the duration could not be determined.
+   */
+  private static Pair<MediaFormat, Long> parseCsdBuffer(CsdBuffer csdBuffer) {
     byte[] csdData = Arrays.copyOf(csdBuffer.data, csdBuffer.length);
 
     int firstByte = csdData[4] & 0xFF;
@@ -161,17 +183,32 @@ private static MediaFormat parseMediaFormat(CsdBuffer csdBuffer) {
         break;
     }
 
-    return MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_MPEG2, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, width, height, Collections.singletonList(csdData),
-        MediaFormat.NO_VALUE, pixelWidthHeightRatio);
+    MediaFormat format = MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_MPEG2,
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, width, height,
+        Collections.singletonList(csdData), MediaFormat.NO_VALUE, pixelWidthHeightRatio);
+
+    long frameDurationUs = 0;
+    int frameRateCodeMinusOne = (csdData[7] & 0x0F) - 1;
+    if (0 <= frameRateCodeMinusOne && frameRateCodeMinusOne < FRAME_RATE_VALUES.length) {
+      double frameRate = FRAME_RATE_VALUES[frameRateCodeMinusOne];
+      int sequenceExtensionPosition = csdBuffer.sequenceExtensionPosition;
+      int frameRateExtensionN = (csdData[sequenceExtensionPosition + 9] & 0x60) >> 5;
+      int frameRateExtensionD = (csdData[sequenceExtensionPosition + 9] & 0x1F);
+      if (frameRateExtensionN != frameRateExtensionD) {
+        frameRate *= (frameRateExtensionN + 1d) / (frameRateExtensionD + 1);
+      }
+      frameDurationUs = (long) (C.MICROS_PER_SECOND / frameRate);
+    }
+
+    return Pair.create(format, frameDurationUs);
   }
 
   private static final class CsdBuffer {
 
     private boolean isFilling;
-    private boolean seenExtensionStartCode;
 
     public int length;
+    public int sequenceExtensionPosition;
     public byte[] data;
 
     public CsdBuffer(int initialCapacity) {
@@ -183,8 +220,8 @@ public CsdBuffer(int initialCapacity) {
      */
     public void reset() {
       isFilling = false;
-      seenExtensionStartCode = false;
       length = 0;
+      sequenceExtensionPosition = 0;
     }
 
     /**
@@ -199,8 +236,8 @@ public void reset() {
      */
     public boolean onStartCode(int startCodeValue, int bytesAlreadyPassed) {
       if (isFilling) {
-        if (!seenExtensionStartCode && startCodeValue == START_EXTENSION) {
-          seenExtensionStartCode = true;
+        if (sequenceExtensionPosition == 0 && startCodeValue == START_EXTENSION) {
+          sequenceExtensionPosition = length;
         } else {
           length -= bytesAlreadyPassed;
           isFilling = false;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index c7ec2f7dc4..569ae6acc4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
@@ -35,8 +34,7 @@
 
   public Id3Reader(TrackOutput output) {
     super(output);
-    output.format(MediaFormat.createFormatForMimeType(null, MimeTypes.APPLICATION_ID3,
-        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US));
+    output.format(MediaFormat.createId3Format());
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java
index 25a92e2bce..c26f52bfc9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java
@@ -23,6 +23,12 @@
  */
 public final class PtsTimestampAdjuster {
 
+  /**
+   * A special {@code firstSampleTimestampUs} value indicating that presentation timestamps should
+   * not be offset.
+   */
+  public static final long DO_NOT_OFFSET = Long.MAX_VALUE;
+
   /**
    * The value one greater than the largest representable (33 bit) presentation timestamp.
    */
@@ -31,11 +37,14 @@
   private final long firstSampleTimestampUs;
 
   private long timestampOffsetUs;
-  private long lastPts;
+
+  // Volatile to allow isInitialized to be called on a different thread to adjustTimestamp.
+  private volatile long lastPts;
 
   /**
    * @param firstSampleTimestampUs The desired result of the first call to
-   *     {@link #adjustTimestamp(long)}.
+   *     {@link #adjustTimestamp(long)}, or {@link #DO_NOT_OFFSET} if presentation timestamps
+   *     should not be offset.
    */
   public PtsTimestampAdjuster(long firstSampleTimestampUs) {
     this.firstSampleTimestampUs = firstSampleTimestampUs;
@@ -57,9 +66,9 @@ public boolean isInitialized() {
   }
 
   /**
-   * Scales and adjusts an MPEG-2 TS presentation timestamp.
+   * Scales and offsets an MPEG-2 TS presentation timestamp.
    *
-   * @param pts The unscaled MPEG-2 TS presentation timestamp.
+   * @param pts The MPEG-2 TS presentation timestamp.
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustTimestamp(long pts) {
@@ -74,8 +83,8 @@ public long adjustTimestamp(long pts) {
     }
     // Calculate the corresponding timestamp.
     long timeUs = ptsToUs(pts);
-    // If we haven't done the initial timestamp adjustment, do it now.
-    if (lastPts == Long.MIN_VALUE) {
+    if (firstSampleTimestampUs != DO_NOT_OFFSET && lastPts == Long.MIN_VALUE) {
+      // Calculate the timestamp offset.
       timestampOffsetUs = firstSampleTimestampUs - timeUs;
     }
     // Record the adjusted PTS to adjust for wraparound next time.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 4dac4facae..bb8351ea5a 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.ts;
 
+import com.google.android.exoplayer.extractor.DummyTrackOutput;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
@@ -45,6 +46,8 @@
   private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
   private static final int TS_STREAM_TYPE_AAC = 0x0F;
   private static final int TS_STREAM_TYPE_AC3 = 0x81;
+  private static final int TS_STREAM_TYPE_DTS = 0x8A;
+  private static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
   private static final int TS_STREAM_TYPE_E_AC3 = 0x87;
   private static final int TS_STREAM_TYPE_H262 = 0x02;
   private static final int TS_STREAM_TYPE_H264 = 0x1B;
@@ -220,9 +223,14 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       int programCount = (sectionLength - 9) / 4;
       for (int i = 0; i < programCount; i++) {
         data.readBytes(patScratch, 4);
-        patScratch.skipBits(19); // program_number (16), reserved (3)
-        int pid = patScratch.readBits(13);
-        tsPayloadReaders.put(pid, new PmtReader());
+        int programNumber = patScratch.readBits(16);
+        patScratch.skipBits(3); // reserved (3)
+        if (programNumber == 0) {
+          patScratch.skipBits(13); // network_PID (13)
+        } else {
+          int pid = patScratch.readBits(13);
+          tsPayloadReaders.put(pid, new PmtReader());
+        }
       }
 
       // Skip CRC_32.
@@ -320,7 +328,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           continue;
         }
 
-        ElementaryStreamReader pesPayloadReader = null;
+        ElementaryStreamReader pesPayloadReader;
         switch (streamType) {
           case TS_STREAM_TYPE_MPA:
             pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA));
@@ -329,7 +337,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA_LSF));
             break;
           case TS_STREAM_TYPE_AAC:
-            pesPayloadReader = new AdtsReader(output.track(TS_STREAM_TYPE_AAC));
+            pesPayloadReader = new AdtsReader(output.track(TS_STREAM_TYPE_AAC),
+                new DummyTrackOutput());
             break;
           case TS_STREAM_TYPE_AC3:
             pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_AC3), false);
@@ -337,6 +346,10 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           case TS_STREAM_TYPE_E_AC3:
             pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_E_AC3), true);
             break;
+          case TS_STREAM_TYPE_DTS:
+          case TS_STREAM_TYPE_HDMV_DTS:
+            pesPayloadReader = new DtsReader(output.track(TS_STREAM_TYPE_DTS));
+            break;
           case TS_STREAM_TYPE_H262:
             pesPayloadReader = new H262Reader(output.track(TS_STREAM_TYPE_H262));
             break;
@@ -351,6 +364,9 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           case TS_STREAM_TYPE_ID3:
             pesPayloadReader = id3Reader;
             break;
+          default:
+            pesPayloadReader = null;
+            break;
         }
 
         if (pesPayloadReader != null) {
@@ -387,7 +403,14 @@ private int readPrivateDataStreamType(ParsableByteArray data, int length) {
             streamType = TS_STREAM_TYPE_H265;
           }
           break;
+        } else if (descriptorTag == 0x6A) { // AC-3_descriptor in DVB (ETSI EN 300 468)
+          streamType = TS_STREAM_TYPE_AC3;
+        } else if (descriptorTag == 0x7A) { // enhanced_AC-3_descriptor
+          streamType = TS_STREAM_TYPE_E_AC3;
+        } else if (descriptorTag == 0x7B) { // DTS_descriptor
+          streamType = TS_STREAM_TYPE_DTS;
         }
+
         data.skipBytes(descriptorLength);
       }
       data.setPosition(descriptorsEndPosition);
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java b/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java
new file mode 100644
index 0000000000..86dbc6f3fb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
+
+import android.content.Context;
+import android.text.TextUtils;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A default {@link HlsTrackSelector} implementation.
+ */
+public final class DefaultHlsTrackSelector implements HlsTrackSelector {
+
+  private static final int TYPE_DEFAULT = 0;
+  private static final int TYPE_VTT = 1;
+
+  private final Context context;
+  private final int type;
+
+  /**
+   * Creates a {@link DefaultHlsTrackSelector} that selects the streams defined in the playlist.
+   *
+   * @param context A context.
+   * @return The selector instance.
+   */
+  public static DefaultHlsTrackSelector newDefaultInstance(Context context) {
+    return new DefaultHlsTrackSelector(context, TYPE_DEFAULT);
+  }
+
+  /**
+   * Creates a {@link DefaultHlsTrackSelector} that selects subtitle renditions.
+   *
+   * @return The selector instance.
+   */
+  public static DefaultHlsTrackSelector newVttInstance() {
+    return new DefaultHlsTrackSelector(null, TYPE_VTT);
+  }
+
+  private DefaultHlsTrackSelector(Context context, int type) {
+    this.context = context;
+    this.type = type;
+  }
+
+  @Override
+  public void selectTracks(HlsMasterPlaylist playlist, Output output) throws IOException {
+    if (type == TYPE_VTT) {
+      List<Variant> subtitleVariants = playlist.subtitles;
+      if (subtitleVariants != null && !subtitleVariants.isEmpty()) {
+        for (int i = 0; i < subtitleVariants.size(); i++) {
+          output.fixedTrack(playlist, subtitleVariants.get(i));
+        }
+      }
+      return;
+    }
+
+    // Type is TYPE_DEFAULT.
+
+    ArrayList<Variant> enabledVariantList = new ArrayList<>();
+    int[] variantIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
+        context, playlist.variants, null, false);
+    for (int i = 0; i < variantIndices.length; i++) {
+      enabledVariantList.add(playlist.variants.get(variantIndices[i]));
+    }
+
+    ArrayList<Variant> definiteVideoVariants = new ArrayList<>();
+    ArrayList<Variant> definiteAudioOnlyVariants = new ArrayList<>();
+    for (int i = 0; i < enabledVariantList.size(); i++) {
+      Variant variant = enabledVariantList.get(i);
+      if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
+        definiteVideoVariants.add(variant);
+      } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
+        definiteAudioOnlyVariants.add(variant);
+      }
+    }
+
+    if (!definiteVideoVariants.isEmpty()) {
+      // We've identified some variants as definitely containing video. Assume variants within the
+      // master playlist are marked consistently, and hence that we have the full set. Filter out
+      // any other variants, which are likely to be audio only.
+      enabledVariantList = definiteVideoVariants;
+    } else if (definiteAudioOnlyVariants.size() < enabledVariantList.size()) {
+      // We've identified some variants, but not all, as being audio only. Filter them out to leave
+      // the remaining variants, which are likely to contain video.
+      enabledVariantList.removeAll(definiteAudioOnlyVariants);
+    } else {
+      // Leave the enabled variants unchanged. They're likely either all video or all audio.
+    }
+
+    if (enabledVariantList.size() > 1) {
+      Variant[] enabledVariants = new Variant[enabledVariantList.size()];
+      enabledVariantList.toArray(enabledVariants);
+      output.adaptiveTrack(playlist, enabledVariants);
+    }
+    for (int i = 0; i < enabledVariantList.size(); i++) {
+      output.fixedTrack(playlist, enabledVariantList.get(i));
+    }
+  }
+
+  private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String prefix) {
+    String codecs = variant.format.codecs;
+    if (TextUtils.isEmpty(codecs)) {
+      return false;
+    }
+    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
+    for (int i = 0; i < codecArray.length; i++) {
+      if (codecArray[i].startsWith(prefix)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 9e305d5969..803f8fbd79 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -39,7 +39,6 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
-import android.text.TextUtils;
 import android.util.Log;
 
 import java.io.ByteArrayInputStream;
@@ -47,17 +46,15 @@
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 
 /**
  * A temporary test source of HLS chunks.
- * <p>
- * TODO: Figure out whether this should merge with the chunk package, or whether the hls
- * implementation is going to naturally diverge.
  */
-public class HlsChunkSource {
+public class HlsChunkSource implements HlsTrackSelector.Output {
 
   /**
    * Interface definition for a callback to be notified of {@link HlsChunkSource} events.
@@ -118,54 +115,85 @@
   private static final String TAG = "HlsChunkSource";
   private static final String AAC_FILE_EXTENSION = ".aac";
   private static final String MP3_FILE_EXTENSION = ".mp3";
+  private static final String VTT_FILE_EXTENSION = ".vtt";
+  private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
   private static final float BANDWIDTH_FRACTION = 0.8f;
 
+  private final boolean isMaster;
   private final DataSource dataSource;
   private final HlsPlaylistParser playlistParser;
+  private final HlsMasterPlaylist masterPlaylist;
+  private final HlsTrackSelector trackSelector;
   private final BandwidthMeter bandwidthMeter;
+  private final PtsTimestampAdjusterProvider timestampAdjusterProvider;
   private final int adaptiveMode;
   private final String baseUri;
-  private final int adaptiveMaxWidth;
-  private final int adaptiveMaxHeight;
   private final long minBufferDurationToSwitchUpUs;
   private final long maxBufferDurationToSwitchDownUs;
 
+  // TODO: Expose tracks.
+  private final ArrayList<ExposedTrack> tracks;
+
+  private int selectedTrackIndex;
+
   // A list of variants considered during playback, ordered by decreasing bandwidth. The following
   // three arrays are of the same length and are ordered in the same way (i.e. variantPlaylists[i],
   // variantLastPlaylistLoadTimesMs[i] and variantBlacklistTimes[i] all correspond to variants[i]).
-  private final Variant[] variants;
-  private final HlsMediaPlaylist[] variantPlaylists;
-  private final long[] variantLastPlaylistLoadTimesMs;
-  private final long[] variantBlacklistTimes;
+  private Variant[] variants;
+  private HlsMediaPlaylist[] variantPlaylists;
+  private long[] variantLastPlaylistLoadTimesMs;
+  private long[] variantBlacklistTimes;
 
   // The index in variants of the currently selected variant.
   private int selectedVariantIndex;
 
+  private boolean prepareCalled;
   private byte[] scratchSpace;
   private boolean live;
   private long durationUs;
   private IOException fatalError;
-  private PtsTimestampAdjuster ptsTimestampAdjuster;
 
   private Uri encryptionKeyUri;
   private byte[] encryptionKey;
   private String encryptionIvString;
   private byte[] encryptionIv;
 
-  public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist playlist,
-      BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode) {
-    this(dataSource, playlistUrl, playlist, bandwidthMeter, variantIndices, adaptiveMode,
-        DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS, DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS);
+  /**
+   * @param isMaster True if this is the master source for the playback. False otherwise. Each
+   *     playback must have exactly one master source, which should be the source providing video
+   *     chunks (or audio chunks for audio only playbacks).
+   * @param dataSource A {@link DataSource} suitable for loading the media data.
+   * @param playlistUrl The playlist URL.
+   * @param playlist The hls playlist.
+   * @param trackSelector Selects tracks to be exposed by this source.
+   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+   * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
+   *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
+   *     same provider.
+   * @param adaptiveMode The mode for switching from one variant to another. One of
+   *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
+   *     {@link #ADAPTIVE_MODE_SPLICE}.
+   */
+  public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUrl,
+      HlsPlaylist playlist, HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
+      PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode) {
+    this(isMaster, dataSource, playlistUrl, playlist, trackSelector, bandwidthMeter,
+        timestampAdjusterProvider, adaptiveMode, DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS,
+        DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS);
   }
 
   /**
+   * @param isMaster True if this is the master source for the playback. False otherwise. Each
+   *     playback must have exactly one master source, which should be the source providing video
+   *     chunks (or audio chunks for audio only playbacks).
    * @param dataSource A {@link DataSource} suitable for loading the media data.
    * @param playlistUrl The playlist URL.
    * @param playlist The hls playlist.
-   * @param bandwidthMeter provides an estimate of the currently available bandwidth.
-   * @param variantIndices If {@code playlist} is a {@link HlsMasterPlaylist}, the subset of variant
-   *     indices to consider, or null to consider all of the variants. For other playlist types
-   *     this parameter is ignored.
+   * @param trackSelector Selects tracks to be exposed by this source.
+   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+   * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
+   *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
+   *     same provider.
    * @param adaptiveMode The mode for switching from one variant to another. One of
    *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
    *     {@link #ADAPTIVE_MODE_SPLICE}.
@@ -174,65 +202,34 @@ public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist pla
    * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
    *     for a switch to a lower quality variant to be considered.
    */
-  public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist playlist,
-      BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode,
+  public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUrl,
+      HlsPlaylist playlist, HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
+      PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode,
       long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs) {
+    this.isMaster = isMaster;
     this.dataSource = dataSource;
+    this.trackSelector = trackSelector;
     this.bandwidthMeter = bandwidthMeter;
+    this.timestampAdjusterProvider = timestampAdjusterProvider;
     this.adaptiveMode = adaptiveMode;
     minBufferDurationToSwitchUpUs = minBufferDurationToSwitchUpMs * 1000;
     maxBufferDurationToSwitchDownUs = maxBufferDurationToSwitchDownMs * 1000;
     baseUri = playlist.baseUri;
     playlistParser = new HlsPlaylistParser();
+    tracks = new ArrayList<>();
 
-    if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
+    if (playlist.type == HlsPlaylist.TYPE_MASTER) {
+      masterPlaylist = (HlsMasterPlaylist) playlist;
+    } else {
       Format format = new Format("0", MimeTypes.APPLICATION_M3U8, -1, -1, -1, -1, -1, -1, null,
           null);
-      variants = new Variant[] {new Variant(playlistUrl, format)};
-      variantPlaylists = new HlsMediaPlaylist[1];
-      variantLastPlaylistLoadTimesMs = new long[1];
-      variantBlacklistTimes = new long[1];
-      setMediaPlaylist(0, (HlsMediaPlaylist) playlist);
-      // We won't be adapting between different variants.
-      adaptiveMaxWidth = MediaFormat.NO_VALUE;
-      adaptiveMaxHeight = MediaFormat.NO_VALUE;
-    } else {
-      List<Variant> masterPlaylistVariants = ((HlsMasterPlaylist) playlist).variants;
-      variants = buildOrderedVariants(masterPlaylistVariants, variantIndices);
-      variantPlaylists = new HlsMediaPlaylist[variants.length];
-      variantLastPlaylistLoadTimesMs = new long[variants.length];
-      variantBlacklistTimes = new long[variants.length];
-      int maxWidth = -1;
-      int maxHeight = -1;
-      // Select the variant that comes first in their original order in the master playlist.
-      int minOriginalVariantIndex = Integer.MAX_VALUE;
-      for (int i = 0; i < variants.length; i++) {
-        int originalVariantIndex = masterPlaylistVariants.indexOf(variants[i]);
-        if (originalVariantIndex < minOriginalVariantIndex) {
-          minOriginalVariantIndex = originalVariantIndex;
-          selectedVariantIndex = i;
-        }
-        Format variantFormat = variants[i].format;
-        maxWidth = Math.max(variantFormat.width, maxWidth);
-        maxHeight = Math.max(variantFormat.height, maxHeight);
-      }
-      if (variants.length <= 1 || adaptiveMode == ADAPTIVE_MODE_NONE) {
-        // We won't be adapting between different variants.
-        this.adaptiveMaxWidth = MediaFormat.NO_VALUE;
-        this.adaptiveMaxHeight = MediaFormat.NO_VALUE;
-      } else {
-        // We will be adapting between different variants.
-        // TODO: We should allow the default values to be passed through the constructor.
-        this.adaptiveMaxWidth = maxWidth > 0 ? maxWidth : 1920;
-        this.adaptiveMaxHeight = maxHeight > 0 ? maxHeight : 1080;
-      }
+      List<Variant> variants = new ArrayList<>();
+      variants.add(new Variant(playlistUrl, format));
+      masterPlaylist = new HlsMasterPlaylist(playlistUrl, variants,
+          Collections.<Variant>emptyList());
     }
   }
 
-  public long getDurationUs() {
-    return durationUs;
-  }
-
   /**
    * If the source is currently having difficulty providing chunks, then this method throws the
    * underlying error. Otherwise does nothing.
@@ -245,6 +242,120 @@ public void maybeThrowError() throws IOException {
     }
   }
 
+  /**
+   * Prepares the source.
+   *
+   * @return True if the source was prepared, false otherwise.
+   */
+  public boolean prepare() {
+    if (!prepareCalled) {
+      prepareCalled = true;
+      try {
+        trackSelector.selectTracks(masterPlaylist, this);
+        selectTrack(0);
+      } catch (IOException e) {
+        fatalError = e;
+      }
+    }
+    return fatalError == null;
+  }
+
+  /**
+   * Returns whether this is a live playback.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   *
+   * @return True if this is a live playback. False otherwise.
+   */
+  public boolean isLive() {
+    return live;
+  }
+
+  /**
+   * Returns the duration of the source, or {@link C#UNKNOWN_TIME_US} if the duration is unknown.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   *
+   * @return The number of tracks.
+   */
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Returns the number of tracks exposed by the source.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   *
+   * @return The number of tracks.
+   */
+  public int getTrackCount() {
+    return tracks.size();
+  }
+
+  /**
+   * Returns the variant corresponding to the fixed track at the specified index, or null if the
+   * track at the specified index is adaptive.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   *
+   * @param index The track index.
+   * @return The variant corresponding to the fixed track, or null if the track is adaptive.
+   */
+  public Variant getFixedTrackVariant(int index) {
+    Variant[] variants = tracks.get(index).variants;
+    return variants.length == 1 ? variants[0] : null;
+  }
+
+
+  /**
+   * Returns the currently selected track index.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   *
+   * @return The currently selected track index.
+   */
+  public int getSelectedTrackIndex() {
+    return selectedTrackIndex;
+  }
+
+  /**
+   * Selects a track for use.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   *
+   * @param index The track index.
+   */
+  public void selectTrack(int index) {
+    selectedTrackIndex = index;
+    ExposedTrack selectedTrack = tracks.get(selectedTrackIndex);
+    selectedVariantIndex = selectedTrack.defaultVariantIndex;
+    variants = selectedTrack.variants;
+    variantPlaylists = new HlsMediaPlaylist[variants.length];
+    variantLastPlaylistLoadTimesMs = new long[variants.length];
+    variantBlacklistTimes = new long[variants.length];
+  }
+
+  /**
+   * Notifies the source that a seek has occurred.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   */
+  public void seek() {
+    if (isMaster) {
+      timestampAdjusterProvider.reset();
+    }
+  }
+
+  /**
+   * Resets the source.
+   * <p>
+   * This method should only be called after the source has been prepared.
+   */
+  public void reset() {
+    fatalError = null;
+  }
+
   /**
    * Updates the provided {@link ChunkOperationHolder} to contain the next operation that should
    * be performed by the calling {@link HlsSampleSource}.
@@ -279,7 +390,6 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
 
     selectedVariantIndex = nextVariantIndex;
     int chunkMediaSequence = 0;
-    boolean liveDiscontinuity = false;
     if (live) {
       if (previousTsChunk == null) {
         chunkMediaSequence = getLiveStartChunkMediaSequence(nextVariantIndex);
@@ -353,28 +463,45 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
 
     // Configure the extractor that will read the chunk.
     HlsExtractorWrapper extractorWrapper;
-    if (chunkUri.getLastPathSegment().endsWith(AAC_FILE_EXTENSION)) {
+    String lastPathSegment = chunkUri.getLastPathSegment();
+    if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
+      // TODO: Inject a timestamp adjuster and use it along with ID3 PRIV tag values with owner
+      // identifier com.apple.streaming.transportStreamTimestamp. This may also apply to the MP3
+      // case below.
       Extractor extractor = new AdtsExtractor(startTimeUs);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, adaptiveMaxWidth, adaptiveMaxHeight);
-    } else if (chunkUri.getLastPathSegment().endsWith(MP3_FILE_EXTENSION)) {
+          switchingVariantSpliced, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+    } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
       Extractor extractor = new Mp3Extractor(startTimeUs);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, adaptiveMaxWidth, adaptiveMaxHeight);
-    } else if (previousTsChunk == null || liveDiscontinuity
+          switchingVariantSpliced, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+    } else if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
+        || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
+      PtsTimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(isMaster,
+          segment.discontinuitySequenceNumber, startTimeUs);
+      if (timestampAdjuster == null) {
+        // The master source has yet to instantiate an adjuster for the discontinuity sequence.
+        // TODO: There's probably an edge case if the master starts playback at a chunk belonging to
+        // a discontinuity sequence greater than the one that this source is trying to start at.
+        return;
+      }
+      Extractor extractor = new WebvttExtractor(timestampAdjuster);
+      extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
+          switchingVariantSpliced, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+    } else if (previousTsChunk == null
         || previousTsChunk.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
         || !format.equals(previousTsChunk.format)) {
       // MPEG-2 TS segments, but we need a new extractor.
-      if (previousTsChunk == null || liveDiscontinuity
-          || previousTsChunk.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
-          || ptsTimestampAdjuster == null) {
-        // TODO: Use this for AAC as well, along with the ID3 PRIV priv tag values with owner
-        // identifier com.apple.streaming.transportStreamTimestamp.
-        ptsTimestampAdjuster = new PtsTimestampAdjuster(startTimeUs);
+      PtsTimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(isMaster,
+          segment.discontinuitySequenceNumber, startTimeUs);
+      if (timestampAdjuster == null) {
+        // The master source has yet to instantiate an adjuster for the discontinuity sequence.
+        return;
       }
-      Extractor extractor = new TsExtractor(ptsTimestampAdjuster);
+      ExposedTrack selectedTrack = tracks.get(selectedTrackIndex);
+      Extractor extractor = new TsExtractor(timestampAdjuster);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
-          switchingVariantSpliced, adaptiveMaxWidth, adaptiveMaxHeight);
+          switchingVariantSpliced, selectedTrack.adaptiveMaxWidth, selectedTrack.adaptiveMaxHeight);
     } else {
       // MPEG-2 TS segments, and we need to continue using the same extractor.
       extractorWrapper = previousTsChunk.extractorWrapper;
@@ -455,10 +582,48 @@ public boolean onChunkLoadError(Chunk chunk, IOException e) {
     return false;
   }
 
-  public void reset() {
-    fatalError = null;
+  // HlsTrackSelector.Output implementation.
+
+  @Override
+  public void adaptiveTrack(HlsMasterPlaylist playlist, Variant[] variants) {
+    Arrays.sort(variants, new Comparator<Variant>() {
+      private final Comparator<Format> formatComparator =
+          new Format.DecreasingBandwidthComparator();
+      @Override
+      public int compare(Variant first, Variant second) {
+        return formatComparator.compare(first.format, second.format);
+      }
+    });
+
+    int defaultVariantIndex = 0;
+    int maxWidth = -1;
+    int maxHeight = -1;
+
+    int minOriginalVariantIndex = Integer.MAX_VALUE;
+    for (int i = 0; i < variants.length; i++) {
+      int originalVariantIndex = playlist.variants.indexOf(variants[i]);
+      if (originalVariantIndex < minOriginalVariantIndex) {
+        minOriginalVariantIndex = originalVariantIndex;
+        defaultVariantIndex = i;
+      }
+      Format variantFormat = variants[i].format;
+      maxWidth = Math.max(variantFormat.width, maxWidth);
+      maxHeight = Math.max(variantFormat.height, maxHeight);
+    }
+    // TODO: We should allow the default values to be passed through the constructor.
+    // TODO: Print a warning if resolution tags are omitted.
+    maxWidth = maxWidth > 0 ? maxWidth : 1920;
+    maxHeight = maxHeight > 0 ? maxHeight : 1080;
+    tracks.add(new ExposedTrack(variants, defaultVariantIndex, maxWidth, maxHeight));
+  }
+
+  @Override
+  public void fixedTrack(HlsMasterPlaylist playlist, Variant variant) {
+    tracks.add(new ExposedTrack(variant));
   }
 
+  // Private methods.
+
   private int getNextVariantIndex(TsChunk previousTsChunk, long playbackPositionUs) {
     clearStaleBlacklistedVariants();
     long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
@@ -576,78 +741,6 @@ private void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist)
     durationUs = live ? C.UNKNOWN_TIME_US : mediaPlaylist.durationUs;
   }
 
-  /**
-   * Selects a list of variants to use, returning them in order of decreasing bandwidth.
-   *
-   * @param originalVariants The original list of variants.
-   * @param originalVariantIndices Indices of variants that in the original list that can be
-   *     considered, or null to allow all variants to be considered.
-   * @return The set of enabled variants in decreasing bandwidth order.
-   */
-  private static Variant[] buildOrderedVariants(List<Variant> originalVariants,
-      int[] originalVariantIndices) {
-    ArrayList<Variant> enabledVariantList = new ArrayList<>();
-    if (originalVariantIndices != null) {
-      for (int i = 0; i < originalVariantIndices.length; i++) {
-        enabledVariantList.add(originalVariants.get(originalVariantIndices[i]));
-      }
-    } else {
-      // If variantIndices is null then all variants are initially considered.
-      enabledVariantList.addAll(originalVariants);
-    }
-
-    ArrayList<Variant> definiteVideoVariants = new ArrayList<>();
-    ArrayList<Variant> definiteAudioOnlyVariants = new ArrayList<>();
-    for (int i = 0; i < enabledVariantList.size(); i++) {
-      Variant variant = enabledVariantList.get(i);
-      if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
-        definiteVideoVariants.add(variant);
-      } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
-        definiteAudioOnlyVariants.add(variant);
-      }
-    }
-
-    if (!definiteVideoVariants.isEmpty()) {
-      // We've identified some variants as definitely containing video. Assume variants within the
-      // master playlist are marked consistently, and hence that we have the full set. Filter out
-      // any other variants, which are likely to be audio only.
-      enabledVariantList = definiteVideoVariants;
-    } else if (definiteAudioOnlyVariants.size() < enabledVariantList.size()) {
-      // We've identified some variants, but not all, as being audio only. Filter them out to leave
-      // the remaining variants, which are likely to contain video.
-      enabledVariantList.removeAll(definiteAudioOnlyVariants);
-    } else {
-      // Leave the enabled variants unchanged. They're likely either all video or all audio.
-    }
-
-    Variant[] enabledVariants = new Variant[enabledVariantList.size()];
-    enabledVariantList.toArray(enabledVariants);
-    Arrays.sort(enabledVariants, new Comparator<Variant>() {
-      private final Comparator<Format> formatComparator =
-          new Format.DecreasingBandwidthComparator();
-      @Override
-      public int compare(Variant first, Variant second) {
-        return formatComparator.compare(first.format, second.format);
-      }
-    });
-
-    return enabledVariants;
-  }
-
-  private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String prefix) {
-    String codecs = variant.format.codecs;
-    if (TextUtils.isEmpty(codecs)) {
-      return false;
-    }
-    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
-    for (int i = 0; i < codecArray.length; i++) {
-      if (codecArray[i].startsWith(prefix)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   private boolean allVariantsBlacklisted() {
     for (int i = 0; i < variantBlacklistTimes.length; i++) {
       if (variantBlacklistTimes[i] == 0) {
@@ -677,7 +770,34 @@ private int getVariantIndex(Format format) {
     throw new IllegalStateException("Invalid format: " + format);
   }
 
-  private static class MediaPlaylistChunk extends DataChunk {
+  // Private classes.
+
+  private static final class ExposedTrack {
+
+    private final Variant[] variants;
+    private final int defaultVariantIndex;
+
+    private final int adaptiveMaxWidth;
+    private final int adaptiveMaxHeight;
+
+    public ExposedTrack(Variant fixedVariant) {
+      this.variants = new Variant[] {fixedVariant};
+      this.defaultVariantIndex = 0;
+      this.adaptiveMaxWidth = MediaFormat.NO_VALUE;
+      this.adaptiveMaxHeight = MediaFormat.NO_VALUE;
+    }
+
+    public ExposedTrack(Variant[] adaptiveVariants, int defaultVariantIndex, int maxWidth,
+        int maxHeight) {
+      this.variants = adaptiveVariants;
+      this.defaultVariantIndex = defaultVariantIndex;
+      this.adaptiveMaxWidth = maxWidth;
+      this.adaptiveMaxHeight = maxHeight;
+    }
+
+  }
+
+  private static final class MediaPlaylistChunk extends DataChunk {
 
     public final int variantIndex;
 
@@ -707,7 +827,7 @@ public HlsMediaPlaylist getResult() {
 
   }
 
-  private static class EncryptionKeyChunk extends DataChunk {
+  private static final class EncryptionKeyChunk extends DataChunk {
 
     public final String iv;
     public final int variantIndex;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index 75929fc7c3..432229fb28 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -158,8 +158,8 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           String subtitleName = HlsParserUtil.parseStringAttr(line, NAME_ATTR_REGEX, NAME_ATTR);
           String uri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX, URI_ATTR);
           String language = HlsParserUtil.parseOptionalStringAttr(line, LANGUAGE_ATTR_REGEX);
-          Format format = new Format(subtitleName, MimeTypes.TEXT_VTT, -1, -1, -1, -1, -1, -1,
-              language, codecs);
+          Format format = new Format(subtitleName, MimeTypes.APPLICATION_M3U8, -1, -1, -1, -1, -1,
+              -1, language, codecs);
           subtitles.add(new Variant(uri, format));
         } else {
           // TODO: Support other types of media tag.
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index f29eb095c4..63b0740418 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -36,6 +36,7 @@
 import android.os.SystemClock;
 
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.LinkedList;
 
 /**
@@ -55,6 +56,11 @@
 
   private static final long NO_RESET_PENDING = Long.MIN_VALUE;
 
+  private static final int PRIMARY_TYPE_NONE = 0;
+  private static final int PRIMARY_TYPE_TEXT = 1;
+  private static final int PRIMARY_TYPE_AUDIO = 2;
+  private static final int PRIMARY_TYPE_VIDEO = 3;
+
   private final HlsChunkSource chunkSource;
   private final LinkedList<HlsExtractorWrapper> extractors;
   private final int minLoadableRetryCount;
@@ -71,11 +77,22 @@
   private boolean loadControlRegistered;
   private int trackCount;
   private int enabledTrackCount;
+
+  private Format downstreamFormat;
+
+  // Tracks are complicated in HLS. See documentation of buildTracks for details.
+  // Indexed by track (as exposed by this source).
+  private MediaFormat[] trackFormats;
   private boolean[] trackEnabledStates;
   private boolean[] pendingDiscontinuities;
-  private MediaFormat[] trackFormat;
   private MediaFormat[] downstreamMediaFormats;
-  private Format downstreamFormat;
+  // Maps track index (as exposed by this source) to the corresponding chunk source track index for
+  // primary tracks, or to -1 otherwise.
+  private int[] chunkSourceTrackIndices;
+  // Maps track index (as exposed by this source) to the corresponding extractor track index.
+  private int[] extractorTrackIndices;
+  // Indexed by extractor track index.
+  private boolean[] extractorTrackEnabledStates;
 
   private long downstreamPositionUs;
   private long lastSeekPositionUs;
@@ -129,26 +146,17 @@ public SampleSourceReader register() {
   public boolean prepare(long positionUs) {
     if (prepared) {
       return true;
+    } else if (!chunkSource.prepare()) {
+      return false;
     }
     if (!extractors.isEmpty()) {
       while (true) {
         // We're not prepared, but we might have loaded what we need.
         HlsExtractorWrapper extractor = extractors.getFirst();
         if (extractor.isPrepared()) {
-          trackCount = extractor.getTrackCount();
-          trackEnabledStates = new boolean[trackCount];
-          pendingDiscontinuities = new boolean[trackCount];
-          downstreamMediaFormats = new MediaFormat[trackCount];
-          trackFormat = new MediaFormat[trackCount];
-          long durationUs = chunkSource.getDurationUs();
-          for (int i = 0; i < trackCount; i++) {
-            MediaFormat format = extractor.getMediaFormat(i).copyWithDurationUs(durationUs);
-            if (MimeTypes.isVideo(format.mimeType)) {
-              format = format.copyAsAdaptive(null);
-            }
-            trackFormat[i] = format;
-          }
+          buildTracks(extractor);
           prepared = true;
+          maybeStartLoading(); // Update the load control.
           return true;
         } else if (extractors.size() > 1) {
           extractors.removeFirst().clear();
@@ -160,8 +168,6 @@ public boolean prepare(long positionUs) {
     // We're not prepared and we haven't loaded what we need.
     if (loader == null) {
       loader = new Loader("Loader:HLS");
-    }
-    if (!loadControlRegistered) {
       loadControl.register(this, bufferSizeContribution);
       loadControlRegistered = true;
     }
@@ -185,15 +191,13 @@ public int getTrackCount() {
   @Override
   public MediaFormat getFormat(int track) {
     Assertions.checkState(prepared);
-    return trackFormat[track];
+    return trackFormats[track];
   }
 
   @Override
   public void enable(int track, long positionUs) {
     Assertions.checkState(prepared);
-    Assertions.checkState(!trackEnabledStates[track]);
-    enabledTrackCount++;
-    trackEnabledStates[track] = true;
+    setTrackEnabledState(track, true);
     downstreamMediaFormats[track] = null;
     pendingDiscontinuities[track] = false;
     downstreamFormat = null;
@@ -202,6 +206,18 @@ public void enable(int track, long positionUs) {
       loadControl.register(this, bufferSizeContribution);
       loadControlRegistered = true;
     }
+    // Treat enabling of a live stream as occurring at t=0 in both of the blocks below.
+    positionUs = chunkSource.isLive() ? 0 : positionUs;
+    int chunkSourceTrack = chunkSourceTrackIndices[track];
+    if (chunkSourceTrack != -1 && chunkSourceTrack != chunkSource.getSelectedTrackIndex()) {
+      // This is a primary track whose corresponding chunk source track is different to the one
+      // currently selected. We need to change the selection and restart. Since other exposed tracks
+      // may be enabled too, we need to implement the restart as a seek so that all downstream
+      // renderers receive a discontinuity event.
+      chunkSource.selectTrack(chunkSourceTrack);
+      seekToInternal(positionUs);
+      return;
+    }
     if (enabledTrackCount == 1) {
       lastSeekPositionUs = positionUs;
       if (wasLoadControlRegistered && downstreamPositionUs == positionUs) {
@@ -220,9 +236,7 @@ public void enable(int track, long positionUs) {
   @Override
   public void disable(int track) {
     Assertions.checkState(prepared);
-    Assertions.checkState(trackEnabledStates[track]);
-    enabledTrackCount--;
-    trackEnabledStates[track] = false;
+    setTrackEnabledState(track, false);
     if (enabledTrackCount == 0) {
       chunkSource.reset();
       downstreamPositionUs = Long.MIN_VALUE;
@@ -247,10 +261,10 @@ public boolean continueBuffering(int track, long playbackPositionUs) {
     if (!extractors.isEmpty()) {
       discardSamplesForDisabledTracks(getCurrentExtractor(), downstreamPositionUs);
     }
+    maybeStartLoading();
     if (loadingFinished) {
       return true;
     }
-    maybeStartLoading();
     if (isPendingReset() || extractors.isEmpty()) {
       return false;
     }
@@ -259,7 +273,8 @@ public boolean continueBuffering(int track, long playbackPositionUs) {
       if (!extractor.isPrepared()) {
         break;
       }
-      if (extractor.hasSamples(track)) {
+      int extractorTrack = extractorTrackIndices[track];
+      if (extractor.hasSamples(extractorTrack)) {
         return true;
       }
     }
@@ -267,21 +282,21 @@ public boolean continueBuffering(int track, long playbackPositionUs) {
   }
 
   @Override
-  public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
-    Assertions.checkState(prepared);
-    downstreamPositionUs = playbackPositionUs;
-
+  public long readDiscontinuity(int track) {
     if (pendingDiscontinuities[track]) {
       pendingDiscontinuities[track] = false;
-      return DISCONTINUITY_READ;
+      return lastSeekPositionUs;
     }
+    return NO_DISCONTINUITY;
+  }
 
-    if (onlyReadDiscontinuity) {
-      return NOTHING_READ;
-    }
+  @Override
+  public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder) {
+    Assertions.checkState(prepared);
+    downstreamPositionUs = playbackPositionUs;
 
-    if (isPendingReset()) {
+    if (pendingDiscontinuities[track] || isPendingReset()) {
       return NOTHING_READ;
     }
 
@@ -302,8 +317,9 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       extractor.configureSpliceTo(extractors.get(1));
     }
 
+    int extractorTrack = extractorTrackIndices[track];
     int extractorIndex = 0;
-    while (extractors.size() > extractorIndex + 1 && !extractor.hasSamples(track)) {
+    while (extractors.size() > extractorIndex + 1 && !extractor.hasSamples(extractorTrack)) {
       // We're finished reading from the extractor for this particular track, so advance to the
       // next one for the current read.
       extractor = extractors.get(++extractorIndex);
@@ -312,14 +328,14 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       }
     }
 
-    MediaFormat mediaFormat = extractor.getMediaFormat(track);
+    MediaFormat mediaFormat = extractor.getMediaFormat(extractorTrack);
     if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormats[track])) {
       formatHolder.format = mediaFormat;
       downstreamMediaFormats[track] = mediaFormat;
       return FORMAT_READ;
     }
 
-    if (extractor.getSample(track, sampleHolder)) {
+    if (extractor.getSample(extractorTrack, sampleHolder)) {
       boolean decodeOnly = sampleHolder.timeUs < lastSeekPositionUs;
       sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
       return SAMPLE_READ;
@@ -345,7 +361,10 @@ public void maybeThrowError() throws IOException {
   public void seekToUs(long positionUs) {
     Assertions.checkState(prepared);
     Assertions.checkState(enabledTrackCount > 0);
+    // Treat all seeks into live streams as being to t=0.
+    positionUs = chunkSource.isLive() ? 0 : positionUs;
 
+    // Ignore seeks to the current position.
     long currentPositionUs = isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
     downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
@@ -353,12 +372,7 @@ public void seekToUs(long positionUs) {
       return;
     }
 
-    // TODO: Optimize the seek for the case where the position is already buffered.
-    downstreamPositionUs = positionUs;
-    for (int i = 0; i < pendingDiscontinuities.length; i++) {
-      pendingDiscontinuities[i] = true;
-    }
-    restartFrom(positionUs);
+    seekToInternal(positionUs);
   }
 
   @Override
@@ -386,6 +400,10 @@ public long getBufferedPositionUs() {
   public void release() {
     Assertions.checkState(remainingReleaseCount > 0);
     if (--remainingReleaseCount == 0 && loader != null) {
+      if (loadControlRegistered) {
+        loadControl.unregister(this);
+        loadControlRegistered = false;
+      }
       loader.release();
       loader = null;
     }
@@ -410,9 +428,7 @@ public void onLoadCompleted(Loadable loadable) {
           currentLoadable.trigger, currentLoadable.format, -1, -1, now, loadDurationMs);
     }
     clearCurrentLoadable();
-    if (enabledTrackCount > 0 || !prepared) {
-      maybeStartLoading();
-    }
+    maybeStartLoading();
   }
 
   @Override
@@ -445,6 +461,146 @@ public void onLoadError(Loadable loadable, IOException e) {
 
   // Internal stuff.
 
+  /**
+   * Builds tracks that are exposed by this {@link HlsSampleSource} instance, as well as internal
+   * data-structures required for operation.
+   * <p>
+   * Tracks in HLS are complicated. A HLS master playlist contains a number of "variants". Each
+   * variant stream typically contains muxed video, audio and (possibly) additional audio, metadata
+   * and caption tracks. We wish to allow the user to select between an adaptive track that spans
+   * all variants, as well as each individual variant. If multiple audio tracks are present within
+   * each variant then we wish to allow the user to select between those also.
+   * <p>
+   * To do this, tracks are constructed as follows. The {@link HlsChunkSource} exposes (N+1) tracks,
+   * where N is the number of variants defined in the HLS master playlist. These consist of one
+   * adaptive track defined to span all variants and a track for each individual variant. The
+   * adaptive track is initially selected. The extractor is then prepared to discover the tracks
+   * inside of each variant stream. The two sets of tracks are then combined by this method to
+   * create a third set, which is the set exposed by this {@link HlsSampleSource}:
+   * <ul>
+   * <li>The extractor tracks are inspected to infer a "primary" track type. If a video track is
+   * present then it is always the primary type. If not, audio is the primary type if present.
+   * Else text is the primary type if present. Else there is no primary type.</li>
+   * <li>If there is exactly one extractor track of the primary type, it's expanded into (N+1)
+   * exposed tracks, all of which correspond to the primary extractor track and each of which
+   * corresponds to a different chunk source track. Selecting one of these tracks has the effect
+   * of switching the selected track on the chunk source.</li>
+   * <li>All other extractor tracks are exposed directly. Selecting one of these tracks has the
+   * effect of selecting an extractor track, leaving the selected track on the chunk source
+   * unchanged.</li>
+   * </ul>
+   *
+   * @param extractor The prepared extractor.
+   */
+  private void buildTracks(HlsExtractorWrapper extractor) {
+    // Iterate through the extractor tracks to discover the "primary" track type, and the index
+    // of the single track of this type.
+    int primaryExtractorTrackType = PRIMARY_TYPE_NONE;
+    int primaryExtractorTrackIndex = -1;
+    int extractorTrackCount = extractor.getTrackCount();
+    for (int i = 0; i < extractorTrackCount; i++) {
+      String mimeType = extractor.getMediaFormat(i).mimeType;
+      int trackType;
+      if (MimeTypes.isVideo(mimeType)) {
+        trackType = PRIMARY_TYPE_VIDEO;
+      } else if (MimeTypes.isAudio(mimeType)) {
+        trackType = PRIMARY_TYPE_AUDIO;
+      } else if (MimeTypes.isText(mimeType)) {
+        trackType = PRIMARY_TYPE_TEXT;
+      } else {
+        trackType = PRIMARY_TYPE_NONE;
+      }
+      if (trackType > primaryExtractorTrackType) {
+        primaryExtractorTrackType = trackType;
+        primaryExtractorTrackIndex = i;
+      } else if (trackType == primaryExtractorTrackType && primaryExtractorTrackIndex != -1) {
+        // We have multiple tracks of the primary type. We only want an index if there only
+        // exists a single track of the primary type, so set the index back to -1.
+        primaryExtractorTrackIndex = -1;
+      }
+    }
+
+    // Calculate the number of tracks that will be exposed.
+    int chunkSourceTrackCount = chunkSource.getTrackCount();
+    boolean expandPrimaryExtractorTrack = primaryExtractorTrackIndex != -1;
+    trackCount = extractorTrackCount;
+    if (expandPrimaryExtractorTrack) {
+      trackCount += chunkSourceTrackCount - 1;
+    }
+
+    // Instantiate the necessary internal data-structures.
+    trackFormats = new MediaFormat[trackCount];
+    trackEnabledStates = new boolean[trackCount];
+    pendingDiscontinuities = new boolean[trackCount];
+    downstreamMediaFormats = new MediaFormat[trackCount];
+    chunkSourceTrackIndices = new int[trackCount];
+    extractorTrackIndices = new int[trackCount];
+    extractorTrackEnabledStates = new boolean[extractorTrackCount];
+
+    // Construct the set of exposed tracks.
+    long durationUs = chunkSource.getDurationUs();
+    int trackIndex = 0;
+    for (int i = 0; i < extractorTrackCount; i++) {
+      MediaFormat format = extractor.getMediaFormat(i).copyWithDurationUs(durationUs);
+      if (i == primaryExtractorTrackIndex) {
+        for (int j = 0; j < chunkSourceTrackCount; j++) {
+          extractorTrackIndices[trackIndex] = i;
+          chunkSourceTrackIndices[trackIndex] = j;
+          Variant fixedTrackVariant = chunkSource.getFixedTrackVariant(j);
+          trackFormats[trackIndex++] = fixedTrackVariant == null ? format.copyAsAdaptive(null)
+              : copyWithFixedTrackInfo(format, fixedTrackVariant.format);
+        }
+      } else {
+        extractorTrackIndices[trackIndex] = i;
+        chunkSourceTrackIndices[trackIndex] = -1;
+        trackFormats[trackIndex++] = format;
+      }
+    }
+  }
+
+  /**
+   * Enables or disables the track at a given index.
+   *
+   * @param track The index of the track.
+   * @param enabledState True if the track is being enabled, or false if it's being disabled.
+   */
+  private void setTrackEnabledState(int track, boolean enabledState) {
+    Assertions.checkState(trackEnabledStates[track] != enabledState);
+    int extractorTrack = extractorTrackIndices[track];
+    Assertions.checkState(extractorTrackEnabledStates[extractorTrack] != enabledState);
+    trackEnabledStates[track] = enabledState;
+    extractorTrackEnabledStates[extractorTrack] = enabledState;
+    enabledTrackCount = enabledTrackCount + (enabledState ? 1 : -1);
+  }
+
+  /**
+   * Copies a provided {@link MediaFormat}, incorporating information from the {@link Format} of
+   * a fixed (i.e. non-adaptive) track.
+   *
+   * @param format The {@link MediaFormat} to copy.
+   * @param fixedTrackFormat The {@link Format} to incorporate into the copy.
+   * @return The copied {@link MediaFormat}.
+   */
+  private static MediaFormat copyWithFixedTrackInfo(MediaFormat format, Format fixedTrackFormat) {
+    int width = fixedTrackFormat.width == -1 ? MediaFormat.NO_VALUE : fixedTrackFormat.width;
+    int height = fixedTrackFormat.height == -1 ? MediaFormat.NO_VALUE : fixedTrackFormat.height;
+    return format.copyWithFixedTrackInfo(fixedTrackFormat.id, fixedTrackFormat.bitrate, width,
+        height, fixedTrackFormat.language);
+  }
+
+  /**
+   * Performs a seek. The operation is performed even if the seek is to the current position.
+   *
+   * @param positionUs The position to seek to.
+   */
+  private void seekToInternal(long positionUs) {
+    lastSeekPositionUs = positionUs;
+    downstreamPositionUs = positionUs;
+    Arrays.fill(pendingDiscontinuities, true);
+    chunkSource.seek();
+    restartFrom(positionUs);
+  }
+
   /**
    * Gets the current extractor from which samples should be read.
    * <p>
@@ -469,8 +625,8 @@ private void discardSamplesForDisabledTracks(HlsExtractorWrapper extractor, long
     if (!extractor.isPrepared()) {
       return;
     }
-    for (int i = 0; i < trackEnabledStates.length; i++) {
-      if (!trackEnabledStates[i]) {
+    for (int i = 0; i < extractorTrackEnabledStates.length; i++) {
+      if (!extractorTrackEnabledStates[i]) {
         extractor.discardUntil(i, timeUs);
       }
     }
@@ -480,8 +636,8 @@ private boolean haveSamplesForEnabledTracks(HlsExtractorWrapper extractor) {
     if (!extractor.isPrepared()) {
       return false;
     }
-    for (int i = 0; i < trackEnabledStates.length; i++) {
-      if (trackEnabledStates[i] && extractor.hasSamples(i)) {
+    for (int i = 0; i < extractorTrackEnabledStates.length; i++) {
+      if (extractorTrackEnabledStates[i] && extractor.hasSamples(i)) {
         return true;
       }
     }
@@ -534,7 +690,7 @@ private void maybeStartLoading() {
       return;
     }
 
-    if (loader.isLoading() || !nextLoader) {
+    if (loader.isLoading() || !nextLoader || (prepared && enabledTrackCount == 0)) {
       return;
     }
 
@@ -547,6 +703,7 @@ private void maybeStartLoading() {
 
     if (endOfStream) {
       loadingFinished = true;
+      loadControl.update(this, downstreamPositionUs, -1, false);
       return;
     }
     if (nextLoadable == null) {
@@ -583,7 +740,7 @@ private long getNextLoadPositionUs() {
     if (isPendingReset()) {
       return pendingResetPositionUs;
     } else {
-      return loadingFinished ? -1
+      return loadingFinished || (prepared && enabledTrackCount == 0) ? -1
           : currentTsLoadable != null ? currentTsLoadable.endTimeUs : previousTsLoadable.endTimeUs;
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsTrackSelector.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsTrackSelector.java
new file mode 100644
index 0000000000..eea3a21535
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsTrackSelector.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import java.io.IOException;
+
+/**
+ * Specifies a track selection from an {@link HlsMasterPlaylist}.
+ */
+public interface HlsTrackSelector {
+
+  /**
+   * Defines a selector output.
+   */
+  interface Output {
+
+    /**
+     * Outputs an adaptive track, covering the specified representations in the specified
+     * adaptation set.
+     *
+     * @param playlist The master playlist being processed.
+     * @param variants The variants to use for the adaptive track.
+     */
+    void adaptiveTrack(HlsMasterPlaylist playlist, Variant[] variants);
+
+    /**
+     * Outputs an fixed track corresponding to the specified representation in the specified
+     * adaptation set.
+     *
+     * @param playlist The master playlist being processed.
+     * @param variant The variant to use for the track.
+     */
+    void fixedTrack(HlsMasterPlaylist playlist, Variant variant);
+
+  }
+
+  /**
+   * Outputs a track selection for a given period.
+   *
+   * @param playlist The master playlist to process.
+   * @param output The output to receive tracks.
+   * @throws IOException If an error occurs processing the period.
+   */
+  void selectTracks(HlsMasterPlaylist playlist, Output output) throws IOException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/PtsTimestampAdjusterProvider.java b/library/src/main/java/com/google/android/exoplayer/hls/PtsTimestampAdjusterProvider.java
new file mode 100644
index 0000000000..d626a728c5
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/PtsTimestampAdjusterProvider.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.extractor.ts.PtsTimestampAdjuster;
+
+import android.util.SparseArray;
+
+/**
+ * Provides {@link PtsTimestampAdjuster} instances for use during HLS playbacks.
+ */
+public final class PtsTimestampAdjusterProvider {
+
+  // TODO: Prevent this array from growing indefinitely large by removing adjusters that are no
+  // longer required.
+  private final SparseArray<PtsTimestampAdjuster> ptsTimestampAdjusters;
+
+  public PtsTimestampAdjusterProvider() {
+    ptsTimestampAdjusters = new SparseArray<>();
+  }
+
+  /**
+   * Gets a {@link PtsTimestampAdjuster} suitable for adjusting the pts timestamps contained in
+   * a chunk with a given discontinuity sequence.
+   * <p>
+   * This method may return null if the master source has yet to initialize a suitable adjuster.
+   *
+   * @param isMasterSource True if the calling chunk source is the master.
+   * @param discontinuitySequence The chunk's discontinuity sequence.
+   * @param startTimeUs The chunk's start time.
+   * @return A {@link PtsTimestampAdjuster}.
+   */
+  public PtsTimestampAdjuster getAdjuster(boolean isMasterSource, int discontinuitySequence,
+      long startTimeUs) {
+    PtsTimestampAdjuster adjuster = ptsTimestampAdjusters.get(discontinuitySequence);
+    if (isMasterSource && adjuster == null) {
+      adjuster = new PtsTimestampAdjuster(startTimeUs);
+      ptsTimestampAdjusters.put(discontinuitySequence, adjuster);
+    }
+    return isMasterSource || (adjuster != null && adjuster.isInitialized()) ? adjuster : null;
+  }
+
+  /**
+   * Resets the provider.
+   */
+  public void reset() {
+    ptsTimestampAdjusters.clear();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
index 0e648a0388..1406807ede 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
@@ -25,16 +25,14 @@
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.ts.PtsTimestampAdjuster;
+import com.google.android.exoplayer.text.webvtt.WebvttCueParser;
 import com.google.android.exoplayer.text.webvtt.WebvttParserUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 import android.text.TextUtils;
 
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.util.Arrays;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -111,12 +109,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     return Extractor.RESULT_END_OF_INPUT;
   }
 
-  private void processSample() throws IOException {
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(new ByteArrayInputStream(sampleData), C.UTF8_NAME));
+  private void processSample() throws ParserException {
+    ParsableByteArray webvttData = new ParsableByteArray(sampleData);
 
     // Validate the first line of the header.
-    WebvttParserUtil.validateWebvttHeaderLine(reader);
+    WebvttParserUtil.validateWebvttHeaderLine(webvttData);
 
     // Defaults to use if the header doesn't contain an X-TIMESTAMP-MAP header.
     long vttTimestampUs = 0;
@@ -124,7 +121,7 @@ private void processSample() throws IOException {
 
     // Parse the remainder of the header looking for X-TIMESTAMP-MAP.
     String line;
-    while (!TextUtils.isEmpty(line = reader.readLine())) {
+    while (!TextUtils.isEmpty(line = webvttData.readLine())) {
       if (line.startsWith("X-TIMESTAMP-MAP")) {
         Matcher localTimestampMatcher = LOCAL_TIMESTAMP.matcher(line);
         if (!localTimestampMatcher.find()) {
@@ -141,7 +138,7 @@ private void processSample() throws IOException {
     }
 
     // Find the first cue header and parse the start time.
-    Matcher cueHeaderMatcher = WebvttParserUtil.findNextCueHeader(reader);
+    Matcher cueHeaderMatcher = WebvttCueParser.findNextCueHeader(webvttData);
     if (cueHeaderMatcher == null) {
       // No cues found. Don't output a sample, but still output a corresponding track.
       buildTrackOutput(0);
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
index a59519a7e6..5bd3ffbf5f 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
@@ -93,29 +93,17 @@ protected boolean handlesTrack(MediaFormat mediaFormat) {
   }
 
   @Override
-  protected void onEnabled(int track, long positionUs, boolean joining)
-      throws ExoPlaybackException {
-    super.onEnabled(track, positionUs, joining);
-    seekToInternal();
-  }
-
-  @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal();
-  }
-
-  private void seekToInternal() {
+  protected void onDiscontinuity(long positionUs) {
     pendingMetadata = null;
     inputStreamEnded = false;
   }
 
   @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    continueBufferingSource(positionUs);
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
     if (!inputStreamEnded && pendingMetadata == null) {
       sampleHolder.clearData();
-      int result = readSource(positionUs, formatHolder, sampleHolder, false);
+      int result = readSource(positionUs, formatHolder, sampleHolder);
       if (result == SampleSource.SAMPLE_READ) {
         pendingMetadataTimestamp = sampleHolder.timeUs;
         try {
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/DefaultSmoothStreamingTrackSelector.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/DefaultSmoothStreamingTrackSelector.java
index d87e52b5ed..142ef6a646 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/DefaultSmoothStreamingTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/DefaultSmoothStreamingTrackSelector.java
@@ -17,6 +17,8 @@
 
 import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
+import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
+import com.google.android.exoplayer.util.Util;
 
 import android.content.Context;
 
@@ -26,30 +28,60 @@
 /**
  * A default {@link SmoothStreamingTrackSelector} implementation.
  */
-// TODO: Add configuration options (e.g. ability to disable adaptive track output, disable format
-// filtering etc).
+// TODO: Add more configuration options (e.g. ability to disable adaptive track output).
 public final class DefaultSmoothStreamingTrackSelector implements SmoothStreamingTrackSelector {
 
-  private final Context context;
   private final int streamElementType;
 
+  private final Context context;
+  private final boolean filterVideoRepresentations;
+  private final boolean filterProtectedHdContent;
+
   /**
-   * @param context A context.
-   * @param streamElementType The type of stream to select. One of {@link StreamElement#TYPE_AUDIO},
-   *     {@link StreamElement#TYPE_VIDEO} and {@link StreamElement#TYPE_TEXT}.
+   * @param context A context. May be null if {@code filterVideoRepresentations == false}.
+   * @param filterVideoRepresentations Whether video representations should be filtered according to
+   *     the capabilities of the device. It is strongly recommended to set this to {@code true},
+   *     unless the application has already verified that all representations are playable.
+   * @param filterProtectedHdContent Whether video representations that are both drm protected and
+   *     high definition should be filtered when tracks are built. If
+   *     {@code filterVideoRepresentations == false} then this parameter is ignored.
    */
-  public DefaultSmoothStreamingTrackSelector(Context context, int streamElementType) {
+  public static DefaultSmoothStreamingTrackSelector newVideoInstance(Context context,
+      boolean filterVideoRepresentations, boolean filterProtectedHdContent) {
+    return new DefaultSmoothStreamingTrackSelector(StreamElement.TYPE_VIDEO, context,
+        filterVideoRepresentations, filterProtectedHdContent);
+  }
+
+  public static DefaultSmoothStreamingTrackSelector newAudioInstance() {
+    return new DefaultSmoothStreamingTrackSelector(StreamElement.TYPE_AUDIO, null, false, false);
+  }
+
+  public static DefaultSmoothStreamingTrackSelector newTextInstance() {
+    return new DefaultSmoothStreamingTrackSelector(StreamElement.TYPE_TEXT, null, false, false);
+  }
+
+  private DefaultSmoothStreamingTrackSelector(int streamElementType, Context context,
+      boolean filterVideoRepresentations, boolean filterProtectedHdContent) {
     this.context = context;
     this.streamElementType = streamElementType;
+    this.filterVideoRepresentations = filterVideoRepresentations;
+    this.filterProtectedHdContent = filterProtectedHdContent;
   }
 
   @Override
   public void selectTracks(SmoothStreamingManifest manifest, Output output) throws IOException {
     for (int i = 0; i < manifest.streamElements.length; i++) {
+      TrackElement[] tracks = manifest.streamElements[i].tracks;
       if (manifest.streamElements[i].type == streamElementType) {
         if (streamElementType == StreamElement.TYPE_VIDEO) {
-          int[] trackIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
-              context, Arrays.asList(manifest.streamElements[i].tracks), null, false);
+          int[] trackIndices;
+          if (filterVideoRepresentations) {
+            trackIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
+                context, Arrays.asList(tracks), null,
+                filterProtectedHdContent && manifest.protectionElement != null);
+          } else {
+            trackIndices = Util.firstIntegersArray(tracks.length);
+          }
           int trackCount = trackIndices.length;
           if (trackCount > 1) {
             output.adaptiveTrack(manifest, i, trackIndices);
@@ -58,7 +90,7 @@ public void selectTracks(SmoothStreamingManifest manifest, Output output) throws
             output.fixedTrack(manifest, i, trackIndices[j]);
           }
         } else {
-          for (int j = 0; j < manifest.streamElements[i].tracks.length; j++) {
+          for (int j = 0; j < tracks.length; j++) {
             output.fixedTrack(manifest, i, j);
           }
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
index 34c3880fa8..568ad2147d 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
@@ -132,10 +132,10 @@ public ProtectionElement(UUID uuid, byte[] data) {
     public final byte[][] csd;
 
     public TrackElement(int index, int bitrate, String mimeType, byte[][] csd, int maxWidth,
-        int maxHeight, int sampleRate, int numChannels) {
+        int maxHeight, int sampleRate, int numChannels, String language) {
       this.csd = csd;
       format = new Format(String.valueOf(index), mimeType, maxWidth, maxHeight, -1, numChannels,
-          sampleRate, bitrate);
+          sampleRate, bitrate, language);
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
index b4c91b7935..6efa6e95d9 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
@@ -543,6 +543,7 @@ private void parseStreamElementStartTag(XmlPullParser parser) throws ParserExcep
       displayWidth = parseInt(parser, KEY_DISPLAY_WIDTH, -1);
       displayHeight = parseInt(parser, KEY_DISPLAY_HEIGHT, -1);
       language = parser.getAttributeValue(null, KEY_LANGUAGE);
+      putNormalizedAttribute(KEY_LANGUAGE, language);
       timescale = parseInt(parser, KEY_TIME_SCALE, -1);
       if (timescale == -1) {
         timescale = (Long) getNormalizedAttribute(KEY_TIME_SCALE);
@@ -595,6 +596,7 @@ public Object build() {
     private static final String KEY_CHANNELS = "Channels";
     private static final String KEY_FOUR_CC = "FourCC";
     private static final String KEY_TYPE = "Type";
+    private static final String KEY_LANGUAGE = "Language";
     private static final String KEY_MAX_WIDTH = "MaxWidth";
     private static final String KEY_MAX_HEIGHT = "MaxHeight";
 
@@ -607,6 +609,7 @@ public Object build() {
     private int maxHeight;
     private int samplingRate;
     private int channels;
+    private String language;
 
     public TrackElementParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
@@ -620,6 +623,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
 
       index = parseInt(parser, KEY_INDEX, -1);
       bitrate = parseRequiredInt(parser, KEY_BITRATE);
+      language = (String) getNormalizedAttribute(KEY_LANGUAGE);
 
       if (type == StreamElement.TYPE_VIDEO) {
         maxHeight = parseRequiredInt(parser, KEY_MAX_HEIGHT);
@@ -664,7 +668,7 @@ public Object build() {
         csd.toArray(csdArray);
       }
       return new TrackElement(index, bitrate, mimeType, csdArray, maxWidth, maxHeight, samplingRate,
-          channels);
+          channels, language);
     }
 
     private static String fourCCToMimeType(String fourCC) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java
index d02ac46f42..1daa5aa128 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java
@@ -15,11 +15,10 @@
  */
 package com.google.android.exoplayer.text;
 
-import java.io.IOException;
-import java.io.InputStream;
+import com.google.android.exoplayer.ParserException;
 
 /**
- * Parses {@link Subtitle}s from {@link InputStream}s.
+ * Parses {@link Subtitle}s from a byte array.
  */
 public interface SubtitleParser {
 
@@ -32,12 +31,14 @@
   public boolean canParse(String mimeType);
 
   /**
-   * Parses a {@link Subtitle} from the provided {@link InputStream}.
+   * Parses a {@link Subtitle} from the provided {@code byte[]}.
    *
-   * @param inputStream The stream from which to parse the subtitle.
+   * @param bytes The array holding the subtitle data.
+   * @param offset The offset of the subtitle data in bytes.
+   * @param length The length of the subtitle data in bytes.
    * @return A parsed representation of the subtitle.
-   * @throws IOException If a problem occurred reading from the stream.
+   * @throws ParserException If a problem occurred parsing the subtitle data.
    */
-  public Subtitle parse(InputStream inputStream) throws IOException;
+  public Subtitle parse(byte[] bytes, int offset, int length) throws ParserException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
index 952ae04b97..eab6933e9a 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.text;
 
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
@@ -25,9 +26,7 @@
 import android.os.Looper;
 import android.os.Message;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.InputStream;
 
 /**
  * Wraps a {@link SubtitleParser}, exposing an interface similar to {@link MediaCodec} for
@@ -165,12 +164,11 @@ private void handleFormat(MediaFormat format) {
 
   private void handleSample(long sampleTimeUs, SampleHolder holder) {
     Subtitle parsedSubtitle = null;
-    IOException error = null;
+    ParserException error = null;
     RuntimeException runtimeError = null;
     try {
-      InputStream inputStream = new ByteArrayInputStream(holder.data.array(), 0, holder.size);
-      parsedSubtitle = parser.parse(inputStream);
-    } catch (IOException e) {
+      parsedSubtitle = parser.parse(holder.data.array(), 0, holder.size);
+    } catch (ParserException e) {
       error = e;
     } catch (RuntimeException e) {
       runtimeError = e;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
index 4fa5a4f918..865966ad53 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
@@ -87,6 +87,13 @@
     } catch (ClassNotFoundException e) {
       // Parser not found.
     }
+    try {
+      DEFAULT_PARSER_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.text.mp4webvtt.Mp4WebvttParser")
+              .asSubclass(SubtitleParser.class));
+    } catch (ClassNotFoundException e) {
+      // Parser not found.
+    }
     try {
       DEFAULT_PARSER_CLASSES.add(
           Class.forName("com.google.android.exoplayer.text.subrip.SubripParser")
@@ -178,26 +185,22 @@ protected void onEnabled(int track, long positionUs, boolean joining)
     parserThread = new HandlerThread("textParser");
     parserThread.start();
     parserHelper = new SubtitleParserHelper(parserThread.getLooper(), subtitleParsers[parserIndex]);
-    seekToInternal();
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal();
-  }
-
-  private void seekToInternal() {
+  protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     subtitle = null;
     nextSubtitle = null;
-    parserHelper.flush();
     clearTextRenderer();
+    if (parserHelper != null) {
+      parserHelper.flush();
+    }
   }
 
   @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    continueBufferingSource(positionUs);
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
     if (nextSubtitle == null) {
       try {
         nextSubtitle = parserHelper.getAndClearResult();
@@ -240,7 +243,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
       // Try and read the next subtitle from the source.
       SampleHolder sampleHolder = parserHelper.getSampleHolder();
       sampleHolder.clearData();
-      int result = readSource(positionUs, formatHolder, sampleHolder, false);
+      int result = readSource(positionUs, formatHolder, sampleHolder);
       if (result == SampleSource.FORMAT_READ) {
         parserHelper.setFormat(formatHolder.format);
       } else if (result == SampleSource.SAMPLE_READ) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
index 316b660cd4..4004846621 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
@@ -97,16 +97,10 @@ protected boolean handlesTrack(MediaFormat mediaFormat) {
   protected void onEnabled(int track, long positionUs, boolean joining)
       throws ExoPlaybackException {
     super.onEnabled(track, positionUs, joining);
-    seekToInternal();
   }
 
   @Override
-  protected void seekTo(long positionUs) throws ExoPlaybackException {
-    super.seekTo(positionUs);
-    seekToInternal();
-  }
-
-  private void seekToInternal() {
+  protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
     pendingCaptionLists.clear();
     clearPendingSample();
@@ -116,15 +110,15 @@ private void seekToInternal() {
   }
 
   @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    continueBufferingSource(positionUs);
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
     if (isSamplePending()) {
       maybeParsePendingSample(positionUs);
     }
 
     int result = inputStreamEnded ? SampleSource.END_OF_STREAM : SampleSource.SAMPLE_READ;
     while (!isSamplePending() && result == SampleSource.SAMPLE_READ) {
-      result = readSource(positionUs, formatHolder, sampleHolder, false);
+      result = readSource(positionUs, formatHolder, sampleHolder);
       if (result == SampleSource.SAMPLE_READ) {
         maybeParsePendingSample(positionUs);
       } else if (result == SampleSource.END_OF_STREAM) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
index 9055c1e1ef..81de172d13 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
@@ -15,21 +15,17 @@
  */
 package com.google.android.exoplayer.text.subrip;
 
-import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.LongArray;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
 
 import android.text.Html;
 import android.text.Spanned;
 import android.text.TextUtils;
 import android.util.Log;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -57,14 +53,15 @@ public boolean canParse(String mimeType) {
   }
 
   @Override
-  public SubripSubtitle parse(InputStream inputStream) throws IOException {
+  public SubripSubtitle parse(byte[] bytes, int offset, int length) {
     ArrayList<Cue> cues = new ArrayList<>();
     LongArray cueTimesUs = new LongArray();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, C.UTF8_NAME));
+    ParsableByteArray subripData = new ParsableByteArray(bytes, offset + length);
+    subripData.setPosition(offset);
     boolean haveEndTimecode;
     String currentLine;
 
-    while ((currentLine = reader.readLine()) != null) {
+    while ((currentLine = subripData.readLine()) != null) {
       if (currentLine.length() == 0) {
         // Skip blank lines.
         continue;
@@ -80,7 +77,7 @@ public SubripSubtitle parse(InputStream inputStream) throws IOException {
 
       // Read and parse the timing line.
       haveEndTimecode = false;
-      currentLine = reader.readLine();
+      currentLine = subripData.readLine();
       Matcher matcher = SUBRIP_TIMING_LINE.matcher(currentLine);
       if (matcher.find()) {
         cueTimesUs.add(parseTimecode(matcher.group(1)));
@@ -96,7 +93,7 @@ public SubripSubtitle parse(InputStream inputStream) throws IOException {
 
       // Read and parse the text.
       textBuilder.setLength(0);
-      while (!TextUtils.isEmpty(currentLine = reader.readLine())) {
+      while (!TextUtils.isEmpty(currentLine = subripData.readLine())) {
         if (textBuilder.length() > 0) {
           textBuilder.append("<br>");
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlColorParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlColorParser.java
index 4a519dae7e..f402142c2f 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlColorParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlColorParser.java
@@ -40,7 +40,6 @@
   private static final Pattern RGBA_PATTERN = Pattern.compile(
       "^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$");
 
-
   static final int TRANSPARENT = 0x00000000;
   static final int BLACK = 0xFF000000;
   static final int SILVER = 0xFFC0C0C0;
@@ -89,15 +88,18 @@ public static int parseColor(String colorExpression) {
     Assertions.checkArgument(!TextUtils.isEmpty(colorExpression));
     colorExpression = colorExpression.replace(" ", "");
     if (colorExpression.charAt(0) == '#') {
-      // Use a long to avoid rollovers on #ffXXXXXX
-      long color = Long.parseLong(colorExpression.substring(1), 16);
+      // Parse using Long to avoid failure when colorExpression is greater than #7FFFFFFF.
+      int color = (int) Long.parseLong(colorExpression.substring(1), 16);
       if (colorExpression.length() == 7) {
         // Set the alpha value
-        color |= 0x00000000ff000000;
-      } else if (colorExpression.length() != 9) {
+        color |= 0xFF000000;
+      } else if (colorExpression.length() == 9) {
+        // We have #RRGGBBAA, but we need #AARRGGBB
+        color = ((color & 0xFF) << 24) | (color >>> 8);
+      } else {
         throw new IllegalArgumentException();
       }
-      return (int) color;
+      return color;
     } else if (colorExpression.startsWith(RGBA)) {
       Matcher matcher = RGBA_PATTERN.matcher(colorExpression);
       if (matcher.matches()) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
index 7bbaa9a215..2b089f258a 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
@@ -17,7 +17,6 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.text.Subtitle;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParserUtil;
@@ -30,8 +29,8 @@
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlPullParserFactory;
 
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Map;
@@ -97,10 +96,11 @@ public boolean canParse(String mimeType) {
   }
 
   @Override
-  public Subtitle parse(InputStream inputStream) throws IOException {
+  public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserException {
     try {
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
       Map<String, TtmlStyle> globalStyles = new HashMap<>();
+      ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes, offset, length);
       xmlParser.setInput(inputStream, null);
       TtmlSubtitle ttmlSubtitle = null;
       LinkedList<TtmlNode> nodeStack = new LinkedList<>();
@@ -150,6 +150,8 @@ public Subtitle parse(InputStream inputStream) throws IOException {
       return ttmlSubtitle;
     } catch (XmlPullParserException xppe) {
       throw new ParserException("Unable to parse source", xppe);
+    } catch (IOException e) {
+      throw new IllegalStateException("Unexpected error when reading input.", e);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
index 63b6cc8886..a2bff2ec1d 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
@@ -35,16 +35,6 @@
  */
 /* package */ final class TtmlRenderUtil {
 
-  /* spans which are always the same can be reused to avoid object creation */
-  private static final StrikethroughSpan STRIKETHROUGH_SPAN = new StrikethroughSpan();
-  private static final UnderlineSpan UNDERLINE_SPAN = new UnderlineSpan();
-  private static final StyleSpan[] STYLE_SPANS = new StyleSpan[] {
-    new StyleSpan(TtmlStyle.STYLE_NORMAL),
-    new StyleSpan(TtmlStyle.STYLE_BOLD),
-    new StyleSpan(TtmlStyle.STYLE_ITALIC),
-    new StyleSpan(TtmlStyle.STYLE_BOLD_ITALIC),
-  };
-
   public static TtmlStyle resolveStyle(TtmlStyle style, String[] styleIds,
       Map<String, TtmlStyle> globalStyles) {
     if (style == null && styleIds == null) {
@@ -78,14 +68,14 @@ public static void applyStylesToSpan(SpannableStringBuilder builder,
       int start, int end, TtmlStyle style) {
 
     if (style.getStyle() != TtmlStyle.UNSPECIFIED) {
-      builder.setSpan(STYLE_SPANS[style.getStyle()], start, end,
+      builder.setSpan(new StyleSpan(style.getStyle()), start, end,
           Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
     if (style.isLinethrough()) {
-      builder.setSpan(STRIKETHROUGH_SPAN, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+      builder.setSpan(new StrikethroughSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
     if (style.isUnderline()) {
-      builder.setSpan(UNDERLINE_SPAN, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+      builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
     if (style.hasColorSpecified()) {
       builder.setSpan(new ForegroundColorSpan(style.getColor()), start, end,
diff --git a/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
index 4804c2e913..8851d5e057 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
@@ -20,10 +20,6 @@
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.MimeTypes;
 
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
 /**
  * A {@link SubtitleParser} for tx3g.
  * <p>
@@ -37,9 +33,8 @@ public boolean canParse(String mimeType) {
   }
 
   @Override
-  public Subtitle parse(InputStream inputStream) throws IOException {
-    DataInputStream dataInputStream  = new DataInputStream(inputStream);
-    String cueText = dataInputStream.readUTF();
+  public Subtitle parse(byte[] bytes, int offset, int length) {
+    String cueText = new String(bytes, offset, length);
     return new Tx3gSubtitle(new Cue(cueText));
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParser.java
new file mode 100644
index 0000000000..41533d9df6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParser.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.SubtitleParser;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A {@link SubtitleParser} for Webvtt embedded in a Mp4 container file.
+ */
+public final class Mp4WebvttParser implements SubtitleParser {
+
+  private static final int BOX_HEADER_SIZE = 8;
+
+  private static final int TYPE_payl = Util.getIntegerCodeForString("payl");
+  private static final int TYPE_sttg = Util.getIntegerCodeForString("sttg");
+  private static final int TYPE_vttc = Util.getIntegerCodeForString("vttc");
+
+  private final ParsableByteArray sampleData;
+  private final WebvttCue.Builder builder;
+
+  public Mp4WebvttParser() {
+    sampleData = new ParsableByteArray();
+    builder = new WebvttCue.Builder();
+  }
+
+  @Override
+  public boolean canParse(String mimeType) {
+    return MimeTypes.APPLICATION_MP4VTT.equals(mimeType);
+  }
+
+  @Override
+  public Mp4WebvttSubtitle parse(byte[] bytes, int offset, int length) throws ParserException {
+    // Webvtt in Mp4 samples have boxes inside of them, so we have to do a traditional box parsing:
+    // first 4 bytes size and then 4 bytes type.
+    sampleData.reset(bytes, offset + length);
+    sampleData.setPosition(offset);
+    List<Cue> resultingCueList = new ArrayList<>();
+    while (sampleData.bytesLeft() > 0) {
+      if (sampleData.bytesLeft() < BOX_HEADER_SIZE) {
+        throw new ParserException("Incomplete Mp4Webvtt Top Level box header found.");
+      }
+      int boxSize = sampleData.readInt();
+      int boxType = sampleData.readInt();
+      if (boxType == TYPE_vttc) {
+        resultingCueList.add(parseVttCueBox(sampleData, builder, boxSize - BOX_HEADER_SIZE));
+      } else {
+        // Peers of the VTTCueBox are still not supported and are skipped.
+        sampleData.skipBytes(boxSize - BOX_HEADER_SIZE);
+      }
+    }
+    return new Mp4WebvttSubtitle(resultingCueList);
+  }
+
+  private static Cue parseVttCueBox(ParsableByteArray sampleData, WebvttCue.Builder builder,
+        int remainingCueBoxBytes) throws ParserException {
+    builder.reset();
+    while (remainingCueBoxBytes > 0) {
+      if (remainingCueBoxBytes < BOX_HEADER_SIZE) {
+        throw new ParserException("Incomplete vtt cue box header found.");
+      }
+      int boxSize = sampleData.readInt();
+      int boxType = sampleData.readInt();
+      remainingCueBoxBytes -= BOX_HEADER_SIZE;
+      int payloadLength = boxSize - BOX_HEADER_SIZE;
+      String boxPayload = new String(sampleData.data, sampleData.getPosition(), payloadLength);
+      sampleData.skipBytes(payloadLength);
+      remainingCueBoxBytes -= payloadLength;
+      if (boxType == TYPE_sttg) {
+        WebvttCueParser.parseCueSettingsList(boxPayload, builder);
+      } else if (boxType == TYPE_payl) {
+        WebvttCueParser.parseCueText(boxPayload.trim(), builder);
+      } else {
+        // Other VTTCueBox children are still not supported and are ignored.
+      }
+    }
+    return builder.build();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttSubtitle.java
new file mode 100644
index 0000000000..474abafbc1
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttSubtitle.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.Subtitle;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Representation of a Webvtt subtitle embedded in a MP4 container file.
+ */
+/* package */ final class Mp4WebvttSubtitle implements Subtitle {
+
+  private final List<Cue> cues;
+
+  public Mp4WebvttSubtitle(List<Cue> cueList) {
+    cues = Collections.unmodifiableList(cueList);
+  }
+
+  @Override
+  public int getNextEventTimeIndex(long timeUs) {
+    return timeUs < 0 ? 0 : -1;
+  }
+
+  @Override
+  public int getEventTimeCount() {
+    return 1;
+  }
+
+  @Override
+  public long getEventTime(int index) {
+    Assertions.checkArgument(index == 0);
+    return 0;
+  }
+
+  @Override
+  public long getLastEventTime() {
+    return 0;
+  }
+
+  @Override
+  public List<Cue> getCues(long timeUs) {
+    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java
index 3b0d233007..95113cfb34 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.text.Cue;
 
 import android.text.Layout.Alignment;
+import android.util.Log;
 
 /**
  * A representation of a WebVTT cue.
@@ -53,4 +54,127 @@ public boolean isNormalCue() {
     return (line == DIMEN_UNSET && position == DIMEN_UNSET);
   }
 
+  /**
+   * Builder for WebVTT cues.
+   */
+  @SuppressWarnings("hiding")
+  public static final class Builder {
+
+    private static final String TAG = "WebvttCueBuilder";
+
+    private long startTime;
+    private long endTime;
+    private CharSequence text;
+    private Alignment textAlignment;
+    private float line;
+    private int lineType;
+    private int lineAnchor;
+    private float position;
+    private int positionAnchor;
+    private float width;
+
+    // Initialization methods
+
+    public Builder() {
+      reset();
+    }
+
+    public void reset() {
+      startTime = 0;
+      endTime = 0;
+      text = null;
+      textAlignment = null;
+      line = Cue.DIMEN_UNSET;
+      lineType = Cue.TYPE_UNSET;
+      lineAnchor = Cue.TYPE_UNSET;
+      position = Cue.DIMEN_UNSET;
+      positionAnchor = Cue.TYPE_UNSET;
+      width = Cue.DIMEN_UNSET;
+    }
+
+    // Construction methods
+
+    public WebvttCue build() {
+      if (position != Cue.DIMEN_UNSET && positionAnchor == Cue.TYPE_UNSET) {
+        derivePositionAnchorFromAlignment();
+      }
+      return new WebvttCue(startTime, endTime, text, textAlignment, line, lineType, lineAnchor,
+          position, positionAnchor, width);
+    }
+
+    public Builder setStartTime(long time) {
+      startTime = time;
+      return this;
+    }
+
+    public Builder setEndTime(long time) {
+      endTime = time;
+      return this;
+    }
+
+    public Builder setText(CharSequence aText) {
+      text = aText;
+      return this;
+    }
+
+    public Builder setTextAlignment(Alignment textAlignment) {
+      this.textAlignment = textAlignment;
+      return this;
+    }
+
+    public Builder setLine(float line) {
+      this.line = line;
+      return this;
+    }
+
+    public Builder setLineType(int lineType) {
+      this.lineType = lineType;
+      return this;
+    }
+
+    public Builder setLineAnchor(int lineAnchor) {
+      this.lineAnchor = lineAnchor;
+      return this;
+    }
+
+    public Builder setPosition(float position) {
+      this.position = position;
+      return this;
+    }
+
+    public Builder setPositionAnchor(int positionAnchor) {
+      this.positionAnchor = positionAnchor;
+      return this;
+    }
+
+    public Builder setWidth(float width) {
+      this.width = width;
+      return this;
+    }
+
+    private Builder derivePositionAnchorFromAlignment() {
+      if (textAlignment == null) {
+        positionAnchor = Cue.TYPE_UNSET;
+      } else {
+        switch (textAlignment) {
+          case ALIGN_NORMAL:
+            positionAnchor = Cue.ANCHOR_TYPE_START;
+            break;
+          case ALIGN_CENTER:
+            positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+            break;
+          case ALIGN_OPPOSITE:
+            positionAnchor = Cue.ANCHOR_TYPE_END;
+            break;
+          default:
+            Log.w(TAG, "Unrecognized alignment: " + textAlignment);
+            positionAnchor = Cue.ANCHOR_TYPE_START;
+            break;
+        }
+      }
+      return this;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
index 89eedf5bf9..7c65a266d7 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
@@ -15,7 +15,11 @@
  */
 package com.google.android.exoplayer.text.webvtt;
 
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
 import android.graphics.Typeface;
+import android.text.Layout.Alignment;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
 import android.text.style.StyleSpan;
@@ -23,11 +27,19 @@
 import android.util.Log;
 
 import java.util.Stack;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
- * Parser for webvtt cue text. (https://w3c.github.io/webvtt/#cue-text)
+ * Parser for WebVTT cues. (https://w3c.github.io/webvtt/#cues)
  */
-/* package */ final class WebvttCueParser {
+public final class WebvttCueParser {
+
+  public static final Pattern CUE_HEADER_PATTERN = Pattern
+      .compile("^(\\S+)\\s+-->\\s+(\\S+)(.*)?$");
+
+  private static final Pattern COMMENT = Pattern.compile("^NOTE((\u0020|\u0009).*)?$");
+  private static final Pattern CUE_SETTING_PATTERN = Pattern.compile("(\\S+?):(\\S+)");
 
   private static final char CHAR_LESS_THAN = '<';
   private static final char CHAR_GREATER_THAN = '>';
@@ -54,7 +66,91 @@
 
   private static final String TAG = "WebvttCueParser";
 
-  public Spanned parse(String markup) {
+  private final StringBuilder textBuilder;
+
+  public WebvttCueParser() {
+    textBuilder = new StringBuilder();
+  }
+
+  /**
+   * Parses the next valid WebVTT cue in a parsable array, including timestamps, settings and text.
+   *
+   * @param webvttData Parsable WebVTT file data.
+   * @param builder Builder for WebVTT Cues.
+   * @return True if a valid Cue was found, false otherwise.
+   */
+  /* package */ boolean parseNextValidCue(ParsableByteArray webvttData, WebvttCue.Builder builder) {
+    Matcher cueHeaderMatcher;
+    while ((cueHeaderMatcher = findNextCueHeader(webvttData)) != null) {
+      if (parseCue(cueHeaderMatcher, webvttData, builder, textBuilder)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Parses a string containing a list of cue settings.
+   *
+   * @param cueSettingsList String containing the settings for a given cue.
+   * @param builder The {@link WebvttCue.Builder} where incremental construction takes place.
+   */
+  /* package */ static void parseCueSettingsList(String cueSettingsList,
+      WebvttCue.Builder builder) {
+    // Parse the cue settings list.
+    Matcher cueSettingMatcher = CUE_SETTING_PATTERN.matcher(cueSettingsList);
+    while (cueSettingMatcher.find()) {
+      String name = cueSettingMatcher.group(1);
+      String value = cueSettingMatcher.group(2);
+      try {
+        if ("line".equals(name)) {
+          parseLineAttribute(value, builder);
+        } else if ("align".equals(name)) {
+          builder.setTextAlignment(parseTextAlignment(value));
+        } else if ("position".equals(name)) {
+          parsePositionAttribute(value, builder);
+        } else if ("size".equals(name)) {
+          builder.setWidth(WebvttParserUtil.parsePercentage(value));
+        } else {
+          Log.w(TAG, "Unknown cue setting " + name + ":" + value);
+        }
+      } catch (NumberFormatException e) {
+        Log.w(TAG, "Skipping bad cue setting: " + cueSettingMatcher.group());
+      }
+    }
+  }
+
+  /**
+   * Reads lines up to and including the next WebVTT cue header.
+   *
+   * @param input The input from which lines should be read.
+   * @return A {@link Matcher} for the WebVTT cue header, or null if the end of the input was
+   *     reached without a cue header being found. In the case that a cue header is found, groups 1,
+   *     2 and 3 of the returned matcher contain the start time, end time and settings list.
+   */
+  public static Matcher findNextCueHeader(ParsableByteArray input) {
+    String line;
+    while ((line = input.readLine()) != null) {
+      if (COMMENT.matcher(line).matches()) {
+        // Skip until the end of the comment block.
+        while ((line = input.readLine()) != null && !line.isEmpty()) {}
+      } else {
+        Matcher cueHeaderMatcher = WebvttCueParser.CUE_HEADER_PATTERN.matcher(line);
+        if (cueHeaderMatcher.matches()) {
+          return cueHeaderMatcher;
+        }
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Parses the text payload of a WebVTT Cue and applies modifications on {@link WebvttCue.Builder}.
+   *
+   * @param markup The markup text to be parsed.
+   * @param builder Target builder.
+   */
+  /* package */ static void parseCueText(String markup, WebvttCue.Builder builder) {
     SpannableStringBuilder spannedText = new SpannableStringBuilder();
     Stack<StartTag> startTagStack = new Stack<>();
     String[] tagTokens;
@@ -116,22 +212,108 @@ public Spanned parse(String markup) {
     while (!startTagStack.isEmpty()) {
       applySpansForTag(startTagStack.pop(), spannedText);
     }
-    return spannedText;
+    builder.setText(spannedText);
+  }
+
+  private static boolean parseCue(Matcher cueHeaderMatcher, ParsableByteArray webvttData,
+      WebvttCue.Builder builder, StringBuilder textBuilder) {
+    try {
+      // Parse the cue start and end times.
+      builder.setStartTime(WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(1)))
+          .setEndTime(WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(2)));
+    } catch (NumberFormatException e) {
+      Log.w(TAG, "Skipping cue with bad header: " + cueHeaderMatcher.group());
+      return false;
+    }
+
+    parseCueSettingsList(cueHeaderMatcher.group(3), builder);
+
+    // Parse the cue text.
+    textBuilder.setLength(0);
+    String line;
+    while ((line = webvttData.readLine()) != null && !line.isEmpty()) {
+      if (textBuilder.length() > 0) {
+        textBuilder.append("\n");
+      }
+      textBuilder.append(line.trim());
+    }
+    parseCueText(textBuilder.toString(), builder);
+    return true;
+  }
+
+  // Internal methods
+
+  private static void parseLineAttribute(String s, WebvttCue.Builder builder)
+      throws NumberFormatException {
+    int commaPosition = s.indexOf(',');
+    if (commaPosition != -1) {
+      builder.setLineAnchor(parsePositionAnchor(s.substring(commaPosition + 1)));
+      s = s.substring(0, commaPosition);
+    } else {
+      builder.setLineAnchor(Cue.TYPE_UNSET);
+    }
+    if (s.endsWith("%")) {
+      builder.setLine(WebvttParserUtil.parsePercentage(s)).setLineType(Cue.LINE_TYPE_FRACTION);
+    } else {
+      builder.setLine(Integer.parseInt(s)).setLineType(Cue.LINE_TYPE_NUMBER);
+    }
+  }
+
+  private static void parsePositionAttribute(String s, WebvttCue.Builder builder)
+      throws NumberFormatException {
+    int commaPosition = s.indexOf(',');
+    if (commaPosition != -1) {
+      builder.setPositionAnchor(parsePositionAnchor(s.substring(commaPosition + 1)));
+      s = s.substring(0, commaPosition);
+    } else {
+      builder.setPositionAnchor(Cue.TYPE_UNSET);
+    }
+    builder.setPosition(WebvttParserUtil.parsePercentage(s));
+  }
+
+  private static int parsePositionAnchor(String s) {
+    switch (s) {
+      case "start":
+        return Cue.ANCHOR_TYPE_START;
+      case "middle":
+        return Cue.ANCHOR_TYPE_MIDDLE;
+      case "end":
+        return Cue.ANCHOR_TYPE_END;
+      default:
+        Log.w(TAG, "Invalid anchor value: " + s);
+        return Cue.TYPE_UNSET;
+    }
+  }
+
+  private static Alignment parseTextAlignment(String s) {
+    switch (s) {
+      case "start":
+      case "left":
+        return Alignment.ALIGN_NORMAL;
+      case "middle":
+        return Alignment.ALIGN_CENTER;
+      case "end":
+      case "right":
+        return Alignment.ALIGN_OPPOSITE;
+      default:
+        Log.w(TAG, "Invalid alignment value: " + s);
+        return null;
+    }
   }
 
   /**
    * Find end of tag (&gt;). The position returned is the position of the &gt; plus one (exclusive).
    *
-   * @param markup The webvtt cue markup to be parsed.
+   * @param markup The WebVTT cue markup to be parsed.
    * @param startPos the position from where to start searching for the end of tag.
    * @return the position of the end of tag plus 1 (one).
    */
-  private int findEndOfTag(String markup, int startPos) {
+  private static int findEndOfTag(String markup, int startPos) {
     int idx = markup.indexOf(CHAR_GREATER_THAN, startPos);
     return idx == -1 ? markup.length() : idx + 1;
   }
 
-  private void applyEntity(String entity, SpannableStringBuilder spannedText) {
+  private static void applyEntity(String entity, SpannableStringBuilder spannedText) {
     switch (entity) {
       case ENTITY_LESS_THAN:
         spannedText.append('<');
@@ -151,7 +333,7 @@ private void applyEntity(String entity, SpannableStringBuilder spannedText) {
     }
   }
 
-  private boolean isSupportedTag(String tagName) {
+  private static boolean isSupportedTag(String tagName) {
     switch (tagName) {
       case TAG_BOLD:
       case TAG_CLASS:
@@ -165,7 +347,7 @@ private boolean isSupportedTag(String tagName) {
     }
   }
 
-  private void applySpansForTag(StartTag startTag, SpannableStringBuilder spannedText) {
+  private static void applySpansForTag(StartTag startTag, SpannableStringBuilder spannedText) {
     switch(startTag.name) {
       case TAG_BOLD:
         spannedText.setSpan(new StyleSpan(STYLE_BOLD), startTag.position,
@@ -191,7 +373,7 @@ private void applySpansForTag(StartTag startTag, SpannableStringBuilder spannedT
    * @return an array of <code>String</code>s with the tag name at pos 0 followed by style classes
    *    or null if it's an empty tag: '&lt;&gt;'
    */
-  private String[] tokenizeTag(String fullTagExpression) {
+  private static String[] tokenizeTag(String fullTagExpression) {
     fullTagExpression = fullTagExpression.replace("\\s+", " ").trim();
     if (fullTagExpression.length() == 0) {
       return null;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
index aca43b451f..3484259724 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
@@ -15,22 +15,14 @@
  */
 package com.google.android.exoplayer.text.webvtt;
 
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
 
-import android.text.Layout.Alignment;
 import android.text.TextUtils;
-import android.util.Log;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * A simple WebVTT parser.
@@ -39,18 +31,14 @@
  */
 public final class WebvttParser implements SubtitleParser {
 
-  private static final String TAG = "WebvttParser";
-
-  private static final Pattern CUE_SETTING = Pattern.compile("(\\S+?):(\\S+)");
-
   private final WebvttCueParser cueParser;
-  private final PositionHolder positionHolder;
-  private final StringBuilder textBuilder;
+  private final ParsableByteArray parsableWebvttData;
+  private final WebvttCue.Builder webvttCueBuilder;
 
   public WebvttParser() {
-    this.cueParser = new WebvttCueParser();
-    positionHolder = new PositionHolder();
-    textBuilder = new StringBuilder();
+    cueParser = new WebvttCueParser();
+    parsableWebvttData = new ParsableByteArray();
+    webvttCueBuilder = new WebvttCue.Builder();
   }
 
   @Override
@@ -59,190 +47,22 @@ public final boolean canParse(String mimeType) {
   }
 
   @Override
-  public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
-    BufferedReader webvttData = new BufferedReader(new InputStreamReader(inputStream, C.UTF8_NAME));
+  public final WebvttSubtitle parse(byte[] bytes, int offset, int length) throws ParserException {
+    parsableWebvttData.reset(bytes, offset + length);
+    parsableWebvttData.setPosition(offset);
+    webvttCueBuilder.reset(); // In case a previous parse run failed with a ParserException.
 
     // Validate the first line of the header, and skip the remainder.
-    WebvttParserUtil.validateWebvttHeaderLine(webvttData);
-    while (!TextUtils.isEmpty(webvttData.readLine())) {}
+    WebvttParserUtil.validateWebvttHeaderLine(parsableWebvttData);
+    while (!TextUtils.isEmpty(parsableWebvttData.readLine())) {}
 
-    // Process the cues and text.
+    // Extract Cues
     ArrayList<WebvttCue> subtitles = new ArrayList<>();
-    Matcher cueHeaderMatcher;
-    while ((cueHeaderMatcher = WebvttParserUtil.findNextCueHeader(webvttData)) != null) {
-      long cueStartTime;
-      long cueEndTime;
-      try {
-        // Parse the cue start and end times.
-        cueStartTime = WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(1));
-        cueEndTime = WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(2));
-      } catch (NumberFormatException e) {
-        Log.w(TAG, "Skipping cue with bad header: " + cueHeaderMatcher.group());
-        continue;
-      }
-
-      // Default cue settings.
-      Alignment cueTextAlignment = null;
-      float cueLine = Cue.DIMEN_UNSET;
-      int cueLineType = Cue.TYPE_UNSET;
-      int cueLineAnchor = Cue.TYPE_UNSET;
-      float cuePosition = Cue.DIMEN_UNSET;
-      int cuePositionAnchor = Cue.TYPE_UNSET;
-      float cueWidth = Cue.DIMEN_UNSET;
-
-      // Parse the cue settings list.
-      Matcher cueSettingMatcher = CUE_SETTING.matcher(cueHeaderMatcher.group(3));
-      while (cueSettingMatcher.find()) {
-        String name = cueSettingMatcher.group(1);
-        String value = cueSettingMatcher.group(2);
-        try {
-          if ("line".equals(name)) {
-            parseLineAttribute(value, positionHolder);
-            cueLine = positionHolder.position;
-            cueLineType = positionHolder.lineType;
-            cueLineAnchor = positionHolder.positionAnchor;
-          } else if ("align".equals(name)) {
-            cueTextAlignment = parseTextAlignment(value);
-          } else if ("position".equals(name)) {
-            parsePositionAttribute(value, positionHolder);
-            cuePosition = positionHolder.position;
-            cuePositionAnchor = positionHolder.positionAnchor;
-          } else if ("size".equals(name)) {
-            cueWidth = parsePercentage(value);
-          } else {
-            Log.w(TAG, "Unknown cue setting " + name + ":" + value);
-          }
-        } catch (NumberFormatException e) {
-          Log.w(TAG, "Skipping bad cue setting: " + cueSettingMatcher.group());
-        }
-      }
-
-      if (cuePosition != Cue.DIMEN_UNSET && cuePositionAnchor == Cue.TYPE_UNSET) {
-        // Computed position alignment should be derived from the text alignment if it has not been
-        // set explicitly.
-        cuePositionAnchor = alignmentToAnchor(cueTextAlignment);
-      }
-
-      // Parse the cue text.
-      textBuilder.setLength(0);
-      String line;
-      while ((line = webvttData.readLine()) != null && !line.isEmpty()) {
-        if (textBuilder.length() > 0) {
-          textBuilder.append("\n");
-        }
-        textBuilder.append(line.trim());
-      }
-
-      CharSequence cueText = cueParser.parse(textBuilder.toString());
-
-      WebvttCue cue = new WebvttCue(cueStartTime, cueEndTime, cueText, cueTextAlignment, cueLine,
-          cueLineType, cueLineAnchor, cuePosition, cuePositionAnchor, cueWidth);
-      subtitles.add(cue);
+    while (cueParser.parseNextValidCue(parsableWebvttData, webvttCueBuilder)) {
+      subtitles.add(webvttCueBuilder.build());
+      webvttCueBuilder.reset();
     }
-
     return new WebvttSubtitle(subtitles);
   }
 
-  private static void parseLineAttribute(String s, PositionHolder out)
-      throws NumberFormatException {
-    int lineAnchor;
-    int commaPosition = s.indexOf(",");
-    if (commaPosition != -1) {
-      lineAnchor = parsePositionAnchor(s.substring(commaPosition + 1));
-      s = s.substring(0, commaPosition);
-    } else {
-      lineAnchor = Cue.TYPE_UNSET;
-    }
-    float line;
-    int lineType;
-    if (s.endsWith("%")) {
-      line = parsePercentage(s);
-      lineType = Cue.LINE_TYPE_FRACTION;
-    } else {
-      line = Integer.parseInt(s);
-      lineType = Cue.LINE_TYPE_NUMBER;
-    }
-    out.position = line;
-    out.positionAnchor = lineAnchor;
-    out.lineType = lineType;
-  }
-
-  private static void parsePositionAttribute(String s, PositionHolder out)
-      throws NumberFormatException {
-    int positionAnchor;
-    int commaPosition = s.indexOf(",");
-    if (commaPosition != -1) {
-      positionAnchor = parsePositionAnchor(s.substring(commaPosition + 1));
-      s = s.substring(0, commaPosition);
-    } else {
-      positionAnchor = Cue.TYPE_UNSET;
-    }
-    out.position = parsePercentage(s);
-    out.positionAnchor = positionAnchor;
-    out.lineType = Cue.TYPE_UNSET;
-  }
-
-  private static float parsePercentage(String s) throws NumberFormatException {
-    if (!s.endsWith("%")) {
-      throw new NumberFormatException("Percentages must end with %");
-    }
-    s = s.substring(0, s.length() - 1);
-    return Float.parseFloat(s) / 100;
-  }
-
-  private static int parsePositionAnchor(String s) {
-    switch (s) {
-      case "start":
-        return Cue.ANCHOR_TYPE_START;
-      case "middle":
-        return Cue.ANCHOR_TYPE_MIDDLE;
-      case "end":
-        return Cue.ANCHOR_TYPE_END;
-      default:
-        Log.w(TAG, "Invalid anchor value: " + s);
-        return Cue.TYPE_UNSET;
-    }
-  }
-
-  private static Alignment parseTextAlignment(String s) {
-    switch (s) {
-      case "start":
-      case "left":
-        return Alignment.ALIGN_NORMAL;
-      case "middle":
-        return Alignment.ALIGN_CENTER;
-      case "end":
-      case "right":
-        return Alignment.ALIGN_OPPOSITE;
-      default:
-        Log.w(TAG, "Invalid alignment value: " + s);
-        return null;
-    }
-  }
-
-  private static int alignmentToAnchor(Alignment alignment) {
-    if (alignment == null) {
-      return Cue.TYPE_UNSET;
-    }
-    switch (alignment) {
-      case ALIGN_NORMAL:
-        return Cue.ANCHOR_TYPE_START;
-      case ALIGN_CENTER:
-        return Cue.ANCHOR_TYPE_MIDDLE;
-      case ALIGN_OPPOSITE:
-        return Cue.ANCHOR_TYPE_END;
-      default:
-        Log.w(TAG, "Unrecognized alignment: " + alignment);
-        return Cue.ANCHOR_TYPE_START;
-    }
-  }
-
-  private static final class PositionHolder {
-
-    public float position;
-    public int positionAnchor;
-    public int lineType;
-
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java
index 1ecc299196..4c1a90531a 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java
@@ -16,10 +16,8 @@
 package com.google.android.exoplayer.text.webvtt;
 
 import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.util.ParsableByteArray;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 /**
@@ -28,8 +26,6 @@
 public final class WebvttParserUtil {
 
   private static final Pattern HEADER = Pattern.compile("^\uFEFF?WEBVTT((\u0020|\u0009).*)?$");
-  private static final Pattern COMMENT = Pattern.compile("^NOTE((\u0020|\u0009).*)?$");
-  private static final Pattern CUE_HEADER = Pattern.compile("^(\\S+)\\s+-->\\s+(\\S+)(.*)?$");
 
   private WebvttParserUtil() {}
 
@@ -38,40 +34,14 @@ private WebvttParserUtil() {}
    *
    * @param input The input from which the line should be read.
    * @throws ParserException If the line isn't the start of a valid WebVTT file.
-   * @throws IOException If an error occurs reading from the input.
    */
-  public static void validateWebvttHeaderLine(BufferedReader input) throws IOException {
+  public static void validateWebvttHeaderLine(ParsableByteArray input) throws ParserException {
     String line = input.readLine();
     if (line == null || !HEADER.matcher(line).matches()) {
       throw new ParserException("Expected WEBVTT. Got " + line);
     }
   }
 
-  /**
-   * Reads lines up to and including the next WebVTT cue header.
-   *
-   * @param input The input from which lines should be read.
-   * @throws IOException If an error occurs reading from the input.
-   * @return A {@link Matcher} for the WebVTT cue header, or null if the end of the input was
-   *     reached without a cue header being found. In the case that a cue header is found, groups 1,
-   *     2 and 3 of the returned matcher contain the start time, end time and settings list.
-   */
-  public static Matcher findNextCueHeader(BufferedReader input) throws IOException {
-    String line;
-    while ((line = input.readLine()) != null) {
-      if (COMMENT.matcher(line).matches()) {
-        // Skip until the end of the comment block.
-        while ((line = input.readLine()) != null && !line.isEmpty()) {}
-      } else {
-        Matcher cueHeaderMatcher = CUE_HEADER.matcher(line);
-        if (cueHeaderMatcher.matches()) {
-          return cueHeaderMatcher;
-        }
-      }
-    }
-    return null;
-  }
-
   /**
    * Parses a WebVTT timestamp.
    *
@@ -89,4 +59,17 @@ public static long parseTimestampUs(String timestamp) throws NumberFormatExcepti
     return (value * 1000 + Long.parseLong(parts[1])) * 1000;
   }
 
+  /**
+   * Parses a percentage and returns a scaled float.
+   * @param s contains the number to parse.
+   * @return a float scaled number. 1.0 represents 100%.
+   * @throws NumberFormatException if the number format is invalid or does not end with '%'.
+   */
+  public static float parsePercentage(String s) throws NumberFormatException {
+    if (!s.endsWith("%")) {
+      throw new NumberFormatException("Percentages must end with %");
+    }
+    return Float.parseFloat(s.substring(0, s.length() - 1)) / 100;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
index 72062a51ac..c65e8b3ffc 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
@@ -152,7 +152,7 @@ public static MediaFormat parseAc3SyncframeFormat(ParsableBitArray data, String
    */
   public static MediaFormat parseEac3SyncframeFormat(ParsableBitArray data, String trackId,
       long durationUs, String language) {
-    data.skipBits(16 + 2 + 11); // syncword, strmtype, frmsiz
+    data.skipBits(16 + 2 + 3 + 11); // syncword, strmtype, substreamid, frmsiz
     int sampleRate;
     int fscod = data.readBits(2);
     if (fscod == 3) {
@@ -235,8 +235,6 @@ private static int getAc3SyncframeSize(int fscod, int frmsizecod) {
     }
   }
 
-  private Ac3Util() {
-    // Prevent instantiation.
-  }
+  private Ac3Util() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/DtsUtil.java b/library/src/main/java/com/google/android/exoplayer/util/DtsUtil.java
new file mode 100644
index 0000000000..5fa6e3e6e4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/DtsUtil.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import com.google.android.exoplayer.MediaFormat;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Utility methods for parsing DTS frames.
+ */
+public final class DtsUtil {
+
+  /**
+   * Maps AMODE to the number of channels. See ETSI TS 102 114 table 5.4.
+   */
+  private static final int[] CHANNELS_BY_AMODE = new int[] {1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6,
+      7, 8, 8};
+
+  /**
+   * Maps SFREQ to the sampling frequency in Hz. See ETSI TS 102 144 table 5.5.
+   */
+  private static final int[] SAMPLE_RATE_BY_SFREQ = new int[] {-1, 8000, 16000, 32000, -1, -1,
+      11025, 22050, 44100, -1, -1, 12000, 24000, 48000, -1, -1};
+
+  /**
+   * Maps RATE to 2 * bitrate in kbit/s. See ETSI TS 102 144 table 5.7.
+   */
+  private static final int[] TWICE_BITRATE_KBPS_BY_RATE = new int[] {64, 112, 128, 192, 224, 256,
+      384, 448, 512, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 2048, 2304, 2560, 2688, 2816,
+      2823, 2944, 3072, 3840, 4096, 6144, 7680};
+
+  private static final ParsableBitArray SCRATCH_BITS = new ParsableBitArray();
+
+  /**
+   * Returns the DTS format given {@code data} containing the DTS frame according to ETSI TS 102 114
+   * subsections 5.3/5.4.
+   * <p>
+   * This method may only be called from one thread at a time.
+   *
+   * @param frame The DTS frame to parse.
+   * @param trackId The track identifier to set on the format, or null.
+   * @param durationUs The duration to set on the format, in microseconds.
+   * @param language The language to set on the format.
+   * @return The DTS format parsed from data in the header.
+   */
+  public static MediaFormat parseDtsFormat(byte[] frame, String trackId, long durationUs,
+      String language) {
+    ParsableBitArray frameBits = SCRATCH_BITS;
+    frameBits.reset(frame);
+    frameBits.skipBits(4 * 8 + 1 + 5 + 1 + 7 + 14); // SYNC, FTYPE, SHORT, CPF, NBLKS, FSIZE
+    int amode = frameBits.readBits(6);
+    int channelCount = CHANNELS_BY_AMODE[amode];
+    int sfreq = frameBits.readBits(4);
+    int sampleRate = SAMPLE_RATE_BY_SFREQ[sfreq];
+    int rate = frameBits.readBits(5);
+    int bitrate = rate >= TWICE_BITRATE_KBPS_BY_RATE.length ? MediaFormat.NO_VALUE
+        : TWICE_BITRATE_KBPS_BY_RATE[rate] * 1000 / 2;
+    frameBits.skipBits(10); // MIX, DYNF, TIMEF, AUXF, HDCD, EXT_AUDIO_ID, EXT_AUDIO, ASPF
+    channelCount += frameBits.readBits(2) > 0 ? 1 : 0; // LFF
+    return MediaFormat.createAudioFormat(trackId, MimeTypes.AUDIO_DTS, bitrate,
+        MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate, null, language);
+  }
+
+  /**
+   * Returns the number of audio samples represented by the given DTS frame.
+   *
+   * @param data The frame to parse.
+   * @return The number of audio samples represented by the frame.
+   */
+  public static int parseDtsAudioSampleCount(byte[] data) {
+    // See ETSI TS 102 114 subsection 5.4.1.
+    int nblks = ((data[4] & 0x01) << 6) | ((data[5] & 0xFC) >> 2);
+    return (nblks + 1) * 32;
+  }
+
+  /**
+   * Like {@link #parseDtsAudioSampleCount(byte[])} but reads from a byte buffer. The buffer
+   * position is not modified.
+   */
+  public static int parseDtsAudioSampleCount(ByteBuffer data) {
+    // See ETSI TS 102 114 subsection 5.4.1.
+    int position = data.position();
+    int nblks = ((data.get(position + 4) & 0x01) << 6)
+        | ((data.get(position + 5) & 0xFC) >> 2);
+    return (nblks + 1) * 32;
+  }
+
+  /**
+   * Returns the size in bytes of the given DTS frame.
+   *
+   * @param data The frame to parse.
+   * @return The frame's size in bytes.
+   */
+  public static int getDtsFrameSize(byte[] data) {
+    return (((data[5] & 0x02) << 12)
+        | ((data[6] & 0xFF) << 4)
+        | ((data[7] & 0xF0) >> 4)) + 1;
+  }
+
+  private DtsUtil() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 0f27a5b9ff..38564f1ce5 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -65,6 +65,7 @@
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
   public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
+  public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4vtt";
 
   private MimeTypes() {}
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java b/library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java
index 2606235883..92f2c05db9 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java
@@ -172,7 +172,8 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
 
     String mimeType = MIME_TYPE_BY_LAYER[3 - layer];
     int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
-    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
+    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate * 1000,
+        samplesPerFrame);
     return true;
   }
 
@@ -186,13 +187,13 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
   public int sampleRate;
   /** Number of audio channels in the frame. */
   public int channels;
-  /** Bitrate of the frame in kbit/s. */
+  /** Bitrate of the frame in bit/s. */
   public int bitrate;
   /** Number of samples stored in the frame. */
   public int samplesPerFrame;
 
-  private void setValues(int version, String mimeType, int frameSize,
-      int sampleRate, int channels, int bitrate, int samplesPerFrame) {
+  private void setValues(int version, String mimeType, int frameSize, int sampleRate, int channels,
+      int bitrate, int samplesPerFrame) {
     this.version = version;
     this.mimeType = mimeType;
     this.frameSize = frameSize;
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 4bc8313dfe..8beff5f9cb 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.util;
 
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 
 /**
  * Wraps a byte array, providing a set of methods for parsing data from it. Numerical values are
@@ -170,12 +171,22 @@ public int readUnsignedShort() {
         | (data[position++] & 0xFF);
   }
 
+  /** Reads the next two bytes as an unsigned value. */
+  public int readLittleEndianUnsignedShort() {
+    return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8;
+  }
+
   /** Reads the next two bytes as an signed value. */
   public short readShort() {
     return (short) ((data[position++] & 0xFF) << 8
         | (data[position++] & 0xFF));
   }
 
+  /** Reads the next two bytes as a signed value. */
+  public short readLittleEndianShort() {
+    return (short) ((data[position++] & 0xFF) | (data[position++] & 0xFF) << 8);
+  }
+
   /** Reads the next three bytes as an unsigned value. */
   public int readUnsignedInt24() {
     return (data[position++] & 0xFF) << 16
@@ -183,6 +194,13 @@ public int readUnsignedInt24() {
         | (data[position++] & 0xFF);
   }
 
+  /**  Reads the next three bytes as an unsigned value in little endian order. */
+  public int readLittleEndianUnsignedInt24() {
+    return (data[position++] & 0xFF)
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF) << 16;
+  }
+
   /** Reads the next four bytes as an unsigned value. */
   public long readUnsignedInt() {
     return (data[position++] & 0xFFL) << 24
@@ -191,6 +209,14 @@ public long readUnsignedInt() {
         | (data[position++] & 0xFFL);
   }
 
+  /** Reads the next four bytes as an unsigned value in little endian order. */
+  public long readLittleEndianUnsignedInt() {
+    return (data[position++] & 0xFFL)
+        | (data[position++] & 0xFFL) << 8
+        | (data[position++] & 0xFFL) << 16
+        | (data[position++] & 0xFFL) << 24;
+  }
+
   /** Reads the next four bytes as a signed value. */
   public int readInt() {
     return (data[position++] & 0xFF) << 24
@@ -199,6 +225,14 @@ public int readInt() {
         | (data[position++] & 0xFF);
   }
 
+  /** Reads the next four bytes as an signed value in little endian order. */
+  public int readLittleEndianInt() {
+    return (data[position++] & 0xFF)
+        | (data[position++]  & 0xFF) << 8
+        | (data[position++]  & 0xFF) << 16
+        | (data[position++]  & 0xFF) << 24;
+  }
+
   /** Reads the next eight bytes as a signed value. */
   public long readLong() {
     return (data[position++] & 0xFFL) << 56
@@ -211,6 +245,18 @@ public long readLong() {
         | (data[position++] & 0xFFL);
   }
 
+  /** Reads the next eight bytes as a signed value in little endian order. */
+  public long readLittleEndianLong() {
+    return (data[position++] & 0xFFL)
+        | (data[position++] & 0xFFL) << 8
+        | (data[position++] & 0xFFL) << 16
+        | (data[position++] & 0xFFL) << 24
+        | (data[position++] & 0xFFL) << 32
+        | (data[position++] & 0xFFL) << 40
+        | (data[position++] & 0xFFL) << 48
+        | (data[position++] & 0xFFL) << 56;
+  }
+
   /** Reads the next four bytes, returning the integer portion of the fixed point 16.16 integer. */
   public int readUnsignedFixedPoint1616() {
     int result = (data[position++] & 0xFF) << 8
@@ -261,4 +307,67 @@ public long readUnsignedLongToLong() {
     return result;
   }
 
+  /**
+   * Reads the next {@code length} bytes as UTF-8 characters.
+   *
+   * @param length The number of bytes to read.
+   * @return The string encoded by the bytes.
+   */
+  public String readString(int length) {
+    return readString(length, Charset.defaultCharset());
+  }
+
+  /**
+   * Reads the next {@code length} bytes as characters in the specified {@link Charset}.
+   *
+   * @param length The number of bytes to read.
+   * @param charset The character set of the encoded characters.
+   * @return The string encoded by the bytes in the specified character set.
+   */
+  public String readString(int length, Charset charset) {
+    String result = new String(data, position, length, charset);
+    position += length;
+    return result;
+  }
+
+  /**
+   * Reads a line of text.
+   * <p>
+   * A line is considered to be terminated by any one of a carriage return ('\r'), a line feed
+   * ('\n'), or a carriage return followed immediately by a line feed ('\r\n'). The system's default
+   * charset (UTF-8) is used.
+   *
+   * @return A String containing the contents of the line, not including any line-termination
+   *     characters, or null if the end of the stream has been reached.
+   */
+  public String readLine() {
+    if (bytesLeft() == 0) {
+      return null;
+    }
+    int lineLimit = position;
+    while (lineLimit < limit && data[lineLimit] != '\n' && data[lineLimit] != '\r') {
+      lineLimit++;
+    }
+    if (lineLimit - position >= 3 && data[position] == (byte) 0xEF
+        && data[position + 1] == (byte) 0xBB && data[position + 2] == (byte) 0xBF) {
+      // There's a byte order mark at the start of the line. Discard it.
+      position += 3;
+    }
+    String line = new String(data, position, lineLimit - position);
+    position = lineLimit;
+    if (position == limit) {
+      return line;
+    }
+    if (data[position] == '\r') {
+      position++;
+      if (position == limit) {
+        return line;
+      }
+    }
+    if (data[position] == '\n') {
+      position++;
+    }
+    return line;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java b/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java
index 32136889a7..105c5a5838 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java
@@ -47,4 +47,5 @@ public static boolean isStartTag(XmlPullParser xpp) throws XmlPullParserExceptio
   public static String removeNamespacePrefix(String attributeName) {
     return attributeName.replaceFirst("^.*:", "");
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index ae9db72916..edff76bdd6 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -62,25 +62,48 @@
    * Like {@link android.os.Build.VERSION#SDK_INT}, but in a place where it can be conveniently
    * overridden for local testing.
    */
-  public static final int SDK_INT = android.os.Build.VERSION.SDK_INT;
+  public static final int SDK_INT =
+      (Build.VERSION.SDK_INT == 23 && Build.VERSION.CODENAME.charAt(0) == 'N') ? 24
+      : Build.VERSION.SDK_INT;
 
   /**
-   * Like {@link android.os.Build#DEVICE}, but in a place where it can be conveniently overridden
-   * for local testing.
+   * Like {@link Build#DEVICE}, but in a place where it can be conveniently overridden for local
+   * testing.
    */
-  public static final String DEVICE = android.os.Build.DEVICE;
+  public static final String DEVICE = Build.DEVICE;
 
   /**
-   * Like {@link android.os.Build#MANUFACTURER}, but in a place where it can be conveniently
-   * overridden for local testing.
+   * Like {@link Build#MANUFACTURER}, but in a place where it can be conveniently overridden for
+   * local testing.
    */
-  public static final String MANUFACTURER = android.os.Build.MANUFACTURER;
+  public static final String MANUFACTURER = Build.MANUFACTURER;
 
   /**
-   * Like {@link android.os.Build#MODEL}, but in a place where it can be conveniently overridden for
-   * local testing.
+   * Like {@link Build#MODEL}, but in a place where it can be conveniently overridden for local
+   * testing.
+   */
+  public static final String MODEL = Build.MODEL;
+
+  /**
+   * Value returned by {@link #inferContentType(String)} for DASH manifests.
+   */
+  public static final int TYPE_DASH = 0;
+
+  /**
+   * Value returned by {@link #inferContentType(String)} for Smooth Streaming manifests.
+   */
+  public static final int TYPE_SS = 1;
+
+  /**
+   * Value returned by {@link #inferContentType(String)} for HLS manifests.
+   */
+  public static final int TYPE_HLS = 2;
+
+  /**
+   * Value returned by {@link #inferContentType(String)} for files other than DASH, HLS or Smooth
+   * Streaming manifests.
    */
-  public static final String MODEL = android.os.Build.MODEL;
+  public static final int TYPE_OTHER = 3;
 
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
@@ -106,6 +129,24 @@ public static boolean isAndroidTv(Context context) {
     return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
   }
 
+  /**
+   * Converts the entirety of an {@link InputStream} to a byte array.
+   *
+   * @param inputStream the {@link InputStream} to be read. The input stream is not closed by this
+   *    method.
+   * @return a byte array containing all of the inputStream's bytes.
+   * @throws IOException if an error occurs reading from the stream.
+   */
+  public static byte[] toByteArray(InputStream inputStream) throws IOException {
+    byte[] buffer = new byte[1024 * 4];
+    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    int bytesRead;
+    while ((bytesRead = inputStream.read(buffer)) != -1) {
+      outputStream.write(buffer, 0, bytesRead);
+    }
+    return outputStream.toByteArray();
+  }
+
   /**
    * Returns true if the URI is a path to a local file or a reference to a local file.
    *
@@ -699,13 +740,7 @@ public static String getUserAgent(Context context, String applicationName) {
       // Read and return the response body.
       InputStream inputStream = urlConnection.getInputStream();
       try {
-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-        byte scratch[] = new byte[1024];
-        int bytesRead;
-        while ((bytesRead = inputStream.read(scratch)) != -1) {
-          byteArrayOutputStream.write(scratch, 0, bytesRead);
-        }
-        return byteArrayOutputStream.toByteArray();
+        return toByteArray(inputStream);
       } finally {
         inputStream.close();
       }
@@ -716,4 +751,23 @@ public static String getUserAgent(Context context, String applicationName) {
     }
   }
 
+  /**
+   * Makes a best guess to infer the type from a file name.
+   *
+   * @param fileName Name of the file. It can include the path of the file.
+   * @return One of {@link #TYPE_DASH}, {@link #TYPE_SS}, {@link #TYPE_HLS} or {@link #TYPE_OTHER}.
+   */
+  public static int inferContentType(String fileName) {
+    if (fileName == null) {
+      return TYPE_OTHER;
+    } else if (fileName.endsWith(".mpd")) {
+      return TYPE_DASH;
+    } else if (fileName.endsWith(".ism")) {
+      return TYPE_SS;
+    } else if (fileName.endsWith(".m3u8")) {
+      return TYPE_HLS;
+    } else {
+      return TYPE_OTHER;
+    }
+  }
 }
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 0d88e48c57..9aeb5b1478 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
     android:versionCode="1503"
-    android:versionName="1.5.3">
+    android:versionName="1.5.4">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index 36766ce130..b50b17ac6b 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
+import com.google.android.exoplayer.MediaCodecUtil;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
@@ -38,15 +40,18 @@
 import com.google.android.exoplayer.playbacktests.util.ExoHostedTest;
 import com.google.android.exoplayer.playbacktests.util.HostActivity;
 import com.google.android.exoplayer.playbacktests.util.LogcatLogger;
+import com.google.android.exoplayer.playbacktests.util.MetricsLogger;
 import com.google.android.exoplayer.playbacktests.util.TestUtil;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
 import android.media.MediaCodec;
+import android.os.Bundle;
 import android.os.Handler;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
@@ -73,11 +78,11 @@
   private static final String MANIFEST_URL_PREFIX = "https://storage.googleapis.com/exoplayer-test-"
       + "media-1/gen-2/screens/dash-vod-single-segment/";
   private static final String H264_MANIFEST = "manifest-h264.mpd";
+  private static final String H265_MANIFEST = "manifest-h265.mpd";
   private static final String VP9_MANIFEST = "manifest-vp9.mpd";
   private static final int AAC_AUDIO_FRAME_COUNT = 5524;
-  private static final int H264_VIDEO_FRAME_COUNT = 3841;
+  private static final int VIDEO_FRAME_COUNT = 3841;
   private static final int VORBIS_AUDIO_FRAME_COUNT = 7773;
-  private static final int VP9_VIDEO_FRAME_COUNT = 3841;
 
   private static final String AAC_AUDIO_REPRESENTATION_ID = "141";
   private static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
@@ -98,9 +103,26 @@
           H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
           H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
 
+  private static final String H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "hevc-main-288";
+  private static final String H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "hevc-main-360";
+  // The highest quality H265 format mandated by the Android CDD.
+  private static final String H265_CDD_FIXED = H265_BASELINE_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple H265 formats mandated by the Android CDD.
+  private static final String[] H265_CDD_ADAPTIVE =
+      new String[] {
+          H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
+          H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
+
   private static final String VORBIS_AUDIO_REPRESENTATION_ID = "2";
   private static final String VP9_180P_VIDEO_REPRESENTATION_ID = "0";
   private static final String VP9_360P_VIDEO_REPRESENTATION_ID = "1";
+  // The highest quality VP9 format mandated by the Android CDD.
+  private static final String VP9_CDD_FIXED = VP9_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple VP9 formats mandated by the Android CDD.
+  private static final String[] VP9_CDD_ADAPTIVE =
+      new String[] {
+          VP9_180P_VIDEO_REPRESENTATION_ID,
+          VP9_360P_VIDEO_REPRESENTATION_ID};
 
   // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
   // if the device advertises support for them.
@@ -154,40 +176,89 @@ public void testH264Fixed() throws IOException {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), AAC_AUDIO_FRAME_COUNT, H264_VIDEO_FRAME_COUNT,
+    String testName = "testH264Fixed";
+    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
         H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, H264_CDD_FIXED);
   }
 
   public void testH264Adaptive() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), AAC_AUDIO_FRAME_COUNT, H264_VIDEO_FRAME_COUNT,
+    String testName = "testH264Adaptive";
+    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
         H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
         H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), SEEKING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
-        H264_VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+    String testName = "testH264AdaptiveWithSeeking";
+    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
+        VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
         ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), RENDERER_DISABLING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
-        H264_VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+    String testName = "testH264AdaptiveWithRendererDisabling";
+    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
+        AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
         ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
+  // H265 CDD.
+
+  public void testH265Fixed() throws IOException {
+    if (Util.SDK_INT < 21) {
+      // Pass.
+      return;
+    }
+    String testName = "testH265Fixed";
+    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
+        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, H265_CDD_FIXED);
+  }
+
+  public void testH265Adaptive() throws IOException {
+    if (Util.SDK_INT < 21 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+      // Pass.
+      return;
+    }
+    String testName = "testH265Adaptive";
+    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
+        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        H265_CDD_ADAPTIVE);
+  }
+
+  public void testH265AdaptiveWithSeeking() throws IOException {
+    if (Util.SDK_INT < 21 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+      // Pass.
+      return;
+    }
+    String testName = "testH265AdaptiveWithSeeking";
+    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
+        VIDEO_FRAME_COUNT, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+  }
+
+  public void testH265AdaptiveWithRendererDisabling() throws IOException {
+    if (Util.SDK_INT < 21 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+      // Pass.
+      return;
+    }
+    String testName = "testH265AdaptiveWithRendererDisabling";
+    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
+        AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+    }
+
   // VP9 (CDD).
 
   public void testVp9Fixed360p() throws IOException {
@@ -195,59 +266,64 @@ public void testVp9Fixed360p() throws IOException {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), VORBIS_AUDIO_FRAME_COUNT, VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST,
-        VORBIS_AUDIO_REPRESENTATION_ID, false, VP9_360P_VIDEO_REPRESENTATION_ID);
+    String testName = "testVp9Fixed360p";
+    testDashPlayback(getActivity(), testName, VORBIS_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
+        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false, VP9_CDD_FIXED);
   }
 
   public void testVp9Adaptive() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), VORBIS_AUDIO_FRAME_COUNT, VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST,
-        VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        VP9_180P_VIDEO_REPRESENTATION_ID, VP9_360P_VIDEO_REPRESENTATION_ID);
+    String testName = "testVp9Adaptive";
+    testDashPlayback(getActivity(), testName, VORBIS_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
+        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), SEEKING_SCHEDULE, false, VORBIS_AUDIO_FRAME_COUNT,
-        VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_180P_VIDEO_REPRESENTATION_ID,
-        VP9_360P_VIDEO_REPRESENTATION_ID);
+    String testName = "testVp9AdaptiveWithSeeking";
+    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, VORBIS_AUDIO_FRAME_COUNT,
+        VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
-    testDashPlayback(getActivity(), RENDERER_DISABLING_SCHEDULE, false, VORBIS_AUDIO_FRAME_COUNT,
-        VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_180P_VIDEO_REPRESENTATION_ID,
-        VP9_360P_VIDEO_REPRESENTATION_ID);
+    String testName = "testVp9AdaptiveWithRendererDisabling";
+    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
+        VORBIS_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   // Internal.
 
-  private static void testDashPlayback(HostActivity activity, int sourceAudioFrameCount,
-      int sourceVideoFrameCount, String manifestFileName, String audioFormat,
-      boolean includeAdditionalVideoFormats, String... videoFormats) throws IOException {
-    testDashPlayback(activity, null, true, sourceAudioFrameCount, sourceVideoFrameCount,
-        manifestFileName, audioFormat, includeAdditionalVideoFormats, videoFormats);
+  private void testDashPlayback(HostActivity activity, String testName,
+      int sourceAudioFrameCount, int sourceVideoFrameCount, String manifestFileName,
+      String audioFormat, boolean includeAdditionalVideoFormats, String... videoFormats)
+      throws IOException {
+    testDashPlayback(activity, testName, null, true, sourceAudioFrameCount,
+        sourceVideoFrameCount, manifestFileName, audioFormat, includeAdditionalVideoFormats,
+        videoFormats);
   }
 
-  private static void testDashPlayback(HostActivity activity, ActionSchedule actionSchedule,
-      boolean fullPlaybackNoSeeking, int sourceAudioFrameCount, int sourceVideoFrameCount,
-      String manifestFileName, String audioFormat, boolean includeAdditionalVideoFormats,
-      String... videoFormats) throws IOException {
+  private void testDashPlayback(HostActivity activity, String testName,
+      ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, int sourceAudioFrameCount,
+      int sourceVideoFrameCount, String manifestFileName, String audioFormat,
+      boolean includeAdditionalVideoFormats, String... videoFormats) throws IOException {
     MediaPresentationDescription mpd = TestUtil.loadManifest(activity,
         MANIFEST_URL_PREFIX + manifestFileName, new MediaPresentationDescriptionParser());
-    DashHostedTest test = new DashHostedTest(mpd, fullPlaybackNoSeeking, sourceAudioFrameCount,
-        sourceVideoFrameCount, audioFormat, includeAdditionalVideoFormats,
+    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG);
+    DashHostedTest test = new DashHostedTest(testName, mpd, metricsLogger, fullPlaybackNoSeeking,
+        sourceAudioFrameCount, sourceVideoFrameCount, audioFormat, includeAdditionalVideoFormats,
         videoFormats);
     if (actionSchedule != null) {
       test.setSchedule(actionSchedule);
@@ -255,6 +331,14 @@ private static void testDashPlayback(HostActivity activity, ActionSchedule actio
     activity.runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
   }
 
+  private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
+    if (!MediaCodecUtil.getDecoderInfo(mimeType, false).adaptive) {
+      assertTrue(Util.SDK_INT < 21);
+      return true;
+    }
+    return false;
+  }
+
   @TargetApi(16)
   private static class DashHostedTest extends ExoHostedTest {
 
@@ -271,19 +355,23 @@ private static void testDashPlayback(HostActivity activity, ActionSchedule actio
     private static final int VIDEO_EVENT_ID = 0;
     private static final int AUDIO_EVENT_ID = 1;
 
+    private final String testName;
     private final MediaPresentationDescription mpd;
+    private final MetricsLogger metricsLogger;
     private final boolean fullPlaybackNoSeeking;
     private final int sourceAudioFrameCount;
     private final int sourceVideoFrameCount;
-    private String[] audioFormats;
-    private boolean includeAdditionalVideoFormats;
-    private String[] videoFormats;
+    private final boolean includeAdditionalVideoFormats;
+    private final String[] audioFormats;
+    private final String[] videoFormats;
 
     private CodecCounters videoCounters;
     private CodecCounters audioCounters;
 
     /**
+     * @param testName The name of the test.
      * @param mpd The manifest.
+     * @param metricsLogger Logger to log metrics from the test.
      * @param fullPlaybackNoSeeking True if the test will play the entire source with no seeking.
      *     False otherwise.
      * @param sourceAudioFrameCount The number of audio frames in the source.
@@ -293,11 +381,14 @@ private static void testDashPlayback(HostActivity activity, ActionSchedule actio
      *     those listed in the videoFormats argument, if the device is capable of playing them.
      * @param videoFormats The video formats.
      */
-    public DashHostedTest(MediaPresentationDescription mpd, boolean fullPlaybackNoSeeking,
-        int sourceAudioFrameCount, int sourceVideoFrameCount, String audioFormat,
-        boolean includeAdditionalVideoFormats, String... videoFormats) {
+    public DashHostedTest(String testName, MediaPresentationDescription mpd,
+        MetricsLogger metricsLogger, boolean fullPlaybackNoSeeking, int sourceAudioFrameCount,
+        int sourceVideoFrameCount, String audioFormat, boolean includeAdditionalVideoFormats,
+        String... videoFormats) {
       super(RENDERER_COUNT);
+      this.testName = testName;
       this.mpd = Assertions.checkNotNull(mpd);
+      this.metricsLogger = metricsLogger;
       this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
       this.sourceAudioFrameCount = sourceAudioFrameCount;
       this.sourceVideoFrameCount = sourceVideoFrameCount;
@@ -323,7 +414,8 @@ public DashHostedTest(MediaPresentationDescription mpd, boolean fullPlaybackNoSe
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, VIDEO_EVENT_ID,
           MIN_LOADABLE_RETRY_COUNT);
       MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(host,
-          videoSampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 0, handler, logger, 50);
+          videoSampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
+          0, handler, logger, 50);
       videoCounters = videoRenderer.codecCounters;
       player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
 
@@ -337,7 +429,7 @@ public DashHostedTest(MediaPresentationDescription mpd, boolean fullPlaybackNoSe
           AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, AUDIO_EVENT_ID,
           MIN_LOADABLE_RETRY_COUNT);
       MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(
-          audioSampleSource, handler, logger);
+          audioSampleSource, MediaCodecSelector.DEFAULT, handler, logger);
       audioCounters = audioRenderer.codecCounters;
 
       TrackRenderer[] renderers = new TrackRenderer[RENDERER_COUNT];
@@ -347,7 +439,7 @@ public DashHostedTest(MediaPresentationDescription mpd, boolean fullPlaybackNoSe
     }
 
     @Override
-    protected void assertPassedInternal() {
+    protected void assertPassed() {
       if (fullPlaybackNoSeeking) {
         // Audio is not adaptive and we didn't seek (which can re-instantiate the audio decoder
         // in ExoPlayer), so the decoder output format should have changed exactly once. The output
@@ -393,6 +485,24 @@ protected void assertPassedInternal() {
           MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
     }
 
+    @Override
+    protected void logMetrics() {
+      // Create Bundle of metrics from the test.
+      Bundle metrics = new Bundle();
+      metrics.putString(MetricsLogger.KEY_TEST_NAME, testName);
+      metrics.putInt(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
+          videoCounters.droppedOutputBufferCount);
+      metrics.putInt(MetricsLogger.KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT,
+          videoCounters.maxConsecutiveDroppedOutputBufferCount);
+      metrics.putInt(MetricsLogger.KEY_FRAMES_SKIPPED_COUNT,
+          videoCounters.skippedOutputBufferCount);
+      metrics.putInt(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
+          videoCounters.renderedOutputBufferCount);
+
+      // Send metrics for logging.
+      metricsLogger.logMetrics(metrics);
+    }
+
     private static final class TrackSelector implements DashTrackSelector {
 
       private final int adaptationSetType;
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java
index a21ffffa30..075a71d587 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java
@@ -112,11 +112,12 @@ public final boolean isFinished() {
   }
 
   @Override
-  public final void assertPassed() {
+  public final void onFinished() {
     if (failOnPlayerError && playerError != null) {
       throw new Error(playerError);
     }
-    assertPassedInternal();
+    logMetrics();
+    assertPassed();
   }
 
   // ExoPlayer.Listener
@@ -160,10 +161,14 @@ protected void onPlayerErrorInternal(ExoPlaybackException error) {
     // Do nothing. Interested subclasses may override.
   }
 
-  protected void assertPassedInternal() {
+  protected void assertPassed() {
     // Do nothing. Subclasses may override to add additional assertions.
   }
 
+  protected void logMetrics() {
+    // Do nothing. Subclasses may override to log metrics.
+  }
+
   // Utility methods and actions for subclasses.
 
   protected final long getTotalPlayingTimeMs() {
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
index 83c1b51943..73d30d99b3 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
@@ -74,12 +74,12 @@
     boolean isFinished();
 
     /**
-     * Asserts that the test passed.
+     * Called after the test is finished and has been released. Implementations may use this method
+     * to assert that test criteria were met.
      * <p>
-     * Called on the test thread once the test has reported that it's finished and after the test
-     * has been released.
+     * Called on the test thread.
      */
-    void assertPassed();
+    void onFinished();
 
   }
 
@@ -120,7 +120,7 @@ public void run() {
     if (hostedTestReleasedCondition.block(timeoutMs)) {
       if (hostedTestFinished) {
         Log.d(TAG, "Test finished. Checking pass conditions.");
-        hostedTest.assertPassed();
+        hostedTest.onFinished();
         Log.d(TAG, "Pass conditions checked.");
       } else {
         Log.e(TAG, "Test released before it finished. Activity may have been paused whilst test "
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java
new file mode 100644
index 0000000000..07a9524d6c
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.playbacktests.util;
+
+import android.os.Bundle;
+import android.util.Log;
+
+/**
+ * Implementation of {@link MetricsLogger} that prints the metrics to logcat.
+ */
+public final class LogcatMetricsLogger implements MetricsLogger {
+
+  private final String tag;
+
+  public LogcatMetricsLogger(String tag) {
+    this.tag = tag;
+  }
+
+  @Override
+  public void logMetrics(Bundle metrics) {
+    if (metrics != null) {
+      for (String key : metrics.keySet()) {
+        Log.v(tag, key + ": " + metrics.get(key).toString());
+      }
+    }
+  }
+
+}
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java
new file mode 100644
index 0000000000..9bbaf48388
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.playbacktests.util;
+
+import android.app.Instrumentation;
+import android.os.Bundle;
+
+/**
+ * Metric Logging interface for ExoPlayer playback tests.
+ */
+public interface MetricsLogger {
+
+  String KEY_FRAMES_DROPPED_COUNT = "Frames Dropped (Count)";
+  String KEY_FRAMES_RENDERED_COUNT = "Frames Rendered (Count)";
+  String KEY_FRAMES_SKIPPED_COUNT = "Frames Skipped (Count)";
+  String KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT = "Maximum Consecutive Frames Dropped";
+  String KEY_TEST_NAME = "Test Name";
+
+  /**
+   * Logs the metrics provided from a test.
+   *
+   * @param metrics The {@link Bundle} of metrics to be logged.
+   */
+  void logMetrics(Bundle metrics);
+
+  /**
+   * A factory for instantiating MetricsLogger instances.
+   */
+  final class Factory {
+
+    private Factory() {}
+
+    /**
+     * Obtains a new instance of MetricsLogger.
+     *
+     * @param instrumentation The test instrumentation.
+     * @param tag The tag to be used for logcat logs.
+     */
+    public static MetricsLogger createDefault(Instrumentation instrumentation, String tag) {
+      return new LogcatMetricsLogger(tag);
+    }
+  }
+
+}
