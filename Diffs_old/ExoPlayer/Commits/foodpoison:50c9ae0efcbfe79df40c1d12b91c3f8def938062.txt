diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 5ff8644ce4..a067bb4cc9 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -6,6 +6,8 @@
   ([#5868](https://github.com/google/ExoPlayer/issues/5868)).
 * Fix handling of line terminators in SHOUTcast ICY metadata
   ([#5876](https://github.com/google/ExoPlayer/issues/5876)).
+* Assume that encrypted content requires secure decoders in renderer support
+  checks ([#5568](https://github.com/google/ExoPlayer/issues/5568)).
 * Offline: Add option to remove all downloads.
 * Decoders:
   * Prefer codecs that advertise format support over ones that do not, even if
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 2e1bd19f47..c3ec759c2d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -33,7 +33,6 @@
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener.EventDispatcher;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
@@ -283,25 +282,10 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
       // Assume the decoder outputs 16-bit PCM, unless the input is raw.
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
-    boolean requiresSecureDecryption = false;
-    DrmInitData drmInitData = format.drmInitData;
-    if (drmInitData != null) {
-      for (int i = 0; i < drmInitData.schemeDataCount; i++) {
-        requiresSecureDecryption |= drmInitData.get(i).requiresSecureDecryption;
-      }
-    }
     List<MediaCodecInfo> decoderInfos =
-        getDecoderInfos(mediaCodecSelector, format, requiresSecureDecryption);
+        getDecoderInfos(mediaCodecSelector, format, /* requiresSecureDecoder= */ false);
     if (decoderInfos.isEmpty()) {
-      return requiresSecureDecryption
-              && !mediaCodecSelector
-                  .getDecoderInfos(
-                      format.sampleMimeType,
-                      /* requiresSecureDecoder= */ false,
-                      /* requiresTunnelingDecoder= */ false)
-                  .isEmpty()
-          ? FORMAT_UNSUPPORTED_DRM
-          : FORMAT_UNSUPPORTED_SUBTYPE;
+      return FORMAT_UNSUPPORTED_SUBTYPE;
     }
     if (!supportsFormatDrm) {
       return FORMAT_UNSUPPORTED_DRM;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
index 89c5dd6650..3b05bd1e41 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
@@ -291,10 +291,6 @@ private static boolean containsSchemeDataWithUuid(
     public final String mimeType;
     /** The initialization data. May be null for scheme support checks only. */
     public final @Nullable byte[] data;
-    /**
-     * Whether secure decryption is required.
-     */
-    public final boolean requiresSecureDecryption;
 
     /**
      * @param uuid The {@link UUID} of the DRM scheme, or {@link C#UUID_NIL} if the data is
@@ -303,19 +299,7 @@ private static boolean containsSchemeDataWithUuid(
      * @param data See {@link #data}.
      */
     public SchemeData(UUID uuid, String mimeType, @Nullable byte[] data) {
-      this(uuid, mimeType, data, false);
-    }
-
-    /**
-     * @param uuid The {@link UUID} of the DRM scheme, or {@link C#UUID_NIL} if the data is
-     *     universal (i.e. applies to all schemes).
-     * @param mimeType See {@link #mimeType}.
-     * @param data See {@link #data}.
-     * @param requiresSecureDecryption See {@link #requiresSecureDecryption}.
-     */
-    public SchemeData(
-        UUID uuid, String mimeType, @Nullable byte[] data, boolean requiresSecureDecryption) {
-      this(uuid, /* licenseServerUrl= */ null, mimeType, data, requiresSecureDecryption);
+      this(uuid, /* licenseServerUrl= */ null, mimeType, data);
     }
 
     /**
@@ -324,19 +308,13 @@ public SchemeData(
      * @param licenseServerUrl See {@link #licenseServerUrl}.
      * @param mimeType See {@link #mimeType}.
      * @param data See {@link #data}.
-     * @param requiresSecureDecryption See {@link #requiresSecureDecryption}.
      */
     public SchemeData(
-        UUID uuid,
-        @Nullable String licenseServerUrl,
-        String mimeType,
-        @Nullable byte[] data,
-        boolean requiresSecureDecryption) {
+        UUID uuid, @Nullable String licenseServerUrl, String mimeType, @Nullable byte[] data) {
       this.uuid = Assertions.checkNotNull(uuid);
       this.licenseServerUrl = licenseServerUrl;
       this.mimeType = Assertions.checkNotNull(mimeType);
       this.data = data;
-      this.requiresSecureDecryption = requiresSecureDecryption;
     }
 
     /* package */ SchemeData(Parcel in) {
@@ -344,7 +322,6 @@ public SchemeData(
       licenseServerUrl = in.readString();
       mimeType = Util.castNonNull(in.readString());
       data = in.createByteArray();
-      requiresSecureDecryption = in.readByte() != 0;
     }
 
     /**
@@ -381,7 +358,7 @@ public boolean hasData() {
      * @return The new instance.
      */
     public SchemeData copyWithData(@Nullable byte[] data) {
-      return new SchemeData(uuid, licenseServerUrl, mimeType, data, requiresSecureDecryption);
+      return new SchemeData(uuid, licenseServerUrl, mimeType, data);
     }
 
     @Override
@@ -425,7 +402,6 @@ public void writeToParcel(Parcel dest, int flags) {
       dest.writeString(licenseServerUrl);
       dest.writeString(mimeType);
       dest.writeByteArray(data);
-      dest.writeByte((byte) (requiresSecureDecryption ? 1 : 0));
     }
 
     public static final Parcelable.Creator<SchemeData> CREATOR =
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index 615aa0e7b1..848d9e146a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -242,8 +242,7 @@ private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas)
       for (int i = 0; i < schemeDatas.size(); i++) {
         SchemeData schemeData = schemeDatas.get(i);
         byte[] schemeDataData = Util.castNonNull(schemeData.data);
-        if (schemeData.requiresSecureDecryption == firstSchemeData.requiresSecureDecryption
-            && Util.areEqual(schemeData.mimeType, firstSchemeData.mimeType)
+        if (Util.areEqual(schemeData.mimeType, firstSchemeData.mimeType)
             && Util.areEqual(schemeData.licenseServerUrl, firstSchemeData.licenseServerUrl)
             && PsshAtomUtil.isPsshAtom(schemeDataData)) {
           concatenatedDataLength += schemeDataData.length;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 611a906a9b..fe9996bfc2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -298,29 +298,26 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
     if (!MimeTypes.isVideo(mimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
-    boolean requiresSecureDecryption = false;
     DrmInitData drmInitData = format.drmInitData;
-    if (drmInitData != null) {
-      for (int i = 0; i < drmInitData.schemeDataCount; i++) {
-        requiresSecureDecryption |= drmInitData.get(i).requiresSecureDecryption;
-      }
-    }
+    // Assume encrypted content requires secure decoders.
+    boolean requiresSecureDecryption = drmInitData != null;
     List<MediaCodecInfo> decoderInfos =
         getDecoderInfos(
             mediaCodecSelector,
             format,
             requiresSecureDecryption,
             /* requiresTunnelingDecoder= */ false);
+    if (requiresSecureDecryption && decoderInfos.isEmpty()) {
+      // No secure decoders are available. Fall back to non-secure decoders.
+      decoderInfos =
+          getDecoderInfos(
+              mediaCodecSelector,
+              format,
+              /* requiresSecureDecoder= */ false,
+              /* requiresTunnelingDecoder= */ false);
+    }
     if (decoderInfos.isEmpty()) {
-      return requiresSecureDecryption
-              && !getDecoderInfos(
-                      mediaCodecSelector,
-                      format,
-                      /* requiresSecureDecoder= */ false,
-                      /* requiresTunnelingDecoder= */ false)
-                  .isEmpty()
-          ? FORMAT_UNSUPPORTED_DRM
-          : FORMAT_UNSUPPORTED_SUBTYPE;
+      return FORMAT_UNSUPPORTED_SUBTYPE;
     }
     if (!supportsFormatDrm(drmSessionManager, drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 0e3c6a8bda..64ec1adb43 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -397,7 +397,6 @@ protected int getContentType(Format format) {
     String licenseServerUrl = null;
     byte[] data = null;
     UUID uuid = null;
-    boolean requiresSecureDecoder = false;
 
     String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
     if (schemeIdUri != null) {
@@ -431,9 +430,6 @@ protected int getContentType(Format format) {
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "ms:laurl")) {
         licenseServerUrl = xpp.getAttributeValue(null, "licenseUrl");
-      } else if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
-        String robustnessLevel = xpp.getAttributeValue(null, "robustness_level");
-        requiresSecureDecoder = robustnessLevel != null && robustnessLevel.startsWith("HW");
       } else if (data == null
           && XmlPullParserUtil.isStartTagIgnorePrefix(xpp, "pssh")
           && xpp.next() == XmlPullParser.TEXT) {
@@ -457,10 +453,7 @@ protected int getContentType(Format format) {
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "ContentProtection"));
     SchemeData schemeData =
-        uuid != null
-            ? new SchemeData(
-                uuid, licenseServerUrl, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder)
-            : null;
+        uuid != null ? new SchemeData(uuid, licenseServerUrl, MimeTypes.VIDEO_MP4, data) : null;
     return Pair.create(schemeType, schemeData);
   }
 
