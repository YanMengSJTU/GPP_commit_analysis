diff --git a/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
index 2f361c3cd4..153cc27cdc 100644
--- a/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
+++ b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer.ext.vp9.VpxDecoderException;
 import com.google.android.exoplayer.ext.vp9.VpxVideoSurfaceView;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.ogg.OggFlacExtractor;
 import com.google.android.exoplayer.extractor.webm.WebmExtractor;
 import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
@@ -141,7 +142,7 @@ private void startBasicPlayback() {
         contentUri,
         new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
         new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
-        new WebmExtractor(), new FlacExtractor());
+        new WebmExtractor(), new FlacExtractor(), new OggFlacExtractor());
     TrackRenderer videoRenderer =
         new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
     if (useOpenGL) {
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
index 7881b45ecd..a26d1910a1 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer.ext.flac;
 
 import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.FlacStreamInfo;
+import com.google.android.exoplayer.util.extensions.Buffer;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
 import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
@@ -75,6 +77,9 @@ protected void releaseOutputBuffer(FlacOutputBuffer buffer) {
 
   @Override
   public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
+    if (inputBuffer.getFlag(Buffer.FLAG_RESET)) {
+      decoder.flush();
+    }
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
     sampleHolder.data.limit(sampleHolder.data.position());
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
index 9fe76c3e71..83d29fa67a 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.FlacStreamInfo;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
index 1c26909c26..c7b066869c 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.FlacStreamInfo;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index e1b07e2162..c5710c52af 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -92,6 +92,7 @@
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean sourceIsReady;
+  private boolean notifyDiscontinuityToDecoder;
 
   private final AudioTrack audioTrack;
   private int audioSessionId;
@@ -261,6 +262,10 @@ private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
       inputStreamEnded = true;
       return false;
     }
+    if (notifyDiscontinuityToDecoder) {
+      notifyDiscontinuityToDecoder = false;
+      inputBuffer.setFlag(Buffer.FLAG_RESET);
+    }
 
     decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
@@ -274,6 +279,7 @@ private void flushDecoder() {
       outputBuffer = null;
     }
     decoder.flush();
+    notifyDiscontinuityToDecoder = true;
   }
 
   @Override
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index 7fe1887971..7b8cdf5bc9 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -89,7 +89,7 @@ FUNC(jobject, flacDecodeMetadata, jlong jContext) {
       context->parser->getStreamInfo();
 
   jclass cls = env->FindClass(
-      "com/google/android/exoplayer/ext/flac/"
+      "com/google/android/exoplayer/util/"
       "FlacStreamInfo");
   jmethodID constructor = env->GetMethodID(cls, "<init>", "(IIIIIIIJ)V");
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggFlacExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggFlacExtractorTest.java
new file mode 100644
index 0000000000..8859621615
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggFlacExtractorTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput.SimulatedIOException;
+import com.google.android.exoplayer.testutil.TestUtil;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+
+/**
+ * Unit test for {@link OggFlacExtractor}.
+ */
+public final class OggFlacExtractorTest extends TestCase {
+
+  private OggFlacExtractor extractor;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    extractor = new OggFlacExtractor();
+  }
+
+  public void testSniff() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x7F, 'F', 'L', 'A', 'C', ' ', ' '});
+    assertTrue(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsOpusFile() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x00),
+        new byte[]{'O', 'p', 'u', 's'});
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsInvalidOggHeader() throws Exception {
+    byte[] data = TestData.buildOggHeader(0x00, 0, 1000, 0x00);
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffInvalidFlacHeader() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x7F, 'X', 'o', 'r', 'b', 'i', 's'});
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsEOF() throws Exception {
+    byte[] data = TestData.buildOggHeader(0x02, 0, 1000, 0x00);
+    assertFalse(sniff(createInput(data)));
+  }
+
+  private static FakeExtractorInput createInput(byte[] data) {
+    return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
+        .setSimulateUnknownLength(true).setSimulatePartialReads(true).build();
+  }
+
+  private boolean sniff(FakeExtractorInput input) throws InterruptedException, IOException {
+    while (true) {
+      try {
+        return extractor.sniff(input);
+      } catch (SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggExtractor.java
new file mode 100644
index 0000000000..f3605b5990
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggExtractor.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Abstract Ogg {@link Extractor}.
+ */
+public abstract class OggExtractor implements Extractor {
+
+  protected final ParsableByteArray scratch = new ParsableByteArray(
+      new byte[OggReader.OGG_MAX_SEGMENT_SIZE * 255], 0);
+
+  protected final OggReader oggReader = new OggReader();
+
+  protected TrackOutput trackOutput;
+
+  protected ExtractorOutput extractorOutput;
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    try {
+      OggUtil.PageHeader header = new OggUtil.PageHeader();
+      if (!OggUtil.populatePageHeader(input, header, scratch, true)
+          || (header.type & 0x02) != 0x02 || header.bodySize < 7) {
+        return false;
+      }
+      scratch.reset();
+      input.peekFully(scratch.data, 0, 7);
+      return verifyBitstreamType();
+    } catch (ParserException e) {
+      // does not happen
+    } finally {
+      scratch.reset();
+    }
+    return false;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    trackOutput = output.track(0);
+    output.endTracks();
+    extractorOutput = output;
+  }
+
+  @Override
+  public void seek() {
+    oggReader.reset();
+    scratch.reset();
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  protected abstract boolean verifyBitstreamType() throws ParserException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggFlacExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggFlacExtractor.java
new file mode 100644
index 0000000000..57620d8a7d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggFlacExtractor.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.util.FlacSeekTable;
+import com.google.android.exoplayer.util.FlacStreamInfo;
+import com.google.android.exoplayer.util.FlacUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * {@link Extractor} to extract Flac data out of Ogg byte stream.
+ */
+public final class OggFlacExtractor extends OggExtractor {
+
+  private static final byte AUDIO_PACKET_TYPE = (byte) 0xFF;
+  private static final byte SEEKTABLE_PACKET_TYPE = 0x03;
+
+  private FlacStreamInfo streamInfo;
+
+  private FlacSeekTable seekTable;
+
+  private boolean firstAudioPacketProcessed;
+
+  @Override
+  public void init(ExtractorOutput output) {
+    super.init(output);
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    long position = input.getPosition();
+
+    if (!oggReader.readPacket(input, scratch)) {
+      return RESULT_END_OF_INPUT;
+    }
+
+    byte[] data = scratch.data;
+    if (streamInfo == null) {
+      streamInfo = new FlacStreamInfo(data, 17);
+
+      byte[] metadata = Arrays.copyOfRange(data, 9, scratch.limit());
+      metadata[4] = (byte) 0x80; // Set the last metadata block flag, ignore the other blocks
+      List<byte[]> initializationData = Collections.singletonList(metadata);
+
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_FLAC,
+          MediaFormat.NO_VALUE, streamInfo.bitRate(), streamInfo.durationUs(),
+          streamInfo.channels, streamInfo.sampleRate, initializationData, null);
+      trackOutput.format(mediaFormat);
+
+    } else if (data[0] == AUDIO_PACKET_TYPE) {
+      if (!firstAudioPacketProcessed) {
+        if (seekTable != null) {
+          extractorOutput.seekMap(seekTable.createSeekMap(position, streamInfo.sampleRate));
+          seekTable = null;
+        } else {
+          extractorOutput.seekMap(SeekMap.UNSEEKABLE);
+        }
+        firstAudioPacketProcessed = true;
+      }
+
+      trackOutput.sampleData(scratch, scratch.limit());
+      scratch.setPosition(0);
+      long timeUs = FlacUtil.extractSampleTimestamp(streamInfo, scratch);
+      trackOutput.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, scratch.limit(), 0, null);
+
+    } else if ((data[0] & 0x7F) == SEEKTABLE_PACKET_TYPE && seekTable == null) {
+      seekTable = FlacSeekTable.parseSeekTable(scratch);
+    }
+
+    scratch.reset();
+    return RESULT_CONTINUE;
+  }
+
+  @Override
+  protected boolean verifyBitstreamType() {
+    return scratch.readUnsignedByte() == 0x7F && // packet type
+        scratch.readUnsignedInt() == 0x464C4143; // ASCII signature "FLAC"
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
index 94124048ab..de8f5d37b7 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
@@ -20,10 +20,8 @@
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.extractor.ExtractorOutput;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
-import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.ogg.VorbisUtil.Mode;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
@@ -34,14 +32,8 @@
 /**
  * {@link Extractor} to extract Vorbis data out of Ogg byte stream.
  */
-public final class OggVorbisExtractor implements Extractor, SeekMap {
+public final class OggVorbisExtractor extends OggExtractor implements SeekMap {
 
-  private final ParsableByteArray scratch = new ParsableByteArray(
-      new byte[OggReader.OGG_MAX_SEGMENT_SIZE * 255], 0);
-
-  private final OggReader oggReader = new OggReader();
-
-  private TrackOutput trackOutput;
   private VorbisSetup vorbisSetup;
   private int previousPacketBlockSize;
   private long elapsedSamples;
@@ -50,7 +42,6 @@
   private final OggSeeker oggSeeker = new OggSeeker();
   private long targetGranule = -1;
 
-  private ExtractorOutput extractorOutput;
   private VorbisUtil.VorbisIdHeader vorbisIdHeader;
   private VorbisUtil.CommentHeader commentHeader;
   private long inputLength;
@@ -58,44 +49,12 @@
   private long totalSamples;
   private long duration;
 
-  @Override
-  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-    try {
-      OggUtil.PageHeader header = new OggUtil.PageHeader();
-      if (!OggUtil.populatePageHeader(input, header, scratch, true)
-          || (header.type & 0x02) != 0x02 || header.bodySize < 7) {
-        return false;
-      }
-      scratch.reset();
-      input.peekFully(scratch.data, 0, 7);
-      return VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, scratch, true);
-    } catch (ParserException e) {
-      // does not happen
-    } finally {
-      scratch.reset();
-    }
-    return false;
-  }
-
-  @Override
-  public void init(ExtractorOutput output) {
-    trackOutput = output.track(0);
-    output.endTracks();
-    extractorOutput = output;
-  }
-
   @Override
   public void seek() {
-    oggReader.reset();
+    super.seek();
     previousPacketBlockSize = 0;
     elapsedSamples = 0;
     seenFirstAudioPacket = false;
-    scratch.reset();
-  }
-
-  @Override
-  public void release() {
-    // Do nothing
   }
 
   @Override
@@ -254,6 +213,11 @@ public long getPosition(long timeUs) {
         / duration) - 4000);
   }
 
+  @Override
+  protected boolean verifyBitstreamType() throws ParserException {
+    return VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, scratch, true);
+  }
+
   /**
    * Class to hold all data read from Vorbis setup headers.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/util/FlacSeekTable.java b/library/src/main/java/com/google/android/exoplayer/util/FlacSeekTable.java
new file mode 100644
index 0000000000..5dbf0e2749
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/FlacSeekTable.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import com.google.android.exoplayer.extractor.SeekMap;
+
+/**
+ * FLAC seek table class
+ */
+public final class FlacSeekTable {
+
+  private static final int METADATA_LENGTH_OFFSET = 1;
+  private static final int SEEK_POINT_SIZE = 18;
+
+  private final long[] sampleNumbers;
+  private final long[] offsets;
+
+  /**
+   * Parses a FLAC file seek table metadata structure and creates a FlacSeekTable instance.
+   *
+   * @param data A ParsableByteArray including whole seek table metadata block. Its position should
+   *     be set to the beginning of the block.
+   * @return A FlacSeekTable instance keeping seek table data
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_seektable">FLAC format
+   *     METADATA_BLOCK_SEEKTABLE</a>
+   */
+  public static FlacSeekTable parseSeekTable(ParsableByteArray data) {
+    data.skipBytes(METADATA_LENGTH_OFFSET);
+    int length = data.readUnsignedInt24();
+    int numberOfSeekPoints = length / SEEK_POINT_SIZE;
+
+    long[] sampleNumbers = new long[numberOfSeekPoints];
+    long[] offsets = new long[numberOfSeekPoints];
+
+    for (int i = 0; i < numberOfSeekPoints; i++) {
+      sampleNumbers[i] = data.readLong();
+      offsets[i] = data.readLong();
+      data.skipBytes(2); // Skip "Number of samples in the target frame."
+    }
+
+    return new FlacSeekTable(sampleNumbers, offsets);
+  }
+
+  private FlacSeekTable(long[] sampleNumbers, long[] offsets) {
+    this.sampleNumbers = sampleNumbers;
+    this.offsets = offsets;
+  }
+
+  /**
+   * Creates a {@link SeekMap} wrapper for this FlacSeekTable.
+   *
+   * @param firstFrameOffset Offset of the first FLAC frame
+   * @param sampleRate Sample rate of the FLAC file.
+   * @return A SeekMap wrapper for this FlacSeekTable.
+   */
+  public SeekMap createSeekMap(final long firstFrameOffset, final long sampleRate) {
+    return new SeekMap() {
+      @Override
+      public boolean isSeekable() {
+        return true;
+      }
+
+      @Override
+      public long getPosition(long timeUs) {
+        long sample = (timeUs * sampleRate) / 1000000L;
+
+        int index = Util.binarySearchFloor(sampleNumbers, sample, true, true);
+        return firstFrameOffset + offsets[index];
+      }
+    };
+  }
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java b/library/src/main/java/com/google/android/exoplayer/util/FlacStreamInfo.java
similarity index 60%
rename from extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
rename to library/src/main/java/com/google/android/exoplayer/util/FlacStreamInfo.java
index 8de58f7993..0f75c8032e 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/FlacStreamInfo.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.ext.flac;
+package com.google.android.exoplayer.util;
 
 /**
- * Holder for flac stream info.
+ * Holder for FLAC stream info.
  */
-/* package */ final class FlacStreamInfo {
+public final class FlacStreamInfo {
+
   public final int minBlockSize;
   public final int maxBlockSize;
   public final int minFrameSize;
@@ -28,6 +29,28 @@
   public final int bitsPerSample;
   public final long totalSamples;
 
+  /**
+   * Constructs a FlacStreamInfo parsing the given binary FLAC stream info metadata structure.
+   *
+   * @param data An array holding FLAC stream info metadata structure
+   * @param offset Offset of the structure in the array
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_streaminfo">FLAC format
+   *     METADATA_BLOCK_STREAMINFO</a>
+   */
+  public FlacStreamInfo(byte[] data, int offset) {
+    ParsableBitArray scratch = new ParsableBitArray(data);
+    scratch.setPosition(offset * 8);
+    this.minBlockSize = scratch.readBits(16);
+    this.maxBlockSize = scratch.readBits(16);
+    this.minFrameSize = scratch.readBits(24);
+    this.maxFrameSize = scratch.readBits(24);
+    this.sampleRate = scratch.readBits(20);
+    this.channels = scratch.readBits(3) + 1;
+    this.bitsPerSample = scratch.readBits(5) + 1;
+    this.totalSamples = scratch.readBits(36);
+    // Remaining 16 bytes is md5 value
+  }
+
   public FlacStreamInfo(int minBlockSize, int maxBlockSize, int minFrameSize, int maxFrameSize,
       int sampleRate, int channels, int bitsPerSample, long totalSamples) {
     this.minBlockSize = minBlockSize;
@@ -51,4 +74,5 @@ public int bitRate() {
   public long durationUs() {
     return (totalSamples * 1000000L) / sampleRate;
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/FlacUtil.java b/library/src/main/java/com/google/android/exoplayer/util/FlacUtil.java
new file mode 100644
index 0000000000..1999be7b5f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/FlacUtil.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+/**
+ * Utility functions for FLAC
+ */
+public final class FlacUtil {
+
+  private static final int FRAME_HEADER_SAMPLE_NUMBER_OFFSET = 4;
+
+  /**
+   * Prevents initialization.
+   */
+  private FlacUtil() {
+  }
+
+  /**
+   * Extracts sample timestamp from the given binary FLAC frame header data structure.
+   *
+   * @param streamInfo A {@link FlacStreamInfo} instance
+   * @param frameData A {@link ParsableByteArray} including binary FLAC frame header data structure.
+   *     Its position should be set to the beginning of the structure.
+   * @return Sample timestamp
+   * @see <a href="https://xiph.org/flac/format.html#frame_header">FLAC format FRAME_HEADER</a>
+   */
+  public static long extractSampleTimestamp(FlacStreamInfo streamInfo,
+      ParsableByteArray frameData) {
+    frameData.skipBytes(FRAME_HEADER_SAMPLE_NUMBER_OFFSET);
+    long sampleNumber = frameData.readUTF8EncodedLong();
+    if (streamInfo.minBlockSize == streamInfo.maxBlockSize) {
+      // if fixed block size then sampleNumber is frame number
+      sampleNumber *= streamInfo.minBlockSize;
+    }
+    return (sampleNumber * 1000000L) / streamInfo.sampleRate;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index f54de76066..b95ba70e64 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -391,4 +391,38 @@ public String readLine() {
     return line;
   }
 
+  /**
+   * Reads a long value encoded by UTF-8 encoding
+   * @throws NumberFormatException if there is a problem with decoding
+   * @return Decoded long value
+   */
+  public long readUTF8EncodedLong() {
+    int length = 0;
+    long value = data[position];
+    // find the high most 0 bit
+    for (int j = 7; j >= 0; j--) {
+      if ((value & (1 << j)) == 0) {
+        if (j < 6) {
+          value &= (1 << j) - 1;
+          length = 7 - j;
+        } else if (j == 7) {
+          length = 1;
+        }
+        break;
+      }
+    }
+    if (length == 0) {
+      throw new NumberFormatException("Invalid UTF-8 sequence first byte: " + value);
+    }
+    for (int i = 1; i < length; i++) {
+      int x = data[position + i];
+      if ((x & 0xC0) != 0x80) { // if the high most 0 bit not 7th
+        throw new NumberFormatException("Invalid UTF-8 sequence continuation byte: " + value);
+      }
+      value = (value << 6) | (x & 0x3F);
+    }
+    position += length;
+    return value;
+  }
+
 }
